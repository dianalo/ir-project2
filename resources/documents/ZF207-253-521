<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-253-521  </DOCNO><DOCID>07 253 521.andM;</DOCID><JOURNAL>Dr. Dobb's Journal of Software Tools  Jan 1989 v14 n1 p111(7)* Full Text COPYRIGHT Mandamp;T Publishing Inc. 1989.andM;</JOURNAL><TITLE>C programming; the surrogate library.andO;</TITLE><AUTHOR>Stevens, Al.andM;</AUTHOR><SUMMARY>A small library of Microsoft C routines are provided as surrogatesfor functions that are being developed as part of a Turbo Cprogramming project.andP;  The Turbo C project is not specificallydescribed, but most of its C programming is not specific to TurboC. Rather, it is generic to PC implementations of C and viable inMicrosoft C. The Turbo C-specific functions and internalconstructs used all relate to screen management.andP;  The Microsoft Croutines consist of three source files and a make file.andP;  The mostimportant one is the microsft.c file which provides the surrogatefunctions that emulate the Turbo C screen management routines.andO;The new functions were tested with versions 5.0 and 5.1 ofMicrosoft C.andM;</SUMMARY><DESCRIPT>Topic:     TutorialSubroutinesVideo DisplayC Programming LanguageCode ConversionProgramsProgram Libraries.andO;Feature:   illustrationprogram.andO;Caption:   Surrogate Turbo C functions. (program)andM;</DESCRIPT><TEXT>C PROGRAMMING The Surrogate LibraryandM;Several readers have asked why I selected Turbo C for the &quot;C Programming&quot;column project.andP;  Many of you use other compilers, and some of you feel leftout.andP;  One such reader goes so far as to say that the next several issues ofDDJ will be useless to him, and he will likely allow his subscription toexpire.andP;  That got my attention.andM;All this distress is because the programs being discussed are written withthe specific screen management functions of Turbo C. This particular readerfelt that the column should restrict itself to generic ANSI C wheneverpossible to reach the widest possible audience.andP;  That argument has merit, andI do not want to lose readers, particularly those who care enough to tell mewhen things are not right.andP;  I must, therefore, deal with this concern.andM;First, let's consider why generic C is not practical for this project.andP;  Theprogram uses our own home-grown video windows on the IBM PC and compatibles.andO;Such a program must, if performance is to be considered, directly addressvideo memory.andP;  The program will also use the PC's serial port.andP;  Theserequirements bind the program to the PC hardware architecture.andP;  Of course,most of the many C compilers for the PC could be used to develop such aprogram, and each such program would be somewhat different from the others.andO;The methods that you use for low-level hardware access are different enoughwith each compiler that different programs will result.andP;  Perhaps a needexists for a standard library for MS-DOS PC programs, but no such standard isin acceptance.andP;  Some compilers attempt to be compatible with others, butthese attempts fall apart when the compiler developers are working on similarextensions at the same time.andP;  Witness the different approaches to graphicslibraries in Turbo C and Microsoft C.andM;The news, however, is not all bad.andP;  A relatively small amount of the code inour project is specific to and dependent upon Turbo C. All such code is inthe area of screen management, and is represented by a set of Turbo Cfunctions and a few internal Turbo C constructs.andP;  Most of the rest of thecode is generic at least at the PC level.andP;  Microsoft C and Turbo C do a lotof things the same way.andP;  Remember, however, that the underlying theory thatapplies to our video windows is based on the PC's video architecture; thefunctions that we are developing are for the PC with MS-DOS.andP;  They are notCP/M, Unix, or VAX/VMS programs, for example.andP;  This fact could give rise to anew uproar, and I reluctantly wait for that heat and will try bravely to bearup under it.andM;Why did I chose Turbo C?andP;  The answer is simple: Turbo C is the compiler I usefor nearly everything else in MS-DOS.andP;  That is not so much an endorsement asa mere fact.andP;  I use Turbo C because it has excellent support for the kind ofprograms I write: TSRs and programs with video windows.andP;  Microsoft C has somesupport for those areas, but not as much ad Turbo C.andM;I might have selected Microsoft C for the project, in which case I would beaddressing this same discourse to the users of all the other compilers.andP;  Ilike Microsoft C.andP;  Recently my work has extended into the OS/2 arena, andthat venture has me using Microsoft C once again.andP;  All that great Turbo Csupport does not apply to OS/2.andP;  First, Turbo C does not come in an OS/2flavor.andP;  Second, one does not write the same kind of TSRs for OS/2 that onewrites for MS-DOS.andP;  Third, one does not do windows in OS/2; that will be thedomain of screen groups and the Presentation Manager, like it or not.andM;THE TC to MSCandM;Surrogate LibraryandM;What good does all this rationalization do for those of you dear readers whodo not use Turbo C and who want to use the code in the &quot;C Programming&quot;column?andP;  None, unfortunately, and that is something I intend to partiallyrectify in this column.andP;  This month I will provide a library of Microsoft Cfunctions and macros that turn the &quot;C programming&quot; project into a MicrosoftC-compatible program.andP;  The library will mirror those Turbo C-specificfunctions that I have used so that you can compile the project's functionswith Microsoft C.andP;  In subsequent months I will add to this library (if needbe).andM;How about the other compilers?andP;  At last count there were countless otherMS-DOS C compilers.andP;  Lattice, Aztec, Watcom, Zortech, MIX, High C,Whitesmith's, Mark Williams, De Smet, QC88, Small C, Eco-C, are all namesthat come to mind.andP;  At one time or another, I have used each of them.andP;  I donot, however, intend to provide a compiler-independent program here.andP;  I willdescribe the Turbo C functions that must be emulated for Microsoft C, and Iwill provide the source code for that purpose.andP;  Users of those other finecompilers may use my example to build their own libraries.andP;  I am doing it forMicrosoft C because that will satisfy the largest base of readers, and thatwheel is squeaking rather prominently just now, thus getting the grease.andP;  Totake this same side trip for all those compilers would use my alloted spacein DDJ for about the next year, and we wouldn't get anything else done.andM;This library development is not a big effort as you will see, but I doencourage anyone who builds one for another compiler to send the code in;we'll post it on CompuServe in the DDJ Forum.andP;  but let me caution you.andP;  Inthe past I wrote and marketed a library of C functions, and I distributedversions that worked with most of those compilers.andP;  It was a frustratingexperience.andP;  The effort required to keep up with the latest versions of thecompilers was significant.andP;  The targets would never hold still.andP;  Eventually Isurrendered and distributed only source code.andP;  The source code was a melangeof compile-time conditionals that managed the difference between compilersand, in doing so, obscured the original meaning of the code.andP;  Such a mess ismarginally acceptable in a commercial product, but it should never be seen ina published work where the purpose is as much to inform as to perform.andM;I built these surrogate functions and tested them with Microsoft C, Versions5.0 and 5.1.andP;  I tried to get them running with QuickC as well, but thewindow.c file causes as internal QuickCompiler error.andP;  I recompiled just thatmodule with Microsft C, linked it with the rest of the program as compiledwith QuickC, and everything worked.andP;  A more recent version of QuickC mightnot have this problem, but I have only the first version.andM;The library consists of three source files and a make file.andP;  The source filesare microsft.h (see Listing One, page 129), microsft.c (Listing Two, page129), and vpeek.asm (List Three, page 131).andP;  The make file is twrp.mak(Listing Four on page 132).andP;  The make file uses these new functions to buildlast month's TWRP tiny work processor with Microsot C.andP;  The microsft.h fileis intended to b appended to or included in the window.h file from mySeptember column.andP;  The microsoft.c file provides the surrogate functions thatemulate those features of the project that depend on things unique to TurboC.andM;These emulations are not comprehensive--some of them will not work as Turbo Csubstitutes for everything you might do.andP;  Rather, they provide sufficientsupport for the ways we used those functions in the &quot;C Programming&quot; projectso far.andP;  For this reason I call them surrogates rather than clones.andO;Naturally, as I add to the project, I will verify tha all the new code workswith both compilers, and I will update this library if necessary.andP;  If youwant a comprehensive cross-compiler library, you might try buying the Turbo Cruntime library source code and compiling the pertinent functions withMicrosft C.andP;  Such an ambitious endeavor is beyond the scope of this column.andO;I need say no more than that it would be a significant effort, fraught willperil.andM;Following is a discussion of each component of the library.andM;microsft.h -- The microsft.h file is meant to be appended to or included inwindow.h from September.andP;  You must make one change to window.h to accommodatedifferences between the two compilers' treatments of prototypes.andP;  In window.hon about line 9 you will see this prototype: in select_window(int,int,int,int(*func)(int,int)); You must change it to the following: intselect_window(int,int,int,int (*)(int,int));andM;Microsoft C does not allow you to mix named and unnamed parameters in aprototype while Turbo C does not seem to mind.andM;The microsft.h file begins with a test of the COMPILER compile-timeconditional flag.andP;  This flag is defined by the compile statement in the makefile, and it tells the compiler to use the code inserted from microsft.h.andP;  Myobjective was to minimize changes to code already published.andM;The #define statements for movmem and setmem substitue the names ofappropriate MSC functions.andM;The setmem function sets all the bytes in a buffer to a specified charactervalue.andP;  The first parameter is a character value.andP;  The first parameter is acharacter pointer that points to the buffer.andP;  The second parameter is thebuffer's size in bytes.andP;  The third parameter is the character value to befilled into the buffer.andP;  The corresponding Microsoft C function is memset.andO;Its parameters are in a different sequence than those of Turbo C's setmem.andM;The movmem function takes three parameters: a source character pointer, adestination character pointer, and a byte count.andP;  The function moves a blockof memory and accounts for overlapping source and destination blocks, movingfrom the correct end of the buffer to prevent byte replication.andP;  Thecorresponding Microsoft C function is memmove.andP;  Its parameters are in adifferent sequence than those of movmem.andP;  Note that Microsoft C has a movmemfunction that resembles Turbo C's movmem, but it does not correct foroverlapping buffers and cannot be used here.andM;The #define statements for cprintf, cputs, getch, and putch substitute thenames of functions in microsft.c for these names.andP;  both Turbo C and MSC havefunctions with these names, but their behaviors are different enough that wemust make substitutions.andM;Next come the prototypes for the functions of TC that MSC does not have.andO;After that are #define statements for the screen colors.andM;microsft.c--This file has the functions that emulate the Turbo Cfunctions--the Turbo surrogate.andP;  It starts with some #includes andprototypes.andP;  The vpeek and vpoke prototypes are for the functions invpeek.asm, which read and write video memory compensating for video snow.andP;  Ifyour system does not use the color graphics adaptor (CGA), you do not needthe assembly language functions.andM;The compile-time global symbol, ADAPTOR, specifies the video adaptor yourprogram uses, and the VSEG symbol is automatically equated to the segmentaddress of display refresh memory, which is 0xb000 for the monochrome displayadaptor and 0xb800 for the others.andP;  The SNOW symbol is set to 0 if theadaptor does not generate video snow when video memory is accessed.andO;Otherwise it is set to 1.andP;  If you use an adaptor other than the CGA, you canremove the references to vpeek.asm and vpeek.obj from Listing Four, twrp.andO;mak.andM;With Turbo C the tests for the video segment and snow are made at run time bythe compiled code and are not visible to you.andP;  for this subset emulation,however, you must specify the video adaptor when you compile the program.andO;This is consistent with the philosophy of this program where configurationitems are controlled by compiled #define control statements.andM;The video structure is a duplicate of an external structure that is internalto Turbo C and that is referenced in window.c.andP;  We declare it here becauseMicrosoft C has no such structure.andP;  By maintaining the values that oursoftware uses, we can make the program react just as it does when the Turbo Crun-time library (RTL) is running things.andM;The window function is used to establish a rectangle of memory as the currentvideo window.andP;  Its integer parameters are the left, top, right, and bottomscreen coordinates where the upper left screen coordinates is row 1, column1, and the lower right coordinate is row 25, column 80.andM;The _vptr function returns a far pointer to video memory based on the x and ycoordinates passed to it.andP;  This is an emulation of an external Turbo Cfunction that is normally only called from within the Turbo c run-timelibrary but that we used in window .c.andP;  You'll recall that I chastised myselffor using it.andP;  Now I pay.andM;The _vram function writes a linear block of program memory to video memory.andO;Its parameters are a far pointer to the start of the video memory location, afar pointer to the program memory buffer, and number of 2-byte integers towrite.andP;  Video memory consists of 2 bytes--a video attribute and an  ASCIIcharacter--for each screen character position.andP;  This function is also anemulation of one that is normally only called from the TC RTL.andP;  We used it inwindow .c to effect a smooth write to the screen without the annoyance of acursor flash across the write such as you see when you use cprintf and cputs.andM;The _getvram function is the reverse of _vram.andP;  It reads rather than writesvideo memory.andP;  This function is not an emulation, but one that we need forthe gettext function described below.andP;  In Turbo C, the _vram function managesvideo memory moves in both directions by using the segment addresses todetermine if the source or destination is the video RAM.andP;  Rather than go tothat trouble, I coded a simple _vram and then added _getvram as a reciprocalof _vram.andM;The gettext and puttext functions are higher-level read and write videomemory functions.andP;  They deal with linear buffers of program memory andrectangular windows of video memory.andP;  They are used to save and restore thevideo space that our windows occupy.andP;  The coordinates (left, top, right,bottom) are relative to the full screen and begin with 1,1 at the top left.andO;The movetext function moves a video window.andP;  We use it for window scrolling,so this emulated function works with vertical movements only.andP;  The Turbo Cmovetext function  is a lot smarter, being able to move a window from and toany screen positions.andP;  The arguments to movetext are the four cornercoordinates of the original window (relative to the full screen) and theupper left coordinates of where it is to be moved.andP;  If you are using the CGA,you can eliminate movetext because we used BIOS to scroll CGA screens forperformance reasons.andP;  To avoid changing the scroll function in window .C, puta null function named movetext in microsoft.C in place of the one given here.andM;The gotoxy function positions the cursor at a location in the current window(the one most recently defined by the window function) as specified by the xand y parameters.andP;  These parameters are relative to the window, with 1,1being the upper left corner of the window.andM;The wherex and wherey functions return the current cursor x and y positionsrelative to the current window.andM;The textcolor and textbackground functions set the colors that will be usedthe next time a text display is written.andP;  Their parameters are integer valuesas defined in microsoft.h.andM;The uprintf function is substituted for cprintf.andP;  Both compilers have cprintffunctions that are similar, but they are both related to their own internaltext display processes.andP;  The cprintf macro in microsoft.h replaces calls tocprintf with ones to uprintf.andP;  This new function makes a simple translationusing the vsprintf function of Microsoft C.andP;  The resulting string is thencopied to video memory based on the current cursor position.andP;  Note that thissurrogate function does not attempt to deal with control characters such as\n and \r.andP;  This omission is because we never use such controls in our callsto cprintf.andP;  I hope I do not regret this shortcut later.andM;We have substituted ugetch and uputch for getch and putch because theexisting Microsoft C functions do not work in the context in which we areusing them.andM;vpeek.asm--The upeek function has two unsigned parameters.andP;  The first is thesegment address of video memory (always the value #defined as VSEG) and thesecond is the video offset address.andP;  The function returns the 2-byte value inthe video memory address.andP;  Before accessing video RAM, upeek waits for avideo retrace cycle to avoid the snow-causing memory access conflict betweenthe CPU and the video controller.andM;The upoke function inserts a 2-byte value into a video memory location withthe same snow-eliminating routine as vpeek.andP;  It has the same two video memoryaddress parameters as vpeek.andP;  Its third parameter is the two-byte word to beinserted into video memory.andM;Header FilesandM;Turbo C and Microsoft C define their function prototypes in header files inmostly the same way.andP;  The same header files define the same ANSI standardfunctions.andP;  There are two minor differences, however.andP;  Turbo C defines allthe memory allocation functions in alloc.h and Microsoft C uses malloc.h.andO;Turbo C uses mem.h for prototypes of functions similar to those thatMicrosoft C puts in memory.h.andP;  To get around this problem, you can putsurrogate alloc.h and mem.h files in with your Microsoft C header files.andP;  Thealloc.h files should simply #include malloc.h.andP;  The mem.h will #includememory.h.andP;  I have not included listings of these one-liners.andM;A C Crotchet: The ANSI GotchaandM;In its goal to specify a standard C language that is all things to allcomputers, the ANSI X3J11 committee has faced some thorny problems.andP;  Theirsolutions do not always provide the best answer for everyone.andP;  Once upon atime, if you coded this statement: char cp []=&quot;\00123&quot;; you got a characterarray of four characters initialized with three characters and a nullterminator.andP;  The first character was the binary value 001 as specified by thebacklash octal sequence.andP;  The next two characters were the ASCII values '2'and '3'.andM;The draft ANSI specification says that since some computers have charactersizes of greater than eight bits, the backlash sequence must allow for morethan three digits.andP;  Therefore, the statement will now declare a two-characterarray with the octal value 123 (hex 53) followed by the null terminator.andP;  Thecompiler's scan of digits to form an integral value continues as long as thecompiler sees octal digits.andM;Existing code can get broken by compilers that comply, particularly if thearray is compiled without warning messages.andP;  ANSI makes no provision for theprotection of existing code with the changes brought about by this new rule.andO;This discussion is, therefore, aimed at those who might be changing to anANSI-compilant compiler.andP;  Eventually that will include all of us.andP;  This willbe part of the future ANSI legacy, but let's see how it is effecting some ofus right now.andM;Borland decided to comply with this new rule of the standard in Turbo C 2.0.andO;This decision, I am told, was based on Borland's commitment to fullcompliance with the ANSI standard.andP;  That position is hard to argue with evenwhen the consequences seem dire.andP;  Allow me to try.andM;When programmers complained that this new rule was breaking existing code,they were offered a workaround: Use the ANSI string concatenation feature,which works like this: char*cp=&quot;\001&quot; &quot;23&quot;;andM;This, of course, is a workaround for developers of new code and does notaddress the problem faced by those who compile large systems of existingcode.andP;  ANSI addressed this rule to solve portability issues.andP;  Some machineshave 6-bit characters, some have 8, some have 12.andP;  Traditionally, when aprogrammer ported C code to a new machine, this was one of the portabilityconsiderations.andP;  Now, however, the new ANSI rule -- or more specifically, theBorland compliance with it -- gives us an unexpected portability issue and anunwanted surprise.andP;  Programs that compiled correctly one way for year --including with Turbo C 1.5 -- are now not portable to Turbo C 2.0, and thecompiler issues no warning and provides no way to turn off the new rule.andM;The only error message associated with the original format occurs whencoincidental octal digits following the octal constant happen to form anintegral value greater than 255.andP;  So if the initializer contains &quot;\00377&quot;,the compiler says your code is correct but compiles something other than whatten years of tradition have conditioned us to expect.andP;  If, however, thestring is &quot;\00400&quot; you get a compile error.andP;  In the latter circumstance youcan do something about it.andP;  In the former, you have no clue that something isamiss until the program stops working.andM;In my opinion, a compiler should issue a warning when it deviates fromtradition in the name of ANSI.andP;  The warning could be turned off by those whodo not need or want to see it.andM;Perhaps compilers for computers with 8-bit characters should ignore the newrule.andP;  I doubt that many users would complain.andP;  That's right, your DDJCcolumnist advocates nonviolent civil disobedience sometimes.andP;  As Paul Newmansaid in the movie Hud, &quot;I've always believed in being lenient with the law.andO;Sometimes I lean one way, Sometimes I lean the other.&quot;andM;Most PC programs, however, are written to execute from inside a userinterface that is tightly bound to the architecture of the PC.andP;  Our &quot;CProgramming&quot; column project is an example of such a program.andP;  The vastmajority of programs written in Turbo C will never be ported anywhere otherthan to the next improved edition of Turbo C. I would guess that if Borlandwere to offer an ANSI-only version of the compiler, there would be fewtakers.andM;Borland's official position on this issue is that the compiler exhibitscorrect ANSI behavior, and is, therefore, correct.andP;  On the other hand,Borland is a company that listens to its users.andP;  If enough of you say thatyou need something changed, they will change it.andP;  I say we need a warningmessage.andM;Since version 1.0, I have recommended Turbo C without hesitation.andP;  Until thisproblem is addressed, however, I suggest caution if Turbo C 2.0 is to be usedin projects that involve large helpings of existing code.andP;  Fortunately, TurboC 1.5, Microsoft C 5.1, and other compilers have not adopted this rule, soyou have reasonable alternatives to Turbo C 2.0 if this new rule will be aproblem.andM;Other Turbo C 2.0 OfferingsandM;Turbo C 2.0 has a bounty of new features.andP;  Most notable is the long-awaitedintegrated debugger in the environment.andP;  Borland now markets a standaloneTurbo Debugger as well, and Turbo C programs can be debugged with it, too.andO;If you get the Turbo C Professional package, you get Turbo C 2.0, the TurboDebugger, and the new Turbo Assembler.andP;  Also included are the linker,librarian, make utility, grep, and a host of other programmer's utilityprograms.andP;  All that is missing is a multi-window, programmable programmer'seditor in the class of Brief or the Microsoft Editor.andM;One new feature of Turbo C 2.0 is a mixed blessing.andP;  Each object file isencoded with the paths and names of the #include file that went into itscompilation.andP;  The Project Make facility has an option called &quot;Autodependencies.&quot;andP;  When this option is on, the make process checks the dates ofthe files that were included against the date of the object file.andP;  This isuseful in projects where the project make files might not be current.andP;  Withthis feature you can get pretty sloppy about keeping the project make file upto date.andM;Why a mixed blessing?andP;  The embedded file names can increase the size of theobject file significantly.andP;  One developer found that his commercial librarynow required additional diskettes.andP;  There is an undocumented TLIB switch (/0)for eliminating these strings.andP;  My sources say that Borland will post autility to strip the path names from object files and that the text releaseof Tubo C will include a switch to suppress them.andP;  Now that I have them,though, I cannot do without them.andP;  I would like to see them used by thecommand line MAKE utility program.andM;Bugs in the version 1.5 cprintf and cputs functions were fixed in version2.0.andP;  What's that, you didn't know those functions were broken?andP;  Then you,like I, did not read the documentation, which has always said that cprintfand cputs do not expand the newline into a carriage return, line feed.andO;That's what the documentation said, but in TC 1.5, the new-line was expanded.andO;In 2.0 you need to code \r\n to get the same effect you got with \n before.andO;This keeps the compiler in synch with its documentation and also withMicrosoft C. TC will need to stay close to MSC with many such functions ifthey intend to get into the OS/2 game.andP;  Many programmers used Cprintf the wayit worked rather than how it was described and are not pleased with thechange.andM;Coming up ...andM;Next month we get on with the project.andP;  We'll discuss the weighty subject ofasynchronous communication and add serial port and modern functions to ourlibrary.andO;</TEXT></DOC>