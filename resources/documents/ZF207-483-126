<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-483-126  </DOCNO><DOCID>07 483 126.andM;</DOCID><JOURNAL>Lotus  August 1989 v5 n8 p24(3)* Full Text COPYRIGHT Lotus Publishing Corporation 1989.andM;</JOURNAL><TITLE>Capture those keystrokes. (includes related article on the &quot;GET&quot;command) (1-2-3 Macros) (column)</TITLE><AUTHOR>Gasteiger, Daniel.andM;</AUTHOR><SUMMARY>Several Lotus 1-2-3 macros that capture and interpret keystrokesare detailed.andP;  The macros can either ignore, use or perform aprogrammed task on the keystrokes.andP;  A data-entry example isillustrated in which a macro is used to reduce repetitive typingand control cell-pointer movement.andP;  The same example furnishesanother macro that keeps the cell pointer from moving and allowsthe user to select between two options for data entry.andP;  If a macrocontains more than 100 IF commands, it is too large to beefficient.andP;  A keystroke-translation table is useful whenredefining many keys.andP;  Step-by-step example of a macro using sucha table is provided.andM;</SUMMARY><DESCRIPT>Product:   Lotus 1-2-3 (Spreadsheet software) (usage).andO;Topic:     MacrosTutorialSpreadsheetsProgramming Instruction.andM;</DESCRIPT><TEXT>CAPTURE THOSE KEYSTROKESandM;There are times when you want a 1-2-3 macro to let users press certain keysbut not others.andP;  For example, your macro might let someone move the cellpointer around in the worksheet but not make any changes.andP;  Or a macro mightlet someone select certain menu items but not others.andP;  A macro can accomplishthese feats by capturing the user's keystrokes.andM;The checkbook-register macro that appeared in the June column captureskeystrokes to simplify a rather tedious chore.andP;  A 1-2-3 macro that ran in theDecember 1986 column captures keystrokes and records them so that you' can&quot;play them back&quot; as a macro later on.andP;  Chances are, once you know how a macrocaptures keystrokes, you'll discover several opportunities to apply thetechnique to your own applications.andM;A SIMPLE SCENARIOandM;A keystroke-capturing macro routine intercepts every keystroke issued at thekeyboard.andP;  The macro then decides whether to ignore the keystroke, to use thekeystroke as it is, or to perform some programmed task associated with thekeystroke.andP;  Using a keystroke-capturing routine, you can redefine the effectof every key on your keyboard.andM;Suppose you're creating a data-entry routine and one of the items to entercomes from a list of only a few possible selections.andP;  Because you haveseveral tens or hundreds of entries to make, you'll type the same words againand again as you work through the database.andP;  However, if your data-entryprocedure is macro-controlled, you can use a keystroke-capturing routine toreduce the repetitious typing.andM;The macro in the illustration on this page is a simplification of thisdata-entry scenario.andP;  To create the worksheet, enter labels as shown.andO;Remember to begin with an apostrophe when you enter the label in cell A5.andO;Use the Range Name LAbels Right command to assign the labels in column A asrange names for the adjacent cells of column B.andP;  Also use the Range NameCreate command to assign the name list to range F1..F4.andM;This macro helps you to enter data in the cell named choice (B1).andP;  Imaginethat this macro is one routine taken from a much larger macro and that choiceis just one of several cells into which you enter data.andP;  The other cellsmight receive values, customer names, dates, and so on; but choice cancontain only one of the labels shown in range F1..F4 of the illustration.andM;To see the macro in action, hold down the MACRO key (Alt on most computers)and press I.andP;  The cell pointer jumps to the first cell in the range namedlist (cell F1).andM;Move the cell pointer down through the list by pressing the DownArrow key.andO;Move the cell pointer up by pressing UpArrow.andP;  Notice that when the cellpointer is in the list's bottommost cell, pressing DownArrow has no effect.andO;Likewise, when the cell pointer is in the uppermost cell of list, pressingUpArrow has no effect.andM;When the pointer highlights the entry you wish to enter in choice, pressReturn.andP;  The cell pointer jumps to choice and enters the selected entry.andO;Here's how the macro works:andM;[GOTO]list [is approx.] moves the cell pointer to the first cell of the rangenamed list.andM;[GET key] causes the macro to pause until you press a key, then stores alabel representation of the keystroke in the cell name key.andP;  See the box fora short discussion of the [GET] command.andM;[IF key=&quot;[UP]&quot;][uprt] calls the subroutine named uprt if the label in key is[UP].andP;  The label in key will be [UP] only if the last key you pressed was theUpArrow key.andP;  The uprt routine moves the cell pointer up if the row number ofthe cell holding the pointer is greater than the first row of the range namedlist.andP;  In other words, the uprt routine moves the cell pointer up only if thepointer isn't already at the top of the list of choices.andM;[IF key=&quot;[DOWN]&quot;][dnrt] calls the subroutine named dnrt if the label in keyis [DOWN].andP;  This will be the case only if the last key you pressed was theDownArrow key.andP;  The dnrt routine moves the cell pointer down only if thepointer's current row number is less than the last row of list.andP;  Therefore,the dnrt routine moves the cell pointer down unless the pointer is already onthe last entry in the list of choices.andM;[IF key=&quot;[is approx.]&quot;][BRANCH copy] transfers macro control to the cellnamed copy if key contains a tilde.andP;  Key will contain a tilde if the last keyyou pressed was the Return key.andP;  The commands starting in copy assign thevalue from the current cell to the cell named choice.andP;  Then they move thecell pointer to choice, and the macro ends.andM;[BRANCH loop] transfers macro control to the cell named loop--the second cellof the macro.andP;  1-2-3 processes this command whether you've pressed UpArrow,DownArrow, or any key other than Return.andP;  By branching to the original [GET]command, the macro prepares to intercept your next keystroke.andP;  This loopingcontinues until you press the Return key.andM;ENTRY TOGGLEandM;The previous macro demonstrates how to capture keystrokes to controlcell-pointer movement.andP;  There are times when you might not want the cellpointer to move at all but you do want to offer some options to the user.andM;For example, suppose that during a data-entry macro, the cell pointer comesto rest in a cell that can contain one of two keywords.andP;  Again, rather thanhave to type one keyword or the other, it's nice to have the macro providethe user with the possible options.andP;  The macro routine in the illustrationbelow displays a Y in the current cell, changes the entry to N when you pressthe Spacebar, changes the entry back to Y when you press the Spacebar asecond time, and so on.andP;  When you press Return, the routine ends, leavingwhatever letter was visible at the moment.andM;To create the macro, continue in the worksheet you created for the previousexample, and enter the labels shown in range A20..B26.andP;  For the moment, omitthe entry shown in red.andP;  Assign the labels in range A20..A26 as names for theadjacent cells of column B.andP;  Then enter the following formula in cell B26: +&quot;[RECALC tog]&quot;andamp;@IF@CELLPOINTER (&quot;contents&quot;)=&quot;Y&quot;,&quot;N&quot;,&quot;Y&quot;)andamp;&quot;[is approx.]&quot;andM;To try the macro, hold down the MACRO key and press T.andP;  The cell pointerjumps to the cell named choice, where the letter Y appears.andP;  Press theSpacebar several times to change the Y to an N and back again, then pressReturn to leave one or the other letter in the cell.andP;  Here's how the macroworks:andM;[GOTO]choice[is approx.]Y[is approx.] sends the cell pointer to choice, andenters the letter Y.andM;[GET key] awaits a keystroke and records it in key.andM;[IF key=&quot; &quot;][tog] calls the subroutine named tog if the last key pressed wasthe Spacebar.andP;  The tog routine consists of a single string formula that canread either [RECALC tog]Y[is approx.] or [RECALC tog]N[is approx.].andP;  Theroutine recalculates itself based on the value of the current cell.andP;  When thecurrent cell contains a Y, the tog routine formula results in [RECALCtog]N[is approx.], and the macro enters an N in the current cell.andO;Conversely, when the current cell contains an N, the tog routine formulareturns [RECALC tog]Y[is approx.], and the macro enters a Y in the currentcell.andP;  In either case, macro control then passes to the commands in cell B23.andM;[IF key=&quot;[is approx.]&quot;][QUIT] stops the macro if the last key pressed was theReturn key.andM;[BRANCH back] transfers macro control to the cell named back.andP;  The macro onceagain processes the [GET] command, awaiting another keystroke.andM;ATRANSLATION TABLEandM;So far you've seen ways to control a few keys at a time.andP;  For each key yourmacro allows someone to press, you've written at least one [IF] statement.andO;You can go on writing [IF] statements for every key on the keyboard if youwant to redefine the outcome of every keystroke.andP;  However, a macro thatcontains more than 100 [IF] commands in a row is unwieldy and inefficient.andM;Rather than bog things down with such slipshod programming, when you need toredefine many keys, create a keystroke-translation table.andP;  The followingillustration shows a macro and a smallkeystroke-translation table.andP;  The macrolets you move around on the worksheet and make limited changes withoutaccessing the menus or using the function keys.andM;To create the macro, continue in the worksheet you used for the last twomacros and enter the labels shown in range A29..F41.andP;  Precede the entries incells A31, E29, and E30 with an apostrophe.andP;  For the moment, omit the entryshown in red.andP;  Assign the labels in range A29..A31 as range names for theadjacent cells of column B. Then use the Range Name Create command to assignthe name table to range E29..F41.andP;  Finally, enter the following formula incell B29: @IF@ISERR@VLOOKUP(key,table,1)), key,@VLOOKUP(key,table,1))andM;This formula returns the entry in key if that entry doesn't appear in theleft column of the range named table.andP;  If key's entry is in the left columnof table, the formula returns the associated label from the right column ofthe table.andM;To try the macro, hold down the MACRO key and press M. Nothing appears tohappen, but the macro is in control.andP;  You can move the cell pointer around inthe worksheet, make cell entries, and so on.andP;  You cannot access the menu orget the expected results from pressing the function keys.andM;The macro intercepts your keystrokes and stores them one by one in the cellnamed key.andP;  If a key you press isn't listed in the table, the macro passesthe keystroke to 1-2-3 and the worksheet reacts accordingly.andP;  If the key islisted, the macro ignores the keystroke and instead performs the instructionsadjacent to the keystroke's listing.andM;In our translation table, the slash (/) and less-than (andless;) keys are pairedwith the [BEEP] command.andP;  This means that if you press slash or less-than toaccess the menu, 1-2-3 will simply beep at you.andM;Our translation table pairs the left brace character ([) with the left bracemacro keyword ([[]).andP;  Without the translation, 1-2-3 would try to interpretany left brace you type as a macro keyword, and the macro would fail.andM;The table pairs the Delete key with the commands [ESC 2]/RE[is approx.].andO;While the macro is running, you can press the Delete key to erase the currentcell.andM;The table pairs the GRAPH key with the [QUIT] command.andP;  If you wish to stopthe macro at any point, press the GRAPH key.andP;  You could just as easily put a[BRANCH] command in place of the [QUIT] command and let a user cause themacro to branch to a different routine.andM;Suppose that you want your macro to allow only keystrokes for which atranslation exists in the table.andP;  Rather than allow keystrokes that aren'tlisted, the macro should altogether ignore them.andP;  Modify the macro to do thisby editing the formula in cell B29.andP;  Replace the @IF function's true argumentwith a null string (&quot;&quot;).andP;  Here's the edited formula:@IF(@ISERR(@VLOOKUP(key,table,1)), &quot;&quot;,@VLOOKUP(key,table,1))andM;Using the macro with this formula in place of the original invalidates allkeystrokes that aren't listed in the left column of the translation table.andO;Therefore, you probably won't want to type a left brace because if you do,you won't be able to do anything other than press the GRAPH key to stop themacro.andM;If you wish to add more allowable keystrokes to the table, enter the macrorepresentation of the keystroke in the table's left column, and enter thedesired translation in the table's right column.andP;  Then select/Range NameCreate, enter table,a nd extend the highlighted range downward to encompassthe new entries.andO;</TEXT></DOC>