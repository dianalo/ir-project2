<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF109-624-401  </DOCNO><DOCID>09 624 401.andM;</DOCID><JOURNAL>PC Magazine  Nov 27 1990 v9 n20 p475(4)* Full Text COPYRIGHT Ziff-Davis Publishing Co. 1990.andM;</JOURNAL><TITLE>Managing the complexity of the GUI environment: the promise ofOOPLs. (object oriented programming languages)(Power Programming)(tutorial)</TITLE><AUTHOR>Duncan, Ray.andM;</AUTHOR><SUMMARY>Object oriented programming languages (OOPLs) are rapidly gainingascendancy as graphical user interfaces (GUIs) become popular.andO;GUIs are complex environments which OOPLs are better suited tomanaging than conventional languages.andP;  Currently availableobject-oriented programming tools include Apple's HyperCard forthe Macintosh and Asymetrix' ToolBook for the Microsoft WindowsGUI.andP;  HyperCard is discussed in detail; it is partly a paintprogram, partly a simple database and partly a development system.andO;It supports different levels of user expertise; users can simply'browse' through existing stacks, design their own stacks or writeelaborate scripts using the HyperTalk language.andP;  Scripts areassociated with buttons.andP;  HyperTalk 'feels' object-oriented but isnot a true OOPL because its object hierarchy is fixed.andM;</SUMMARY><DESCRIPT>Topic:     TutorialObject-Oriented LanguagesObject-Oriented ProgrammingGraphical User Interface.andO;Feature:   illustrationchart.andO;Caption:   The HyperTalk object hierarchy. (chart)andM;</DESCRIPT><TEXT>Managing the Complexity Of the GUI Environment: The Promise of OOPLs Althoughboth graphical user interfaces (GUIs) and object-oriented programminglanguages (OOPLs) have been around for 20 years, they are only nowpercolating down to the masses of users and programmers.andP;  The GUI and OOPLboosters may well ask, why has it taken so long?andP;  On the other hand, thedie-hard advocates of command lines and assembly language might be wondering,why now instead of yet another 20 years from now?andM;Dogma has it that a major technological advance takes at least ten years topenetrate into widespread use.andP;  Part of this time lag is due to the time ittakes inventors to communicate their findings to their peers; part to themassive amount of work required to transform a research discovery intosomething that can be manufactured economically and used safely by normalmortals; part to the learning curve, conversion cost, and temporary decreasein productivity that accompanies a major change; and part to peoples' innateresistance to new ways of doing things.andM;All these factors were certainly involved in acceptance of the GUI.andP;  It waspioneered at Xerox's Palo Alto Research Center in the early 1970s, thetechnology migrated to Apple in the early 1980s, and the Macintosh--the firstviable implementation of a GUI on a mass-market personal computer--appearedin 1984.andP;  Two other GUI-based machines, the Atari 520ST and the CommodoreAmiga, appeared shortly thereafter, as did Digital Research's GEM andMicrosoft Windows, two GUIs for IBM-compatible personal computers.andP;  All thesemachines and products enjoyed a certain degree of success, but the ultimatevictory of the GUI never appeared certain until Microsoft's introduction ofWindows 3.0 a few months ago.andM;Since then, although debates over the efficiency and desirability of GUIscontinue to rage in the press, it seems clear that the text-mode command-lineinterface is on the fast track to extinction.andP;  In retrospect, it's obviousthat users were really only waiting for a painless migration path at areasonable price.andP;  Microsoft's release of Windows 3.0, together with theemergence of a large installed base of VGA-capable 80386- and 80386SX-basedmachines and a concurrent decline in RAM prices, was met by a level ofend-user enthusiasm that must have startled even the most optimisticMicrosoft marketeers.andP;  It is rumored that Microsoft shipped nearly a millioncopies of Windows 3.0 in the first few weeks!andM;Is it a coincidence that GUIs and OOPLs are receiving so much attention atthe same-time?andP;  I suspect not; in fact, I'd be willing to bet that the rapidshift toward GUI applications is the primary driving force behindprogrammers' willingness to suffer through such a drastic change inprogramming paradigms.andP;  Most of us have seen enough C or Pascal code for theMacintosh, Windows, or Presentation Manager to appreciate how incrediblylaborious it is to program for these environments in a traditional procedurallanguage.andP;  We all instinctively sense that there must be a better way, andOOPLs promise to help us manage the complexity of GUI environments in anatural manner that promotes, robust, reusable code.andM;Whether this promise will be fulfilled, however, is yet to be determined.andO;Small-talk has, after all, gone hand in hand with GUIs since its creation,but it remains very much a niche language.andP;  Apple has been promoting anobject-oriented programming environment called MacApp for years, but mostpopular Macintosh software is still written in C or Pascal, and a surprisingnumber of Mac applications are actually written in assembly language.andP;  Actor,an OOPL for Windows, has been available for several years, but virtually allWindows applications are still coded in plain-vanilla C.andM;Over the next few months I intend to take a look at some of the currentlyavailable object-oriented programming tools for Windows and PresentationManager, and see whether they live up to their press releases.andP;  For my firstvictim, I've chosen Asymetrix's ToolBook, but an intelligent discussion ofToolBook demands that we discuss Apple's HyperCard first.andM;A SURVEY OF HYPERCARDandM;In spite of the implications of its name, HyperCard is not a hypertex mediumby any stretch of the imagination.andP;  But HyperCard is a protean product withan incredible range of capabilities; it can be thought of as a paint program,a flat-file database, a sound generator, an animation controller, a visuallyconfigurable user interface, a shell to launch other applications, anextensible integrated programming environment, and a front-end for enormousstorage devices such as CD-RPMs.andP;  One of the saddest side effects of the(totally unjustified) scorn most DOS programmers feel for the Macintosh isthat they've never had an opportunity to experiment with HyperCard and toexperience just how much fun it can be to build applications with a properlydesigned, GUI-based, object-oriented, integrated development environment.andM;HyperCard was written by Bill Atkinson, a member of the original Macintoshdevelopment team and the author of QuickDraw (the Mac's graphical drawingengine in ROM) and MacPaint (one of the first two Mac application programs).andO;Atkinson is one of the few true creative geniuses of personal computerprogramming, and his near-fanatical devotion to code optimization andaesthetics of the user interface are legendary.andP;  After the announcement ofthe Macintosh, Apple went through a series of upheavals in management andsudden shifts in direction that have been well-documented elsewhere, andAtkinson drifted away to work on one of his pet projects, a &quot;personal toolkitfor the rest of us.&quot;andP;  When HyperCard was completed in 1987, he cashed in hisconsiderable pile of chips at Apple and managed to convince the company (overthe objections of many third-party Mac developers) to bundle HyperCard withthe Macintosh as free system software.andM;A HyperCard data file is called a stack.andP;  From the user's perspective, astack is an ordered collection of one or more cards, which can only be viewedone at a time.andP;  Each card is exactly the size of the Mac's screen and cancontain from one to many text-field and button objects, as well as text,drawings, and images that have been painted onto the card as bitmaps.andP;  Cardsshare background, and there can be many different backgrounds in a singlestack.andP;  Bitmaps, buttons, and text fields that are placed on a backgroundwill appear on all cards that use that background, although they might bepartially or completely obscured by bitmaps, buttons, and fields that areunique to (in the foreground of) a particular card.andP;  One special stack,called the home stack, is used by HyperCard as a sort of master menu and tostore configuration information and certain global resources.andM;As paint programs go, HyperCard is middle-of-the-road.andP;  Predictably, itspaint tools are direct descendants of MacPaint, albeit with a number of niftynew tricks and features, such as tear-off menus, edge tracing, and patternpickup.andP;  Of course, the Mac's clipboard makes it easy to work around suchlimitations as exist with HyperCard's painting tools; you can draw, paint, orscan-in sophisticated images in other, more specialized applications, thencopy and paste the pictures into a HyperCard stack with a few keystrokes ormouse clicks.andP;  Scanning pictures and line art into a HyperCard stack is madeespecially easy by Atkinson's HyperScan utility, which unfortunately worksonly with the relatively expensive flatbed Apple Scanner.andM;You can also visualize HyperCard as a simple database.andP;  Each card can bethought of as a record, and each text field within a card as a field ormember of that record.andP;  There's only one data type, though--plain ASCII text;even the mathematical operations supported by HyperCard accept ASCIIarguments and return ASCII results (consequently, although the range ofmathematical functions provided by HyperCard is quite respectable,number-crunching is not one of HyperCard's strong points).andP;  Text fields canbe scrolled, and each text field on a card can contain up to 32,768characters, so you can readily see that a HyperCard stack can hold anenormous amount of data.andP;  Searching for data is alsy very efficient inHyperCard; Atkinson makes use of sophisticated compression algorithms,indexing schemes, and &quot;hinting&quot; bitmaps that yield exceptional performancefor the most common cases.andM;One of the peculiar strengths of HyperCard is the way it lends itself to useby people with vastly different levels of expertise.andP;  The most naive user canbrowse through an existing stack as though it were a book, merely clickingthe mouse on butons or using the Find command to navigate from one card toanother.andP;  If not disallowed by the stack's designer, the naive user can alsoadd cards, delete cards, and modify or add text within the fields of cardswith simple mouse, keybord, and menu operations.andM;At the next level, a user who is computer-literate but has no programmingexperience can design his own stacks, decorating them with backgrounddesigns, images, and clip art pasted from other stacks (HyperCard comes witha cornucopia of examples).andP;  He can visually create, place, and resize buttonsand text fields with the mouse and &quot;hook&quot; buttons to a specific destinationcard within the same or another stack through a simple dialog.andM;And for the experienced programmer, the HyperCard environment is rich indeed.andO;HyperCard's programming language, called HyperTalk, resembles naturalEngilish in its freedome of syntax and tolerance for synonyms and is ratherlike Pascal in its control structures and distinction between procedures andfunctions.andP;  A HyperTalk program doesn't exist as a single entity in anycentral place within a stack.andP;  Instead, a stack's program is the sum of manysmall scripts, each scrip in turn containing one or more district functionsand procedures called message handlers.andP;  A script is associated with abutton, text field, card, background, or stack, and execution of a handlerwithin a script is triggered by the arrival of a message generated by theunderlying HyperCard system, usually as a result of some user action.andM;They key to HyperTalk programming is understanding HyperCard's objecthierarchy, shown in Figure 1, and its huge repertoire of event messages.andO;When an event occurs, HyperTalk sends a message to the lowest appropriatelevel of the hierarchy; if no handler for the event is present at that level,the message filters up through the hierarchy until it finds a handler or&quot;falls out&quot; the top.andP;  The button and text-field handlers are mainly relevantto mouse and keyboard events that occur when the mouse pointer or text cursorlies within the corresponding visible button or text-field objects.andP;  Forexample, imagine that a card contains a single button and the button isassociated with the following short script:andM;on mouseUp visual effect dissolve slow go to next card of this background endmouseUpandM;If the user moves the mouse pointer onto the button and clicks it, HyperCardsends a mouseUp event message to the button, the on mouseUp handler in thebutton's script is activated, and the user will see the current card slowlydissolve into the contents of the next card in the stack that shares the samebackground.andP;  If the user clicks the mouse outside the button, the button'shandler is bypassed: the mouseUp message enters the object hierarchy at thenext level (the script for the current card), and is either processed by ahandler at one of the remaining levels or is discarded.andM;Although HyperCard is general, and HyperTalk programming in particular, hasan intense object-oriented feel to it, purists will tell you that HyperTalkis not a true OOPL.andP;  The reason is that HyperTalk has a fixed hierarchy ofobjects.andP;  Although you can change the internal procedures or methodsassociated with instances of these objects, there is no way to create newclasses of objects out of existing objects.andP;  Nevertheless, investing sometime in HyperTalk remains the most pleasant way I know of to break free ofthe traditional, procedural programming paradigm; the lessons you learn inHyperTalk will serve you well when you move on the Smalltalk, Object Pascal,C++, or similar languages.andM;I've been using HyperCard 1.2 and HyperTalk for about two years as the frontend for an information management system in a neonatal intensive care unit.andO;I'm very fond of HyperCard, but it would be unfair to suggest the it doesn'thave any problems at all.andP;  HyperCard doesn't support color, and itstext-handling facilities are very limited, especially when they're comparedwith its painting facilities; for example, all the text in a text field musthave the same font, size, and style--the only way to display a sentence witha single word in italics or bold type is to &quot;paint&quot; the sentence onto thecard as a bitmap, which means that you can no longer perform searches forwords in the sentence!andP;  Hypertext links between chunks of text are notsupported directly and can be simulated only by use of the most gruesomekludges.andP;  HyperCard is also very &quot;modal&quot; compared with most Macintoshapplications, and it breaks Apple's user-interface guidelines in severalrespects, such as the way it takes over the whole screen as a nonsizable,nonmovable window and the way single mouse-clicks will initiate actions thatelsewhere would require double-clicks.andM;Some of these faults will no doubt be addressed in the upcoming release ofHyperCard 2.0.andP;  In any event, HyperCard has earned an important place inpersonal computing history.andP;  It was a breakthrough product when it wasreleased, and it still stands out today as a masterpiece of design andimplementation.andP;  Even the on-line help shows an attention to detail andvisual grace that has few, if any, counterparts in the IBM PC world.andM;ASYMETRIX'S TOOLBOOK FOR WINDOWSandM;Several companies have shipped or announced products fr the IBM PC platformthat are HyperCard-like, but the one that seems most likely to succeed isAsymetrix's ToolBook.andP;  Asymetrix, as most people know by now, is owned byPaul Allen, Bill Gates' high-school pal and the co-founder of Microsoft.andO;Allen phased himself out of Microsoft's day-to-day operations in the early1980s for health reasons, but retained massive stock holdings.andP;  Four yearsago he financed his own start-up--Asymetrix--and recently he has again becomemore involved with Microsoft and has been appointed to Microsoft's board ofdirectors.andP;  Allen's long-standing relationship with Gates was no doubtcrucial to Microsoft's decision to ship the Asymetrix runtime libraries withevery copy of Windows 3.0, putting ToolBook in an enviable position withsoftware developers, compared with alternative DOS-based HyperCard-likeenvironments.andM;Philosophically, ToolBook is so much like HyperCard that an experiencedHyperCard developer can be highly productive with TookBook within hours.andO;There are terminology differences, of course--for example, ToolBook calls itsfiles books and the records within the books pages, in contrast toHyperCard's use of stacks and cards, and ToolBook's programming language,OpenScript, is considerably more elaborate than HyperTalk.andP;  However, thegeneral approach to designing and implementing an application is essentiallyidentical in ToolBook and HyperCard.andP;  In fact, the mapping between the twosystems is close enough the Heizer Software has been able to develop autility (Convertlt) that converts HyperCard stacks directly into ToolBookbooks.andM;But ToolBook is an improvement over HyperCard in many ways.andP;  It's obviousthat ToolBook's developers studied HyperCard closely, and they systematicallytried to fill in the gaps in HyperCard's capabilities.andP;  ToolBook can havemultiple files and multiple independent windows open at the same time; itssupport for color is impeccable; its facilities for formatting text andestablishing dynamic links from one chunk of text to another are excellent;scripts can be attached to graphical objects as well as to text fields andbuttons.andP;  And ToolBook makes animation easy with a sort of &quot;watch me&quot; mode,which lets you drag objects around the screen and automatically generates ascript that will carry out the same movements.andM;There is one area where ToolBook doesn't fare very well compared withHyperCard: performance.andP;  HyperCard was coded by one of the greatest livingwizards of assembly language programming.andP;  It's both fast and economical withdisk space and RAM; it runs very well even on an old 68000-based Mac Pluswith IBM of RAM and a single floppy disk drive.andP;  ToolBook, on the other hand,is typical of the new generation of applications coded in C; the completedevelopment package requires an 80286 or better CPU and megabytes of diskspace and RAM.andP;  It feels sluggish on anything less than a 25-MHz 80386.andM;In the next issue of PC Magazine, I'll continue this discussion of ToolBook,with special attention to OpenScript programming.andO;</TEXT></DOC>