<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-705-758  </DOCNO><DOCID>07 705 758.andM;</DOCID><JOURNAL>EXE  Sept 1989 v4 n4 p42(4)* Full Text COPYRIGHT Process Communications Ltd. 1989.andM;</JOURNAL><TITLE>The software prototype.andO;</TITLE><AUTHOR>Ince, Darrel.andM;</AUTHOR><SUMMARY>Requirements analysis and systems specification are two of themost difficult and error-prone parts of software developmentprojects.andP;  Attempts to improve the system specification processhave focused on graphic ways of describing what a system shoulddo.andP;  Attempts to improve the requirements analysis process havefocused on software prototyping, the development of an earlyversion of a system to demonstrate to a customer before systemsspecifications are developed.andP;  Recent years have seen theappearance of many prototype development tools.andP;  Very-high-levelprogramming languages are suitable for prototyping.andM;</SUMMARY><DESCRIPT>Topic:     Program Development TechniquesPrototypeSoftware EngineeringProgrammingRequirements Analysis.andO;Feature:   illustrationprogramchart.andO;Caption:   Quicksort algorithm coded in Miranda. (program)State transition diagram, with five states. (chart)andM;</DESCRIPT><TEXT>The software prototype One of the most difficult and error-prone parts of thesoftware project is requirements analysis.andP;  This is the process of findingout what a customer wants from a system and writing this down in a documentcalled the system specificatio.andM;Requirements analysis is difficult for several reasons.andP;  First, there is acultural difference between the software developer and the customer.andP;  Theformer is often skilled in the latest development methods, but may have ascant knowledge of an application area.andP;  The customer will know theapplication area in minute detail, but will have, at best, an outdated viewof the capabilities of software systems.andM;The second problem occurs inside the system specification.andP;  Normally,developers use natural language to write this document.andP;  Now, naturallanguage is excellent for creating literary works of art.andP;  Poems and booksare often prized for the subtlety and ambiguity of their text.andO;Unfortunately, this makes it a poor choice of medium for specifications,which must be precise.andP;  Errors in interpretation of a system spefication cancause projects to go over budget, software to be delivered late or produceuseless software that misses the user's requirements.andP;  There are manydocumented instances where misinterpretation of a system specification by asoftware developer has led to the cancellation of million dollar projects.andM;The other feature of system specifications which often causes poor softwareis its size.andP;  For medium to large software projects the specification canoccupy hundreds of pages of text.andP;  For example, the specification of thesoftware for a recent American fighter plane occupied twenty volumes of text.andO;Each of these volumes contained four or five hundred pages of closely typedsentences.andP;  To discover the detailed functionality of a software system fromsuch a document is, at best, an error-prone process.andM;The system specification is the key document in a software project.andP;  It isgiven to the designers who define the architecture of a system.andP;  It is givento quality assurance staff to construct the acceptance tests which willdetermine whether the system is handed over to the customer.andP;  Finally, it isgiven to the technical authors who write the user manuals.andP;  So an ambiguoussystem specification will be followed by a wrong design, poor system testsand user manuals which bear very little relation to the software system theypurport to describe.andP;  An error, caused by the system specification andundetected until system testing, can be ten thousand times more expensivethan if it is discovered during requirements analysis.andM;A graphical solutionandM;Several researchers have attempted to improve the system specificationprocess.andP;  Most of the effort has concentrated on inventing new notations fordescribing what a system should do.andP;  These have mostly been graphical innature.andP;  Without a doubt, these techniques have increased productivity.andO;There are some software tools, on the market now, intended to help analystsdevelop system specifications using graphical notations.andP;  These tools, called'analyst workbenches', usually run on top-end PCs or Sun/HP workstations.andM;Even though such notations have been of some help, software developers stillencounter difficulties during requirements analysis.andP;  These problems tend toshow themselves when the system is delivered to the customer.andP;  I have heardmany stories from developers who, while demonstrating a system duringacceptance testing, have had the customer turn to them and say 'This is notthe system I want!andP;  If only you had shown it to me earlier!'andP;  This phrase isthe key to software prototyping.andM;Software prototyping is the process of developing an early version of asystem which can be shown to the customer before system specification.andP;  Whenthe prototype has been agreed, it can be signed off by the customer and usedas a reference point during development.andP;  The last five years have seen theemergence of many tools for quick development of prototypes.andP;  Prototypingtools produce programs which are deficient in some way.andP;  The code is veryslow, or uses an inordinate amount of memory.andP;  However, these deficienciespale into insignificance compared with the advantages of having a workingsystem which the customer can examine and use.andM;Very high level languagesandM;One of the most effective ways of prototyping is to use a very high levelprogramming language.andP;  We have used high level languages for thirty years.andO;Languages such as FORTRAN and BASIC have given us major productivity gains.andO;Very high level languages are a further step forward.andP;  The major differencelies in the basic data types.andP;  High-level languages work with simple items ofdata - for example, integers and characters.andP;  Very high level languages havemore sophisticated data types.andM;Probably the most practical very high level language for prototyping is SETL.andO;Developed at the Courant Institute at the University of New York, its basicdata type is the set: a collection of dissimilar objects.andP;  SETL consists ofoperations which carry out actions such as printing out a set, merging twosets together and constructing a set which contains those elements which arecommon to two other sets.andP;  Because of its high-level data types, SETLachieves massive savings in terms of textual program size.andP;  Users of SETLclaim that they can write a program a tenth of the size of an equivalentprogram written in a conventional language.andM;AI programming languages, such as LISP and Prolog, are suitable forprototyping.andP;  The major advantage of such languages is that they are normallysurrounded by an interactive programming environment.andP;  This helps theprogrammer to move through the update-compile-execute cycle quickly andeasily.andP;  Prototyping is highly dynamic: dozens of changes can be made to aprototype during an evaluation session between the developer and thecustomer.andP;  Consequently, programming environments, such as the softwaresupplied with many LISP packages, are useful for prototyping.andM;The most widespread type of prototyping language is the fourth generationlanguage.andP;  Commercial DP departments use these to manipulate large datafiles.andP;  A fourth generation language contains facilities for definingtransaction screens (as used by bank clerks and air line reservation staff),for generating reports and for accessing complex databases.andP;  There are nowhundreds of fourth generation languages and they are gradually replacing theageing COBOL language for commercial data processing applications.andM;The specification that runsandM;One powerful method of prototyping is called 'specification execution' - thedeveloper actually runs a compiled version of the system specificationdocument.andP;  The developer produces the specification as normal.andP;  It is thenprocessed by a special-purpose tool which translates the specification into acomputer program.andP;  This program may then be executed.andP;  The importantadvantage of this technique is that it requires little work from thedeveloper, once he has completed the specification.andP;  This contrasts with SETLor LISP, where the services of a skilled 'hacking' programmer are required.andO;The system specification may only be produced after the 'hacking' hasfinished.andM;The disadvantage with specification execution is that available softwaretools are only capable of processing specifications expressed in discretemathematics.andP;  Such formal specifications, while exact and capable of beingvalidated to a high degree of precision, suffer from various disadvantages.andO;For example: the customer cannot understand the notation and few UKdevelopers possess the necessary mathematical expertise.andP;  However, a recentsafety critical software standard for the defence industry, Defence Standard00-55, makes it mandatory for software developers to use mathematics as aspecification medium.andP;  So there should be a major increase in the use offormal specifications and specification prototyping in the computer industry.andM;One of the least-known tools for prototyping is the Unix operating systemitself - a tool which has had remarkable success in producing systemsquickly.andP;  Unix has two functions.andP;  The first is to control the resources ofthe computer system on which it is installed.andP;  The second is to provide setsof general facilities which enable the programmer to develop software veryquickly.andP;  The archetypal facility for prototyping in Unix is the softwaretool known as 'yacc'.andP;  Using this program, you can quickly build compilersand language processors.andP;  The programmer defines the structure of a language,then invokes yacc to produce the compiler for that language.andP;  This is done ina fraction of the time that would have been required if the compiler werehand-coded.andP;  Unix contains many similar tools.andP;  There is also the facilityknown as 'the pipe', which enables the developer rapidly to glue togetherchinks of software produced by such tools to create prototype systems.andM;Fifth generation languagesandM;Another promising technique involves fifth generation programming languages.andO;These languages were developed in response to the problems encountered whenrunning conventional language programs on large multi-processor computers.andO;The developers found that when they added an extra processor to aconventional computer, programs tended to run just slightly less than twicethe speed.andM;Adding a third processor only produced an increase of 2.5 times.andP;  They soonreached the point where adding processors made little difference to the speedof the programs.andP;  On some computers, adding a processor made programs slower.andM;The explanation for this is that as more processors are added they need tosynchronise with each other with messages.andP;  This synchronisation eats upprocessor time.andP;  It has been found that the processor time required bysynchronisation increases exponentially measured against the number ofprocessors present in the system.andP;  To solve this problem, researchersproposed several 'fifth generation' computer architectures.andP;  These were aradical change from the conventional computer architectures in use today.andO;Unfortunately, fifth generation machines are unable to run languages likeBASIC and Pascal efficiently, so new languages had to be invented.andM;Although research into fifth generation hardware has been slow, some fifthgeneration languages have been implemented on conventional computers.andO;Typical languages include ML, developed at the University of Edinburgh,Miranda, developed at the University of Kent and Scheme, developed at MIT.andM;The feature that makes fifth generation languages ideal for prototyping istheir succinctness.andP;  Very complicated algorithms can be expressed in a smallamount of text.andP;  An example of a sorting program expressed in the programminglanguage Miranda is shown in Figure 1.andM;The program uses the quicksort algorithm, where a list of numbers is split upinto two sub-lists and each sorted separately.andP;  The first line of the programstates that when you sort an empty sequence of numbers you get an emptysequence of numbers.andP;  The second line states 'when you sort a sequence whichconsists of a number a concatenated by a sequence of numbers x, then you haveto sort the set consisting of those elements of x which are less than a,concatenate it with a and then concatenate it with the set formed by sortingthose members of x which are greater than a.'andM;Functional programming languages are quite difficult to read, as the exampleabove shows.andP;  They required the programmer to forget almost all thetechniques that he uses with conventional languages.andP;  However, programswritten in such languages are very much shorter than equivalents inconventional languages.andP;  For example the program code for the quicksortalgorithm would be more than fifteen statements of Pascal.andM;The human touchandM;The tools that I have described so far can only be used to prototype thefunctions of a software system, ie what it is to do.andP;  There is another aspectof a computer system which requires prototyping: the human-computer interface(aka Man Machine Interface or MMI).andP;  Sadly, tools in this area have lagged along way behind.andP;  However, the emergence of high-quality graphics for PCs andworkstations has caused a flurry of activity.andP;  Many fourth generationlanguages have facilities which let the user design his own input and outputscreens.andP;  The definition of such screens often requires only a few minutes'effort.andM;There are now tools capable of processing descriptions of the interactionsbetwee a user and a computer system.andP;  Working from these descriptions, thetools can generate a prototype MMI.andP;  A popular notation used for describinginteractions is the state transition diagram, as shown in Figure 2.andP;  Eachcircle represents a state.andP;  An arrowed line from one circle to another showsa transition between states.andP;  The line is labelled with the event that causedthe transition, together with the action to be taken when the transitionoccurs.andP;  These are separated by the / character.andM;Figure 2 shows five states: 0 to 4.andP;  In state 0 the state transition diagramis awaiting a command.andP;  If the user types in the characters 'ed' then thediagram moves to state 1.andP;  If he types the characters 'run' then the diagrammoves to sate 3; if he types 'compile' the diagram moves to state 4.andP;  Anyother input (signified by an asterisk) is treated as an error and the systemproduces an error message.andM;If, while in state 1, the user types a letter character, then the diagrammoves to state 2.andP;  If any other character is typed, then another error occursand the diagram returns to state 0.andP;  If, from state 2, the user types aletter or a digit, then the diagram will remain in state 2; any othercharacter causes the diagram to move to state 0.andP;  The transitions for state 3and 4 are not shown in the diagram.andM;Several prototype processors are now available to work on these statetransition diagrams.andP;  User reaction to these tools has been veryenthusiastic.andP;  It is expected that they will be incorporated into the fourthgeneration languages of the 1990s.andM;This, then is the state of software prototyping: there are now many softwaretools for prototyping the functions of a system and a few for prototyping thehuman computer interface.andP;  Although the interface tools are less than ideal,I believe that a developer who wants to use prototyping has a more thanadequate set of tools available.andP;  However, there are still some problems.andM;The first problem is that little is known about the management of prototypingon the software project.andP;  Because prototyping appears to be a haphazardprocess, it encourages haphazard and disorganised management.andP;  Mostprototyping disasters that I have seen on software projects occurred becausethe Project Manager failed to monitor the process adequately.andP;  Such Managersfind out, far too late, that the prototyping effort has eaten into theresources intended for design.andM;The second problem is concerned with change.andP;  All medium to large softwareprojects experience change.andP;  Commercial data processing projects are affectedby changes in tax law and business policy.andP;  Defence systems experience changebecause of new types of weapon, or new tactics adopted by a potentialaggressor.andP;  All systems are vulnerable to changes in computer hardware.andP;  Thechange occurs throughout the lifetime of the software project and forcesredesign, re-specification and re-programming.andP;  Some software ProjectManagers, impressed by the power of prototyping, have been lured into a falsesense of security.andP;  They chose to ignore changes which occurred during theirproject.andP;  As a result, they delivered systems which did not meet customerrequirements.andM;Revolutionary evolutionandM;Because of the nature of change, a few radical researchers and developershave proposed a new form of prototyping: evolutionary prototyping.andP;  Insteadof abandoning the prototype after the system specification has been produced,it is used as the basis for subsequent development.andP;  A working prototype isalways available during the project, to show the customer the effect ofparticular changes.andM;Evolutionary prototyping is in its early stages, but several primitivesystems have been developed.andP;  One such is EPROS, from the Open University.andO;EPROS is based on a wide spectrum language known as EPROL.andP;  A wide spectrumlanguage is one which contains facilities for specification, design andprogramming.andP;  Whatever the state of the project, the system descriptionexpressed in EPROL is executable.andP;  Consider a multi-module system, for whichthe design is complete.andP;  A requirements change occurs which affects three orfour modules of the system.andP;  The developer can re-specify these modules usingthe specification facilities of EPROL.andP;  He replaces the completed (butoutdated) design of these modules with the new specification.andP;  The system insuch a partial form remains executable and can still be shown to the customeras a prototype.andM;Despite the problems that I have described, prototyping remains one of themost exciting developments in computing over the last five years.andP;  It isbased on the strong notion of producing software that meets the needs ofusers.andP;  It heralds a new way of treating the customer, by placing him firmlywithin the software development project.andM;Darrel Ince is a Professor of Computing Science at the Open University.andP;  Heis co-author of Software Prototyping, formal methods and VDM, published byAddison-Wesley price 19.95 pounds sterling.andO;</TEXT></DOC>