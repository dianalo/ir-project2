<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-374-794  </DOCNO><DOCID>07 374 794.andM;</DOCID><JOURNAL>AI Expert  July 1989 v4 n7 p19(4)* Full Text COPYRIGHT Miller-Freeman 1989.andM;</JOURNAL><TITLE>Expert debugging help. (a bug finder in PROLOG) (Expert's Toolbox)(technical)</TITLE><AUTHOR>Knaus, Rodger.andM;</AUTHOR><SUMMARY>Debugging in PROLOG is a three-step process which entails usingtrace messages to determine which rule and subgoal is failing,making that subgoal into the new top-level rule, and continuinguntil the current goal is the bug causing the program to fail.andP;  APROLOG predicate for automating the bug search is presented.andP;  Its'bug at current level' module reports a problem at the currentlevel of computation, checks what happens with each clause of thegoal predicate, and calls subgoals one by one to generate a listof clause-level bug reports.andP;  The user can use this information tosport undefined goal predicates and other errors.andP;  A 'frameprocessing' module tests for conditions which indicate aparticular bug diagnosis and condenses the input data into aconcise 'frame' containing the diagnosis.andM;</SUMMARY><DESCRIPT>Topic:     Applications ProgrammingDebugging ToolsSoftware DesignExpert SystemsArtificial IntelligencePROLOG.andO;Feature:   illustrationprogram.andO;Caption:   Bug finding strategy in PROLOG. (program)Finding information about the current level bug. (program)Clause-level bug reporting. (program)andM;</DESCRIPT><TEXT>Expert Debugging HelpandM;Our last two columns discussed frames; this time, instead of just talkingabout how useful they are, we'll use them in an expert system, a debugginghelper.andP;  I'll discuss the bug expert for PROLOG, but many of the techniquescould be adapted to other languages.andM;As a software developer working in PROLOG, some of my most frustratingexperiences occur after the first version of a new program is written.andP;  Atlast the product is ready to test; the sound of the disk drive loading myprogram is like a fanfare, and now I, the software artist, am onstage for thebig moment.andP;  The excitement builds as I get ready to start the new program.andO;Like a conductor giving the downbeat, I type in the top-level goal and hitthe andless;ENTERandgt; key.andP;  I wait expectantly for a moment as the system chugs.andP;  Andthen comes the answer--no.andP;  Exhilaration gives way to depression as I thinkabout the tedious process of locating the failure in the 10 different modulesand eight layers of function calls that make up the program.andM;With a little practice, however, you can find bugs systematically.andP;  In pastcolumns, I have laid out a simple strategy for zeroing in on the bugs(Expert's Toolbox, Al EXPERT, Sept. 1988, pp.andP;  17-21; Nov. 1988, pp.andO;17-23.):andM;1.andP;  Use trace messages to determine which top-level rule and subgoal of thatrule is failing.andM;2.andP;  Make the subgoal you found in Step 1 the new goal that fails; repeat Step1.andM;3.andP;  Continue this process until the current goal is the bug that causes yourprogram to fail.andM;Changing the form of this procedure from iterative to recursive and puttingit into PROLOG, we get the debugging procedure shown in Listing 1.andM;AUTOMATING THE SEARCHandM;Now that we have our bug search in PROLOG, why not program it and avoidsearching for bugs by hand?andP;  The strategy we will use in the automated bugfinder is the same as we have used by hand; without compelling reasons to dootherwise, imitating a successful strategy used by people in an AI program isa good idea.andP;  Also, the hand strategy breaks the bug-finding problem intosmall steps, each of which has merely to find a failing subgoal among theclauses for a single PROLOG predicate.andP;  Further analyzing the hand algorithmfrom Listing 1, we discover that the entire bug finder can be built from thefollowing set of modules:andM;* Bug at current level.andP;  The input to this module is a goal that fails.andP;  Themodule finds the subgoals from the clauses for the goal predicate that failwhen they shouldn't.andM;* Bug paths.andP;  The input to this module is the top-level goal that fails; theoutput is one or more paths through a set of failing subgoals from the toplevel to the interior subgoals somewhere in the program that fail when theyshouldn't.andP;  Bug paths calls bug at current level recursively to build itsoutput paths.andM;* Report writer.andP;  Subgoal failure information for possible bugs as returnedfrom bug paths is summarized by report writer.andP;  Its bug report suppressesunnecessary details but contains enough information to find the bug easily.andM;Listing 2 contains a simple PROLOG predicate that succeeds only if itsargument is a list of integers.andP;  We have intentionally added a but to thisprogram.andP;  While I am fully confident that all you sharpies out there havefound it, I'll pretend the bug is a mystery to show off the bug finder, whichproduced the report shown in Listing 3.andP;  Notice, however, that typical staticprogram analyzers, which report underfined predicates and other syntacticsins, would not find this bug.andM;THE CURRENT LEVEL BUGandM;We'll start our detailed construction of the bug finder with the bug atcurrent level module that reports a problem at the current level of thecomputation.andP;  We assume a bug exists--that is, the goal being debugged fails.andO;Some predicate is used as the functor of this current failing goal; let'scall that predicate pred.andP;  Since pred fails, each of its clauses fails.andO;Thus, to guess the reason the current goal fails, we gather information aboutthe way each clause of pred fails and heuristically analyze that information;Listing 4 shows the top level of this process.andM;The first step in bug analysis is to see what happens with each clause of thegoal predicate.andP;  Listing 5 shows how to retrieve the clauses for the goalpredicate; the subgoal gen_clause_reports generates the clause reports.andP;  Inthe Listing 5 predicate, zzz_current_goal preserves a copy of thecurrent-level goal unsullied by unifications during the bug search.andM;The real work of clause reporting is done by clause_report_hlpr in Listing 6.andO;This predicate gets a copy of the current goal (remember, we saved it withzzz_current_goal) and tries to satisfy the goal with one of the clauses ofthe current goal predicate.andP;  For this end, it tries to unify the goal withthe clause head and calls the subgoals in the clause body one by one.andP;  Ateach step, it records information about the clause evaluation in a reportframe.andP;  For instance, if the head fails to match the goal, the report recordsit.andP;  If the heads do match, that also gets recorded.andP;  If we reach a cut inthe subgoal body, that fact gets saved in the report, and if some particularsubgoal fails, we save the position of the offending subgoal in the clause.andM;The news team that records all this information is headed by the predicateclause_report_hlpr.andP;  That predicate and its helpers use frames to record theinformation they gather, because in a frame we can create a slot for anyinformation we please.andP;  For example, suppose we want to record the Positionof the failing subgoal.andP;  The goal: frame_unify( Current_report,[failing_subgoal_number :Position], New_report), does the trick.andM;Frame_unify is just like ordinary unification (the = operator of PROLOG),except that it unifies values in like-labeled slots instead of incorresponding argument positions.andP;  Like ordinary unification, frame_unifycreates the most general frame that's more specific than either of its inputarguments.andP;  If information in like-labeled slots of the input framesconflicts, frame unification fails.andP;  For frame unification, we assume anabsent slot is filled with an anonymous variable.andP;  This means, for example,[a: 1] and [b: 2] unify to [a: 1, b: 2].andP;  More generally, frame_unify is aconvenient method of adding new slots to a frame while ensuring informationis added consistently.andM;USING THE INFORMATIONandM;Now we'll assume we have a list of clause-level bug reports.andP;  These reportstell us why each clause of the goal predicate failed.andP;  We can't be certainwhich clause should have succeeded, but even with no knowledge of theapplication, we can make some plausible guesses.andP;  For example, if the goalpredicate is undefined, it caused the failure.andP;  We can spot this conditionautomatically because it's true when the goal predicate is not a systempredicate and the clause report list is empty (Listing 5).andP;  Likewise, if thehead of only one clause matches the goal, that clause is probably the blacksheep; if only one clause gets past a cut before it fails, that clause ismost likely the problem.andM;Listing 7 contains a typical example of clause-report analysis.andP;  Thisanalysis rule says if the head matches the goal for only one rule of the goalpredicate, the failing subgoal of that rule is reported as the bug at thecurrent level.andP;  The input to the analysis rule is a list of clause reportsand the output is a bug report for the current-level goal.andP;  Both input andoutput reports are represented as frames, because frames let you file everypiece of information under its own slot name.andM;Let's look at the frame processing of Listing 7 in more detail.andP;  The findallsubgoal finds the unique goal predicate clause whose head matched the goal,if such exists.andP;  The singleton list in the third argument of findall insuresthat this subgoal succeeds only if a single goal-predicate clause meets thiscondition.andP;  The second argument of findall filters the clause reports lookingfor all clauses whose heads match the goal.andP;  Two steps achieve this, as shownin the code by the and operation in the second findall argument (denoted bythe semicolon in PROLOG).andP;  First we generate a list of all members of theclause-report list; memb, a backtracking version of the member predicate(shown on AI EXPERT's Bulletin Board and CompuServe forum).andP;  Then, usingframe_slot_val, we test the head_matched slot of each clause and keep onlythose with true in the slot.andP;  With the remaining subgoals ofcurrent_level_bug_report_hlpr and the helper predicate bug_report_on_clause,we edit the clause report for its new role as the current-bug-level report.andO;Frame editing uses several of Chris Jay's frame library predicates, discussedin Expert's Toolbox (AI EXPERT, March 1989, pp.andP;  19-24; May 1989, pp.andO;19-24):andM;Frame_info finds the class and list of slot-value pairs of a frame.andO;Frame_slot_val finds the value of a given slot in a frame.andP;  Frame_unifybuilds the most general frame containing the information in two input frames,provied the input frames don't conflict.andP;  Remove_if_slot removes a slot froma frame, if one exists.andP;  The library containing these predicates and acompiled version of the bug finder are on the AI EXPERT and Instant RecallBBSs.andM;Stepping back from the details, we've used frame processing to test forconditions when a particular bug diagnosis can be given, thus condensing theinput information into a more concise frame containing that diagnosis.andP;  Eachgoal_report tells us one subgoal of the current goal that might have failedin error.andP;  This subgoal becomes the new failing goal for another layer of buganalysis using the current-level bug analzyer.andP;  In the next column, we willdiscuss how to take the bug information from each level and put it togetherinto a bug report.andO;</TEXT></DOC>