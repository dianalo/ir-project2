<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-589-659  </DOCNO><DOCID>07 589 659.andM;</DOCID><JOURNAL>Communications of the ACM  May 1989 v32 n5 p608(16)* Full Text COPYRIGHT Assn. for Computing Machinery, Inc. 1989.andM;</JOURNAL><TITLE>An object-oriented requirements specification method.andO;</TITLE><AUTHOR>Bailin, Sidney C.andM;</AUTHOR><SUMMARY>Object-oriented software requirements analysis is approached withmethodology different from the more conventional structuredanalysis method.andP;  This alternative methodology is detailed throughthe use of parallel processes of decomposing objects andallocating functions.andP;  The new method is designed to flow smoothlyinto design by object diagrams and from there into programmingwith Ada or other high level languages.andP;  The primary concept is ofentity rather than process.andP;  The specification method has sevensteps: identify key problem domain entities; distinguish betweenactive and passive entities; establish data flow between activesentities; decompose entities into sub-entities and - or functions;check for new entities; group functions under new entities; andassign new entities to appropriate domains.andM;</SUMMARY><DESCRIPT>Topic:     Object-Oriented LanguagesRequirements AnalysisAnalysisSpecifications.andO;Feature:   illustrationchart.andO;Caption:   Functions are performed by or act on an entity. (chart)An entity-relationship diagram defines the problem domain. (chart)Corrections are suggested by the OOS rule checking program.andO;(chart)andM;</DESCRIPT><NOTE>Only Text is presented here; see printed issues for graphics.andO;</NOTE><TEXT>AN OBJECT-ORIENTED REQUIREMENTS SPECIFICATION METHOD This article describes amethod of analyzing requirements for object-oriented software.andP;  The method isintended to flow smoothly into design by object diagrams, [15], and fromthere into programming with Ada or another high-level language.andP;  Our methodis intended to serve as an alternative to structured analysis when the use ofobject-oriented design is foreseen.andM;We assume that the analyst who is using this method has a textual statementof requirements for a system available.andP;  Ideally, the analyst would alreadyhave distilled the requirements statement into a database of discreet,traceable requirements.andP;  This is not necessary for the method we describehere, but it is highly advisable.andP;  The steps we describe are part of a methodfor understanding and articulating the implications of the originalrequirements (whether in text or database form).andM;Structured analysis is the method most widely used for this purpose.andP;  So whynot use structured analysis instead of inventing a new method?andP;  To answerthis we must reflect on what structured analysis offers us.andP;  Structuredanalysis is a method of articulating functional requirements.andP;  Some--perhapsmost--of the initial set of requirements for a system will be functional,i.e., they will state that the system must accept certain inputs and delivercertain outputs.andP;  In structured analysis we attempt to clarify what suchstatements really mean.andP;  Processes are introduced to representtransformations of inputs to outputs.andP;  To ensure that all parties involved(customer, end-user, developer, etc.) have a common understanding of what isto be accomplished by the transformations, we decompose the processes.andP;  Foreach transformation of inputs to outputs we ask, What are the steps involvedin performing this transformation?andP;  Each step becomes a subprocess of thehigher level process.andP;  Thus, built into structured analysis is the followingprinciple of aggregation:andM;Functions are grouped together if they are constituent steps in the executionof a higher level function.andM;The constituent steps may operate on entirely different data abstractions (wewill see this in an example in the next section).andP;  If this is the case, thenfrom an  object-oriented viewpoint the subfunctions belong in differentobjects.andP;  The object-oriented principle of aggregation refers, unlikestructured analysis, to the underlying data:andM;Functions are grouped together if they operate on the same data abstraction.andM;In an object-oriented design, functions executed in sequence can reside indifferent objects.andP;  A chain of messages between objects effects the sequenceof operations.andM;Because of the difference in aggregation principles, proceeding from astructured analysis to an object-oriented design can be awkward.andP;  Since thecriteria for grouping functions are different in the two methods, thetransition from one to the other may require significant recasting of thedata flow diagrams.andP;  This is a laborious process, which can be avoided byassuming an object-oriented viewpoint during the analysis phase.andM;In our method the primary concept is that of entity rather than process.andP;  Aprocess in structured analysis may be a valid entity but the connotation ofentity is different.andP;  Our emphasis is not on the transformation of inputs tooutputs, but on the underlying &quot;content&quot; of the entity.andP;  We can think of thiscontent in several ways:andM;* Data structures that define the entityandM;* The underlying state of a process as it evolves in timeandM;* That aspect of a process that is persistent across repeated executioncyclesandM;Complementing our notion of entity is the notion of function.andP;  A function ispurely a transformation of inputs to outputs.andP;  It has no underlying statethat it remembers across successive invocations.andM;Through the distinction between entities and functions, our methodologyachieves a precision that is lacking in structured analysis.andP;  Every processin a structured analysis is, implicitly, either an entity or a function--butbecause the emphasis is on transforming inputs to outputs, we lack a means tofocus on the persistent aspect of entities.andP;  That is why the object-orientedprinciple of aggregation is not articulated in structured analysis.andM;In our method we retain the data flow diagram representation of inputs andoutputs.andP;  The idea of specifying data flow between entities is taken from theObject Dataflow Diagrams of Stark and Seidewitz.andP;  We use the term entity dataflow diagrams for the same concept.andP;  EDFDs are just like conventional DFDsexcept that the nodes fall into two categories: entities and functions.andO;Every function must occur in the context of an entity, i.e., it must beperformed by or act on the entity (see Figure 1, which uses a notationderived from Object Diagrams).andM;We distinguish between active and passive entities.andP;  Active entities arerepresented as diagram nodes, while passive entities appear as data flows ordata stores.andP;  Entity for us is synonymous with object (we tend to use entityduring the analysis phase and object during design).andM;Lower level EDFDs decompose each active entity either into subentities orinto functions performed by the entity (or into some combination of the two).andO;Functions may be decomposed into subfunctions.andP;  The resulting EDFD hierarchyconsists of an upper hierarchy of entities and subentities, a wavy line oflowest-level entities, and a hierarchy of functions and subfunctions beloweach lowest-level entity.andP;  This is illustrated in Figure 2.andM;An object-oriented specification consists of a hierarchy of EDFDs and a setof entity relationship diagrams.andP;  The entity relationship model serves as acontext for the specification.andP;  The E-R model provides both users andbuilders with a comprehensive view of the problem domain--and, possibly, sometechnology domains that are known to be part of the context of the system.andO;(Purists may reject the presence of technological considerations in arequirements analysis.andP;  We refer them to the discussion of entity domains andthe discussion of analysis vs.andP;  design, later in the article, for a defenseof our approach.andP;  A general discussion of the early stages of softwaredevelopment may be found in [10]).andM;DETAILED DESCRIPTION OF THE METHODandM;The specification method consists of seven steps:andM;(1) Identify key problem-domain entities.andM;(2) Distinguish between active and passive entities.andM;(3) Establish data flow between active entities.andM;(4) Decompose entities (or functions) into sub-entities and/or functions.andM;(5) Check for new entities.andM;(6) Group functions under new entities.andM;(7) Assign new entities to appropriate domains.andM;Although steps one through three are, in principle, performed only once, wemay backtrack at any time to reconsider these steps.andP;  Steps four throughseven should be iterated until the desired level of detail is reached.andM;Identify Key Problem-Domain EntitiesandM;Identification of the right problem-domain entities is crucial to thedevelopment of a stable design.andP;  There is no hard and fast way to define whatis (and what is not) a problem-domain entity.andP;  Part of the analysis processis to assess the consequences of including (or not including) potentialproblem-domain entities.andP;  Ask the following questions:andM;* Is every known functional requirement met by one of the entities?andM;* Is the internal state of the system adequately represented by the states ofthe entities?andM;An excellent discussion of these and related issues may be found in the firstchapter of Jackson's book System Development.andM;A heuristic procedure for identifying the problem-domain entities issuggested by Grady Booch in the first edition of his book, SoftwareEngineering with Ada.andP;  The procedure is to create a list of the key nouns andnoun phrases from the original (textual) statement of requirements.andP;  Such alist may serve as a first approximation to the problem-domain entities.andP;  Wemust take this heuristic with a grain of salt, however.andP;  Booch even omittedthe procedure from the second edition of his book.andP;  In a typical requirementsspecification there will be several nouns that are completely irrelevant tothe problem-domain entities.andP;  We must be highly selective when examining thespecification for key nouns.andM;A more realistic variation on this approach would be to locate the nouns andnoun phrases in the requirements database (if there is one).andP;  A requirementsdatabase distills the original textual statement into a set of traceablerequirements, in a form that is less verbose than the original statement.andP;  Inperforming such distillation, engineering judgment and selection are appliedto the original statement.andP;  The database therefore offers a better chance ofidentifying truly significant nouns.andM;A still more manageable approach draws on the process-orientation ofstructured analysis and helps to clarify the relationship between that methodand ours.andP;  The typical process name in structured analysis will take theform.andP;  action_object.andM;More often than not, the objects in such names refer to problem-domainentities.andP;  We have found it useful to draw structured analysis DFDs merely toextract the nouns from the process names.andP;  We do this repeatedly, throughoutthe seven steps of our method.andP;  The structured analysis DFDs are not part ofthe object-oriented specification--they serve only as intermediaterepresentations--but they are an effective way of identifying entities.andM;We draw an Entity-Relationship Diagram to record the problem-domain entitiesand their interrelationships.andP;  Figure 3 shows an ERD for an automated bankingapplication, which we will use as an example.andP;  As recommended by Stark andSeidewitz [16] we may also create an entity dictionary, which is analogous tothe data dictionary in structured analysis.andM;Distinguish Between Active and Passive EntitiesandM;The most natural distinction between active and passive entities is in thefollowing definition.andM;An active entity is one that operates on inputs to produce outputs.andP;  Apassive entity is one that is acted upon.andM;This is not the definition we use.andP;  The need for a slighlty differentdefinition arises from the following requirements:andM;* Active entities as should appear as processes, passive entities as dataflowsandM;* Every function must be performed by some entityandM;The first of these requirements provides us with a straightforward semanticsfor EDFDs.andP;  The second requirement is our insurance that the specificationwill be objected-oriented.andM;The problem is that passive entities may consist of more than just data: theymay provide a set of primitive functions for accessing the data.andP;  AbstractData Types (ADTs) such as lists and stacks are the best-known examples.andP;  Ifwe represent such entities as data flows, how do we represent the built-infunctions?andP;  More precisely, how do we represent both data and functions aspart of one and the same entity?andM;There is no problem if the functions are sufficiently low-level.andP;  Operationson an ADT my be primitive enough to warrant not including them inrequirements analysis--at least for large systems.andP;  Other operations onpassive entities (using the definition just given) may be essential tospecifying requirements though.andP;  We might, for example, want to sort a streamof elements input from a file.andP;  In structured analysis this is simple.andP;  Werepresent the sort as a process and the input stream as a data flow (Figure4).andP;  In OOS the process sort is in fact a function.andP;  It operates on a listelements with a built-in partial ordering relation, and returns a sortedlist.andP;  From an object-oriented viewpoint, sort is an operation provided by anentity whose underlying content is the list of elements (Figure 5, which usesan object diagram rather than EDFD notation).andM;The difference between Figures 4 and 5 illustrates in as concise a manner aspossible the difference between structured analysis and OOS.andP;  In Figure 4,the operation (sort) and the data stream (being sorted) are not packagedtogether.andP;  Sort appears as a standalone function.andP;  In Figure 5, the data andoperations are packaged together according to the object-oriented principleof aggregation.andM;In order to adhere to this principle, we need to represent entities such assortable list, as diagram nodes, i.e., active entities, rather than as dataflows.andP;  We choose to treat them as active entities despite the fact that theyperform operations on themselves.andP;  We consider them to be active because theyare doing something important (whether to themselves or to other entities).andO;The following definition expresses this approach:andM;An active entity is an entity whose functions we want to consider in theanalysis phase.andP;  A passive entity is one whose functions we do not want toconsider until the design phase.andM;For example, the active entities in Figure 3 are Customer and Account.andO;Customer is obviously active.andP;  Account might be considered passive withrespect to our original definition.andP;  To specify a banking system, however, wehave to consider the functions by which accounts are maintained.andP;  This leadsus to make Account an active entity in terms of our revised definition.andM;Establish Data Flow Between Active EntitiesandM;In this step we draw a top-level entity data flow diagram (EDFD).andP;  Eachactive entity is the ERD becomes a process in an EDFD.andP;  Passive entitiesshould appear as data flows or data stores.andM;The level-0 EDFD should contain the top-level active entities.andP;  The ERD doesnot explicitly distinguish between top-level and lower-level entities, so ifwe have not already made this distinction we will have to do so now.andO;Typically, the ERD may show relationships with names like &quot;contains&quot; or&quot;includes.&quot;andP;  This is an indication that a contained or included entity shouldappear in some lower-level EDFD, rather than at level 0.andM;The level-0 EDFD should contain only entities.andP;  This will ensure that everyfunction is provided by some entity.andP;  Lower-level EDFDs may contain bothentities and functions.andP;  We differentiate between entities and functions byplacing brackets around the name of an entity as shown in Figure 6a.andP;  This ismeant to be suggestive of the PAMELA notation for Abstract Data Types [8].andO;(In PAMELA, to indicate that a process is an ADT one encloses the name of theADT in a rectagle.)andM;Figure 6a illustrates a common phenomenon in OOS.andP;  The entity &quot;Customer&quot; alsoappears as an external.andP;  This indicates that the entity is a system (orsoftware) model of an external entity.andP;  The model serves as the interface tothe external entity.andP;  This principle is articulated as an explicit step inthe JSD methodology [12].andP;  We have found that it occurs naturally in theobject-oriented specification process.andM;We have defined some rules for ensuring mutual consistency between the E-Rand data flow models.andP;  One rule states that the entities in the two modelsmust correspond one-to-one.andP;  Another rule states that any relationship in theE-R model must be manifested, in some manner, in the data flow model.andP;  Thisrule is somewhat conjectural.andP;  We are not sure it is true, but we areinterested in understanding the extent to which it is not true (i.e., whattypes of relationships would not be manifested in a data flow model?)andP;  Thesection on pre-defined relational types addresses this further.andM;There are, it seems, only a few ways for a relationship to be manifested in adata flow model.andP;  Containment is one way.andP;  An active or passive entity (i.e.,andO;a process or data flow) may be contained in a higher-level active entity(process).andP;  A passive entity may also, in principle, be contained in ahigher-level passive entity, but we have no way of showing this in an EDFD.andO;An entity dictionary could be used for this purpose.andM;Data Flow is another way to manifest relationships in an EDFD.andP;  If a passiveentity is represented as a data flow into or out of an active entity, thereis clearly some relationship between them.andP;  If two active entities areconnected by a data flow then there is also some relationship present.andM;We have developed a program that executes these checks automatically.andP;  Asample run of the rule checker on Figures 3 and 6b yields the followingmessages:andM;The entity: Checks in the ERD: Figure3 does not appear in the DFD hierarchy: Figure6a.andM;Entity Account is a process, and entity Transactions is a dataflow, andAccount and Transactions are related, but Transactions is not contained in,nor is it an input nor an output of Account.andM;To eliminate these errors we revise the top-level EDFD to look like Figure6b.andM;The conjectural status of our relationship rule is not our reason for notusing the rule checker.andP;  The purpose of the rule checker is to ensure that wehave adequately addressed the consistency of the E-R and data flow models.andO;If relationships in the E-R model are not represented in the data flow model,the rule checker will report this; we are then free to decide that thesituation is acceptable or not, as the case may be.andM;Decompose Entities (or Functions) into SubentitiesandM;and/or FunctionsandM;Steps four through six form the heart of the OOS method.andP;  When performingstep four the first time, we decompose the top-level EDFD.andP;  Nodes in thisdiagram are all active entities.andP;  We decompose each active entity intosubentities and/or functions.andP;  The subentities are lower-level entities outof which the higher-level entity is composed.andP;  The functions (if there areany) are performed by the entity being decomposed.andP;  Figure 7, for example,shows a diagram that decomposes the Account entity of Figure 6b.andM;In subsequent passes through this step we decompose both entities andfunctions.andP;  An entity may be decomposed into subentities and/or functions.andO;Funtions, however, may only be decomposed into subfunctions.andM;To identify functions we consider what the entity does.andP;  As in step one, weask whether every known functional requirement can be met by one or more ofthe functions identified.andP;  We may also apply the same sort of heuristics thatwe applied in step one.andP;  For example, we might look for verbs and verbphrases in the initial (textual) requirements specification, or in therequirements database (if this exists).andP;  Some of the verbs may refer tofunctions that the system is supposed to perform.andP;  We emphasize, though, thatjudgment is required in selecting only significant verbs.andP;  The action_objectheuristic also applies.andP;  Prior to this point we may have applied thisheuristic to identifying entities.andP;  We drew structured analysis DFDs andextracted the object from each process name.andP;  We may now apply the sameheuristic to identifying functions.andP;  In this case the action becomes thefunction.andM;Check For New EntitiesandM;At each stage of decomposition, we must stop and ask whether any new entitiesare implied by the functions we have introduced.andP;  The action_object heuristicagain applies.andP;  For each function introduced through this heuristic in stepfour, we now consider the corresponding entity that was the object of theaction.andP;  More generally, regardless of the method used in step four, we canput all new function names into the form action_object, and examine thesenames for objects not previously identified.andM;For example, in Figure 7 we find a function with the labelTransfer_Funds_to_Other_Bank We see that Other_People's_Banks appears as anexternal but not as an entity within our system.andP;  We should consider, then,whether Other_People's_Banks should have an internal interface entity just asCustomer does.andP;  We should also consider whether Funds should be identified asan entity.andM;Data stores and data flows may have been introduced through step four.andP;  Theseare potential passive entities.andP;  We examine each new flow or store and askwhether it is significant enough to include in the E-R model.andP;  Some new flowsor stores may represent transformed versions of passive entities alreadyidentified, and in such cases we do not add a new entity.andP;  Exceptions arediscussed in the section on identification of passive entities undersuccessive transformations.andM;An active entity must be added unless it is already part of thespecification.andP;  Since we have been working with the data flow model, we firstadd the entity to an appropriate EDFD.andP;  (We will add it to the E-R model aswell, in step seven.)andP;  Deciding where in the EDFDs to place the new entity isnot always a trivial task.andP;  One alternative is to replace a function by a newentity.andP;  The function might then be placed one level down, below the newentity.andM;In our example, although Other_Banks was identified through the functionTransfer_Funds_to_Other_Bank, which is provided by Account, we would notplace Other_Banks under Account.andP;  This would not make any sense.andP;  Instead, wewould create Other_Banks, a new top-level entity, which would interface withthe external entity of the same name.andP;  The resulting top-level EDFD is shownin Figure 8.andM;We do not offer any guidelines for placing new active entities except to notethat the diagrams may have to be reorganized.andP;  It is in this step and thenext that we consider such issues as strength and coupling, informationhiding and visibility, and the quality of entity abstractions.andM;Reorganization of DFDs, as we noted in the beginning of this article, is theprecise difficulty in proceeding from a structured analysis to anobject-oriented design.andP;  We now see that our OOS method does not eliminatethis task.andP;  It simply distributes it over the course of the requirementsanalysis so that an object orientation is retained throughout.andP;  The sameamount of work may, in the end, be necessary (we are not sure of this), buteh force required is less because the structure is not allowed to become toobad (i.e., too functional) before being corrected.andM;Group Functions Under New EntitiesandM;Since we introduced new entities in step five, we must now identify all thefunctions performed by (or on) the new entities.andP;  This might mean making apassive entity active.andM;Checking for additional functions is a way of ensuring a faithfulrepresentation of entities.andP;  We call this feature functional completeness: itis characteristic of the object-oriented approach.andP;  It providesobject-oriented specifications (and subsequent designs) with stability underevolving functional requirements.andP;  By including all functions performed by anentity--whether they are immediately required or not--we increase the chancesof being able to respond to future functional enhancements with minimalrespecification and redesign.andP;  We also increase the probability of developingreusable components.andM;Besides checking for new functions, we need to examine the EDFDs and reassessthe placement of functions already present.andP;  We introduced new entitiesthrough step five.andP;  These new entities may now serve as the most naturalproviders of functions that were previously present (and provided by otherentities).andP;  In our example, we conclude that the functions *Receive_Incoming_Checks * Return_No_Good_Checks and *Transfer_Funds_to_Other_Bank, which were originally provided by the entityAccount, should now be moved under Other_Banks.andP;  We then consider whetherthere are other functions or atrribute data that should be part of thisentity.andP;  Figure 9 shows the resulting decomposition of Other_Banks.andM;The analyst must be open to reorganizing the EDFDs in this step.andP;  It is thisinteraction of entities and functions (i.e., entities providing newfunctions, functions suggesting new entities, and the consequent recasting ofdiagrams) that constitutes the life-blood of our method and that justifiesour inclusion of functinal decomposition within an object-oriented approach.andM;Assign New Entities To Appropriate DomainsandM;This last step is intended to help in managing the complexity ofproliferating entities.andP;  We recommend assigning each new entity (introducedthrough step five) to some domain.andP;  The domain may be new.andP;  In figure 9, forexample, further analysis of the external interface may lead us to specifystandard message formats from the domain of Electronic Funds Transfer (EFT).andO;Having established that EFT is an existing technology to be used in theapplication, the data flows between the internal entity Other_Banks and itsexternal counterpart may be assigned to the EFT domain.andM;If the E-R model is becoming complex, we may want to represent each domain ina separate diagram.andP;  This will prevent the original ERD (which represents theapplication or problem domain) from growing too large to visualize.andP;  The setof ERDs, taken together, provides a comprehensible view of the entities ofthe system.andM;We find it helpful to consider different levels of entity domains.andP;  Forexample, the following list describes a hierarchy of types of domains.andP;  Thisis a kind of &quot;virtual-machine&quot; hierarchy, in so far as higher-level domainsuse the domains at lower levels: (1) Application Domains (2) TechnologyDomains (3) Computer Science Domains (4) Execution Models (5) ExecutionDomainsandM;This hierarchy of domain levels was proposed by Ira Baxter of the Universityof California at Irvine--see references [4] and [5] for a discussion of theunderlying ideas.andP;  Baxter's work occurs in the context of the Dracomethodology, which is discussed by James Neighbors in [13] and [14].andM;During the specification phase we are most likely interested only in theapplication domain and, possibly, some technology domains such ascommunications, database management, signal processing, and graphics.andP;  As weapproach the design phase we may begin to address classes of algorithms andimplementation approaches.andP;  Computer Science domains provide the concepts forexpressing and analyzing such issues.andP;  For those who might argue that onlythe problem domain is relevant to requirements analysis, we refer to thelater section on analysis or design.andM;POSSIBLE EXTENSIONS OF THE METHODandM;In this section we discuss some aspects of requirements definition that wecannot, as yet, represent in an object-oriented specification.andP;  We arecontinuing to experiment with extensions and variations of the ERD and EDFDrepresentations in order to accommodate these aspects of system requirements.andO;A discussion of various representation mechanisms can be found in [7].andM;Identifying Passive Entities under SuccessiveandM;TransformationsandM;In the pipeline paradigm of data processing, a stream of elements is inputfrom some source, passed through a series of transformations and filters, andfed out to some sink.andP;  Extensions of this paradigm allow for more than onesource and more than one sink.andP;  It seems safe to say that this paradigm, inits extended form, underlies the thinking that led to structured analysis.andO;Structured analysis, however, has also been applied to systems not adequatelydescribed by the (extended) pipeline paradigm.andP;  Structured analysis hasencouraged this view of systems, and it has proven to be a useful view evenwhen other views are necessary.andM;One helpful feature of the pipeline view is that we can regard a data elementas undergoing successive transformations while still retaining its identity.andO;Unfortunately, the rules for Data Flow Diagrams discourage representing thiscontinuity explicitly.andP;  Each data flow must have a unique name.andP;  Usually itis just a visual feature of the diagram that allows us to infer the identityof a data element as it passes from process to process, i.e., we can see thedata passing through successive processes.andM;In structured analysis, seeing this is enough.andP;  In object-orientedspecification we correlate data flows with entities in the E-R model, and itis here that the naming rules pose a problem.andP;  As the method now stands wemust select one out of possibly several flows (related to each other by oneor more transformations), and decide that the selected flow, and not itstransformed versions, corresponds to the passive entity.andP;  It would be helpfulto be able to give all these flows the same name.andP;  This is discouraged instructured analysis because it suggests that the processes, which input dataelements and then output the same data elements, are not doing anything.andM;Another way to identify passive entities under successive transformations isto annotate the data flows.andP;  This amounts to giving them a second name whichwould not be subject to the uniqueness rule (i.e., more than one data flowcould have the same second name).andP;  We find this approach less than inspiring.andO;It does not make use of the expressive power of the EDFDs themselves.andP;  If anautomated drawing tool is used, annotation may or may not be possible.andP;  Evenif supported by a tool, annotations may not be visible while editing thediagrams.andP;  Providing data flows with aliases does not make the identity oftransformed data flows an integral part of the method.andM;It may be that a representation other than EDFDs is needed.andP;  This possibilityis further suggested by a question that emcompasses, but is broader than, theidentity of passive entities under transformation.andP;  The broader issueconcerns end-to-end service definition, and will now be discussed.andM;End-to-End Service DefinitionandM;The concept of service is found in many operational concepts.andP;  There areprobably as many definitions of service as there are of operational concept,but common to all definitions is an end-user orientation.andM;The concept of service can fit nicely into an object-oriented framework.andP;  Forexample, services are sometimes defined as groups of related functions.andP;  Thisis not a bad definition of objects, although for objects, it is usually somedata abstraction that serves to relate the functions with each other.andP;  Oneway to incorporate the concept of services into OOS is, therefore, toidentify services with entities.andP;  The name of the service often suggests theentity.andP;  In our banking example we might refer to an automated tellerservice, a customer support service, a loan service, a new account service,and others.andP;  As entities we could identify the automated teller, thecustomer, loans, and accounts.andM;Conversely, object-oriented principles imply the concept of services.andP;  As ablack box with a well-defined interface, an object is essentially a serviceaccess point (to borrow the terminology from open systems interconnection).andM;This approach identifies the service with its user interface (the user mightbe the end-user or another service or entity).andP;  There are, however, somedrawbacks to doing this.andP;  Identifying the service with its user interfacecomplicates the task of clarifying what the service does for the user.andP;  Muchof what the service does occurs behind the interface, and may not beperformed by the entity that provides the interface.andP;  This is a consequencesof the object-oriented principle of aggregation.andP;  Execution of a task mayrequire a chain of messages between objects as mentioned earlier.andP;  In orderto express end-to-end response time requirements we need to refer to suchchains explicitly.andM;Our representation provides no way to do this.andP;  In entity data flow diagramswe are limited to tracing data flows through a sequence of processing steps.andO;The sequence itself is not explicitly represented.andP;  Referring to the timebetween the call to an interface function and its return is not sufficient.andO;Through asynchronous processing, the output of a service request may bedelivered after the interface function has returned as displayed in Figure10.andM;A formalism such as R-Nets (part of M. Alford's SREM or Distributed ComputingDesign System methodology) can be sued to specify end-to-end processing ofservice requests [1].andP;  CTA uses a variant of this formalism, which we callcomposition graphs, to define end-user operational requirements.andP;  Figure 11shows a composition graph corresponding tothe EDFD in Figure 7.andP;  Theseformalisms are especially useful for specifying end-to-end response timerequirements and representing the budgets assigned to individual processingsteps.andM;Enriching the Entity-Relationship ModelandM;Our method uses entity relationship diagrams to provide a comprehensiblepicture of the problem domain and, perhaps, of some technology domains thatare assumed as a context for the problem.andP;  Most of the analysis processfocuses on the EDFD representation.andP;  We are considering ways to enrich theE-R model so that it plays a more substantive role in the analysis process.andO;The enrichments we will describe would provide greater isomorphism betweenthe E-R model and the data flow and object diagram models.andM;Pre-Defined Relationship TypesandM;In Section 2.3 we conjectured that relationships in the E-R model should bemanifested somehow in the EDFDs.andP;  We also described two ways in whichrelationships may be manifested in the EDFDs, i.e., through containment orwith data flow.andP;  Reserving names for these types of relationships would givethe ERDs more precise semantics, and would enable us to check more preciselythe consistency of the E-R and data flow models.andM;If our conjecture is false, there is all the more reason to reserve names forthese relationship types.andP;  By restricting the requirement for manifestationin an EDFD to these relationship types, we would remove the rule'sconjectural status.andP;  We could also explore the possiblity of otherpre-defined relationship types, (e.g., uses, inputs, outputs).andP;  The intentionwould not be to restrict all relationships to one of these types, but ratherto make these pre-defined types available and thereby enrich the semantics ofthe ERDs.andM;An alternative to reserved names is to recognize grammatical classes ofrelationships.andP;  For example, we could distinguish between transtive verbs(such as updates) and intransitive predicates (such as is part of).andP;  It mightbe possible to define rules that govern how much relationships are manifestedin the EDFDs based on their grammatical class.andP;  For example, we might be ableto infer whether an entity is active or passive based on the types ofrelationships it has with other entities.andM;Functions as Attributes of EntitiesandM;Functions immediately below the wavy line in Figure 2 are the operationsprovided by entities.andP;  The entitles are above the wavy line.andP;  In Smalltalkterminology the operations are known as methods.andP;  In object diagrams, theyare listed as annotations to the objects.andP;  The object's methods appeartogether with its visible state variables and data types as shown in Figure12.andM;In the terminology of an E-R model, state variables are attributes of anentity.andP;  Since an entity (object provides functions (methods) as well asstate variables, it seems reasonalb eto view these functions as attributes ofthe entity.andP;  We could use the standard notation for attributes to specifywhat functions each entity provides.andM;Specifying functions as attributes of entities would provide a more precisesemantics for the E-R model.andP;  It would also provide another way to check forconsistency between the E-R and data flow models.andP;  Every functional attributeof an entity would have to appear as a function in the EDFD that decomposesthat entity.andP;  Every data-valued attribute of an entity would have to appearas a data store in the EDFD.andP;  (This last rule could also be applied to a moreconventional ERD semantics in which all attributes are assumed to bedata-valued.)andP;  A drawback to specifying functions as attributes is thepossibility of cluttering the ERDs.andM;Relationships Between DomainsandM;We have spoken of a hierarchy of domains with the problem domain at the top.andO;Under the problem domain are one or more technology domains, and under theseare the Computer Science domains.andP;  A domain at any level of this hierarchymay employ entities belonging to lower-level domains, as well as entitiesbelonging to other domains at the same level.andM;There are two ways in which one domain can employ another: messages andcontainment.andP;  Messages are the means by which one entity invokes an operationprovided by another entity.andP;  Containment refers to the decomposition of anentity belonging to a higher-level domain into entities belonging tolower-level domains.andP;  For example, the problem domain entity transactionmight be represented in terms of standard communications protocol data units.andM;In either case, the relationship between entities in different domainsamounts to a relationship between the domains themselves.andP;  It might be usefulto represent these relationships in a high-level ERD whose entities would bethe domains themselves.andP;  The high-level diagram would provide a globalpicture of the domains that form the context of the problem.andM;It would also be useful to represent cross-domain relationships in thedomain-specific ERDs.andP;  This could be accomplished by introducing &quot;off-edge&quot;relationships, which would connect entities in different diagram (Figure 13).andM;The State-Transition ModelandM;Entities have evolving states, distinguishing them from functions.andP;  Modelingentities as state machines seems a natural way to incorporatestate-transition semantics into an OOS.andP;  This is the approach taken by Hatleyand Pirbhai, although they still speak in terms of processes rather thanentities.andM;The difficult question is how to correlate state-transitions with the dataflow model.andP;  The most obvious answer is to identify selected data flows withevents.andP;  For example, if a data flow corresponds to a specific interruptsignal, then this is a reasonable approach.andM;In other contexts, however, different values of the same data flow maycorrespond to different events.andP;  This is the case whenever the processinglogic takes conditional branches depending on the value of the input data,and the different branches result in different state updates.andP;  In some cases,ranges of values for a given data flow can be identified with differentevents.andP;  In such cases we can represent the state-transition logic in an EDFDby assigning a different function to handle the data in each range.andM;If events cannot be correlated with either data flows or ranges of data flowvalues, then the relationship between the two models must be left implicit.andO;This, at any rate, is our current view.andP;  We are continuing to experiment withideas for mapping between the two views.andM;ADDITIONAL ISSUES AND CLARIFICATIONSandM;We will address some of the questions posed when explaining the OOS method.andO;These points are not crucial to understanding the method, but we have foundthat a satisfactory answer goes far in increasing people's confidence in ourapproach.andM;System or Software Requirements?andM;We developed the method with software in mind--specifically Ada--but webelieve it applies equally well to specifying requirements ofhardware/software systems.andP;  At some point the question of hardware/softwareallocation must be addressed.andP;  An entity may be allocated to hardware, tosoftware, or to a hardware/software combination.andP;  Allocations to hardware andto software must be preserved under decomposition.andP;  A subentity of a hardwareentity must be hardware; a subentity of a software entity must be software,and the same is true for functions.andP;  A subentity or subfunction of a combinedhardware/software entity (or function) can itself be a hardware/softwarecombination, or just hardware, or just software.andP;  This is illustrated inFigure 14.andM;Is the Method New?andM;The answer is both yes and no.andP;  Under the guise of structured analysis,engineers have been doing object-oriented specification for years!andP;  Look atthe requirements specification for a system of any significant size, and seewhether or not the data flow diagrams contain all the meaninglesspseudo-action words that structured analysis purists warn against: * Control* Manage * Monitor * Handle and others.andP;  How many times have we and ourcolleagues struggled over finding more expresive action words; yet thepseudo-actions seem appropriate, and the reason is that the substance is notin the action but in the object.andM;Analysts have tacitly chosen to specify and decompose entities whenappropriate, disguising them as structured analysis processes.andP;  It is in suchsituations that strength and coupling questions are addressed.andP;  We have oftenwondered about strength and coupling metrics for data flow diagrams, eventhough such considerations should really not occur in pure structuredanalysis.andP;  Refer back to the aggregation principle of structured analysis,which we summarized in the first part of this article.andP;  If functions are tobe grouped according to their place in the execution of a higher-levelprocess, then strength and coupling considerations are irrelevant.andP;  Again wesee object-oriented principles creep into what are ostensibly functionaldecompositions.andM;Unfortunately, counting data flows--the basis of conventional strength andcoupling measurements--is not necessarily the best approach to assessingstrength and coupling of objects.andP;  Principles of data encapsulation andinformation hiding are, perhaps, more germane.andP;  This is one argument fordefining a method that is patently object-oriented.andM;Another argument for OOS is that by applying such principles consciously,rather than by accident, a more consistent product is likely to result.andM;Is it Analysis or Design?andM;The conventional wisdom is that analysis addresses what and design addresseshow.andP;  We find this insight valid but infuriating.andP;  It contains some importanttruth, but it ignores some subtle issues.andP;  To begin with let us observe thatin structured analysis one often regroups functions.andP;  This may occur foreither of two reasons: * Strength and coupling considerations * Alternativedecompositions of a processandM;We have already acknowledged that strength and coupling considerations shouldnot occur in pure structured analysis.andP;  Alternative decompositions are,however, a legitimate concern--even in pure structured analysis.andP;  Totransform inputs andless;i1, i2, ...andgt; into outputs andless;o1, o2, ...andgt; there may beseveral different sequences of steps that can be taken.andP;  There may be manycriteria that suggest one decomposition over another, (e.g., organization ofthe user's institution, reusability, or extensibility).andM;We should not delude ourselves into thinking that structured analysis merelymakes explicit what is already implicit in the original statement ofrequirements.andP;  Structured analysis adds content.andP;  We must therefore considerthe difference between adding content in answer to what (analysis) and addingcontent in answer to how (design).andM;The difference lies in the distinction between problem and solution domains.andO;If the additional content refers to a domain that the customer does not viewas part of the problem (or as part of the problem's context), then theadditional content is content about how.andP;  A technology domain such ascommunications may be part of the customer's perceived context of theproblem.andP;  In such cases there may be requirements that dictate the use of aparticular communications network.andP;  The customer's reasons for this could beorganizational and completely independent of technical considerations.andP;  Butif the customer is oblivious to how information travels from one host toanother (or even that there are multiple hosts), then the communicationsnetwork is part of the solution, not of the problem.andM;The builder may convince the customer that processing loads necessitatedistributing the work over multiple hosts, and that a specific type ofcommunications network is the only viable technology for transferringinformation within the stated response-time constraints.andP;  The customer mayeven be convinced to weaken the response-time requirements.andP;  In such a casethe revised performance requirements are still what (this is how design canimpact requirements in an iterative development lifecycle), but thecommunications network is still how because the customer does not especiallywant the network, he is only willing to accept the network as a solution.andM;We must now ask into which category the product of our OOS method falls: theproblem (what) or the solution (how).andP;  Looking back over the seven steps wecan see that nowhere is a solution introduced.andP;  When we decompose an entity,we ask what the entity does and what it consists of.andP;  Both of these questionshelp define the entity more precisely.andP;  This can, potentially, turn into aquestion of how, if, for example, we decompose the entity into low-levelbuilding blocks that belong to some solution domain.andP;  This is the point atwhich analysis should end and design should begin; but not all subentitieswill be of this sort.andM;Deciding which functions to group under which entities may seem like a designactivity, but it is based on our understanding of what the entity is (andhence what it does).andP;  We recast entity data flow diagrams only to achieve amore accurate representation of the entities.andP;  If, therefore, we limitourselves to entities that are part of the problem (not the solution), therecasting of diagrams serves only to better articulate the requirements.andM;Transition from Analysis to DesignandM;We have developed a design generator tool which reads a hierarchy of EDFDsand outputs a hierarchy of object diagrams.andP;  Prior to invoking the generator,the developer is supposed to annotate the EDFDs with some additionalinformation.andP;  Default assumptions allow the generator to work even if theannotations are not present.andP;  To achieve a reasonable first cut at a design,however, the developer ought to consider the following issues: * Direction ofcontrol flow * Concurrent processing threads * Abstract Data Types * ReusablefunctionsandM;The default assumption for the direction of control flow is that control flowand data flow are in the same direction.andP;  If there are data flows in bothdirections between two entities or functions, this assumption will cause theresulting objects in the object diagrams to call (or use) each other.andP;  Inmost cases this is not the intended result.andP;  To indicate that control flow isin the opposite direction of a data flow, the developer annotates the dataflow by placing a question mark (?) in front of the data flow label as shownwith &quot;Debits&quot; in Figure 15.andM;The design generator maps entities in an EDFD to ordinary objects in anobject diagram.andP;  Ordinary objects correspond to Ada packages.andP;  The oppositeof an ordinary object is a degenerate object.andP;  Degenerate objects correspondto Ada tasks and procedures.andP;  The highest layer of functions in the data flowmodel (those lying just below the wavy line in Figure 2) are mapped by thedesign generator to degenerate objects.andP;  Lower-level functions are not mappedinto the object diagrams at all.andP;  These lower-level functions correspond tosubprograms of Ada procedures and tasks.andP;  They are not part of theobject-oriented view of the design as represented in a set of objectdiagrams.andP;  By default, the highest-level functions are converted intoprocedure objects.andP;  If the function represents an independent thread ofcontrol then it should be mapped to a task rather than a procedure.andP;  Thedeveloper indicates this by placing a pound sign (#) in front of the functionname (in the EDFD).andM;Passive entities in the object-oriented specification are represented as dataflows (or stores) with square brackets ([ ]) around the data flow (or store)label.andP;  Before executing the design generator, a final check should be madefor instances of abstract data types.andP;  An ADT that belongs to a ComputerScience domain, for example, would not be identified in the OOS.andP;  Data flowsthat are instances of such an ADT would not be marked as entities.andP;  To ensurethat the ADT does appear in the design, the developer should now annotate thedata flow by placing a left-hand square bracket in front of the label.andP;  Thedesign generator will create and place the ADT in the top-level objectdiagram, and will adjust all flows accordingly.andM;Functions that are potentially reusable (within the present or futuresystems) are identified by placing an ampersand (andamp;) in front of the functionlabel.andP;  Such functions may lie more than one level below the wavy line ofFigure 2.andP;  The design generator collects all such functions and places themin an object created for this purpose in the top-level object diagram.andP;  Flowsare adjusted accordingly.andP;  This placement of the reusable functions ensuresthat they are potentially visible to other objects in the system, as well aspotentially importable to other systems.andP;  We assume that in the final designthe single object containing these functions will be split into multipleobjects, depending on the nature of the reusable functions.andP;  Collecting theminto a single top-level object is just an intermediate step, which is takento ensure their visibility.andP;  The object diagrams created by the designgenerator are intended to serve only as a first cut.andM;Data Flow vs.andP;  Control FlowandM;Should we have incorporated control flow more fully into the OOS? Thequestion mark notation described in the previous section clearly subordinatescontrol flow to data flow.andP;  Control flow is in fact a hybrid concept,encompassing two distinct aspects of a system: * Sequencing of events (flow)* Control hierarchy (who calls whom)andM;Sequencing is relevant to any method in which functional requirements areanalyzed.andP;  Sequencing is implicit in a functional decomposition (even in DataFlow Diagrams) because inputs must be available before outputs can beproduced.andP;  Sequencing is a necessary concept in specifying operationalscenarios for a system.andP;  Our comments on end-to-end service definitionsuggest that such scenarios are a necessary complement to OOS (as seenearlier in the &quot;End-to-End Service Definition&quot; section).andM;The question mark notation does not tell us anything about sequencing.andP;  Ittells us about a control hierarchy, which may need to be specified inarticulating operational requirements.andP;  Many Operational Concepts definelayers of services by means of a hierarchy of control.andP;  The very notion of anobject as a provider of services suggests that OOS should enable us torepresent such information.andP;  Real-time system specification requires a cleardefinition of stimuli and events, receptors and actors.andP;  Including suchinformation in the data flow model would increase the overlap between thatmodel and the state-transition model.andP;  This greater overlap between viewsmight promote consistency and soundness of the specification.andM;We may ask, therefore, why data flow is given predominance in our approach.andO;There are those who argue that while control flow is sometimes important,data flow is always important because functional requirements--that mostbasic starting point for a requirements analysis--refer to inputs andoutputs, which are nothing but data flows.andP;  The requirements in their initial(textual) form refer to system inputs and outputs.andP;  Internal inputs andoutputs arise during functional decomposition, which we have described as away of clarifying the content of the original functional requirements.andO;Functional decomposition also carries with it the concept of sequence,however, and we have already noted that some amount of sequencing is impliciteven in the data flow model.andM;Our position on this issue is inconclusive.andP;  Our own motivation forconcentrating on data flow had more to do with practical considerations thanmethodology.andP;  We wanted to use a representation method with which mostanalysts were already familiar, and DFDs fit that bill.andP;  We must admit thatfocusing on data flow between entities is uncomfortable for us.andP;  We do seeentities as objects with well-defined interfaces and therefore as serviceaccess points.andP;  To ignore this during requirements specification feelsunnatural to us.andP;  The question mark notation does, however, give us a meansof specifying hierarchies of control, and for us this is an acceptablecompromise.andP;  Further use of the method will perhaps confirm our decisions or,if not, then suggest alternatives.andO;</TEXT></DOC>