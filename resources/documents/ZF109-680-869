<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF109-680-869  </DOCNO><DOCID>09 680 869.andM;</DOCID><JOURNAL>IBM Systems Journal  Dec 1990 v29 n4 p539(12)* Full Text COPYRIGHT International Business Machines Corp. 1990.andM;</JOURNAL><TITLE>Extension of the relational database semantic processing model.andO;(technical)</TITLE><AUTHOR>Hirao, Takayuki.andM;</AUTHOR><SUMMARY>A data model consists of three parts: (1) a data definition thatrepresents the information in an understandable manner; (2) adefinition of the constraints that must hold for the informationto be valid; and (3) a definition of operations that can beperformed on the information.andP;  Current database management systemsdo not allow explicit specification of all three parts of the datamodel.andP;  This paper gives an approach that extends current databasemanagement systems through a technique called pre-precompilation.andO;(Reprinted by permission of the publisher.)andM;</SUMMARY><DESCRIPT>Topic:     Relational DBMSElectronic Data ProcessingModelingData Base ModelsData Base Design.andO;Feature:   illustrationchartprogram.andO;Caption:   The recursive process using KT. (chart)Results of the pre-precompiler. (program)Types of data. (chart)andM;</DESCRIPT><TEXT>A  deductive database is proposed as a solution for recursive or semanticprocessing, utilizing the advantages of both relational and knowledge-basedsystems.andP;  The following introduction focuses the reader's understanding onthe parts of a relational data model and states the need for extensions.andP;  Therelational data model discussed in Reference I consists of the followingthree parts: (1) a structural part that represents information in the form ofa table; (2) an integrity part that applies the constraints on the table;&quot;'and (3) a manipulative part that operates on the table.andP;  These three partsare shown in Figure 1.andP;  The following are the characteristics of eachcomponent.andP;  The structure of the information translates into the format of atable, in which the elements may represent such entities as concepts, events,or objects.andM;Although the table is simple, it is difficult to represent as a treestructure.andP;  A tree structure is a convenient way to represent ageneralization, a specialization, or an aggregation.andM;Integrity constraints assure that information is correct as regards itscreation and the operations that use it.andP;  Integrity constraints are alsoimportant with respect to the semantics and maintenance of data.andP;  Therefore,we have to define precisely the integrity constraints at the time of thecreation of a structure.andP;  Typical examples of integrity constraints are theISA relations, which are functional dependencies, and the domain constraint,which relates to the properties of a value.andP;  The term ISA is aself-referential term meaning &quot;is a,&quot; and is used in the sense of &quot;is arelation.&quot;andM;The manipulative part defines the four types of operations for tables:selection, insertion, deletion, and updating.andP;  The Structured Query Language(SQL) has been the standard manipulative language for the relational databasemodel since 1986.andP;  7andM;Relational database requirements become increasingly complex each year asinformation processing technologies increase in function.andP;  Some of theserequirements cannot be implemented using relational database technologies.andO;For example, manipulations of the engineering data in a CAD/CAM environmenthave to process tree structures or recursion.andP;  However, it is difficult to dothese operations, because values of attributes in a relational database areconstrained to be atomic values.andM;Therefore, we need manipulation based not only on the data alone but also onrelationships among the data, that is, on the semantics of the data.andP;  Topursue the operations that are the subject of this paper, researchers proposenew data models such as the Non-First-Normal-Form model (NF2) and a deductivedatabase model.andP;  We define the deductive database model later in this paper.andO;The aims of the NF2 model and the deductive database are to establishcapabilities of recursive or semantic processing.andP;  That type of dataprocessing cannot be achieved using current database management systems.andM;This paper discusses characteristics and limitations of the following threecurrent database management systems: (1) those based on the hierarchicalmodel; (2) those based on the network model; and (3) those based on therelational model.andP;  We then propose new techniques to overcome the limitationsin using the concept of the deductive database.andP;  However, we still usecurrent technologies, such as the relational database, conventionalprogramming languages, and so on.andP;  Next we discuss the semantics in databaseprocessing and propose techniques of resolving limitations of integrityprocessing, recursive processing, and the handling of ambiguous (or fuzzy)data.andM;Conventional databasesandM;In order to provide basic knowledge about database management systems andknowledge-based systems, we first review three conventional databasemanagement systems and their data models-the hierarchical, network, andrelational models.andP;  The hierarchical model represents information in the formof a tree, in which it is easy to understand the relationships among higherand lower information.andP;  Each box shown in Figure 2A is called a segment andsegments are linked by pointers.andP;  These pointers facilitate the capabilitiesof the referential integrity constraints.andP;  The hierarchical model producesduplicated segments, as, for example, box E in Figure 2A.andM;The network model represents information in the form of a network.andP;  Each boxin Figure 2B is called a record and is linked with every other box with linksthat realize some capabilities of referential integrity.andP;  The network modeldoes not produce duplicate records.andM;The relational model represents information as a table.andP;  This model may beimplemented easily on a workstation as well as on large mainframe systems.andO;Each box shown in Figure 2C is called a table.andP;  Relationships among tablesare established by columns having values in common between pairs of tables.andO;Referential integrity in a relational model, such as DATABASE 2- (DB2-)Version 2, is realized with the definition of the table using a FOREIGN KEYphrase in the CREATE Statement.andP;  16 The relational data model producesduplicated columns because of their foreign key, as in the example of the 2and 3 in Figure 2C, table E.andM;Conventional database management systems and their data models havecharacteristics as summarized in Table 1, from which we can extract problemsof each model as follows.andM;Data redundancies.andP;  The relational model and the hierarchical model haveredundancies of data, which is obvious from Figure 2.andP;  (See, for example, Ein the hierarchical model and 2 in table E in the relational model.)andM;Lack of constraint representation.andP;  There are three types of constraints: (1)domain constraint, (2) relation constraint, and (3) referential constraint.andO;The domain constraint is that an attribute value should meet certainconditions.andP;  For example, the character length for an employee number is 5.andO;These constraints are not specified explicitly in the three database models,except for predefined data types, such as date, integer, etc.andP;  Relationconstraints control the attributes in a tuple.andP;  For example, the maximumsalary of a person whose age is under 30 must be less than a specifiedamount.andP;  These constraints are not supported by the hierarchical model andthe network model.andP;  In the relational model, one can specify such a conditionby the WITH CHECK OPTON in the CREATE viEw statement.andP;  The referentialconstraint is that the value in the foreign key must be the same as theprimary key in the referenced table.andP;  The relational model can specify thereferential constraint in the CREATE TABLE Statement, which has already beenmentioned.andM;Limitations of operational capability.andP;  The hierarchical and network modelshave been used for a long time.andP;  In those models, we can manipulate only onesegment or record at a time by the host programming language via an accesspath that is predetermined in the database system.andP;  On the other hand, SQL inthe relational model environment is a user-oriented language that isexecutable interactively or through the host programming language.andP;  Therelational model is also able to manipulate many tuples at a time (called aSET Operation) by means of automatic navigation.andP;  However, SQL cannot processrecursively, and the three models cannot do inferencing the way it is done inartificial intelligence  Al) processing.andM;Semantics in a database and its processing Semantics in a database isdiscussed mostly in the area of a database design.andP;  One example is that ofconceptual modeling-classification, aggregation, and generalization.andP;  Theseaspects are incorporated in such semantic data models as SHM, RM/T, SDM,TAXIS, and IFO.andP;  One of the aims of semantic data models is that of integritymaintenance, whereas only the referential integrity is supported in currentdatabase management systems.andP;  Other aims of semantic data models are those ofextending the capability of data manipulation (such as recursive processing)and the processing of incomplete information.andP;  This paper focuses on theprocessing of the semantic differences between data types by means ofintegrity maintenance, recursive processing, and the processing of ambiguousdata.andP;  Processing details are discussed in later sections of this paper.andM;As a basis for later discussion, we briefly mention characteristics ofrelational database systems and knowledge-based systems.andP;  Currently, arelational database system is a database management system that maintains thestatic business data and provides for full recovery, restart, and so on.andO;However, a relational database system does not provide for recursiveprocessing.andP;  A knowledge-based system, on the other hand, is an applicationcomposed of a knowledge base of facts and rules that use the flexibleprocessing of recursion or inference formation.andP;  However, a knowledge-basedsystem is limited in its use as a database system.andP;  Table 2 summarizes theadvantages and disadvantages of relational database systems andknowledge-based systems.andM;By combining the advantages of both systems, we can overcome thedisadvantages of the relational and knowledge-based systems.andP;  We can considerthe relational database system as a database management system that maintainsstatic data, and we can consider a knowledge-based system as an applicationsystem that exploits the capabilities of a relational database managementsystem.andP;  Toward a new database systemandM;Because relational database systems and knowledge-based systems havecharacteristics that complement each other, we can construct a new databasemanagement system that can expand the capabilities of a database managementsystem and knowledge-based system.andP;  Let us consider the new database systemas a deductive database system because it uses a knowledge base.andP;  This newdatabase system has the following four characteristics:andM;* It is based on first-order predicate logic.andM;* It can manipulate incomplete or ambiguous information.andM;* It can make inferences using facts and rules.andM;* It can maintain the integrity of data.andM;Figure 3 represents the relationship between the relational database and theearlier deductive database.andP;  There are three ways to implement the newdeductive database: The advanced database shown in Figure 4 adds new functionto the relational database to enable new capabilities of semantic processing,including recursion and inference.andP;  This approach need not change existingprograms, which is a great advantage.andP;  However, the current database does nothave these capabilities.andP;  Many researchers propose new data models, such asthe NF2, the semantic data model, and the deductive data model.andM;Table 3 summarizes the characteristics of these three models.andP;  Each datamodel shown in Table 3 has two types of data, one is data itself and theother is metadata, which describe characteristics of real data.andP;  Theproperties of the data and metadata are shown in Figure 5.andM;Metadata incorporate the following five definitions:andM;* Schema defines the table, the column and its domain name, the primary key,and the foreign key.andM;* Domain defines data types and characteristics of the domain.andM;* Structure defines the relationships among tables or columns in the sametable.andM;*  Constraint defines the referential integrity and the relation integrity.andM;*  Operation defines the alert and trigger that are executed at the time of aspecial event; operation also defines procedures that are used forinferencing.andM;The meaning of soft and hard data is as follows.andP;  Soft data are ordinary datathat are manipulated by users.andP;  Hard data are new types of data, typicallyhistorical data, that require control information that is stored in softdata.andP;  For example, CAD/CAM data are hard data that require information ofthe creator, the dates of any modifications, and their relationship to otherCAD/CAM data in soft data.andP;  Figure 6 shows an example of metadata.andP;  Theimportant fact is that we can manipulate both metadata and soft (natural)data in a consistent way.andM;The logic database shown in Figure 7 adds database function, multiprocessingcapability, and the functions of recovery and restart to the logicprogramming language.andP;  The logic programming language can do recursiveprocessing.andP;  Therefore, it is easy to implement a logic database.andP;  However,there are some limitations.andP;  The database space is limited to the memory ofthe running address space.andP;  Existing programs must be changed in order toaccess a logic database.andP;  We have to create the interface routine forcoordinating a conventional programming language and a logic programminglanguage.andM;The compromise approach shown in Figure 8 benefits from the advanced databaseand logic database approaches in that it incorporates cooperation betweenrelational databases and the logic programming language.andP;  Although theoverhead of this approach may be less than that of the logic databaseapproach, it is greater than that of the advanced database approach.andO;Therefore, we should consider that this approach is a step in the migrationto an advanced database approach.andP;  This paper discusses a compromise approachbecause of its implementability at the present time.andP;  Thus we shall discusssemantic processing, recursive processing, and the processing of ambiguousdata.andM;Semantic processingandM;Integrity constraints.andP;  One of the aims of a deductive database is that ofintegrity maintenance-referential integrity and relation integrity.andP;  Currentrelational database systems cannot define the integrity rule among dataexplicitly, except for referential integrity, which is realized in DB2Version 2.andP;  Therefore, it is difficult to maintain data integrity.andP;  To havethe capability of integrity maintenance, SQL should have the new functionsshown in Table 4.andP;  New functions of constraint checking are essential inorder to develop a new deductive database.andP;  In this section, we discuss atechnique that can maintain the integrity among data in a relationaldatabase.andP;  A database that uses this technique can maintain consistency andreduce redundancies in the database.andM;The double precompiling technique.andP;  In order to process semantics, we mustspecify such semantic information as integrity constraints.andP;  To do this, weuse a special table named a semantic table, which contains the information ofintegrity constraints.andP;  That information will be created by a table creator,using the SQL INSERT Statement or the data load utility supplied by DB2.andM;To illustrate, consider the example employee table shown in Figure 9.andP;  Thistable has some integrity constraints.andP;  For example, the column AENO, whichmeans the administrative employee number, is the foreign key of the columnEMPNO.andP;  The AGE Value must be greater than or equal to 25 and less than orequal to 50, and so on.andP;  We can now incorporate the integrity-constraintsinformation into the semantic table shown in Figure 10.andP;  This figure showssample data for the employee table in Figure 9.andP;  The semantic table will beused twice-at pre-precompile time and at the execution time of the userprogram, which is shown in Figure 11.andM;Semantic processing is executed in the following sequence of steps.andM;Program coding.andP;  First, code the program using new statements, instead of thestandard SQL Statements for the input of the pre-precompiler.andP;  In this paper,we use the symbol $ preceding standard SQL Statements, by which they arerecognized by the preprecompiler as statements for semantic processing.andP;  Thusthe $INSERT Statement is used for semantic processing rather than thestandard INSERT Statement.andM;Pre-precompile.andP;  The program prepared in the first step is pre-precompiled,which translates the statements with the $ character into standard SQLstatements plus some other statements that are needed for semanticprocessing.andP;  This process uses information in the semantic table.andM;Normal processing.andP;  The conventional relational database system has to donormal processing, which includes precompile, compile, and link edit.andP;  Thisincludes an interface routine supplied by the new deductive database system.andM;Here we present two examples using the KnowledgeTool-, which is anIBM-supplied artificial intelligence Al) tool based on PL/l.andP;  KnowledgeTool(KT) is used for implementing expert systems.andP;  We use the KT in the newdeductive database system because that system requires knowledge-basedprocessing.andP;  The function to be performed by the program is to update theemployee table by inserting the data for a new employee.andM;Given:andM;$INSERT INTO EmployeeandM;VALUES ('A0015','T.andP;  HIROTA',andM;'C001','A0002',25000,25)andM;Translation:andM;Allocate A for the semantic table.andM;Allocate B for data to be inserted.andM;WHEN(S1-andgt;Aandamp;andM;S2- andgt; B  S2- andgt; AGE andgt; S 1- andgt; DOWN,andM;S2- andgt; AGE andless; S1- andgt; UPandM;BEGIN;andM;EXEC SQL INSERT INTOandM;Employee VALUESandM;END;andM;This semantic processing checks age restrictions.andP;  Nc.:,, delete informationof the employee number A0008 from the table in Figure 9.andP;  Given:andM;$DELETE FROM EmployeeandM;WHERE ENO =  'A0008'andM;Translation:andM;Allocate A for the semantic table.andM;Allocate B for conditions of DELETE.andM;WHEN (S1 - andgt; A (S1 - andgt; FKEY =  Yes') andamp;andM;S2- andgt; B (S1 - andgt; REFF = S2- andgt; TNAME)andM;BEGIN;andM;EXEC SQL DELETE FROM EmployeeandM;WHERE EMPNO =:S2- andgt; EMPNO;andM;EXEC SQL UPDATE :S1 - andgt; TNAMEandM;SET:S1 - andgt; FKEY = NULL;andM;END:andM;This processing uses referential integrity.andP;  In this case, the DELETE rule isSET NULL.andM;Execution.andP;  We can execute the program, which is pre-precompiled andcompiled.andP;  Although we use KT, this pre-precompile approach may be adapted toa traditional programming language such as PL/I or COBOL.andM;Recursive processingandM;Defining recursive processing.andP;  When a relation R(a,b) exists between theitems a and h and a relation R(b,c) exists between the items h and c, a newrelation R(a,c) is also established.andP;  The relation R(a,o is called thederived relation.andP;  This derived relation is represented by the decision treeshown in Figure 12.andP;  The process of tracing the decision tree is known asrecursive processing and is included in such Al architectures as PROI,OG.andO;Using PROI,OG, we can derive c from a as indicated in Figure 12.andP;  However,current relational database systems have to record the relation R(a,c) asshown in Figure 13, because relational database systems cannot do recursiveprocessing.andP;  If we can perform recursive processing, we can derive therelation without storing redundant data in the database.andP;  We now discuss thenecessity of recursive processing and its implementation in a relationaldatabase environment.andM;The necessity of recursive processing.andP;  Consider the parts-relation shown inFigure 14, which is a typical relation requiring recursive processing as inthe case of a bill-of-materials overview for all parts of a certain product.andO;This type of relation is suitable for representing a hierarchical database,because the parts relation is represented hierarchically.andM;To avoid the complication of specifying the way to enter a certain recordinto a hierarchical database.andP;  we should migrate from the hierarchicaldatabase to the relational database gradually.andP;  However, it is difficult tostore parts records in a relational database efficiently.andP;  Currently, we usean identifier that enables us to recognize the hierarchical relationship ofparts to one another, and we add logic that manipulates the identifier in theprogram.andP;  This is the way we develop applications that can trace thehierarchy upward or downward, using the identifier and adding the capabilityof recursive processing to a relational database.andM;The implementation of recursive processing.andP;  In order to do recursiveprocessing, we have to declare the information of recursiveness in some tableR, and we have to code in a special form that specifies recursion.andM;Preparing the declarative information of recursiveness.andP;  Because of thecharacteristics of a foreign key, recursiveness can be considered as therelationship between a primary key and the foreign key in tables.andP;  Considerthe table shown in Figure 9.andP;  Given that there is a relationship betweenEMPNO (employee number) and AENO (administrative employee number), these arethe primary key and the foreign key with respect to one another.andP;  If we wantthe name of an employee's manager, we trace columns in the followingsequence:andM;EMPNO - AENO = EMPNO - AENO...andM;That is, we trace the sequence of the primary key and the foreign key.andP;  Thus,for example, managers of the employee number A0006 are A0003 and A0000.andP;  Wecan record the information of the primary key and the foreign key in a DB2catalog by executing CREATE statements as follows: CREATE TABLE EmployeeandM;(.......PRIMARY KEY (EMPNO)andM;REFERENCES EmployeeandM;ON DELETE SET NULL)andM;CREATE UNIQUE INDEX XempandM;ON Employee (EMPNO)andM;Of course, we can prepare the special table that retains the information ofthe primary key and the foreign key, as in the semantic table in Figure 10.andO;Coding statements for recursive processing.andP;  Many requests may be satisfiedusing recursiveness.andP;  For example, find the names of all managers in mymanagement chain; or find the name of the manager whose second line is thepresident.andP;  If we want to specify these requests in one statement, we mustobey predefined rules of syntax and procedures.andP;  This paper proposes a newsyntax Of SQL statements as follows:andM;A statement is for recursive processing.andM;The number of times and in which direction theandM;recursion is to be done are given.andP;  Let us review the new SQL Statements indetail.andP;  Expansion to the SQL Statement is $SELECT column list FROM tablelistandM;RECURSIVEandM;USING starting-column-of-recursionandM;,{ALL|n}andM;WHERE conditionandM;whereandM;*  RECURSIVE indicates this statement contains recursive processingandM;*  USING indicates the direction of the recursion; a column name is theprimary key or the foreign keyandM;*  ALL|n indicates the number of recursive processes; the default iS ALL,which means to get all data through the whole recursive processandM;The sample requests previously described are now coded, using the new SQLsyntax as follows: (a) $SELECT NAME FROM EmployeeandM;RECURSIVE USING EMPNO,ALLandM;YMERE EMPNO =  A0006' (b) $SELECT NAME FROM EmployeeandM;RECURSIVE USING AENO,2andM;WHERE AENO =  A0000'andM;We can now process these requests.andP;  First, the statements have to betranslated into conventional SQL form using the pre-precompiler.andP;  Oneapproach is shown in Figure 15, which is the result of the preprecompilerfrom the request (a) just given.andP;  Because it is easy to expand the currentapplication using this programming language, this type of implementation isvaluable for those who use a traditional programming language.andM;Implementation using the KnowledgeTool.andP;  Another implementation is requiredfor users who use such Al tools as KT, which can allocate storage dynamicallyin responding to the new data.andP;  The KT also provides class-type variablesthat can select members immediately after conditions have been met.andP;  Thesecapabilities are convenient to pass several answers to the program at thetime of the execution of the extended SQL SELECT statement.andP;  We can also makeinferences using rules stored in the knowledge base, after extracting thefacts from the database.andP;  We can implement the pre-precompiler and routinesfor recursive processing using the skeleton of the process shown in Figure16.andP;  The pre-precompiler interprets the extended SQL statement and checks theprimary key and the foreign key in the semantic table.andP;  Then it creates twotypes of stacks-one stack for searching and the other for storing results.andO;The KT subroutine is called by the user program at execution time and usesthe KT functions.andP;  Using the skeleton in Figure 16, implementation ofrecursive processing is easy.andM;Processing ambiguous dataandM;Definition of ambiguous data.andP;  Ambiguous data are defined as incompleteinformation that is stored as null values in a relational database.andP;  Thereare two meanings of null value: (1) don't-care value, which is notpermanently stored; and (2) don't-know value, which is not yet stored.andO;Examples of ambiguous data are shown in Figure 17.andP;  Manipulating ambiguousdata.andP;  Current relational database systems treat these two types of ambiguousdata as null values and make no distinction between them.andP;  However, we wantto treat null values in another way.andM;Consider the queries against ambiguous data:andM;Name the persons who are proficient in English.andM;Find the persons whose scores on the TOEIC are about 800 (TOEIC iS Test ofEnglish for International Communication).andM;We want to retrieve the right information using such queries.andP;  In order tomanipulate ambiguous data in DB2, we propose the pre-precompiler method, forwhich two tables must be created prior to pre-precompilation.andP;  An ordinarytable is created, which contains real data as well as additional columnsrepresenting ambiguous data, an example of which is given in Figure 18.andP;  Akeyword table is prepared, which contains special keywords forpre-precompiling, as shown in Figure 19.andM;The process of pre-precompilation is as follows: 1.andP;  Code the program with aspecial keyword givenandM;in the keyword table.andM;Example 1.andP;  $SELECT EMPNO FROM VTIandM;WHERE TOEIC = $highandM;Example 2.andP;  $SELECT * FROM VT1andM;WHERE TOEIC =  $about800andM;2.andP;  The pre-precompiler translates the extended SQLandM;statement to the standard SQL statement using theandM;keyword table.andM;Example 1.andM;$SELECT EMPNO FROM VT1andM;WHERE TOEIC = $highandM;producesandM;SELECT EMPNO FROM T1andM;WHERE TOEICandM;BETWEEN 700 AND 1000andM;UNIONandM;SELECT EMPNO FROM T1andM;WHERE TOEICF1 andgt; = 700andM;AND TOEICF2 andless; = 1000andM;AND TOEIC IS NULLandM;Example 2.andM;$SELECT * FROM VT1andM;WHERE TOEIC =  about800andM;producesandM;SELECT * FROM T1andM;WHERE TOEIC BETWEEN 780 AND 820andM;UNIONandM;SELECT * FROM TIandM;WHERE TOEICF1 andgt; = 780andM;AND TOEICF2 andless; = 820andM;AND TOEIC IS NULLandM;3.andP;  The program, after translation, is the program that contains onlystandard SQL statements.andP;  Therefore, we can continue the next ordinary stepof precompiling.andP;  It is important to decide the special keyword like $high,and to standardize the meanings of the keywords for users in order to use thekeyword correctly.andM;Concluding remarksandM;The implementation of a new experimental deductive database is discussed.andO;This database uses the same first-order predicate logic as relationaldatabases.andP;  Therefore, prototypes of the new deductive database are easilyimplemented using the relational database.andM;Another component is that of the object-oriented database, which incorporatesthe data and procedures.andP;  The use of object-oriented databases and deductivedatabases is also a topic of research in the relational model.andP;  In thefuture, we hope to combine databases and knowledge engineering.andM;AcknowledgmentsandM;The author is grateful to M. Egawa, H. Tsuchino, and 1.andP;  Hayashi for theiradvice and comments during the preparation of this paper.andP;  The author alsothanks George Stierhoff and the referees for their helpful comments.andM;DATABASE 2, DB2, and KnowledgeTool are trademarks of International BusinessMachines Corporation.andP;  Cited referencesandM;1.andP;  E.F.andP;  Codd, &quot;A Relational Model of Data for Large Shared Data Banks,&quot;Communications of the ACM 13, No.andP;  6, 377387 (1970).andM;2.andP;  E.F.andP;  Codd, &quot;Relational Database: A Practical Foundation forProductivity,&quot; Communications of the ACM 25, No.andP;  2, 109117  1982).andM;3.andP;  C. J. Date, Relational Database: Selected Writings, AddisonWesleyPublishing Co., Reading, MA (1986).andM;4.andP;  D. C. Tsichritzis and F. H. Lochovsky, Data Models, PrenticeHall, Inc.,andO;Englewood Cliffs, NJ (1982).andM;5 .J.andP;  M. Smith and D. C. P. Smith, &quot;Database Abstractions: Aggregation andGeneralization,&quot; ACM Transactions on Database Systems 2, No.andP;  2, 105-133(1977).andM;6.andP;  C. J. Date, An Introduction to Database Systems, Volume II,Addison-Wesley Publishing Co., Reading, MA (1983).andM;7.andP;  C. J. Date, A Guide to the SQL Standard, Addison-Wesley Publishing Co.,andO;Reading, MA (I 987).andM;8.andP;  R. Hull,  A Survey of Theoretical Research on Typed Complex Objects,&quot;Database, J. Paredaens, Editor, Academic Press, London (1987), pp.andP;  193-256.andM;9.andP;  H. Gallaire, J. Minker, and J.-E.andP;  Nicolas, &quot;Logic and Databases: ADeductive Approach,&quot; ACM Computing Surveys 16, No.andP;  2, 153-185 (1984).andM;10.andP;  B. E. Jacobs, Applied Database Logic I.- Fundamental Database Issues,Prentice-Hall, Inc., Englewood Cliffs, NJ (1985).andM;11.andP;  C. J. Date, An Introduction to Database Systems, Volume I,Addison-Wesley Publishing Co., Reading, MA (1986).andM;12.andP;  T. Hirao, Relational Database System, Kindai-kagaku-sha (1986, inJapanese).andM;13.andP;  Y. Kambayashi, &quot;Semantics of Data Structures,&quot; Journal of theInformation Processing Society of Japan 27, No.andP;  2, 129139 (1986, inJapanese).andM;14.andP;  J. D. Uliman, Principles of Database Systems, 2nd edition, ComputerScience Press, MD (1982).andM;15.andP;  J. Peckham and F. Maryanski, &quot;Semantic Data Models, &quot;ACM ComputingSurveys 20, No.andP;  3, 153-189 (1988).andM;16.andP;  IBM DATABASE 2 General Information Manual, GC264073-3, IBM Corporation(1987); available through IBM branch offices.andM;17.andP;  M. L. Brodie, &quot;On the Development of Data Models,' On ConceptualModeling, M. L. Brodie, J. Mylopoulos, and J.W.andP;  Schmidt, Editors,Springer-Verlag, Inc., N-Y (1984), pp.andP;  19-47.andM;Takayuki Hirao IBM Japan Ltd, 1, Kanda Izumi-cho, Chiyodaku, Tokyo 101,Japan.andP;  Mr. Hirao is an advisory instructor in the IBM Japan EducationCenter, where he is working on education activities for customers.andP;  He joinedIBM Japan in 1974, working as a systems engineer (SE) until 1980.andP;  Hereceived his B.S.andP;  in applied mathematics from Tokyo Education University(now renamed Tsukuba University).andP;  Mr. Hirao is the author of RelationalDatabase Systems (in Japanese) and a member of the Information ProcessingSociety of Japan and Japanese Society for Artificial Intelligence.andO;</TEXT></DOC>