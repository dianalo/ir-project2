<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-155-036  </DOCNO><DOCID>08 155 036.andM;</DOCID><JOURNAL>Hewlett-Packard Journal  Feb 1990 v41 n1 p8(11)* Full Text COPYRIGHT Hewlett Packard 1990.andM;</JOURNAL><TITLE>The HP OSI Express card backplane handler. (includes a relatedarticle on custom VLSI chips for DMA) (technical)</TITLE><AUTHOR>Talbott, Glenn F.andM;</AUTHOR><SUMMARY>Hewlett-Packard's OSI Express card backplane handler firmwareroutines connect the common OSI networking environment (CONE)software with the host-resident driver.andP;  The handler controls thehardware moving messages between the host and the OSI Express cardand is compatible with the I/O architecture defined for HPPrecision Architecture systems, which defines the kinds of modulesthat can be connected to an HP Precision bus (HP-PB).andP;  The HP-PBis a 32-bit-wide high-performance memory and I/O bus used toconnect the OSI Express card to the HP 9000 Series 800; it allowsconnected modules to be masters or slaves in bus transactions.andO;Two custom VLSI chips are used by the card to perform DMA betweenits resident memory and host memory.andP;  The host interface,procedure call interface, backplane handler and asynchronous eventhandling are described.andM;</SUMMARY><DESCRIPT>Company:   Hewlett-Packard Co. (products).andO;Ticker:    HWP.andO;Product:   HP OSI Express (Circuit board) (design and construction).andO;Topic:     Communications Boards-CardsOSI StandardMemory ManagementInterfaceCircuit DesignDevice DriversFirmware.andO;Feature:   illustrationchart.andO;Caption:   Data flow relationships between OSI Express driver and cardcomponents. (chart)A portion of a DMA chain. (chart)Flow activities involved in a DMA chaining operation. (chart)andM;</DESCRIPT><TEXT>The backplane on the HP OSI Express card is handled by a pair of VLSI chipsand a set of firmware routines.andP;  These components provide the interfacebetween the HP OSI Express card driver on the host machine and the common OSInetworking environment, or CONE, on the OSI Express card.andM;THE HP OSI EXPRESS CARD BACKPLANE handler is a set of firmware routines thatprovide an interface between the common OSI networking environment (CONE)software and the host-resident driver.andP;  CONE provides network-specificoperating system functions and other facilities for the OSI Express card (seethe article on page 18).andP;  The handler accomplishes its tasks by controllingthe hardware that moves messages between the host computer and the OSIExpress card.andP;  The backplane handler design is compatible with the I/Oarchitecture defined for HP Precision Architecture systems,' and it makes useof the features of this architecture to provide the communication pathsbetween CONE and the host-resident driver.andP;  The HP Precision I/O Architecturedefines the types of modules that can be connected to an HP Precision bus(including processors, memory, and I/O).andP;  The OSI Express card is classifiedas an I/O module.andM;The OSI Express card connects to an HP 9000 Series 800 system via the HPPrecision bus (HP-PB), which is a 32-bitwide high-performance memory and I/Obus.andP;  The HP-PB allows all modules connected to it to be either masters orslaves in bus transactions.andP;  Bus transactions are initiated by a master andresponses are invoked from one or more slaves.andP;  For a read transaction, datais transferred from the slave to the master, and for a write transaction,data is transferred from the master to the slave.andP;  Each module that can actas a master in bus transactions is capable of being a DMA controller.andP;  Bustransactions include reading or writing 4, 16, or 32 bytes and atomicallyreading and clearing 16 bytes for semaphore operations.andM;The OSI Express card uses a pair of custom VLSI chips to perform DMA betweenits own resident memory and the host memory.andP;  The first chip is the HP-PBinterface chip, which acts as the master in the appropriate HP Precision bustransactions to perform DMA between the OSI Express card and the host systemmemory space.andP;  The second chip is the midplane memory controller, whichcontrols the DMA between the HP-PB interface chip and the OSI Express cardresident memory.andP;  The memory controller chip also performs midplane busarbitration and functions as a dynamic RAM memory controller and an interruptcontroller.andP;  See the box on page 15 for more information about the HP-IBinterface chip and the midplane memory controller chip.andP;  The backplanehandler hides all the programming required for these chips from the hostcomputer OSI Express driver and CONE.andM;Host InterfaceandM;The HP Precision I/O Architecture views an I/O module as a continuouslyaddressable portion of the overall HP Precision Architecture address space.andO;I/O modules are assigned starting addresses and sizes in this space at systeminitialization time.andP;  The HP Precision I/O Architecture further divides thisI/O module address space (called soft physical address space, or SPA) intouniform, independent register sets consisting of 16 32-bit registers each.andM;The OSI Express backplane handler is designed to support up to 2048 of theseregister sets.andP;  (The HP-PB interface chip maps HP-PB accesses to theseregister sets into the Express card's resident memory.) With one exception,for the backplane handler each register set is independent of all the otherregister sets, and the register sets are organized in inbound-outbound pairsto form full-duplex paths or connections.andP;  The one register set that is theexception (RS 1) is used to notify the host system driver of asynchronousevents on the OSI Express card, and the driver is always expected to keep aread transaction pending on this register because it is set to receivenotification of these events.andM;Register SetsandM;The registers are numbered zero through 15 within a given register set.andP;  Theregisters within each set that are used by the backplane handler as they aredefined by the HP Precision I/O Architecture are listed below.andP;  The registersnot included in the list are used by the backplane handler to maintaininternal state information about the register set.andM;Number              Name                     FunctionandM;4        IO_DMA_LINK                Pointer to DMA controlandM;structureandM;5        IO_DMA_COMMAND             Current DMA chainandM;commandandM;6        IO_DMA_ADDRESS             DMA buffer addressandM;7        IO_DMA_COUNT               DMA buffer size (bytes)andM;12        IO_COMMAND                 Register set I/O commandandM;13        IO-STATUS                  Register set statusandM;The OSI Express card functions as a DMA controller and uses DMA chaining totransfer data to and from the card.andP;  DMA chaining consists of the DMAcontroller's autonomously following chains of DMA commands written in memoryby the host processor.andP;  HP Precision I/O Architecture defines DMA chainingmethods and commands for HP Precision Architecture systems.andP;  A DMA chainconsists of a linked list of DMA control structures known as quads.andM;Data Quad.andP;  The data quad is used to maintain reference to and informationabout the data that is being transferred.andP;  The fields in the data quad havethe following meaning and use.andM;Field                         Meaning and UseandM;CHAIN_LINK         Pointer to the next quad in the chainandM;CHAIN_CMD          DMA chaining command plusandM;application-specific fieldsandM;ADDRESS            Memory address of the data bufferandM;COUNT              Length of the data buffer in bytesandM;Bits in the application-specific fields of CHAIN-CMD control the generationof asynchronous events to CONE and the acknowledgment of asynchronous eventindications to the host.andM;Link Quad.andP;  A link quad is created by the driver to indicate the end of a DMAtransaction (note: not the end of a DMA chain).andP;  When a link quad isencountered in the chain, a completion list is filled in and linked into acompletion list.andP;  if the CHAIN-LINK field does not contain an END-OFCHAIN,DMA transfers continue.andP;  The fields in the link quad have the followingmeaning and use.andM;Field                         Meaning and UseandM;CHAIN_LINK        Pointer to the next quad in the chain, orandM;END-OF-CHAIN valueandM;CCMD_LINK         Causes a completion list entry to beandM;created and may specify whether the hostandM;should be interruptedandM;HEAD_ADDR         Address of the completion listandM;ENTRY_ADDR        Address of the completion list entry toandM;be used to report completion statusandM;Completion List Entry.andP;  A completion list entry is used to indicate thecompletion status of a DMA transaction.andP;  One is filled in when a link quad isencountered in the DMA chain.andP;  The fields in the completion list have thefollowing meanings and use:andM;Field                         Meaning and UseandM;NEXT_LINK         Pointer used to link the entry into theandM;completion listandM;10_STATUS         Completion status field, a copy of theandM;10  STATUS registerandM;SAVE_LINK         Pointer to the quad where an errorandM;occurred, or to the link quad in the caseandM;of no errorandM;SAVE_COUNT        Residue count of bytes remaining in theandM;buffer associated with the quad pointedandM;to by SAVE_LINK, or zero if no errorandM;The completion list head contains a semaphore that allowsandM;a completion list to be shared by multiple I/O modules,andM;and a pointer to the first entry in the completion list.andM;DMA ChainingandM;DMA chaining is started by the host system driver whenandM;the address of the first quad in a DMA chain is written intoandM;the IO_DMA_LINK register of a register set.andP;  To tell the OSIandM;Express card to start chaining, the driver writes the chainandM;command CMD_CHAIN into the register set's IO_COMMANDandM;register.andP;  This causes an interrupt and the Express card'sandM;backplane handler is entered.andP;  From this point until a completionandM;list entry is made, the DMA chain belongs to theandM;OSI Express card's register set, and DMA chaining is underandM;control of the backplane handler through the register set.andM;Once control is transferred to the backplane handler, theandM;first thing the handler does is queue the register set forandM;service.andP;  When the register set reaches the head of the queue,andM;the backplane handler fetches the quad pointed to by IO_andM;DMA_LINK and copies the quad into the registers IO_DMA_andM;LINK, IO_DMA_COMMAND, IO_DMA_ADDRESS, and IO_andM;DMA_COUNT.andP;  The backplane handler then interprets theandM;chain command in register IO_DMA_COMMAND, executesandM;the indicated DMA operation, and fetches and copies theandM;next quad pointed to by IO_DMA_LINK.andP;  This fetch, interpret,andM;and execute process is repeated until the value inandM;IO_DMA_LINK is END_OF_CHAIN.andP;  When END_OF_CHAIN isandM;reached, the backplane handler indicates that the registerandM;set is ready for a new I/O command by posting the statusandM;of the DMA transaction in the IO_STATUS register.andM;The DMA operation executed by the backplane handlerandM;is determined by the chain command in the IO_DMA_COM_andM;MAND register.andP;  For quads associated with data buffers,andM;this chain command is CCMD_IN or CCMD_OUT for inboundandM;or outbound buffers, respectively.andP;  In this case the backplaneandM;handler transfers the number of bytes of dataandM;specified in the IO_DMA_COUNT register to or from theandM;buffer at the host memory location in the IO_DMA_AD_andM;DRESS register.andP;  The IO_DMA_ADDRESS and IO_DMAandM;-COUNT registers are incremented and decremented as theandM;data is transferred.andM;The link quads containing a CCMD_LINK chain commandandM;cause the backplane handler to report the status of theandM;previous DMA transfers and continue chaining if the registerandM;containing the CHAIN_LINK field does not indicate ENDandM;-OF_CHAIN.andP;  The CCMD_LINK can also cause the backplaneandM;handler to generate an interrupt to the host processor whichandM;indicates to the driver that a completion list entry is readyandM;to be read.andM;Completion List EntryandM;When a link quad containing the CCMD_LINK chain commandandM;is encountered, a completion list entry is created.andM;Creating a completion list is a three_or_four_step process.andM;First, the backplane handler acquires the semaphore in theandM;completion list head at the address in HEAD_ADDR.andM;This is accomplished by repeatedly mastering (gainingandM;control of the bus) a read_and_clear bus transaction until aandM;nonzero value is returned.andP;  When a nonzero value has beenandM;read, the OSI Express card owns the semaphore and canandM;proceed to the next step.andP;  The second step is to fill the fourandM;fields of the completion list entry indicated by the pointerandM;ENTRY_ADDR in the link quad.andP;  The third step is to write aandM;nonzero value into the semaphore field of the completionandM;list head, thus releasing the semaphore, and insert the newandM;completion list entry into the completion list.andM;These three steps are done automatically by the HP PrecisionandM;bus interface chip on command from the backplaneandM;handler.andM;The optional fourth step of the completion list insertionandM;process is to generate an interrupt to the host processor.andP;  IfandM;the CCMD-LINK specifies, the address of the host processorandM;and the value written in the processor's external interruptandM;register are packed into the chain command word containingandM;the CCMD_LINK.andP;  The backplane handler uses these valuesandM;to master a write to the host processor and cause an interrupt.andM;When the OSI Express driver has built a DMA chain andandM;started the OSI Express card traversing the chain, subsequentandM;DMA chains can be appended to the existing chainandM;without interrupting the card.andP;  To do this the driver simplyandM;writes the address of the first quad in the new chain intoandM;the CHAIN_LINK word of the last quad of the old chain.andP;  SinceandM;the driver does not know whether an append is successfulandM;(the card may have already fetched the last quad in the oldandM;chain), there is a mechanism to verify the success of anandM;append.andP;  When the driver reads the completion list entryandM;for the old chain, a bit in the IO_STATUS word indicatesandM;whether or not the OSI Express card found END_OF_CHAINandM;in the last quad.andP;  If this bit is set  END_OF_CHAIN found) theandM;append is not successful and the driver must start the newandM;chain by writing the address of the first quad of the newandM;chain to the register set's IO_DMA_LINK register and aandM;CMD_CHAIN to the IO_COMMAND register.andP;  Using the appendandM;mechanism, the OSI Express card can run more effiandM;-ciently when the driver can stay ahead of the card in postingandM;DMA chains.andP;  This way the driver only starts one chainandM;(generating an interrupt on the Express card) on each registerandM;set being used.andM;Procedure Call InterfaceandM;Data transfers between the host computer and the OSIandM;Express card are via DMA.andP;  DMA chains containing dataandM;and control information are created by the host driver, andandM;the backplane handler uses the HP-PB register sets to transferandM;the data to and from the OSI Express card.andP;  On the OSIandM;Express card the data is moved to and from the protocolandM;layers.andP;  Access to the protocol layers is provided by theandM;common OSI network environment, or CONE, and accessandM;to CONE is through the backplane message interface (BMI).andM;The backplane message interfaceandM;is responsible for converting backplane message (asynchronous)andM;requests into corresponding CONE (synchronous)andM;procedure calls for outbound data transfers, and convertingandM;CONE procedure calls into backplane message requestsandM;for inbound data transfers.andP;  The reasons for this particularandM;interface design are discussed in more detail onandM;page 27.andM;Handshake ProceduresandM;The backplane handler interface to CONE uses a set ofandM;procedures, which are written in C, to transfer messagesandM;to and from CONE.andP;  CONE makes initialization and dataandM;movement request calls to the backplane handler, and theandM;backplane handler makes completion and asynchronousandM;event procedure calls to CONE.andP;  The data movement requestsandM;are made by CONE executing at a normal interruptandM;level.andP;  The completion and event calls are made by theandM;backplane handler at the backplane handler interrupt levelandM;(level three) to CONE.andP;  These completion and event proceduresandM;set flags for processing later by CONE at a normalandM;interrupt level.andP;  The completion and event procedures areandM;located in the backplane message interface module.andP;  PointersandM;to these routines are passed to the backplane handlerandM;at initialization time for each register set.andP;  Although theseandM;procedures are located in the BMI, CONE is responsibleandM;for initiation, interpretation, and action for messages toandM;and from the backplane handler, and the BMI is the interprocessandM;communication handler.andM;Initialization and Data Movement Procedures.andP;  These procedures,andM;which are located in the backplane handler, areandM;used by CONE to send messages to the backplane handler.andM;* Bh_assoc_rs().andP;  This procedure is used by CONE to enableandM;an inbound and outbound register pair when a networkandM;connection is established.andP;  It is also used to disable theandM;register pair when the connection is broken.andP;  The parametersandM;passed when this procedure is called include:andM;* The register set number.andM;* An identifier that is meaningful to CONE and is usedandM;to identify subsequent asynchronous events.andM;* The priority to be used in servicing the register set.andM;* Pointers to the three completion and event proceduresandM;for this register set.andM;* A pointer to a block of memory to be used by the backandM;-     plane handler to queue asynchronous events.andM;* A pointer to a block of memory to be used by the backplaneandM;handler to copy event parameters from the hostandM;computer.andM;* The length of the event parameter memory block.andM;* Bh_put_data() and Bh_get_data().andP;  These routines are used toandM;start a data transfer request-bh_put_data for inboundandM;transfers and Bh_get_data for outbound transfers.andP;  TheyandM;are also instrumental in determining the state transitionsandM;in the backplane handler's main interrupt serviceandM;routine.andP;  The parameters passed when these proceduresandM;are called include:andM;* The register set number.andM;* An identifier that is returned with the Bhi_put_data_done()andM;or Bhi_get_data_done() call to identify this particularandM;request.andM;* A pointer to a block of memory to be used by theandM;backplane handler to queue this request.andP;  The blockandM;of memory ensures that the queue depth of requestsandM;held by the backplane handler is not limited by the resourcesandM;directly available to the backplane handler.andM;* A pointer to a structure of chained data buffers to beandM;sent or filled.andP;  This structure is matched to the structuresandM;created by the CONE memory manager.andM;* The total number of bytes requested for the transfer.andM;* A status value passed to the host computer in the completionandM;list entry.andM;* A bit_field mode parameter that controls various aspectsandM;of the transfer, such as whether errors andandM;acknowledgments of previous asynchronous eventsandM;should be sent to the host computer.andM;Completion and Event Procedures.andP;  These procedures,andM;which are located in the backplane message interface module,andM;are used by the backplane handler to send messagesandM;to CONE.andM;*  Bhi_cmd_arrival().andP;  This procedure is used to announceandM;asynchronous events to CONE.andP;  There are two asynchronousandM;events that cause Bhi_cmd_arrival() to be called by theandM;backplane handler.andP;  The first event is the posting of outboundandM;data to a register set by the host driver.andP;  The firstandM;quad in the DMA chain associated with the register setandM;has its transparent bit set and the quad's data buffer isandM;set to contain information about how much outboundandM;data is being sent.andP;  The transparent bit causes a call toandM;Bhi_cmd_arrival(), passing the buffer attached to the firstandM;quad.andP;  The second case in which Bhi_cmd_arrival() is calledandM;is the resetting of a register set by the driver.andP;  CONE mustandM;acknowledge the receipt of a Bhi_cmd_arrival() call with aandM;Bh_get_data() call.andP;  The backplane handler's internal logicandM;prevents more than one Bhi_cmd_arrival() per register setandM;from being outstanding at any time.andP;  The parametersandM;passed in a call to BHI_cmd_arrival include:andM;* The register set of the event.andM;* An identifier that is meaningful to CONE (establishedandM;with Bh_assoc_rs().andM;* A code indicating the type of event.andM;* The length of data in an event parameter block.andM;*  Bhi_put_data_done() and Bhi_get_data_done().andP;  These proceduresandM;are used to announce the completion and freeingandM;of resources from prior data movement requests.andP;  TheandM;parameters passed with these procedures include:andM;* An identifier that is meaningful to CONE (establishedandM;by the Bh_put_data() or Bh_get_data() request).andM;* A count of the number of bytes moved to or from theandM;host computer.andM;* A status value passed from the host computer.andM;* An error value to indicate backplane handler errors.andM;Inbound and Outbound RequestsandM;Outbound Requests.andP;  When Bhi_cmd_arrival() is called to informandM;CONE that the host computer has posted outboundandM;data to an outbound register set, CONE allocates the requiredandM;buffer space and calls Bh_get_data(), specifying anandM;acknowledgment of the Bhi_cmd_arrival() call.andP;  When the dataandM;has been transferred across the backplane, Bhi_get_data_done()andM;is called, triggering CONE to send the outbound dataandM;across the network.andM;Inbound Requests.andP;  When CONE receives inbound data, itandM;calls Bh_put_data() to send the data across the backplane,andM;specifying that an asynchronous event must be sent to theandM;host and giving the size of the data.andP;  After the host computerandM;receives the asynchronous event, it posts reads to acceptandM;the data.andP;  After the data has been transferred, the backplaneandM;handler calls Bhi_put_data_done(), triggering CONE to releaseandM;the buffers used by the inbound data so they can be usedandM;to receive more data.andM;The send and receive data sequences are repeated asandM;often as necessary to move data across the backplane.andP;  NoteandM;that as long as CONE has free buffers available, CONE doesandM;not have to wait for a preceding Bhi_get_data_done() to allocateandM;the next outbound buffer and call Bh_get_data().andP;  Also,andM;as long as free buffers are available, CONE can receive dataandM;from the network and call Bh_put_data() without waiting forandM;the preceding Bhi_put_data_done() calls to indicate that theandM;host has taken previous data.andP;  When the connection is cut,andM;The Backplane HandlerandM;The simplified state diagram shown in Fig.andP;  6 shows theandM;behavior of the backplane handler to inputs from the OSIandM;Express card driver on the host computer and from CONEandM;through the backplane message interface.andM;In the BH_IDLE state the backplane handler is typicallyandM;not executing because the OSI Express card processor isandM;either executing in the CONE protocol stack, or the processorandM;is in an idle loop itself.andP;  There are two ways to get outandM;of BH_IDLE.andP;  Either a new I/O command is written by theandM;host driver into a register set's IO_COMMAND register causingandM;an interrupt, or the backplane handler's main interruptandM;service routine is called from CONE via Bh_put_data() orandM;Bh_get_data() to process a new request.andP;  In either case at leastandM;one register set will be queued for service, and the backplaneandM;handler will find the queued register set, switch contextandM;to that register set, and enter the RS_BUSY state.andM;In the RS_BUSY state the backplane handler does all theandM;processing required to service one register set, moving theandM;register set through the various register set states.andP;  If a longandM;DMA transfer is started and the backplane handler mustandM;exit to await DMA completion, the backplane handler willandM;enter the DMA_ACTIVE state.andP;  DMA_ACTIVE is a transitory stateandM;that ends when the DMA completes and the backplaneandM;handler returns to the RS_BUSY state.andP;  When one registerandM;set can progress no further through the register set states,andM;the backplane handler switches to the next queued registerandM;set.andP;  When there are no more register sets, the backplaneandM;handler returns to the BH_IDLE state.andM;Main interrupt Service RoutineandM;The backplane handler's main interrupt service routineandM;is the component of the backplane handler that drives theandM;backplane handler state machine.andP;  A flowchart of the backplaneandM;handler main interrupt service routine is shown inandM;figure Fig.andP;  7.andM;On entry to the main interrupt service routine, a threeandM;way decision is made based on the reason for entry.andM;* If the entry is from a call by BH_ put_data() or Bh_gel_data()andM;the routine searches f or a queued register set to service.andM;* If the entry is from a new command written to a registerandM;set, the register set is queued for service, and if the backplaneandM;handler state is DMA_ACTIVE, an exit is taken.andP;  OtherwiseandM;the interrupt service routine searches for a queuedandM;register set to service.andM;* If the entry is from a DMA completion, the backplaneandM;handler ends DMA processing and enters a loop for processingandM;one register set.andP;  This loop consists of a test toandM;see if there is further action that can be taken on theandM;register set, register set processing (which drives the registerandM;set state machine) if the test is successful, and aandM;test for DMA_ACTIVE.andP;  If the first test fails and there isandM;nothing further that can be done on the current registerandM;set, that register set is removed from the queue of registerandM;sets requesting service and the interrupt service routineandM;searches for a queued register set to service.andP;  If the secondandM;test shows that DMA is active, an immediate exit is taken.andM;Note that there are no context switches to another registerandM;set before a particular register set being serviced reachesandM;DMA completion.andP;  This is because on new command entries,andM;if the backplane handler state is DMA_ACTIVE anandM;exit is taken with no context switch.andP;  Also, BH_put_data()andM;and Bh_get_data() will queue a register set for service butandM;not call the main interrupt service routine if the backplaneandM;handler state is DMA_ACTIVE.andM;All paths through the main interrupt service routine thatandM;do not exit with DMA_ACTIVE eventually wind up searchingandM;for another queued register set to service.andP;  Register sets areandM;queued for service in multiple priority queues.andP;  Each priorityandM;queue is serviced in a first in, first out fashion before steppingandM;to the next-lower-priority queue.andP;  (Register set prioritiesandM;are established at initialization.) When a register set is foundandM;requesting service, a context switch is made to that registerandM;set and the loop that processes register sets is entered.andP;  WhenandM;there are no more register sets requesting service the mainandM;interrupt service routine exits.andM;Register Set State MachineandM;The backplane handler sends and receives multipleandM;streams of data on register sets and maintains those registerandM;sets as independent state machines.andP;  Each register set is anandM;instance of a register set state machine.andP;  Register set stateandM;changes are driven by the process register set block in theandM;main interrupt service routine.andM;A register set leaves the RS_IDLE state either when a newandM;request is started  Bh_put_data() or Bh_get_data() queue a requestandM;and then queue the register set for service) or whenandM;a host data buffer becomes available (host driver posts aandM;DMA chain, and a normal data quad is fetched).andP;  If a newandM;request is started, the register set transitions to the REQandM;-PEND state.andP;  If a new host buffer becomes available the registerandM;set transitions to the DATA_PEND state.andP;  The register setandM;may stay in either REQ_PEND or DATA_PEND for a long timeandM;waiting for driver action, resources to free up, or networkandM;data to be received to cause the transitions to REQ_DATA_andM;PEND.andM;Once in the REQ_DATA_PEND state, DMA data will flowandM;through a register set until either the end of the host dataandM;is encountered or the end of the local request data is encountered,andM;or both.andP;  When one of these events is encountered,andM;the register set will transition back to the appropriateandM;REQ_PEND, DATA_PEND, or RS_IDLE state.andM;The ability of a register set to go between either the REQ_andM;PEND or DATA_PEND state and the REQ_DATA_PEND state repeatedlyandM;allows the OSI Express card to use the backplaneandM;handler as a packet segmentation or reassembly point.andM;When networking buffer memory on the OSI Express cardandM;is scarce and a large buffer of outbound data is posted byandM;the driver, CONE can allocate one small buffer to send theandM;data.andP;  The one buffer can be used over and over again byandM;going through multiple iterations of passing it to the backplaneandM;handler in a Bh_get_data() call and then transmittingandM;it across the network.andP;  Each successive BH_get_data() callandM;reads successive blocks of data from the host computer'sandM;buffer.andP;  On the inbound side the process can be repeatedandM;using Bh_put_data().andP;  The backplane handler is also flexibleandM;enough to perform the same service for the host computer,andM;using large buffers on the card and multiple small buffersandM;on the host computer.andP;  The result is that because of theandM;backplane handler's ability to move data spanning bufferandM;boundaries on either the host computer or the OSI ExpressandM;card, the driver and CONE need not worry about accuratelyandM;matching buffers with each other.andM;Asynchronous Event HandlingandM;For inbound and outbound data transfers the backplaneandM;handler must process asynchronous events to notify CONEandM;and the host system of these data transfers.andP;  In the outboundandM;direction the CONE modules must be notified when theandM;host driver posts a buffer of outbound data so that CONEandM;can allocate outbound buffers to transport the data to theandM;network.andP;  CONE needs to be told how much data is outboundandM;so that it can allocate resources before the data isandM;read onto the OSI Express card.andP;  The same problem existsandM;in the inbound direction.andP;  When a packet of data arrives atandM;the backplane handler from the network, the host driverandM;and networking code must be told of its arrival and sizeandM;so that host networking memory can be efficiently allocated.andM;In the outbound direction, the driver prefixes each outboundandM;message, which may be made up of multiple largeandM;physical buffers linked with DMA chaining quads, with aandM;quad and a small buffer containing size and other informationandM;about the outbound message.andP;  A bit is set in the prefixandM;quad indicating that it is a transparent command (transparentandM;to the backplane handler), and the entire DMA chainandM;is posted on a register set.andM;When the transparent command quad is fetched by theandM;backplane handler, the small buffer associated with theandM;quad is copied into the event parameter buffer for thatandM;register set.andP;  BhI_cmd_arrival() is then called and the transparentandM;command and event parameters are passed on to CONE.andM;The backplane handler will then suspend fetching quadsandM;on that register set until CONE has acknowledged the BHI_cmd_arrival()andM;event with a BH_get_data() call on that registerandM;set.andP;  This prevents a subsequent transparent command fromandM;overwriting the original command in the the event parameterandM;buffer until CONE has acknowledged the first transparentandM;command.andP;  CONE allocates the resources needed to sendandM;part or all of the data across the network, and then callsandM;BH_get_data() with the acknowledge bit set.andM;In the inbound direction, transparent indications provideandM;event notification to the driver and host networking software.andM;One register set (RS 1) is used as a high-priorityandM;transparent indication register set.andP;  This register set is servicedandM;by the backplane handler at a priority higher thanandM;any other register set, and the driver always keeps a DMAandM;chain of small buffers and completion list entries postedandM;on the transparent indication register set.andM;When the first packet of an inbound message arrives fromandM;the network, the packet is placed in a line data buffer consistingandM;of one or more physical buffers.andP;  A physical bufferandM;containing the size and other information about the inboundandM;message is prefixed to the line data buffer, and theandM;prefixed line data buffer is posted to the backplane handlerandM;in a Bh_put_data() call with the transparent indication bitandM;set.andP;  When the request generated by the Bh_put_data() callandM;arrives at the head of the request queue on the register set,andM;the request is then requeued onto the transparent indicationandM;register set.andP;  The data is then sent via DMA into one of theandM;small host computer buffers posted there to receive theandM;data, and then the backplane handler creates a completionandM;list entry.andM;When the driver reads the completion list entry associatedandM;with the transparent indication register set, theandM;transparent indication is passed on to host networking software,andM;which allocates the resources necessary to receiveandM;the message.andP;  The driver then posts the allocated buffers onandM;the correct register set (as indicated in the transparent indication)andM;with an acknowledge bit set in the first quad'sandM;CHAIN_CMD word.andP;  The backplane handler then sends theandM;data via DMA into the buffers on the host via the appropriateandM;register set.andM;ConclusionandM;Four main benefits have resulted from the design of theandM;OSI Express card backplane handler.andP;  The first three are allandM;related in that they are derived from the flexibility of theandM;register set state machine.andP;  These benefits include:andM;* The producer and consumer processes on the host andandM;on the OSI Express card do not have to be time-synchronized.andM;Data transfers may be started either by theandM;host system or the OSI Express card register set beingandM;used.andP;  The host system can post buffers to start the transferandM;or CONE can start the transfer by calling proceduresandM;BH_put_data() or Bh_get_data().andM;* Data buffers on the host system and the OSI Express cardandM;do not need to match in size.andP;  Large buffers on the hostandM;can be filled (or emptied) from multiple small buffersandM;on the card, and large buffers on the card can be filledandM;(or emptied) from multiple small buffers on the host.andM;Neither the host nor the CONE modules resident on theandM;I/O module need to know about the buffer sizes on theandM;other side of the backplane.andM;The independence of buffer sizes has resulted in reducedandM;overhead for packet assembly and disassembly (a normalandM;operation for network software).andP;  The backplane handlerandM;allows the OSI Express card to combine packet assemblyandM;and disassembly with the data copy that is required toandM;cross the backplane.andP;  This allows the OSI Express cardandM;networking software to accomplish packet assembly andandM;disassembly without the added overhead of a data copy.andM;The problem of one connection or data path blockingandM;data flow on another path at the backplane interface isandM;eliminated.andP;  The primary reason for the backplane handler'sandM;maintaining multiple independent register sets is toandM;prevent one path from blocking another.andP;  If one of theseandM;paths becomes blocked because a consumer stops takingandM;data, the remaining paths continue to carry data withoutandM;the intervention of the networking application on theandM;OSI Express card or the host system.andM;AcknowledgmentsandM;Special thanks to Jim Haagen-Smit who made significantandM;contributions to the design and development of the backplaneandM;handler, and in reviewing this article.andP;  I would alsoandM;like to acknowledge the efforts of the HP Precision busandM;interface chip design team, especially Vince Cavanna andandM;Calvin Olsen, and the midplane memory controller chipandM;design team, especially Mark Fidler and Alan Albrecht, forandM;providing these remarkable integrated circuits and reviewingandM;this article.andM;ReferencesandM;1.andP;  D.V.James, et al, &quot;HP Precision Architecture: The Input/outputandM;System,&quot; Hewlett-Packard Journal, Vol.andP;  37, no.andP;  8, August 1986,andM;pp.andP;  23-30.andM;Custom VLSI chips for DMAandM;The OSI Express card uses a pair of custom VLSI circuits toandM;perform DMA between the OSI Express card resident memoryandM;and the host system's memory.andP;  The first chip is the Hewlett-packardandM;Precision bus interface chip and the other is the midplaneandM;memory controller chip.andP;  The bus interface chip masters theandM;appropriate HP Precision bus transactions to perform DMA betweenandM;the OSI Express card and the host system memory space.andM;The memory controller chip is responsible for controlling DMAandM;between the bus interface chip and the OSI Express card residentandM;memory, performing midplane bus arbitration, and functioningandM;as a dynamic RAM memory controller and an interrupt controller.andM;The bus interface chip functions as a bus master when doingandM;DMA on the HP Precision bus and as a bus slave when respondingandM;to direct I/O to and from the OSI Express card registers byandM;the host processor.andP;  The memory controller chip serves as a DMAandM;controller when the bus interface chip is doing DMA, performingandM;DMA to or from card memory when the bus interface chip assertsandM;a DMA request (DMAR).andP;  The memory controller chip also servesandM;as a bus arbitrator when the bus interface chip responds to directandM;I/O from the host computer, granting the bus interface chip theandM;bus when it asserts a bus request (BUSRQ).andM;Both chips are connected to a 68020 processor, dynamic RAM,andM;and address and data buses as shown in Fig.andP;  1.andP;  All RAM addressesandM;on the address bus are translated by the memory controllerandM;chip into addresses that map into the physical RAM space.andM;DMA between the host system and the OSI Express card is aandM;complex process, considering that:andM;* All HP Precision bus DMA data transfers are either 16 or 32andM;bytes and must be size-aligned.andM;* DMA bus transfers on the OSI Express card bus are 16 bits,andM;and a one-byte shift is required if even-addressed OSI ExpressandM;card bytes are transferred to odd-addressed host bytes.andM;* DMA transfers on the HP Precision bus side can be specifiedandM;to start or end on arbitrary byte boundaries, with garbage dataandM;used to pad to 16-byte alignment and size.andM;* DMA transfers on the OSI Express card memory side can beandM;specified to start or end on arbitrary byte boundaries with noandM;extra data allowed.andM;The bus interface chip and the memory controller chip combineandM;to make the task of doing DMA between OSI Express card memoryandM;and host memory almost as simple as programming addressesandM;and counts.andM;The figure is drawn showing DMA from the OSI ExpressandM;card to the host computer.andP;  To go the other way, reverse theandM;direction of the data flow arrows.andM;The bus interface chip uses a pair of 32-byte swing buffers soandM;that an HP-PB transaction can proceed in parallel with an OSIandM;Express card midplane transaction.andP;  The bus interface chipandM;PDMA_ADDRESS register is a pointer into host memory.andP;  It isandM;initialized to the size-aligned boundary below the desired startingandM;address and is incremented by the size of the transactions (16andM;or 32 bytes).andM;The bus interface chip N_COUNT and M COUNT registersandM;count down as the DMA transfer progresses on the HP PrecisionandM;bus side (N COUNT) and the OSI Express card midplane sideandM;(M_COUNT).andP;  N COUNT is decremented by the HP Precision busandM;transaction size (16 or 32 bytes) and M COUNT is decrementedandM;by the midplane transaction size (2 bytes).andP;  Both registers areandM;normally initialized to the desired size of the transfer.andP;  However,andM;if the transfer is from the host system to the OSI Express cardandM;and the starting host address is not 16 (or 32) byte aligned, theandM;amount of misalignment is added to N_COUNT to cause thatandM;number of bytes to be read and discarded.andP;  The bus interfaceandM;chip will assert DMAR as long as both M COUNT and N_COUNTandM;are greater than zero and the swing buffer on the OSI ExpressandM;card midplane side is not full (or not empty for host-to-osi ExpressandM;card transfers).andM;The memory controller chip has the task of aligning misalignedandM;host computer and OSI Express card data.andP;  if data on the hostandM;computer starts on an odd byte and the OSI Express card dataandM;starts on an even byte, or vice versa, the data is passed throughandM;the memory controller chip using the shift byte register to provideandM;the one-byte shift required for all data transfers between the OSIandM;Express card memory and the bus interface chip.andP;  If the startingandM;addresses match (odd - odd or even - even) then DMA data isandM;transferred directly between the bus interface chip and the OSIandM;Express card memory without passing through the memory controllerandM;chip.andP;  There is a two-clock-cycle penalty for each 16 bitsandM;transferred when byte shifting DMA data.andM;The memory controller chip DMA_ADDRESS register, whichandM;sources the OSI Express card memory address, is initialized toandM;the starting address of the transfer and is incremented by twoandM;bytes as the data is transferred (one byte for first or last byte asandM;required by misalignment and length).andP;  The COUNT register isandM;initialized to the number of bytes required and is decrementedandM;as the DMA_ADDRESS register is incremented.andP;  The PDMAandM;OFFSET register is a five-bit rollover counter that is used to provideandM;addressing into the bus interface chip swing buffers.andP;  PDMA_andM;OFFSET is masked to four bits when 16-byte HP Precision busandM;transactions are being used so that it counts from 0 to 15 andandM;rolls to zero.andP;  PDMA OFFSET is initialized to an offset value dependingandM;on the size alignment of the desired host starting addressandM;(zero for size-aligned transfers).andP;  The memory controllerandM;chip will drive the DMA as long as the bus interface chip assertsandM;DMAR and the memory controller chip COUNT register is greaterandM;than zero.andM;@@@081550421 0HPJIja018CASEandM;The common OSI network environment, or CONE, providesandM;a network-specific operating system for the HP OSI ExpressandM;card and an environment for implementing OSI protocols.andM;IMPLEMENTING HIGH-PERFORMANCE and reliableandM;network protocols is an expensive and time-consumingandM;endeavor.andP;  Supporting products containing these protocolsandM;is also costly, considering changes in standards,andM;hardware, and application emphasis.andP;  Because of these challenges,andM;in the early 1980s HP began to develop a frameworkandM;for providing portable protocol modules that could be usedandM;in a number of products to minimize incompatibility problemsandM;and development and support costs.andP;  Early networkandM;protocol portability concepts were used in networkingandM;products for the HP 9000 Series 500 computers,l the HPandM;9000 Series 300 computers, the HP Vectra personal computer,andM;and the HP code for connecting Digital Equipment Corporation'sandM;VAX/VMS systems to HP AdvanceNet.[sup.2] OtherandM;concepts in modularity and protocol flexibility were developedandM;for products on HP 3000 computers[sup.3] and HP 1000andM;computers.[sup.4]  In anticipation of new standards for ISO OSIandM;(Open Systems Interconnection) protocols, an HP interdivisionalandM;task force was formed to define a networking environmentandM;for protocols that would incorporate the best ideasandM;identified from current and previous network products,andM;and provide protocols that were portable to a maximumandM;number of machines.andP;  This environment is called CONE, orandM;common OSI networking environment.andM;CONE is a system design for a set of cooperating protocolandM;modules, a collection of functions that support these modules,andM;and a comprehensive specification for module interfaces.andM;A protocol module contains the code that implementsandM;the functions for a particular layer of the OSI stack.andM;The more deeply nested boxes contain more portable code.andM;The network protocol code contains the data structures andandM;functions that implement the protocol layers.andP;  The executionandM;environment defines all the interfaces to the network protocolandM;modules, providing services that are tuned to support networkandM;protocols and ensure isolation from the embedding operatingandM;system.andP;  The embedding operating system includes theandM;facilities provided by the operating system for the processorandM;on the OSI Express card.andP;  These facilities include a simpleandM;interrupt system and a rudimentary memory manager.andP;  TheandM;system interface is composed of small, partially portableandM;modules that perform whatever actions are necessary toandM;adapt the embedding operating system for network use.andM;The services provided by the system interface include:andM;* Interfaces to interrupt service routines for card-to-hostandM;computer DMAandM;* LAN frontplane hardware and timer functionsandM;* Message channels from the card to the host for errorandM;reportingandM;* Tracing and network management.andM;This article describes the CONE architecture and the featuresandM;it provides to support the OSI model.andM;OSI AddressingandM;Service Access Points and ConnectionsandM;Two concepts that are central to the OSI model are serviceandM;access points  SAPS) and connections (see Fig.andP;  2).andP;  TheseandM;concepts apply at every OSI layer and represent the relationshipandM;between a protocol layer and a black box containingandM;all the protocol layers below it.andM;An SAP is an addressable point at which protocol servicesandM;are provided for a layer user.andP;  A layer user is the next-higherandM;protocol layer (e.g., the layer user of the networkandM;layer is typically the transport layer).andP;  SAPS for higher-layerandM;users are identified by address or SAP selector informationandM;carried by the protocol header.andP;  Protocol headers are discussedandM;in the next section.andM;A connection represents an association between a pairandM;of users for the exchange of information.andP;  In the CCITT X. 25andM;standard, which defines protocols that correspond to theandM;first three layers of the OSI model, connections are calledandM;virtual circuits.andP;  Each connection represents a separate communicationandM;path that is maintained by lower-layer protocols.andM;If data stops moving on one connection (e.g., if anandM;application stops receiving data), data can still be exchangedandM;over other connections, since they are independent.andM;An analogy will serve to illustrate these concepts.andP;  A serviceandM;access point is like a multiline telephone-the kindandM;with the lighted buttons across the bottom, which is typicallyandM;used by small businesses or departments.andP;  The telephoneandM;(SAP) is the point at which service is offered by theandM;telephone company (lower-layer protocols).andP;  The telephoneandM;has a telephone number (address or SAP selector) whichandM;is used by the telephone company to identify it when placingandM;calls (see Fig.andP;  3).andP;  A connection is like an individualandM;call from one telephone number to another.andP;  just like theandM;lighted buttons on the telephone, several connections mayandM;be alive simultaneously between two or more phone numbers.andM;Each lighted button (connection endpoint identifier)andM;can be viewed as the end of an imaginary wire which isandM;used to represent that distinct instance of communicationandM;with a remote user.andP;  The same pair of telephones may evenandM;have more than one connection active between them at aandM;time, each with its own lighted button on each telephone.andM;The user can specify which connection will send or receiveandM;data by pressing the related button (connection endpointandM;identifier).andP;  If a remote user stops listening on a given connection,andM;the local user is still free to talk on other connectionsandM;whose remote users are more responsive.andM;Protocol HeadersandM;Most networking protocols send data from a local to aandM;remote layer user by adding protocol control informationandM;to the front of the layer user's data buffer.andP;  This prependedandM;control information is called a protocol header.andP;  The concatenatedandM;result then becomes user data for the next-lowerandM;layer of protocol (see Fig.andP;  4).andP;  This works much the sameandM;as envelopes within other envelopes, with the outermostandM;envelopes corresponding to lower layers of protocol.andP;  EachandM;protocol layer's header control information corresponds toandM;handling instructions on each envelope.andP;  When a packet isandM;received by a machine, each protocol layer examines andandM;removes its handling instruction envelope (header) andandM;delivers the contents to the next-higher protocol layer.andP;  OneandM;crucial piece of header information identifies which moduleandM;is the next-higher layer.andP;  In the OSI model, this is calledandM;the SAP selector.andP;  Datagram protocols carry the SAP selectorandM;in each packet and treat each packet independently of allandM;others.andP;  Connection-oriented protocols only exchange theandM;(possibly large) SAP selectors during the connection establishmentandM;handshakes.andP;  Successive packet headers carry onlyandM;a connection endpoint identifier, which is a dynamicallyandM;allocated shorthand reference that is mapped by the receivingandM;protocol to the specific connection between a pair ofandM;layer users.andM;Addressing RelationshipsandM;Every user application finds a remote application viaandM;some sort of application directory, which is analogous toandM;a telephone directory.andP;  To communicate with an applicationandM;on another machine, the directory maps the target application'sandM;name into an NSAP (network service access point)andM;and an n-tuple vector of SAP selectors.andP;  The NSAP is theandM;intermachine address for the machine, and the n-tuple vecandM;-tor contains an entry (intramachine address) for each OSIandM;layer used to communicate with the application on theandM;target machine.andP;  There are many schemes for assigning SAPandM;selector values to each of the entries in the n-tuple vector.andM;The ISO OSI standards offer little guidance as to which isandM;the best scheme.andP;  However, the important thing is that theandM;n-tuple vector combination be unique for application-to-applicationandM;communication over a network.andM;The intermachine address, or NSAP, for all theandM;applications on this machine is X. The lines in Fig.andP;  5 doandM;not represent connections but addressing relationships,andM;that is, they show which module is pointed at by an addressandM;and what are valid address combinations.andP;  For applicationandM;A in Fig.andP;  5, the n-tuple vector is P1, S1, T1 and for applicationandM;B the n-tuple vector is P22, S1, T1.andP;  For these twoandM;applications the protocol stack uses the presentation layerandM;SAP selector values Pi and P22 to tell these two applicationsandM;apart.andP;  For application C, which has the n-tuple P44,andM;S9, T1, the presentation layer SAP selector P44 would beandM;redundant because no other application uses the subvectorandM;S9, T1.andP;  For application D the n-tuple is P77, S9, T2.andP;  SinceandM;application C and D have the same SAP selector for theandM;session layer (S9), the SAP selectors are interpreted withinandM;the context of the transport layer SAP selectors Ti and T2,andM;respectively.andM;Direct applications are applications that use the servicesandM;of lower OSI layers and bypass some of the upper-layerandM;protocols.andP;  To the rest of the OSI stack these applicationsandM;look like alternative modules to the upper OSI layers.andP;  ForandM;example, applications E and F use the session layer directly.andM;To the lower-layer protocols they look like alternative protocolandM;modules of the presentation layer.andP;  The address vectorsandM;for applications E and F are S32, T2 and S99, T2,andM;respectively.andP;  Applications G and H use the transport layerandM;directly and they are addressed by the vectors T40 andandM;T50, respectively.andM;Protocol Module InterfacesandM;In CONE, interfaces to protocol layers are procedure based,andM;as opposed to being message-based as in many previousandM;network products.andP;  Procedure-based means that protocolandM;modules call one another instead of sending messagesandM;to each other through the operating system.andP;  This minimizesandM;the number of instructions because a data packet can passandM;through the protocol layers and be processed without beingandM;queued.andP;  When necessary, protocol interface procedureandM;calls are converted to messages to cross a process boundary-forandM;instance, when crossing the OSI Express card backplaneandM;into the host operating system.andP;  Within the OSI ExpressandM;card protocol stack, higher-level protocol layers callandM;lower-level protocols to process outbound packets, andandM;lower-level protocol layers call higher-level protocols toandM;process inbound packets.andP;  To avoid bugs that would be veryandM;hard for a protocol designer to anticipate, reentrance is notandM;allowed, that is, a protocol module cannot call back intoandM;the protocol module that called it.andP;  This means that packetsandM;move in one direction at a time through the protocol stackandM;before all the procedures return to the outermost CONEandM;routine.andM;Protocol layer interrelationships and protocol moduleandM;interfaces in CONE are represented by three central dataandM;structures: protocol entries, paths, and service access pointandM;(SAP) entries.andM;Protocol EntriesandM;For the OSI Express card there is a protocol entry dataandM;structure for each protocol layer in the system.andP;  This includesandM;protocols from physical layer 1 (IEEE 802.3 or 802.4andM;LAN) to application layer 7 which contains the AssociationandM;Control Service Element (ACSE).andM;The protocol entry for each protocol layer containsandM;a list of pointers to all of its standard procedure entryandM;points and other information, such as protocol identifiers,andM;statistics, and trace and log masks.andP;  Standard procedure entryandM;points include separate calls for actions like establishing andandM;destroying network connections, sending and receiving data, andandM;special control commands.andP;  This list of entry points is used toandM;bind modules dynamically in a way similar to the protocolandM;switch table in the University of California, Berkeley UNIXandM;networking implementation.andM;Separate entry points exist for categorically different actionsandM;and for each direction of packet travel-for example,andM;the entry points SP_Send_Down() for outbound packets andandM;SP_Send_Up() for inbound packets.andM;These separate entry points speed access to aandM;protocol's action-handling routines andandM;allow protocols to take advantage of implicitandM;assumptions about the state of a path, thusandM;reducing extraneous state checks and minimizingandM;the number of instructions in theandM;most common data-handling cases.andP;  All protocols handleandM;the same parameter structure for each procedure call, allowingandM;protocols to be used interchangeably as buildingandM;blocks in different combinations as necessary to reach aandM;given destination.andM;The SAP lookup tables are also set up for each protocolandM;layer right after power-up and all are empty except theandM;tables for the data link (layer 2) and internet protocol (layerandM;3) layers.andP;  The SAP lookup table contains the SAP selectors.andM;Part of the system configuration at power-up is to set upandM;the SAP lookup tables so that the data link protocol moduleandM;(layer 2) can find the network module (layer 3) and layerandM;3 can find the transport module (layer 4).andP;  The remote netandM;-work SAP (NSAP) table is also empty because there is noandM;communication with remote nodes at the beginning.andP;  If aandM;remote node did try to connect right after power-up andandM;before any applications started to run, the internet protocolandM;layer would create a destination entry to remember whoandM;is calling and then it would use its SAP entry to find theandM;transport layer to give it the packet.andP;  The transport layerandM;would send an error packet back to the remote node becauseandM;no transport SAP selector values would be active-theandM;transport layer would not know of any layer users aboveandM;it yet.andM;Path Data StructureandM;When an application begins to communicate with anandM;application on another machine, several data structures areandM;set up by CONE to handle the connection between the twoandM;applications.andP;  One of these data structures is the path dataandM;structure.andP;  The path data structure represents an individualandM;connection and serves as a focal point to tie together theandM;collection of all supporting information required to talk toandM;a remote application.andP;  It also represents the intramachineandM;route taken through the protocol layers by packets on aandM;given connection from the user to the LAN interface.andP;  ItandM;consists of an ordered list of all the protocols involved inandM;the conversation, together with their connectionandM;state information for this connection.andP;  As each protocolandM;module is called by CONE to process an event  it isandM;passed a pointer to its entry in this list.andP;  This pointerandM;is represented by the Pathentry parameter shown in the interfaceandM;call IP_send_down.andP;   The other parameter, buf, points to theandM;parameter block that points to the line data buffers containingandM;the data packets.andP;  Parameter blocks and line data buffersandM;are discussed later when the  CONE memory manager is described.andM;When each protocol is finished with its part of the overallandM;processing, the Pathentry pointer is used to find the nextandM;protocol module to be called, either above or below the currentandM;one, depending on whether the packet is being received or transmitted (seeandM;the previous and next entries in the path data structure inandM;Fig.andP;  7).andP;  Different stacks of protocols can be used for differentandM;connections by changing the makeup of the path template.andM;Paths are used by both datagram and connection-orientedandM;protocols on a packet-by-packet basis.andM;SAP EntriesandM;SAP entries are used by protocols to find each otherandM;when a path is first being created.andP;  A SAP entry containsandM;the SAP selector value that represents the intramachineandM;address of the next-higher layer user.andP;  This relationship isandM;recorded in a standard data structure so that other subsystemsandM;like tracing, logging, network management, andandM;dynamic debuggers can know which modules are involvedandM;with a given path or packet.andP;  Each path entry points to theandM;SAP entry that represents the user on the local end of theandM;connection.andM;When an OSI application is first activated, it sets up theandM;n-tuple vector of SAP selectors stored in the SAP lookupandM;tables.andP;  Each cell in the n-tuple is handled by a separateandM;protocol layer.andP;  When CONE calls a protocol module thatandM;serves a new user, it passes the user's SAP selector value,andM;user dependent parameters, and a pointer to the relatedandM;protocol global entry for the next-higher layer in the n-tuple.andM;The called protocol layer adds the new SAP selectorandM;value to its SAP lookup table.andP;  The relationship of each newandM;SAP selector value to other values and the network topologyandM;is protocol dependent because, besides the SAP selectorandM;value, information from the protocol header on an incomingandM;packet is often used by the protocol layer as partandM;of the key value to find a given SAP entry.andP;  The responsibilityandM;of managing these key values belongs to the protocolandM;module.andP;  CONE supports the protocols in this function byandM;providing address management utility routines that performandM;common functions like creating and destroying SAPandM;entries and high-speed mapping of key values to SAP-entryandM;pointers for a given SAP entry.andM;Besides SAP entries, there is another structure called theandM;destination entry, which is used by the data link layer andandM;the network layer to contain network intermachine addressesandM;and other information about the remote node.andP;  In alignmentandM;with the functions defined in the OSI model, destinationandM;entries for the network layer represent the NSAP forandM;a remote machine beyond the LAN, and destination entriesandM;for the data link layer represent machines that share theandM;same link (e.g., a LAN) with the local machine.andP;  The destinationandM;entry is a standard data structure for all the informaandM;-tion that needs to be remembered about a remote machine.andM;Besides the NSAP, examples of other information thatandM;would be stored in a destination entry include route andandM;remote dependent protocol parameters (e.g., packet size,andM;options, version).andP;  This structure can be used to filter traceandM;and log data for each destination to avoid overloading outputandM;files.andP;  Transient relationships can exist between theandM;network and data link layer destination entries to representandM;routing information-for example, to forward a packet toandM;the network layer for destination A, use the data link layerandM;on destination B as the next stop.andP;  References to destinationandM;entries are counted to ensure that they are held in existenceandM;while they are pointed at by other structures.andM;Tying it TogetherandM;The protocol entry, path, and SAP entry data structuresandM;together provide the framework that enables protocol modulesandM;to create and maintain network connections betweenandM;applications on different machines.andP;  When a user applicationandM;makes an outbound connection, it directly or indirectlyandM;passes down all the related local and remote address informationandM;needed to identify the remote machine and all theandM;modules on each end of the connection.andP;  CONE uses thisandM;information when setting up the path data structure andandM;its relationship to local SAP entries.andP;  As the protocols sendandM;packets to the remote node to set up the connection, theandM;address information is carried by the protocol headers.andP;  ForandM;connections coming alive in the inbound direction, theandM;address information in the protocol headers is used by eachandM;protocol module to find a SAP entry that contains the informationandM;needed to initialize its entry in a fresh path dataandM;structure.andP;  Inbound paths are initialized upward, one protocolandM;layer at a time.andP;  When the incoming connectionandM;reaches the user application, the path data structure is aandM;mirror image of the one built for the outbound path on theandM;initiating machine.andP;  At any time during the life of the path,andM;CONE can be requested to extract all the address (and protocolandM;parameter) information from a path.andP;  This informationandM;can be used by a user application to call a remote userandM;back, or during an error log for precise identification of allandM;the modules on each end of a connection having a problem.andM;Surrounding these common data structures is an extensiveandM;list of rules related to how these structures are usedandM;and what can and cannot happen as a result of a protocolandM;interface event procedure call.andP;  These rules specify:andM;* What services a protocol at a given layer can rely onandM;from the protocol layer below it without binding itselfandM;to a specific lower protocol.andP;  This is needed for supportingandM;protocol replaceability (e.g., OSI internet protocolandM;can work with IEEE 802.3, IEEE 802.4, X.25, LAPB, testandM;modules, etc.).andM;* How protocol facilities are enabled and disabled, andandM;how protocol-specific information is passed to a moduleandM;in the middle of the protocol stack without the modulesandM;around it having to know what is happening.andP;  This isandM;needed for protocol module independence and also forandM;protocol replaceability.andM;n How paths are used when connections at various levelsandM;have different lifetimes, or when multiple connectionsandM;multiplex onto each other.andM;n Which modules have the right to read or write each ofandM;the fields in the common data structures.andM;n At what times the data structure fields are known to beandM;valid or assumed to be invalid.andM;2 How data sent or received on the network wire (lineandM;data) flows from layer to layer.andM;*  How buffer space is managed for multiple protocol layersandM;and what layer has the right to touch a line data bufferandM;(buffer containing data packets) at any given time.andM;*  How a line data buffer is to be segmented and reassembledandM;at a given layer when multiple layers have thisandM;ability.andM;*  How flow is controlled on a system-wide basis.andP;  For example,andM;when there are multiple connection-oriented protocols,andM;buffers do not need to be reserved by each layerandM;to handle its own flow control, retransmission, and queuingandM;requirements.andP;  All layers know collectively what willandM;happen to data buffer memory entering or exiting theandM;system.andM;* How to handle arbitrarily complicated OSI protocol interfaceandM;events with a minimum number of simple, standardandM;buffer structures and interface calls.andM;* How to handle error situations, especially under raceandM;conditions where things are going wrong on both endsandM;of the path at the same time.andM;Process ModelandM;One of the major goals of CONE is to provide an architectureandM;where protocol modules can be easily ported to differentandM;environments.andP;  To provide a portable architecture, it isandM;essential that a well-defined process structure be ported asandM;well.andP;  This allows the protocol modules to be designed withandM;a specific process structure in mind.andM;The underlying process model for the CONE protocolandM;code is procedure-oriented.andP;  The CONE process model differsandM;from a typical time-sliced dispatching algorithm inandM;that once a task is dispatched, it is run to completion.andM;CONE performs a sort of &quot;pseudo-multitasking&quot; in that theandM;system depends on the timely completion of a task ratherandM;than incurring the overhead of process preemption andandM;context-switching.andP;  A task can be thought of as an eventandM;handler.andP;  When a CONE task is invoked, the dispatcherandM;makes a procedure call to the related event handler procedure.andM;The event handler is then free to do whatever it likesandM;but must eventually return to the dispatcher.andP;  When thereandM;is no work to be done, the card is idle waiting for an externalandM;event to occur.andP;  When an external event occurs, the handlerandM;for the event is scheduled.andM;A scheduled event handler is represented by a small dataandM;structure called a token.andP;  The protocol module provides theandM;space for the token as part of its path data structure.andP;  TheandM;token contains, among other things, the entry point of theandM;event handler.andP;  When an event handler is scheduled, theandM;token is added to the end of a global FIFO task queue.andP;  TheandM;dispatcher simply calls the event handling routine whenandM;the routine's token reaches the front of the queue.andP;  BecauseandM;of the potential overhead, task priorities are avoided asandM;much as possible.andM;All Cone-based event handlers are considered to beandM;tested, trusted system-quality code.andP;  With this type of processandM;model, the protocol modules must abide by two rules.andM;First, the protocol module must complete execution asandM;quickly as possible.andP;  Waiting in a loop for an external eventandM;is not allowed because it would delay other tasks fromandM;running and degrade performance.andP;  Second, a protocol moduleandM;is not allowed to reenter the protocol module that calledandM;it.andP;  Disallowing a protocol module from being reenteredandM;avoids the possibility of infinite loops, and makes codingandM;of the protocol modules much simpler because only oneandM;protocol module at a time can be changing the commonandM;data structures.andP;  Reentrance in a procedure-based system isandM;a fertile bug source.andP;  For a small cost in performance, reentranceandM;can be avoided by simply scheduling a task to callandM;the other layers back only after they have exited back toandM;the dispatcher.andM;In this example a packet is received thatandM;requires a TP4 AK (transport 4 acknowledgment) packetandM;to be sent back out on the LAN.andP;  When a packet for the OSIandM;stack is received from the LAN, a frontplane interrupt isandM;generated.andP;  The frontplane interrupt service routine willandM;service the hardware, queue the packet, schedule the inboundandM;task of the data link protocol module (LLC = logicalandM;link control), and exit.andM;LLC processes the packet andandM;calls the network layer's protocol module (IP]), which processesandM;the packet and calls the transport protocol moduleandM;(TP4).andP;  Since TP4 was entered via its inbound packet interfaceandM;call, it is not allowed at this time to call an outboundandM;interface routine to send an AK.andP;  Therefore, it must scheduleandM;an AK task  to send the AK packet out after the inboundandM;routines are done.andP;  After processing of the inbound packet,andM;TP4 returns to IP which returns to LLC, which returnsandM;to the CONE dispatcher.andP;  The CONE dispatcher then movesandM;on to the next pending event, namely the AK task, andandM;wakes up TP4 to handle the event.andP;  Since TP4 was enteredandM;directly from the dispatcher, it is now free to send outboundandM;(or inbound) packets, since no other protocol modules areandM;in danger of being reentered.andP;  At  TP4 calls IP to sendandM;the AK, which calls LLC to put the packet on the LAN.andM;Memory ManagementandM;CONE provides two types of memory: memory objectsandM;and line data buffers.andP;  A memory object is a contiguousandM;block of memory (heap space).andP;  The intended use of a memoryandM;object is to hold a data structure for direct use by aandM;Cone-based module.andP;  Memory objects can be shared byandM;multiple modules but there is always a single, well-definedandM;owner which changes very little over the lifetime of theandM;object.andM;Line data buffers hold data that is sent and received onandM;the network wire or line.andP;  Unlike memory objects, line dataandM;buffers are passed, created, and destroyed outside theandM;CONE environment.andP;  To ensure portability, all Cone-basedandM;modules allocate, deal locate, write, read, and manipulateandM;line data buffers through macro calls to the CONE bufferandM;manager.andP;  Since protocol modules aren't coupled to specificandM;buffer structures, only the buffer manager needs to beandM;changed to use a different underlying structure for efficientandM;interaction within another operating system.andP;  Line data buffersandM;are not guaranteed to be contiguous and may consistandM;internally of several smaller memory objects chained together.andM;CONE'S use of memory is optimized for speed in allocatingandM;and deallocating memory objects and line data buffers.andM;At the same time, it is designed to make maximum use ofandM;available memory by taking advantage of the predeterminedandM;characteristics of protocol memory use.andP;  This can beandM;contrasted with the memory managers in many conventionalandM;operating systems which are not optimized for speedandM;of allocation and deallocation, since most regular processesandM;allocate arbitrary-size memory objects and keep them untilandM;the process dies.andP;  The CONE buffer manager also plays aandM;major role in card flow control, ensuring that all users canandM;continue to run in worst-case memory situations.andP;  Refer toandM;the article on page 36 for a detailed discussion on OSIandM;Express card flow control.andM;Memory Object AllocationandM;A fundamental element of any memory management systemandM;is the ability to allocate and deallocate contiguousandM;blocks of memory dynamically.andP;  Although a basic function,andM;the method chosen can have a significant effect on performance.andM;We studied the first-fit, best-fit, and buddy systemandM;memory allocation algorithms and these methods provedandM;to be slower and more complicated than we needed.andP;  NetworkingandM;applications typically make repeated requests forandM;memory objects that fall into a small number of fixed sizes.andM;Since the number of different memory object sizes is small,andM;a two-level scheme is used in which memory is first dividedandM;into one of two block sizes, and then small blocks areandM;subdivided to fill memory object pools.andP;  Having only twoandM;block sizes greatly reduces the time necessary to allocateandM;and deallocate a memory block.andP;  A memory block is allocatedandM;by removing the block at the head of a free list.andP;  AandM;memory block is deallocated by inserting the block at theandM;head of the free list.andP;  Large block sizes are only used toandM;grant large line data buffer requests, while the small blockandM;sizes are used for both small line data and memory objects.andM;Dividing the entire memory into fixed-size blocks eliminatesandM;external fragmentation because there are no wastedandM;chunks of memory between blocks.andP;  However, internal fragmentationandM;can still be a problem since the memory blockandM;may be larger than needed.andP;  To reduce internal fragmentationandM;a pool manager was developed.andP;  The pool managerandM;takes the smaller-size blocks described above and dividesandM;them into even smaller blocks of various fixed sizes so thatandM;they fit the groups of memory objects used by Cone-basedandM;modules.andP;  There are several pools, each managing a differentandM;object size.andP;  By studying the distribution of memory objectandM;sizes that are allocated, we determined that four differentandM;pool object size groups were needed.andP;  With the four poolandM;object size groups and the two original block sizes, wastedandM;space resulting from internal fragmentation was reducedandM;to approximately 10 to 15 percent.andP;  Cone-based modulesandM;are unaware of whether a memory object comes from aandM;pool or directly from the free list, since this detail is hiddenandM;behind the CONE interface.andM;The pool manager is designed to allocate and deal-locateandM;memory objects very quickly.andP;  The speed of the pool manager,andM;combined with the simplicity of the memory free list,andM;reduces the time required to allocate and deallocate memoryandM;to a very small portion of the overall processing time.andM;Line Data Buffer StructureandM;The structure of a line data buffer is a key part of theandM;CONE design.andP;  For portability, the internal structure of lineandM;data buffers is hidden from Cone-based modules.andP;  LineandM;data buffers are passed from module to module as protocolandM;interface events propagate through the stack.andP;  To the layerandM;users, a line data buffer is represented by a pointer to aandM;standard data structure in a memory object called a parameterandM;block which invisibly references the memory area thatandM;actually stores line data.andP;  The parameter blockandM;functions like a baton that is passed from module to module.andM;The layer currently holding the parameter block is theandM;one that has the right to work with the buffer.andP;  The parameterandM;block has a fixed part that carries the standard parametersandM;every protocol module must recognize, such as the currentandM;amount of line data contained in the buffer, whether theandM;buffer contains a packet fragment or the end of a fragmentandM;train, and what protocol interface event the packet is relatedandM;to.andP;  The rest of the parameter block can be used for storingandM;protocol dependent parameters related to the interfaceandM;event.andP;  This structure allows the protocol interface procedureandM;calls to have a very small number of parameters,andM;speeding up procedure calls from layer to layer.andP;  It alsoandM;provides the space for queuing event-related informationandM;in the suboptimal case where the event can't immediatelyandM;be acted upon and propagated through the stack.andM;Data copying is kept to a minimum in the buffer managerandM;design, both to maximize performance and to minimizeandM;memory use.andP;  This led to a special feature in the parameterandM;block design.andP;  Many connection-oriented protocols, such asandM;OSI transport, need to keep a copy of each transmittedandM;packet until an acknowledgment of delivery is receivedandM;from the remote machine in case the packet needs to beandM;retransmitted.andP;  Rather than allocate another buffer and copyandM;the data, the parameter block is simply marked with aandM;pointer to the protocol module's entry point so that theandM;buffer can be given back when the lower protocol layersandM;have finished with it.andP;  When this entry point is called, theandM;protocol module queues the original packet, rather than aandM;copy.andP;  The retransmission timer is also started during thisandM;buffer return call made by the lower layers after the previousandM;transmission has left the machine.andP;  This avoids theandM;embarassing problem of having multiple retransmittedandM;copies of the same packet piling up in the lower layers.andM;Line Data Buffer ManagerandM;The design of the primitives for the line data buffer managerandM;was driven by what the module designers needed toandM;implement the protocol layers' functionality.andP;  PrimitivesandM;exist for allocating and deal locating buffers, reading or writingandM;data in a line data buffer, adding or removing headerandM;data in a line data buffer, disabling or enabling line dataandM;flow inbound or outbound for a path, pacing of line dataandM;buffer use for each path, and a variety of other functions.andM;Line data buffers are allocated asynchronously.andP;  If a moduleandM;requests a line data buffer and one is not available, theandM;buffer manager will schedule an event and inform the moduleandM;when the buffer is available.andM;There are many line data buffer management functions.andM;However, the two most important functions are responsibleandM;for fragmenting a packet for transmission and reassemblingandM;a packet when it is received.andM;Fragmenting a Data Packet.andP;  When a protocol module, suchandM;as the module for the transport layer, receives an outboundandM;packet that is larger than it can legally send, the packetandM;must be fragmented and sent as several smaller data packets.andM;When the transport layer fragments a packet it mustandM;attach a header to each fragment.andP;  The buffer manager providesandM;a primitive that allows the protocol module to attachandM;its header, which is in a separate buffer, at any point inandM;the data packet without having to copy data from the originalandM;buffer.andP;  By changing fields in the segment control structuresandM;(see Fig.andP;  10) within the line data buffer, the headerandM;can be attached without copying data by making the newandM;fragment buffer point into the relevant data portion of theandM;unfragmented buffer.andP;  This method significantly improvesandM;performance because it avoids data copying.andM;Reassembling a Data Packet: Some protocol modules, suchandM;as the network layer, need to reassemble a fragmented inboundandM;packet before delivering it to the layer above.andP;  TheandM;buffer manager provides a primitive for reassembling a dataandM;packet.andP;  This routine will handle out-of-order, duplicate,andM;and overlapping fragments.andP;  Again, links in internal bufferandM;segment control structures can be manipulated to avoidandM;recopying the data in the buffers being coalesced.andM;line data buffers to send and receive packets.andP;  The bufferandM;manager design evolved from a method in which line dataandM;buffers were preallocated for each connection based onandM;where they were most needed.andP;  When a connection wasandM;established, enough line data buffers were preallocated toandM;ensure that the connection could always make progress.andM;Any line data buffers that were not preallocated could beandM;shared by all other connections to increase performance.andM;The idea was to ensure that each connection had enoughandM;buffers to make progress in worst-case memory situations,andM;but allow connection performance to increase when extra,andM;uncommitted line data buffers were available.andM;Since the OSI Express card has a limited number of buffers,andM;it became apparent that preallocating line data buffersandM;restricted the total number of connections that the cardandM;could support.andP;  We wanted to support a greater number ofandM;connections.andP;  Good performance can be achieved as longandM;as too many of the open connections do not try to send orandM;receive data at the same time.andP;  The phone company is againandM;a good analogy.andP;  Everyone has a phone and performance isandM;generally good, even though there isn't enough switchingandM;equipment for everyone to make a call at the same time.andM;The algorithm used is to have all connections share aandM;pool of line data memory, rather than preallocate buffersandM;when a connection is established.andP;  When a moderateandM;number of connections are active, performance is good.andP;  AsandM;more connections become active at the same time, connectionandM;performance degrades since the aggregate system performanceandM;is divided among the active connections.andP;  ThisandM;proved to be a good compromise.andP;  Good performance wasandM;achieved while allowing a large number of connections.andM;Timer ManagementandM;Networking stacks use a large number of timer wakeups.andM;Each connection needs one or more problem timers to detectandM;when an expected event is overdue and recovery actionandM;is necessary.andP;  Other timers are used to generate protocolandM;messages to check back with the remote machine beforeandM;its problem timers wake up, and to avoid long delays whenandM;the remote machine can't send because of the flow controlandM;rules of OSI transport.andP;  Unlike timers for most other applications,andM;network timers rarely expire in normal operation,andM;since the expected event usually occurs.andP;  Instead, they areandM;canceled or restarted.andP;  A resolution of 100 to 200 ms is justandM;fine since the timers are for exceptional events anyway.andM;Traditional timer manager implementations have keptandM;the timers in a linked list.andP;  This makes it very easy to dealandM;with the expiration of a timer because it is simply removedandM;from the front of the list.andP;  However, restarting a timer isandM;slow because the list has to be scanned to locate the properandM;place to insert it.andP;  In the case of the OSI Express card thisandM;proved to be too slow.andP;  During normal data transfer thereandM;are four timers for every connection, at least two of whichandM;have to be restarted every time a data packet is sent orandM;received.andP;  A quick analysis showed that with just 50 connections,andM;timer insertion could take as long as all other protocolandM;stack processing combined, causing the timer manager toandM;become a performance bottleneck.andM;What we needed was a way to restart timers quickly.andM;The solution is to keep timers in two unordered lists calledandM;the short-term bin and the long-term bin.andP;  Timer wakeupsandM;are represented by the same tokens that were describedandM;earlier for event handlers, with the addition of a &quot;time leftandM;until expiration&quot; field.andP;  When a timer is restarted it is simplyandM;inserted at the head of the appropriate bin.andP;  No scanningandM;has to be done every time a packet arrives.andP;  Periodically, aandM;monitor task runs that scans the entire short-term bin lookingandM;for timers that have expired since the last time it ran.andM;Those timers are removed from the bin and passed to theandM;scheduler to be put on the task queue.andP;  Every ten times theandM;timer monitor task runs, it also scans the long-term binandM;looking for timers that are getting close to expiring andandM;need to be moved down into the short-term bin.andM;The central idea of this algorithm is to spread the timerandM;list scanning overhead among many packets.andP;  To be successfulandM;the timer monitor task has to run at some large multipleandM;of the packet arrival rate.andP;  If a packet arrives every 5 ms,andM;the timer monitor task can't run every 10 ms or there wouldandM;be little savings.andP;  We found that a period of 100 ms is aandM;good compromise between precision and performance.andM;System InterfaceandM;The system interface is a collection of functions thatandM;provides the OSI Express card with an interface to theandM;embedding operating system on the card and communicationandM;with the host system housing the OSI Express card.andM;These functions include interrupt service routines andandM;message channels for the card-to-host error reporting, tracing,andM;and network management.andM;Interrupt SystemandM;There are eight available interrupt levels on the OSI ExpressandM;card.andP;  Level zero has the lowest priority and levelandM;seven the highest priority.andP;  The first three levels are softandM;interrupts in that they are generated by a processor writeandM;to a special hardware register.andP;  The rest of the interruptandM;levels are devoted to interrupt handlers for the various cardandM;hardware components.andP;  They include a timer hardware interrupt,andM;DMA hardware interrupt, LAN frontplaneandM;hardware interrupt, host backplane interrupt, power fail interrupt,andM;and memory parity and bus error interrupts.andM;The OSI Express card contains two types of code: theandM;full OSI protocol stack and the card monitor/debugger.andP;  TheandM;full OSI stack runs at interrupt level zero, which is theandM;card's background level, and the card monitor/debuggerandM;runs at interrupt level two.andP;  Interrupt level one is reservedandM;for applications that may need to preempt the normal OSIandM;protocol activities.andP;  The OSI stack is the largest and mostandM;active level since it contains all the protocol modules commonlyandM;used for general-purpose networking applications.andM;The card debugger runs at a higher interrupt level than theandM;OSI protocol stack and level one applications so that it canandM;preempt all protocol activity, allowing card diagnosis whenandM;either the OSI protocol stack or other applications are stuckandM;in loops.andM;There are two CONE dispatcher task queues, one forandM;the full OSI stack and one for the card monitor/debugger.andM;Each task queue represents a separate independent instanceandM;of the simple CONE process model.andP;  When a task queueandM;becomes empty the CONE dispatcher will return to theandM;module that called it.andP;  In the full-stack OSI case, the dispatcherandM;will return to the card background process, whichandM;is simply an infinite loop that calls the CONE dispatcher.andM;Since the card monitor/debugger runs at interrupt levelandM;two, the CONE dispatcher is called from the level twoandM;interrupt service routine.andM;Backplane Message interfaceandM;The OSI Express card's backplane interface is message-based,andM;in that an interface event (transfer of data inboundandM;or outbound) is represented as a message with all the eventandM;parameters and line data serially encoded into a string ofandM;bytes.andP;  The string is sent via DMA between the host computerandM;RAM and the OSI Express card.andM;Since the CONE protocol module interfaces are procedure-based,andM;a module called the backplane message interface,andM;or BMI, is used to translate CONE events (inboundandM;packets) into messages that are sent to the host operatingandM;system and eventually to user applications.andP;  For outboundandM;packets the backplane message interface converts messaged-basedandM;requests into CONE procedure calls.andP;  BecauseandM;of the way the backplane message interface and the CONEandM;protocol module interface are designed, any protocol moduleandM;can be accessed across the backplane without the protocolandM;module's knowing whether the entity above its interfaceandM;is adjacent to it inside CONE.andM;The following factors affected the design of the OSI ExpressandM;card's message-based backplane:andM;*  High-performance LAN interface chips require rapid,andM;high-bandwidth access to buffer memory when data isandM;being sent or received on the line.andP;  Line signaling is synchronous,andM;meaning that once started, data flows continuously,andM;one bit after another with no wait signals.andP;  ForandM;these reasons, the buffers accessed by the LAN chips areandM;located in RAM on the OSI Express card, rather than inandM;the host computer.andM;*  A specific word of host RAM cannot be rapidly read orandM;written by the OSI Express card's processor, nor can cardandM;RAM be rapidly read or written by the host processor.andM;Instead, so that many cards can share access to hostandM;RAM, the backplane is optimized for very high-speedandM;DMA bursts.andP;  This minimizes the amount of busandM;bandwidth lost during bus access arbitration (see articleandM;on page 8 for more about DMA and the OSI ExpressandM;card).andM;* The OSI Express card's processor operates as an asynchronous,andM;independent front end to the host processor.andM;Very little card-related processing occurs inside the hostandM;operating system, but rather in user-space processes belongingandM;to OSI applications.andP;  Since the user-space applicationsandM;can be busy, timesharing the host with otherandM;applications, swapped out to disk, and so on, the couplingandM;between the protocols on the card and the hostandM;system is very loose.andM;* The backplane hardware supports a large number of independentandM;DMA channels.andP;  Each CONE path that is tiedandM;to a user application is allocated an inbound and anandM;outbound DMA channel at path-creation time.andP;  There areandM;also fixed DMA channels for trace messages (inbound),andM;log messages (inbound), nodal management messagesandM;(inbound and outbound), debug/monitor messages (inboundandM;and outbound), expedited data which bypassesandM;normal flow control on each path (inbound and outbound),andM;and backplane messages which set up and tearandM;down paths and manage dynamic DMA channel assignmentandM;(inbound and outbound).andM;ConclusionandM;CONE provides a system design for supporting system-wideandM;and module-internal optimization.andP;  Flexibility in theandM;overall framework supports interchangeability of individualandM;protocol modules and protocols from multiple protocolandM;families, as well as portability of Cone-based codeandM;to almost any system.andP;  Having a coordinated overallandM;framework also makes the system much more instrumentableandM;and supportable.andP;  Finally, because of this system-wideandM;orientation, the overall system performance and theandM;number of connections supported for a given amount ofandM;RAM are much higher than they would otherwise be.andM;AcknowledgmentsandM;The members of the interdivisional task force that definedandM;CONE include: Sanjay Chikarmane, Allwyn Sequeira,andM;Collin Park, and Dean Thompson.andP;  Other contributors whoandM;provided additional details and site representation in otherandM;areas include Gerry Claflin, Steve Dean, Doug Gregory, andandM;Lori Jacobson.andP;  CONE system designers include some ofandM;those already mentioned, as well as Bill Gilbert and DaveandM;Woods.andP;  As mentioned earlier, CONE was built with theandM;best ideas taken from previous products.andP;  CONE representsandM;the work of many people, but the work of one person particularlyandM;stands out, Carl Dierschow, who originated theandM;leaf node architecture which greatly influenced the CONEandM;design.andM;ReferencesandM;1.andP;  J.J.andP;  Balza, H.M.andP;  Wenzel, and J.L.andP;  Willits, &quot;A Local Area NetworkandM;for the HP 9000 Series 500 Computers,&quot; Hewlett-Packard journal,andM;Vol.andP;  35, no.andP;  3, March 1984, pp.andP;  22-27.andM;2.andP;  C.Dierschow,&quot;leaf Node Architecture,&quot;Hewlett-Packard Journal,andM;Vol.andP;  37, no.andP;  10, October 1986, pp.andP;  31-32.andM;3.andP;  K.J.andP;  Faulkner, C.W.andP;  Knouse, and B.K.andP;  Lynn, &quot;Network ServicesandM;and Transport for the HP 3000 Computer,&quot; Hewlett-Packard journal,andM;Vol.andP;  37, no.andP;  10, October 1986, pp.andP;  11-18.andM;4.andP;  D.M.andP;  Tribby, &quot;Network Services for HP Real-time Computers,&quot;andM;Hewlett-Packard Journal, Vol.andP;  37, no.andP;  10, October 1986, pp.andP;  22-27.andM;5.andP;  S.J.andP;  Leffler, W.N.andP;  Joy, R.S.andP;  Fabry, and M.J.andP;  Karels, NetworkingandM;Implementation Notes, 4.3 Edition, Computer Systems ResearchandM;Group, Department of Electrical Engineering and Computer Science,andM;University of California, Berkeley, Revised June 5, 1986.andM;@@@081550448 0HPJIja028ULOTandM;The upper three layers of the HP OSI Express card shareandM;the same architecture and use tables to simplify theirandM;implementations of the OSI stack.andP;  The application andandM;presentation layers are implemented in the same module.andM;THE TOP THREE LAYERS of the OSI Reference ModelandM;consist of the session layer, the presentation layer,andM;and the application layer.andP;  The purpose of the sessionandM;layer is to provide organized and synchronized exchangeandM;of data between two cooperating session users-that is, twoandM;presentation layers in different applications.andP;  The sessionandM;layer depends on the services of the transport layer to provideandM;the end-to-end system communication channels forandM;data transfer.andP;  The presentation layer's job is to negotiate aandM;common transfer syntax (representation of data values) thatandM;is used by applications when transferring various dataandM;structures back and forth.andP;  The application layer is the highandM;-est layer of the OSI Reference Model and does not provideandM;services to any other layer.andP;  This layer uses the commonandM;protocol called Association Control Service Element, orandM;ACSE, to establish and terminate associations between applicationsandM;and to negotiate things that are common to applications.andM;Session LayerandM;The OSI Express card's implementation of the sessionandM;layer provides services to the presentation layer that enableandM;it to:andM;* Establish a virtual connection with a peer session userandM;to exchange data in a synchronized manner and releaseandM;the connection in an organized mannerandM;* Negotiate for the use of tokens to exchange data andandM;arrange for data exchange to be half-duplex or full-duplexandM;* Establish synchronization points within the session connectionandM;dialogue so that in the event of errors, dialogueandM;can be resumed from the agreed synchronization pointandM;* Iinterrupt a dialogue and resume it later from a prearrangedandM;point.andM;Session ArchitectureandM;The OSI session protocol is now an international standardandM;which is specified in ISO documents 8326 and 8327.andM;However, defect reports and enhancements continue to beandM;made to the base standard.andP;  These changes will continue toandM;occur long after the first release of the first OSI ExpressandM;product.andP;  Therefore, one of the key design considerationsandM;for our implementation of the session protocol was to provideandM;for easy maintenance of the software.andP;  Another designandM;goal was to isolate the protocol software from machine andandM;system dependencies, thus allowing the protocol softwareandM;to be portable from machine to machine with little or noandM;changes.andP;  The common OSI networking environmentandM;(CONE) architecture enabled us to achieve our portabilityandM;goal.andM;The session software is designed to separate those functionsandM;that pertain specifically to the OSI protocol and thoseandM;that are called local matters.andP;  Local matters are primarilyandM;tasks that are not included in a protocol specification becauseandM;they depend on specific system capabilities, such asandM;user interfaces and memory management.andM;The OSI Express implementation divides session functionsandM;into two main modules, the session CONE managerandM;and the SPM (session protocol machine).andM;The session CONE manger is primarily responsible forandM;servicing local matters and providing a clean interface betweenandM;CONE and the SPM.andP;  Some of the major functions ofandM;the session CONE manager include:andM;* Translating CONE interface macros into a form the SPMandM;can act uponandM;* Providing session memory requirements using the CONEandM;buffer managerandM;* Providing session timer requirements using the CONEandM;timer managerandM;* Providing much of the session abort processing capabilitiesandM;* Managing the underlying transport connection.andM;The SPM is responsible for servicing the OSI sessionandM;protocol requirements.andP;  The three primary functions theandM;SPM performs are:andM;* Coordinating state table transitionsandM;* Encoding SPDUS (session protocol data units)andM;* Decoding SPDUS.andM;Most of the future changes to the session standard willandM;affect these three SPM operations.andP;  Therefore, maintainabilityandM;was a critical concern in design decisions for the SPM.andM;Session State TableandM;Aside from some clarifying text, the entire OSI sessionandM;protocol can be defined in terms of tables.andP;  Ten separateandM;tables dictate session protocol behavior.andM;The intersection of any given session event (outbound sessionandM;primitive or inbound SPDU) with a valid session protocolandM;state indicates a set of specific actions and the new protocolandM;state to enter.andP;  For example, once the underlying transportandM;connection is established, the SPM is in state STA01C.andP;  WhenandM;a CN event arrives (indicating a successful connection withandM;another session layer) the SPM will change state if theandM;proper predicate conditions are met.andP;  In this example, if theandM;predicate condition ^p01 is satisfied, a transition to stateandM;STA08 occurs, which causes the SPM to generate a sessionandM;connect indication (ScoNind) to its session user.andM;A fully functional OSI session service implementationandM;is responsible for coordinating the intersection of approximatelyandM;80 different session events with 32 different protocolandM;states.andP;  This creates 2560 possible state table transitions.andM;Close examination of the session state tables revealsandM;that only 600 of the 2560 possible state table transitionsandM;are considered to be valid.andP;  Also, many of the valid intersectionsandM;result in the same actions and next states.andM;A straightforward and common approach to implementingandM;the behavior of these state tables is to create a massiveandM;series of if-then-else and/or switch statements that account forandM;each of the valid session event-state intersections.andP;  WithandM;600 valid intersections to account for, the code's complexityandM;is high and its maintainability low.andM;For the OSI Express card implementation of the sessionandM;protocol the objective was to exploit the tabular structureandM;of the OSI session protocol as much as possible.andP;  By creatingandM;a structure of multidimensional arrays corresponding toandM;the OSI session state tables, a direct relationship can beandM;maintained between the OSI standard and the implementation.andM;Basic Schemes:andM;* Enumerated values of the current session SPM state andandM;the incoming session event are used as indexes into aandM;combination of arrays that generate a pair of event andandM;state indexes.andM;* Ten two-dimensional static arrays are defined, one forandM;each of the 10 protocol state tables defined in the OSIandM;session protocol standard.andP;  These arrays are called sparseandM;state table arrays.andP;  Each element in a sparse state tableandM;array is an unsigned byte that represents an index for aandM;unique C function that is responsible for processing theandM;specific actions of an event-state intersection.andP;  The eventandM;and state indexes generated above are used to select theandM;correct sparse state table array and serve as indexes intoandM;the state table array to generate the corresponding functionandM;index.andM;* The function index is used to select a specific pointerandM;to a function from an array of function pointers.andP;  TheandM;selected function is then invoked to service the requirementsandM;dictated by the session event and the SPM state.andM;Invoking functions from pointer arrays (also known asandM;jump tables) is one of the rarely used yet very powerfulandM;capabilities of the C programming language.andM;Encoding and Decoding SPDUSandM;Array manipulation also plays a key role in how theandM;session implementation performs the tasks of encoding andandM;decoding SPDUS.andP;  SPDUS are constructed in a fairly simpleandM;variable format that can be nested three levels deep.andM;The LI (length indicator) following the SI valueandM;indicates how many bytes remain in the SPDU.andM;The remainder of the SPDU consistsandM;of an optional combination of PGI (parameter group identifier)andM;units and PI (parameter identifier) units to defineandM;the particular parameters of the SPDU.andP;  PI units are usedandM;to encapsulate parameter values such as token items andandM;reason codes, while PGIS are primarily used to encapsulateandM;groups of related PI units.andP;  Each PI and PGI unit consistsandM;of a PI or PGI value identifying the type of parameters,andM;followed by a length value.andP;  The PI unit terminates withandM;the parameter value while the PGI unit follows with eitherandM;a parameter or one or more encapsulated PI units.andP;  TheandM;order in which PI and PGI units appear in an SPDU is alsoandM;important and is uniquely specified for each SPDU.andM;A fully functional session implementation is required toandM;encode and decode approximately 20 different types ofandM;SPDUS.andP;  There are about 30 different types of PI or PGI unitsandM;that make up these 20 SPDUS, with many SPDUS using theandM;same type of PI and PGI units.andP;  PI and PGI units have certainandM;parameter attributes associated with them, such as theandM;maximum number of bytes the parameter may occupy inandM;an SPDU.andP;  Because so many of the SPDUS contain the sameandM;types of parameters, and since the same parameter attributeandM;information is needed for both encoding and decoding theandM;SPDUS, the decision was made to define the parameter andandM;ordering attributes only once and make this informationandM;available for both the encoding and the decoding processes.andM;Once the SPDU identifier value forandM;the SPDU is determined, it serves as an index into an SPDUandM;script directory array which contains the script index  location)andM;and size of an SPDU script located in the SPDUandM;script array.andP;  The SPDU script array contains scripts thatandM;define the order in which parameters should appear inandM;each SPDU and indicate whether the parameters are mandatoryandM;or optional in that particular SPDU.andP;  For each parameterandM;of the SPDU, the SPDU script array also provides anandM;index that selects parameter attribute information from theandM;parameter attribute array.andM;Two independent programming modules are required toandM;build and parse the SPDUS.andP;  They share the informationandM;provided by the SPDU and parameter structures definedandM;above.andM;ACSE and Presentation LayerandM;The Association Control Service Element (ACSE) is theandM;common protocol for the seventh layer of the OSI hierarandM;-chy.andP;  ACSE is meant to be used to establish and terminateandM;an association between applications and to negotiateandM;things that are common to applications, which can be onandM;separate systems.andP;  The most important function providedandM;by this common protocol is the negotiation related to theandM;application context parameter.andP;  This parameter is a registeredandM;name that is passed between applications in the ACSEandM;connect PDU.andP;  The application context parameter definesandM;the scope of an application's functionality and is used byandM;local applications to ensure that the remote application isandM;appropriate for a particular association.andM;The presentation layer is the sixth layer of the OSIandM;model.&quot;,,' The presentation layer's job is to negotiate commonandM;transfer and abstract syntaxes that can be used byandM;applications when transferring various data structures backandM;and forth.andP;  Abstract syntax refers to the meaning of the data,andM;and transfer syntax refers to the manner of encoding theandM;data bits.andM;An application can use the presentation layer to specifyandM;several abstract syntaxes for use during an association.andP;  ForandM;example, an application might specify ACSE and virtualandM;terminal as two abstract syntaxes to be used together in aandM;specific association.andP;  The presentation layer will negotiateandM;these two abstract syntaxes during the connection establishmentandM;and add the transfer syntaxes for each of theandM;abstract syntaxes it is able to support.andP;  If these combinationsandM;are acceptable to both sides, subsequent data transfers areandM;transferred with presentation tags denoting the particularandM;abstract syntax  and thus which process should receiveandM;this data).andP;  The data is encoded in the negotiated transferandM;syntax and transformed to and from the local representationandM;by the presentation service.andM;OSI Express implementationandM;In the OSI Express card, the ACSE and presentationandM;layers are located in the same code section because bothandM;layers share the same challenge in their implementation.andM;The main complexity encountered in implementing ACSEandM;and presentation service on a card involved the encodingandM;and decoding of the ACSE and presentation protocol dataandM;units  (PDUS) specified by Abstract Syntax Notation OneandM;(ASN.1).andP;  The protocol data units contain the protocol conandM;-trol information and data that are exchanged between twoandM;instances of any protocol.andP;  Most protocols (e.g., transport,andM;network, LLC) specify the contents (transfer and abstractandM;syntax) of their PDUS by means of text within their protocolandM;specification document.andP;  Most of the upper-layer protocols,andM;such as FTAM, directory services, ACSE, and presentation,andM;use standard and more formal specifications contained inandM;ASN.1.andM;The OSI Express implementation separates the presentationandM;service into two parts: the protocol that provides transferandM;and abstract syntax negotiation for applications, andandM;the transformation of user data from ASN.1 transfer syntaxandM;to the local representation specified by the abstract syntaxandM;and vice versa.andP;  Only the protocol is implemented on theandM;card and described in this article, while the remainingandM;transformation of user data occurs in the host system.andP;  UserandM;data is delivered to the host fully encoded in the agreedandM;upon transfer syntax for a particular abstract syntax.andP;  HostandM;software recognizes the abstract syntax from a tag (presentationandM;context identifier) in the PDU and directly transformsandM;the data from the transfer syntax into a local form recognizableandM;to the particular application service element.andP;  ExceptandM;for encoding and decoding PDUS, implementation of theandM;presentation protocol was straightforward.andM;Two key considerations were identified during the designandM;phase: memory use and the stability of the OSI ACSEandM;and presentation standards.andP;  For memory use our goal wasandM;not to require a contiguous block of physical memory forandM;either encoding or decoding since large memory buffers inandM;our memory management scheme are not guaranteed.andP;  ThisandM;consideration quickly eliminated many alternative designs.andM;When we were doing our design the OSI standards wereandM;just gaining draft approval status with many changes promisedandM;in the future.andP;  Therefore, our design and architectureandM;had to be easy to modify.andP;  This architecture is similarandM;to that used by other layers in the OSI Express card.andM;The protocol machine is isolated from the CONE architectureandM;by the ACSE/presentation CONE manager.andP;  The CONEandM;manager provides a simple interface to the protocolandM;machine and insulates the protocol machine from concernsandM;of state transitions and memory availability.andP;  CONE is describedandM;in the article on page 18.andP;  The heart of the ACSEandM;and presentation protocol implementation is the PDU encoderandM;and decoder.andP;  Understanding some basic attributesandM;of ASN.1 provides some insight into the technical solutionandM;of encoding and decoding PDUS for the presentation andandM;ACSE protocols.andM;ASN.1andM;ASN.1 defines a means to specify the different types ofandM;data structures that can be transferred between protocolandM;layers.andP;  The ASN.1 standard does not specify the encodingandM;to be used for each type.andP;  A companion standard&quot; definesandM;the encoding rules which together with the ACSE and presentationandM;specifications define the bit encodings used betweenandM;the ACSE and presentation protocol layers.andP;  The followingandM;discussion does not differentiate between the termandM;ASN.1 and the encoding rules since only one set of encodingandM;rules exists for ASN.1.andM;The basic concept underlying ASN.1 encoding is quiteandM;simple.andP;  Primitive values are encoded as tag, length, andandM;value.andP;  The tag identifies the type of value, length indicatesandM;the length of the value, and value represents the contentsandM;of the PDU being encoded.andP;  Simple primitive types pre-definedandM;by ASN.1 include character string, Boolean, integer,andM;and real.andP;  Primitive types can also be bit string orandM;octet string.andP;  However, the encoding of these types is optional.andM;Primitive values are values that cannot be brokenandM;down further into other ASN.1 values.andP;  ASN.1 also definesandM;complex types, whose values can be broken into additionalandM;types.andM;To accommodate the need to encode complex types, valuesandM;can be constructed within outer structure definitions.andM;The encoding rules allow a value to consist of another tag,andM;length, and value.andP;  Structure definitions for these complexandM;types include:andM;* Sequence.andP;  A fixed ordered list of types.andM;* Sequence Of.andP;  An ordered list of a single type.andM;* Set.andP;  A fixed unordered list of types.andM;* Set Of.andP;  A fixed unordered list of a single type.andM;* Choice.andP;  A fixed unordered list of exclusive types.andM;These constructed types can be composed of additionalandM;constructed types.andP;  ASN.1 allows recursive PDU definitionsandM;that result in an unbounded collection of permissible sequences.andM;The OSI Express presentation layer has severalandM;unbounded sequence types within its connect PDUS.andP;  SinceandM;values can represent constructed values of tags, lengths,andM;and other values, nesting is prevalent in ASN.1 encodings.andM;In fact, encodings of nested tags and lengths often makeandM;up a major portion of an encoded PDU.andM;7.andP;  The PDU description has six parameters, which are definedandM;as follows:andM;* Protocol-version.andP;  The presentation protocol version beingandM;used (currently only one exists).andM;* Responding-presentation-selector.andP;  This is presentation layerandM;addressing information.andM;* Presentation-context-definition-result-list.andP;  This structure containsandM;information about which abstract syntaxes are acceptedandM;at the initial connection and which transfer syntaxandM;is accepted for the transfer of PDUS encoded in theandM;selected abstract syntaxes.andM;* Default-context-result.andP;  This structure specifies whether theandM;proposed default context is accepted.andM;* Provider-reason.andP;  This structure contains fields for declaringandM;the reason for refusing the connection associated with aandM;particular PDU.andM;* User-data.andP;  This is data that an application wishes to includeandM;on this presentation service primitive.andM;This PDU is a complex type of Choice.andP;  It is a Choice ofandM;either Set or Sequence, and in this case Sequence is alwaysandM;used.andP;  The first parameter, Protocol-version, has a context-specificandM;tag of 0, as denoted by the [0].andP;  Protocol-version is furtherandM;defined as a BIT STRING, with the only acceptable valueandM;being version-1 the value of 0, as denoted by  0).andP;  The PresentationandM;-context-definition-result-list is a complex type with threeandM;primitive types: Result, Transfer-syntax-name, and Provider reason.andM;The values in parentheses to the right of the sixandM;parameters denote the values for specific semantics.andP;  ForandM;example, a value of  (1) for a Default-context-result means thatandM;the application rejected this default context.andM;Multiple levels of nesting also make decoding and verifyingandM;the length fields challenging.andP;  Length fields can be encodedandM;in one of two ways: definite and indefinite.andP;  DefiniteandM;lengths must be kept and verified during decoding andandM;indefinite lengths require the decoder to keep track ofandM;where end-of-contents (EOC) flags appear in the PDU definition.andM;Definite and indefinite lengths can appear togetherandM;in the same PDU at the discretion of the encoder.andM;The numbers are the hexadecimalandM;values derived by using the basic encoding rules.andM;Each line represents a tag and a length.andM;The values for complex types appear on theandM;lines following the complex type declaration, andandM;primitive types include the value on the same line.andP;  TagandM;values are derived from the encoding rules with each bitandM;indicating the tag type (complex of primitive type) and theandM;value begins with 30, which is the universalandM;tag type for Sequence, followed by 80, which representsandM;an indefinite length.andP;  For each indefinite length field, aandM;corresponding EOC flag consisting of two octets of zerosandM;must follow.andP;  Only complex types can be encoded usingandM;indefinite lengths.andP;  Fig.andP;  8b shows the same encoded PDUandM;using definite length encoding.andP;  Note that 80 is replacedandM;with the definite length indicator 2B.andP;  Also note that theandM;Responding-presentation-selector is encoded in two ways, bothandM;of which are valid since octet strings can be encoded asandM;constructed types at the discretion of the sender.andP;  In Fig.andM;8a a constructed type is used to break the Responding-presentationandM;-selector value into three primitive encodings, each withandM;a tag of 04 (universal tag type for octet string) and a lengthandM;of 02.andM;Another important aspect of ASN.1 is the concept of aandM;context-specific tag.andP;  Some tag values are universal in scopeandM;and apply to all ASN.1 encodings.andP;  Other tag types assumeandM;values whose meaning is specific to a particular PDU.andP;  ForandM;example, context-specific tag value [0] identifies the presentation.andM;This tag value only means Protocol-version when encounteredandM;in a presentation connect confirm negative PDU.andM;In another PDU, the value [0] means something else entirely.andM;Context tags allow a protocol designer to assign a tagandM;value such that the value of the tag determines the type ofandM;value.andP;  To decode and validate the PDU, the decoder mustandM;have knowledge of a protocol's context-specific values,andM;their meanings, and the order and range of the PDU primitiveandM;values.andP;  This means that some parts of an ASN.1 decoderandM;may be generic to any ASN.1 encoded PDU (such asandM;an ASN.1 integer decode routine), while other parts of theandM;decoder are quite specific to a single PDU (such as theandM;checking needed to verify that presentation transfer syntaxesandM;are in the appropriate sequence).andM;A final key to understanding ASN.1 encoding rules isandM;that in almost all cases, the sender chooses which optionsandM;to use.andP;  These options include the way in which lengthsandM;are encoded and when constructed elements may be segmented.andM;Octet strings, for example, may optionally be sentandM;as a contiguous string or parsed into a constructed versionandM;with many pieces, which may themselves be segmented.andM;A decoder must handle any combination of the above.andM;Thus, the decoder must be able to handle an almost infiniteandM;number of byte combinations for PDUS of any complexity.andM;This makes the decoder more complicated to constructandM;than an encoder.andM;EncoderandM;The encoder is responsible for encoding outbound dataandM;packets based on the ASN.1 syntax.andP;  Because the encoderandM;can select a limited set of options within the rather largeandM;ASN.1 set of choices, encoding is much easier than decoding.andM;The main requirement of the encoder is to know theandM;syntax of the PDU to be constructed.andP;  In particular, it needsandM;to know the order and values of the tags and be equippedandM;with the mechanisms to encode the actual lengths andandM;values.andM;The OSI Express card implementation encodes PDUSandM;front to back using indefinite length encoding.andP;  An alternative,andM;encoding ASN.1 back to front, has the advantage ofandM;being able to calculate the lengths and allow definite lengthandM;encoding.andP;  Once all of the primitive values are encoded,andM;the encoder can work backwards, filling in all of the conandM;-structed tag lengths.andP;  However, encoding back to front doesandM;not allow data streaming, since all of the PDU must beandM;present and encoded (including user data) to calculate theandM;lengths.andP;  Without data streaming, large pieces of sharedandM;memory must be used, thus making memory unavailableandM;to the rest of the card's processes until all of the PDU andandM;its user data has been encoded.andM;The encoder is table-driven in that a set of tables is usedandM;for each type of PDU.andP;  Each table contains constants for theandM;tag and length and an index to a routine for a particularandM;value.andP;  A generic algorithm uses the tables to build eachandM;PDU.andP;  The tables allow modifications to be made easilyandM;when there are changes to the OSI standards.andP;  OSI standardsandM;for tag values and primitives changed constantly duringandM;our implementation.andP;  However, these changes merely meantandM;changing a constant used by the table (often a simple macroandM;update).andP;  Changing the order or adding or deleting a valueandM;was also easy because only the table entries had to beandM;altered.andM;DecoderandM;The decoder presented a more significant challenge inandM;the ACSE/presentation protocol machine.andP;  In an effort toandM;reduce memory requirements, the decoder does not dependandM;upon having the entire PDU in memory to decode.andP;  PiecesandM;can be received separately, and these need to be decodedandM;and the memory released.andP;  The decoder also does not requireandM;contiguous memory.andP;  PDU segments can be received fromandM;the session layer according to the transport segment size.andM;In addition, the memory manager on the card presentsandM;PDUS in separate physical buffers called line data buffersandM;(see the article on page 18, which describes the CONEandM;memory manager).andM;The main job of the decoder is to find the primitiveandM;values encoded within the complex nesting of tags andandM;values, and extract those primitives.andP;  Along the way, theandM;decoder must also verify that the outer constructed tagsandM;are correct, and that the lengths associated with all theandM;constructed tags are correct.andM;The decoder uses a mathematical calculation to predictandM;and check directly the appropriate tag values.andP;  The idea isandM;to generate a unique token that directly identifies particularandM;primitive values.andP;  This unique tag is calculated by successivelyandM;using the outer nested tag values to create a uniqueandM;number that can be predicted a priori.andP;  For example, a simpleandM;method to calculate a unique value for any primitiveandM;is to take every constructed tag value and add it to the totalandM;calculated from previous constructed tags, and then multiplyandM;the new total by some base.andP;  This calculation derives aandM;unique value for every primitive in a PDU.andP;  The uniqueandM;value can be calculated statically from the standard.andP;  OurandM;implementation uses the same constants as were used inandM;the encoding tables above to construct a compiled constant.andM;The unique value can then be calculated dynamically asandM;the decoder goes through a received PDU.andP;  Thus, as theandM;decoder is parsing a PDU and successively reading constructedandM;tags, it is calculating the current-unique-tag = (old_unique_tagandM;X base) + tag_value.andM;The advantage of this method is that a generic decodeandM;routine can be used to validate ASN.1 syntax, and as soonandM;as a primitive is reached within a nested PDU, the genericandM;routine can jump directly to a specific routine to deal withandM;the primitive.andP;  The value can be checked for specifics andandM;then used or stored.andP;  The generic routine is relatively simple.andM;It merely loops looking for a tag, length, and value.andP;  IfandM;the value is not a primitive it calculates the unique tag.andM;Otherwise it uses the calculated unique tag to know whichandM;routine to call.andP;  Much of the syntax is automatically verifiedandM;during the calculation.andM;The disadvantage of using such a calculation is that whileandM;it guarantees a unique number, the number may grow quiteandM;large as the depth of nesting within a PDU grows.andP;  TheandM;problem is that the base used must be at least as large asandM;the total number of tag values.andP;  Thus, the unique tag mustandM;be able to represent a number as large as the base to theandM;nth power, where n is the depth of nesting required.andP;  PDUSandM;that allow very large nesting may not be suitable for uniqueandM;tag calculation if the largest reasonable number cannot holdandM;the maximum calculated unique tag.andP;  Calculating a uniqueandM;tag has proven to be fairly quick in comparison to using aandM;structure definition to verify each incoming PDU.andM;Once a primitive tag value is reached, the derived uniqueandM;tag is used to vector to a procedure specific to that primitive.andM;The procedure contains the code to deal with the primitive.andM;The decoder has a switch table of valid tags, as well as aandM;bit table used to determine correct orders of values andandM;mandatory or optional field checks.andP;  This mechanism allowsandM;the decoder to identify quickly the primitives nestedandM;within a complex PDU, verify correctness, and take theandM;necessary action.andM;The decoder must perform two types of length checking:andM;definite lengths in which lengths must be kept and verified,andM;and indefinite lengths in which the decoder must keepandM;track of end-of-contents flags.andP;  Definite and indefiniteandM;lengths can appear together in the same PDU at the discretionandM;of the encoder.andP;  The decoder uses two stacks in parallelandM;to check the lengths, one for definite values, and one forandM;EOCS.andP;  The definite length stack pushes a value for eachandM;constructor type encountered and subtracts a primitiveandM;length from each of the appropriate constructor values inandM;the stack.andP;  When the last, innermost primitive is subtracted,andM;the appropriate constructor values are popped from theandM;stack.andP;  Using and saving stacks allows the decoder to receiveandM;PDU segments and decode part way, stop, save the stackandM;values, and resume decoding when the next PDU segmentandM;is received.andP;  Thus, a complete PDU does not have to beandM;received before memory can be released back to the cardandM;memory pool.andP;  With this design we have not noticed anyandM;difference in the amount of time it takes to decode definiteandM;and indefinite length types.andM;Using a CompilerandM;During the design phase, the option of using an ASN.1andM;compiler was considered for the ACSE and presentationandM;protocol machines.andP;  The main advantage of a compiler isandM;that once the compiler is written, any protocol specificationandM;that uses ASN.1 can be compiled into useful object code.andM;The object code then interacts with the protocol machineandM;via a set of interface structures.andP;  The disadvantages of compilersandM;are that they are complicated to write and existingandM;compilers expect PDUS to be decoded from contiguous buffers.andM;The generic code produced is also larger than theandM;specific code necessary for relatively small protocols.andM;Given the requirement to stream PDUS in memory segments,andM;to use as little memory as possible, and to decodeandM;only ACSE and presentation PDUS, the compiler alternativeandM;was not as attractive as it might be in other applications.andM;ReferencesandM;1.andP;  Information Processing Systems - Open Systems InterconnectionandM;-Application Layer Structure, ISO/DP 9545, ISO/RRC97/SC21/andM;N1743.andP;  july 24, 1987.andP;  Revised November 1987.andM;2.andP;  Information Processing Systems - Open Systems InterconnectionandM;- Specification of Abstract Syntax Notation One (ASN.1), ISOandM;8824: 1987 (E).andM;3.andP;  Information Processing Systems - Open Systems InterconnectionandM;- Specification of Basic Encoding Rules for Abstract SyntaxandM;Notation One (ASN.1), ISO 8825: 1987 (E).andM;4.andP;  Information Processing Systems - Open Systems InterconnecandM;-tion - Service Definition for the Association Control Service Element,andM;ISO 8649: 1987 (E)  ISO/IEC JTCL/SC21 N2326).andM;5.andP;  Information Processing Systems - Open Systems InterconnectionandM;- Protocol Definition for the Association Control Service Element,andM;ISO 8650: 1987 (E) (ISO/IEC JTCL/SC21 N2327).andM;6.andP;  Information Processing Systems - Open Systems InterconnecandM;-tion - Connection Oriented Presentation Service Specification,andM;ISO 8822: 1988  ISO/IEC JTCL/SC21 N2335).andM;7.andP;  Information Processing Systems - Open Systems InterconnectionandM;- Connection Oriented Presentation Protocol Specification,andM;ISO 8822: 1988 (ISO/IEC JTCL/SC21 N2336).andM;@@@081550502 0HPJIja035IOTOandM;The HP OSI Express card's implementation of the transportandM;layer protocol provides flow control, congestion control, andandM;congestion avoidance.andM;THE TRANSPORT LAYER is responsible for providingandM;reliable end-to-end transport services, such asandM;Terror detection and recovery, multiplexing, addressing,andM;flow control, and other features.andP;  These services relieveandM;the upper-layer user (typically the session layer) of anyandM;concern about the details of achieving reliable cost-effectiveandM;data transfers.andP;  These services are provided on top ofandM;both connection-oriented and connectionless network protocols.andM;Basically, the transport layer is responsible for convertingandM;the quality of service provided by the network layerandM;into the quality of services demanded by the upper layerandM;protocol.andM;This article describes the OSI Express card's implementationandM;of OSI Class 4 Transport Protocol (TP4).andP;  The OSIandM;Express TP4 implementation extends the definition of theandM;OSI transport layer's basic flow control mechanisms to provideandM;congestion avoidance and congestion control for theandM;network and the OSI Express card itself.andP;  Because we haveandM;requirements to support a large number of connections onandM;a fairly inexpensive platform, the memory managementandM;and flow control schemes are designed to work closelyandM;together and to use the card's limited memory as efficientlyandM;as possible.andP;  This efficiency also includes ensuring fair bufferandM;utilization among connections.andM;Flow Control BasicsandM;An introduction to the basic concepts of flow control,andM;congestion control, and congestion avoidance is useful inandM;setting the stage for a discussion of the OSI Express cardandM;TP4 implementation.andP;  These concepts are related becauseandM;they all solve the problem of resource management in theandM;network.andP;  They are also distinct because they solve resourceandM;problems either in different parts of the network or in aandM;different manner.andM;Flow ControlandM;Flow control is the process of controlling the flow ofandM;data between two network entities.andP;  Flow control at theandM;transport layer is needed because of the interactions betweenandM;the transport service users, the transport protocolandM;machines, and the network service.andP;  A transport entity canandM;be modeled as a pair of queues (inbound and outbound)andM;between the transport service user and the transport protocolandM;machine, and a set of buffers dedicated to receivingandM;inbound data and/or storing outbound data for retransmission.andM;The transport entity would want to restrain the rateandM;of transport protocol data unit  (TPDU) transmissionandM;over a connection from another transport entity forandM;the following reasons:andM;* The user of the receiving transport entity cannot keepandM;up with the flow of inbound data.andP;  In other words, theandM;inbound queue between the transport service user andandM;the transport protocol machine has grown too deep.andM;*  The receiving transport entity does not have enough buffersandM;to keep up with the flow of inbound data from theandM;network.andM;Note that analogous situations exist in the outbound direction,andM;but they are usually handled internally betweenandM;the transport user and the transport entity.andP;  If the sendingandM;transport entity does not have enough buffers to keep upandM;with the flow of data from the transport user, or the sendingandM;transport entity is flow controlled by the receiving transportandM;entity, then the transport user must be flow controlled byandM;some backpressure mechanism caused by the outboundandM;queue's growing too deep.andM;Thus flow control is a two-party agreement between theandM;transport entities of a connection to limit the flow of packetsandM;without taking into account the load on the network.andP;  ItsandM;purpose is to ensure that a packet arriving at its destinationandM;is given the resources it needs to be processed up to theandM;transport user.andM;Congestion ControlandM;While flow control is used to prevent end system resourcesandM;from being overrun, congestion control is used toandM;keep resources along a network path from becoming congested.andM;Congestion is said to occur in the network whenandM;the resource demands exceed the capacity and packets areandM;lost because of too much queuing in the network.andM;Congestion control is usually categorized as a networkandM;layer function.andP;  In an X.25 type network where the networkandM;layer is connection-oriented, the congestion problem isandM;handled by reserving resources at each of the routers alongandM;a path during connection setup.andP;  The X.25 flow controlandM;mechanism can be used between the X.25 routers to ensureandM;that these resources do not become congested.andP;  With a connection-lessandM;network layer like ISO 8473, the routers canandM;detect that they are becoming congested, but there are noandM;explicit flow control mechanisms (like choke packets') thatandM;can be used by the OSI network layer alone for controllingandM;congestion.andM;The most promising approach to congestion control inandM;connectionless networks is the use of implicit techniquesandM;whereby the transport entities are notified that the networkandM;is becoming congested.andP;  The binary feedback scheme         is anandM;example of such a notification technique.andP;  The transportandM;entities can relieve the congestion by exercising varyingandM;degrees of flow control.andM;Thus congestion control is a social agreement amongandM;network entities.andP;  Different connections may choose differandM;-ent flow control practices, but all entities on a networkandM;must follow the same congestion control strategy.andP;  The purposeandM;of congestion control is to control network traffic toandM;reduce resource overload.andM;Congestion AvoidanceandM;Congestion control helps to improve performance afterandM;congestion has occurred.andP;  Congestion avoidance tries toandM;keep congestion from occurring.andP;  Thus congestion controlandM;procedures are curative while congestion avoidance proceduresandM;are preventive.andP;  Given that a graph of throughputandM;versus network load typically looks like Fig.andP;  2, a congestionandM;avoidance scheme should cause the network to oscillateandM;slightly around the knee, while a congestion controlandM;scheme tries to minimize the chances of going over theandM;cliff.andP;  The knee is the optimal operating point because increasesandM;in load do not offer a proportional increase inandM;throughput, and it provides a certain amount of reserve forandM;the natural burstiness associated with network traffic.andM;Flow Control Mechanisms in TP4andM;The OSI Class 4 Transport, or TP4, protocol is describedandM;in ISO document number 8073.andP;  It provides a reliable end-to-endandM;data transfer service by using error detection andandM;recovery mechanisms.andP;  Flow control is an inherent part ofandM;this reliable service.andP;  This section will describe the protocolandM;mechanisms that are used to provide flow control in OSIandM;TP4.andP;  These mechanisms make use of the TP4 data streamandM;structure, TPDU numbering, and TPDU acknowledgments.andM;TP4 Data Stream StructureandM;The main service provided by the transport layer is, ofandM;course, data transfer.andP;  Two types of transfer service are availableandM;from TP4: a normal data service and an expedited dataandM;service.andP;  Expedited data at the transport layer bypasses normalandM;data end-to-end flow control, so we need not concernandM;ourselves with expedited data when discussing TP4 flowandM;control.andM;The OSI transport service (TS) interface is modeled as aandM;set of primitives through which information is passed betweenandM;the TS provider and the TS user.andP;  Normal TS userandM;data is given to the transport layer by the sending TS userandM;in a transport data request primitive.andP;  TS user data is deliveredandM;to the receiving TS user in a transport data indicationandM;primitive.andM;The data carried in each transport data request and transportandM;data indication primitive is called a transport serviceandM;data unit (TSDU).andP;  There is no limit on the length of a TSDU.andM;To deliver a TSDU, the transport protocol may segmentandM;the TSDU into multiple data transport protocol data unitsandM;(DT TPDUs).andP;  The maximum data TPDU size is negotiatedandM;for each connection at connection establishment.andP;  NegotiationandM;of a particular size depends on the internal bufferandM;management scheme and the maximum packet size supportedandM;by the underlying network service.andP;  The maximumandM;TPDU sizes allowed in TP4 are 128, 256, 512, 1024, 2048,andM;4096, and 8192 octets.*andM;TPDU NumberingandM;The error detection, recovery, and flow control functionsandM;all rely on TPDU numbering.andP;  Unlike ARPA TCP, whereandM;sequencing is based on numbering each byte in the dataandM;stream since connection establishment, TP4 sequencing isandM;based on numbering each TPDU in the data stream sinceandM;connection establishment.andP;  A transport entity allocates theandM;sequence number zero to the first DT TPDU that it transmitsandM;for a transport connection.andP;  For subsequent DT TPDUs sentandM;on the same transport connection, the transport entity allocatesandM;a sequence number one greater than the previous one,andM;modulo the sequence space size.andM;The sequence number is carried in the header of eachandM;DT TPDU and its corresponding AK (acknowledgment)andM;TPDU.andP;  The sequence number field can be either 7 or 31andM;bits long.andP;  The size of the sequence space is negotiated atandM;connection establishment.andP;  Since a transport entity mustandM;wait until the network's maximum packet lifetime has expiredandM;before reusing a sequence number, the 31-bit sequenceandM;space is preferred for performance reasons.andM;TP4 AcknowledgmentsandM;An AK (acknowledgment) TPDU is used in OSI TP4 forandM;the following reasons:andM;* It is the third part of the three-way handshake that isandM;used for connection establishment.andP;  It acknowledgesandM;the receipt of the CC (connect confirm)andM;TPDU.andM;* It is used to provide the connection assurance or keepandM;-alive function.andP;  To detect an unsignaled loss of the networkandM;connection or failure of the remote transport entity,andM;an inactivity timer is used.andP;  A connection's inactivityandM;An octet is eight bits.andM;timer is reset each time a valid TPDU is received on thatandM;connection.andP;  If a connection's inactivity timer expires,andM;the connection is presumed lost and the local transportandM;entity invokes its release procedures for the connection.andM;The keep-alive function maintains an idle connectionandM;by periodically transmitting an AK TPDU upon expirationandM;of the window timer.andP;  Thus the interval of one transportandM;entity's window timer must be less than that of itsandM;peer's inactivity timer.andP;  Since there is no mechanism forandM;sharing information about timer values, a transport entityandM;must respond to the receipt of a duplicate AK TPDUandM;not containing the FCC (flow control confirmation) parameterandM;by transmitting an AK TPDU containing theandM;FCC parameter.andP;  Thus, a transport entity can provokeandM;another transport entity into sending an AK TPDU toandM;keep the connection alive by transmitting a duplicateandM;AK TPDU.andM;It is used to acknowledge the in-sequence receipt of oneandM;or more DT TPDUs.andP;  Since OSI TP4 retains DT TPDUsandM;until acknowledgment (for possible retransmission), receiptandM;of an AK TPDU allows the sender to release theandM;acknowledged TPDUs and free transmit buffers.andP;  To acknowledgeandM;the receipt of multiple DT TPDUs, an implementationandM;of OSI TP4 may withhold sending an AKandM;TPDU for some time (maximum acknowledgmentandM;holdback time) after receipt of a DT TPDU.andP;  This holdbackandM;time must be conveyed to the remote transport entity atandM;connection establishment time.andM;* It is used to convey TP4 flow control information, asandM;described in the next section.andM;TP4 Flow ControlandM;OSI TP4 flow control, like many other schemes, is managedandM;by the receiver.andP;  TP4 uses a credit scheme.andP;  The receiverandM;sends an indication through the AK TPDU of how manyandM;DT TPDUs it is prepared to receive.andP;  More specifically, anandM;AK TPDU carries the sequence number of the next expectedandM;DT TPDU (this is called the LWE or lower window edge)andM;and the credit window (CDT), which is the number of DTandM;TPDUs that the peer transport entity may send on thisandM;connection.andP;  The sequence number of the first DT TPDUandM;that cannot be sent, called the upper window edge  UWE),andM;is then the lower window edge plus the credit windowandM;modulo the sequence space size.andP;  As an example,andM;say that the receiving transport entity has received DTandM;TPDUs up through sequence number 5.andP;  Then the LWE orandM;next expected DT TPDU number is 6.andP;  If the receiver transmitsandM;an AK TPDU with a CDT of 10 and an LWE of 6, thenandM;the transmitter (receiver of the AK TPDU) has permissionandM;to transmit 10 DT TPDUs numbered 6 through 15.andP;  TheandM;transmitter is free to retransmit any DT TPDU that has notandM;been acknowledged and for which it has credit.andP;  A DT TPDUandM;is acknowledged when an AK TPDU is received whoseandM;LWE is greater than the sequence number of the DT TPDU.andM;Credit ReductionandM;OSI TP4 allows the receiver to reduce the credit windowandM;as well as take back credit for DT TPDUs that it has notandM;yet acknowledged.andP;  The LWE cannot be reduced, however,andM;since it represents the next expected DT TPDU sequenceandM;number and acknowledges receipt of all DT TPDUs of lowerandM;number.andP;  Another way of saying this is that the UWE needandM;not move forward with each successive AK TPDU, and inandM;fact it may move backwards as long as it isn't less than theandM;LWE.andP;  As will be discussed later, the OSI Express card'sandM;TP4 takes advantage of this feature to provide memoryandM;congestion control by closing the credit window (AK TPDUandM;with CDT of zero) under certain circumstances.andM;The OSI Express card's implementation of TP4 (here-afterandM;called the Express TP4) flow control and network congestionandM;control and avoidance policies use many of the basicandM;protocol mechanisms described above.andM;Flow ControlandM;In Express TP4 the maximum receive credit window sizeandM;(W) is a user-settable parameter.andP;  A similar parameter (Q)andM;is used to provide an upper limit on the number of DTandM;TPDUs a given connection is allowed to retain awaitingandM;acknowledgment.andP;  The Express TP4 dynamically changesandM;the window size and queuing limit based on the state ofandM;congestion, so W and Q are treated as upper limits.andP;  AnandM;application can set values for W and Q for a particularandM;connection during connection establishment.andP;  A set of valuesandM;may also be associated with a particular TSAP (transportandM;service access point) selector, so that applications canandM;select from different transport service profiles.andP;  In lieu of aandM;connection using one of the two methods just described,andM;configured default values are used.andM;There is no real notion of flow control in the outboundandM;direction, although TPDU transmissions are paced duringandM;times of congestion.andP;  The Express TP4 continues to sendandM;TPDUs until it has used all the credit that it was allocatedandM;by the peer entity, or it has Q TPDUs in its retransmissionandM;queue awaiting acknowledgment, whichever comes first.andM;Ignoring any congestion control mechanisms for the moment,andM;inbound flow control is also fairly simple.andP;  When theandM;Express TP4 sends an AK TPDU, its goal is to grant a fullandM;window's worth of credit.andP;  The CDT field of the AK TPDUandM;is set to W, and the LWE field is set to the sequence numberandM;of the last in-sequence DT TPDU received plus one (i.e.,andM;the next expected DT TPDU).andP;  The key to the efficient operandM;-ation of the flow control policy is the timing of the AKandM;TPDU transmissions.andM;A simple flow control policy  could be to sendandM;an AK TPDU granting a full credit window when the lastandM;in-sequence DT TPDU of the current credit window hasandM;been received.andP;  This policy would degrade the potentialandM;throughput of the connection, however, because it neglectsandM;the propagation delays and processing times of the DTandM;TPDUs and AK TPDUs.andP;  After transmitting the last DT TPDUandM;of the current credit window, the sender is idle until theandM;AK TPDU is received and processed.andP;  After sending the AKandM;TPDU, the receiver is idle until the first DT TPDU of theandM;new credit window has propagated across the network.andM;These delays could be lengthy depending on the speed ofandM;the underlying transmission equipment and on the relativeandM;speeds of the sending and receiving end systems.andM;A more efficient flow control policy, like that implementedandM;in the Express TP4, sends credit updates suchandM;that the slowest part of the transmission pipeline (sendingandM;entity, receiving entity, or network subsystem) is not idleandM;as long as there is data to be transmitted.andP;  This is done byandM;sending an AK TPDU granting a full window's worth ofandM;credit before all of the DT TPDUs of the current creditandM;window have been received.andP;  The point in the current creditandM;window at which the credit-giving AK TPDU is sent isandM;called the credit acknowledgment point (CAP).andP;  Thus theandM;CAP is the sequence number of a DT TPDU in the currentandM;credit window whose in-sequence receipt will generate theandM;transmission of an AK TPDU.andP;  The AK TPDU's LWE willandM;be the sequence number of the DT TPDU causing the generationandM;of the AK TPDU and the CDT field of the AK TPDUandM;will contain the value of W. The CAP is calculated eachandM;time an AK TPDU is sent, and is just the sum of the creditandM;acknowledgment interval (CAI) and the current LWE.andP;  CAIandM;represents the number of data packets received before anandM;AK TPDU is sent.andM;ExampleandM;Consider a hypothetical connection where two end systemsandM;are connected through an intermediate system viaandM;two 9600-baud full-duplex serial links.andP;  shows theandM;progression of DT TPDUs and the flow control pacing AKandM;TPDUs across the links of this connection.andP;  At time To, endandM;system 1 has received the DT TPDU whose sequenceandM;number is the CAP.andP;  End system 1 then places an AK TPDUandM;in the transmission queue of link A', thereby granting aandM;new credit window.andP;  Meanwhile links A and B are busyandM;processing DT TPDUs numbered CAP + 1 and CAP + 2 respectively.andM;At time T1, the AK TPDU has made it to theandM;link B' transmission queue and the DT TPDUs have advancedandM;one hop, allowing DT TPDU number CAP + 3 to beandM;inserted in the link B transmission queue.andP;  Finally, at timeandM;T2, the AK TPDU has made it to end system 2, and againandM;the DT TPDUs have advanced one hop, allowing DT TPDUandM;number CAP+4 to be inserted in the link B transmissionandM;queue.andP;  Note that for simplicity, it is assumed that the propagationandM;delay of a DT TPDU across a link is equal to thatandM;of an AK TPDU.andP;  In reality, DT TPDUs are larger than AKandM;TPDUs and would take longer to propagate.andM;For this example, the minimal CAI needed to keep theandM;links busy is four, and the minimal window size W is eight.andM;Thus the AK TPDU would carry a CDT of eight, so thatandM;end system 2 has credit to send DT TPDUs numberedandM;CAP+5 through CAP+8 at the time it receives the AKandM;TPDU (time T2).andP;  DT TPDU number CAP + 4 would triggerandM;end system 1 to send another credit-granting AK.andP;  The CAIandM;should not be greater than W - 4 for this example, or endandM;system 1 will notice an abnormal delay in the packet trainandM;because end system 2 does not have enough credit to keepandM;the links busy while the AK TPDU is in transit.andP;  Any CAIandM;less than W-4 would avoid the delay problem, but theandM;increase in AK TPDU traffic tends to decrease the amountandM;of CPU and link bandwidth that can be used for data transandM;-mission.andP;  The optimal CAI for this example would be W - 4andM;since that avoids the credit delay and minimizes theandM;number of AK TPDUs.andP;  The graph in Fig.andP;  9 on page 56andM;shows the effect on throughput of different values for WandM;and different Cals (packets per AK TPDU) for each of theandM;window sizes.andP;  This graph was created from a simulationandM;of the Express TP4 implementation running a connectionandM;between two end systems connected to a single LAN segment.andM;This simulation data and analysis of real ExpressandM;TP4 data have shown that a maximum CAI of W/2 yieldsandM;the best performance with the least amount of algorithmicandM;complexity.andM;Optimal Credit WindowandM;In the Express TP4, the CAI initially starts at half theandM;credit window size (W/2), but can be reduced and subsequentlyandM;increased dynamically to reach and maintain theandM;optimal interval during the life of the connection.andP;  The optimalandM;value, as shown in the above example, is large enoughandM;to ensure that the sender receives the AK TPDU grantingandM;a new credit window before it finishes transmitting at leastandM;the last DT TPDU of the current window, but not largerandM;than the number of DT TPDUs the sender is willing toandM;queue on its retransmit queue awaiting acknowledgmentandM;(note that this scheme relies on the setting of sufficientlyandM;large values for Q and W such that the optimal CAI can beandM;reached).andP;  If the sending transport entity does not allow W/2andM;DT TPDUs to be queued awaiting acknowledgment, thenandM;as a receiver, the Express TP4 will decrease the CAI toandM;avoid waiting for the CAP DT TPDU that would neverandM;come.andP;  This situation is detected with the maximumandM;acknowledgment holdback timer.andP;  Since any AK TPDU thatandM;is sent cancels the acknowledgment holdback timer, expirationandM;of the holdback timer indicates that the sender mayandM;not have sent the CAP DT TPDU.andP;  When the timer expires,andM;the CAI is decreased to half the number of DT TPDUsandM;received since the last credit update.andP;  This is done to preserveandM;the pipelining scheme, since it has been shown thatandM;it is better to send AK TPDUs slightly more often than toandM;allow the pipeline to dry up.andP;  The amount of credit offeredandM;to the receiver is not shrunk (unless congestion is detected),andM;so if the sender devotes more resources to the connection,andM;it can take advantage of the larger window size.andP;  The CAPandM;will increase linearly as long as the sender is able to sendandM;up to the CAP DT TPDU before the acknowledgmentandM;holdback timer expires.andP;  The linear increase allows the ExpressandM;TP4 to probe the sender's transmit capability, andandM;has proved fairly effective.andM;A more effective mechanism for matching the receiver'sandM;AK TPDU rate to the sender's needs has reached draft proposalandM;status as an enhancement to OSI TP4.andP;  That mechanismandM;allows the sending transport entity to request anandM;acknowledgment from the receiving transport entity.andM;Congestion Control and AvoidanceandM;Several network congestion control and avoidance algorithmsandM;are used in the Express TP4.andP;  All of these algorithmsandM;have been described and rationalized in referenceandM;3.andP;  This section provides a basic description of each algorithmandM;and how they were effectively incorporated in theandM;Express TP4 implementation.andP;  There is also a descriptionandM;of how these algorithms are used together with the dynamicandM;credit window and retransmit queue sizing algorithms toandM;provide congestion control of card resources and networkandM;resources.andM;Slow Start/cute Congestion AvoidanceandM;Two very similar congestion avoidance schemes haveandM;been described by Jacobsen and Jain.andP;  The fundamentalandM;observation of these two algorithms is that the flow on aandM;transport connection should obey a &quot;conservation of packets&quot;andM;principle.andP;  If a network is running in equilibrium, thenandM;a new packet isn't put onto the network until an old oneandM;leaves.andP;  Congestion and ultimately packet loss occur as soonandM;as this principle is violated.andP;  In practice, whenever a newandM;connection is started or an existing connection is restartedandM;after an idle period, new packets are injected into the networkandM;before an old packet has exited.andP;  To minimize theandM;destabilizing effects of these new packet injections, theandM;CUTE' and slow start schemes require the sender to startandM;from one packet and linearly increase the number of packetsandM;sent per round-trip time.andP;  The basic algorithm is as folandM;-lows:andM;When starting or restarting after a packet loss or an idleandM;period, set a variable congestion window to one.andM;When sending DT TPDUs, send the minimum of theandM;congestion window or the receiver's advertised creditandM;window size.andM;On receipt of an AK TPDU acknowledging outstandingandM;DT TPDUs, increase the congestion window by one upandM;to some maximum (the minimum of Q or the receiver'sandM;advertised credit window size).andM;Note that this algorithm also is employed when the retransmitandM;or retransmission timer expires.andP;  The CUTEandM;scheme proposes that a retransmission time-out be used asandM;an indication of packet loss because of congestion.andP;  Jacobsen alsoandM;argues, with some confidence, that if a goodandM;round-trip-time estimator is used in setting the retransmitandM;timer, a time-out indicates a lost packet and not a brokenandM;timer (assuming that a delayed packet is equated with aandM;lost packet).andP;  For a LAN environment, packets are droppedandM;because of congestion.andM;The Express TP4 uses the slow start algorithm (if configuredandM;to do so) when a connection is first established, uponandM;expiration of the retransmission timer, and after an idleandM;period on an existing connection.andP;  An idle period is detectedandM;when certain number of keep-alive AK TPDU's have beenandM;sent or received.andP;  The slow start and CUTE schemes limitandM;their description to sender functions.andP;  The Express TP4 providesandM;the slow start function on the receive side as well,andM;to protect both the network and the OSI Express card fromandM;a sender that does not use the slow start scheme.andP;  The receiverandM;slow start algorithm is nearly identical to the sender'sandM;and works as follows:andM;When starting or restarting after an idle period, set aandM;variable congestion window to one.andM;When sending an AK TPDU, offer a credit window sizeandM;equal to the congestion window to the sender.andM;On receipt of the CAP DT TPDU, increase the congestionandM;window by one up to some maximum W as described above.andM;Round-trip-time Variance EstimationandM;Since the retransmit timer is used to provide congestionandM;notification, it must be sensitive to abnormal packet delayandM;as well as packet loss.andP;  To do this, it must maintain anandM;accurate measurement of the round-trip time (RTT).andP;  TheandM;round-trip time is defined as the time it takes for a packetandM;to propagate across the network and its acknowledgmentandM;to propagate back.andP;  Most transport implementations use anandM;averaging algorithm to keep an ongoing estimation of theandM;round-trip time using measurements taken for each receivedandM;acknowledgment.andM;The Express TP4 uses RTT mean and variance estimationandM;algorithms&quot; to derive its retransmission timer value.andP;  TheandM;basic estimator equations in a C-language-like notation are:andM;Err = M-AandM;A   = A + (Errandgt;andgt;Gain)andM;D   = D + (|Erri| - D)andgt;andgt;Gain)andM;where:andM;M  =  current RTT measurementandM;A  =  average estimation for RTT, or aandM;prediction of the next measurementandM;Err =  error in the previous predictionandM;of M which may be treated as a varianceandM;Gain =  a weighting factorandM;D  =  estimated mean deviationandM;andgt;andgt;   =  C notation for the logical shift rightandM;operation (a division of the left operandandM;by 2 to the power of the right operand).andM;The retransmission timer is then calculated as:andM;retrans_time = A + 2D.andM;The addition of the deviation estimator has provided aandM;more reactive retransmission timer while still damping theandM;somewhat spurious fluctuations in the round-trip time.andM;Exponential Retransmit TimerandM;If it can be believed that a retransmit timer expiration isandM;a signal of network congestion, then it should be obviousandM;that the retransmission time should be increased when theandM;timer expires to avoid further unnecessary retransmissions.andM;If the network is congested, then the timer most likelyandM;expired because the round-trip time has increased appreciablyandM;(a packet loss could be viewed as an infinite increase).andM;The question is how the retransmissions shouldandM;be spaced.andP;  An exponential timer back-off seems to be goodandM;enough to provide stability in the face of congestion, althoughandM;in theory even an exponential back-off won'tandM;guarantee stability.'andM;The Express TP4 uses an exponential back-off withandM;clamping.andP;  Clamping means that the backed-off retransmitandM;time is used as the new round-trip time estimate, and thusandM;directly effects the retransmit time for subsequent DTandM;TPDUs.andP;  The exponential back-off equation is as follows:andM;retrans_time = retrans time x 2[sup.n]andM;where n is the number of times the packet has been transmitted.andM;For a given DT TPDU, the first time the retransmissionandM;timer expires the retransmission time is doubled.andP;  The secondandM;time it expires, the doubled retransmission time isandM;quadrupled, and so on.andM;Dynamic Window and Retransmit Queue SizingandM;The slow start described earlier provides congestionandM;avoidance when used at connection start-up and restartandM;after idle.andP;  It provides congestion control when triggered byandM;a retransmission.andP;  The problem with it is that a slow startandM;only reduces a connection's resource demands for a shortandM;while.andP;  It takes time RTT1092W, where RTT is the round-tripandM;time and W is the credit window size, for the windowandM;increase to reach W. When a window size reaches W again,andM;congestion will most likely recur if it doesn't still exist.andM;Something needs to be done to control a connection's contributionandM;to the load on the network for the long run.andM;The transport credit window size is the most appropriateandM;control point, since the size of the offered credit windowandM;directly effects the load on the network.andP;  Increasing theandM;window size increases the load on the network, and decreasingandM;the window size decreases the load.andP;  A simple ruleandM;is that to avoid congestion, the sum of all the window sizesandM;(W[sub.i]) of the connections in the network must be less thanandM;the network capacity.andP;  If the network becomes congested,andM;then having each connection reduce its W (while also employingandM;the slow start algorithm to alleviate the congestion)andM;should bring the network back into equilibrium.andP;  Since thereandM;is no notification by the network when a connection isandM;using less than its fair share of the network resources, aandM;connection should increase its W in the absence of congestionandM;notification to find its limit.andP;  For example, a connectionandM;could have been sharing a path with someone else andandM;converged to a window that gave each connection half theandM;available bandwidth.andP;  If the other connection shuts down,andM;the released bandwidth will be wasted unless the remainingandM;connection increases its window size.andM;It is argued that a multiplicative decrease of the windowandM;size is best when the feedback selector signals congestion,andM;while an additive increase of the window size is best inandM;the absence of congestion.3,6   Network load grows nonlinearlyandM;at the onset of congestion, so a multiplicative decreaseandM;is about the least that can be done to help the networkandM;reach equilibrium again.andP;  A multiplicative decrease alsoandM;affects connections with large window sizes more thanandM;those with small window sizes, so it penalizes connectionsandM;fairly.andP;  An additive increase slowly probes the capacity ofandM;the network and lessens the chance of overestimating theandM;available bandwidth.andP;  Overestimation could result in frequentandM;congestion oscillations.andM;Like the slow start algorithm, the Express TP4 uses multiplicativeandM;decrease and additive increase by adjusting WandM;on a connection's receive side and by adjusting Q on aandM;connection's send side.andP;  This allows us to control the injectionandM;of packets into the network and control the memoryandM;utilization of each connection on the OSI Express card.andM;The amount of credit given controls the amount of bufferandM;space needed in the network and on the card.andP;  The size ofandM;Q also controls the amount of buffer space needed on theandM;card, because TSDUs are not sent to the card from the hostandM;computer unless the connection has credit to send themandM;or there are less than Q TPDUs already queued awaitingandM;acknowledgment.andP;  The Express TP4 uses the following equationsandM;to implement multiplicative decrease and additiveandM;increase.andM;Upon notification of congestion (multiplicative decrease):andM;W' = W'/2                        (1)andM;Q' = Q'/2.andP;                       (2)andM;Upon absence of congestion (additive increase):andM;W' = W' + W'/4                       (3)andM;Q' = Q' + Q'/4.andP;                      (4)andM;W' and Q' are the actual values used by the connectionandM;and W and Q are upper limits for W' and Q' respectively.andM;The window and queue size adjustments are used withandM;the retransmit timer congestion notification in the followingandM;manner:andM;*  Expiration of the retransmit timer signals network congestionandM;and Q' is decreased.andM;*  The slow start algorithm is used to clock data packetsandM;out until the congestion window equals Q'.andM;*  As long as no other notifications of congestion occur, Q'andM;is increased each time an AK TPDU is received, up to aandM;maximum of Q.andM;OSI Express Congestion ControlandM;One of the main design goals of the OSI Express cardandM;was to support a large number of connections.andP;  To achieveandM;this goal, the memory management scheme had to be asandM;efficient as possible since memory (for data structures andandM;data buffers) is the limiting factor in supporting many connections.andM;OSI Express memory management is providedandM;by the CONE memory buffer manager.andM;Initially, the memory buffer manager was designed suchandM;that each connection's packet buffers were preallocated.andP;  AandM;connection was guaranteed that the buffers it needed wouldandM;be available on demand.andP;  This scheme provided good performanceandM;for each connection when there were many activeandM;connections, but it would not support enough active connections.andM;The connections goal had to be met, so the memoryandM;buffer manager was redesigned such that all connectionsandM;share the buffer pool.andP;  Theoretically, there can be moreandM;connections active than there are data buffers, so thisandM;scheme maximizes the number of supportable connectionsandM;at the cost of individual connection performance as theandM;ratio of data buffers to the number of connections approachesandM;one.andM;The Problem and The SolutionandM;With a shared buffer scheme comes the possibility ofandM;congestion.andP;  (Actually, even without a shared bufferandM;scheme, other resources such as CPU and queuing capacityandM;are typically shared, so congestion is not a problem specificandM;to statistical buffering.) Since no resources are reserved forandM;each connection, congestion on the card arises from theandM;same situations as congestion in the network.andP;  A new connectionandM;coming alive or an existing connection restartingandM;after an idle period injects new packets into the systemandM;without waiting for old packets to leave the system.andP;  Also,andM;since there can be many connections, it is likely that theandM;sum of the connections' window sizes and other resourceandM;demands could become greater than what the card canandM;actually supply.andM;A shared resource scheme also brings the problem ofandM;ensuring that each connection can get its fair share of theandM;resources.andP;  Connections will operate with different windowandM;sizes, packet sizes, and consumption and production rates.andM;This leads to many different patterns and quantities ofandM;resource use.andP;  As many connections start competing forandM;scarce resources, the congestion control scheme must beandM;able to determine which connections are and which connectionsandM;are not contributing to the shortage.andM;The problem of congestion and fairness was addressedandM;by modeling the card as a simple feedback control system.andM;The system model used consists of processes (connections)andM;that take input in the form of user data, buffers, CPU resources,andM;and control signals, and produce output in theandM;form of protocol data units.andP;  To guarantee the success ofandM;the system as a whole, each process must be successful.andM;Each process reports its success by providing feedback signalsandM;to a central control decision process.andP;  The control decisionandM;process is responsible for processing these feedbackandM;signals, determining how well the system is performingandM;and providing control information to the connection processesandM;so that they will adjust their use of buffers and CPUandM;resources such that system performance can be maximized.andM;Control SystemandM;Certain measures are needed to determine the load onandM;the card so that congestion can be detected, controlled, andandM;hopefully avoided.andP;  When the card is lightly loaded, fairnessandM;is not an issue.andP;  As resources become scarce, however, someandM;way is needed to measure each connection's resource useandM;so that fairness can be determined and control applied toandM;reduce congestion.andM;Two types of accounting structures are used on the OSIandM;Express card to facilitate measurement: accounts and creditandM;cards.andP;  Since outbound packets are already associated withandM;a connection as they are sent from the host to the card,andM;each connection uses its own account structure to maintainandM;its outbound resource use information.andP;  All protocol layersandM;involved in a particular connection charge their outboundandM;operations directly to the connection's outbound account.andM;For inbound traffic, when a packet is received from theandM;LAN, the first three protocol layers do not know whichandM;upper-layer connection the packet is for.andP;  Therefore, a singleandM;inbound account is used for all inbound resource use informationandM;for the first three protocol layers, and some combinedandM;resource use information for upper-layer connections.andM;This provides some level of accountability for inboundandM;resource use at the lower layers such that comparisonsandM;can be made to overall outbound resource use.andP;  SinceandM;a single inbound account exists for all connections, creditandM;cards are used by the upper four layers (transport and up)andM;to charge their inbound operations to specific connections.andM;Thus each connection has an outbound account and a creditandM;card for the inbound account.andM;The protocol modules and CONE utilities are responsibleandM;for updating the statistics (i.e., charging the operations)andM;that are used to measure resource use.andP;  These statistics includeandM;various system and connection queue depths, CPUandM;use, throughput, and time-averaged memory utilization.andM;When summed over all of the connections, these statisticsandM;are used along with other signals to determine the degreeandM;of resource shortage or congestion on the card.andP;  The individualandM;connection values indicate which connections areandM;contributing the most to the congestion (and should beandM;punished) and which connections are not using their fairandM;share of resources (and should be allowed to do so).andM;Flow Control DaemonandM;The control decision and feedback filtering function isandM;implemented in a CONE daemon process aptly named theandM;flow control daemon.andP;  Using a daemon allows the overheadandM;for flow control to be averaged over a number of packets.andM;The daemon periodically looks at the global resource statisticsandM;and then sets a target for each of the resources for eachandM;connection.andP;  The target level is not just the total number of,andM;say, buffers divided by the number of connections.andP;  TargetsandM;are based on the average use adjusted up or down basedandM;on the scarcity of various resources.andP;  This allows more flexibilityandM;of system configurations since one installation orandM;mix of connections may perform better with differentandM;maximum queue depths than another.andP;  It is also the simplestandM;way to set targets for things like throughput since totalandM;throughput is not a constant or a linear function of theandM;number of connections.andM;Control signals are generated by the flow control daemonandM;as simple indications of whether a connection should increase,andM;decrease, or leave as is its level of resource use.andM;The daemon determines the direction by comparing theandM;connection's level of use with the current target levels.andM;There is a separate direction indication for inbound andandM;outbound resource use.andM;The fairness function falls out very simply from thisandM;decision and control scheme.andP;  Any connection that is usingandM;more than its fair share of a resource will have a level ofandM;use greater than the average and thus greater than the targetandM;when that resource is scarce.andP;  In other words, the &quot;fairandM;share&quot; is the target.andM;The control signals are generated when a connectionandM;queries the daemon.andP;  The most likely point for querying theandM;daemon is when a connection is about to make a flowandM;control decision.andP;  That decision point is, of course, in theandM;TP4 layer of the OSI Express card.andM;Effects of the DaemonandM;The effects of flow control notifications to a connectionandM;regarding decreasing or increasing resource use vary accordingandM;to whether the direction of traffic is inbound orandM;outbound.andM;Outbound.andP;  The Express TP4 queries the flow controlandM;daemon for outbound congestion/fairness notificationandM;when it receives an AK TPDU.andP;  It is at this point that DTandM;TPDUs are released from the retransmission queue, and itandM;can be decided if more or fewer DT TPDUs can be queuedandM;until the next AK TPDU is received.andM;If the connection is using more than its fair share ofandM;outbound resources  because of congestion or just overandM;-zealousness), the daemon will return a decrease notification.andM;A decrease notification causes the Express TP4 toandM;reduce the connection's retransmit queue size  Q') usingandM;equation 2.andP;  The slow start algorithm is then used to clockandM;DT TPDUs out until the congestion window equals Q'.andM;If Q' is equal to one when a decrease is signaled, theandM;Express TP4 goes into DT TPDU send delay mode.andP;  In thisandM;mode, transmission of successive DT TPDUs is spaced byandM;a minimum delay (D) to produce an interpacket gap thatandM;will slow down the connection's demand for resources.andP;  IfandM;further decrease signals are received in delay mode, theandM;minimum delay is increased using D = D x 2.andM;If the connection is using less than its fair share of outboundandM;resources, the daemon will return an increase notification.andM;An increase notification causes the Express TP4 toandM;increase the connection's retransmit queue size  Q') up toandM;a maximum of Q, using the additive increase equation.andP;  IfandM;an increase signal is received in delay mode, the minimumandM;delay is decreased using D = D - D/4.andM;Inbound.andP;  The Express TP4 queries the flow control daemonandM;for inbound congestion/fairness notification when it sendsandM;an AK TPDU.andP;  At this point the decision needs to be madeandM;whether more or fewer DT TPDUs should be allowed inandM;the pipeline until the next AK TPDU is sent.andP;  If the connectionandM;is using more than its fair share of inbound resources,andM;the daemon will return a decrease notification.andP;  A decreaseandM;notification causes the Express TP4 to reduce the connection'sandM;receive window size  W') using equation 1.andP;  The slowandM;start algorithm is then used to clock AK TPDUs out withandM;credit window (CDT) values increasing from one to W'.andM;If W' is equal to one when a decrease is signaled, theandM;Express TP4 goes into credit delay mode.andP;  In this mode,andM;transmission of AK TPDUs containing a CDT of one areandM;spaced by a minimum delay to produce an interpacket gapandM;between incoming DT TPDUs that will slow down the connection'sandM;demand for resources.andP;  If further decrease signalsandM;are received in delay mode, the minimum delay is increasedandM;using D = D x 2.andM;If the connection is using less than its fair share of inboundandM;resources, the daemon will return an increase notification.andM;An increase notification causes the Express TP4 toandM;increase the connection's credit window size  W') up to aandM;maximum of W, using equation 3.andP;  If an increase signal isandM;received in delay mode, the minimum delay is decreasedandM;using D = D - D/4.andM;Severe Congestion NotificationandM;The flow control daemon also provides an emergencyandM;notification to Express TP4 in cases where transient shortagesandM;of memory are severe enough to jeopardize the existenceandM;of connections.andP;  Because the OSI Express card usesandM;statistical buffering, there is a possibility that a large burstandM;of outbound data could queue up in the Express TP4 retransmissionandM;queues, while inbound data is flowing in andandM;getting queued because the host computer is not readingandM;data from the card.andP;  If the situation is such that buffers mayandM;not be available to receive or send AK TPDUs, the daemonandM;will give an emergency notification to the Express TP4.andM;Upon receipt of this notification, the Express TP4 sendsandM;an AK TPDU with a CDT of zero, closing the credit window.andM;Thus DT TPDUs received that are outside the new creditandM;window are thrown away so as to avoid memory deadlock.andM;The Express TP4 also decreases the credit window W' andandM;the retransmit queue size Q' using equations 1 and 2.andP;  TheandM;slow start algorithm is used to get the inbound and outboundandM;data traffic flowing again.andM;AcknowledgmentsandM;A special thanks to Ballard Bare who participated in theandM;design and development efforts for the OSI Express TP4andM;implementation, and to Mike Wenzel who contributed toandM;the design efforts.andM;ReferencesandM;1.andP;  J.C.andP;  Majithia, et al., &quot;Experiments in Congestion Control,&quot;ProceedingsandM;of the International Symposium on Flow Control in ComputerandM;Networks, Versailles, France, February 1979.andM;2.andP;  K.K.andP;  Ramakrishnan and Raj Jain, Congestion Avoidance inandM;Computer Networks with a Connectionless Network Layer.andP;  PartandM;II: An Explicit Binary Feedback Scheme, Digital Equipment Corporation,andM;Technical Report  TR-508, August 1987.andM;3.andP;  V. Jacobsen, &quot;Congestion Avoidance and Control,&quot; ComputerandM;Review: Communications Architectures and Protocols (SIGCOMMandM;'88), Vol.andP;  18, no.andP;  4, August 1988.andM;4.andP;  Raj Jain, &quot;A Timeout-based Congestion Control Scheme forandM;Window Flow-controlled Networks,&quot; IEEE journal on SelectedandM;Areas in Communications, Vol.andP;  SAC-4, no.andP;  7, October 1986.andM;5.andP;  D.J.andP;  Aldous, &quot;Ultimate Instability of Exponential Back-off forandM;Acknowledgment Based Transmission Control of Random AccessandM;Communication Channels,&quot; IEEE Transactions on InformationandM;Theory, Vol.andP;  IT-33, no.andP;  3, March 1987.andM;6.andP;  K.K.andP;  Ramakrishnan and Raj Jain, Congestion Avoidance inandM;Computer Networks with a Connectionless Network Layer, DigitalandM;Equipment Corporation, Technical Report  TR-506, August 1987.andM;@@@081550529 0HPJIja045DLLDandM;The modules in the data link layer occupy the bottom of theandM;OSI Reference Model.andP;  Therefore, it was imperative that theyandM;be finished first and that their reliability be assured beforeandM;use by the upper layers of the OSI stack.andM;THE DATA LINK LAYER is the second layer in theandM;OSI Reference Model.andP;  Its function is to provide acandM;-cess to the LAN interface for the OSI network layerandM;(layer 3), and transmitting and receiving of data packets toandM;or from the physical layer (layer 1).andP;  This article describesandM;the data link layer, particularly the OSI Express card's implementationandM;of this protocol layer.andP;  The box on page 49andM;provides a brief description of the OSI network layer.andM;The data link layer consists of two sublayers: the LMCandM;(logical link control) sublayer and the MAC (media accessandM;control) sublayer.andP;  The LLC sublayer providesandM;a hardware independent interface to the upper-layer protocol.andM;The LLC used for the OSI Express card implementationandM;is specified in ANSI/IEEE standard 802.2.andP;  The OSIandM;Express card uses the Type 1 LLC protocol described withinandM;this specification.andP;  Type 1 LLCS exchange PDUS (protocolandM;data units) between themselves without the establishmentandM;of a data link connection.andP;  This is also called connectionlessandM;network protocol.andP;  The MAC sublayer controls access to theandM;shared physical signaling and medium technologies (e.g.,andM;coaxial cable, twisted pair, fiber optic cables, and evenandM;radio signals).andP;  The MAC protocol used by the OSI ExpressandM;card implementation is specified in IEEE standard 802.4.andM;Besides requiring that the OSI Express card implementationandM;conform closely to the IEEE standards, the goals thatandM;guided our design included:andM;* Hiding the upper LLC interface details from the data linkandM;layer user (network layer).andM;* Making the LLC support multiple MAC sublayers.andM;* Making the lower LLC interface simple and flexibleandM;enough to promote testability and ease of integration.andM;* Providing a loopback mechanism in the LLC.andM;* Creating and porting the MAC code to the OSI ExpressandM;card before all other protocol layers.andM;* Designing the MAC code and MAC test environment soandM;that some portions are leverageable to other MAC implementations.andM;Since the data link layer module had to be the first protocolandM;module completed, another goal was to ensure thatandM;the design and development process produced simple andandM;The Data Link Layer and CONEandM;The data link layer uses the facilities provided by CONEandM;(common OSI networking environment) to provide servicesandM;to the protocol layer above it and to communicate with theandM;protocol layer below it.andP;  These facilities include data structuresandM;for service access points (SAPS), interfaces to theandM;protocol layer routines, and the path data structure whichandM;represents an individual connection between applicationsandM;on different machines.andP;  CONE facilities and SAPS are describedandM;in detail in the article on page 18.andM;The protocol layer above the data link layer is called theandM;data link layer user.andP;  This is the network layer.andP;  Since theandM;LLC is the top layer of the data link layer, the networkandM;layer is also the LLC user.andP;  Similarly the MAC user is theandM;LLC.andP;  A SAP is an addressable point at which protocolandM;services are provided for a layer user.andP;  SAPS are identifiedandM;by address information found in the headers (protocolandM;headers) of data packets arriving at each layer.andP;  For the LLCandM;layer a SAP address is called an LSAP.andP;  Packets arriving at theandM;LLC layer usually have two addresses.andP;  One indicates whereandM;the packet came from (source) and the other indicates theandM;packet's destination.andP;  The from address is called the sourceandM;service access point, or SSAP, and the destination addressandM;is called the destination service access point, or DSAP.andM;CONE provides three data structures for all the protocolandM;layers that enable them to communicate with each other.andM;The first is the protocol entry data structure, which containsandM;pointers to all the procedures required by a particular protocolandM;layer.andP;  For example the following procedures are partandM;of the data link layer protocol and are used by the networkandM;layer to command the data link layer to perform certainandM;actions.andM;* DL-ADD-SAP.andP;  Set up an LSAP.andM;* DL_send_down.andP;  Send a data packet.andM;* DL_control_down.andP;  Send an XID or TEST command packet.andM;* DL_start_down.andP;  Set up a path between the data layer andandM;its user.andM;* DL_delete_sap.andP;  Remove an LSAP.andM;* DL_stop_down.andP;  Remove a path.andM;Pointers to these procedures are set in the CONE protocolandM;data structure when the LLC initialization procedure isandM;called.andP;  Also at initialization, an LLC SAP data structure isandM;set up so that the data link layer can find the network layer.andM;When a connection is established with a remote application,andM;CONE creates a data structure called a path.andP;  A pathandM;represents the intramachine route taken through the protocolandM;layers by packets on a given connection from theandM;application to the LAN interface.andP;  It consists of an orderedandM;list of data structures that contain, among other things,andM;pointers to the SAP entries of the protocol layers involvedandM;in the conversation between the two applications.andP;  Fig.andP;  7andM;on page 23 shows the CONE data structures.andM;Logical Link Control SublayerandM;The LLC sublayer on the OSI Express card performs twoandM;kinds of functions.andP;  It sends and receives packets for theandM;users and sends and responds to XID (exchange identification)andM;and TEST commands.andP;  The XID command is used toandM;describe the capabilities of the LLC sublayer on oneandM;machine to the LLC sublayer on another machine.andP;  The XIDandM;command is sent as a single packet containing the DSAPandM;and SSAP addresses, a control field set to the XID command,andM;and the XID information which describes the functions theandM;LLC supports.andP;  The LLC on the receiving machine sends aandM;response packet to the sender describing itself.andP;  The receiptandM;of the XID command is not reported to the LLC user becauseandM;it is handled internally by the LLC sublayer.andP;  The TESTandM;command is used to test the integrity of the communicationandM;link between the LLC sublayers on two communicatingandM;machines.andP;  Therefore, the TEST command also causes theandM;receiving LLC to send a response.andP;  The response data fromandM;the receiving machine is expected to be the same data thatandM;is sent in the command packet.andP;  Like the XID command, theandM;TEST command is not sent to the LLC user.andP;  The kinds ofandM;DSAP addresses in the XID and TEST commands includeandM;individual, group, and global addresses.andP;  The individualandM;address is used when the response packet is to be sent forandM;one particular LSAP address.andP;  The group address is usedandM;when the response is to be sent for a group of LLC users.andM;The global address is used when the response is to be sentandM;for all of the active LLC SAP addresses.andP;  A TEST packet sentandM;to the global address should result in responses from addressandM;zero and from each of the other active SAPS.andP;  One ofandM;the individual addresses, address 0, designates the sendingandM;LLC itself and is always active.andP;  Therefore, an XID or TESTandM;command sent to this address will always generate a response.andM;Media Access Control SublayerandM;The MAC sublayer is responsible for sending and receivingandM;data from the media.andP;  To fulfill this responsibility theandM;MAC sublayer performs:andM;* Conversion of outbound data into a form acceptable toandM;the hardware that sends the packet onto the media.andP;  ItandM;performs the reverse transformation for inbound packetsandM;* Checking to ensure that received packets have a MACandM;address that is acceptable to the OSI Express card andandM;that there are no detectable transmission errorsandM;* Managing how many times retransmission of a packetandM;should be attempted if there are transmission errors.andM;The MAC sublayer maintains a SAP table with one entryandM;for each active MAC address.andP;  Two addresses are alwaysandM;active: the local individual MAC address and the broadcastandM;MAC address.andP;  The individual MAC address is stored inandM;nonvolatile memory on the card and is unique for everyandM;individual card made.andP;  The assignment of this address isandM;managed on a worldwide basis.andP;  The broadcast address isandM;one that all MAC sublayers are required to accept.andP;  AdditionalandM;addresses, such as multicast addresses, may also beandM;activated.andP;  These multicast addresses are used by the networkandM;layer.andM;LLC and MAC interfaceandM;The procedures contained in the LLC and MAC sublayersandM;are designed to conform closely to IEEE standards 802.3andM;and 802.4 and to maximize the independence between theandM;two sublayers.andP;  The procedures provided by the MAC sublayerandM;include:andM;* Send-packet.andP;  This procedure is used by the LLC sublayerandM;to request the MAC sublayer to send a data packet outandM;onto the media.andM;* Activate_mac_addr and Deactivate_MAC_addr.andP;  These proceduresandM;are used as their name implies, to activate andandM;deactivate MAC addresses.andP;  When a MAC address is activated,andM;an entry is made in the MAC SAP lookup table.andM;A MAC address may be activated more than once if severalandM;LLC users (with different LSAPS) use the same MACandM;address.andP;  The data structure containing the MAC SAPandM;has a reference counter that contains a count of theandM;number of times the address is activated by one of theandM;LLC users.andP;  When the MAC address is deactivated, theandM;count is reduced, but the MAC address itself is not deactivatedandM;until the count is reduced to zero.andM;* Check-mac-addr and Store_Indiv_MAC_Addr.andP;  These proceduresandM;are used to provide independence between theandM;LLC and MAC sublayers.andM;The procedures provided by the LLC for the MAC sublayerandM;include:andM;* Check_packet and Receive_packet.andP;   These procedures areandM;used to send packets received from the media by theandM;MAC sublayer to the LLC sublayer, which in turn sendsandM;them to the data link layer user.andP;  The Check-packet procedureandM;was developed to improve performance.andP;  When theandM;MAC layer receives a packet from the media it is in aandM;format used by the hardware to interface to the media.andM;Therefore, the data must be converted to the format usedandM;by the OSI protocol stack.andP;  This effort is wasted if thereandM;is no data link layer user to accept the packet.andP;  Therefore,andM;before the MAC does the conversion, it calls the CheckandM;-  Packet procedure to check that the packet's LLC headerandM;is valid and that its destination address has an activeandM;LSAP set up for it.andP;  The LLC then returns a pointer toandM;the LSAP to the MAC sublayer if and only if the packetandM;is acceptable.andP;  If a pointer is returned, the MAC sublayerandM;does the conversion and then passes the packet andandM;pointer to the LLC sublayer using the Receive_packet procedure.andM;* Return_Sent_Packet.andP;  This procedure is used by the MACandM;sublayer to return the data structure of the packet thatandM;the MAC sublayer has sent onto the media.andP;  The LLCandM;sublayer will return the data structure to whatever protocolandM;wants it back.andM;Design DecisionsandM;The network layer and the LLC and NRC sublayers workandM;together successfully because of the decisions we made toandM;simplify the design and to minimize the amount of informationandM;each layer needed to have about the other layer.andP;  OneandM;of these decisions was that the network layer and the LLCandM;and MAC sublayers are to return no error messages aboutandM;whether or not a packet is successfully sent.andP;  This decisionandM;stemmed from trying to decide how a layer user shouldandM;respond to an error from lower layers.andP;  Since these errorsandM;are characteristic of the particular lower layer in use, handlingandM;these errors could result in a great deal of dependencyandM;in an upper layer on what was going on in a lower layer,andM;and would change if the lower layer changed (e.g., if theandM;IEEE 802.4 MAC was replaced with IEEE 802.3).andM;After reviewing the functions each layer was required toandM;provide, we realized that the transport layer had the responsibilityandM;for end-to-end communication and also that theandM;transport layer contains algorithms for ensuring the integrityandM;of the connection no matter how the packets are lost.andM;Some packets transmitted with no errors will fail to arriveandM;their destination because of network errors on the media.andM;It was decided to allow the transport layer to detect theandM;loss of any packets and handle all error recovery.andP;  ThisandM;relieves the transport layer from having to check statusandM;information from the lower levels on every packet.andM;One area we went to great length to simplify is addressandM;handling.andP;  The individual MAC address is a good example.andM;The network layer needs, as part of its protocol, to knowandM;which of three MAC addresses (two multicast addressesandM;and the individual address) a received packet has as itsandM;destination address.andP;  One method is to pass the individualandM;MAC address to the network layer.andP;  This has the drawbackandM;that the network layer would have to know the format ofandM;the address and the value of the individual address.andP;  ToandM;eliminate the need for the network layer to know this information,andM;LSAPS are set up for each set of LLC and MACandM;addresses the network layer might use.andM;The network parameters are used internally by theandM;network layer and each of the sets of address data is usedandM;to add an LSAP for the network layer.andM;The network layer sets up an LSAP with the DL_Add_SAP procedure,andM;which is in the LLC sublayer.andP;  To get the MAC addressandM;field initialized for the local address data, a call is madeandM;to the DL_Add_SAP procedure with one of the parametersandM;pointing to the local address data shown.andP;   TheandM;DL_Add_SAP procedure examines the address data fields andandM;if the field containing the flag for the local MAC addressandM;is true, the LLC calls the MAC sublayer routine Store_Indiv_andM;MAC_Addr and passes to the routine a pointer to the placeandM;in the address data where the MAC address is supposedandM;to be.andP;  The availability of the Store_Indiv-MAC-AddrandM;ensures that the LLC does not have to know what the MACandM;address is or where it is stored.andP;  When control is returnedandM;to the LLC sublayer, it uses the modified address data bufferandM;to add an LSAP just as if the MAC address had beenandM;supplied when DL_ADD_SAP was initially called.andM;The network layer does not have within its protocol theandM;concept of XID and TEST commands or responses.andP;  EitherandM;the network layer must detect and reject these packets orandM;the LLC must not send them to the LLC user.andP;  Some LLCandM;users do want to receive these packets.andP;  To prevent theandM;network layer from having to check the LLC control fieldsandM;of every packet, special flags were added to the LSAPs forandM;XID and TEST packets.andP;  When the LSAP is activated, theandM;network layer designates that the XID and TEST flags be setandM;to prohibit the reception of these responses at this particularandM;SAP.andP;  LLC users that do want to receive XID and TESTandM;packets would not set these flags.andM;Loop-backandM;Loop-back is the process by which the card is able toandM;receive or appear to receive something it has sent.andP;  LoopandM;-back is often used for testing, but it is also required for theandM;normal operation of the card.andP;  If two programs that are writtenandM;to communicate with each other over the network areandM;run on the same machine, loop-back is necessary for themandM;to communicate with each other.andP;  A data packet from eitherandM;of these programs must travel the entire protocol stackandM;because some of the layers of the network provide servicesandM;such as data transformations as well as transporting theandM;packet from one program to the other.andP;  Another reason forandM;traversing the entire stack is that the card cannot knowandM;whether a packet being sent is also one that the card shouldandM;receive unless the entire address of the packet is evaluated.andM;The task of loop-back, that is, the process of generating aandM;receive packet from a packet being sent, is the responsibilityandM;of the LLC sublayer in this implementation.andM;The network layer does not want all packets looped backandM;to itself.andP;  For instance, if all packets sent out with one ofandM;the multicast addresses as the destination address wereandM;looped back, the network layer would be burdened withandM;spurious packets and would have to check each packet'sandM;network address to be sure it was not one it had sent.andP;  SinceandM;one possible error in a network is for two network layersandM;to have the same network layer address, even the detectionandM;of unwanted looped-back packets could be impossible,andM;since the MAC individual address, which would decideandM;the issue, is not available to the network layer.andP;  The solutionandM;is to have a loop-back flag in the LSAP data structure.andP;  WhenandM;the loop-back flag is set, the LLC knows that packets sentandM;on a path using the LSAP should be looped back if theandM;remote address of the path is the one on which the cardandM;receives packets.andM;The data flow of a loop-back packet is shown in Fig.andP;  3.andM;The packet is sent from program A to program B. ProgramandM;A sends the packet down to the upper layers just as itandM;would send a packet to a program on another node.andP;  FromandM;there it is sent to the transport layer and then the networkandM;layer.andP;  The network layer sends the packet to the LLC usingandM;path 1, which has its remote address set to the node ofandM;program B. In this case since program B is on the sameandM;node, the remote address is the one on which the localandM;node itself receives packets.andP;  The LLC sublayer sends theandM;packet to the MAC sublayer where it is sent out onto theandM;network.andP;  (Loop-back packets are also sent out onto theandM;network because the remote address can be one that otherandM;nodes also receive.) The MAC returns the packet to theandM;LLC after it is sent.andP;  The LLC checks to see if the packetandM;is a loop-back packet.andP;  Since it is, the LLC starts the packetandM;up the stack via path 2, which has as its remote addressandM;the local address of the original packet.andP;  The LSAP associatedandM;with path 2 has as its address the destinationandM;address of the original packet.andP;  The network layer receivesandM;this packet the same way it would if it came from anotherandM;node.andP;  The packet is then passed up the stack to program B.andM;Rather than do a full LLC and MAC address comparisonandM;each time a packet is returned from the MAC sublayer, aandM;flag in the path is tested.andP;  This flag is set when the path isandM;set up, based on whether the LSAP associated with theandM;path allows loop-back and whether the remote address ofandM;the path is one on which the node receives packets.andP;  ThisandM;flag must be updated each time an LSAP is added or deleted.andM;Since LSAPS are usually added at initialization andandM;never deleted, the updating does not add any overhead toandM;the card's operation.andM;The checking of a path's remote address against addressesandM;that are active in the LLC and MAC sublayers is doneandM;by a method that maintains as much independence betweenandM;the two sublayers as possible.andP;  The LLC sublayer uses theandM;MAC procedure Check_MAC_Addr to check a remote address.andM;The MAC sublayer returns a flag that indicates whether orandM;not the address is an active MAC address.andP;  Thus, the LLCandM;does not have to know the format of the MAC address orandM;how it is stored in the MAC sublayer.andP;  If the MAC addressandM;is active, the LLC checks its own LSAPs to determine ifandM;one of them will accept the remote address of the path asandM;a legitimate destination address.andM;LLC and MAC TestingandM;Once the LLC and MAC interface design was completed,andM;testing became the next critical issue.andP;  The OSI ExpressandM;project required that the MAC interface software be one ofandM;the first functional modules on the OSI Express prototypeandM;card.andP;  A high percentage of its functionality had to be veryandM;reliable so that code for the LLC and other layers of theandM;OSI stack could begin to run on the card.andP;  Since the prototypeandM;card was not immediately available, another methodandM;of testing had to be developed to make immediate progress.andM;The scenario interpreter and test harness environment hadandM;already been developed for the HP 9000 Series 300 HP-UXandM;environment, so we decided to leverage the tools from thisandM;existing testing environment.andP;  The scenario interpreter is aandM;software test tool that handles the sending and receivingandM;of data packets to and from the software under test, andandM;the test harness enables testing in different environments.andM;Both of these test tools are described in the article on pageandM;72.andP;  Testing the MAC interface in the scenario interpreterandM;and test harness environment also allowed the LLC andandM;other modules that have interfaces to the MAC software toandM;exercise this interface without writing special test code.andP;  ItandM;was also necessary to be able to do a majority of the debuggingandM;in the friendly HP-UX environment.andP;  Since theandM;Motorola 68824 token bus controller chip (TBC) had beenandM;previously tested and had proven to be reliable, it wasandM;decided that the TBC could be emulated, thereby avoidingandM;the need to wait for the hardware prototype to be ready.andM;As shown in Fig.andP;  4, the MAC interface testing environmentandM;used the existing scenario interpreter and its scenarioandM;syntax and the existing test harness.andP;  In place of the genericandM;bounce-back module, a special MAC interface bounce-backandM;module was written.andP;  The generic bounce-back module isandM;used by any module that needs to make it look as thoughandM;it is receiving data packets from the layer below it.andP;  It takesandM;the data transmitted to it and calls the receive routine ofandM;the layer configured above it.andP;  The MAC interface could notandM;use this module because there is no layer below it and soandM;special code had to be written in the emulator.andP;  In a typicalandM;testing instance, the scenario interpreter reads a scenarioandM;that tells it to send a specific amount of data to the configuredandM;layer.andP;  The test harness reads the data, which eventuallyandM;gets sent to the LLC sublayer.andP;  The LLC puts its headerandM;on the data packet and calls the MAC module.andP;  The MACandM;module prepares all the data structures needed by the TBCandM;and transmits the packet.andP;  The special MAC interfaceandM;bounce-back module is then called.andP;  This module performsandM;the tasks that the hardware and the TBC normally perform;andM;it sets status in the packet to make it appear that it hasandM;been transmitted onto the network and copies the informationandM;in the transmitted packet into buffers in the inboundandM;buffer pool to make it appear that a packet has been receivedandM;from the network.andP;  It then causes a receive packet interrupt,andM;which causes the MAC code responsible for receiving theandM;packet to be invoked.andP;  The transmitted and received packetsandM;are processed and forwarded to the LLC software as thoughandM;the code was running on the OSI Express card.andP;  When theandM;received data reaches the scenario interpreter, the interpreterandM;compares it to the data that was sent and saves the resultsandM;of the comparison in the test results file.andM;ConclusionandM;The network layer and the data link layer with its LLCandM;and MAC sublayers provide the network layer user, theandM;transport layer, with the ability to send a packet efficientlyandM;to any accessible node given just the network layer address.andM;The network layer locates the destination node even if itandM;is not on the local area network.andP;  The LLC separates packetsandM;it receives that are for the network layer from those thatandM;are for other data link layer users on the OSI Express card.andM;The MAC sublayer provides an interface to the media thatandM;is independent of the media.andP;  This achievement was accomplishedandM;by adherence to international standards and aandM;design that minimizes the dependencies of the protocolsandM;upon each other's internal operations.andM;AcknowledgmentsandM;We would like to acknowledge and thank the card andandM;chip hardware design team which consisted of Mike Perkins,andM;Mark Fidler, Paul Zimmer, Alan Albrecht, Dan Dove,andM;and Nancy Mundelius.andP;  Mike Perkins and Mark Fidler wereandM;also vital in the early debugging and testing of the TBCandM;chip.andP;  Mike Wenzel provided vital insights on how to incorporateandM;the data link layer into the CONE environment.andP;  CurtisandM;Derr provided a ROM version of the LLC/MAC and TBCandM;interface software which is used with the hardware diagnosticandM;program.andP;  He also coordinated the COS (CorporationandM;for Open Systems) testing of the data link layer.andP;  SpecialandM;thanks to Motorola's technical support staff, especiallyandM;Rhonda Alexis Dirvin, Paul Polansky, and Robert OdellandM;who provided excellent technical support of the TBC.andM;@@@0815506OX 0HPJIja051HOEDandM;Network standards are sometimes associated with slowandM;networking.andP;  This is not the case with the HP OSI ExpressandM;card.andP;  Because of early analysis of critical code paths,andM;throughput exceeds 600,000 bytes per second.andM;PEFORMANCE ANALYSIS of the HP OSI ExpressandM;card began during its early design stages and continuedandM;until the product was released.andP;  During theandM;course of the project several different analysis techniquesandM;were applied.andP;  These included simple analytic modeling,andM;path length estimation, simulation, and prototype measurement.andM;Several tools were developed to make the prototypeandM;performance measurements.andP;  Many estimations of throughputandM;and delay were made during the development phasesandM;of the OSI Express project.andP;  These intermediate results ledandM;to redesign or code reduction efforts on the bottlenecks inandM;the software.andM;In the end, we far exceeded our initial performance expectations.andM;Early performance investigation was invaluableandM;in pinpointing potential bottlenecks when there was stillandM;time to make design changes.andP;  We learned that the mostandM;fertile areas for performance enhancement and code pathandM;reduction are usually in module redesign, not code tuning.andM;Static Analysis.andM;The earliest OSI Express performance activity was toandM;estimate the amount of code in &quot;typical&quot; inbound and outboundandM;data paths.andP;  A typical inbound data path was definedandM;as the code executed when a data packet is received fromandM;the LAN going to the host service.andP;  For this estimate, it wasandM;assumed that the packet arrives without errors.andP;  Some assumptionsandM;were also made about what processing was typicalandM;or most common.andP;  These assumptions were periodicallyandM;revised as we learned more about the system.andM;Once the path estimates were derived, throughput andandM;delay measurements could be obtained.andP;  This process wasandM;referred to as static analysis because the statistics obtainedandM;were best-case and worst-case estimates without any referenceandM;to how a dynamic system behaved.andP;  The static analysisandM;process derived these statistics by comparing the numberandM;of CPU (and DMA) cycles required by a single packet toandM;the total number of cycles available in the hardware.andM;The first path measurements were made in units of 68020andM;assembler instructions.andP;  An early analysis revealed thatandM;using ten CPU cycles per assembler instruction was a fairlyandM;safe (and usually conservative) estimate.andP;  This was true unlessandM;the design engineer used a number of multiply or divideandM;instructions.andP;  In fact, early analysis showed the highandM;cost of these two instructions and steps were taken to avoidandM;using multiplies and divides unless necessary.andM;Because the earliest performance estimates were attemptedandM;before much code was written, it was necessary to studyandM;each software module carefully to understand all of theandM;tasks that the software would be required to perform.andP;  TheandM;typical paths (inbound and outbound) could then beandM;roughly pseudocoded.andP;  A second analysis during this timeandM;revealed that the C compiler on the development systemsandM;typically generated three to four 68020 assembler instructionsandM;per line of simple C code.andP;  A simple C code line wasandM;defined as a line in which only one operation is performed.andM;Therefore, if a line of C (or pseudo C) wasandM;a = (b andamp; a) I (c andless;andless; d);andM;it was estimated as four simple C instructions and thereforeandM;twelve to sixteen 68020 assembler instructions.andM;The inbound and outbound paths were estimated separatelyandM;because independent estimates for each path wereandM;needed to understand the complete set of tasks necessaryandM;to transfer a packet from one node to another.andP;  The twoandM;parts are not the same length.andP;  We expected to find theandM;inbound path longer (in terms of instructions) than theandM;outbound path.andM;Once the estimation had been completed, the number ofandM;assembler instructions in both paths was multiplied byandM;10 (ten cycles per 68020 instruction).andP;  The result is theandM;number of processor cycles used in transmitting and receivingandM;one typical data packet by the OSI Express card.andP;  SinceandM;the basic hardware architecture of the OSI Express cardandM;was in place, it was relatively easy to estimate theandM;maximum possible throughput and minimum possibleandM;delay.andP;  The following is an example of a static analysisandM;throughput equation for the OSI Express card.andM;Throughput in bytes per second =andM;[TC/(PW(RC + WC) + IC)I(P - H)andM;where TC   = total available cycles per secondandM;PW   = size of the packet in words (16 bits)andM;RC   = number of cycles per read accessandM;WC   = number of cycles per write accessandM;IC   = number of instruction cycles in receiveandM;data pathandM;P    = packet size in bytesandM;H    = header size.andM;Some of these values were slightly variable.andP;  Average orandM;typical values were often used, and care was taken to estimateandM;conservatively.andM;First Path EstimationandM;During the course of the OSI Express project, two completeandM;data path estimations were made.andP;  The first estimateandM;was made during the design phase, before much codingandM;had begun.andP;  The second estimate was made after most ofandM;the code had been written.andM;The first code path length estimate was done while theandM;project was in the early design phase.andP;  Only a portion ofandM;the code was written.andP;  To get the path length for the codeandM;that was written, a mixed listing of the code was obtained.andM;A mixed listing in this case was an assembled listing ofandM;the 68020 instructions intermixed with the original C instructions.andM;The data path was then identified and the assemblyandM;instructions counted.andP;  In addition to giving us theandM;instruction count, this exercise also educated us on howandM;the C compiler was behaving and what sort of assemblyandM;code was generated.andM;As discussed before, most of the code was written at theandM;time of the first path length estimation when most of theandM;development engineers were working on their external designs.andM;The estimation method used was to read the ISOandM;specifications for each layer and the ERS for CONE (commonandM;OSI networking environment), and write pseudocodeandM;for the data path.andP;  The pseudocode was then translated intoandM;68020 instructions using the the multiplier factors discussedandM;above.andP;  This entire process took about six months.andM;Figs.andP;  1 and 2 show the results of this first estimationandM;process.andP;  Fig.andP;  1 displays the number of instructions in theandM;outbound data path and Fig.andP;  2 displays the number of instructionsandM;in the inbound data path.andP;  The graphs show thatandM;the largest code segment in the data path at that time wasandM;the memory management code.andP;  We therefore decided toandM;redesign the memory manager code to reduce the numberandM;of instructions in the most common data path.andM;A number of smaller code changes were also made as aandM;result of this first performance investigation.andP;  RedundantandM;instructions, excessive multiplies, unnecessary initialization,andM;and more streamlined code processes were identified.andM;In addition, the team learned more about code modulesandM;that were influenced by decisions in distant code modules.andM;Second Path EstimationandM;The second estimate was made after the code was basicallyandM;written but before much unit testing had been done.andM;This estimate was quite a bit quicker because there was noandM;pseudocoding to do.andP;  In addition, the data path was prettyandM;well understood by this point.andP;  Therefore, mixed listings ofandM;all the code modules (and protocol layers) were obtainedandM;and a walkthrough of the data path was performed.andP;  Again,andM;care was taken to be as accurate as possible, since theandM;performance statistics resulting from the code count wereandM;only as good as the data.andM;Code was counted for both the inbound and the outboundandM;data paths.andP;  By the time the second count was made thereandM;had been a number of design changes and developments.andM;Figs.andP;  3 through 6 show the results of these changes.andP;  TheandM;backplane handler code had exploded into a much largerandM;module than was initially expected.andP;  This module then becameandM;the primary target of a performance redesign effort.andM;As before, a number of performance opportunities wereandM;identified as a result of the second walkthrough.andP;  In addition,andM;we learned more about how the OSI Express cardandM;would behave when parameters were varied in the FTAM,andM;IPC, and CIA host code.' Several changes were suggestedandM;to the designers of these modules.andP;  In one case, we foundandM;that performance was severely impacted during file transfersandM;when the data was presented to the OSI Express backplaneandM;in 256-byte buffers instead of kernel clusters  2K-byteandM;buffers).andM;Connection Establishment PathandM;In addition to the common data path, the connectionandM;establishment path was also analyzed during the OSI ExpressandM;performance investigation.andP;  This analysis was madeandM;a little later in the project after the second path estimateandM;had been completed.andP;  For the sake of speed, this path wasandM;counted in lines of simple C. By this time we had gainedandM;quite a bit of confidence in our estimation method and inandM;our knowledge of the code processes.andP;  This estimation tookandM;much less time than the other two.andM;It was discovered that the amount of code required toandM;secure a connection was quite a bit larger than that requiredandM;to send or receive a data packet.andP;  Of course, we knew thatandM;this was true before even beginning the connect pathandM;analysis.andP;  We just did not know how large it was.andP;  Our investigationandM;showed us that the connect code path was 91,424andM;lines of C code (simple) in a typical case.andP;  In other words,andM;it would take approximately 366 milliseconds for a connectandM;to complete successfully.andP;  (We assumed four 68020 instructionsandM;per C instruction).andM;It was also discovered that the connect path providedandM;many opportunities for path reduction.andP;  Once a particularandM;code path is fully understood, performance opportunitiesandM;are usually obvious.andP;  This was definitely the case in thisandM;analysis and both of the previous path estimation exercises.andM;Benefits of Early Performance WalkthroughsandM;There are a number of benefits to performance analysisandM;during all of the phases of new product design.andP;  The benefitsandM;far outweigh the cost of the additional engineer (or two) ifandM;one of the project goals is good performance.andP;  The benefitsandM;are obvious when path analysis reveals code redundancyandM;or other time-saving opportunities.andP;  Other benefits that provideandM;big paybacks may not be so obvious.andP;  The followingandM;is a list of the less obvious benefits we found during OSIandM;Express performance analysis.andM;* Design inconsistencies were exposed.andM;* The design engineers became performance consciousandM;and wrote cleaner code.andM;* There was time for redesign of bottleneck areas.andM;* We became much more proficient in performanceandM;analysis.andP;  Future products benefit from this kind of education.andM;Simulating Flow ControlandM;The second major step in the OSI Express performanceandM;study was to create a simulation model to aid us in discoveringandM;how configurable parameters in the OSI Express stackandM;affected performance.andP;  The static or path f low analysis thatandM;was discussed above had yielded best possible throughputandM;and delay statistics.andP;  In other words, the static analysis hadandM;given us an idea of what the upper performance boundsandM;were, given our code paths.andP;  What quickly became apparentandM;was that it was quite improbable that we could achieveandM;these upper bounds unless the card was configured withandM;optimal parameters and all other conditions were perfect.andM;Fig.andP;  7 shows the difference in throughput when only oneandM;parameter (packet size) is varied.andM;The reason that packet size plays such a substantial roleandM;in throughput is that it takes approximately the sameandM;amount of work to process an 8K packet (the maximumandM;packet size allowable by the IEEE 802.4 standard) as it doesandM;a 1K packet.andP;  At least this is true if the memory managementandM;design is optimal for fast throughput.' Larger packets generallyandM;require more CPU cycles to process (for memoryandM;copies, DMA transfers, checksum operation, etc.).andP;  However,andM;the difference in the cycles required to process twoandM;packets of different sizes is proportionally smaller than theandM;difference in the number of bytes transferred.andP;  Additionally,andM;processors with cache memories can minimize the differenceandM;in the CPU overhead between large and small packetsandM;because copies and checksum operations are repetitiveandM;looping functions.andM;Transport LayerandM;The OSI transport layer (layer 4) is the layer where theandM;packet size is determined.andP;  Other transport parameters alsoandM;have values that can dramatically influence systemandM;throughput and delay.andP;  The parameters that govern the flowandM;of data from one node to another were the major topics ofandM;our simulation study.andM;The transport layer parameters have significant impactandM;on the communication performance of a network node.andM;The flow control algorithm in the transport layer is responsibleandM;for the dynamic end-to-end pacing of conversationandM;between two nodes.andP;  Its main purpose is to ensure that oneandM;node does not send data faster than another node can receiveandM;it.andP;  Given two connected nodes, one node will usuallyandM;be able to execute faster than the other.andP;  The best throughputandM;between these two nodes is achieved when the slowestandM;node is kept completely busy.andP;  If the flow control algorithmandM;allows the slower node to become idle, throughput will beandM;lower than its potential maximum.andP;  If the flow control algorithmandM;allows too much data to be sent to the slower sideandM;(usually the receiving side), the slow side will eventuallyandM;be filled to capacity and be unable to accept more data.andM;This results in lost data, which must be resent.andP;  ResendingandM;data also causes performance degradation.andM;The flow control algorithm usually has a number of parametersandM;that can be set by the system manager.andP;  TheseandM;parameters are available so that the algorithm can be tunedandM;to provide the best performance in a specific user environment.andM;Some of the parameters at the transport layer includeandM;the transport segment size (the maximum amount of dataandM;in each packet), the transport window size (the maximumandM;number of packets that can be sent at one time), the amountandM;of credit to extend to a peer, the frequency of acknowledgmentandM;packets, and the length of the retransmission timer.andM;Simulation ModelandM;The simulation model of the OSI Express card was writtenandM;in a language called PC Simscript 11.5.andP;  It was primarilyandM;designed to expose and isolate the dynamic elements ofandM;the OSI Express system.andP;  Therefore, the transport layer, theandM;backplane message interface layer (because of the segmentationandM;capability at the backplane), and the CONE schedulerandM;were simulated in great detail.andP;  The upper layers (ACSE,andM;presentation, and session) were not really simulated at allandM;because they do very little processing for a data packet.andM;Instead the simulation merely &quot;worked&quot; for the amount ofandM;time that the upper layer headers would typically requireandM;for processing.andM;The simulation model was specifically designed to allowandM;a user to vary parameters, getting a performance report atandM;the end of each simulation run.andP;  The idea was that theandM;simulation would help the OSI Express team define whichandM;parameter values gave the best throughput and delay valuesandM;and why.andM;A number of assumptions were made in the simulationandM;model that are not necessarily true in the actual OSI ExpressandM;system.andP;  The reason for these simplifying assumptions isandM;that they streamlined the simulation implementation andandM;facilitated the experimentation process.andP;  Since the simulationandM;was written to isolate dynamic behavior, details thatandM;might obscure or complicate the simulation were ignored.andM;Although the system representation had been simplifiedandM;extensively, an attempt was made to be meticulous inandM;simulating those parts of the real system that have an impactandM;on dynamic behavior on the OSI Express card.andP;  To aandM;large extent, the art of simulation is knowing what not toandM;simulate.andM;The following is a list of the major assumptions madeandM;during the design of the simulation program:andM;* All packets arrive in order and without error.andM;* All data transmissions from the host contain the sameandM;amount of data for all connections (the amount of thatandM;data is a parameter).andM;* Since packets are never lost, no retransmission timersandM;or AK' delay timers are included in the transport simulation.andM;* The two target nodes transmit all data at the highestandM;priority level (IEEE 802.4 specifies four priority levels:andM;0, 2, 4, and 6).andM;* There is no simulated connect setup or tear-down time.andM;The assumption is that connections are fully establishedandM;before the data is sent to the card.andM;* All packets sent onto the simulated network are eitherandM;data packets or AK/credit packets.andP;  None of the routineandM;features in the internet protocol are simulated.andP;  Consequently,andM;there are no end-system or intermediate-systemandM;hello packets to contend with.andM;*  The packet headers are 80 bytes long.andM;*  Card memory is a user-configurable parameter.andP;  However,andM;the inbound packet data memory is assumed to be halfandM;of the total data memory.andP;  The outbound data packetandM;memory is also assumed to be half of the total data memory.andM;2  The host data can be sent to the card faster than the cardandM;can consume it.andP;  Also, on the receiving side, the host canandM;consume the data faster than the card can send it.andP;  InandM;short, the host is assumed to be an infinitely fast sourceandM;and sink.andM;* The maximum speed of the token bus is 10 Mbits/s.andP;  AnandM;assumption is made that the speed with which packetandM;data can travel is 1 Mbyte/s.andP;  This is because there isandM;overhead for the IEEE 802.4 protocol that prevents theandM;data packets from traveling much faster.andM;Simulation Model FeaturesandM;The simulation model has a number of features that increaseandM;its usability.andP;  The model can be run in either half-duplexandM;or full-duplex mode.andP;  In half-duplex mode, one ofandM;the two communicating nodes is a sender and one is theandM;receiver.andP;  In full-duplex mode, both nodes send and receiveandM;simultaneously.andM;The model has the capability of varying four parametersandM;automatically and running a complete simulation for eachandM;value of the parameters.andP;  Each of the four parameters canandM;be given a range of values and a step size to vary.andP;  StatisticsandM;are collected for each of the simulation runs and saved inandM;a file.andM;The model allows the communicating nodes to have aandM;number of connections alive at the same time.andP;  In this mode,andM;the model can calculate statistics for each connection, asandM;well as global statistics.andM;The model has various debugging levels that can beandM;turned on to enable the user to understand better what isandM;happening during a simulation run.andM;There is a separate default parameter generator programandM;that enables the user to specifiy default parameters easily.andM;The generator program then creates a default file that isandM;used by the simulation program.andM;The simulation model generates and saves a number ofandM;useful statistics during execution.andP;  These are formatted andandM;saved in a file for later examination.andP;  Some of these statisticsandM;are:andM;* Throughput in bytes per secondandM;* Total simulaton delay in bytes per secondandM;* Mean packet delay in millisecondsandM;* Maximum packet delay in millisecondsandM;* Mean transport-to-transport delay in millisecondsandM;* Mean acknowledge delay in millisecondsandM;* Maximum acknowledge delay in millisecondsandM;* Average interval time between packets, in millisecondsandM;* Total interval time between packets, in millisecondsandM;* Percentage of CPU idle timeandM;* Maximum and minimum queue depths for five systemandM;queues.andM;The simulation model has a very friendly user interfaceandM;to simplify the selection of the system parameters.andP;  In addition,andM;the user interface displays the parameters obtainedandM;from the default file and allows the user to change themandM;if necessary.andM;Simulation Study ResultsandM;Once the simulation was written and verified (by hoursandM;of painstaking cross-checking) a number of simulation experimentsandM;were run.andP;  Time and space prevent describingandM;all of the results except the most interesting: what happensandM;when the transport window size and the frequency of sendingandM;AK/credit packets are varied.andM;Figs.andP;  8 and 9 show the impact of varying these two parametersandM;in the simulated system.andP;  Each of the data points inandM;these graphs represents one complete simulation run withandM;a particular set of parameter values.andP;  To get Fig.andP;  9, the windowandM;size was set to 10 and the packet size fixed at 1KandM;bytes.andP;  For the sake of simplicity, it was assumed that incomingandM;packets were only acknowledged when it was time toandM;send more credit (permission for the transmitting node toandM;send more packets) to the peer node.andP;  The frequency ofandM;sending credit packets was varied from one to ten.andP;  In otherandM;words, during the first simulation run, the window sizeandM;was ten and the receiving node sent out an AK/credit packetandM;to the sending node after each packet was received andandM;processed.andP;  The Ak/credit packet acknowledged the packetandM;that was received and gave the sending node permissionandM;to send another.andP;  During the next simulation run, the creditandM;frequency parameter was set to two.andP;  An AK/credit packetandM;was therefore sent after two packets had been received byandM;the receiving node and processed.andP;  In this case the receivingandM;node acknowledged reception of two packets and gave permissionandM;to send two more.andM;As shown above, the best throughput value is achievedandM;when the receiving node sends an AK/credit packet everyandM;sixth packet.andP;  This point represents a balance between sendingandM;AKs too frequently and not sending them frequentlyandM;enough to keep the system fully pipelined.andP;  If too manyandM;AKs are sent, they effectively increase the CPU overheadandM;required to process packets (Fig.andP;  10).andP;  That is because theandM;number of instructions required to construct and send (andandM;receive) AK packets is significant.andM;On the other hand, if AK packets are not sent frequentlyandM;enough, the sending node will run out of packets to sendandM;and will have to wait for an AK before starting to sendandM;more (the window size limits how many packets can beandM;sent without an AK).andP;  When the sending side stops sendingandM;packets (even for a short while), interarrival time betweenandM;incoming packets at the receiving node will, in general,andM;increase.andM;Dozens of simulation experiments were run during theandM;course of the OSI Express project.andP;  The flow control parameterandM;defaults were set based on the information from theandM;simulations.andP;  In addition, we learned a great deal about theandM;behavior and resulting statistics of the transport stack.andM;Some design decisions were changed based on the resultsandM;of the experiments.andP;  For example, we decided not to giveandM;priority to inbound packets by allowing a logical link controlandM;(LLC) process to execute until all the receive packets wereandM;processed.andP;  We found out to our surprise that the simulatedandM;throughput dropped sharply when we experimented withandM;this design.andP;  The reason was that the AK/credit packets wereandM;being excessively delayed and the queues between theandM;transmitting and receiving node were therefore emptying.andM;Performance MeasurementandM;The final challenge of the OSI Express performance projectandM;was to measure the product, compare the measuredandM;performance with the estimates, and identify any bottleandM;-neck code modules.andP;  Several tools were designed and writtenandM;to help us get real-time performance measurements.andM;These tools were basically designed solely for prototypeandM;measurement, not for field or customer use.andP;  In the followingandM;paragraphs, three tools are briefly described.andP;  These toolsandM;are the real-time procedure tracer, the statistics monitor,andM;and the statistics formatter.andM;Real-time Procedure Tracer.andP;  This tool consists of a specialandM;entry and exit macro call that was put after the entry andandM;before the exit of every procedure in the OSI Express code.andM;Each module in the OSI Express code was assigned aandM;hexadecimal number range.andP;  The designers of each moduleandM;then assigned an even number within that range to eachandM;routine in the module.andP;  A second value (i + even number)andM;was reserved for the exit macro.andP;  These numbers wereandM;passed as parameters in the macro calls.andP;  Both the entryandM;and the exit macros caused the passed hexadecimal valueandM;to be written into a reserved memory location called CISTandM;-ERN.andP;  The idea is that using a logic analyzer (such as theandM;HP 64000, HP 1630, or HP 1650), a user can trace writesandM;to the CISTERN location and see the procedures being executedandM;in real time.andP;  The hexadecimal value ranges assignedandM;to each module allow the user to limit the values read toandM;a specific number range.andP;  This way, the user can choose toandM;see only the transport layer executing, if desired.andM;To make the traces more readable, a formatter programandM;was written for HP 64000 trace files.andP;  The formatter requiredandM;a file that defined the hexadecimal values for specific procedures.andM;It then produced very readable formatted traces.andM;Fig.andP;  11 is an example of one of these formatted traces.andM;The procedure traces were used extensively once integratedandM;OSI Express code measurements could be made.andM;These traces allowed us to see how long each module wasandM;executing in as much detail as we cared to see.andP;  Code couldandM;be quickly tuned and remeasured.andP;  In addition, the traceandM;macros were optionally compiled, ensuring that they didandM;not provide needless overhead in the final product code.andM;Statistics Monitor.andP;  A second tool that was designed intoandM;the OSI Express stack Was the statistics monitor.andP;  A numberandM;of primitive statistics are kept in the OSI Express code (seeandM;Fig.andP;  12).andP;  In addition, statistics are kept (these optionallyandM;compiled) about each of five major queues in the OSI ExpressandM;system (see Fig.andP;  13).andP;  These statistics can be retrievedandM;and displayed upon command.andP;  The statistics can beandM;cleared, read, or read and cleared.andP;  The clear commandandM;clears all of the statistics except for current-value statisticsandM;such as the current queue depths.andM;These statistics made it possible to get real-time throughputandM;values at at the card level.andP;  In addition, the queue statisticsandM;provided some troubleshooting capability because certainandM;queue depths signaled flow control problems.andM;Statistics Formatter.andP;  The OSI Express statistics formatterandM;is a tool designed to allow a user to run a user-level testandM;program a number of times automatically, varying OSI ExpressandM;parameters each time.andP;  The transit statistics are clearedandM;at the beginning of each test run and sampled at the end.'andM;The purpose of this tool was to find the optimal parameterandM;set automatically on the working prototype.andP;  The simulationandM;model had this basic capability, so in effect, we wereandM;simulating the simulation model.andM;Once all of the test program runs have executed, theandM;formatter can retrieve the file with the statistical samplesandM;and display the results in several ways.andP;  Fig.andP;  14 is an exampleandM;of one of the types of displays that can be obtained.andM;The user now has the opportunity to identify, for example,andM;the highest throughput obtained when packet size is variedandM;because the test program was repeated for several possibleandM;packet sizes.andM;Performance ResultsandM;After the OSI Express prototype testing had been completed,andM;final performance measurements were made.andP;  OfandM;course, numerous performance values are possible, dependingandM;on how the card is configured.andP;  However, our best-caseandM;throughput for 8K packets was approximately 600,000andM;bytes per second.andM;This result reflects numerous redesign, code rewrite, andandM;code tuning efforts made by the whole team during theandM;entire lab prototype phase of the project.andP;  Many milandM;-liseconds were cut out of the code path based on informationandM;uncovered by these investigations.andP;  The majority ofandM;these improvements were made well before most code tuningandM;efforts began.andP;  There is no way that the same code reductionsandM;could have been made after the code had beenandM;integrated.andM;ConclusionandM;Early performance investigation and prediction is vitalandM;to performance sensitive projects, especially if they areandM;large and involve a number of design engineers.andP;  A largeandM;amount of very useful data can be retrieved with very littleandM;investment if it begins early enough in the project andandM;continues through code integration.andP;  Full performance investigationsandM;should be a part of every product life cycle.andM;AcknowledgmentsandM;Many thanks to Mike Wenzel at Roseville Network DivisionandM;and Martin Ackroyd at HP Laboratories in Bristol forandM;their expert consultation and assistance.andP;  Thanks also toandM;the rest of the OSI Express team for their patience andandM;many excellent suggestions.andP;  Special thanks to Glenn TalbottandM;for writing the CISTERN formatter, and to David ChingandM;for writing the statistics formatter tool.andM;@@@081550626 0HPJIja059HOECandM;The software diagnostic program is a high-level mnernonicandM;debugger.andP;  The structure definition utility isolates theandM;diagnostic program from compiler differences and dataandM;definition changes.andM;APPROPRIATE DIAGNOSTIC AND DEBUGGINGandM;TOOLS are essential to any successful software orandM;hardware development effort.andP;  A project as large asandM;the HP OSI Express card development effort posed someandM;challenging opportunities.andP;  Not only was most of the technologyandM;for the card, both software and hardware, still beingandM;defined, but the target computer line was still under developmentandM;as well.andP;  Tools such as the HP 64000-UX microprocessorandM;development environment and the HP 1650 logicandM;analyzer were evaluated to understand what was alreadyandM;available.andP;  These tools provided features such as single-steppingandM;and data tracing and were indispensable for doingandM;low-level debugging.andP;  However, a much higher-level debuggerandM;was also necessary to observe protocol operations andandM;system dynamics.andP;  Obtaining this information by decipheringandM;screens of hexadecimal data would be very tedious andandM;time-consuming.andP;  Also, until the card management toolsandM;were in place much later in the development cycle, thereandM;would be no means of monitoring the utilization of resourcesandM;on the card.andM;For these reasons, it was decided to pursue the developmentandM;of in-house debugging and diagnostic tools.andP;  The followingandM;design goals were established:andM;*  No existing functions duplicatedandM;*  Modular designandM;*  Evolving feature setandM;*  Minimal impact on product performanceandM;*  Minimal impact on card software sizeandM;*  No additional hardware on card requiredandM;*  No additional coding in product modules requiredandM;*  Can be used when all other debugging hooks are removed.andM;The design goals can be summarized as: (1) use the limitedandM;available time and engineers to develop new functionsandM;rather than trying to duplicate features provided elsewhere,andM;(2) provide flexibility to accommodate changes in the developmentandM;environment and new requests from the customerandM;base, and (3) ensure that nothing special needs toandM;be done to use these tools and that their use does not impactandM;the product being developed.andP;  While these goals may appearandM;to be unattainable, their intent was to focus the project soandM;that something usable could be provided in a reasonableandM;time and the effort would not collapse under its own weightandM;by trying to be the last word in diagnostics.andP;  The result ofandM;all this was the development of two modules: the structureandM;definition utility, which provides a dictionary of data definitionsandM;that can be accessed programatically, and the softandM;-ware diagnostic program, which is a high-level mnemonicandM;debugger that can monitor the resources on the card andandM;allow the user to view data from the card in variousandM;formats.andM;Structure Definition UtilityandM;During the early stages of the development of the cardandM;software, the definitions of the internal data structures wereandM;constantly in a state of flux.andP;  Any module or program referencingandM;these data types was constantly being recompiledandM;in an effort to keep it up to date.andP;  It was quickly recognizedandM;that it would not be practical or productive if the diagnosticandM;tools, test programs, and formatters had to be recreatedandM;every time a data type changed.andP;  Also, at any time in theandM;development process there could be different versions ofandM;protocol or environment modules under test.andP;  It would beandM;impractical to require that a different version of the diagnosticandM;and test programs be used depending on which versionandM;of a module was being tested.andM;A second obstacle in the creation of the diagnostic toolsandM;had to do with the two compilers that were to be used.andM;The card code was to be compiled with the 68000 C compiler.andM;The diagnostic programs, which resided on the host,andM;used the standard UNIX C compiler.andP;  The primary differenceandM;between these two compilers has to do with the way dataandM;types are aligned and padded.andP;  The 68000 compiler alignsandM;types such as ints on 2-byte boundaries while the UNIXandM;compiler aligns ints on 4-byte boundaries.andP;  Therefore, a dataandM;buffer retrieved from the card could not be interpreted byandM;the host program if the same data types were used.andP;  TheseandM;differences prevented the host diagnostics from compilingandM;with the same C header files as the card code.andM;It was obvious that some mechanism was needed to isolateandM;the test and debugging programs from both the fluctuationsandM;in the data structure declarations and the differencesandM;in the compilers.andP;  The structure definition utility (SDU) wasandM;developed for this purpose.andP;  The SDU is used to create aandM;data dictionary containing the C data type definitions.andP;  TheandM;definitions stored in the dictionary can then be accessedandM;via standard SDU library routines.andP;  When a data typeandM;changes, the new definition is loaded into the dictionaryandM;and the engineer can continue testing and debugging withoutandM;recompiling.andM;The SDU consists of three parts: a stand-alone parser/andM;compiler program, sdu.build, which processes the C typeandM;definitions and creates the data dictionary, the dictionaryandM;file, which is generated by the sdu.build program, and theandM;dictionary interface library, which allows applications toandM;access the information stored in the dictionary.andM;When designing the SDU it was necessary to keep inandM;mind that regardless of how creative the end product was,andM;no one would ever use it if it was too complicated, tookandM;too long to operate, or required that data be maintained inandM;more than one location.andP;  Given the number of type definitions,andM;it was especially important that the sdu.build programandM;be able to accept standard C include files as input.andP;  ThisandM;also meant that the sdu.build parser had to recognize as manyandM;of the C data type constructs as possible.andP;  After these twoandM;criteria were satisfied the whole process of creating andandM;accessing the dictionary still had to remain relatively simpleandM;and fast.andM;Input FormatandM;The input to the SDU parser is a C include file containingandM;the C data types, type definitions, and #defines from theandM;program header (.h) files.andP;  To provide for portability betweenandM;compilers and to simplify the parser design, some minimalandM;structure had to be imposed on the input data.andP;  The basicandM;format for the input data is:andM;(*type specifiersandM;type definitions, #defines, andandM;data default valuesandM;The input is divided into two parts: the type specifiersandM;and the type declarations.andP;  The punctuation denotes theandM;beginning and end of input and separates the two sections.andM;The type specifiers are optional, but the punctuation isandM;required even if the specifiers are not entered.andP;  While syntaxandM;is important, the input format is relatively free-form.andP;  ForandM;example, there are no restrictions on the number of statementsandM;per line.andP;  At least one blank must separate identifiersandM;on an input line, but for the most part, separators (blanks,andM;tabs, newlines) are ignored.andM;All data declarations are defined from the atomic C dataandM;types (int, char, short, etc.).andP;  The alignment and sizes of theandM;C basic types are preloaded into the data dictionary.andP;  TheseandM;values can be redefined and/or new values added usingandM;the type specifiers input.andP;  The primary reason for redefiningandM;the basic type values is the use of a different C compiler.andM;At least two and possibly three different C compilers wereandM;expected to be used during the development of the cardandM;code.andP;  The main differences between the compilers wereandM;the alignment of the data types and the padding of struct/unionandM;data types.andP;  The SDU compiler defaults to the alignmentandM;requirements of the HP 9000 Series 300 and 68000 C compilers.andM;The syntax for a type specifier entry is:andM;type, type_len, alignment, format;andM;Type is an ASCII string representing the name of the typeandM;specifier to be loaded.andP;  Type_len is a decimal value indicatingandM;the storage requirements of the type specifier in bytes (e.g.,andM;storage for the C type char is one byte).andP;  Alignment is a decimalandM;value indicating the byte alignment of the type when itandM;appears within a struct/union type declaration.andP;  The value isandM;in bytes and must be greater than zero.andP;  The value is usedandM;to determine to what boundary (byte, even byte, doubleandM;word, etc.) the type should be aligned.andP;  The value is alsoandM;used to determine the padding within the struct type.andP;  TheandM;format field is a single character indicating the default displayandM;form for this data type  x = hexadecimal, d = decimal,andM;a = ASCII).andM;Variable Definitions and ConstantsandM;The C variable definitions and constants are specified inandM;the second part of the SDU parser input.andP;  The variable definitionsandM;must be in standard C format as defined in the CandM;reference manual.' Data declarations (e.andP;  g., int abc;) and typeandM;definitions (typedefs) are accepted as input.andP;  Both simple andandM;complex (struct/union) definitions can be loaded.andP;  ConstantsandM;are loaded using the C preprocessor #define statement.andP;  TheandM;constant values can be used in subsequent  define statementsandM;or to specify the size of an array in a type definition.andM;Application programs can access the #define values onceandM;the dictionary is created.andP;  The SDU compiler will also recognizeandM;C comments (/*  */) and some forms of compilerandM;directives  #ifdef,  #else).andM;It is not necessary to define all the variables and constantsandM;explicitly in the same file as the basic type specifiers.andP;  It isandM;not even necessary to have them all in a single text file.andM;The SDU parser allows the user to specify the name of theandM;file or files containing the definitions instead of the definitionsandM;themselves.andP;  Given the name of the file bracketed byandM;percent signs  (%name%), the SDU parser will open theandM;specified file and load the definitions.andP;  This feature allowsandM;the variable and constant definitions to be used directlyandM;by the C programs since any special SDU symbols can beandM;restricted to the input specification file and do not haveandM;to be put in with the types.andM;Default informationandM;The SDU provides routines that allow applications toandM;create data buffers based on definitions loaded in the dictionary.andM;These buffers can then be used by the applicationsandM;for various purposes such as testing, debugging, and validation.andM;The SDU provides mechanisms for storing defaultandM;values for the data definitions in the dictionary.andP;  The defaultandM;values can then be loaded into the data buffers created forandM;the applications.andP;  The default information is loaded at theandM;same time as the data definitions using the format:andM;definition name = default value;andM;The definition must have already been loaded into theandM;dictionary.andP;  If the definition name is an item within a structandM;or union type then it must be fully qualified.andM;Creating the DictionaryandM;The data dictionary is created by the sdu.build programandM;from the C include files.andP;  Depending on the amount of informationandM;to be processed, the creation of the dictionary canandM;be a time-intensive task.andP;  So that every application does notandM;have to incur this overhead cost each time it wishes toandM;access the dictionary, the sdu.build program is run as a standaloneandM;program.andP;  The sdu.build program must be run wheneverandM;new data definitions are to be added to a dictionary.andP;  OnceandM;the dictionary is created, the dictionary can be accessedandM;by multiple applications.andM;Building the dictionary is a two-step process.andP;  The firstandM;step is to create the dictionary in the internal memory ofandM;the sdu.build program.andP;  As the data declarations are read theyandM;are loaded into the internal tables and data structures ofandM;the dictionary.andP;  The SDU compiler is responsible for readingandM;and verifying the input definitions and loading the informationandM;into the tables.andP;  Each #define constant and data declarationandM;will have at least one entry in a table  struct/union dataandM;types have one entry for each element defined as part ofandM;the struct/union declaration).andP;  Any errors encountered duringandM;the processing will cause the program to terminate andandM;display an appropriate message.andP;  The second step is to saveandM;the table information from the internal memory into somethingandM;more accessible by the user applications.andP;  Once theandM;dictionary has been successfully loaded the memory imageandM;is written to an HP-UX disk file.andP;  The name of this file isandM;specified in the run string when the sdu.build program isandM;executed.andM;Accessing the DictionaryandM;Applications planning to use the data dictionary mustandM;link with the dictionary interface library.andP;  This library containsandM;all the routines for accessing information stored inandM;the dictionary.andP;  The first library call made by the applicationandM;must be the one to load the dictionary information fromandM;the disk file into the application's internal memory.andP;  TheandM;application passes the name of the dictionary file to theandM;load call.andP;  The load routine allocates memory for the dictionaryandM;and reads the data into memory.andP;  The amount of spaceandM;required was written to a header record in the disk file byandM;the build program.andP;  The dictionary loaded is now an exactandM;copy of the dictionary created by the sdu.build program.andM;The load routine performs one more task before the dataandM;can be accessed by the calling application.andP;  The internalandM;design of the dictionary requires numerous pointers to linkandM;various pieces of information together.andP;  These pointers,andM;which are really just memory addresses, are valid only inandM;the original memory space where the dictionary wasandM;created.andP;  Although the system call malloc is used in both theandM;build and the load processes, it cannot be guaranteed thatandM;the memory obtained from the call will be in exactly theandM;same address location each time.andP;  Therefore, the internalandM;pointers must be modified to reflect the location of the dataandM;in the new address space.andM;The pointers are adjusted by comparing the load addressandM;and the build address (which was stored in the image file).andM;The required pointer adjustment is the difference betweenandM;the starting address for the build and the starting addressandM;of the internal memory for the load.andP;  This adjustment valueandM;(positive or negative) is added to all pointers in the internalandM;dictionary structures.andP;  When the pointers are adjusted theandM;load process is complete and the dictionary is ready forandM;use by the application.andM;Developing sdu.buildandM;Developing a program that can recognize C-language dataandM;declarations in all forms is akin to writing a mini versionandM;of the C compiler.andP;  Development of the SDU parser/compilerandM;program sdu.build would have been a formidable task hadandM;it not been for the tools yacc and lex available under theandM;HP-UX operating system.andP;   Yacc is a generalized tool forandM;describing input to programs; it imposes a structure on theandM;input and then provides a framework in which to developandM;routines to handle the input as it is recognized.andP;  The parserandM;generated from yacc organizes the input according to theandM;specified structure rules to determine if the data is valid.andM;Lex is used to generate the lexical analyzer, which assemblesandM;the input stream into identifiable items known as tokens,andM;which are then passed to the parser.andP;  Lex has its own set ofandM;rules called regular expressions,3   which define the inputandM;tokens.andP;  Regular expressions are patterns against which theandM;input is compared; a match represents a recognized token.andM;The parser and lexical analyzer are combined to create theandM;SDU compiler known as sdu.build.andM;The first step in using yacc is to define the set of rules,andM;or grammar, for the input.andP;  A grammar specifies the syntacticandM;structure of a language, with the language in this case beingandM;the C data declarations.andP;  The syntax is used to determineandM;whether a sequence of words (or tokens) is in the language.andM;Describing the syntax of a language is not as hard as itandM;sounds.andP;  A notation known as Backus_Naur form  (BNF)andM;already exists for specifying the syntax of a language.andP;  ConvertingandM;the C data declarations to BNF was simplified byandM;the fact that a partial grammar already existed.andP;  ElementsandM;not supported by the SDU were eliminated from the grammar.andM;The grammar consists of a sequence of rules.andP;  A rule isandM;written with a left-hand side and a right-hand side separatedandM;by a colon.andP;  The left-hand side consists of a singleandM;unique symbol called a nonterminal.andP;  The right-hand sideandM;consists of a sequence of zero or more terminals and nonterminalsandM;sometimes called a formulation.andP;  One or moreandM;formulations may appear on the right-hand side of a rule.andM;A rule must exist for every nonterminal symbol.andP;  TerminalandM;symbols, which are synonymous with tokens, are not definedandM;further in the grammar but are returned from theandM;lexical analyzer.andP;  Examples of grammar rules used for describingandM;some simplified mathematical expressions are:andM;expression    : primaryandM;| '('expression')'andM;| '-'expressionandM;| expression'+'expressionandM;| expression'-'expressionandM;| expression'*'expressionandM;| expression'/'expressionandM;primary       : identifierandM;| constantandM;The symbols expression and primary are nonterminals whileandM;identifier and constant are terminals.andP;  Values enclosed in singleandM;quotes are literals and must be recognized from the inputandM;stream along with the terminals.andP;  The vertical bar (|) meansandM;&quot;or&quot; and is used to combine formulations for the sameandM;nonterminal symbol.andP;  The nonterminal symbol on the left-handandM;side of the first rule is called the start symbol.andP;  ThisandM;symbol represents the most general structure defined byandM;the grammar rules and is used to denote the language thatandM;the grammar describes.andM;Once the grammar is defined in BNF, it is a very simpleandM;process to convert it to a form that is acceptable to yacc.andM;Because terminals and nonterminals look alike, yacc requiresandM;terminals to be defined using the %token statementandM;in a declarations section ahead of the grammar.andP;  Any grammarandM;that involves arithmetic expressions must define theandM;precedence and associativity of the operators in the declarationsandM;section to avoid parsing conflicts.andP;  Some additionalandM;punctuation, such as semicolons (;) at the end of each grammarandM;rule, and double percent signs (%%) to separate theandM;declarations section from the grammar, must also be addedandM;before the file can be processed by yacc.andP;  With these modificationsandM;the specifications can now be turned into a C proandM;-gram by yacc that will parse an input stream based on theandM;grammar rules.andM;The function of the lexical analyzer is to read the inputandM;stream a character at a time and assemble tokens from theandM;unstructured data.andP;  Tokens can be anything from operatorsandM;to reserved words to user-defined constants and identifiers.andM;Separating the tokens can be any number of white-spaceandM;characters (blanks, tabs, and line separators), which areandM;typically ignored.andP;  The most time-consuming part of creatingandM;the lexical analyzer is defining the regular expressions,andM;or patterns, which are used to recognize the input tokens.andM;The patterns must be general enough to recognize all formsandM;of the tokens and yet be specific enough to exclude tokensandM;that are not of the desired class.andP;  The syntax for definingandM;regular expressions is similar to the pattern matching featuresandM;found in most editors.andP;  A pattern to match C identifiersandM;might look like:andM;[A - Za - z-][A - Za - z0 - 9_]*andM;C identifiers start with a letter or underscore followedandM;by an arbitrary number of letters, digits, or underscores.andP;  InandM;the case where a token matches more than one pattern, lexandM;attempts to resolve the conflict by first choosing the patternandM;that represents the longest possible input string, and then,andM;if the conflict still exists, by choosing the pattern that isandM;listed first.andP;  Once a pattern is matched, lex executes anyandM;action associated with the pattern.andP;  Actions can be specifiedandM;along with the patterns; they consist of one or more linesandM;of C code that perform additional processing on the tokens.andM;For example, when an identifier is recognized it can be aandM;user-defined value or a C reserved word such as typedef orandM;struct.andP;  The action associated with the identifier pattern canandM;be used to search a table of reserved words to determineandM;the type of identifier found.andP;  This information can then beandM;returned to the parser along with the token.andM;Using the lexical analyzer and the parser as just described,andM;we now have a program that will read and validateandM;the input data.andP;  There is still one more step before thisandM;program can be used to create the data dictionary.andP;  NowandM;that we know the information is acceptable we have to doandM;something with it.andP;  This requires going back to the specificationsandM;for yacc and adding actions for each grammar rule.andM;The actions consist of one or more C statements that areandM;performed each time a rule is recognized.andP;  Unlike the lexandM;actions, these actions may return values that can be accessedandM;by other actions.andP;  They can also access values returned byandM;the lexical analyzer for tokens.andP;  In the sdu.build program, theandM;purpose of the yacc actions is to load the C data declarationsandM;into the internal structures of the data dictionary.andP;  With theandM;addition of the yacc actions the sdu.build program is nowandM;complete.andM;Software Diagnostic ProgramandM;The software diagnostic program (SDP) is an interactiveandM;application program that runs under the HP-UX operatingandM;system on HP 9000 Series 800 computers.andP;  It provides diagnosticandM;and debugging features for the software downloadedandM;to the OSI Express card.andP;  The primary function of the diagnosticandM;program is to provide a means for dynamicallyandM;accessing data structures on the card and then displayingandM;the data in an easily readable format.andP;  The SDP also allowsandM;the user to monitor certain aspects of the card's operationandM;and to gather and report performance related statistics.andM;Some of the features provided include:andM;*  Dynamic access to card-resident data structuresandM;*  Data formatting capabilitiesandM;*  Single-character commandsandM;*  Statistical displaysandM;*  Mnemonic access to global symbolsandM;*  Per-path state information displaysandM;*  Print and log functionsandM;*  Breakpoints, traps, and suspend functionandM;*  Card death displayandM;*  Dumpfile access.andM;The diagnostic program consists of two primary modules:andM;the data access routines and the user interface module.andP;  TheandM;access routines provide the mechanisms to read and writeandM;information between the application and the card or theandM;dumpfile.andP;  The user interface module handles all the interactionsandM;with the user, makes the necessary access routineandM;calls to read or write data, and does the formatting andandM;displaying of information to the terminal screen.andP;  The userandM;interface and the data access routines were developed inandM;a modular fashion with a documented interface betweenandM;the two.andP;  While the library routines were originally intendedandM;for use only by the user interface module, the interface isandM;functions.andM;Data Access RoutinesandM;The data access routines provide the mechanism forandM;reading and writing information between the host applicaandM;-tion and the card or the dumpfile.andP;  The data access routinesandM;consist of three major components: the host-resident libraryandM;routines, the dumpfile access module, and the card-resiandM;-dent process.andP;  The library is a well-defined set of calls thatandM;provide the application interface to the various data accessandM;operations.andP;  The library routines do all the error checkingandM;on the call parameters and then route the request to eitherandM;the card process or the dumpfile access module.andP;  The libraryandM;routines decode any received responses and return theandM;appropriate data and status information back to the hostandM;application program.andP;  The most important service providedandM;by the library routines is providing a transparent interfaceandM;to the data.andP;  The same library calls are used to access bothandM;the dumpfile and the card.andM;The card process is downloaded to the card along withandM;the networking software.andP;  It receives messages from the hostandM;library via an established communication channel and thenandM;performs the requested operation on the card.andP;  Status informationandM;and any data retrieved are returned to the host viaandM;the same communication channel.andP;  For the card process toandM;be able to carry out its duties, it must operate independentlyandM;from the networking software and it must not rely on anyandM;services provided through CONE (common OSI networkingandM;environment).andP;  The process must also be able to interruptandM;the networking operations when necessary, and be able toandM;operate when the networking software has died.andP;  Most ofandM;this independence is achieved by communicating directlyandM;with the backplane handler (on the card) and the driverandM;(from the host).andP;  This interface bypasses most of the standardandM;communication paths used by the networking software.andM;The card process manages all its own data buffers and hasandM;no dependencies on external data structures.andP;  Also, the cardandM;process is designed to operate at a higher interrupt levelandM;than the network protocols.andP;  This allows the diagnosticandM;module to gain control of the card processor when necessary.andM;In some debugging situations it is not always possibleandM;or practical to access the OSI Express card directly.andP;  DuringandM;development, for example, if the card died abnormally theandM;developer might not be able to get to the problem for someandM;time.andP;  Rather than tie up the hardware for an extendedandM;period of time or attempt to try to reproduce the problemandM;at a later time it is often better to save the card image andandM;attempt to diagnose the problem off-line.andP;  The facility existsandM;for dumping the card image to a disk file.andP;  However, mostandM;engineers prefer something other than digging throughandM;stacks of hexadecimal listings.andP;  In fact, the preferred methodandM;is to use the same debugging tool on both the card and theandM;dumpfile.andP;  For this reason, the library routines provide accessandM;to both the card and the dumpfile, the only changeandM;being the parameters that are passed to the call that initiatesandM;the connection.andP;  Once the connection is established, cardandM;and dumpfile operations are identical, with the exceptionandM;that write operations are not allowed to the dumpfile.andP;  WhatandM;is going on is completely transparent to the user sitting atandM;the terminal.andM;User interfaceandM;When developing the user interface it was important toandM;keep in mind some basic concepts.andP;  First, the users of theandM;diagnostic program would be in the process of learningandM;many new debugging tools such as the symbolic debuggersandM;on the HP 9000 Series 300 (cdb) and 800  (xdb) and the HPandM;64000-UX development environment at the same time.andP;  ItandM;was important to keep the interface simple and the numberandM;of special keys to a minimum so as not to make the learningandM;curve too long or steep.andP;  Also, where possible, functions orandM;data input operations should be handled in the same wayandM;as the corresponding operations in the other debuggers.andM;Something as simple as entering numeric informationandM;should not require users to learn two different formats.andM;Second, the development time for providing a useful debuggingandM;tool required that the complexity of the interfaceandM;be kept to a minimum so the functionality would be availableandM;on time.andM;When the diagnostic is initially invoked the user is presentedandM;with a menu listing the major functional areas available,andM;such as resource utilization or data retrieval.andP;  Sub-menusandM;may be displayed detailing the operations availableandM;within a particular functional area depending on the selectionandM;on the main menu.andP;  Once a specific operation has beenandM;any data retrieved from the card and a list of commandsandM;available for that display.andM;The user interface has a two-tiered command structureandM;consisting of global and local commands.andP;  Both global andandM;local commands are typically single keyboard charactersandM;which are acted on as soon as they are typed (Return is notandM;required).andP;  Global commands are active for every displayandM;within the program and can be entered whenever a comandM;-mand is expected as input.andP;  Some examples of global commandsandM;include: help (?), quit (Q), shell escape (!), and mainandM;menu (M).andP;  Local commands are specific to the display withandM;which they are associated and are only available when thatandM;display is current (appearing on the terminal).andP;  The localandM;commands for a particular display are shown at the bottomandM;of the terminal screen.andP;  Local commands perform operationsandM;such as reread statistics, reformat data, and retrieve a globalandM;data structure from the card.andP;  While global commands areandM;unique for the entire program the local commands areandM;unique only within the associated display.andP;  The sameandM;keyboard character may invoke entirely different functionsandM;in different displays.andM;The software diagnostic uses the HP-UX curses screenandM;control package to create displays and handle all interactionsandM;with the terminal.andP;  Curses is designed to use the terminalandM;screen control and display capabilities.andP;  Briefly, cursesandM;uses data structures called windows to collect the data toandM;be displayed.andP;  The application program writes the data toandM;be displayed to the current window and then makes theandM;appropriate curses calls to transfer the window to the terminalandM;screen.andP;  The primary benefit of using curses is that itandM;relieves the application of the overhead of dealing withandM;different terminal types and cursor movements.andP;  It alsoandM;minimizes the amount of information that must be redisplayedandM;on the screen by only transmitting the text informationandM;that has changed from the previous display.andM;Data Access OperationsandM;The data access operations are all functions and commandsandM;for accessing, formatting, and manipulating informationandM;from the card.andP;  As with most debuggers, the abilityandM;to view data is one of the most frequently used.andP;  Data retrievedandM;from the card can be displayed in two forms: rawandM;and cast.andP;  In raw form the data is displayed in columnsandM;of four-byte integers.andP;  The first column is the RAMandM;address of the first byte of data in each row.andP;  The addressandM;and data values are hexadecimal.andP;  The right two screenandM;columns contain the ASCII representation of each byte ofandM;data in the row if it is printable.andP;  If the byte is not a printableandM;character then a period is shown as a placeholder.andP;  The userandM;also has the option to change the data format from hexadecimalandM;to decimal and from four-byte integers to columns ofandM;two-byte words.andP;  The NEXT and PREVIOUS functions can beandM;used to page through memory from the initial display address.andM;The second form of data formatting is the cast function.andM;The data retrieved from the card can be displayed basedandM;on a specified C data type.andP;  When the cast functionandM;is selected the user is prompted for the RAM address fromandM;which to retrieve the information and the name of a dataandM;type, which will define the formatting of the data.andP;  To useandM;the cast function the specified data type must be in theandM;SDU data dictionary and the dictionary must have beenandM;loaded into the user interface module.andP;  The data type isandM;displayed and the information is formatted based on theandM;data type.andP;  Data can be reformatted simply by specifying aandM;different data type.andP;  If the data type exceeds a single screenandM;the user is allowed to page through the displays.andP;  The userandM;can switch between the raw and cast displays without havingandM;to reread the data from the card.andM;Address values can be entered in either numeric orandM;mnemonic forms.andP;  Numeric addresses can be either hexadecimal,andM;decimal, or octal values.andP;  Mnemonic addresses areandM;entered by typing the name of a global variable or procedure.andM;C variables and procedure names must be precededandM;by an underbar (_) while assembly variables and labels mayandM;or may not require an underbar depending on how theyandM;are declared in the code.andP;  The address value is obtained byandM;searching the linker symbol file (.L), which corresponds toandM;the download file on the OSI Express card.andP;  In addition toandM;other information, the symbol file contains global symbolandM;records,&quot; which provide the names of global symbols (variablesandM;and procedures) and their relocated addresses.andP;  TheandM;address stored in the file for the symbol entered is thenandM;used to retrieve the information from the card.andP;  Use of theandM;mnemonic address is recommended whenever possible.andM;Not only does it eliminate the need to look up the addressandM;of the variable in the first place, it ensures that the addressandM;will be correct regardless of the version of the card softwareandM;being accessed.andM;One level of addressing indirection can be accessed byandM;preceding the address values, either numeric or mnemonic,andM;by an asterisk  ').andP;  The address location on the card is thenandM;interpreted as containing the address of the data to be retrieved.andM;In other words, the address specified is really aandM;pointer to the data rather than the data itself.andP;  All addressandM;values, either direct or indirect, are checked to ensure thatandM;they are in the range of accessible addresses on the card.andM;Both read access and write access are allowed to RAMandM;memory, while only read access is permitted to EEPROMandM;addresses.andM;Card Death DisplayandM;Whenever the OSI Express card dies abnormally, eitherandM;from a software exception (address error, divide by zero,andM;etc.) or an internal error (disaster log), or is halted fromandM;the host, a fatal error routine is invoked on the card to saveandM;the state of the card processors and record the error informationandM;at the time the card halted.andP;  The routine also sendsandM;an error indication to the host which reports that the cardandM;has died.andP;  During development and testing these situationsandM;were common.andP;  At such times, the process of gathering theandM;data to determine why the error occurred can be time-consumingandM;and involved.andP;  The type of error and even the sizeandM;of the RAM memory can influence the location of the informationandM;to be read.andP;  Once the error is known a text file mustandM;still be searched to determine the meaning of the error.andM;The card death information display attempts to provideandM;on one screen all the error information necessary to determineandM;where and possibly why the card died.andP;  The diagnosticandM;program gathers the information concerning the card deathandM;from the various memory locations and, after analyzing theandM;data, displays on the screen the values that relate to theandM;type of death that occurred (Fig.andP;  5).andP;  The processor registers,andM;including the stack pointer, the program counter, the statusandM;register, and the data and address registers, are retrievedandM;and displayed in the center of the screen.andP;  When a cardandM;module dies gracefully it stores information in a disasterandM;record.andP;  This information is retrieved, if available, and displayedandM;at the bottom of the screen.andP;  The program alsoandM;evaluates the error and supplies an apparent reason, or bestandM;guess, as to why the card died.andP;  On this screen the userandM;should have enough data to understand why the card diedandM;and be able to locate any additional information.andM;Resource UtilizationandM;The displays available under the resource utilizationandM;selection are intended to provide information on the operationalandM;state of the various modules and resources on theandM;OSI Express card.andP;  For the most part, the displays containandM;various combinations of statistics gathered from the cardandM;that can be monitored to determine such things asandM;throughput, flow control, and memory utilization.andM;There are basically two types of statistics that areandM;maintained; cumulative and actual.andP;  The cumulative statisticsandM;represent values that have accumulated over a timeandM;period.andP;  Examples of cumulative statistics include front-planeandM;packets transmitted, number of global retransmissions,andM;and backplane bytes transferred.andP;  These statistics canandM;be cleared to zero by the user.andP;  Actual statistics reflect theandM;conditions as they currently exist on the card.andP;  Number ofandM;open connections, available buffer manager memory, andandM;scheduler queue depth are examples of actual statistics.andM;Actual statistics cannot be cleared.andM;Trap/Breakpoint/SuspendandM;When attempting to debug problems on the card it isandM;often necessary to stop the processing on the card toandM;examine the current state of the processor or a global variandM;-able before continuing.andP;  The diagnostic program providesandM;three mechanisms for stopping the card: breakpoints, traps,andM;and suspend.andM;The breakpoint feature is similar in implementation toandM;breakpoints in other debuggers.andP;  The user specifies the addressandM;of the instruction on the card where the breakpointandM;should be set.andP;  When that location is reached in the processingandM;stream the card is stopped and a message is sent to theandM;host application, which notifies the user.andP;  The card remainsandM;stopped until the user tells it to continue.andP;  The card thenandM;resumes processing from the instruction at the breakpointandM;location.andM;Traps are basically predefined breakpoints hardcoded inandM;the networking software that can be turned on and off asandM;needed.andP;  The locations of the trap calls are determined byandM;the code developers and can be anywhere in the executableandM;code.andP;  When a trap is encountered a diagnostic procedureandM;on the card is called.andP;  The diagnostic procedure checks theandM;trap type with a global mask to determine whether thisandM;trap is on or off.andP;  The trap type is one of the parametersandM;passed on the trap call and is defined by the code developer.andM;The global mask is configurable from the user interfaceandM;module.andP;  if the trap is off then the call returns and the codeandM;continues without any break.andP;  If the trap is on then the cardandM;is stopped and a message is sent to the host application.andM;Again, the card remains stopped until the user tells it toandM;continue.andP;  Processing resumes from the instruction after theandM;trap call.andM;The suspend operation gives the user the ability to stopandM;the card at any moment in time.andP;  This is a global commandandM;issued from the user interface.andP;  When the request is receivedandM;by the card process a routine is invoked that interrupts theandM;networking protocols and places the card in an idle loop.andM;The card timer manager interrupts are also suppressed byandM;this routine.andP;  The suspend will remain in effect until a resumeandM;command is issued by the user.andP;  The purpose of theandM;suspend function is to give the user the opportunity to takeandM;a quick look around without having data change or moveandM;before it can be examined.andM;SummaryandM;The success of these modules is evidenced by their acceptanceandM;as the tools of choice for much of the debugging,andM;diagnostic, and testing efforts.andP;  The use of these tools significantlyandM;reduced the time needed to isolate many of theandM;defects encountered in the card software.andP;  The statisticalandM;displays provided valuable information on throughput andandM;flow control early enough in the development cycle toandM;allow time to make any necessary adjustments.andM;AcknowledgmentsandM;The following individuals have contributed to the successandM;of these tools through their work on either the designandM;or the coding of certain functions: Gerry Claflin, SteveandM;Dean, John Nivinski, and Chuck Black.andP;  Also, I would especiallyandM;like to mention David Ching, who provided theandM;routines for processing the linker symbol file, and ChweeandM;Kong Quek for his work on the dumpfile access module.andM;ReferencesandM;1.andP;  B.W.andP;  Kernighan and D.M.andP;  Ritchie, The C Programming Longuage,andM;Prentice-Hall, 1978.andM;2.andP;  HP-UX Concepts and Tutorials, Volume 3: Programming Environment,andM;Hewlett-packard Company, 1986.andM;3.andP;  A.V.andP;  Aho and J.D.andP;  Ullman, Principles of Compiler Design,Addison-Wesley,andM;1979.andM;4.andP;  A.T.andP;  Schreiner and H.G.andP;  Friedman, Jr., Introduction to CompilerandM;Construction with UNIX, Prentice-hall, 1985.andM;5.andP;  HP-UX Concepts and Tutorials, Volume 4: Device I/O and UserandM;Interfacing, Hewlett-Packard Company, 1985.andM;6.andP;  File Format Reference for the HP 64000-UX MicroprocessorandM;Development Environment, Hewlett-Packard Company, 1987.andM;@@@081550642 0HPJIja067SPOTandM;The HP OSI Express card offers event logging and tracingandM;to facilitate troubleshooting in multivendor networks.andM;TODAY'S STATE-OF-THE-ART automated factoriesandM;require the seamless interaction of systems and deandM;-vices supplied by a diverse set of vendors.andP;  To manageandM;this complex environment effectively and keep it operatingandM;smoothly, users must be able to resolve problems quickly.andM;The HP OSI Express card incorporates several powerfulandM;new features to aid the troubleshooter.andP;  This article highlightsandM;the support features of the HP OSI Express card andandM;illustrates their use in two troubleshooting scenarios.andM;Architecture OverviewandM;The support architecture of the HP OSI Express card wasandM;an important consideration since the development of OSIandM;protocols was a new area of endeavor for HP as well as forandM;other computer companies.andP;  Numerous communicationandM;problems with other OSI implementations were expected.andM;Therefore, a superior set of diagnostic capabilities wasandM;needed to resolve problems quickly in an I/O card environment.andM;To achieve this functionality it was decided to extendandM;the host's own nodal management facilities to include theandM;HP OSI Express card.andP;  This design provides a single nodalandM;management mechanism for event logging and protocolandM;tracing for both host and card modules and provides theandM;user with several benefits.andP;  The user does not have to beandM;concerned whether a layer, module, or service resides inandM;the host or on the card.andP;  The same set of tools with the sameandM;capabilities can be used to manage all aspects of the product.andM;In addition, the trace and log output from both host andandM;card-based modules are identical in format because theyandM;share a common header and terminology for describing theandM;severity of an error or the type of message being traced.andM;The numbered arrows show the initial flow of controlandM;and information to enable a log class (logging severity level)andM;and then to send log information from a card-based layerandM;to the file system.andP;  Log classes are controlled by the userandM;via the nodal management applications osiconfig and osicontrol.andM;When the user enters a command to enable a particularandM;log class in a particular layer, a request is passed by theandM;nodal management application to the trace/log facility,andM;which validates the request and ensures that various trace/andM;log resources have been allocated.andP;  The request is thenandM;passed to subsystem management services (SMS), whichandM;provides facilities that allow the user to access managementandM;services (parameter manipulation, statistics collection,andM;status, and control) and sends the request to card managementandM;services (CMS).andP;  CMS, which is the card-based counterpartandM;of SMS, provides nodal and network management servicesandM;to both the host-based management applications andandM;the card-based protocol and system modules.andP;  After receivingandM;the request from SMS, CMS forwards the request to theandM;appropriate protocol layer or system module.andM;When an event that must be logged occurs in a card-basedandM;protocol layer, the event is passed from the protocol stackandM;to CMS which communicates through the kernel with theandM;log daemon.andP;  The log daemon receives the event (log) messagesandM;from the OSI Express card, obtains the system timeandM;(timestamps the message) and formats a log call to the hostandM;trace/log facility.andP;  Unformatted log messages are then writtenandM;to the file system.andP;  When the user reads the log file, theandM;trace/log formatter osidump is used.andP;  Osidump writes formattedandM;log entries to the log file or terminal.andM;Event LoggingandM;Logging is used to record abnormal or unusual networkingandM;events such as the receipt of an inbound packet withandM;invalid protocol information (remote protocol error) or aandM;remote system's refusal to accept a connect request.andP;  ThisandM;is different from tracing.andP;  Tracing is used to record all informationandM;of a particular type or types from one or more layersandM;or modules.andM;Log HeadersandM;Log (and trace) messages have two parts: the header partandM;and the data part.andP;  The header consists of the first eightandM;lines.andP;  It includes the timestamp and other identifiers.andM;The contents of the header are very important becauseandM;the data in the header usually determines the formattingandM;capabilities of the trace/log formatter.andP;  The data portionandM;of the message that follows the header contains the descriptionandM;of the event (error message text).andM;One of the more important fields in the header is the logandM;class.andP;  This is the severity of the event being logged.andP;  WhenandM;logging is enabled the severity can be selected by the user.andM;The user can choose to ignore event messages that are byandM;nature informational, but when problems occur the userandM;can modify the log class to obtain informational messages.andM;Log messages have four classes of severity: disaster, error,andM;warning, and informational.andP;  Disaster class messages areandM;logged when a condition occurs that could jeopardize theandM;integrity of the system or network.andP;  Discovering that anotherandM;system on the network is using the identical NSAP addressandM;is one example of a disaster class event.andP;  Once a disasterandM;event occurs, the event is logged and the OSI Express cardandM;is taken off-line.andP;  The next lower event classification is errorandM;class.andP;  Errors are events that cause a user application to failandM;or take extra steps to recover.andP;  This is the default log classandM;for most of the product's layers or modules.andP;  The definitionandM;of an error class event put the additional burden on theandM;OSI Express card software developers of understanding theandM;end result of an event.andP;  It could only be classified as anandM;error once it was understood that it would adversely impactandM;a user application.andP;  The expiration of one connection'sandM;transport inactivity timer is an example of an error classandM;event.andP;  The error class designation is not as significant forandM;what is included as an error as it is for what is excludedandM;as an error.andP;  The error class definition prevents events thatandM;are interesting but not a problem (from the applicationandM;point of view) from being logged.andP;  This not only saves diskandM;space but frees the user from having to consider eventsandM;that do not affect applications.andP;  Warning and informationalandM;class events are the next-lower-severity log classes.andP;  WarningandM;events such as &quot;Destination NSAP Unreachable,&quot;andM;which impacts the network layer, or informational eventsandM;such as receipt of a duplicate connection request, whichandM;impacts the transport layer, have no impact on user applicationsandM;except for time loss.andP;  These events are probablyandM;most useful for performance analysis.andM;Two fields in the header provide connection information:andM;the connection identifier (CID) and the path identifier (pathandM;ID).andP;  The CID is used by host software to reference a connectionandM;and is returned to the user.andP;  The path ID identifies aandM;specific communication path on the OSI Express card andandM;thus serves the same purpose in the card environment asandM;the CID does in the host environment.andP;  From a troubleshootingandM;perspective the path ID is very useful when problemsandM;occur on inbound connection requests that fail beforeandM;reaching the host.andP;  In this situation, a CID will not existandM;since the request does not reach connection managementandM;and hence a CID is not issued.andM;Another field in the header and one of the most significantandM;contributions to the supportability of this product isandM;the log instance.andP;  The log instance is an identifier thatandM;threads log messages together.andP;  When a module first detectsandM;an error, it obtains a new unique log instance identifierandM;and logs the event.andP;  The log instance is then passed withandM;the error to the calling entity.andP;  If the calling entity also logsandM;an error as a result of processing the error it receives, itandM;logs the error as well as the log instance passed to it.andP;  TheandM;calling entity then returns the log instance to its caller.andP;  InandM;this manner, the log instance is propagated all the way upandM;to the user application.andP;  Log events with the same log instanceandM;are related.andP;  The earliest event with the same logandM;instance is the root of the problem.andP;  Without a log instanceandM;mechanism, a user might think that several errors had occurredandM;when in fact only one had occurred.andP;  Once the errorandM;is returned to the user application the log instance is availableandM;via a special function call to the service interface.andM;Thus, the log instance provides an audit trail from theandM;module that first detects an error all the way back to theandM;user application.andM;Other fields in the header of interest to users include theandM;user identifier (UID), and the process identifier (PID).andP;  TheandM;UID is the HP-UX user identifier of the user that createdandM;the connection.andP;  The PID is the identifier of the process thatandM;created the connection.andM;Error MessagesandM;Special attention was focused on the content of errorandM;messages.andP;  All error messages include the problem category,andM;the cause of the problem, and the corrective action recommendedandM;to resolve the problem.andP;  At all points in the codeandM;where an error might be logged, the protocol developer hadandM;to resolve the problem and not merely report it.andP;  It was alsoandM;generally agreed to return any helpful information that wasandM;available to the user that would aid problem resolution.andM;The product troubleshooting guide is tightly coupled toandM;the error messages.andP;  Card_04 is a troubleshootingandM;procedure designed to lead the user through theandM;process of resolving a remote protocol error.andP;  TheandM;technique of referring to a specific troubleshootingandM;procedure in the troubleshooting manual is used whenandM;the resolution procedure is longer than what could easilyandM;be described in a log message.andM;In addition, since usability was of great concern, weandM;wanted to avoid terse log messages that required interpretingandM;to understand what transpired.andP;  Therefore, error messagesandM;were reviewed and reworked to ensure that the textandM;was clear.andP;  As a result of the efforts to make error messagesandM;more usable, an error messages manual was not requiredandM;as part of the product's documentation.andM;CMS informational LogandM;Another feature designed to aid troubleshooting is theandM;CMS informational log message.andP;  Recall that CMS is usedandM;by the protocol stack and system modules to log eventandM;messages and trace protocol and system module activity.andM;When CMS receives a request to log a message it checksandM;to see if it has logged a message on that path before.andP;  If itandM;has, it just performs the log or trace task requested by theandM;calling software module.andP;  If it has not logged a message onandM;that path before, it logs a CMS informational message andandM;then logs the message requested by the calling softwareandM;module.andP;  The informational message logged by CMS includesandM;as much of both the local and remote applications'andM;presentation addresses as is known.andP;  An application's presentationandM;address is also often referred to as its PST-NandM;selectors.andP;  This information is logged in the data portion ofandM;the log message and is especially useful for remotely initiatedandM;connections as is typical on server nodes.andP;  Now,andM;when an error occurs, information is available that providesandM;the presentation addresses of the affected applications.andM;A Troubleshooting ScenarioandM;Two sample scenarios will illustrate the use of theandM;troubleshooting features described above.andP;  Assume that user applicationandM;1  (Ua1), an HP MMS (Manufacturing Message Service)andM;client, on node A wants to communicate with user applicationandM;2 (UA2) on node B. Furthermore, assume that UA1'sandM;connect request to UA2 fails because UA2 has a differentandM;presentation address from the one UA1 is trying to communicateandM;with.andP;  This can occur when the same presentationandM;address is maintained in two separate locations.andP;  For example,andM;a shop-floor-device OSI implementation may not provideandM;a directory service user agent for directory access.andM;Instead, it may locally manage presentation addresses,andM;thereby providing an opportunity for address inconsistency.andM;When the connect request is received by the transportandM;layer on node B, the transport layer finds that theandM;destination TSAP (transport service access point) is not inandM;its table and rejects the request.andP;  The transport layer onandM;node B rejects the connect request by sending a disconnectandM;request to the transport layer on node A. The transportandM;layer on node A logs this event.andP;  When it logs the event, itandM;gets a unique log instance value.andP;  The transport layer onandM;node A returns an error along with the log instance to theandM;session layer.andP;  If any other module in the propagation pathandM;logs additional information, the log instance will be identicalandM;to the one originally logged by the transport layer.andP;  AsandM;explained above, the log instance is a mechanism thatandM;threads together all errors related to a specific error.andM;Error information returned to UA1 from the service interfaceandM;includes the log instance.andP;  The user can then use theandM;log instance as a key to query the log file for the underlyingandM;cause of the problem.andP;  All necessary data required to resolveandM;the problem is logged along with the error message.andP;  In thisandM;example, the transport layer on node A will log the disconnectandM;request TPDU (transport protocol data unit) in theandM;data portion of the message.andP;  In this way, fault isolation andandM;correction are facilitated by the use of the log instance, aandM;detailed error message, and a comprehensive troubleshootingandM;procedure.andM;Another ScenarioandM;In this scenario, assume that an FTAM (File Transfer AccessandM;and Management) initiator application on a remote systemandM;receives an abort indication while transferring a file to theandM;local HP system.andP;  Also, assume that the remote system hasandM;limited troubleshooting capability.andP;  Thus, we need to isolateandM;and resolve the problem from the responder side.andP;  AssumeandM;that the cause of the problem is that the remote system hasandM;sent an invalid session PDU (protocol data unit) and theandM;local session entity aborted the connection.andM;When the connection was aborted on the responder side,andM;a connection information message was logged by CMS withandM;the complete presentation address of both the initiator andandM;the responder along with the path identifier of the abortedandM;connection.andP;  To resolve the problem, the user searches theandM;log file for the CMS message with the appropriate initiatorandM;and responder presentation addresses.andP;  Locating this logandM;message provides the user with the path ID, which can beandM;used as a key to query the log file for errors that occurredandM;on the aborted connection.andP;  The abort event message thatandM;the user obtains informs the user that the type of problemandM;encountered was a remote protocol error.andP;  TheandM;event message also specifies the exact nature of the problem:andM;the received PDU had an incorrect value for the sessionandM;indicator.andP;  This type of problem is typically caused by aandM;defect in the remote vendor's code and can be resolvedandM;only by a code change in the remote vendor's implementation.andM;Therefore, the corrective action in the error messageandM;tells the user to follow a procedure that recreates the problemandM;with tracing turned on.andP;  The additional trace informationandM;will help the remote system's vendor understand theandM;context in which the problem occured so that an approandM;-priate fix can be made.andM;TracingandM;Tracing is used to record all activity of a specific kind.andM;It provides the contextual information that may be necessaryandM;to determine the cause or the activities that led up toandM;a networking event.andP;  Both normal and abnormal events areandM;recorded and, in fact, the trace utility cannot distinguishandM;between the two.andP;  Tracing is a very useful tool for isolatingandM;remote protocol errors  (interoperability problems) or internalandM;defects.andM;Typically, a troubleshooter uses network tracing as a lastandM;resort to identify a problem.andP;  This is because configurationandM;problems and user application problems are much moreandM;common, and because the use of trace tools and the analysisandM;of the output require significant expertise.andP;  A major problem,andM;therefore, is knowing when to use tracing.andP;  The logandM;message in troubleshooting scenario 2 is typical of remoteandM;protocol error log messages generated by protocol modules.andM;The message is intended to define the problem clearly andandM;guide the troubleshooter to a procedure to isolate it.andM;The user can enable several types of tracing for eachandM;subsystem.andP;  The most commonly used trace kinds are listedandM;below.andM;* Header Inbound.andP;  Traces protocol headers received fromandM;the next-lower protocol layer before decoding is done.andM;* Header Outbound.andP;  Traces protocol headers after encodingandM;is complete before they are sent to the next-lowerandM;protocol layer.andM;* PDU Inbound.andP;  Traces the whole protocol data unit as itandM;is received.andM;* PDU Outbound.andP;  Traces the whole protocol data unit asandM;it is being sent.andM;*State Trace.andP;  Traces protocol state information.andM;A fundamental problem with tracing in general is thatandM;the person analyzing the trace file must recognize an abnormalandM;event and so must have a fairly intimate knowledgeandM;of the protocol.andP;  The logging trace is a special trace typeandM;that writes a copy of the log message to the trace file.andP;  ForandM;instance, when tracing is enabled at the transport layer andandM;this layer logs a message, that message is written to the logandM;file (this is normal) and also to the trace file.andP;  The loggingandM;trace message acts as a marker within the trace file to helpandM;the person analyzing it locate the area of interest.andM;AcknowledgmentsandM;We are grateful to Mike Wenzel for his patience and forandM;helping us evaluate various technical alternatives.andP;  RichandM;Rolph was instrumental in the development of usable errorandM;messages and troubleshooting procedures.andP;  We would likeandM;to thank the entire OSI Express team for suggesting andandM;implementing supportability and usability features.andM;@@@081550669 0HPJIja072IATFandM;Special test tools and a multidimensional integrationandM;process enabled engineers to develop, test, and debug theandM;firmware for the OSI Express card in two differentandM;environments.andP;  In one environment an emulation of the OSIandM;Express card was used and in another the real hardwareandM;was used.andM;THE OSI EXPRESS PROJECT consisted of many independentandM;project teams (made up of one or more enandM;-gineers) working on specific portions of the protocolandM;modules or support code.andP;  Each team needed the ability toandM;test and develop code independent of others.andP;  However,andM;periodically they needed to have a set of stable and testedandM;code from other teams to enable them to test their ownandM;code.andP;  Since each engineer was involved in testing, testandM;environments were designed to maximize their efforts.andP;  OneandM;environment consisted of an emulation of the OSI ExpressandM;card on the development machines and another test environmentandM;consisted of a real OSI Express card connected toandM;a target machine.andP;  Both the target and the developmentandM;machines were HP 9000 Series 800 computers running theandM;HP-UX operating system.andP;  Because of the number of engineersandM;working on the project, multiple development andandM;test machines were configured as a network.andM;Test ArchitectureandM;Each protocol module was first tested in isolation beforeandM;the module was integrated with the rest of the modules ofandM;the OSI Express stack.andP;  The CONE (common OSI networkingandM;environment) protocol module interface facilitates thisandM;module isolation since a stack can be built that does notandM;contain all seven protocol modules.andP;  Protocol modules doandM;not call each other directly to pass packets but insteadandM;make calls to CONE.andP;  A data structure called a path reportandM;is used to specify the modules configured into a stack.andM;Protocol modules not specified in a path report will notandM;be called by CONE and do not need to be in the stack.andM;However, even with this modular design, several test modulesandM;are needed to test the stack fully.andM;This architecture was used on the host (running in userandM;space) to test and debug protocol modules before the hardware wasandM;ready.andP;  When the hardware was ready, this same architectureandM;was used on the target machines to test the protocolandM;modules in the real environment.andM;Exception GeneratorandM;The exception generator is a test module that is configuredandM;in the stack below the module being tested.andP;  PacketsandM;moving inbound to the protocol module under test andandM;moving outbound from the module are operated on by theandM;exception generator.andP;  Packets not operated on by the exceptionandM;generator are simply passed through to the next layer.andM;The exception generator can intercept, modify, generate,andM;or discard packets as they are moving up or down the stack.andM;Packets intercepted are placed in the exception generatorandM;packet queue.andP;  Up to ten packets can be saved in the queueandM;at one time.andP;  Packets stored in this queue can be modifiedandM;and then sent up or down the protocol stack.andP;  In this way,andM;PDUS that occur rarely can be constructed.andP;  Also, errors inandM;transmission can be simulated by corrupting a packet inandM;the queue and then sending it.andM;Scenario Interpreter AgentandM;The scenario interpreter agent performs functions similarandM;to the exception generator.andP;  Whereas the exceptionandM;generator is configured below the module under test, theandM;scenario interpreter agent is positioned above the moduleandM;under test.andP;  The scenario interpreter agent operates on inboundandM;packets coming from the module under test andandM;outbound packets going to the module under test.andP;  A packetandM;can be intercepted as it moves down the stack and placedandM;in the packet queue of the scenario interpreter agent.andP;  AandM;saved packet is sent to the module under test by releasingandM;it from the save queue of the scenario interpreter agent.andM;Bounce-back ModuleandM;The bounce-back module sits at the bottom of the stack,andM;and as its name implies, it enables packets heading downandM;the stack to be sent (bounced) back up the stack.andP;  Normally,andM;a protocol stack runs in a two-node configuration consistingandM;of a sender and a receiver with the two nodes connectedandM;by a communication medium such as coax cable.andP;  WhenandM;testing of the protocol stack first started, all testing wasandM;done in a single-node configuration.andP;  Packets were sentandM;down the stack, turned around by the bounce-back testandM;module, and then sent back up the stack.andP;  To make oneandM;stack act as both the incoming and the outgoing protocolandM;stacks, the bounce-back module maintains a set of tables.andM;The tables contain the proper inbound CONE call for eachandM;outgoing CONE call.andM;The bounce-back module makes different calls to CONEandM;depending on which layer is configured above it in theandM;stack.andP;  Thus, a separate table is maintained in the bounceandM;back module for each protocol layer that may be above it.andM;For example, a stack can be configured for testing thatandM;consists only of the session layer above the bounce-backandM;module.andP;  The session layer is a connection-oriented protocolandM;layer and receives different incoming CONE callsandM;than a connectionless layer such as the network layer.andP;  InandM;this example, a packet would flow outbound from the sessionandM;layer and be received by the bounce-back module.andM;The bounce-back module would look in the session tableandM;to find the corresponding incoming call for the sessionandM;layer.andP;  The packet would be copied and sent back up to theandM;session layer, which would accept the incoming call as ifandM;it were part of the receiving node in a two-node test.andM;Error HandlingandM;Every CONE call returns an error value to the protocolandM;module making the call.andP;  Normally, the exception generatorandM;and the scenario interpreter agent would simply propagateandM;the error value returned to them to the next layer.andP;  However,andM;the error value returned can be changed by the test modules.andM;In this way error paths can be executed in the protocolandM;modules for unusual error return values from CONE calls.andM;Since the bounce-back module is at the bottom of the stackandM;and cannot propagate error return values, tables were usedandM;as explained above for the return value of each CONE call.andM;Scenario interpreterandM;To generate packets to send down the stack, the scenarioandM;interpreter is used.andP;  Scenarios are test specifications thatandM;tell the scenario interpreter what packets to send and whatandM;packets to expect to receive.andP;  Each scenario has two sides,andM;which can be thought of as a sender and a receiver.andP;  PacketsandM;are defined using packet definition commands.andP;  These constructedandM;packets are sent down the stack using packet send/andM;receive commands.andP;  A parameter tells the scenario interpreterandM;whether to send or expect to receive a packet.andP;  When aandM;packet is received it is compared to the packet specifiedandM;in the scenario.andP;  If the packets do not match, an error isandM;reported.andP;  Repeating sequences of data are generated byandM;macros in the scenario interpreter.andP;  For example, a repeatingandM;sequence of 5000 bytes is generated with the simple macroandM;!5000.andP;  The value of each byte is one greater than the previousandM;byte, modulo 256.andM;The scenario interpreter also controls the exceptionandM;generator, bounce-back module, and scenario interpreterandM;agent test modules.andP;  Commands to these test modules areandM;sent down the protocol stack in special command packets.andM;Command packets are created in the same fashion as dataandM;packets.andP;  A parameter indicates whether the packet is a dataandM;packet or a command packet.andP;  The command packets areandM;absorbed by the test module they are intended for.andP;  A testandM;module can also send a command packet to the scenarioandM;interpreter.andP;  For example, the scenario interpreter can sendandM;a command packet to the exception generator telling it toandM;signal the scenario interpreter when a certain number ofandM;outbound packets have passed through the exceptionandM;generator.andP;  After sending the packet, the scenario interpreterandM;waits for a response.andP;  When the exception generator determinesandM;that the specified number of packets have passedandM;through, it sends a command packet to the scenario interpreterandM;telling it that the specified number of packetsandM;were sent.andP;  After the scenario interpreter receives the expectedandM;response it can then proceed.andP;  The scenario interpreterandM;can also wait for inbound packets to pass through a testandM;module.andM;This interaction between the scenario interpreter and theandM;test modules is used to test the many states of a protocolandM;layer.andP;  One example is the session layer.andP;  Several specialandM;packets that the session layer sends to its peer on anotherandM;machine are preceded by a prepare packet.andP;  The two packetsandM;are sent one after the other (prepare packet followed by aandM;special packet).andP;  However, some states in the session protocolandM;state machine are only entered when a data packetandM;is sent after the prepare packet is received but before theandM;special packet is received (see Fig.andP;  3).andP;  To test this case, aandM;prepare and special packet combination is sent down theandM;stack.andP;  The special packet is caught and saved by the exceptionandM;generator.andP;  On the receiving side the scenario interpreterandM;waits to receive the prepare packet.andP;  After receiving theandM;prepare packet, the scenario interpreter sends a data packetandM;and the receiving side enters the desired state.andP;  Finally, theandM;special packet previously captured by the exceptionandM;generator is released.andP;  Without this kind of control, hittingandM;the desired state on the receiving side would only resultandM;as a matter of chance.andM;Another example of packet timing involves the transportandM;layer.andP;  The transport layer receives acknowledgments fromandM;its peer on another node for the packets it sends.andP;  The timingandM;of these acknowledgments is not deterministic.andP;  Testing allandM;the transport protocol states requires sending certain packetsandM;after an acknowledgment is received.andP;  To send a packetandM;after the transport layer receives an acknowledgment requiresandM;the scenario interpreter to wait for the exceptionandM;generator to signal that the acknowledgment packet hasandM;arrived.andM;The scenario interpreter interfaces to the stack via theandM;test harness.andP;  The test harness operates in the two differentandM;environments.andP;  In the environment where the stack is actuallyandM;running on the OSI Express card, the test harness usesandM;a tool called UL-IPC (upper-layer interprocess communication)andM;to communicate with the card.andP;  In the user space environmentandM;on the development machine, the test harnessandM;uses shared buffers (HP-UX IPC) to communicate with theandM;protocol stack.andM;Integration ProcessandM;System integration in its simplest form is the process ofandM;creating a set of deliverables (e.g., executable product code,andM;test code, etc.) from some source code.andP;  For the OSI ExpressandM;card the integration process was driven by project goals,andM;project size, and environment.andM;Goals and ResultsandM;The integration process for the OSI Express card wasandM;designed with follow-on products in mind.andP;  CONEandM;exemplifies how this works.andP;  CONE allows the protocolandM;modules to be combined in different ways to create newandM;protocol stacks.andP;  The integration process also needed theandM;ability to produce additional products without modificationandM;to the build process.andP;  Like CONE, this involved combiningandM;existing code in new ways to produce additional products.andM;The whole problem can be thought of as multidimensional,andM;in that the integration process for the OSI ExpressandM;card needed to run in a multiple-machine environment,andM;where there were multiple products, each product havingandM;multiple versions, each version's code subject to compilationandM;in multiple ways.andM;The challenge was to create a process that would runandM;effectively in a network environment, supply timely andandM;accurate integration services, and be flexible enough toandM;produce all the targeted outputs required.andP;  Other goals forandM;the integration process included quick response to changesandM;by developers, sufficient tracking to create a history of theandM;events that occurred during any given integration, and proandM;-duction of metrics for managing the project.andM;Although the integration process was modified overandM;the course of the project, what eventually developed wasandM;a set of structures and concepts that make integration inandM;this multidimensional environment possible.andP;  A successfulandM;integration for a given version of a product produced aandM;download file that was able to run on the card, an emulationandM;testing environment to run on development machines, andandM;host-based tools to run on the host machine housing theandM;card.andP;  The test environments were similar in that they usedandM;the same set of source code to build from.andP;  They were differentandM;in the deliverables that came out of the environmentandM;and the compilers required to produce them.andP;  The deliverablesandM;for each of these environments was built separatelyandM;in its own integration directory.andP;  These integration directoriesandM;were built in a standard way so that they had theandM;same look to the build processes regardless of the type ofandM;deliverables being built.andP;  Standardization of integration directoriesandM;made it easy to support multiple products, versions,andM;and types of compiles.andP;  Having an integration directoryandM;with a standard structure residing in a known directory,andM;it was easy to build tools that performed their functionsandM;simply by being passed only the name of the integrationandM;directory.andP;  The flexibility to perform different types ofandM;integrations within the integration directory came from theandM;control files (inputs to HP-UX scripts) contained withinandM;each integration directory.andP;  This information included whatandM;source to use, what to build, and compiler options.andP;  TheandM;integration scripts could then use these files to determineandM;exactly what needed to be done for a particular integrationandM;space.andM;The ProcessandM;To get a better understanding of how the integration processandM;functions, let's see what happens when a a new versionandM;of a source code module is added to the system.andP;  Fig.andP;  5andM;shows the data flows between some of the componentsandM;involved in the integration process.andP;  Assume that a developerandM;would like to make a bug fix to an existing integration.andM;The first step would be to check out the sourceandM;code using the HP-UX revision control system (RCS) andandM;put it into a directory on the development system.andP;  TheandM;specific version is identified by an RCS tag.andP;  The RCS tagandM;associates a name with a revision number, so in this caseandM;the developer would check out the source code using a tagandM;that is associated with the integration version in which theandM;bug is being fixed.andP;  The developer would then make theandM;changes necessary to the source, compile it, and test itandM;using a standard test suite that uses code from the integrationandM;directory associated with the change.andP;  After the changeandM;has passed testing in the emulation space it can be checkedandM;back into the common source directories.andP;  At this time theandM;new versions are tagged to indicate that they are the latestandM;tested versions and are ready to be integrated.andP;  This tagandM;serves as a communication vehicle to tell the integrationandM;process that a new version of some module needs to beandM;brought into a specific set of integration directories.andM;Within each integration directory, a source map containsandM;the name, version, and location of each piece of sourceandM;code that is needed for a specific integration.andP;  The locationandM;serves a dual role in that it is the subdirectory path withinandM;the source directory of where to get the source code andandM;it is the subdirectory path of where the code belongs withinandM;the integration directory.andP;  An updated version of this mapandM;can be generated by finding out which version of a fileandM;needs to be used.andP;  To do this a process is run that selectsandM;a version of the code to use based on one or more tags.andP;  InandM;this case the tag that the developer put on the code wouldandM;be used.andP;  When the module that was updated is looked at,andM;the process would discover that a new version of the fileandM;is now needed and a new source map would be created toandM;reflect these changes.andP;  The next step would be to place theandM;correct version of the source code into the appropriate directoryandM;within the integration directory.andP;  This process isandM;accomplished by using the source map previously generatedandM;to direct RCS as to what version to check out andandM;where to put it.andP;  Other checking is done at this point toandM;make sure the source code residing in a directory is actuallyandM;the version specified by the source map.andM;Once valid source code has been placed in an integrationandM;directory it is compiled or assembled as required to createandM;relocatable object files, which are then linked into a library.andM;The compiler to use is determined by parsing the integrationandM;directory name.andP;  Based on a subfield within the name,andM;one of three compiles is chosen: Express card downloads,andM;host-based debugging tools, or card emulations.andP;  Each ofandM;these types of integration requires that a different compilerandM;be used.andP;  The scripts that perform this process verify thatandM;the compiler or assembler needed is available on theandM;machine that they are being run from.andP;  The compiler orandM;assembler options needed are collected from three locations.andM;N  Options that are specific to the compiler being used areandM;contained in the script that calls the compiler.andM;2  Options that are specific to a library being built comeandM;from a control file that describes the name of the libraryandM;to build, where to build it, where the source can beandM;found, and what compiler options are needed.andM;2 Options that apply to all compiles within an integrationandM;directory come from a global flags file.andM;These three sets of options are combined and passed toandM;the compiler.andP;  Note that since the global flags file and theandM;file that describes how to build libraries are both containedandM;in the specified integration directory, they are unique to aandM;particular integration.andM;After all the libraries are built other types of targets canandM;be built.andP;  These could be programs or downloads dependingandM;on the type of integration directory.andP;  Again there are controlandM;files that specify what target outputs to build, where theandM;inputs can be found, the tool that needs to be called, andandM;where to store the result.andP;  If the above steps have all runandM;successfully then the integration directory is again up toandM;date and ready for use by the rest of the team.andM;The mechanism used to deliver an integration to developersandM;is network mounting.andP;  Mounting allows a given machineandM;to have access to another machine's files as if they wereandM;stored locally.andP;  This method avoids the problem of developersandM;working with out-of-date copies of an integration, andandM;provides immediate availability of an updated integrationandM;to all developers.andM;Data LoggingandM;Since there is a standard set of scripts that provide integrationandM;build services, inclusion of consistent logging andandM;error handling was straightforward.andP;  The scripts log informationandM;to four different log files.andM;Error Log.andP;  The most detailed log contains the warning messagesandM;and compile errors generated from calling compilersandM;and other tools needed to produce the target outputs.andP;  ThisandM;file also contains separators indicating what was built andandM;whether or not the process was successful.andM;Process Log.andP;  The process log is a process summary indicatingandM;whether a program or library was built successfully.andM;The log file and the error log file are useful for identifyingandM;details about process failures or simple compile errors.andM;Event Log.andP;  This file is an event history of the actions uponandM;every module involved in a compile.andP;  Every time a moduleandM;is checked out, compiled, or archived into a library, a recordandM;is written to the event log with the time and date, theandM;module name, the version number, what was done (compiled,andM;archived), and if it was successful.andP;  This file is establishedandM;when an integration process is started and is neverandM;purged until the the integration directory is removed.andP;  TheandM;event log provides a Useful audit trail to track down thingsandM;like when a given mod ale changed, what else might haveandM;changed at the same time, or whether a particular fix wasandM;made.andM;Process Management Log.andP;  This logging file is used to manageandM;the overall integration process.andP;  Since there are generallyandM;over ten integration directories active at any given time,andM;looking at logging files  within each directory to determineandM;what needs to be done is time-consuming and provides noandM;overview of how the integration process is working.andP;  AnyandM;integration build run on any machine in the network logsandM;to this file to indicate if a major integration process wasandM;successful.andP;  Information in each record includes the startandM;and stop time, the process run, and the name of the integrationandM;directory that  was processed.andM;AcknowledgmentsandM;Tim McGowen produced the early version of the OSIandM;Express card integration tools from which the current processandM;evolved.andP;  Jeff Ferreira-Pro was instrumental in settingandM;the long range direction of the integration process and theandM;use of RCS, and Kevin Porter and Mike McKinnon produced,andM;tuned, and managed the integration process.andP;  Also contributingandM;to the success of the test tools through their workandM;on designing, coding, arid enhancing the tools were: LynnandM;Vaughan, Meryem Primmer, and Jon Saunders.andM;@@@081550685 0HPJIja080HSLSandM;This analyzer measures the important characteristics ofandM;high-capacity lightwave systems and their components,andM;including single-frequency or distributed feedbackandM;semiconductor lasers and broadband pin photodetectors.andM;THE LOW PROPAGATION LOSS and extremelyandM;broad bandwidth of single-mode optical fiber haveandM;contributed to the emergence of high-capacity digitalandM;transmission systems and analog-modulated microwave frequencyandM;systems.andP;  New lightwave components have beenandM;developed to support these high-speed systems.andP;  Most notableandM;among these components are single-frequency or distributedandM;feedback semiconductor lasers and broadband pinandM;photodetectors.andM;The HP 71400A Lightwave Signal Analyzer has beenandM;designed to measure the important characteristics of theseandM;lightwave components and systems, such as signal strengthandM;and distortion, modulation depth and bandwidth, intensityandM;noise, and susceptibility to reflected light.andP;  When the lightwaveandM;signal analyzer is used in conjunction with the HPandM;11980A Fiber Optic InterferometerandM;the linewidth, chirp, and frequency modulation characteristicsandM;of single-frequency lasers can be measured.andM;System DescriptionandM;The HP 71400A Lightwave Signal Analyzer,  isandM;part of the HP 70000 Modular Measurement System, whichandM;provides RF, microwave, and now lightwave measurementandM;capability.andP;  The HP 70000 is an expandable system and canandM;be upgraded as requirements grow and new modules becomeandM;available.andP;  For example, the HP 71400A can measureandM;lightwave modulation up to 22 Ghz.andP;  However, substitutionandM;of a 2.9-Ghz RF front-end module makes the system an HPandM;71401A, which for certain applications may be a more cost-effectiveandM;solution.andP;  In addition to being lightwave signalandM;analyzers, the HP 71400A and HP 71401A also function asandM;microwave and RF spectrum analyzers.andM;The key module in the system is the HP 70810AandM;Lightwave Receiver.andP;  Light from the input fiber is collimatedandM;by a lens and focused onto a high-speed pin photodetector.andM;The optical attenuator in the collimated beam preventsandM;overload of the front end.andP;  The photodetector convertsandM;photons (optical power) to electrons (photocurrent).andP;  TheandM;time varying component of this photocurrent, which representsandM;the demodulated signal, is fed through the preamplifierandM;to the input of the microwave spectrum analyzer.andP;  TheandM;dc portion of the photocurrent is fed to a power meterandM;circuit.andP;  Thus the same detector is used to measure bothandM;the average power and the modulated power.andM;The lightwave signal analyzer is often confused with anandM;optical spectrum analyzer (also called a spectrometer).andP;  AlthoughandM;both instruments have frequency-domain displays,andM;the information the provide is quite different.andP;  The opticalandM;spectrum analyzer shows the spectral distribution of averageandM;optical power and is useful for observing the modes ofandM;multimode lasers or the sidelobe rejection of single-frequencyandM;lasers.andP;  Its measurement resolution is typically aboutandM;0.1 nm or approximately 18 Ghz at a wavelength of 1300andM;nm.andP;  The lightwave signal analyzer displays the total averageandM;power and the modulation spectrum, but provides noandM;information about the wavelength of the optical signal.andM;Lightwave Receiver DesignandM;Four major subassemblies make up the lightwave receiverandM;module.andP;  They are the optoblock, the optical microcircuit,andM;the average power circuitry, and the optical attenuatorandM;control circuitry.andP;  The optical and high-frequencyandM;RF circuits are located close to the front-panel connectors.andM;The optoblock is essentially an optical-mechanical assemblyandM;that serves two functions.andP;  It collimates the light atandM;the input and refocuses it onto the detector, and along theandM;way it allows for attenuation of the light.andP;  The input to theandM;optoblock uses the fiber optic connector adapter systemandM;developed by Hp's Boblingen Instruments Division.andP;  TheandM;adapter system is based on the precision Diamonds, HMSandM;-10/HP fiber optic connector.1 This adapter design allowsandM;easy access to the ferrule for cleaning, provides a physical,andM;low-return-loss contact to the input fiber, and allows matingandM;to any of five different connector systems: HMS-10/HP,andM;FC/PC, ST, biconic, and DIN.andP;  Internally, the fiber butts upandM;against a piece of glass on the backside of the connector.andM;Index matching fluid at this interface and an antireflectionandM;coating on the glass-to-air surface help maintain the connector'sandM;good input return loss.andM;Exiting the input connector, the light passes into air.andP;  TheandM;diverging beam is collimated into an expanded parallelandM;beam, which then passes through a continuously variableandM;0-to-30-db circular filter.andP;  The filter is coated with a metallicandM;neutral density layer which reduces the wavelength dependenceandM;of the optical attenuation.andP;  The filter is angled to theandM;optical axis to prevent reflection back to the optical connector.andM;The positioning of the filter with the drive motor, opticalandM;encoder, and drive electronics will be described later.andM;A mirror positioned at a 45-degree angle to the opticalandM;path directs the light to the output lens, which focuses itandM;onto the detector.andP;  The mirror is partially transmissive,andM;which allows the light to be aligned to the detector byandM;viewing the reflected light from the illuminated detectorandM;with a microscope objective.andM;Optical MicrocircuitandM;The optical microcircuit containing the pin photodiodeandM;and microwave preamplifier is mated to the optoblock.andP;  TheandM;pin detector works by converting received optical powerandM;into an electrical current.andP;  Light at wavelengths betweenandM;1200 and 1600 nm enters through the antireflection-coatedandM;top surface, and passes through the transparent InP p layer.andM;Electron/hole pairs are created when the photons are absorbedandM;in the InGaAs i region.andP;  Reverse bias is applied acrossandM;the device, sweeping the electrons out through the bottomandM;n-type InP substrate, while the holes are collected by theandM;p-type top contact.andP;  The active area is only 25 [micro-m]andM;in diameter, which keeps the device capacitance low.andP;  This,andM;along with the short transit time across the i layer,andM;contributes to a 20-Ghz device bandwidth.andM;Electrical photocurrent from the photodiode's anode isandM;terminated in a preamplifier that has an input impedanceandM;of 50 Ohms and a bandwidth of 100 khz to 22 Ghz.andP;  The cathodeandM;side of the photodiode is bypassed by an 800-pF capacitorandM;to provide a good RF termination.andP;  The preamplifier helpsandM;overcome the relatively high noise figure of the microwaveandM;spectrum analyzer shown in Fig.andP;  3.andP;  It also improves theandM;overall system sensitivity.andP;  The preamplifier has about 32andM;dB of gain, provided by a cascade of four microwaveandM;monolithic integrated circuit (MMIC) amplifier chips, eachandM;with a nominal gain of 8 dB.andM;The optical microcircuit package includes the bias boardandM;assembly.andP;  This was done to shield the bias lines from anyandM;radiated electromagnetic interference (EMI).andP;  In addition, aandM;spiral wound gasket is placed at the microcircuit-optoblockandM;interface to reduce the likelihood of any EMI pickup.andP;  AandM;rubber 0-ring gasket is also placed at this interface to helpandM;seal the microcircuit assembly.andM;Average Power CircuitryandM;Connected to the cathode of the photodetector is aandM;transimpedance amplifier, which is the input circuit for theandM;average power circuitry.andP;  The design of the average powerandM;meter was highly leveraged from the HP 8152A OpticalandM;Average Power Meter.andP;  The average power circuitry, whichandM;incorporates four key elements: a transimpedance amplifier,andM;offset correction, wavelength gain correction, and digitization.andM;In this design, the transimpedance amplifier serves aandM;dual role.andP;  It converts photocurrent into an equivalent voltageandM;depending on which feedback resistor is selected.andP;  InandM;addition, it provides the reverse bias for the photodiode.andM;The input amplifier is an OPA111BM, which was chosenandM;for its low input offset characteristics.andP;  The transimpedanceandM;amplifier is followed by a difference amplifier which removesandM;the bias voltage component from the signal componentandM;being measured.andP;  This amplifier is followed by an internalandM;gain-adjust amplifier, which is set to produce a 4-voltandM;output when - 20 dbm of optical power is present at theandM;input.andM;The two values of feedback resistors, along with the threeandM;values of step gain, provide six different range settings.andM;The proper range is automatically selected as a functionandM;of input power level.andP;  The design allows a measurementandM;range of + 3 dbm to less than - 60 dbm when there is noandM;optical attenuation present.andP;  With the attenuator set to 30andM;dB, power levels up to + 33 dbm can be measured.andP;  In theandM;lowest range the feedback resistor is 3.33 Mil and at - 60andM;dbm the photocurrent is less than 1 nA, so guarding isandM;used to prevent offset errors resulting from leakage currents.andM;[Lambdal] DAC, ADC, and Offset DACandM;To compensate for the photodiode's responsivity variationsandM;with wavelength, a multiplying digital-to-analogandM;converter called the [lambdal] DAC is used as a variable-gainandM;amplifier.andP;  The average power reading of the HP 71400A isandM;calibrated at two wavelengths: 1300 nm and 1550 nm.andP;  TheandM;responsivity at 1300 nm is defined as 0 dB and the relativeandM;responsivity value at 1550 nm is within  0.5 dB of thisandM;value.andP;  To calibrate the HP 71400A to an external referenceandM;or if the customer chooses to operate at another wavelength,andM;the value of the [lambdal] DAC can be varied by  3 dB using theandM;USER CAL function.andM;The operation of the analog-to-digital converter (ADC)andM;circuitry is identical to that of the HP 8152A.andP;  An AD7550andM;13-bit ADC is used, with the following relationship for aandM;10-db range step:andM;n = A[sub.in](4096/V[sub.fs]) + 4096,andM;where n is the number of ADC counts, A[sub.in] is the analogandM;input voltage, and V[sub.fs], is the full-scale input voltage.andP;  AandM;one-millivolt change in the voltage at V[sub.e], producesandM;a one-count change in the ADC reading.andP;  To center the inputandM;voltage range on the ADC range, V[sub.e] is shifted down byandM;3.901V to produce the following relationship:andM;The relative power in a given range is computed by subtractingandM;195 from the ADC counts and then dividing byandM;4000 counts.andM;Because the reverse-biased, uncooled Ingaas photodiodeandM;has a substantial dark current of several nanoamperes thatandM;is present under no illumination, offset compensation hadandM;to be designed to correct for offsets that could be largerandM;than the signal in the most sensitive range.andP;  There are twoandM;convenient places to put the offset correction DAC: beforeandM;or after the step-gain amplifier.andP;  Placing the offset correctionandM;after the step-gain amplifier has the advantage that theandM;resolution of the offset correction is constant and independentandM;of range, and there can be a one-to-one correspondenceandM;between an ADC count and an offset DAC count.andP;  However,andM;the disadvantage is that the effective offset correction range,andM;referenced to the input, decreases as the step gain is inandM;-creased.andP;  In this design, a significant offset can exist becauseandM;of a large dark current component, particularly at the maximumandM;instrument operating temperature of 55 degrees C. Therefore,andM;a 12-bit offset DAC is used to supply an offset correctionandM;at the input of the step-gain amplifier that can compensateandM;for as much as 250 nA of dark current at the photodiode.andM;This causes a corresponding loss in offset resolution in theandM;most sensitive range, and these leftover residual offsetandM;counts are recorded and subtracted in the firmware.andM;input Optical AttenuatorandM;The control circuitry for the input optical attenuator wasandM;highly leveraged from another instrument, the HP 8158AandM;Optical Attenuator.&quot; The digital motor controller uses anandM;8-bit microprocessor with 128 bytes of internal RAM andandM;a 16-bit internal timer.andP;  This processor sets the pulse widthandM;of the motor drive, whose period is 31.25 khz.andP;  The motorandM;driver itself is a simple transistor full bridge circuit.andP;  AnandM;optical encoder, driven in quadrature mode, provides anandM;effective resolution of 2048 positions per revolution.andP;  TheandM;positions, corresponding to 1-dB steps of the linear filterandM;wheel, are measured at both 1300 nm and 1550 nm, andandM;these positions are stored in EEPROM.andP;  The HP 71400AandM;uses the same motor control firmware as the HP 8158A,andM;which is based on a PD (proportional differential) algorithm.3andM;Display and User interfaceandM;The goal of the display and user interface design wasandM;that both optical and microwave scientists and engineersandM;would be comfortable with it.andP;  Basically, the design followsandM;the HP 70000 electrical spectrum analyzer formats, andandM;integrates the optical functionality into this context.andM;Primarily menu-driven, the user interface consists of aandM;set of firmkeys on the left side of the display.andM;These firmkeys are the basic analyzer controlandM;function headings, which when selected, pull up submenusandM;on the softkeys on the right side of the display.andP;  TheseandM;softkeys for the most part represent immediately executableandM;functions.andP;  Control of optical parameters such as wavelengthandM;calibration, optical attenuation, power meter offset zeroing,andM;and optical marker functions is offered on submenus withandM;related analyzer functions.andM;Displayed intensity modulation of a lightwave carrierandM;has essentially the same appearance as the electrical modulationandM;spectrum, so the basic display format mimics thatandM;of the electrical spectrum analyzer with one important diffandM;-erence.andP;  This difference is the display of the average powerandM;bar on the left side of the screen.andP;  In additionandM;to providing an accurate average power indication, theandM;graphical power bar representation makes optical alignmentandM;much easier.andP;  The average power and modulatedandM;power displays are coupled in that they are have the sameandM;scale and are referenced to the same absolute amplitudeandM;level.andM;The lightwave signal analyzer has three measurementandM;modes.andP;  Two modes are for making lightwave measurements-theandM;input is the optical input of the lightwave section.andM;The difference in these two modes is in the displayandM;units.andP;  In lightwave-optical mode, the display is referencedandM;to the optical input connector and the display is calibratedandM;in optical power units.andP;  In lightwave-electrical mode, theandM;display is referenced to the input of the electrical spectrumandM;analyzer and the display is calibrated in electrical powerandM;units.andP;  This mode was implemented because, before theandM;lightwave signal analyzer was developed, customers becameandM;accustomed to using electrical spectrum analyzers toandM;make these lightwave measurements, and have specifiedandM;some of these measurements in electrical power units.andP;  TheandM;display units of these two modes are related by the followingandM;equation:andM;P[sub.elec.] (dbm) = 2P[sub.opt](dBm) + 10log[(l mW) xandM;r[sup.2]  50 Ohms x Gv(lin)[sup.2]]andM;where r is the responsivity of the photodiode and Gv[sub.(lin)] isandM;the linear voltage gain of the microwave preamplifier.andM;The third measurement mode, the microwave mode, isandM;for making strictly electrical measurements.andP;  In the microwaveandM;mode the RF input of the lightwave section is usedandM;and the optical path is bypassed.andM;Firmware Design OverviewandM;As previously mentioned, the HP 71400A Lightwave SignalandM;Analyzer is part of the HP 70000 Modular MeasurementandM;System (MMS).andP;  In this system, certain instrument modules,andM;designated as masters, can control the operation of otherandM;modules, designated as slaves.andP;  Communication betweenandM;modules occurs over the internal high-speed modular systemandM;interface bus (HP-MSIB).andP;  Whether a module operatesandM;as a master or a slave is determined by the module's internalandM;firmware design and its relative position in the moduleandM;address map.andP;   The address map for the lightwave signalandM;analyzer, indicating the row and column positions of theandM;modules in the system, is shown in Fig.andP;  10.andP;  The HP 70810AandM;lightwave section, in the row 0, column 17 location, is theandM;master module, controlling all the modules at higher rowandM;and column addresses up to the column where anotherandM;master is present on row 0.andP;  Thus, a number of independentandM;instruments can be configured in the system, simultaneouslyandM;making measurements.andM;Firmware for the lightwave module is written in the CandM;programming language, and the compiled code runs on aandM;Motorola 68000 microprocessor.andP;  The firmware consists ofandM;three major components:andM;* The PSOS operating system, written by Software ComponentandM;Group, Inc.' This is a full multitasking operatingandM;system.andM;* The MMS instrument shell.andP;  This is a large, integratedandM;collection of support routines and drivers intended toandM;supply functionality to most HP 70000 Series modules.andM;* Lightwave-section-specific code written on top of theandM;instrument shell and the PSOS operating system.andM;The lightwave-specific code encompasses a number ofandM;elements.andP;  Communication, measurement coordination,andM;and control of the HP 70900A local oscillator module mustandM;be established and maintained.andP;  The HP 70900A local oscillatorandM;module is the controller of the electrical spectrumandM;analyzer and is allocated a display subwindow for presentingandM;the lightwave modulation spectrum.andP;  An array containingandM;the flatness corrections for the frequency responseandM;of the optical microcircuit is stored in the HP 70810A'sandM;EEPROM and is passed over the HP-MSIB to the HP 70900AandM;to apply as a correction to the displayed trace.andP;  A smallandM;vertical stripe on the left edge of the window is reservedandM;for the average power bar, which the HP 70810A generates.andM;The HP 70900A is relied upon to display all annotationandM;normally associated with the spectrum analyzer except forandM;the active parameter area, the message area, the mode annotation,andM;and the average power and optical attenuation annotation,andM;for which the HP 7081OA is responsible.andP;  The manualandM;interface is handled entirely by the lightwave section.andP;  AllandM;remote commands and parameters are parsed by the HPandM;70810A.andP;  Commands that are intended to modify the spectrumandM;analyzer are passed along to the HP 70900A.andM;When the HP 70810A is operated without an HP 70900AandM;as its slave, it operates in a stand-alone mode.andP;  In this modeandM;the module can be used as a lightwave converter, can makeandM;average optical power measurements, and can control theandM;optical attenuation.andM;CalibrationandM;A major contribution of the HP 71400A is its opticalandM;calibration.andP;  To our knowledge it is the only lightwave productandM;that is calibrated in both relative and absolute powerandM;levels out to a modulation bandwidth of 22 Ghz.andP;  The lightwaveandM;signal analyzer is calibrated by comparing its responseandM;at 250 frequency points to that of a reference receiver.andM;This specially packaged reference receiver is calibrated.andM;All sources of electrical frequencyandM;response error, including detector capacitance,andM;mismatch loss, cable loss, and spectrum analyzer amplitudeandM;errors, are measured by feeding a power-meter-calibratedandM;microwave signal through the fixture and into theandM;spectrum analyzer.andP;  The frequency response of the referenceandM;detector's photocurrent is then calibrated by turning offandM;the microwave signal and injecting a constant amplituandM;-demodulated optical signal whose modulation frequency isandM;determined by the heterodyne interaction of two quasiplanarring,andM;diode-pumped Nd:YAG lasers,&quot; one of which is temperatureandM;tuned over a 22-Ghz range.andM;These two highly stable single-line lasers produce a beatandM;frequency with a linewidth less than 10 khz, which is essentialandM;for accurate repeatable measurements.andM;The system is constructed with polarization-preservingandM;fiber to avoid amplitude variations of the beat frequencyandM;caused by a change in the relative polarizations ofandM;the two laser signals.andP;  The output powers of the lasers areandM;monitored during the calibration process, eliminating anandM;-other potential error source.andM;After the reference receiver is calibrated, it is used toandM;calibrate lightwave signal analyzer systems.andP;  To calibrate aandM;system, a gain-switched diode laser's output is measuredandM;with the reference receiver.andP;  The calibrated laser responseandM;is then used to calibrate the system under test.andM;System PerformanceandM;The HP 71400A Lightwave Signal Analyzer offers advancedandM;lightwave measurement performance.andP;  The combinationandM;of the broad-bandwidth pin photodetector, the high-gain,andM;low-noise microwave preamplifier, and HewlettandM;-Packard's highest-performance spectrum analyzer offersandM;excellent measurement sensitivity out to 22 Ghz.andP;  The displayedandM;average optical noise floor in a 10-Hz resolutionandM;bandwidth is typically better than - 68 dBm from 10 MhzandM;to 16 Ghz, allowing optical signals below - 60 dBm (1 nW)andM;to be detected easily.andP;  With the built-in 30-dB optical attenuator,andM;intensity modulation up to + 15 dBm (31.6 mW)andM;can be displayed.andM;Modulated power frequency response is flat within anandM;excellent  +/- 1.0 dB from 100 khz to 22 Ghz.andP;  This is a resultandM;of the optical heterodyne calibration technique and theandM;method of calibrating the HP 71400A as a system.andP;  TheandM;system calibration corrects for the roll-off of the HP 70810AandM;lightwave section and the frequency response of the spectrumandM;analyzer.andP;  The mismatch loss and cable loss betweenandM;the lightwave section and the spectrum analyzer are alsoandM;corrected.andM;MeasurementsandM;The HP 71400A can make a number of measurementsandM;on lasers, optical modulators, and receivers.8   Only a fewandM;can be described here.andM;A key parameter in any lightwave system is the modulationandM;bandwidth of the optical source.andP;  Current-modulatedandM;semiconductor lasers today have bandwidths that are approachingandM;20 Ghz.andP;  This bandwidth is achieved by optimizationandM;of the laser construction and selection of the appropriateandM;current bias point.andP;  Fig.andP;  13 shows a measurement ofandM;intensity modulation frequency response on a semiconductorandM;laser designed particularly for high-frequency operation.andM;As can be shown analytically,&quot; the modulation bandwidthandM;increases as a function of bias.andP;  In addition, the peakingandM;in the response decreases, which is generally advantageous.andM;If the current is increased beyond the criticallyandM;damped response point, the bandwidth decreases.andM;This intensity modulation response measurement wasandM;made with the HP 71400A in conjunction with the HPandM;70300A tracking generator (20 Hz to 2.9 Ghz) and the HPandM;70301A tracking generator (2.7 Ghz to 18 Ghz).andM;These tracking generators are also modulesandM;in the HP 70000 MMS family, and produce a modulationandM;signal that is locked to the frequency to which theandM;analyzer is tuned, thus making stimulus-response measurementsandM;easy and straightforward.andM;In most applications the laser noise spectrum is veryandM;important for a number of reasons.andP;  It obviously impactsandM;the signal-to-noise ratio in a transmission system.andP;  Furthermore,andM;it can be shown that the intensity noise spectrumandM;has the same general shape as the intensity modulationandM;response, and can be used as a indicator of potential modulationandM;bandwidth.' The characteristic noise peak of theandM;intensity noise spectrum also increases in frequency andandM;decreases in amplitude as the bias current is increased.andM;The laser intensity noise spectrum can be greatly affectedandM;by both the magnitude and the polarization of the opticalandM;power that is fed back to the laser.andP;  This is called reflectionandM;induced noise and is typically caused by reflections fromandM;optical connectors.andP;  This reflected power upsets the dynamicandM;equilibrium of the lasing process and typically increasesandM;the amplitude of the intensity noise.andM;It also can induce a ripple on the spectrum with a frequencyandM;that is inversely porportional to the round-trip time fromandM;the laser to the reflection.andP;  It should be noted that otherandM;instruments, such as an optical time-domain reflectometer,andM;can measure the magnitude of a reflection, but the lightwaveandM;signal analyzer is the only instrument that can measureandM;the effect of these reflections on the noise characteristicandM;of the laser under test.andM;An important quantity related to signal-to-noise ratio isandM;the relative intensity noise (RIN).andP;  It is a ratio of the opticalandM;noise power to the average optical power, and is an indicationandM;of the maximum possible signal-to-noise ratio in aandM;lightwave system, where the dominant noise source is theandM;laser intensity noise.andP;  In the lightwave-optical measurementandM;mode, the HP 71400A makes the following measurementandM;when the RIN marker is activated:andM;RIN = P[sub.noise] / P[sub.avg]andM;where P[sub.noise], is the optical noise power expressed in a 1-HzandM;bandwidth, and P[sub.avg] is the average optical power.andP;  ThisandM;measurement can be made directly because of the built-inandM;power meter function.andM;Before the development of the lightwave signal analyzer,andM;customers used a photodiode and a microwave spectrumandM;analyzer to make this noise measurement, and an ammeterandM;to monitor the photocurrent.andP;  This has led to an alternateandM;expression of RIN in electrical power units, since theseandM;were the units of the measurement equipment being used.andM;The HP 71400A has the ability to express this RIN measurementandM;in electrical power units in the lightwave-electricalandM;measurement mode.andM;Notice that the noise floor of the HPandM;71400A is 10 dB lower than the laser noiseandM;floor in this measurement.andM;The HP 71400A can make a number of useful measurementsandM;involving large-signal digital modulation of lasers.andM;This sequence is a widely used test signal usuallyandM;observed as an eye diagram in the time domain.andP;  In theandM;frequency domain, an envelope that is the Fourier transformandM;of the pulse shape is displayed.andP;  Nonideal characteristics,andM;such as clock feedthough, are evident.andP;  As shown inandM;Fig.andP;  19, a narrower frequency sweep reveals that the signalandM;is divided into discrete frequencies whose spacing is equalandM;to the clock rate divided by the sequence length.andP;  Noise isandM;also visible.andP;  In fact, different signal-to-noise ratios are observableandM;as the feedback to the laser is adjusted.andP;  It is likelyandM;that this is the only way to measure transmitter-relatedandM;noise problems under large-signal modulation.andP;  In principle,andM;it is possible to estimate bit error rate from this signal-to-noiseandM;ratio.andM;High-speed pulse modulation can also be displayed onandM;the HP 71400A.andM;The spacing between the individualandM;discrete frequencies is equal to the pulse repetitionandM;rate.andP;  Once again, the envelope is the Fourier transform ofandM;the pulse shape.andP;  The pulse width can be determined fromandM;the 3-dB bandwidth, here 12.5 Ghz, by assuming the pulseandM;shape is Gaussian and using the following relationship:andM;Pulse Width = 0.44/Optical 3-dB Bandwidth.andM;This technique may be just as accurate as measuring theandM;pulse width on a sampling oscilloscope, where the riseandM;time of the scope must be deconvolved to get the correctandM;answer.andM;AcknowledgmentsandM;The development of the HP 71400A Lightwave SignalandM;Analyzer depended on contributions of a number of individuals,andM;spread over a number of Hewlett-Packard divisions.andM;This project had the potential to be a project manager'sandM;nightmare with all the personnel interdependencyandM;and new technology development, along with an aggressiveandM;introduction schedule.andP;  It was the dedication and perseveranceandM;of the following people that made this product happen.andM;The project team and their responsibilities were: DennisandM;Derickson, microcircuit design, Roberto Collins, digitalandM;design, Jimmie Yarnell, mechanical design, Dave BaileyandM;and Zoltan Azary, firmware design.andP;  The instrument shellandM;design team completed their portion of the firmware underandM;significant time constraints.andP;  This product was based on aandM;new technology for Signal Analysis Division, and the effortandM;of the NPI team to get this product into production wasandM;commendable.andP;  The major contributions of this instrumentandM;were dependent on the high-speed pin photodiode, distributedandM;MMIC amplifier, and Tao, thin-film integratedandM;capacitor technology, all developed by the engineers atandM;Microwave Technology Division.andP;  Portions of the designandM;were leveraged from existing products with the help of theandM;engineers at Boblingen Instruments Division.andP;  I would likeandM;to thank Jack Dupre and the rest of the management teamandM;at Signal Analysis Division who supported the developmentandM;of this product.andP;  Finally, I would especially like toandM;acknowledge the efforts of Rory Van Tuyl, who started ourandM;lightwave program at Signal Analysis Division and whoseandM;vision this product reflects.andM;ReferencesandM;1.andP;  W. Radermacher, &quot;A High-precision Optical Connector for OpticalandM;Test and Instrumentation,&quot; Hewlett-Packard Journal, Vol.andP;  38,andM;no.andP;  2, February 1987, pp.andP;  28-30.andM;2.andP;  H. Schweikardt, &quot;An Accurate Two-Channel Optical AverageandM;Power Meter,&quot; Hewlett-Packard journal, Vol.andP;  38, no.andP;  2, FebruaryandM;1987, pp.andP;  8-11.andM;3.andP;  B. Maisenbacher, S. Schmidt, and M. Schlicker, &quot;Design ApproachandM;for a Programmable Optical Attenuator,&quot; Hewlett-PackardandM;Journal, Vol.andP;  38, no.andP;  2, February 1987, pp.andP;  31-35.andM;4.andP;  Product Note 70000-1, HP 70000 System Design Overview,andM;Hewlett-packard Publication No.andP;  5954-9135.andM;5.andP;  pSOS-68K User's Manual, The Software Components GroupandM;Inc., Doc.andP;  No.andP;  PK68K-MAN.andM;6.andP;  W.R.andP;  Trutna Jr., D.K.andP;  Donald, and M. Nazarathy, &quot;UnidirectionalandM;Diode Laser-pumped ND:YAG Ring Laser,&quot; Optical Letters,andM;Vol.andP;  12, 1987, pg.andP;  248.andM;7.andP;  T.S.andP;  Tan, R.L.andP;  Jungerman, and S.S.andP;  Elliot, &quot;Calibration ofandM;Optical Receivers and Modulators Using an Optical HeterodyneandM;Technique,&quot; IEEE-MTT-S International Microwave SymposiumandM;Digest, 00-2, 1988, pp.andP;  1067-1070.andM;8.andP;  Application Note 371, Lightwave Measurements with the HPandM;71400 Lightwave Signal Analyzer, Hewlett-packard PublicationandM;No.andP;  5954-9137.andM;9.andP;  C. Miller, D. Baney, and J. Dupre, &quot;Measurements on LasersandM;for High-capacity Communication Systems,&quot; Hewlett-packard RF,andM;Microwave, and Lightwave Measurement Symposium, 1989.andM;@@@08155074X 0HPJIja092LAPSandM;WITH THE ADVENT OF SEMICONDUCTOR lasersandM;and low-loss optical fibers, the possibility ofandM;achieving over 1000-Gbit-km/s bandwidth-distanceandM;products has propelled research towards improvingandM;the performance of the laser and the optical fiber transmissionandM;medium.1 To minimize transmission penalties resultingandM;from dispersion in long optical fiber communicationandM;links, high-performance lightwave communication systemsandM;require lasers that operate in a single longitudinalandM;mode (i.e., single-frequency oscillation) and have minimalandM;dynamic linewidth broadening (i.e., frequency chirp)andM;under modulation.andP;  In coherent communications, the lasingandM;linewidth becomes an important determinant of systemandM;performance.andP;  In the development of FSK modulated systems,andM;which often rely on modulating the injection currentandM;to a semiconductor laser, the FM deviation as a functionandM;of both injection current and modulation frequency mustandM;be characterized.andM;Advances in laser technology necessary to meet the stringentandM;requirements of communications system design haveandM;required similar advances in measurement techniques andandM;technology.andP;  The HP 11980A Fiber Optic Interferometer wasandM;developed to work as an accessory to the HP 71400A LightwaveandM;Signal Analyzer (see article, page 80) to enable usersandM;to characterize many important spectral modulation propertiesandM;of single-frequency telecommunication lasers.andM;Interferometer DesignandM;The function of the HP 11980A is to act as a frequencyandM;discriminator, converting optical phase or frequency deviaandM;-tions into intensity variations, which can then be detectedandM;using a square-law photodetector (e.g., the high-speedandM;photodiode of the HP 71400A).andP;  Inside the HP 11980A isandM;an unbalanced fiber optic Mach-Zehnder interferometerandM;This type of interferometer has an input directionalandM;coupler, which splits the incoming optical signalandM;into two equal parts.andP;  The two signals then travel alongandM;separate fiber paths where they experience a differentialandM;delay, To.andP;  The two signals are then recombined usingandM;another directional coupler.andP;  Since the optical fiber doesandM;not preserve the polarization state, a polarization state controllerandM;is added to one arm of the interferometer.andP;  The controllerandM;is purely mechanical and consists simply of a loopandM;of fiber that can be rotated.andP;  This adjustment allows the userandM;to maximize the interference signal by ensuring similarandM;polarization states at the combining directional coupler.andM;The optical output can then be sent to the HP 71400AandM;where intensity variations are converted to a time-varyingandM;photocurrent, which is displayed on a spectrum analyzer.andM;The HP 11980A interferometer is completely passive andandM;has the same adaptable fiber optic connectors as the HPandM;71400A.andP;  The connectors are compatible with the HMS-10/andM;HP, FC/PC, ST, biconic, and DIN connector formats.andP;  FusedandM;single-mode fiber directional couplers from Gould, Inc.andM;were chosen for their broad wavelength range from 1250andM;to 1600 nanometers, enabling coverage of the importantandM;1300-nm and 1550-nm telecommunication windows.andP;  OneandM;arm of the interferometer is spliced to a 730-meter reel ofandM;Corning single-mode optical fiber to provide a differentialandM;delay of 3.5 microseconds.andP;  This delay permits laserandM;linewidth measurements as low as 225 khz (LorentzianandM;line shapes).andM;Laser Diode LinewidthandM;The most basic type of semiconductor laser uses reflectionsandM;from cleaved end facets to provide the feedbackandM;needed for laser operation.andP;  One disadvantage of this FabryandM;-Perot type laser is that it generally operates in several frequencyandM;modes, each separated by about 100 Ghz.andP;  This canandM;produce effective laser linewidths greater than 500 Ghz,andM;which can limit data rates (because of dispersion) in long haulandM;fiber optic communication links.andP;  One possible solutionandM;for reducing the effects of dispersion is the developmentandM;of DFB (distributed feedback) and DBR (distributedandM;Bragg reflector) semiconductor lasers.andP;  In these lasers, aandM;wavelength filter (a diffraction grating) suppresses all butandM;one of the frequency modes of the laser.andP;  The resultingandM;linewidths for these lasers are typically less than 50 Mhz.andM;Considering that the laser itself oscillates at a frequency ofandM;about 200,000 Ghz, this is a relatively small fractionalandM;linewidth.andM;DFB and DBR lasers have a tendency to change theirandM;operating frequency f or different levels of injection current.andM;This causes the laser to frequency chirp while beingandM;amplitude modulated, which can also result in limited dataandM;rates because of dispersion.andP;  The magnitude of these frequencyandM;chirps can be in the tens of gigahertz.andP;  MeasurementsandM;of linewidth and frequency chirp yield important informationandM;not only about the laser's performance in a lightwaveandM;link, but also about the physical characteristics of the laserandM;itself.andM;Measuring LinewidthandM;The HP 11980A enables measurement of laser linewidth,andM;[Delta v], by preprocessing the optical signal for the HP 71400AandM;Lightwave Signal Analyzer.andM;The single-frequency laser, typically a DFB or DBR laser,andM;is coupled to an optical fiber.andP;  Isolators are often usedandM;to reduce perturbations ofandM;the laser by optical feedback arising from optical scatteringandM;in the fiber or at optical interfaces.andP;  The signal to be analyzedandM;is then fed into the unbalanced Mach-Zehnder fiber opticandM;interferometer inside the HP 11980A.andP;  Inside the interferometerandM;the laser signal is split into two signals, whichandM;experience different delays before being recombined andandM;sent to the photodiode of the HP 71400A.andP;  If the differentialandM;delay [Tau][sub.o] is larger than the coherence time [Tau][sub.r],andM;of the laser,andM;the two combined signals become uncorrelated.andP;  This processandM;is equivalent to mixing two separate laser signals, bothandM;having the same linewidth and center frequency.andP;  The mixingandM;(i.e., multiplying) of these two signals is accomplishedandM;as a result of the square-law nature of the photodiode.andP;  TheandM;resulting photocurrent spectrum is the autocorrelationandM;function of the laser's electric field spectrum S[sub.E](f) and isandM;commonly referred to as the delayed self-homodyneandM;linewidth measurement.andM;Since the displayed spectrum is the autocorrelationandM;function of the laser's line shape, its spectral width isandM;approximately twice that of the laser linewidth.andP;  For theandM;special case of Lorentzian line shapes, the autocorrelationandM;function is also Lorentzian and has a linewidth exactlyandM;twice that of the original line shape.andP;  For Gaussian lineandM;shapes, the autocorrelation function is also Gaussian butandM;has a linewidth equal to V2- times that of the original lineandM;shape.andP;  Currently, most single-frequency semiconductorandM;lasers are accurately described by Lorentzian line shapes.andM;For the delayed self-homodyne measurement to be valid,andM;the combining signals from the two arms of the interferometerandM;must be uncorrelated.andP;  For the HP 11980A, this meansandM;that the coherence time of the laser should be less than theandM;interferometer delay of 3.5 microseconds.andP;  Since the coherenceandM;time is approximately equal to the inverse of theandM;linewidth (i.e., [tau][sub.c] = 1/[delta] v), the HP 11980AandM;can measure linewidths less than 300 khz.andM;The signal-to-noise ratio of the displayed photocurrentandM;spectrum can often be improved by manual adjustment ofandM;the front-panel knob on the HP 11980A.andP;  This polarizationandM;state adjustment can increase the interference between theandM;two mixing signals by ensuring that their polarization statesandM;are closely matched.andP;  The shape of the displayed spectrumandM;is not altered by this adjustment, only its size relative toandM;the noise floor.andP;  It was decided not to automate this adjustandM;ment because of the additional complexity that would beandM;required.andM;The linewidth,  [Delta]v, is foundandM;by placing the display delta marker at the - 3-dB poiandM;from the peak.andP;  The half width is measured, since the auandM;-tocorrelation process doubles the width of the laser's specandM;trum.andP;  For the conditions of Fig.andP;  3a, the laser linewidth isandM;measured to be approximately 25 Mhz.andM;It is also possible to display a two-side line shape byandM;by applying a small amount of amplitude modulation toandM;the laser and observing the linewidth convolved about oneandM;of the modulation sidebands.andM;The linewidth is again measured to be about 25andM;Mhz, which agrees with that.andM;Modulated Laser Power Spectrum MeasurementandM;Using a newly developed measurement technique,&quot; theandM;HP 11980A Fiber Optic Interferometer can used to measureandM;laser chirp as well as intentional frequency modulation.andM;Chirp can be thought of as the unwanted frequency deviationandM;in the optical carrier of a modulated laser.andP;  There existandM;a variety of techniques to measure the modulated powerandM;spectrum of a single-frequency laser.andP;  These include gratingandM;and Fabry-perot spectrometers and heterodyne down-conversionandM;using two lasers.andP;  The technique presented hereandM;was developed in response to the shortcomings of previouslyandM;known techniques.andP;  For example, it offers superiorandM;frequency resolution than grating spectrometers, which inandM;practice are limited to a resolution of about 1 angstromandM;(approximately 15 Ghz).andP;  Higher resolution (i.e., finesse)andM;can be achieved with Fabry-perot spectrometers, but theandM;wavelength range is limited for a fixed pair of mirrors.andP;  InandM;heterodyne techniques, two lasers are required and theirandM;wavelengths must be precisely controlled, which often requiresandM;a high degree of complexity.andP;  The technique presentedandM;in this section overcomes these problems, allowingandM;homodyne frequency measurements to be made over aandM;range of 300 khz to 22 Ghz.andM;Laser chirp in semiconductor lasers is caused by theandM;dependence of the real and imaginary parts of the indexandM;of refraction on the injection current.andP;  Because of this effect,andM;modulation of the injection current can result in large fluctuationsandM;of the lasing wavelength.andP;  This phenomenon isandM;responsible for a substantial widening of the electric fieldandM;modulation power spectrum, S[sub.m](f), beyond the FourierandM;transform limit of the information bandwidth.andP;  A wideandM;power spectrum can impose severe transmission penaltiesandM;in lightwave links with nonnegligible wavelength dispersion.andM;Using the new gated delayed self-homodyne techandM;-nique, a homodyne measurement of S[sub.](f) can be performedandM;using the HP 11980A in conjunction with the HP 71400A.andM;Fig.andP;  4 shows the measurement setup.andP;  With the laserandM;biased above threshold, the injection current is gated betweenandM;two states, one state modulated and the other stateandM;unmodulated.andP;  Thus, the laser behaves as a modulated laserandM;for a period To and an unmodulated laser, or local oscillatorandM;signal, for a sequential period [Tau.sub.andP;  o].andP;  The period [Tau.andP;  sub.o]andM;is chosen to equal the differential delay in the arms of the fiber opticandM;interferometer, which is assumed to be longer than theandM;coherence time of the laser.andP;  In the HP 11980A, there is aandM;continuous combination of a modulated state with an unmodulatedandM;state.andP;  These states are then mixed in the photodetectorandM;of the HP 71400A.andP;  The power spectrum of theandM;detector photocurrent, S[sub.i](f), is displayed by the HP 71400A.andM;The homodyne down-conversion of the optical spectrum.andM;In this figure, the modulated spectrumandM;is shown to be asymmetrically located around theandM;average frequency V[sub.o].andP;  This demonstrates the folding aboutandM;zero frequency which is characteristic of homodyne mixing.andM;This spectrum, S[sub.i](f), for the case where [Tau sub.o] andgt;andM;[Tau sub.c], can be approximated as:andM;S[sub.i](f) = S[sub.D](f) + { Delta [sub.v]/ Pi /andM;(Delta[sub.v)[sup.2] + f[sup.2]} * {S[sub.m(f) +andM;S[sub.m] (-f}andM;where S[sub.D](f) is the direct intensity modulation that wouldandM;be measured if the interferometer were not present, andandM;the other terms describe the Lorentzian line shape of theandM;laser crosscorrelated with the homodyne power spectrumandM;of the lasers's electric field modulation.andP;  The ability to makeandM;this measurement while the laser is modulated allows theandM;determination of the alpha factor,6 which characterizes theandM;coupling between gain and frequency chirp in semiconductorandM;lasers.andM;Figs.andP;  6a and 6b demonstrate some of the experimentalandM;results that can be obtained using this gated delayed self homodyneandM;technique.andP;  In Fig.andP;  6a, the injection current to aandM;DFB laser is sinusoidally modulated at a rate of 300 Mhz.andM;Besides introducing a small amount of intensity modulation,andM;the optical frequency is also modulated.andP;  The modulaandM;-tion of the optical carrier results in an electric field spectrumandM;whose peaks are spaced by 300 Mhz and whoseandM;amplitudes are described in terms of Bessel functions asandM;predicted by classical FM theory.andP;  By adjusting the injectionandM;current to null a specific Bessel sideband, the frequencyandM;modulation index 8 can be determined very accurately.andM;This technique is useful for accurately determining theandM;optical FM response at various modulation frequencies.andM;In Fig.andP;  6b, the modulation frequency was reduced to 45andM;Mhz, which results in a larger FM modulation index forandM;the laser.andP;  The individual sidebands are no longer resolvedandM;because of the finite linewidth of the laser, and the spectrumandM;takes on the shape of the probability density functionandM;for wideband sinusoidal FM modulation.andP;  The two curvesandM;in Fig.andP;  6b indicate the progression of laser chirp with increasingandM;modulation power.andP;  The difference between theseandM;two curves corresponds to a ratio of optical frequency chirpandM;to injection current of 410 Mhz/ma at a modulation frequencyandM;of 45 Mhz.andM;The resolution of the technique is approximately equalandM;to the laser linewidth and therefore can be significantlyandM;superior to that of the Fabry-perot spectrometer while beingandM;able to operate over a wavelength range of approximatelyandM;1250 to 1600 nm.andP;  Compared to heterodyne techniques employingandM;two lasers, this technique has the advantage ofandM;wavelength autotracking between the local oscillator andandM;the modulated laser, since the same laser is used to generateandM;both signals.andM;SummaryandM;The HP 11980A Fiber Optic Interferometer was developedandM;to enhance the measurement capabilities of theandM;HP 71400A Lightwave Signal Analyzer.andP;  The fiber interferometerandM;provides the ability to compare an optical signalandM;with a 3.5-microsecond delayed version of itself.andP;  Using thisandM;type of comparison, information can be obtained aboutandM;deviations in the optical carrier frequency.andP;  This enhancementandM;allows the HP 71400A to measure laser linewidthsandM;as low as 225 khz and frequency chirp (up to +/-22 Ghz)andM;over a wavelength range of 1250 to 1600 nm.andM;AcknowledgmentsandM;Since the conception of the HP 11980A was based on aandM;new measurement technique, it required allocation of previouslyandM;unscheduled human and material resources.andP;  ManyandM;people put in the extra effort needed to make it a reality.andM;Some key people and their responsibilities are as follows.andM;Rory Van Tuyl provided indispensable management andandM;technical support.andP;  Scott Conrad and Ron Koo providedandM;manufacturing and production engineering support.andP;  DeanandM;Carter performed mechanical design.andP;  At Hewlett-PackardandM;Laboratories, Moshe Nazarathy and Steve Newton providedandM;important technical support.andM;ReferencesandM;1.andP;  N.A.andP;  Olsson, G.P.andP;  Agrawal, and K.W.andP;  Wecht, &quot;16 Gbit/s, 70 kmandM;pulse transmission by simultaneous dispersion and loss compensationandM;with 1.5 micro-m optical amplifiers,&quot; Electronics Letters, Vol.andM;25, April 1989, pp.andP;  603-605.andM;2.andP;  M. Nazarathy, W.V.andP;  Sorin, D.M.andP;  Baney, and S.A.andP;  Newton,andM;&quot;Spectral analysis of optical mixing measurements,&quot; Journal ofandM;Lightwave Technology, Vol.andP;  LT-7, 1989, pp.andP;  1083-1096.andM;3.andP;  R.D.andP;  Esman and L. Goldberg, &quot;Simple measurement of laserandM;diode spectral linewidth using modulation sidebands,&quot; ElectronicsandM;Letters, Vol.andP;  24, October 1988, pp.andP;  1393-1395.andM;4.andP;  D.M.andP;  Baney and W.V.andP;  Sorin, &quot;Measurement of a modulatedandM;DFB laser spectrum using gated delayed self-homodyneandM;technique,&quot; Electronics Letters, Vol.andP;  24, May 1988, pp.andP;  669-670.andM;5.andP;  D.M.andP;  Baney and P.B.andP;  Gallion, &quot;Power spectrum measurementandM;of a modulated semiconductor laser using an interferometric selfandM;-homodyne technique: influence of quantum phase noise and fieldandM;correlation,&quot; IEEE Journal of Quantum Electronics, Vol.andP;  25,andM;October 1989, pp.andP;  2106-2112.andM;6.andP;  C.H.andP;  Henry, &quot;Phase noise in semiconductor lasers,&quot; Journal ofandM;Lightwave Technology, Vol.andP;  LT-4, 1986, pp.andP;  298-311, 1986.andO;</TEXT></DOC>