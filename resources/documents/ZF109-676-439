<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF109-676-439  </DOCNO><DOCID>09 676 439.andM;</DOCID><JOURNAL>Dr. Dobb's Journal  Dec 1990 v15 n12 p131(7)* Full Text COPYRIGHT Mandamp;T Publishing 1990.andM;</JOURNAL><TITLE>The Cuba Lake effect. (getting lost in a program with intricatemenu-tree structures) (Structured Programming) (column)</TITLE><AUTHOR>Duntemann, Jeff.andM;</AUTHOR><SUMMARY>The 'Cuba Lake Effect' takes its name from a short story by NebulaAward winner Nancy Kress about a woman who finds herself onbackroads trying to get to the other side of a lake but alwaysseeming to end up back at the lake shore.andP;  In programming, it iscommon to become lost in a menu-tree structure of a complexprogram, such as for transaction processing and other mainframeand minicomputer office applications.andP;  This is a primary reasonwhy users come to detest computers: navigating through the programis done on the program's terms, and rarely are users presentedwith ways to back out of operations gracefully.andP;  An event-drivenarchitecture, such as is used in the Macintosh, returns muchcontrol to users and allows movement from point A to point B in aprogram simply by clicking on the appropriate icon rather thanbeing forced to follow some convoluted 'road map'.andP;  Coding suchapplications is described.andM;</SUMMARY><DESCRIPT>Topic:     Event-Driven SystemsSystem DesignProgramming InstructionSoftware DesignUser InterfaceSoftware ComplexityApplications ProgrammingWindowingUser Needs.andO;Feature:   illustrationchartprogram.andO;Caption:   Turbo Vision event processing. (chart)Jeff's Experimental Desktop Manager for Turbo Vision. (program)andM;</DESCRIPT><TEXT>It was a wonderful trade: Nancy Kress taught me how to write fiction, and Itaught her how to use computers.andP;  She has gone on to win the coveted NebulaAward for science fiction, and I, well, I've gone on using computers.andP;  Butnow I can write a character that isn't part of the ASCII table.andP;  A good dealall the way around.andM;Nan published a story some years back that still haunts me.andP;  In &quot;Down BehindCuba Lake,&quot; the protagonist is travelling through rural New York State tomake amends with an old lover with whom she has had - and broken off adisastrous affair.andP;  As night falls she is forced off the main highway by roadconstruction and decides to cut through the back roads near a small lake.andM;The first back road she takes dead ends on the shore of the lake.andP;  No problem- back roads can be that way.andP;  So she backtracks and tries another dark,twisting road - and again, winds up headlights to the water.andP;  Again, shebacktracks - and again, she winds up somewhere down behind Cuba Lake, on adead-end dirt road that vanishes into the black water.andP;  No matter where shegoes, or how far she follows the increasingly narrow and rough dirt roads,she can't get around Cuba Lake.andP;  Worse, she can't go back.andM;It's an exquisite piece of low-key psychological horror.andP;  What it means, ofcourse, is that there are some decisions you simply can't rescind, and themore you try, the deeper in trouble you get.andP;  You Can't Get Out Nan wouldprotest that she doesn't know anything about programming, but anybody who'sever gotten lost somewhere seven levels down in the menu tree of an elaboratetransaction-processing application would swear she's been there too.andM;What I call the &quot;Cuba Lake Effect&quot; is something that almost invariablyhappens in traditional menu-tree applications that mix modes and menus withdata dependencies.andP;  You know, things such as this: You're editing a record,and you try to enter a Canadian customer from the Yukon Territory, provincecode &quot;YT.&quot; Whoops, undefined code error - you forgot to add  YT&quot; to the tablewhen you set it up.andP;  (Nobody really lives up there, do they? Yup, they doandM;.... )The table maintenance screen is up three levels, across, and down two.andP;  Youhammer the ESC key, SCOOT Lip three screens, and back down into tablemaintenance ...andP;  but you get stopped cold: You can't edit tables while you'reediting records.andP;  So back you go, up a screen, across, and down three.andP;  Thenyour blood runs cold as you remember: You can't get out of record edit modewithout closing the customer file.andP;  You can't close the customer file whilethe current record edit screen is in an error mode, and you can't close therecord edit screen without deleting the current record, and you can't deletethe current record without going through the state/province code key file tobring it up on the screen again, and the key for the current record is in anerror state with an undefined value ....andM;Get me out of here! Who Chooses the Path? This sort of nightmare is one majorreason that office staffers traditionally hate computers.andP;  What I'vedescribed is a common situation on traditional mainframe and minicomputerapplications.andP;  Such applications begin with a top-level menu screen.andP;  Theuser picks a number, and goes &quot;down&quot; into the next level, typically anothermenu, and continues until some sort of data entry screen or report definitionscreen is found.andP;  There are a number of paths from the top level down to theleaves of the menu tree, but every path is defined by the structure of themenus, and may be constrained by modes and data dependencies.andP;  If you changesomething the return path may change.andP;  it may even be blocked.andM;The essence of a system such as this (which is about as hideous a way ofprogramming as I've ever seen) is that every path is dictated to the user.andO;Navigating through the program is done strictly on the program's terms.andP;  In abadly-designed program (which includes most minicomputer and nearly allmainframe software I've experienced) the program's terms don't necessarilyinclude the imperative that the user be able to back gracefully out of anyoperation without having to yell for help or abort the whole session.andM;The essence of writing ergonomic software is giving the user more control ofwhat's going on.andP;  This begins with providing the user near-absolute controlover how to navigate the system.andP;  Ideally, this should be the differencebetween having to follow the roads on a map to get from point A to point B,or simply having to put your finger over point B on the map and saying, &quot;Iwant to be here.&quot; it is the difference between the view from the inside andthe view from a height; in the country of the flat, the 3-D view is king.andO;Event-Driven Architectures If you've lived your programming life creatingendless full-screen menu trees, your first impression might be that this isimpossible.andP;  It's not impossible at all, but like object-orientedprogramming, such an ideal requires a whole different way of thinking aboutthe architecture of an application.andP;  This new architecture was invented byXerox, borrowed and popularized by the Macintosh (to the extent that Applehas now convinced itself that Apple did the inventing) and is now (withMicrosoft Windows at the vanguard) percolating through most commercialapplications for DOS.andP;  it's called an event-driven architecture and if you'renot using it yet you're already way behind the times.andM;Rather than being a maze of fullscreen menus, an event-driven application istypically a single screen with two major parts.andP;  At the center of theapplication (and usually at the center of the screen) is the workspace.andP;  Thiscontains some representation of the work that is being done.andP;  it might he atechnical drawing, a spreadsheet, a document, or a database arranged as rowsand columns of records and fields.andP;  All around the workspace are tools thatmay be selected to manipulate the workspace and the information within it.andM;The user selects tools either from the keyboard, with some combination ofcontrol keys, or (much more appropriately) with a mouse cursor that zipsaround the screen and allows the user to &quot;click on&quot; a tool when the mousecursor is over that tool's representation on the screen.andP;  This representationmight in fact be a graphics icon, but remember that nothing in anevent-driven architecture limits us to a graphics environment.andP;  The new TurboC++ and Turbo Pascal 6.0 environments are mouse-based and truly event-driven,yet both run strictly in text mode.andP;  A Natural for Windows Nor is thereanything in an event-driven architecture that requires the use of windows,but windows are a natural way to return a measure of control to the user inan event-driven system.andP;  Think back to the transaction processing nightmare Idescribed a little earlier.andP;  In an event-driven system, the user would beediting records in the central workspace of the application.andP;  (Editingrecords is, at the heart of it, what such transaction processing applicationsare about.) If an invalid state code turned up, the user would simply reachout with the mouse to a tools icon or menu of some sort,  grab&quot; the codes'editor, and open it as a window, either beside or even on top of the recordbeing edited in the central workspace.andM;You need to think of the user's action as the equivalent of a subroutine callin the work flow.andP;  While editing a record, programmers find the need to dosome code table editing.andP;  Rather than close the edit screen and backtrackthrough the menu tree to open another screen devoted to code table editing,the user simply &quot;ducks out&quot; from record editing for a while and opens awindow into the code tables.andP;  once done with the code tables, you close thecode table tool window and you are instantly back where you were in thecentral workspace when you discovered the undefined state code.andP;  No backingup, no opportunity to get lost behind Cuba Lake.andP;  When you find a need for atool, you reach out and grab it.andP;  While you're using the tool, your previouswork remains, perhaps dormant, in the central workspace.andP;  That's the metaphorof an event-driven architecture.andP;  Beneath the Surface I'm not going to tellyou how to code up an event-driven application framework here.andP;  it's probablytoo big a project for a magazine article.andP;  and to be honest, 99.999 percentof you would be wasting your time trying to roll your own, because there arefar, far better ones on the open market right now than you could ever hope tocreate yourselves.andP;  They're inexpensive, too in fact, one of the very bestnow comes bundled free with every copy of Turbo Pascal 6.0.andM;Still, it always pays to have a handle on what's going on beneath thesurface.andP;  So I'll speak in broad terms of how event managers work.andM;First, to define this thing called an event:&quot; An event is an occurrence thateffects your program but which is not dictated by the flow of control in theprogram.andP;  in other words, an event is not something triggered by an IFstatement.andP;  It is triggered, instead, by forces outside of the currentprogram, and even outside of the machine itself.andM;The best example of an event is something that the user does.andP;  A keystroke isperhaps the crispest example of an event.andP;  The program has no idea what theuser will type, or when.andP;  Similarly, the user's moving a mouse cursor over apredefined &quot;hot area&quot; (such as a menu bar) is something done when the userchooses to do it.andP;  A mouse button click, like a keystroke, is anotherexcellent example of an event.andM;Events can also come from within the machine.andP;  A character from a serial portcan be an event, as one can appear at any time once the port is enabled.andP;  Thesystem software (DOS, BIOS) can also create events.andP;  The best known of theseis the&quot;timer tick&quot; that happens 18 times every second.andP;  Timer ticks are notbeholden to the currently-running program.andP;  They march inexorably in stepwith the hardware timer regardless of what the current program does (unless,of course, the current program inhibits interrupts).andP;  Usually timer tickevents don't happen every tick, but every Nticks, providing aprogrammabletime delay between events.andM;Similarly, timer ticks can be used to create &quot;now is the time&quot; events; youset a specific date and time when something must happen, and at each timertick, a simple comparison determines whether it's zero hour or not.andP;  if thetime is now, the event is generated.andP;  Event Managers Beneath the surface ofan event-driven application must be some sort of event manager.andP;  The eventmanager is a mechanism that watches for events,  typically by &quot;capturing&quot; aninterrupt vector signalling an event's occurrence) places them in anapplication-friendly &quot;wrapper&quot; of some sort, and then queues the wrappedevents up for processing in some sort of FIFO (First In, First Out) datastructure.andP;  The event manager then processes the queued events in order.andM;Nearly all event-driven systems have this much in common.andP;  How the queued upevents are processed is up to the cleverness of the system architect, andvaries with the event-driven system or toolkit under discussion.andP;  Typically,the programmer associates an event with a procedure, function, or objectmethod that is called when the event occurs.andP;  Turbo Pascal 4.x and later, forexample, considers function key F10 an event.andP;  When the F10 event isdetected, Turbo Pascal calls its menuing system and moves the cursor to themenu bar at the top of the screen.andM;Events can be prioritized, meaning that some events are handled immediatelyeven if others are waiting in the queue.andP;  The word  queue&quot; suggest a wholeconga-line of events in a row struggling toward their ultimate fate, butthat's misleading.andP;  In nearly all cases, the event queue is empty or containsone or (on the outside) two events.andP;  A good system should not allow events topile up; there's nothing like watching a system try to execute a queue of adozen accumulated mouse clicks to drive a user to distraction.andP;  If somethingis begun that absolutely cannot be interrupted, (like saving the work file todisk) event sensing should be suspended until - but only until - the criticaltask is finished.andP;  More typically, an event &quot;freezes&quot; the current task andopens something new in a process akin to (as just mentioned) a subroutinecall.andP;  You can duck out of editing the work file in Turbo Pascal by pressingany of numerous hot keys such as F10, Alt-F, Alt-C, and so on, each of whichgenerates an event.andP;  The edit screen waits patiently while you fool around inthe menus; when the menu work is done, the focus returns to the edit fileexactly where you left off when you triggered one of the keyboard events.andM;Event-driven architectures facilitate a level of concurrency impossible inmenu-tree systems.andP;  Even if the underlying platform isn't multitasking innature, having three windows open on the screen with an edit file in each isnearly as useful, especially if you can zip from one to another with a singleclick of the mouse on the selected window.andP;  Getting involved People who havebeen using eventdriven systems for years will find all this stuitifyinglyobvious, but a great many people (particularly programming newcomers) haven'tcaught on.andP;  I think a good many of those holding back assume you have to comeup with the event management and menuing code yourself, which simply isn'ttrue.andP;  There are a dozen or more solid event-driven application frameworkproducts out there, with more appearing all the time.andM;Most of them, as you might imagine, are limited to C, and many operate onlyin graphics mode.andP;  Still, some of the best support text mode and are in factavailable for Pascal.andP;  (The best one I've seen for any language, The ZincInterface Library, is an SAA-compliant C++ product that operatesinterchangeably in either graphics or text mode; if you're working in C++, Ipowerfully suggest that you look into it.) TurboPower Software's ObjectProfessional is one that I've mentioned in the past, and will mention again.andO;Turbo Vision But the one that most people will be talking about for a whileis the event driven application framework provided as part of the recentlyreleased Turbo Pascal 6.0.andP;  Borland's Turbo Vision is an &quot;empty application&quot;in object form that you inherit and extend using object oriented techniques.andO;Turbo Vision provides a classic, mouse-based windowing user interface in textmode.andP;  In fact, the Turbo Pascal 6.0 integrated development environment (IDE)itself was written using Turbo Vision, so if you want to see what a TurboVision application looks like, just look at Turbo Pascal.andM;Turbo Vision's TApplication object type and the object types it includesalready contain thousands of lines of code implementing event management,menuing, and windowing, as well as dialog boxes, buttons, pick lists, andother controls.andP;  Your part in the programming process is to define a childclass of TApplication and add the code specific to your own application.andM;If your application is fairly simple, you don't even have to write the mainprogram.andP;  These three method calls comprise the main program of most TurboVision applications, and all three are inherited whole from TApplication: !!!andO;BEGIN TABLEandM;BEGINandM;MyApp.Init;andM;MyApp.Run;andM;MyApp.DoneandM;END.andP;  !!! END TABLE Initis the application's constructor, and Done is itsdestructor.andP;  You set the application up, you run it, and you shut it down.andO;This is structured programming with a vengeance.andM;Like its elder cousin Object Professional, Turbo Vision defies easydescription in a 3500-word magazine column.andP;  The best I can do this time isgive you a flavor for how it works, and show you a simple program that usesit.andP;  in future columns I'll be speaking of Turbo Vision regularly, now thatit's an intrinsic part of Turbo Pascal.andP;  An Experimental Desktop Manager inonly an hour or two, I was able to come up with the prototype of a desktopmanager in Turbo Vision, and I've presented it in Listing One (page 151).andO;it's a prototype because what's there is a menu structure and a couple ofdialog boxes; there's no real &quot;guts&quot; to the program.andP;  That's by design,because Turbo Vision is a user interface tool, and I wanted to show how ithelps you put together an event-driven user interface.andP;  The guts are aseparate issue.andM;Working with Turbo Vision begins with the definition of your applicationobject, which is always a child class of the abstract class TApplication.andP;  Icalled mine TDesk (the  T&quot; prefix means type,&quot; and is an Object Pascalconvention going back to Apple's Lisa days).andP;  You must override threeTApplication methods: InitMenuBar, which sets up menus in the menu bar at thetop of the screen; InitStatusLine, which sets up any prompts in the statusline at the bottom of the screen; and HandleEvent, which is yourapplication's event handler, and in many ways the key to the whole process.andM;Your own code never actually calls any of these three methods.andP;  Theapplication constructor Init calls InitStatusLine and InitMenuBallbem whileit's setting up the program.andP;  HandleEvent is called from withinTApplication's Run method, which is inherited unchanged by your own specificapplication class.andM;This struck me very oddly at first, but like OOP in general, it gets morenatural the more you work with it.andP;  Working with Turbo Vision might beconsidered a process of setting up a series of effects, and allowing TurboVision's internals to provide the causes.andM;When you call the Run method, what happens is that execution vanishes intoTurbo Vision (for which source code is not available, sadly) and waits forevents to happen.andP;  when an event happens, Turbo Vision gets first crack athandling the event.andP;  (Some events, like the Alt-X hotkey for exiting anapplication, are pre-coded into Turbo Vision and inherited by your ownapplication class.) If the event is not something Turbo Vision handles, itpasses the event on to your application by calling your application'sHandleEvent method.andP;  Inside your HandleEvent method, you parse the eventpassed along by Turbo Vision, typically through a CASE statement.andP;  If theevent provided by Turbo Vision is something your application knows how tohandle, the CASE statement calls an appropriate method or other routine toservice the event.andP;  If the event is undefined, you have the option of safelyignoring it.andP;  See Figure 1.andM;This, at the highest level, is how the flow of control goes in a Turbo Visionapplication: Events happen.andP;  Turbo Vision queues them up, and gets first shotat processing them.andP;  If it cannot process an event, Turbo Vision passes theevent along to your application.andP;  Once your application processes the event,control eventually falls back into Turbo Vision to wait for the next event.andM;For simplicity's sake I have created only one method that handles an event inJXDESK: SystemStatistics, which is called in response to the Statisticsoption in the System menu.andP;  The call is made from the HandleEvent method.andO;Note that the event is passed out from within Turbo Vision as a namedconstant, SysStatCmd, which is simply a name given to the value 102.andP;  Such aconstant is called a command&quot; in Turbo Vision.andP;  You define commands andassociate them with events by passing a command to Turbo Vision along with amenu option definition, when InitMenuBar is called.andP;  Note that all theNewItem calls made from within InitMenuBar associate their menu items withthe null command except for one: The one that sets up the Statistics menuitem on the System menu.andM;Read the code for JXDESK a few times, and it should start making sense.andO;Better still, download the EXE file that I have provided along with thesource to JXDESK and play around with it for a while.andP;  Like many other thingsin our complicated world, Turbo Vision shows better than it tells.andP;  The Endof an Era I'll have more to say about JXDESK in my next column, and moreabout Turbo Vision as well.andP;  And I'll wrap this month up by positing thatwe're coming to the close of another era in structured programming: The eraof Doing It All Yourself.andP;  Everywhere I look, Pascal and Modula-2 programmersare using screen generators, procedure and object libraries, menu generators,and all other manner of productivity enhancers and canned code.andP;  Nobody butthe rankest beginners or the hardest-headed compulsives sit down with thenaked compiler and roll it all from scratch.andP;  This makes the apps happen alot faster, but there's a whole crop of new dangers heaving over the horizon,stemming from not really knowing how your own&quot; code works.andP;  Turbo Vision is acase in point; from now on, as much as half of your application will probablyremain a total mystery from a source code standpoint, rather than just somecanned procs here or there.andP;  You can even get away without learning in detailwhat Turbo Vision does, as long as you can set up menus and an eventandM;Is this good? I don't know yet.andP;  I haven't the vaguest idea how DOS works,and don't care much, because it hasn't hurt me.andP;  This wasn't always the case;back in the CP/M era we had to understand what the OS did, because we had tomodify and extend it to mate with our oddball hardware.andP;  And before CP/M, itwas every hacker for himself.andP;  I even wrote my own operating system once,lordy.andM;Now, more and more of the code we use in creating our applications comesstandard in a can from somebody else and can be taken for granted once welearn how to use it.andP;  obviously, we're heading somewhere.andP;  When I figure outwhere, I'll be sure to let you know.andP;  Listings omitted</TEXT></DOC>