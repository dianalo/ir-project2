<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-695-440  </DOCNO><DOCID>08 695 440.andM;</DOCID><JOURNAL>Microsoft Systems Journal  July 1990 v5 n4 p29(23)* Full Text COPYRIGHT The Microsoft Corporation 1990.andM;</JOURNAL><TITLE>Extending the Windows 3.0 interface with installable customcontrols. (tutorial)</TITLE><AUTHOR>Welch, Kevin P.andO;AttFile:   MSJ\V05N04\CONTROL.EXE;2 Program:  CONTROL.EXE  Self-extracting archive.andM;</AUTHOR><SUMMARY>A special feature of Microsoft Windows 3.0 is the ability to crateand formally install custom controls.andP;  The design and definitionof new control classes, the new interface supported by Windows 3.0for installable controls and the use of the interface with asample Page selection control are discussed.andP;  In designing aninstallable control class several steps are outlined.andP;  Theyinclude: naming the control; designing the user interface byextending the functionality of that interface and considering theuse of colors; defining the interface by considering the styleflags to be supported by the control and creating a public headerfile; defining the window function; defining the related utilityfunctions; and, finally, creating a self-contained dynamic linklibrary.andP;  In addition, the use of installable controls with theaid of the new Dialog Editor is explained.andM;</SUMMARY><DESCRIPT>Ticker:    MSFT.andO;Product:   Microsoft Windows 3.0 (Graphical user interface) (customizing).andO;Topic:     Graphical User InterfaceControl StructuresCustomizationColorUtility ProgramsLibrariesTutorialApplications Programming.andO;Feature:   illustrationprogram.andO;Caption:   Control.H. (program)Page.H. (program)Page. (program)andM;</DESCRIPT><TEXT>The ability to create and formally install custom controls is a feature ofthe Microsoft[R] Windows[TM] graphical environment Version 3.0 that will beof great interest to software developers.andP;  This ability permits the developerto extend the user interface of Windows' and encourages the creation ofsmall, self-contained, reusable software objects that can be shared betweenapplications.andM;This article describes the design and definition of new control classes,discusses the new interface supported by Windows 3.0 for such installablecontrols, and demonstrates the use of the interface with a sample Pageselection control.andP;  The sample control can be used with the new dialog editorsupplied with the Windows Version 3.0 Software Development Kit (SDK).andM;A few fairly simple steps greatly simplify the process of designing a newinstallable control class.andP;  While these guidelines are helpful when creatingany new window class, they are particularly applicable when designing aninstallable control.andM;The first step is to name the control.andP;  As with any other window, eachcontrol must be associated with a class name.andP;  This class name is used inyour RC file whenever you wish to use the control explicitly in a dialog box.andO;When naming the control, make sure not to use one of the public class namesdefined by Windows or other applications.andP;  If you do, the registrationprocess for your control class will not succeed.andM;Second, you must design the user interface.andP;  This is usually the mostdifficult aspect of creating a control.andP;  The interface you design for yourcontrol determines to a large degree how difficult the control will be foryou to implement, and how the end user will perceive it.andM;When you design a new control, you are extending the functionality of theWindows user interface.andP;  Your new control should look and act similarly tothose already provided by Windows.andP;  For example, you should be consistentwith the commonly used mechanisms to indicate selection and keyboard inputfocus.andM;You should also avoid device dependencies when you design your control.andP;  Asyou know, Windows is device-independent so it can run on a wide variety ofdisplay subsystems, with varying screen-aspect ratios, pixel densities, andcolor capabilities.andP;  For instance, you probably shouldn't put fixed-sizebitmaps in the control interface.andP;  Since aspect ratios and pixel densitiesvary widely, the bitmap will probably be scaled or distorted, resulting in aless-than-optimal interface.andM;Another issue to consider is the use of colors.andP;  Predefined system colorswork best.andP;  Don't assume, for example, that the window background color willalways be white and the window frame black.andP;  Although it takes a little extrawork to incorporate such flexibility into your control, it is almost alwaysnecessary when producing controls for commercial use.andM;Finally, if you are creating an active control, be prepared to support somemechanism to define the input focus.andM;The third step is to define the interface.andP;  Almost all controls interact withother windows in some way or another.andP;  Although this interaction can occurusing any of the mechanisms supported by Windows, almost all the controlspredefined by Windows (except the scroll bar) use a completely message-basedinterface.andP;  Therefore, you must decide which messages your control will workwith.andM;You should also design the style flags your control will support.andP;  Whenever anew instance of your control is created, these style flags are combined withflags that are predefined by Windows and are passed to the system as aparameter in the CreateWindow function.andM;After you have designed the control interface, you should create a publicheader file defining each supported style, command, and notification message.andO;This header file can then be used by any other module that uses the control.andM;Fourth, define the instance variables.andP;  By their nature, controls must becompletely reentrant and totally modular.andP;  As a result, the data structuresused by your control must be dynamically allocated and readily accessible byeach instance.andP;  Although you could create your own scheme for defininginstance variables, in most cases you should consider allocating extra classor window bytes when the class is registered, or perhaps use property listsor atoms.andM;The fifth step is to define the window function.andP;  Each control must beassociated with a window function that processes all related messages.andP;  Bydefinition, controls must be able to work with the Windows dialog boxmanager.andP;  Consequently, your window function should handle at least thefollowing messages:andM;Message -- Window Function ResponseandM;WM_CREATE  Initialize any instance variables and perform any other necessarysteps to use the control.andM;WM_DESTROY  Release all the resources associated with the control instance,including the removal of property lists and deletion of any atomsandM;WM_PAINT  Update the client region of the control.andP;  Carefully tune the updateoperations for a variety of display devices, paying special attention to thequality of the result.andP;  This is often one of the most tedious aspects of theentire control development process.andM;If your control is to be capable of receiving input from both the keyboardand the mouse, your window function should also be able to handle thefollowing messages:andM;Message -- Window Function ResponseandM;WM_GETDLGCODE  This message is sent to your control by the dialog boxmanager.andP;  The response to this message determines how the control will bemanaged inside a dialog box.andP;  By responding with one of the following returncodes, your control can manage a particular type of input and process theinformation itself -  * DLGC_WANTALLKEYS  Intercept all keyboard inputandM;* DLGC_WANTARROWS  Intercept cursor keysandM;* DLGC_WANTCHARS  Intercept WM_CHAR messagesandM;* DLGC_WANTMESSAGE  Intercept all messagesandM;* DLGC_WANTTAB  Intercept the TAB keyandM;WM_KEYDOWN  Received when a key is held down.andP;  By processing the virtual keycodes within this message, you can perform any necessary action.andP;  When anaction is taken that changes the state of the control, be sure to provideappropriate notification codes to the parent window.andM;WM_KILLFOCUS  Received when the input focus changes to another window.andP;  Ifthe control displays some sort of highlight, it should be destroyed at thistime.andM;WM_LBUTTONDOWN  Received when the user presses the left mouse button insidethe control client area.andP;  You will want to capture the system input focus,display your highlight, and start capturing mouse movements.andP;  If the mouseclick results in a new selection, you may also want to notify the parentwindow of the change.andM;WM_LBUTTONUP  Received when the user releases the left mouse button.andP;  If youare capturing mouse movements, you should be careful to release the mousecapture at this time.andP;  Note that it is entirely possible to receive extrabutton-down and button-up messages.andP;  If you want to animate a drag operationyou will need to capture the mouse and process each of the WM_MOUSEMOVIEmessages.andM;WM_SETFOCUS  When this message is received, a highlight should indicate thatthe control has the system input focus.andM;In addition to these messages, your window function should also be capable ofprocessing the command messages you define as part of your message-basedinterface.andP;  Note that you should be careful to return the appropriateresponse for each message received, especially when an internal error occurs.andM;The next step in the process is to define related utility functions.andP;  Theimplementation of even a simple control often requires the definition ofseveral related utility functions that perform often-repeated processes.andP;  Aswith any Windows program, you should structure and organize these functionscarefully, preferably placing them in logical groups using separate,discardable code segments.andM;Finally, you must physically create the control modules.andP;  Depending on yourneeds, you can either link each control object module directly into yourapplication or combine them into a library and let the linker extract therequired components.andP;  Be aware that if your control uses any resources, youmust also incorporate them into your application.andM;You might also want to modularize your control completely (with allassociated resources) into a self-contained dynamic-link library (DLL).andP;  Thisextra degree of encapsulation can be very beneficial, enabling you to use thecontrol simultaneously in several applications.andP;  You will also be able to useit with the new Windows 3.0 Dialog Editor by adhering to a few simplestandards.andM;Creating Installable Control LibrariesandM;When creating an installable control you must follow the procedures justoutlined, plus a few additional steps that permit the control to exist in aDLL.andP;  DLLs form the foundation upon which Windows is built.andP;  Unfortunately,DLLs impose certain programming restrictions.andP;  Perhaps the most significantis the SS != DS issue.andP;  Unlike conventional Windows programs, DLLs have nostack segment and only one data segment.andP;  Consequently, when an applicationcalls a function within a DLL, it has to use its own stack segment and thelibrary's data segment.andP;  The result is that many of the standard C run-timelibrary functions cannot be used within a DLL.andM;Library Module Definition File To create an installable control, first definea DLL containing a series of exported functions that are associated with aseries of predefined ordinal values.andP;  Create the DLL using the followingmodule definition file, where Xxxx represents the class name of the control:andM;LIBRARY         XxxxandM;DESCRIPTION     'Xxxx Control Library'andM;EXETYPE         WINDOWSandM;STUB            'WINSTUB.EXE'andM;CODE            MOVEABLE DISCARDABLE SHARED PRELOADandM;DATA            MOVEABLE SINGLE PRELOADandM;HEAPSIZE        1024andM;EXPORTSandM;WEP            @1 RESIDENTNAMEandM;XxxxInfo()     @2andM;XxxxStyle()    @3andM;XxxxFlags()    @4andM;XxxxWndFn()    @5andM;XxxxDlgFn()    @6andM;You should always use the same predefined ordinal values for each of theseexported functions.andP;  The XxxxDlgFn function associated with the XxxxStylefunction must also be exported since it is used directly by Windows.andP;  LibraryEntry Points In addition to the module definition file, you will need tocreate several different source code modules, each containing one or more ofthe exported functions discussed below.andP;  These functions must be present forthe Windows 3.0 Dialog Editor to use the control.andP;  The next section describeseach of these required functions in detail.andP;  Note that all the required datastructures are defined in CONTROL.H (see Figure 1), one of the files used tobuild the sample control discussed later in this article.andM;BOOL FAR PASCAL XxxxInit( hInstance )andM;The XxxxInit function is responsible for all the initialization needed to usethe DLL.andP;  This function is normally called by the assembly language entrypoint to the library.andP;  After saving the library instance handle using aglobal static variable, this function should register the control class andinitialize the local heap (if necessary) by calling LocalInit.andM;Parameter       Type             DescriptionandM;hinstance       HANDLE           Library instance handleandM;The return value indicates the success or failure of the libraryinitialization.andP;  A return value of FALSE indicates that the initializationprocess has failed; TRUE indicates that the control class has been registeredand initialization has succeeded.andM;HANDLE FAR PASCAL XxxxInfo()andM;The XxxxInfo function provides the calling application with information aboutthe control library.andP;  Based on the information returned, the application cancreate instances of the control using one of the supported styles.andP;  If thecontrol was used with the Windows Dialog Editor, for example, this functioncould be used to query the library about the different control styles it cansupport.andM;The return value is a handle to a CTLINFO data structure.andP;  This informationbecomes the property of the caller and must be explicitly released using theGlobalFree function when it is no longer needed.andP;  If there is insufficientmemory available to define this structure, a NULL handle is returned.andM;The CTLINFO structure, defined in CONTROL.H (see Figure 1), specifies theclass name and version number and lists each of the supported control styleswith suggested size information and a short description.andM;/* general style andamp; size definitions */andM;#define   CT_STD     0x0000andM;#define       CTLTYPES   12andM;#define       CTLDESCR   22andM;#define       CTLCLASS   20andM;#define       CTLTITLE   94andM;typedef struct {andM;WORD        wType;andM;WORD        wWidth;andM;WORD        wHeight;andM;DWORD       dwStyle;andM;char        szDescr[CTLDESCR];andM;} CTLTYPE;andM;typedef struct {andM;WORD        wVersion;andM;WORD        wCtlTypes;andM;char        szClass[CTLCLASS];andM;char        szTitle[CTLTITLE];andM;char        szReserved[10];andM;CTLTYPE     Type[CTLTYPES];andM;} CTLINFO;andM;typedef CTLINFO *      PCTLINFO;andM;typedef CTLINFO FAR *  LPCTLINFO;andM;The CTLTYPE structure has the following fields:andM;Field -- DescriptionandM;wType  Defines the type of control.andP;  While only the CT_STD option iscurrently supported, other types may be defined in the future.andM;wWidth  Defines the suggested width of the control.andP;  If the most significantbit is zero, the remaining bits specify the default width in RC coordinates;otherwise, the remaining bits specify the default width in pixels.andP;  Onehorizontal RC unit is the width of the system font divided by four.andM;wHeight  Defines the suggested height of the control.andP;  If the mostsignificant bit is zero, the remaining bits specify the default height in RCcoordinates; otherwise, the remaining bits specify the default height inpixels.andP;  One vertical RC unit is the height of the system font divided byeight.andM;dwStyle  Specifies the initial style flags used to obtain this particularcontrol variant.andP;  This value includes both the control-defined style flags inthe low-order word and the Windows-defined flags in the high-order word.andM;szDescr  Defines the name to be used by other applications when referencingthis particular variant of the base control class.andM;The CTLINFO structure contains the following fields:andM;Field  DescriptionandM;wVersion  Specifies the control version number.andP;  Although you can start yournumbering scheme from 1, most implementations use the lower two digits torepresent minor releases.andP;  Using this scheme, the first version would benumbered 100.andM;wCtlTypes  Specifies the number of control types supported by this class.andO;This value should always be greater than zero and less than or equal toCTLTYPES.andM;szClass  Specifies with a NULL-terminated string the control class namesupported by the DLL.andM;szTitle  Specifies with a NULL-terminated string copyright or authorinformation relating to the control library.andM;Type  Specifies an array of CTLTYPE data structures containing informationrelating to each of the control types supported by the class.andM;BOOL FAR PASCAL XxxxStyle( hWnd, hCtlStyle, IpfnStrTold, IpfnIdToStr )andM;The XxxxStyle function enables the calling application to edit the style of aparticular control.andP;  When this function is called, a modal dialog box shouldbe displayed that permits the user to edit the CTLSTYLE parameters.andP;  Thedisplay of this dialog box should be consistent with Style dialog boxesprovided by existing controls.andM;Parameter    TYPE         DescriptionandM;hwnd         HWND         Handle to parent windowandM;hCtlStyle    HANDLE       Handle to CTLSTYLE dataandM;lpfnStrToId  LPFNSTRTOID  String-to-ID conversion functionandM;lpfnIdToStr  LPFNIDTOSTR  ID-to-string conversion functionandM;The XxxxStyle function returns a value of TRUE if the CTLSTYLE structure waschanged.andP;  Otherwise, it returns FALSE.andM;The CTLSTYLE structure specifies the various attributes of the selectedcontrol, including the current style flags, location, dimensions, andassociated text.andM;#define     CTLCLASS      20andM;#define     CTLTITLE      94andM;typedef struct {andM;WORD        wX;andM;WORD        wY;andM;WORD        wCx;andM;WORD        wCy;andM;WORD        wId;andM;DWORD       dwStyle;andM;char        szClass[CTLCLASS];andM;char        szTitle[CTLTITLE];andM;} CTLSTYLE;andM;typedef CTLSTYLE *       PCTLSTYLE;andM;typedef CTLSTYLE FAR *   LPCTLSTYLE;andM;The CTLSTYLE structure contains the following fields:andM;Field -- DescriptionandM;wX  Specifies in screen coordinates the X origin of the control relative tothe client region of the parent window.andM;wY  Specifies in screen coordinates the Y origin of the control relative tothe client region of the parent window.andM;wCx  Specifies the current width of the control in screen coordinates.andM;wCy  Specifies the current height of the control in screen coordinates.andM;wId  Specifies the current ID number of the control.andP;  Although you can allowthe user to change this value, in most situations changes should be made inconjunction with the string-to-ID and ID-to-string conversion functionsprovided as parameters (see below).andM;dwStyle  Specifies the current style of the control.andP;  The low-order wordcontains the control-specific flags; the high-order word contains theWindows-specific flags.andP;  You should let the user change these flags to anyvalues supported by your control library.andM;szClass  Specifies a NULL-terminated string representing the name of thecurrent control class.andP;  Don't allow the user to edit this field-it isprovided for informational purposes only.andM;szTitle  Specifies the text associated with the control with aNULL-terminated string.andP;  This text is usually displayed inside the control ormay be used to store other associated information required by the control.andM;The lpfnStrToId and lpfnIdToStr functions require a little furtherexplanation.andP;  The primary purpose of the XxxxStyle function is to display adialog box through which the user can edit the various parameters associatedwith the control.andP;  As you know, each control is associated with an ID value.andO;This value is used by the parent window or dialog box to keep track of eachof its child windows.andM;/* ID to string translation function prototypes */andM;typedef WORD   (FAR PASCAL *LPFNIDTOSTR)( WORD, LPSTR, WORD );andM;typedef DWORD  (FAR PASCAL *LPFNSTRTOID)( LPSTR );andM;The lpfnIdToStr function, an optional parameter provided by the callingapplication, enables you to translate the ID from the CTLSTYLE data structureto a text string.andP;  This text string can then be displayed in place of thenumeric value.andP;  The first parameter is the control ID; the second, a longpointer to an empty text string; the third parameter is the maximum length ofthis string.andP;  The value returned by this function is the number of characterscopied to the string.andP;  If a value of zero is returned, it can be assumed thatthe function call failed.andM;The lpfnStrToId function operates exactly in reverse.andP;  This function takes astring containing an ID value as a parameter and returns a doubleword result.andO;If the LOWORD of the result is nonzero, then the HIWORD contains the newcontrol ID value (which you can use to update the CTLSTYLE structure).andP;  Ifthe LOWORD of the result is zero, the ID string was undefined.andM;The calling application (in this case, usually the Dialog Editor) keeps trackof the ID strings and their corresponding values.andP;  The control style functionaccesses this information using the lpfnStrToId and lpfnIdToStr functions.andO;The calling application can produce a header file containing these ID stringsand values for use by the application under development.andM;WORD FAR PASCAL XxxxFlags( wStyle, lpszstyle, wMaxString )andM;The XxxxFlags function translates the control style flags provided into acorresponding text string for output to a text or RC file.andP;  Note that youshould return the same control style definitions specified in the #includefile that accompanies your control library.andM;Parameter           Type           DescriptionandM;wStyle              WORD           Control styleandM;lpszStyle           LPSTR          Style flags stringandM;wMaxString          WORD           Maximum string lengthandM;The return value is the length of the resulting lpszstyle string.andP;  If anerror occurs, zero is returned.andM;LONG FAR PASCAL XxxxWndFn( hwnd, wMsg, wParam, iParam )andM;The XxxxWndFn function is the conventional window procedure responsible forprocessing all the messages sent to the control.andP;  The messages that thisfunction should be capable of handling were described earlier.andM;Parameter   Type    DescriptionandM;hwnd        HWND    Handle to the control windowandM;wMsg        WORD    Message identifierandM;wParam      WORD    Additional message dataandM;iParam      LONG    Additional message dataandM;The return value indicates the result of message processing.andP;  The possiblereturn values depend on the actual message sent.andM;BOOL FAR PASCAL XxxxDlgFn( hDlg, wMsg, wParam, lParam )andM;The XxxxDlgFn function is a conventional window procedure that processes allthe messages sent to the control style dialog box.andP;  This dialog box shoulddisplay the control ID, title, and other related information.andP;  The usershould be able to define different control styles and change the associatedID and title with this dialog box.andM;Parameter    Type    DescriptionandM;hDlg         HWND    Handle to the style dialog boxandM;wMsg         WORD    Message identifierandM;wParam       WORD    Additional message dataandM;lParam       LONG    Additional message dataandM;The return value indicates the result of message processing.andP;  If a nonzerovalue is returned, the dialog box manager will assume that the dialogfunction has processed the message.andP;  If zero is returned, the dialog boxmanager will process the message.andP;  Building the Control Library After youhave defined the control library components, you can create the installablecontrol much as you would any other Windows application.andP;  Make sure you usethe appropriate compilation flags, verifying especially that SS != DS.andM;To be consistent, consider structuring the various modules and components ofyour library in the following manner:andM;Name             DescriptionandM;Xxxx             Make fileandM;Xxxx.H           Public header fileandM;Xxxx.D           Private header fileandM;Xrxx.DEF         Module definition fileandM;Xxxx.RC          Resource fileandM;Xxxx0.ASM        DLL entry moduleandM;Xxxx1.C          Initialization moduleandM;Xxxx2.C          Message processing moduleandM;Xxxx3.C          Style dialog box moduleandM;Xxxx4.C          Information moduleandM;Xxxx5.C          Style flags moduleandM;Sample ControlandM;To put all this in perspective, let's work through a sample control.andP;  ThePage selection control is a relatively simple control that facilitates theselection of a numbered page within a small range of pages.andP;  You can select aparticular page by clicking the mouse inside one of the control's pagesymbols or by using the cursor when the control has the keyboard input focus(see Figure 2).andP;  You might use this control to support the selection of aparticular page in a document, specify a print range, or perhaps enable theuser to select a particular page of a multipage data entry form.andM;The library PAGE.DLL completely defines the installable Page control.andP;  Whenan instance is created, the Page control responds to the following set ofmessages, as defined in the public header file, PAGE.H (see Figure 3).andM;PM_SETRANGEandM;Used to set the number of pages displayed inside the control (numbered from 1to n).andP;  Note that the currently selected page is not reset.andP;  The defaultrange is set to the maximum number of pages that can be displayed.andM;Parameter        DescriptionandM;wParam           The new number of pagesandM;lParam           (not used)andM;The return value is nonzero if the new range was successfully defined.andP;  If anerror occurs, zero is returned.andM;PM_GETRANGEandM;Used to retrieve the current number of pages displayed inside the control.andM;Parameter        DescriptionandM;wParam           (not used)andM;iParam           (not used)andM;The return value indicates the number of pages displayed.andM;PM_SETSELECTandM;Used to define the currently selected page.andM;Parameter        DescriptionandM;wParam           An index for the newly selected page in theandM;range of 0 to n-1, where n is the currentandM;page rangeandM;iParam           (not used)andM;The return value is the index of the newly selected page; in most cases thisis identical to the wParam value.andM;PM_GETSELECTandM;Used to retrieve the index to the currently selected page.andM;Parameter        DescriptionandM;wParam           (not used)andM;iParam           (not used)andM;The return value is the index to the currently selected page (from 0 to n-1).andM;PN_SELCHANGEandM;Whenever the user selects a particular page using the control, thisnotification message is sent to the parent window, indicating that theselected page has changed.andP;  Notification messages are used to inform thecontrol's parent window of the control of changes that the parent may beinterested in.andP;  As with all control notification messages, the selectionchange notification message is sent to the parent window in the followingformat:andM;Parameter     DescriptionandM;wMsg          WM_COMMANDandM;wParam        Page control IDandM;iParam        Low-order word is the window handleandM;High-order word is the notification codeandM;(PN_SELCHANGE)andM;Page Control ComponentsandM;The Page control library is constructed from the following files.andP;  Continuedon page 43andM;File       Description            Figure NumberandM;PAGE       Make file                    4andM;PAGE.H     Public header file           3andM;PAGE.D     Private header file          5andM;PAGE.DEF   Module definition file       6andM;PAGE.RC    Resource file                7andM;PAGE0.ASM  DLL entry module             8andM;PAGE1.C    Initialization module        9andM;PAGE2.C    Message processing module   10andM;PAGE3.C    Style dialog box module     12andM;PAGE4.C    Information module          13andM;PAGE5.C    Style flags module          14andM;The make file, PAGE (see Figure 4), is almost identical to that used by anyWindows application except that it uses the -Aw and -D_WINDLL compile flags.andO;These flags instruct the C compiler to generate code in a DLL format with SS!= DS.andM;The next file, PAGE.H (see Figure 3), is the public header file associatedwith the control library.andP;  Because this file is designed to be used byapplications using the control, it contains only the control commands,notification codes, and function prototypes.andM;The private header file PAGE.D (see Figure 5) is associated with PAGE.H.andO;This file defines the values used throughout the control library that do notneed to be made public.andP;  For example, the following fragment from PAGE.Ddefines various constants that are used when registering the Page windowclass and when returning information about the control:andM;#define PAGE_CLASSEXTRA 0andM;#define PAGE_WNDEXTRA   18andM;#define PAGE_VERSION    100andM;#define PAGE_NAME       &quot;Page&quot;andM;#define PAGE_COLOR      NULLandM;#define PAGE_WNDSTYLE   WS_CHILD|WS_VISIBLE|WS_TABSTOPandM;#define PAGE_CLASSSTYLE CS_HREDRAW|CS_VREDRAW|CS_DBLCLKS|CS_GLOBALCLASSandM;Note the specification of the CS_DBLCLKS and CS_GLOBALCLASS class styleflags-they are extremely important.andP;  If you don't specify CS_DBLCLKS, youwill not be able to bring up the control style dialog box inside the dialogeditor by double-clicking inside the control.andP;  The CS_GLOBALCLASS flag isalso necessary, as the control class must be made publicly available.andM;PAGE.DEF (see Figure 6), the module definition file, is almost identical tothat described previously in the article, except that obviously Xxxx isreplaced with the class name Page.andM;The library resource file, PAGE.RC (see Figure 7), defines the PageStyledialog box used by the PageDlgFn function.andP;  This dialog box displays theinformation passed to the PageStyle function, allowing the user to define thecontrol identifier when used in conjunction with the dialog editor.andM;PAGE0.ASM (see Figure 8) is the assembly language entry point to the DLL.andO;Remember that in order to create DLLs, an assembly language entry point mustcall the control initialization function PageInit whenever the control isloaded.andM;The PAGE1.C module (see Figure 9) contains the PageInit function.andP;  If this isthe first attempt to initialize the control, this function defines the Pagecontrol class and registers it.andP;  If the registration process succeeds, thelibrary instance handle is saved and a value of TRUE is returned.andP;  Theinstance handle is saved because it will be used throughout the other modulesin the library.andM;The next module, PAGE2.C (see Figure 10), is the most complex.andP;  It containsthe window message processing function PageWndFn.andP;  Most of this function (andits associated helper functions) is quite typical, but two sections mightneed further explanation.andM;The first section requiring explanation is the update of the Page controlwindow, which is performed when a WM_PAINT message is received or when theuser selects a different page number.andP;  Although most of this code consists ofstraightforward Graphics Device Interface (GDI) calls, you should know howthe update colors are defined.andM;The update colors involve the use of a new pen and background brush.andP;  The penis created using the current system window frame color and selected into thedisplay device context.andP;  The background brush is obtained from the parentwindow, enabling it to define the background color of the control, just asWindows does with the system buttons.andM;/* define appropriate pen */andM;hNewPen = CreatePen( PS_SOLID, 1,andM;GetSysColor(COLOR_WINDOWFRAME) );andM;hOldPen = (hNewPen) ? SelectObject(Ps.hdc,hNewPen) : NULL;andM;/* define appropriate brush and text colors*/andM;hNewBrush = (HBRUSH)SendMessage(andM;PARENT (hwnd),andM;WM_CTLCOLOR,andM;Ps.hdc,andM;MAKELONG(hwnd,CTLCOLOR_BTN)andM;);hOldBrush = hNewBrush ? SelectObject(Ps.hdc,hNewBrush) : NULL;andM;Creating the three-dimensional look of each page icon inside the control (seeFigure 11), also requires some explanation.andP;  Unless this is done carefully,the result may not look right when viewed with different system colors anddisplay drivers.andP;  Generally speaking, three-dimensional objects in Windows3.0 are filled using a solid brush based on the COLOR_BTNFACE system color.andO;The top and left edges are colored with a solid brush based on theCOLOR_WINDOW system color, while the bottom and right edges are colored witha brush based on the COLOR_BTNSHADOW system color.andP;  These values must be usedfor the three-dimensional look to appear correctly on a monochrome display.andM;The DrawPage function uses these system colors when drawing each page icon inthe following manner:andM;/* draw page outline */andM;hOldBrush = SelectObject( hDC, CreateSolidBrush(andM;GetSysColor(COLOR_BTNFACE)) );andM;Polygon( hDC, ptPage, 7 );andM;DeleteObject( SelectObject(hDC,hOldBrush) );andM;/* draw white border */andM;hOldPen = SelectObject( hDC, CreatePen(PS_SOLID,1,andM;GetSysColor(COLOR_WINDOW)) );andM;MoveTo( hDC, ptPage[5].x + 1, ptPage[5].y - 1 );andM;LineTo( hDC, ptPage[5].x + 1, ptPage[6].y + 1 );andM;LineTo( hDC, ptPage[1].x, ptpage[1].y + 1 );andM;DeleteObject( SelectObject(hDC,hOldPen) );andM;/* draw shadow */andM;hOldPen  = SelectObject( hDC, CreatePen(PS_SOLID.1,andM;GetSysColor(COLOR_BTNSHADOW))andM;MoveTo( hDC, ptPage[5].x + 1, ptPage[5].y - 1 );andM;LineTo( hDC, ptPage[4].x - 1, ptPage[4].y - 1 );andM;LineTo( hDC, ptPage[3].x - 1, ptPage[3].y );andM;MoveTo( hDC, ptPage[5].x + 2, ptPage[5].y - 2 );andM;LineTo( hDC, ptPage[4].x - 2, ptPage[4].y - 2 );andM;LineTo( hDC, ptPage[3].x - 2, ptPage[3].y );andM;DeleteObject( SelectObject(hDC,hOldPen) );andM;The control style dialog box module, PAGE3.C (see Figure 12), contains thePageStyle and PageDlgFn functions.andP;  The PageStyle function is relativelysimple; it sets a few temporary global variables and brings up the controlstyle dialog box.andM;The PageDlgFn function is also quite simple, but further explanation might benecessary in two areas.andP;  The first involves the initial display of thecontrol ID value.andP;  If the lpfnIdToStr and lpfnStrToId parameters have beendefined, the control ID is passed to the lpfnIdToStr function and convertedinto a string.andP;  The resulting text string is then displayed in place of thenumeric value.andM;/* define page id field */andM;if ( lpfnIdToStrTemp andamp;andamp; lpfnStrToIdTemp ) {andM;(*lpfnIdToStrTemp)( lpCtlStyle-andgt;wId,andM;(LPSTR)szId, sizeof(szId) );andM;SetDlgItemText( hDlg, ID_IDENTIFER, szId );andM;}When the user closes the style dialog box, the updated text string isretrieved and translated back into an identifier using the lpfnStrToIdfunction.andP;  If the LOWORD of the returned double word is nonzero, then theHIWORD contains the new control ID.andM;/* retrieve identifier string */andM;wSize = GetDlgItemText( hDlg, ID_IDENTIFIER, szId,andM;sizeof(szId) );andM;szId[wSize] = NULL;andM;/* translate identifier */andM;dwResult = (*lpfnStrToId)( (LPSTR)szId );andM;if ( LOWORD( dwresult ) )andM;lpCtlStyle-andgt;wId = HIWORD( dwResult );andM;The PAGE4.C module (see Figure 13) contains the PageInfo function that isresponsible for allocating and defining a CTLINFO data structure.andP;  Once thisstructure has been defined, a handle is returned to the calling application.andO;It then becomes the calling application's responsibility to release thememory associated with this handle when it is no longer needed.andM;The last file, PAGE5.C (see Figure 14), contains the PageFlags function.andP;  Asmentioned previously, this function is responsible for converting controlstyle flags into their text string equivalents.andP;  In situations where multipleflags are appropriate, they can be combined with the bitwise OR operator.andP;  Inthis case, since the Page control does not define any private style flags, noaction is taken.andM;To build the Page control library, you need the Windows 3.0 SDK, Microsoft C5.1 or 6.0, and Microsoft Macro Assembler.andP;  The result will be PAGE.DLL, aDLL that you can experiment with using the Windows 3.0 Dialog editor orreference in your own application using the associated import library.andM;Using Installable Controls in Your ApplicationsandM;Before you can use an installable control in an application, you must includethe appropriate header file and register the control with the system.andP;  Ifyour control is defined in a module linked into your application, you mustensure that the initialization function is called before the control class isused in a window or dialog box.andP;  If your control is incorporated into alibrary with the mechanisms described previously, you can load the library(and thus register the class) in one of three ways.andP;  The first method isreferencing the library initialization function explicitly in the importsection of the module definition file (DEF) associated with your application.andO;If you do this, Windows will automatically load all the referenced librarieswhen it loads your application.andP;  If you wanted to use the Page control inyour application, for example, the following statement in your DEF file wouldcause the library to be loaded:andM;IMPORTSandM;Page.PageInitandM;The second method involves an explicit reference to one of the controllibrary functions inside your application.andP;  For example, in certainsituations you might want to call the control information or style functions.andO;If you create an import library for your installable control (using theIMPLIB facility) and include it with the list of object libraries searchedduring the linking of your application, Windows will automatically load thecontrol library when resolving these external references.andP;  In the process ofloading the library, the control initialization function will be called, andyour control will be registered with the system.andM;The third approach is a manual one in which you explicitly load and free thedesired control library.andP;  The advantage of this approach is that youcompletely control how the library is used, even to the extent of enablingthe user to determine which library is used (much as is done by the DialogEditor).andM;The following code fragment demonstrates this:andM;/* definitions */andM;HANDLE        hCtlLibrary;andM;/* load the library */andM;hCtlLibrary = LoadLibrary( &quot;PAGE.DLL&quot; );andM;if ( hCtlLibrary ) {andM;/* USE THE CONTROL HERE */andM;/* release the library */andM;FreeLibrary( hCtlLibrary );andM;Using the ControlandM;Once you have made sure that your library will be loaded successfully, youcan use the new control throughout your application, even as a child of anexisting window.andP;  If you wish, you can create child windows based on thecontrol class using an explicit CreateWindow function call.andP;  The followingcode fragment shows how an instance of the Page control can be created:andM;hWnd = CreateWindow(andM;&quot;Page&quot;,andM;&quot;&quot;,WS_CHILD | WS_TABSTOP,andM;8,andM;8,andM;64,andM;64,andM;hWndParent,andM;ID_PAGE,andM;hInstance,andM;NULLandM;);Note the specification of the control class (&quot;Page&quot;), the use of appropriatestyle flags, and the definition of a unique ID value that will be associatedwith the control.andM;Once the control has been created, the parent window will be responsible formanaging many of its activities, such as displaying or hiding the control,repositioning it whenever the parent window size changes, and processing allnotification messages generated by the control.andM;Using installable controls in dialog boxes is easier than creating themyourself, because Windows performs many of the routine tasks for you.andO;Windows creates dialog boxes from templates defined in your resource file.andO;Once your control library has been loaded, all you need to do to use thecontrol is reference the public header file associated with it in yourresource file, and use the following control placement statement inside eachdialog box template:andM;CONTROL andless;textandgt;, andless;idandgt;, andless;classandgt;, andless;flagsandgt;,andM;andless;xandgt;, andless;yandgt;, andless;widthandgt;, andless;heightandgt;andM;For example, the following statements define two instances of the Pagecontrol:andM;CONTROL &quot;&quot;, ID-PAGE1, &quot;Page&quot;,andM;WS_CHILD | WS_TABSTOP, 8, 8, 64, 64andM;CONTROL &quot;&quot;, ID_PAGE2, &quot;Page&quot;,andM;WS_CHILD, 24, 24, 64, 64andM;Using installable Controls with the Dialog EditorandM;Another way to use installable controls in your applications is with the newWindows 3.0 Dialog Editor.andP;  Before you can use an installable control in theDialog Editor, you must formally make it part of the Windows environment.andO;One way to do this is to edit your WIN.INI file manually, creating a sectionthat specifies the association between each control class name and the DLLresponsible for it.andP;  To add the Page control to Windows this way, you wouldadd a statement such as the following to your WIN.INI file:andM;PAGE=C:\WINDOWS\SYSTEM\PAGE.DLLandM;The second and perhaps easier method is to load the Dialog Editor and selectAdd Custom Control under the File menu.andP;  When you do this, the dialog box inFigure Is will be displayed.andP;  Using this dialog box you can specifyinstallable controls with either of two options.andP;  The first option specifiescontrols permanently and requires the use of a DLL.andP;  First, copy the DLL toyour SYSTEM subdirectory.andP;  Then select the first option in the dialog box andenter the full pathname of the library supporting the control.andP;  This optioncauses an entry to be made automatically in your WIN.INI file associating thecontrol class with this DLL (as previously described).andP;  From then on, thiscontrol can be used in the Dialog Editor in the same manner as any predefinedsystem control.andP;  The advantage of this process is that the control isrepresented accurately on the screen and you can select the control stylesdefined by the library.andM;The second option is temporary and does not require the use of a DLL todefine the control.andP;  If you choose this option, simply enter the name of thecontrol class in the edit field provided.andP;  The Dialog Editor will then letyou work with this control class.andP;  It will be represented on the screensimply as a rectangle with the class name centered inside (see Figure 16).andO;Temporary control classes must be redefined each time you run the DialogEditor.andM;Once you have defined an installable control, you can start using it insideyour dialog boxes.andP;  To place a custom control in the new dialog box, selectthe Custom option under the Control menu.andP;  This will display the dialog boxshown in Figure 17.andP;  Select a control class from this dialog box.andP;  A previewof the control you have selected is displayed on the right side of the dialogbox.andP;  You will then be returned to the editor to place the control in thesame manner used for predefined system controls.andP;  Or you can simply use theDialog Editor toolbox.andP;  Make the toolbox visible by selecting the Toolboxoption under the Options menu.andP;  Select the tool in the lower right corner todisplay the control selection dialog box (see Figure 17).andM;You can change the style of a custom control after it has been placed.andO;Select the control, then either double-click inside the control or select theStyles option under the Edit menu.andP;  A dialog box, defined by the control'sDLL itself, will be displayed.andP;  For example, when the Page control isselected, the dialog box in Figure 18 is displayed.andP;  Using this dialog boxyou can define the identifier associated with the control.andP;  For moresophisticated controls you can experiment with the various styles supportedby the control class.andP;  In some cases, this dialog box will also display asmall sample of the current control style in the lower right corner.andP;  Whenyou have specified the new control style, click OK.andP;  The control in yourdialog box will be updated automatically to reflect the changes you havespecified.andM;You can also use the Dialog Editor to remove temporary or permanent controlclasses.andP;  Select the Remove Custom Control option under the File menu; adialog box that lets you select the control class to be removed will bedisplayed.andP;  If the control was permanent, the Dialog Editor will release theassociated DLL and update your WIN.INI file.andP;  However, the library may remainin memory if other applications are still using this control class.andP;  Also,you cannot remove a class (either permanent or temporary) in the dialog boxcurrently being edited.andP;  When you remove custom controls from the DialogEditor, the DLL associated with the removed control is not deleted from yourhard disk.andM;ConclusionandM;Although the process of designing, creating, and using an installable controlcan be quite complicated, the end result is well worth the trouble.andP;  With alittle effort, you should be able to create a custom collection ofinstallable controls that you can use over and over again when buildingWindows applications.andO;</TEXT></DOC>