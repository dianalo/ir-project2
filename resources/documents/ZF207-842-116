<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-842-116  </DOCNO><DOCID>07 842 116.andM;</DOCID><JOURNAL>UNIX Review  Oct 1989 v7 n10 p91(5)* Full Text COPYRIGHT Review Publications Co. 1989.andM;</JOURNAL><TITLE>Sensitive protection. (C advisor)(file protection) (column)</TITLE><AUTHOR>Arnold, Ken.andM;</AUTHOR><SUMMARY>C-language function calls for setting protections on files arediscussed.andP;  UNIX handles access permissions via a 12-bit octalnumber, with nine bits governing user access; 4, 2 and 1 coverread, write, and execute permissions.andP;  The 'chmod()' call letsusers set the access permissions on an existing file; the'creat()' call takes the mode as its second parameter.andP;  'Unmask'is a set of permission bits that are 'unset' at the time of filecreation.andP;  The 'unmask'() function call specifies what permissionsother users should not have by default.andP;  An 'access()' routinelets the user ask whether specific access to a file is availablebefore going ahead with planned actions; it takes the path name tothe file or directory as a parameter.andP;  'Stat()' uses many fieldsto check for specific filenames; only a few of these pertain toprotections.andP;  Programmers should exercise caution in assigningfile permissions.andM;</SUMMARY><DESCRIPT>Topic:     File DirectoriesData SecurityAccess ControlsFile ManagementC Programming LanguageProgramming Instruction.andM;</DESCRIPT><TEXT>SENSITIVE PROTECTIONandM;Today we're going to talk about protection.andP;  No, not protection from socialdiseases, you dirty-minded people.andP;  Protectopms on files.andM;A little explanation about file access bits is probably in order.andO;Internally, the way the system handles access permissions is by use of a12-bit octal number.andP;  The lower nine bits (three octal digits) are those thatgovern access by users.andP;  The octal numbers are each a bitwise-or of 4, 2, and1, for read, write, and execute permissions respectively.andP;  Read/writetogether would be 6 (4:2), and read/execute would be 5 (4:1).andP;  An Is -I showsthese symbolically; for example: -rw-rw-r--  1 arnold  4555 Aug 25 15:39misc.2andM;This translates to an octal mode of 0664: read/write for user (6), read/writefor group members (6), and read-only for other (4).andP;  The top three bits arethe setuid bit (4), the setgid bit (2), and another bit that is useddifferently on different systems (1).andP;  A setuid program is one whoseeffective user-id is that of the owner of the file, not the person runningthe program (which is what would be the case otherwise); setgid has the sameeffect for the group-id.andP;  A setuid/ setgid program might have mode 06711, andlook like this under an Is -I: -rwsr-s--x  1 arnold  455 Aug 25 15:39 misc.2andM;The &quot;s&quot; in the usual spot for the user and group &quot;x&quot; indicates that this is asetuid or setgid file.andM;chmod()andM;You can set the access permissions on an existing file by using the chmod()call: chmod(path, mode) char  *path; int  mode;andM;The first mistake everyone makes using chmod() is to forget the fact thatthey are typing modes in C, not from the command line.andP;  The shell commandchmod knows that numerical modes must be in octal, so you can type: chmod 666file_my_nails Butthe C call: chmod(&quot;file_my_nails&quot;, 666); would actually beequivalent to a mode 01232, since the 666 is in decimal.andP;  You must rememberto type: chmod(&quot;file_my_nails&quot;, 0666); to get it right.andP;  Don't worry--eventhough I've warned you, you'll forget at least once.andM;A chmod() call can only work on a file you own and will return - if it fails.andM;creat()andM;The mode is the second parameter to creat(): creat(file, mode) char  *file;int mode; which creates the file if it doesn't exist truncates it if it does,and returns a file descriptor.andP;  This is what fopen() uses when you give themode parameter as &quot;w&quot;.andM;umask()andM;Your umask is a mask of permission bits to unset when a file is created.andO;This may sound a little backwards, but it is actually quite correct.andP;  Whatyou say with your umask is what permissions you don't want to allow otherpeople to have by default.andP;  Thus, a text editor creating a new file cancreate it with mode 0666, for example.andP;  If you don't like giving everyonewrite access to your files, however, you can set your umask to 02 and it willturn off write permission for the world automatically (mode 0664) when thefile is created.andP;  Each process has a umask, and the initial umask isinherited by child processes.andP;  Normally you should not have to manipulatethis yourself, but sometimes it is the easiest way to make sure that a fileis created with exactly the permissions you asked for.andP;  The umask call is:int umask(new_mask) int  new_mask;andM;The umask() call returns the original mask, so you can reset the mask bystoring that value and calling umask() again with it when you are ready to goback to the original value.andM;access()andM;The routine access() allows you to ask if you have specific access to a filebefore you actually try to do something.andP;  This could be very useful--you maywant to know that a file is executable, for example, before going through theoverhead of fork()ing a new process to run it (see &quot;C Advisor&quot; in Vol.andP;  6 No.andO;8).andP;  Or you might want to know that you can write a file before you gochurning away, generating data to write into it, only to find that in the endyou can't dump the data out.andP;  It would be better to fail first.andM;(By the bye, opening the file for writing at the beginning, which is oneobvious way to accomplish this, should be done only cautiously, since itdestroys any data that is already in the file.andP;  If users interrupt quickly,they may already have lost the data.andP;  If you aren't ready to write yetanyway, it is better not to trash existing data.)andM;The format for access() is: access(path, mode) char  *path int mode;andM;The path is the pathname to the file or directory; mode is the mode you aretrying to test.andM;The mode is fairly easy to remember--it exactly correlates to the octal modesyou give to chmod--04 is read, 02 is write, 01 is executable.andP;  You can orthese together to test for multiple permissions simultaneously.andP;  The returnvalue will be 0 if all of the requested permissions would be granted, and - 1if not.andP;  If the mode is 0, the file will be tested simply for existence.andP;  Ifyou're on a BSD system, and you'll get symbolic constants for these bits;R_OK is 4, W_OK is 2, X_OK is 1, and F_OK is 0 when you #include [is lessthan]sys/file.j[is greater than].andM;The first caveat is that you can't take the reponse at face value.andP;  The modeis tested against the permissions, not against actual abilities.andP;  Forexample, if you test a directory for write access, and access() returns 0,this does not mean that you can open it for writing.andP;  It means that writeaccess is available to the filesystem object that you named.andP;  Fordirectories, this means that you can create files in the directory, or deletefiles from it.andM;A more subtle problem (that is, alas, sometimes a feature) is that thepermissions are checked against the real user-and group-ids, not theeffective ones.andP;  This means that for setuid or setgid programs, the answerfrom access() will indicates not the program's actual access abilities, butwhat the user's access abilities would be.andP;  The use of this is clear--itallows your setuid program to know whether the user would be able to dosomething if he or she didn't have the special privileges granted by thesetuid program, which can be used to decide if you really should do somethingfor them.andP;  The problem, is if a program using access() is run from a setuidprogram, it will also indicate the user's permissions, not those of theprograms.andP;  A program whose author expected it to be setuid can work aroundthis problem, but a program that isn't intended to be a setuid program willuse access() and assume that it talks about its own capabilities.andM;What is certainly needed is either a different routine--one that checksagainst the effective user and group ids (which is what setuid and setgidset) -or a flag to invoke this behavior in access().andM;Under UNIX System V, you can toggle back and forth between the effective andreal user-and group-ids, so it would be possible to write a routine yourselfthat did a swap of the effective and real ids, called access(), and thenswapped back.andP;  On a BSD system, making your effective id into your real id orvice versa is a one-way trap door, so this would not be possible.andM;stat()andM;There's this function called stat().andM;Often, just saying this is enough to send novices who think they're expertsscreaming off toward the horizon.andP;  (Learning that trick alone might besufficient justification for reading this column.)andP;  The reason is that stat()uses lots of fields, some that are essential and others that are evil blackmagic which you should almost never look at.andP;  The data you need is oftenencoded in the legitimate fields, and to truly understand stat() requiressome access to true guru enlightenment.andM;We aren't going to go into much of that here.andP;  We're just going to talk aboutthe piece that is relevant to protections, because that's how you ask whatthe protections on a file are.andM;The format for stat() is: # include  andless;sys/types.handgt; # include andless;sys/stat.handgt;stat(path, sbuf) char  *path; struct stat  *sbuf;andM;The return is 0 if successful, and -1 if the file could not be accessed.andO;There are many fields in the stat() structure, but we will only talk aboutone of them here, namely st_mode.andP;  It has the 12 bits talked about above,plus possibly some other stuff in the top bits.andP;  There is a macro that is thesetuid bit, so: sbuf.st_mode andamp; S_ISUID would test to see whether the file hadthe setuid bit on; S_ISGID is, equivalently, the setgid bit.andP;  As for theaccess permission bits, in order to make sure that you're just looking at theright bits, you first must mask off other stuff: int  prot_mode; struct stat sbuf; prot_mode = sbuf.st_mode andamp; 0777;andM;You may then check for exact modes or for specific permissions.andP;  You shouldbe careful here, though; a file may say you can write to it, but it may be ona read-only device.andP;  And again, as for access(), the protections are notliteral but semantic--write permission does not necessarily mean you can openthe file for writing.andP;  Generally you should not need to look at thepermissions directly, but if you do, make sure you really need to, and do itcarefully, since there are lots of special cases.andM;There is a variant of stat() called fstat() that takes a file descriptor, andso can be called on files that are already open.andP;  The stat() call isexpensive, and so should be used sparingly; fstat() is a somewhat faster.andO;The format is: fstat(file_desc, sbuf) int  file_desc; struct stat  *sbuf;andM;The file descriptor is the result of a creat() or open() call; if you'reusing stdio (and you probably should be, for portability reasons), you canget this via the fileno() macro: FILE  *inf; struct stat sbuf; inf =fopen(file, &quot;r&quot;); fstat(fileno(inf), andamp;sbuf);andM;On BSD systems, there is a variant of stat() called Istat() that follows softlinks; stat() will return information for the link itself, rather than forthe target the link points at.andM;Delving further into the arcana of stat() is something we'll leave to afuture column (you should live so long).andM;You should generally be careful about permissions on files you create--don'tput execute permission on a file unless you actually intend to run it as aprogram.andP;  You should allow the user's umask to pick out unwanted bits; thepermissions for user, group, and other on the arguments to creat() shouldgenerally be the same (umask doesn't override chmod()).andP;  You should be goodboys and girls until next time, when Uncle Ken will tell you more things youshould do, like sending him large piles of unmarked bills...andM;While at the UC Berkeley, Ken Arnold worked on the UNIX system project thatproduced 4.0 and 4.1BSD.andP;  During that time, he authored curses andco-authored rogue.andP;  He now does Randamp;D work in the User Environment Group atApollo Computer, a subsidiary of Hewlett-Packard Co.andO;</TEXT></DOC>