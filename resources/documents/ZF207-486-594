<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-486-594  </DOCNO><DOCID>07 486 594.andM;</DOCID><JOURNAL>Computer Language  August 1989 v6 n8 p63(5)* Full Text COPYRIGHT Miller Freeman Publications 1989.andM;</JOURNAL><TITLE>Multiple inheritance in C++; version 2.0 of the language standardlets objects inherit from multiple forebears. (ATandamp;T C++)</TITLE><AUTHOR>Miller, William M.andM;</AUTHOR><SUMMARY>The multiple inheritance capabilities introduced in version 2.0 ofATandamp;T's C++ translator facilitates the development of thelanguage's library of code objects as well as their reuse.andO;Multiple inheritance involves the creation of a class of codeobjects that may combine attributes of two base (parent) classes.andO;This adds a fourth kind of relationship, composition, to the threeother types that exist between classes: specialization, extension,and incremental modification.andP;  The major advantage of multipleinheritance is the ability to combine pre-existing objects in newways.andP;  The major debit with multiple inheritance is theintroduction of code ambiguities because of increased complexityof class relations.andP;  Examples of multiple inheritance form baseclasses are described.andM;</SUMMARY><DESCRIPT>Product:   AT and T C++ 2.0 (Translator) (usage).andO;Topic:     Object-Oriented ProgrammingImpact AnalysisProgram Development TechniquesFunctionsC Programming Language.andO;Feature:   illustrationprogram.andO;Caption:   Base classes. (program)andM;</DESCRIPT><TEXT>Multiple Inheritance in C++ Although it has been over two years since thelast release of cfront, ATandamp;T's source-to-source C++ translator, the languagecontinues to evolve in response to the needs of its users.andP;  This process willbecome apparent with v. 2.0 of the product (expected to appear prior to thepublication of this article) and in forthcoming compatible releases of othercompilers.andM;The language definition embodied in v. 2.0 will contain enough new bells andwhistles to please just about everyone, including useful capabilities such asan expanded list of overloadable operators and greater control over objectallocation.andP;  Probably the most eagerly anticipated addition, however, ismultiple inheritance.andP;  Even the language's author, Bjarne Stroustrup,lamented its absence in his 1986 book, The C++ Programming Language.andM;Just what is multiple inheritance?andP;  What is it good for?andP;  To answer thesequestions, we must review the concepts of ordinary single inheritance.andM;InheritanceandM;Inheritance, along with encapsulation and late binding, is one of thefoundation of object-oriented programming.andP;  In C++, inheritance is expressedby deriving one class from another:andM;class B {...}; class D: public B {...};andM;Class D is said to be derived from class B, the base class.andP;  Consequently, itinherits the attributes of class B; that is, B's data members and memberfunctions are also considered to be members of D, and if they are publiclyaccessible in B, they will also be accessible in D.andM;Inheritance can be used to express at least three different types ofrelationships among classes:andM;* Specialization--the derived class is a more specific kind of base class.andO;For example, a triangle class could be derived from a shape class or a mammalfrom an animal class.andM;* Extension--the derived class has all the features of the base, along withsome extras.andP;  For instance, a text editor might be derived from a textbrowser or inspector by providing member functions that modify the text.andM;* Incremental modification--the derived class is similar to the base classbut has a small number of deletions or changes.andP;  To turn the precedingexample on its head, if a text editor class exists, a browser can be derivedfrom it by disabling the functions that modify the text.andM;In C++, inheritance also provides the avenue for support of anotherfundamental aspect of object-oriented programming: late binding.andP;  A pointeror a reference to a base class can be used to refer to a class that has beenpublicly derived from it (Listing 1).andM;It is also possible to convert a pointer to a base class into a pointer to aclass derived from it.andP;  Converting from a derived pointer to a base pointeris guaranteed to be safe.andP;  The reverse conversion, however, can be erroneous(if the object pointed to is actually of a different derived class from thatgiven in the conversion), so an explicit cast is required.andM;By itself, the ability to treat an object of a derived class as if it were abase class object is not terribly useful.andP;  Support for late binding reallyrequires another C++ feature: virtual functions.andP;  A virtual function allows aderived class to provide its own version of a base class member function;that version will be invoked for derived class objects, even if the call isdone through a pointer or reference to the base class.andM;Consider a base class that represents graphical objects on a display screen.andO;Every derived class will need a different version of a draw() member functionto render it onto the screen.andP;  This kind of relationship is described in C++as shown in Listing 2.andM;Base classes that declare virtual functions are typically (but not always)abstract classes.andP;  An abstract class is one for which no objects exist; itonly provides a pattern from which other classes can be derived.andM;These capabilities, base/derived interchangeability and virtual functions,make it possible to write code that is independent of the actual type ofobject being handled.andP;  This is the essence of late binding.andM;The ability to treat an object of a derived class as if it were a base-classobject is restricted to public derivation.andP;  Private derivation (substitutingprivate for public before the name of the base class in the derived classdeclaration) prevents interchangeability.andP;  This restriction would be usefulif, for example, you are deriving a browser from an editor.andP;  You don't wantto allow a user of the class to circumvent the disabling of thetext-modifying member functions simply by using a pointer to the base classto refer to the browser object!andM;Multiple inheritanceandM;Multiple inheritance is useful when a given class is required to have one ofthe relationships described with more than one base class.andP;  In effect,multiple inheritance introduces a fourth kind of relationship: composition.andO;A class may be constructed by composing (combining) several existing classes.andM;Consider the following situation.andP;  You have a simulation program of somesort, including a class simulated object that is used to model objects beingsimulated.andP;  You also have a graphical system with a class displayable objectthat is used to represent pictures on the screen.andP;  Now you want to integratethe two systems so you can watch the simulation via graphical output.andM;Ideally, you would want a single class that could function as either asimulated object or a displayable object, depending on its context.andP;  Objectsof the new class should be able to respond to draw() and move() requests likea displayable object and to process control requests like a simulated object.andO;In addition, it should be possible to place an object of the new class on alist of either of the existing classes, requiring the kind of base/derivedinterchangeability afforded by single inheritance.andP;  The newmultiple-inheritance mechanism of the v. 2.0 C++ language definition providesall these capabilities in a very straightforward fashion, although it usessyntax a bit different from that hypothesized in Stroustrup's book.andM;Listing 3 is a relatively simple example that illustrates several importantconcepts.andP;  First, the public keyword must be specified for each base classdesired; derivation may be either public or private for each base independentof every other base.andM;Second, virtual functions work in multiple inheritance just as they do withsingle inheritance.andP;  In this case, tick(), draw(), and move() are all virtualfunctions, and you would expect the implementation of displayable simulatedobject to provide its own version of each.andM;A third point (not illustrated in Listing 3 but equally important) is thatpointer and reference conversions between base and derived classes work justas in single inheritance.andP;  The pointer arithmetic required to make the resultpoint to the correct portion of the composite object is suppliedautomatically by the conversion.andM;AmbiguitiesandM;Although multiple inheritance can be as straightforward and simple as singleinheritance, the introduction of more advanced capabilities will bringadditional complexity.andP;  In multiple inheritance, this complexity manifestsitself primarily in the area of ambiguities.andM;Consider the code fragment in Listing 4.andP;  The problem is that D inheriteddeclaration of f() from both B1 and B2.andP;  The inheritance is not an errorbecause it is only a potential ambiguity.andP;  The compiler is forced to issue anerror message only when an ambiguous reference occurs.andP;  In this case, theambiguity can be resolved by specifying which f() is intended and typingeither d.B1::f() or d .b2::f().andP;  In general, however, it is unwise to forceclients of class D to write such disambiguating references.andP;  The more typicaland friendly approach would be for D to provide its own member function, f().andO;The body of D::f() would then choose the inherited function(s) to invoke,using explicit class qualification.andM;These ambiguity considerations explain a restriction on the list of classesfrom which a class may be derived: a given base class may not appear morethan once.andP;  It would not be possible to refer unambiguously to any membersinherited from a class that appeared more than once in the list of baseclasses.andP;  Since such a derivation would be useless, it is illegal.andM;This restriction is not as severe as it might seem.andP;  A class inherits notonly the members of the classes from which it is directly derived, but alsothe members of classes from which its bases were derived.andP;  Considering theentire derivation hierarchy, a class may indeed inherit from another classmultiple times via intermediate classes.andM;Consider the example of the displayable simulated object.andP;  A program willtypically need to keep a list of all the objects being simulated and anotherof objects displayed on the screen.andP;  One way this can be done is to deriveboth simulated object and displayable object from a class such as listelement (Listing 5).andP;  This derivation hierarchy causes displayable simulatedobject to inherit the members of list element twice, once for eachintermediate base class.andP;  This result is, in fact, what is desired since youwould want each displayable simulated object to be on both the list ofdisplayable objects and the list of simulated objects, requiring two sets ofthe list element data.andM;Of course, the ambiguities inherent in multiple copies of the base classremain.andP;  Any use of the members of list element must be explicitly qualifiedwith the name of the desired intermediate class, and conversion between baseand derived pointers and references requires similar explicit disambiguation.andM;Virtual base classesandM;The displayable simulated object example demonstrates that it may bedesirable to have multiple copies of the data of a base class inherited viadifferent intermediate classes.andP;  However, some situations require theopposite behavior.andM;Consider the class hierarchy shown in Listing 6.andP;  What happens if we wish tohave a scrollable bordered window?andP;  Clearly it is only a single window, andthere should only be one instance of the data for the window class included.andO;C++ accomplishes this using virtual base classes (Listing 7).andM;All the classes in an inheritance hierarchy that declare a given base classto be virtual will share a single instance of that class's data.andP;  As aconsequence, in Listing 7, scrollable bordered window will have only one copyof the window data, corresponding to our natural expectation of what shouldoccur.andM;At first glance, it might seem odd that the intermediate classes rather thanthe ultimate derived class must take remedial action to prevent multiplecopies.andP;  This complaint is somewhat justified since the author of a givenclass cannot, in general, know whether or not it will be used in a contextthat requires virtual derivation.andM;Furthermore, it is not feasible to simply make all base classes virtual.andO;Besides the fact that the logic of the program may require nonvirtualderivation, as shown in Listing 7, a couple of significant restrictions existon the uses of virtual base classes.andM;The first limitation has to do with how virtual base classes are initialized.andO;Consider the situation in Listing 8.andP;  In this hierarchy, B is putativelyinitialized three times, each with a different argument.andP;  However, because ofvirtual derivation, only one instance of B is shared by the classes and itcan be initialized only once.andP;  When d is created, which (if any) of the threepossible values will be used to invoke the constructor for B?andM;The conflicting initializations are resolved by ignoring the initializers inthe intermediate base classes.andP;  In this case, B will be initialized with thevalue 15.andP;  (Even though D does not explicitly include B in its list of baseclasses, every class is considered to be publicly derived from every virtualbase class in its entire inheritance hierarchy.)andP;  If D had not specified aninitializer for B, the initializations in the intermediate base classes wouldstill have been ignored.andP;  In this case, B would be required to provide aconstructor with no arguments, and this default constructor would be used tocreate the object.andM;The restriction in this management comes from the fact that theinitialization specified in an intermediate base class is sometimes performedand sometimes ignored.andP;  Creating an object of class I1, for example, wouldindeed initialize B with the value 5.andP;  If the code for the class relies uponthis initialization's occurrence, serious and subtle bugs can result when theclass is used as a base.andM;The second restriction on virtual base classes is that it is not possible toconvert a reference or pointer to the base class to a reference or pointer toa class that is virtually derived from it (although the more frequentconversion in the opposite direction, from derived to base, is allowed).andP;  Theexplanation for this restriction is beyond the scope of this article; sufficeto say that the implementation of virtual base classes makes it impossible todo the normal pointer arithmetic used in these conversions.andM;Deciding whether to make a base class virtual or not seems analogous todeciding whether or not to make a member function virtual.andP;  In both cases,the author of the class cannot know the uses to which it will be put.andP;  Thiskind of decision must be based on experience and made using reasonableexpectations.andP;  If a wrong choice is made, it can be adjusted later.andO;Sometimes it might even be necessary to have multiple versions of a class,differing only in whether a given base is virtual or not.andM;In conclusion, one of the major attractions of object-oriented programming isthe promise of extensive code reuse.andP;  Since objects are self-contained andself-defining, combining them in new ways should be much easier than usingolder forms of modularity.andM;Multiple inheritance is one more way C++ facilities library development andcode reuse.andP;  In the displayable simulated object example, the simulation andgraphics packages were probably developed completely independently, perhapseven by different vendors.andP;  Being able to combine them into a single object,compatible with both libraries, is a powerful technique for leveraging off ofprevious development efforts.andM;ReferencesandM;Lippman, S.B., and Bjarne Stroustrup.andP;  &quot;Pointers to Class Members in C++,&quot; inProceedings of the USENIX C++ Conference, Denver, Colo., 1988.andM;Stroustrup, Bjarne.andP;  The C++ Programming Language.andP;  Reading, Mass.:andO;Addison-Wesley, 1986.andM;Stroustrup, Bjarne.andP;  &quot;The Evolution of C++: 1985 to 1987,&quot; in Proceedings ofthe USENIX C++ Workshop, Santa Fe, N.M., 1987.andM;Stroustrup, Bjarne.andP;  &quot;Multiple Inheritance for C++,&quot; in Proceedings of theEUUG Spring '87 Conference, Helsinki, Finland.andM;William M. Miller is president of Software Development Technologies Inc.,andO;Sudbury, Mass.andO;</TEXT></DOC>