<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-625-168  </DOCNO><DOCID>08 625 168.andM;</DOCID><JOURNAL>Communications of the ACM  July 1990 v33 n7 p117(9)* Full Text COPYRIGHT Association for Computing Machinery 1990.andM;</JOURNAL><TITLE>Object subclass hierarchy in SQL: a simple approach.andO;</TITLE><AUTHOR>Kung, Chenho.andM;</AUTHOR><SUMMARY>The object subclass hierarchy feature of object-orientedprogramming techniques provides a simple, efficient way to modelshared properties of objects in relational data base design.andP;  Thismethod also facilitates translation of object-oriented code intoStructured Query Language.andP;  Relational data bases may storeinformation about the characteristics of objects in severaltables.andP;  These data must be linked in some fashion, usuallyrequiring the user to perform necessary upkeep on the inclusionconstraints which delineate subclass membership.andP;  The viewmechanism of relational data bases can solve these difficulties bycreating virtual tables to join the objects.andP;  Such solutions mayreduce retrieval performance but permit query structures thatmaintain data base integrity and make property inheritanceautomatic.andM;</SUMMARY><DESCRIPT>Topic:     Object-Oriented ProgrammingModelingRelational data basesProgram Development TechniquesData base designStructured Query Language.andO;Feature:   illustrationchart.andO;Caption:   The major steps of database construction. (chart)Specification of object subclasses. (chart)An example of object modeling. (chart)andM;</DESCRIPT><NOTE>Only Text is presented here; see printed issues for graphics.andO;</NOTE><TEXT>OBJECT SUBCLASS HIERARCHY IN SQL: A SIMPLE APPROACHandM;In the object-oriented paradigm the real world is viewed as consisting ofobjects or object classes.andP;  Object classes have their own properties andbehavior; and hence, they can be implemented separately from each other.andP;  Asstated by Blaha et al.andP;  in [2], &quot;Object-oriented models and systems adhere tonormal forms and improves integrity between databases and applications.&quot;andM;One of the important notions of the object-oriented paradigm is the ObjectSubclass Hierarchy (OSH).andP;  An object class is said to be a subclass ofanother object class if every member of the former (object class) is also amember of the latter (object class).andP;  For example, since every student isalso a person, we can say that STUDENT is a subclass of PERSON.andP;  OSH providesa useful way for specifying property and behavior inheritance [3, 6].andP;  Forexample, students from the United States inherit the properties of persons,such as social security numbers, names, and addresses.andM;Using the relational approach, information about an object might berepresented in several base tables (i.e., tables that are actually stored inthe database).andP;  The user might need to join two or more base tables to obtaininformation about an object.andP;  Another disadvantage is that splittinginformation about an object class into more than one table requires theintroduction of the so-called (subclass) inclusion constraint.andP;  Thisconstraint means that primary key values of a table that representsinformation about a subclass must be a subset of the primary key values ofeach of the tables that represent information about the superclasses of thatsubclass.andP;  It is usually the user's responsibility to maintain the inclusionconstraints unless the system has been implemented to do so.andM;The objective of this article is to use the view mechanism of a relationaldatabase management system (DBMS) to overcome these problems.andP;  The basic ideais to define some of the object classes as join views, that is, virtualtables that do not physically exist but look to the user as if they did.andP;  Inorder to do this, we first describe the modeling concepts and constructs forspecifying the OSH.andP;  We then describe the translation of the OSH intoStructured Query Language (SQL), a relational query language.andP;  The ideadescribed in this article, however, can also be applied to other modelingapproaches.andM;Related WorkandM;The work presented in this article has a goal similar to that found in [2],which discussed the Object Modeling Technique (OMT).andP;  This is, to provide anobject-oriented modeling approach for database design.andP;  Our emphasis,however, is focused on the translation to the relational model.andP;  The modelingpart has been described in [7, 8].andP;  Moreover, we propose using views torepresent the object subclasses, while in [2], information about an objectclass is represented in one or more base tables.andP;  While OMT also supportsmethods, this article does not cover that area.andP;  Behavior (or method)modeling can be found in [7, 8], and the behavior aspect can be implementedin a similar way to the method proposed by Jacky and Kalet [6].andP;  By embeddingthe current result into Jacky and Kalet's programs, object persistence andproperty inheritance can be achieved.andP;  We plan to report on this in thefuture.andM;Similar work has also been reported in the field of semantic data modeling.andO;Tsur and Zaniolo [12] had implemented a semantic data model on top ofINGRES[C] [10], a relational DBMS.andP;  The implementation allowed objectattributes to range over object classes.andP;  Our approach does not support this.andO;Instead of using views, Tsur and Zaniolo stored all the attributes of ahierarchy in one base table and used internal codes to distinguish the objectsubclasses.andP;  Teorey, Yang, and Fry [11] described a comprehensive databasedesign methodology based on a semantic data model.andP;  The work concentrated onthe modeling and translation of the static aspect.andP;  The behavior aspect wasmodeled in a transaction language.andP;  Lyngbaek and Vianu reported in [9] themapping of a semantic data model, called Iris, to the relational model.andP;  Thestudy seemed to be of theoretical interest, (namely, using the relationaltranslations in order to determine if two Iris schemes are equivalent and tosimplify the type structure of an Iris schema).andP;  Using the methods proposedby Teorey et al.andP;  [11] and Lyngbaek et al.andP;  [9], an object subclass might berepresented in several base tables and require the introduction of theinclusion constraints.andM;We note that view update remains a problem for further research (see [4] and[13]).andP;  Due to the use of object-oriented modeling, however, the resultingtables end to be in third normal form [2], in which each nonkey attributedirectly depends on the primary key.andP;  The views that are defined are joinqueries over the primary keys of the underlying tables.andP;  Such views are easyto update, as we will see later.andM;Features andandM;ApplicabilityandM;The basic idea behind the current approch is to implement some of the objectclasses as views, which are defined as join queries.andP;  The method has severalattractive features.andP;  It is simple to implement.andP;  It requires minimal andhigh-level changes to an existing DBMS.andP;  It uses the view mechanism toprovide the user with an integral view of objects.andP;  It provides automaticenforcement of the inclusion constraints for most of the cases in whichinsert, delete, and update operations are performed.andP;  By materializing someof the views, performance degradation can be remedied in some cases.andM;The method can be applied to application having the followingcharacteristics.andP;  First, all the objects in an OSH must be identified by onlyone (i.e., the primary) key.andP;  We found it difficult to realize the surrogate(i.e., system-maintained identity) concept on an existing relational DBMS.andO;Second, the application emphasizes the provision of an integral view ofobjects and automatic enforcement of the inclusion constraints at the expenseof retrieval performance.andP;  In cases where retrieval performance is crucial,however, we can materialize some of the views to provide the requiredresponse.andP;  We will discuss performance improvement later in the article.andM;It is assumed that in between the deletion of an object from an object classand the insertion of an object having the same key value into the same class,there is an interval during which garbage collection must be performed.andP;  Thegarbage collection process is needed in order to avoid the undesiredside-effect of some deletion operations.andP;  We will illustrate this later inthe article.andP;  Further, updating of the key components of an object is treatedas a special operation.andP;  This implies that an ordinary update will not changethe key components of an object.andP;  This assumption is reasonable since thekeys of the object classes are usually stable; and hence key update is notfrequently required.andM;Outline of theandM;Design ProcessandM;Our aproach to object-oriented database design is depicted in Figure 1.andP;  Thefirst step, called conceptual modeling [7], involves the construction of areal-world model or conceptual model.andP;  The conceptual model describes theobject classes and their relationships and behavior.andP;  The construction of theconceptual model is a top-down decomposition process during whichverification and validation are performed.andP;  For instance, in [7], theautomated translation of the conceptual model into a Prolog program thatallows users to experiment with the system prototype and request changes wasexplored.andM;The verified and validated conceptual model is then implemented.andP;  Theimplementation of the conceptual model on a relational DBMS involves thetranslation of the object class specification into base tables and views andthe behavior aspect into database transactions.andM;In this article, we will focus on the modeling of the OSH and itsimplementation using base tables and views.andP;  We will discuss themodifications (if any) of the insert, delete, and update queries, which wouldmaintain the integrity of the underlying database.andP;  The transformation tobase tables and views and the modifications of queries can be easilyautomated.andM;Object SubclassandM;HierarchyandM;Real world objects are classified into object classes.andP;  Objects belonging tothe same object class have similar properties, called attributes.andP;  An objectclass can have one or more direct superclasses or subclasses.andP;  In theliterature, four types of subclass relationships have been identified.andO;Figure 2 correlates with each of the following:andM;(1) Specialization Subclass (SS) specifies overlapping subclasses of asuperclass (Figure 2a).andP;  For example, TENNIS_PLAYER and EMPLOYEE might be twooverlapping subclasses of the object class PERSON.andP;  Note that PERSON mightinclude other objects that are not TENNIS_PLAYER or EMPLOYEE.andM;(2) Disjoint Subclass (DS) specifies disjoint subclasses of a superclass(Figure 2b).andP;  For example, TENURE_FACULTY and PROBATIONAL_FACULTY might betwo disjoint subclasses of EMPLOYEE.andP;  Note that EMPLOYEE might contain otherobjects that are not TENURE_FACULTY or PROBATIONAL_FACULTY.andM;(3) Covering Subclass (CS) specifies overlapping subclasses of a superclasssuch that every object of the superclass must be an object of at least one ofthe subclasses (Figure 2c).andP;  For example, the object class EMPLOYEE mightconsist of ENGINEER, MANAGER, and SECRETARY.andP;  Note that these subclassesmight not be disjoint, e.g., a secretary might also be a manager.andM;(4) Partitioning Subclass (PS) specifies disjoint subclasses of a superclasssuch that every object of the superclass must be an object of one and onlyone of the subclasses (Figure 2d).andP;  For example, MAN and WOMAN might beconsidered two partitioning subclasses of the object class PERSON.andM;Note that the graphical representations for these four types are the same butthe labels are different.andP;  This choice facilitates the storage and processingof the graphical layout information on a computer.andM;A relationship between two object classes can be modeled by an object class,called a relationship object class.andP;  We do not intend to describe themodeling and translation of relationships in this article.andP;  The interestedreader is referred to [7[ and [8], where relationships are modeled as in theEntity Relationship model.andP;  A relationship object class can be translatedinto a base table, as proposed in [2].andP;  Alternatively, a one-to-one ormany-to-one relationship can be represented by an attribute, while amany-to-many relationship can be represented by a base table.andP;  There are prosand cons.andP;  The best translation depends on the application.andP;  In any case, itis the user's responsibility to maintain the referential integrity, that is,ensuring that the objects that are referred to by the relationship actuallyexist in the database.andM;An ExampleandM;In Figure 3 we show the modeling of five object classes.andP;  The attributes ofan object class are specified by edges linking the object class to the datatypes (represented by text in ovals) of the attributes.andP;  For instance, PERSONhas name as one of its attributes, which has type char(20).andP;  The socialsecurity number attribute of PERSON is specified as the key of the objectclass.andP;  This means that the social security number can be used to uniquelyidentify each member of PERSON.andP;  Each object class must have a primary key,and the primary key of the root object class is also the primary key of theother object classes in the hierarchy.andP;  The data type of an attribute can bea compound type; for example, the address attribute is specified asconsisting of street, city and zip code.andM;The object class ENGINEER inherits all the attributes of PERSON, sinceENGINEER is a specialization subclass of PERSON.andP;  Similarly, S_MANAGERinherits all the attributes of both SECRETARY and MANAGER.andM;Transformation toandM;Base Tables and ViewsandM;In our approach, the OSH is transformed into a set of base tables and views.andO;As described earlier, a base table is a table that physically exists.andP;  Aview, by contrast, is a virtual table whose tuples do not physically exist.andO;A view can be defined using one or more base tables or views.andP;  The tuples ofa view are computed from the defining tables when they are to be retrieved.andM;In our approach, a base table can be either internal or external.andP;  It isinternal if it is not intended to be seen by the user; otherwise, it isexternal.andP;  To distinguish between these two cases, we will use the objectclass name (e.g., PERSON) to name an external base table, and it is intendedto represent the object class PERSON.andP;  We will use REL_ [is less than] objectname [is greater than] (e.g., REL_FACULTY) to name an internal base table,and it is intended to represent some aspect(s) of the object class [is lessthan] object name [is greater than].andM;For convenience, we will use the following notations:andM;* X.K.: if X is an object class, then it denotes the set of key attributes ofX; if X is a relational table (i.e., a base table or a view), then it denotesthe set of primary key attributes of X.andM;* X.A: this is similar to X.K except that it denotes the set of non-keyattributes of X.andM;* if [T.sub.a..A={[A.sub.1], ..., [A.sub.n]} is a set of attributes of table[A.sub.a] and [T.sub.b].B={[B.sub.1], ..., [B.sub.n]} is a set of attributesof table [T.sub.b], then [T.sub.a..A=T.sub.b..B] or simply A=B) denotes theexpression [A.sub.1.=B.sub.1] and [A.sub.2.=B.sub.2] and [A.sub.n = B.sub.n].andM;Figure 4 gives the transformation rules for the four types of subclassrelationship shown in Figure 2.andP;  We have chosen to express the transformationrules in SQL because it is widely used in practice.andP;  For simplicity, we haveomitted the declarations of the data types.andM;As shown in Figure 4 and Figure 6, the root of an OSH is implemented by abase table, which is the external representation of the object class at theroot.andP;  To each of the other object classes, there will be an internal basetable and a view associated with it.andP;  The internal base table stores theobject-specific information, and the view provides the externalrepresentation of the object class.andP;  The view is defined as the join of theinternal base table and the table or view that represents the parent classover the primary key.andP;  Thus, the properties (or attributes) of the parentobject class are inherited by the child class through the use of a view, aswe will show in the next section.andP;  Since the view is defined as a join overthe primary key, updating to such a view can be translated into a uniqueupdate to the base tables.andP;  In this article, views are always named by thenames of the object classes, such as MANAGER in Figure 6.andM;An object class can have more than one superclass (e.g., S_MANAGER AGER inFigure 3).andP;  Such an object subclass can also be defined by a view, which is ajoin of the tables or views representing the superclasses.andP;  Figure 5illustrates the transformation.andP;  Note that in Figure 5b, X and Y denote theobject class table(s) or view(s) for the object classes X and Y in Figure 5a.andO;Figure 6, as an example (1), shows the transformation of part of Figure 3.andM;Better User InterfaceandM;Using views to implement the object classes of an OSH facilities queryformulation.andP;  Consider for example the implementation given in Figure 6.andP;  Theuser can obtain details for managers whose salaries are at least $50,000through the following query:andM;SELECT*FROM MANAGER WHERE SALARYandgt;=50,000;andM;Since MANAGER is a view, the DBMS first translates the query into one thataccesses the defining tables:andM;SELECT* FROM PERSON, REL_ MANAGER, REL_EMS WHERE REL_MANAGER.andP;  SS#=PERSON.SS#AND REL_MANAGER.SS#= REL_EMS.SS# AND SALARYandgt;=50,000;andM;The resulting query is then evaluated, and the results are returned to theuser.andP;  This shows how the social security number, name, street, city, and zipare automatically inherited by MANAGER.andM;Using views, the user can formulate queries in a natural way.andP;  For example,&quot;get names for persons who are secretary managers&quot; can be formulated asandM;SELECT NAME FROM PERSON WHERE SS#IN (SELECT SS# FROM S_ MANAGER);andM;Inserting an object into MANAGER is also easy, since the tuples to beinserted into PERSON, REL_EMS and REL_MANAGER can be uniquely identified.andO;For example,andM;INSERT INTO MANAGER VALUES ('123456789', JOHN KALISKY',,,,,$45,000);andM;will result in the insertion of andless;'123456789', 'JOHN KALISKY', , , andgt; intoPERSON, andless;'123456789'andgt; into REL_MANAGER, and andless;'123456789', $45,000andgt; intoREL_EMS.andP;  Thus, the inclusion constrait that a MANAGER must be a PERSON isautomatically enforced.andP;  If andless;'123456789', 'DOUGLAS JONES', ...andgt; alreadybelongs to PERSON, then the above insertion will be rejected automatically bythe DBMS.andM;Deleting andless;'123456789', JOHN KALISKY', ...andP;  andgt; from PERSON will lead to thedeletion of andless;'123456789', JOHN KALISKY', ..., $45,000andgt; from the object classMANAGER.andP;  Again, the inclusion constraint is automatically enforced.andM;A few of the insertion, deletion, and updating queries need modifications inorder to ensure the integrity of the underlying database.andM;Query ModificationandM;Representing object classes using base tables and views as described aboverequires modifications to some of the insertion, deletion, and updatingqueries.andP;  Modifications of queries can be done by implementing a querypreprocessor.andP;  We now describe the rules for modifying the queries.andM;Update of Key ComponentsandM;In practice, updating the key components is not a usual operation.andO;Therefore, in our approach we treat key component update as a special case.andO;This implies that the usual update does not involve the change of any of thekey components, and key updates modify only the key components.andM;Let T be a table (or view) and T.K={[A.sub.1], [A.sub.2], ..., [A.sub.j]} andE={[e.sub.1], {[e.sub.1], [e.sub.2], ..., ej} be the set of expressions thatwill update the key components of T.andP;  As before, we will abbreviate[A.sub.1]=[e.sub.1], [A.sub.2]=[e.sub.2], ..., [A.sub.j]=[e.sub.j] as T.K=E.andO;Moreover, let Q be a predicate expression.andP;  Then a key updating query can beexpressed asandM;UPDATE T SET T.K=E WHERE Q:andM;Such a key update is translated toandM;CREATE TABLE TEMP (T.K); INSERT INTO TEMP SELECT T.K.andP;  FROM T WHERE Q; forall base table T in the OSH do UPDATE T SET T.K=E WHERE T.K IN (SELECT * FROMTEMP); DROP TABLE TEMP;andM;Other Modifying OperationsandM;Using the transformation described in this article, only a few cases needquery modifications.andP;  Table I shows the cases where query modifications arerequired.andP;  In TAble I, NM means Need Modification (of the query); N/A meansthat the operation cannot be applied; since the user's intention is notclear; OK means no modification is needed.andM;In the rest of this section, we present the rules for modifying the queriesfor the five cases that need query modifications.andP;  Note that all these casesare concerned with changes to a subclass Y.andP;  In the other (i.e., OK) cases,it is assumed that if V is a view, which is a join of [T.sub.a] and [T.sub.b]over their primary keys, then inserting a tuple into V results in theinsertion of a tuple into [T.sub.a] and [T.sub.b.andP;  Similarly, deleting atuple from V results in the deletion of a tuple from both [T.sub.a] and[T.sub.b], and updating a tuple of V results in updating a tuple of both[T.sub.a] and [T.sub.b].andM;Deletion from a SpecializationandM;or Disjoint SubclassandM;If Y is a SS or DS of X and the operation is &quot;DELETE FROM Y WHEE Q,&quot; thenmodify the query to DELETE FROM REL_Y WHERE REL_Y.K IN (SELECT Y.K FROM YWHERE Q);andM;Insertion into a DisjointandM;or Partitioning SubclassandM;without a SELECT ClauseandM;If Y, Z1, ..., ZK are DS or PS of X and the operation is &quot;INSERT INTO YVALUES (C1, C2, ..., Cj),&quot; then modify the query to CREATE TABLE TEMP (Y.KNOT NULL, Y.A); INSERT INTO TEMP VALUES (C1, C2, ..., Cj); INSERT INTO YSELECT * FROM TEMP WHERE TEMP.K NOT IN (SELECT REL_S1.K FROM REL_Z1 UNIONSELECT REL_Z2.K FROM REL_Z2 UNION ...andP;  UNION SELECT REL_Zk.K FROM REL_Zk);DROP TABLE TEMP;andM;Insertion into a Disjoint orandM;Partitioning Subclass withandM;a SELECT ClauseandM;If Y, Z1, ..., Zk are DS or PS of X and the operation is &quot;INSERT INTO YSELECT ...andP;  FROM andless;table nameandgt; WHERE Q,&quot; then modify the query toandM;INSERT INTO Y SELECT ...andP;  FROM andless;table_ nameandgt; WHERE Q AND andless;table_ nameandgt; .K NOTIN (SELECT REL_Z1.K FROM REL_Z1 UNION SELECT REL_Z2.K FROM REL_Z2 UNION ...andO;UNION SELECT REL_Zk.K FROM REL_Zk);andM;Deletion from a CoveringandM;SubclassandM;If Y, Z1, ..., Zk are CS of X and the operation is &quot;DELETE FROM Y WHERE Q,&quot;Then modify the query toandM;DELETE FROM REL_Y WHERE REL_Y.K.andP;  IN (SELECT Y.K FROM Y WHERE Q);andM;DELETE FROM X WHERE X.K NOT IN (SELECT REL_Z1.K FROM REL_Z1 UNION SELECTREL_Z2.K FROM REL_Z2 UNION ...andP;  UNION SELECT REL_Zk.K FROM REL_Zk);andM;Garbage CollectionandM;Deleting objects from a superclass of an object class might leave useless andharmful tuples in the database that can cause undesired side effects.andO;Suppose that OBJ1 has attributes A and B with A being the primary key andOBJ2 is a subclass of OBJ1 and has attributes A, B, and C.andP;  Then, accordingto the transformation rules, we will create a base table of OBJ1 as OBJ1(A,B), where A is underlined to indicate that it is the primary key.andP;  We willalso create an internal base table for OBJ2, say REL_OBJ2 (A, C).andP;  OBJ2 isthen defined by a view, which is a join between OBJ1 (A, B) and REL_OBJ2(A,C).andM;Now suppose that the database content is as it is shown in Figure 7a.andP;  Afterdeleting object andless;a2,b2andgt; from OBJ1, object andless;a2,b2,c2andgt; vanishes from OBJ2 asFigure 7b shows, but andless;a2,c2andgt; remains in REL_OBJ2.andP;  If a new object andless;a2,b2'andgt;is inserted into OBJ1, the the undesired object andless;a2,b2',c2andgt; will occur inOBJ2 as shown in Figure 7c.andP;  In other words, the undesired effect will occurwhen an object is deleted from a parent object class, and subsequently anobject with the same primary key is inserted into the same object class.andO;Therefore, the method requires a garbage collection process to remove thosegarbage tuples.andP;  This garbage collection process must be executed oftenenough to prevent the above-undesired side effect; the frequency of runningthis process is to be determined by the application on hand.andM;The garbage collection process can be coded as follows:andM;for each internal base table REL _andless;object nameandgt; do begin let andless;object nameandgt; bethe view defined by REL_andless;object nameandgt;; DELETE FROM REL_andless;object nameandgt; WHEREREL_andless;object nameandgt;.K NOT IN (SELECT andless;object nameandgt;.K FROM andless;object nameandgt;);andM;Performance andandM;View MaterializationandM;Representing objects by join views affects retrieval performance.andP;  The exactperformance depends on the implementation of the join operation and thequery.andP;  Consider for example the join of two base tables [T.sub.1] and[T.sub.2] on the primary key.andP;  If a simple nested-loop algorithm is used,then the join can be constructed in O(|[T.sub.1]|*|[T.sub.2]|) time, where|[T.sub.i]| denotes the number of tuples stored in [T.sub.i].andP;  This meansthat the cost of joining the two tables is proportional to the product of thesizes of the two tables.andM;If the two tables are indexed on the primary key, as they are in thisarticle, then all the tuples can be directly accessed using the primary key.andO;Thus, the join can be constructed by scanning the tuples that are stored inthe smaller table and by using the primary key to retrieve the correspondingtuple in the larger table.andP;  The performance of this implementation isO(min(|[T.sub.1], |[T.sub.2]|)), i.e., it is proportional to the size of thesmaller table.andP;  As reported by Bitton, DeWitt, and Turbyfill [1], on an IDM500 connected to PDP 11/70 host, it took more than five hours to join twotables, each of which contained 10,000 tuples of length 182 bytes using asimple nested-loop algorithm.andP;  The time was reduced to only 35.5 seconds whenone of the tables was indexed on the join attribute, a significantimprovement in performance.andP;  If the selection predicate of the retrievalquery is evaluated before the join (most DMBSs do this), then the performancecan be further improved.andP;  The actual improvement depends on the selectivityof the selection predicate.andM;As mentioned earlier, we can materialize frequently accessed views to remedyperformance degradation.andP;  Suppose that the user frequently retrievesinformation from an object class OBJ (which is assumed to be a view) butseldom makes changes to it.andP;  Then we can create a base table to permanentlystore the tuples of the view.andP;  The base table is called a materialized view.andO;We name this new base table OBJ, and we name the view that defined the objectclass V_OBJ.andP;  When no confusion arises, we will also use OBJ to refer to theobject class represented by OBJ.andM;Key update to OBJ or the other object classes can be treated as before andwill not be repeated here.andM;Modifying theandM;Materialized ViewandM;If OBJ is a DS or PS and the modifying operation is &quot;INSERT INTO OBJ ...,&quot;andO;then modify the query to (See QUERY MODIFICATION section for insertion into aDS or PS)andM;INSERT INTO V_OBJ ...; INSERT INTO OBJ SELECT * FROM V_OBJ WHERE V_OBJ.K NOTIN (SELECT OBJ.K FROM OBJ);andM;Deletion from OBJ should result in deletion of the corresponding objects fromall of its subclasses.andP;  Since a subclass can be materialized ornonmaterialized, it must be treated differently.andP;  In particular, let thequery be &quot;DELETE FROM OBJ...,&quot; then modify the query toandM;{The following deletes the objects from the nonmaterialized subclasses}DELETE FROM OBJ ...; DELETE FROM REL_OBJ WHERE REL_OBJ.K NOT IN (SELECT KFROM OBJ);andM;for all materialized subclass C of OBJ do DELETE FROM C WHERE C.K.andP;  NOT IN(SELECT K FROM OBJ);andM;Updating OBJ requires updating OBJ, V_OBJ, and all the materializedsubclasses the OBJ.andP;  For simplicity, we omit the modification of the queryhere.andP;  For the other cases, we apply the modification to V_OBJ and then OBJ.andM;Modifying a SuperclassandM;of OBJandM;If X is a superclass of OBJ and the operation is &quot;DELETE FROM X WHERE Q,&quot;then modify the query toandM;DELETE FROM X WHERE Q; DELETE FROM OBJ WHERE OBJ.K NOT IN (SELECT V_OBJ.KFROM V_OBJ);andM;Updating a superclass of OBJ can be treated similarly and is omitted.andO;Insertion into a superclass does not require query modification.andM;Modifying a Subclass of OBJandM;If Y is a DS or PS of OBJ and the operation is &quot;DELETE FROM Y WHERE Q,&quot; thenmodify the query toandM;DELETE FROM Y WHERE Q; DELETE FROM OBJ WHERE OBJ.K NOT IN (SELECT K FROM Y);andM;If Y is an SS, DS, CS, or PS of OBJ and the operation is &quot;INSERt INTO Y ...,&quot;andO;then modify the query to (See QUERY MODIFICATION section for insertion into aDS or PS)andM;INSERT INTO Y ...; INSERT INTO OBJ SELECT * FROM V_OBJ WHERE V_OBJ.K NOT IN(SELECT OBJ.K FROM OBJ);andM;I Y is an SS, DS, CS, or PS of OBJ and the operation is &quot;UPDATE Y SET[A.sub.1] =[e.sub.1], [A.sub.2] =[e.sub.2], ..., [A.sub.j] =[e.sub.j],[A.sub.j]+1 = [e.sub.j]+1, ..., [A.sub.j]+k =[e.sub.j]+k WHERE Q,&quot; and[A.sub.1], [A.sub.2], ..., [A.sub.j] are the attributes of OBJ, then modifythe query toandM;UPDATE OBJ SET [A.sub.1], [A.sub.2] = [e.sub.2], ..., [A.sub.j] =[e.sub.j]WHERE OBJ.K IN (SELECT Y.K FROM Y WHERE Q); UPDATE Y SET A1=e1, A2=e2, ...,andO;Aj=ej, Aj+1=ej+1, ..., [A.sub.j+k.andP;  = e.sub.j+k] WHERE Q;andM;A thorough discussion of view materialization is not the focus of thisarticle.andP;  Above we described only the simplest way to maintain thematerialized views.andP;  There are other strategies.andP;  The differential strategyproposed by Blakeley, Larson, and Tompa [3] utilizes the view definitionpredicate (i.e., the WHERE Clause of the CREATE VIEW statement) to determinethe modification that must be performed on the materialized view when one ofthe base tables that defines the view is modified.andP;  This result can be usedwhen a superclass of OBJ is modified.andP;  The deferred view maintenancestrategy, proposed by Hanson [5], defers the modification of the materializedview until data are to be retrieved from it.andP;  Hanson's study [5] shows thatthe efficiency of the strategies depends heavily on the structure of thedatabase, the view definition, the type of query, and the modificationactivity present.andP;  The results of the study can be used to provide guidelinesfor determining whether to materialize a view and what strategy should beused to maintain the materialized view.andM;ConclusionsandM;A method for implementing object subclass hierarchy in SQL has beendescribed.andP;  The method provides an object-oriented view of data at theexpense of affecting retrieval performance.andP;  In case the retrievalperformance is crucial, however, some of the views that are frequentlyretrieved can be materialized.andP;  We have also described how queries can bemodified so that the integrity of the database can be ensured when insert,delete, and update operations are performed.andM;Property inheritance is a direct consequence of the view mechanism.andP;  Anotheradvantage is that the user does not need to worry about the inclusionconstraints.andP;  Moreover, most of the optimization techniques that have beenimplemented in the existing database management systems can still be used.andM;We have not addressed the issues of selective inheritance and overriddenattributes in this article.andP;  Selective inheritance means some of thesubclasses inherit only a subset of the attributes of the superclass.andO;Overridden attributes means that some of the attributes of the superclass canbe overridden by attributes of a subclass.andP;  The approach can be extended tocover selective inheritance by using the projection operation in thedefinition of the views.andP;  Overridden attributes can be implemented byincluding the overridden attributes in the REL_andless;object nameandgt; base table forthe subclass and excluding from the view those superclass attributes that areoverridden.andM;(1) SS# refers to &quot;social security number&quot; and should not be confused with&quot;Specialization Subclass.&quot;andM;ReferencesandM;[1] Bitton, D., DeWitt, D.J., and Turbyfill, C. Benchmarking databasesystems: A systematic approach.andP;  In Proceedings of the Ninth InternationalConference on Very Large Data Bases (Florence, Italy, Oct.).andP;  IEEE, NewJersey, 1983, pp.andP;  8-19.andM;[2] Blaha, M.R., Permerlani, W.J., and Rumbaugh, J.E.andP;  Relational databasedesign using an object-oriented methodology.andP;  Commun.andP;  ACM 31, 4 (Apr.andO;1988), 414-427.andM;[3] Blakeley, J.A., Larson, P., and Tompa, F.W.andP;  Efficiently updatingmaterialized views.andP;  In Proceedings of the International Conference onManagement of Data (SIGMOD '86) (Washington, D.C., May 28-30).andP;  ACM/SIGMOD,New York, 1986, pp.andP;  61-71.andM;[4] Gottlob, G., Paolini, P., and Zicari, R. Properties and update semanticsof consistent views.andP;  ACM Trans.andP;  Database Syst.andP;  13, 4 (Dec.andP;  1988),486-524.andM;[5] Hanson, E.N.A  performance analysis of view materialization strategies.andO;In Proceedings of the International Conference on Management of Data (SIGMOD'87) (San Francisco, May 27-29).andP;  ACM/SIGMOD, New York, 1987, pp.andP;  440-43.andM;[6] Jacky, J.P., and Kalet, I.J.andP;  An object-oriented programming disciplinefor standard Pascal.andP;  Commun.andP;  ACM 30, 9 (Sept.andP;  1987), 772-776.andM;[7] Kung, C.H.andP;  Conceptual modeling in the context of software development.andO;IEEETSE 15, 10 (Oct.andP;  1989), 1176-1187.andM;[8] Kung, C.H.andP;  The behavior network model for conceptual informationmodeling.andP;  To be published.andM;[9] Lyngbaek, P., and Vianu, V. Mapping a semantic database model to therelational model.andP;  In Proceedings of the International Conference onManagement of Data (SIGMOD '87) (San Francisco, May 27-29).andP;  ACM/SIGMOD, NewYork, 1987, pp.andP;  132-142.andM;[10] Stonebraker, M., Wong, E., Preps, P., and Held, G.andP;  The design andimplementation of INGRES.andP;  ACM Trans.andP;  Database Syst.andP;  1, 3 (Sept.andP;  1976),189-222.andM;[11] Teorey, T.J., Yang, D., and Fry, J.P.andP;  A logical design methodology forrelational databases: The extended entity-relationship model.ACM Comput.andO;Surv.andP;  18, 2 (June 1986), 197-222.andM;[12] Tsur, S., and Zaniolo, C.andP;  An implementation of GEM--Supporting asemantic data model on a relational back-end.andP;  In Proceedings of theInternational Conference on Management of Data (SIGMOD '84) (Boston, June18-21).andP;  ACM/SIGMOD, New York, 1984, pp.andP;  286-295.andM;[13] Vianu, V.A.andP;  dynamic framework for object projection views.andP;  ACM Trans.andO;Database Syst.andP;  13, 1 (Mar.andP;  1988), 1-22.andM;CR Categories and Subject Descriptors: D.2.1 [Software Engineering]:Requirements/Specifications--methodologies, D.2.2 [Software Engineering]:Tools and Techniques--user interfaces; H.1.2 [Models and Principles]:User/Machine Systems--human factors, H.2.1 [Database Management]: LogicalDesign; H.2.8 [Information Systems): Database Management--databaseapplicationsandM;General Term: Design, Human FactorsandM;Additional Key Words and Phrases: Inclusion constraints, normal forms,object-oriented, query processing, relational database, SQL, viewsandM;CHENHO KUNG is an assistant professor in the Department of Computer Scienceat the University of Iowa.andP;  He is currently a visiting staff softwarescientist at International Software Systems, Inc., Austin, Texas.andP;  Hisresearch interests include software engineering and databases.andP;  Author'sPresent Address: International Software Systems, Inc., 9430 Research Blvd.,andO;Suite 250, Austin, TX 78759.andP;  kung @issi.uucp or issi!kung@cs.utexas.edu</TEXT></DOC>