<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-100-974  </DOCNO><DOCID>07 100 974.andM;</DOCID><JOURNAL>Communications of the ACM  March 1989 v32 n3 p311(8)* Full Text COPYRIGHT Assn. for Computing Machinery, Inc. 1989.andM;</JOURNAL><TITLE>The engineering of XCON. (DEC XCON expert configurationsystem)(one of two articles)</TITLE><AUTHOR>Bachant, Judith; Soloway, Elliot.andM;</AUTHOR><SUMMARY>XCON expert configuration system is a key to DEC's 'a la carte'marketing strategy of permitting customers to specify ahardware-software system tailored to their needs.andP;  Eachconfiguration is unique.andP;  Each may have hundreds of components andhundreds of systems are configured each day.andP;  The componentdatabase and knowledge base must be continually updated.andP;  Whileautomation is clearly necessary, DEC was unsuccessful inattempting it with traditional procedural programming.andP;  XCON usesOPS5 production rule programming language.andP;  The language providesdynamic, run-time decision-making, throwing back on the programitself the critical tasks of determining what to do and when to doit.andP;  RIME software engineering methodology developed by DEC helpsmanage the size, complexity and quantity of rules.andM;</SUMMARY><DESCRIPT>Company:   Digital Equipment Corp. (management).andO;Ticker:    DEC.andO;Topic:     Expert SystemsProduct DevelopmentComputer SystemsCAD-CAMSpecifications.andO;Feature:   illustrationtable.andO;Caption:   Example of pre-RIME XCON rule. (table)Examples of RIME XNET rules. (table)Examples of RIME XCON rules. (table)Partial subgroup schema example. (table)andM;</DESCRIPT><NOTE>Only Text is presented here; see printed issues for graphics.andO;</NOTE><TEXT>THE ENGINEERING OF XCON AS Barker and O'Connor point out, XCON providescritically important support for Digital's marketing strategy of selling a lacarte systems; i.e., customers can put together a hardware/software systemthat is tailored to their specific needs.andP;  In effect, each systemconfiguration is unique.andP;  Given that each such configuration may havehundreds of components, and that hundreds of systems are configured each day,this marketing philosophy would be difficult to manage without a high degreeof automation.andM;In automating the configuration task, Digital needed to confront a number ofserious issues: there are 30,000+ hardware and software parts that are drawnupon; there is a hefty body of knowledge about how to configure a system; andthere is no way to identify beforehand what specific configurations might beproduced--the combinatorics are substantial.andP;  A further complication involvescoping with the following fact: the component database and the knowledge basemust be continually updated to reflect new products, new marketingstrategies, changing government regulations, new user requests, etc.andP;  Thesecharacteristics raise the question about the suitability of this task forautomation.andP;  Prior to XCON, Digital attempted to tackle the configurationtask using traditional procedural programming languages--without success.andO;Rather, the breakthrough came when the configuration task was viewed from theperspective of production rule programming.andP;  In particular, OPS5, aproduction rule programming language, provided mechanisms for coping with akey aspect of automating the configuration task: the program deciding what todo and when to do it.andM;In general, customer orders are highly variable, and thus the determinationof what actions need to be performed to configure an order must be madedynamically, at execution time, as the order is being processed.andP;  Decidingwhen an action can appropriately occur in relation to other actions is alsosensitive to this variability in the customer order.andP;  While two systemconfigurations may well need most of the same actions to occur, evenostensibly slight differences in the configurations may dictate variations inthe sequence of activities due to complex interactions between components andconstraints.andP;  Thus, procedural languages, with their commitment topre-determined sequences of activities with relatively limited branching, donot provide the flexibility at run time that is needed to cope with the&quot;what&quot; and &quot;when&quot; characteristics of the configuration task confrontingDigital.andM;In contrast, the production rule programming paradigm explicitly provides thedynamic, run-time decision-making that was essential.andP;  The foundation forprocessing in OPS5, a production rule language, is the recognize/act cycle.andO;In the OPS5 language, the &quot;working memory&quot; holds global state information:inputs and results of rule actions.andP;  The conditional part of a productionrule (the &quot;if&quot; part) specifies tests on that working memory; if all theconditions are satisfied by matches in the working memory, then the actionpart of the rule (the &quot;then&quot; part) is executed, which in turn changes workingmemory in some way.andP;  Changing working memory means updating or deletingexisting elements that match conditions in the rule, or creating newelements.andP;  Furthermore, the method of selecting what to do next in OPS5differs substantially from that in a procedural language.andP;  In the case of aprocedural language, the amount of global state information needed for such adecision is, quite deliberately, severely limited: the program counter isincremented by one, or a small set of tests in a conditional statement isused to select what to do next.andM;In OPS5, the entire rule set is examined in light of the change to theworking memory (global state), in order to select which rule to execute next.andO;Each rule must carry its own complete triggering context in order to identifyits scope of applicability.andP;  (This type of control will be referred to lateras &quot;situation recognition.&quot;) These properties of OPS5 provide the flexibilityand variability needed for the task.andM;COPING WITH COMPLEXITY AND CHANGE IN XCONandM;In Figure 1, we present a representative rule from pre-1988 XCON.andP;  (For easeof readability, the rules in all the figures are English renderings of actualOPS5 rules.)andP;  This rule deals with positioning a disk drive within anenclosure and connecting the disk to its controller.andP;  Notice first the numberof test conditions in the conditional part of the rule; before this rule canactivate, a great deal of information must exist in the global state.andP;  Thesituation described is complex and each condition is annotated to indicatewhy it is needed and what might happen if it were absent.andP;  Some of theconditions are needed in order to actually take the action specified.andP;  Thismay involve identifying what element in working memory needs to be updated.andO;For example, the disk being configured needs to be identified (C4), since oneaction involves marking it as such and other actions use its identifiers increating the connecting and containing relationships to other components.andO;Other conditions, like C2, specify the general context of applicability forthe entire rule.andP;  Still others look for cues signaling that related actionshave occurred previously or have not yet occurred, in order to insure thatthis rule will activate at the appropriate time.andP;  Part of C4 specifies that acontroller has already been assigned to the disk.andP;  This rule cannot activateuntil a controller has been assigned as a result of the activation of someother rule.andP;  C11 looks for specific unused spaces in a particular type ofcabinet, since if there are such spaces, it is not yet time for this rule toexecute.andP;  The OPS5 language effectively supports and efficiently processesthis degree of conditional specification.andP;  XCON was successfully implementedin this manner.andM;As Barker and O'Connor point out, key to XCON's success has been its abilityto grow and change in response to both Digital's product offerings and theever expanding user base.andP;  Since XCON is continually evolving, the ability tomodify, extend, and develop code efficiently is of paramount importance.andO;Enhancing developer productivity became an increasingly important priority asthe demands resulting from the success of the application mushroomed.andP;  Towardenhancing productivity, we needed to better manage the size and complexity ofrules, and better manage the sheer quantity of rules.andP;  The RIME softwareengineering methodology [1, 12, 13] was developed to achieve these desiredbenefits.andP;  XCON was reimplemented utilizing this methodology and the newimplementation has been in production use since January 1988.andP;  RIME was alsoused in the design and development of XNET (an expert system that configurescomputer networks--see Barker and O'Connor).andP;  We will now focus on two ofRIME's major prescriptions: RIME's guidance in specifying control in aproduction rule context, and RIME's guidance in organizing a rule base.andM;NEW CONTROL TECHNIQUESandM;Problem-Solving Methods:andM;Specifying Algorithmic ControlandM;OPS5 supports &quot;situation recognition&quot; as its only form of control.andP;  Followingthe principles of pure production rule programming style, one should notforce the firing of rules in a fixed sequence.andP;  However, the reality is thatthere are times when one wants to implement an algorithm, and thus execute aset of rules in some specific sequence.andP;  Rule developers did, in fact, usesituation recognition to implement algorithm-like rule sequencing.andP;  What RIMEhas done is recognize that algorithms can and should be specifiable in aproduction rule context, and it provided explicit techniques for theirdefinition.andP;  In RIME, pre-defined algorithms are referred to asproblem-solving methods.andM;Problem-solving methods, then, are defined at development time--not at runtime--and are composed of steps; each step of a method may contain one ormore rules.andP;  Upon entry to a step, the rules fire (using &quot;situationrecognition&quot;) until all satisfied rules have been activated, and thenprocessing proceeds to the next step.andP;  For example, in Figure 2 we presenttwo rules from the &quot;change-characteristic&quot; problem-solving method used inXNET, an interactive system for specifying a computer network.andP;  This methodallows a user to interact with XNET and change the characteristics of a partof the network (e.g., server, host, segment, etc.).andP;  The rule in Figure 2a isfrom the &quot;ask-value&quot; step of the method; in this step, the user is asked fora value of a network characteristic that the user wants to change.andP;  The rulein Figure 2b is from the &quot;reset&quot; step of this same method; as the last stepit performs finalization activities, in this instance marking thecharacteristic as no longer identified as needing to be changed.andP;  There arealso a number of other rules in each of these two steps.andM;Using this type of control reduces the amount of situation specification inthe conditional part of the rule, since locating a rule within apre-determined process eliminates the need for the individual rule to specifywhere it fits in that context.andP;  The individual rule's situation specificationneed not include reference to when it needs to activate in relation to rulesin other steps of the process.andP;  In this case, without &quot;algorithmic&quot; control,one or more conditions would need to be added to the situation specificationof the rule in figure 2b to prevent it from activating before its time in theprocess (e.g., after the rule in Figure 2a fires).andM;Deliberate Decision Making:andM;Explicitly Choosing Among AlternativesandM;As the rule in Figure 1 illustrates, XCON rules tend to be complex.andP;  Thisrule actually makes a number of decisions implicitly in the course ofrecognizing its applicability (e.g., selecting an appropriate disk, selectinga cabinet in which to place it, selecting a particular place within thecabinet), all in order to configure a disk.andP;  In effect, each rule that dealtwith configuring a component needed to make sure that a constellation ofcomponents was available; such a need resulted in complex conditional partsof rules.andP;  Given the large number of rules that had such complex conditionalparts, it became quite difficult to update the rules in light to new productannouncements, etc.; it was hard to know if one had found all the rules thatneeded changing.andM;In contrast, RIME's philosophy is that complex rules need to be broken down;in particular, multiple tasks need to be factored out and each task needs tobe made into an explicit, separate process.andP;  For example, in the newimplementation of XCON, there is a set of rules that accomplishes the task ofselecting a device (tape, disk, etc.), a set of rules that accomplishes thetask of selecting a container for another component (cabinet, box, etc.), andanother set of rules that accomplishes the task of selecting the particularlocation within the container to place the other component.andP;  Notice that allof these tasks are embedded in the conditional part of the rule in Figure 1.andM;The effect of accomplishing each of these tasks is to create intermediateresults; components are selected, and made available to other tasks upon thecompletion of the task.andP;  In effect, these tasks work together to build up theset of components needed in order to perform the various activities involvedin configuration.andP;  Thus, each rule can assume a certain amount of thespecification as being accomplished; thus, rules, such as those in Figure 3,need only test those features of the state that are relevant to theirspecific task (e.g., selecting a particular disk).andM;Now that there are explicit tasks that need to be carried out, the questionarises as to which tasks to execute and in what order.andP;  What RIME prescribes,in situations in which a choice must be made among competing alternatives, isthat tasks to be accomplished are first proposed, and that there be anexplicit arbitration process that examines the alternatives and selects oneto carry out.andP;  We term this type of control technique &quot;deliberate decisionmaking&quot; since we want to emphasize the need to have rules that deliberatelyexamine the set of proposed tasks and decide, for specific, identifiablereasons why one task should be preferred over some others.andM;Putting It All Together:andM;An Example Illustrating Three Types of ControlandM;The activity in the &quot;proposed-apply&quot; problem-solving method provides examplesof all three types of control techniques.andP;  Propose-apply was derived from the&quot;universal weak method&quot; developed by the researchers involved with the SOARarchitecture [5].andP;  The method is utilized fairly extensively in XCON becauseof the preponderance of complex decisions.andP;  The steps of the method include:proposing operators, eliminating the less desirable ones, selecting one, andperforming the operation specified.andM;Figures 3, 4, and 5 present rules in three steps of the propose-apply method.andO;The method, in this instance, is used for the task of configuring a device.andO;The rules in Figures 3a and 3b are both from the propose step, and thus bothput forth alternative suggestions.andP;  In this case, the alternatives are taskstehmselves: 3a proposes to accomplish the task of selecting a device (tape,disk, etc.) to configure, while 3b proposes to accomplish the task ofselecting a container (box, cabinet, etc.) in which to place a device.andP;  Therules in Figures 4a and 4b belong to a subsequent step (the eliminate step)in the method, and arbitrate between the two alternative tasks suggested inthe previous step by the two rules in Figure 3.andP;  Deliberate decision makingis this arbitration  process: there are explicit rules that propose tasks,examine the proposed tasks, and choose which one to carry out.andM;Note in particular, that the rule in Figure 4a prefers one of the tasksproposed, while the rule in Figure 4b selects the other activity.andP;  The choiceof whether 4a or 4b fires depends on the specific situation, (i.e., usingsituation recognition, these rules will fire depending on the details of theparticular system configuration).andP;  Once the alternatives are narrowed to one,the apply step is entered.andP;  In this example, the rule in Figure 5 willactivate since either alternative involves performing a new task.andP;  The newtask will commence alternative involves performing a new task.andP;  The new taskwill commence (either selecting a device of selecting a container) and whenit is finished, control will return to the previous task, configuring adevice.andM;After, for instance, the task of selecting a device completes and controlreturns to the task of configuring a device, other tasks may be proposed, andthen eventually performed, until all of the required intermediate results areavailable.andP;  At this point, the task of actually performing the functionalityof configuring a device will be proposed and selected.andP;  Once selected, theactions (corresponding to those performed by the &quot;then&quot; part of the rule inFigure 1) will be performed: actually marking the device configured, placingit in the cabinet, connecting it to its controller and specifying theappropriate cabling, etc.andP;  This method is used for the configuration of othertypes of components, and at its highest level for the process of configuringa system.andM;In summary, there are three forms of control that developers using RIME canemploy.andP;  If the task they are implementing can be accomplished through asequence of steps with little variation, using algorithmic control isencouraged.andP;  The developer makes decisions at development time about whatshould happen when during execution.andP;  Developers are encouraged to make thesealgorithms as general as possible to allow for their reuse in otherinstances.andP;  If there is  significant variation in what activities need tooccur when depending on different inputs, situation recognition or deliberatedecision should be examined.andP;  Each of these provides a means for the programto participate in the decision process.andP;  Situation recognition should be usedif the conditions and actions are straightforward and limited.andP;  Deliberatedecision is most useful for managing complex situations with many variationsand interactions.andP;  RIME has identified guidelines for aiding the developer indeciding between the last two forms of control.andM;RIME's Guidelines for Organizing the rule BaseandM;In addition to making explicit three types of control, RIME also prescribesexplicit criteria for organizing the rule base.andP;  For many years, XCONdevelopers have been in the habit of attempting to physically co-locate rulesthat had some commonality.andP;  However, as the complexity of the rules increasedand the number of them grew, it became increasingly difficult to actuallyco-locate similar rules.andP;  It was hard to datermine the most criticalsimilarity since there were so many dimensions to choose from.andP;  There were nodefined (and agreed upon) strategies for the organization so there was littleconsistency among different developers.andP;  Also, the reason for co-locatingspecific rules was not explicitly recorded.andP;  Another developer needed toinfer the commonality from reading the rules.andP;  Since rules developed underRIME were less complex with the reduction in the number of conditions needingto be specified and with the limiting of functionality per rule, it easeasier to see how they could be organized appropriately.andP;  The use of thecontrol mechanisms already provided some organization based on thatdimension.andP;  However, within a step in a method there may still be hundreds ofrules for whom the sequence of their activation is irrelevant.andP;  The rules inthe same step need to be grouped along some other dimension.andP;  Moreover, thedimensions may vary among the steps.andP;  RIME requires that the criteria forgrouping be explicitly identified and recorded in &quot;subgroup schemas.&quot;andP;  Theseschemas, much like database schemas, provide abstrations describing sets ofrules that allow developers to efficiently index into the rule base.andP;  Theschema in Figure 6 presents the organization for the &quot;apply&quot; rules forconfiguring a device.andP;  These rules actually perform the functionality ofmarking a device configured, connecting it to a controller, placing it in acontainer, etc.andP;  These actions are similar to the actions in the rule inFigure 1, but they are distributed among many rules.andP;  These rules are groupedaccording to their functionality.andP;  The action of a &quot;200&quot; rule would updatethe status of a component, a &quot;320&quot; rule would reduce the capacity availablein the container in which the device was placed, etc.andP;  The dimensions forspecifying organizing criteria may vary between steps.andP;  Since all of the&quot;eliminate&quot; rules nsee Figures 4a and 4b) do exactly the same thing (actuallyremoving from working memory the alternative matching C3) organizing by typeof action would not be an effective strategy.andM;THE BENEFITS OF RIMEandM;Recall that RIME was intended to provide guidance for the engineering of theevolving expert configuration systems at Digital.andP;  In particular, thecojectives were to reduce the size and complexity of an average rule, andbetter manage the increasing number of rules.andP;  RIME's impact was feltdramatically in the reimplementation of XCON.andP;  For example, the appropriateuse of the three available control techniques and the limiting of a rule'sfunctionality led to smaller, more intelligible rules.andP;  Compare, forinstance, the rule in Figure 1 with the RIME rules in subsequent figures.andO;Both the use of the control techniques and the introduction of subgroupschemas aided in the management of large quantities of rules.andP;  While at firstglance it may appear that the RIME methodology might require more rules andmuch more processing to perform the same task, that turned out not to be thecase.andP;  The difference in quantity of rules was not significant: the smaller,more general rules can apply in a variety of situations.andP;  In fact, in addingnew rules, one can now more easily take advantage of existing rules, and thusknowledge reuse results in a major productivity gain.andP;  The actual number ofrule firings or activations did increase significantly.andP;  However, the actualprocessing time difference was negligible, since the OPSS language canprocess the less complex rule network more efficiently.andP;  In fact, the timerequired per rule was an order of magnitude less, which compensated for thegreater number of firings.andP;  When the newly reimplemented XCON was released,the users did not notice any change in performance either in accuracy orspeed of execution.andP;  (The average cpu time to process a customer order, on aVax 8800 with 128 MB of memory, is under a minute.)andP;  In contrast to theusers, the developers definitely have noticed the difference inmaintainability.andP;  The smaller rules are easier to understand, the differencesbetween them are more pronounced, and they are much better organized.andM;THE FUTURE:andM;VERY Large Configuration Expert SystemsandM;The RIME methodology continues to undergo change as we gain more experiencewith it in building industrial-strength, expert configuration systems.andP;  Inaddition, we are currently implementing a RIME Programming Environment thatwill help the developer better follow the RIME guidelines.andP;  In sum, ourexperiences with RIME support its utility in serving to increase both theproductivity of our developers and the quality of the expert configurationsystems.andP;  Inasmuch as we fully expect our configuration systems to haveupwards of 20,000-30,000 rules in the near term, we believe that the RIMEsoftware development methodology can play a critical role in the engineeringof this next generation of expert systems.andM;Acknowledgments.andP;  We are grateful to Bill Hanson, Digital's Vice President ofManufacturing, and Lou Gaviglia, Vice President of U.S.andP;  Manufacturing, fortheir commitment to and sponsorship of the configuration systems efforts overthe years.andP;  This support has insured the positive environment which hasenabled us to proceed, experiment, and make significant impacts.andP;  We wouldalso like to thank John McDermott, Ken Gilbert, Bob Breau, and Anne Van Tinefor their inputs on this article.andP;  And finally, it is important toacknowledge the ongoing dedication and hard work of all the members of theCSDG who have made this effort so successful and given us this story to tell.andM;VIRGINIA E. BARKER has been manager for the Configuration Systems DevelopmentGroup and XCON program manager at Digital Equipment Corporation (DEC) since1982.andP;  She received an S.B.andP;  degree from Massachusetts Institute ofTechnology in 1970.andM;DENNIS E. O'CONNOR is the senior group manager for the Intelligent SystemsTechnologies group which is part of the Digital Artificial Technology Center.andO;XCON is one of the many expert systems for which his group is responsible.andM;JUDITH BACHANT is a principal software engineer in the Configurations SystemsDevelopment Group at DEC.andP;  His work includes defining software engineeringpractices for expert systems.andM;Authors' Present Address: Barker, O'Connor and Bachant, Digital EquipmentCorporation, 290 Donald Lynch Blvd., Marlboro, MA 01752, DLB5-2/E5.andM;ELLIOT SOLOWAY is an associate professor in the Department of ElectricalEngineering and Computer Science at the University of Michigan, where he is amember of the Artificial Intelligence Laboratory.andP;  He is a consultant toseveral firms and government agencies, including DEC.andP;  Author's PresentAddress: Department of EECS, University of Michigan, Ann Arbor, MI 48109.andM;Permission to copy without fee all or part of this material is grantedprovided that the copies are not made or distributed for direct commercialadvantage, the ACM copyright notice and the title of the publication and itsdate appear, and notice is given that copying is by permission of theAssociation for Computing Machinery.andP;  To copy otherwise, or to republish,requires a fee and/or specific permission.andO;</TEXT></DOC>