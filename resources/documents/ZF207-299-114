<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-299-114  </DOCNO><DOCID>07 299 114.andM;</DOCID><JOURNAL>Dr. Dobb's Journal of Software Tools  June 1989 v14 n6 p46(6)* Full Text COPYRIGHT Mandamp;T Publishing Inc. 1989.andM;</JOURNAL><TITLE>Variable-level programming. (technical)</TITLE><AUTHOR>Fischer, Ronald.andM;</AUTHOR><SUMMARY>Variable-level programming, a new concept in programminglanguages, is a good compromise in system-software situationswhere assembly language is too complex but the full use of ahigh-level language would weaken performance.andP;  Two new languagesusing the variable-level concept are FUTURE86 and CDL2.andP;  FUTURE86was developed from FIFTH, an attempt to improve on Forth, whichitself allows the implementation of several levels of code withinone language.andP;  It consists of 'words' which can be combined withstatements from its own assembler for flexibility.andP;  CDL2 is madeup of 'actions' which perform operations, Boolean tests,functions, and 'predicates,' which may either fail or succeed.andO;Actions may call each other, and any action may be defined as anassembly-language macro.andP;  The use of variable-level programming isexpected to grow in the next 20 years.andM;</SUMMARY><DESCRIPT>Topic:     Programming LanguagesSystems ProgrammingPerformance ImprovementLanguage ComplexityVariable-Level Languages.andM;</DESCRIPT><TEXT>VARIABLE-LEVEL ProgrammingandM;Looking back at approximately 30 years of steady development of programminglanguages, there is no doubt that development strives towards moregenerality, more abstraction, and--last but not least--more expressionalpower.andP;  The first assembler programs of the early 1950s were a giantachievement over machine code (binary) programming.andP;  Later, the first socalled high-level language was invented by software pioneer John Backus.andO;This language was called Fortran, and its descendant, Fortran 77, is still inuse today.andM;The next development in programming languages was known as &quot;nonprocedurallanguages&quot; (sometimes called 5th-generation languages, a term that I do notlike because it has become rather worn over the years).andP;  The very sameexpression is used today not only for pure database languages like SQL,Nomad, and RAMIS but also for true general-purpose languages such as Prolog.andM;No one debates that you can code a given problem much faster using, say,Prolog rather than assembler.andP;  We call this modern approach &quot;high-levelprogramming,&quot; compared to the &quot;low level&quot; of assembly language.andP;  So why doassemblers still exist?andP;  As every system programmer knows, there aresituations where you have to use assembler.andP;  Most operating system kernelsare, for instance, written in assembler.andP;  Even the famous Lilith machine,designed in the early 1980s by a design team led by Pascal inventor NiklausWirth, had a few critical routines written in machine language, although mostof the operating system was coded in Modula-2.andP;  The reasons for suchdecisions are--in most cases--speed, but sometimes space considerations alsoplay a critical role.andM;On the other hand, given a sufficiently huge problem, like coding a multiuseroperating system, it becomes too complex for the human grain to manage atassembly level.andP;  In most applications, a mix of assembler and high-levellanguage (HLL) is used.andP;  Examples are the PICK operating system(Basic+assembler) and some of IBM's mainframe operating systems (PL/1 andassembler).andP;  One could call this approach &quot;two-level programming,&quot; becauselanguages at precisely two different levels are used.andM;When developing system software, two-level programming is often anunsatisfactory solution: For much of the code, the HLL is &quot;too high,&quot; butassembly language is too &quot;low.&quot;andP;  System programmers therefore have beenlooking for languages that can better accommodate the range of needs.andP;  Wecall a programming language that satisfies this property &quot;variable level.&quot;andM;Many experiments were carried out in this area during the late 1960s andthroughout the 1970s: BCPL, BLISS, SPL3000 (Hewlett-Packard) and Siemens SPLare just a few examples.andP;  Three languages, however, proved to be verysuccessful: C, which was used to write the Unix operating system, PL/M usedfor system programming by Digital Research, and Charles Moore's Forth.andP;  Butonly the latter really earns the tag &quot;variable level,&quot; because neither C norPL/M, despite their success, provde a single framework for systemprogramming: Both Unix and Digital Research's Concurrent CP/M contain someassembler code and the user does not have much influence on the degree ofabstraction or &quot;level&quot; of the statements used.andM;Forth is different.andP;  A Forth program consists of a collection of words(similar to functions or procedures in other languages).andP;  Each word in turnis composed of other words.andP;  The user therefore may assign to eachconceptional level (or abstraction layer) a family of Forth words that aredefined in terms of lower-level words only.andP;  The assembler is integrated intothe language and represents the bottom level.andP;  In practice, this means that afunction for searching through a text file uses high-level Forth words likeEOF?, GET-NEXT-LINE, OR MATCH-PATTERN, while an interrupt hander manipulatesbits and bytes.andM;Variable-Level ApproachesandM;Recently two new languages aimed at variable-level programming have gainedattention from system programmers:  FUTURE86 and CDL2.andP;  The remainder of thisarticle covers some of the main features of these languages.andP;  For comparisonpurposes, two sample programs are coded in FUTURE86 and CDL2.andP;  Because manyreaders may be familiar with C, these sample programs are described first inC.andP;  All programs were developed on a 80386 system running PC-DOS 3.3.andP;  Thecompilers used were MIX Power C, Development Associates FUTURE86, and epsilonCDL2Lab.andM;The first example is a subroutine, AUXOUT, which sends one character to theserial device (called AUX under DOS).andP;  This is an example oif a low-levelsystem dependent function, because it is unlikely that the very same callexists on different operating systems.andP;  Although DOS, for example, has oneprimary serial port--namely AUX--other operating systems might always requirean identification of which serial interface to use.andM;Most C compilers support some generic interface to the host system.andP;  Forexample, Power C has among its functions a routine called bdos, which acceptsthree parameters and generates an INT 21H interrupt to call DOS.andP;  Theparameters are placed in the registers AH, DX, and AL, respectively, andcorrespond therefore to funtion code, function argument, and function codeparameter.andP;  For this example, a quick look in IBM's DOS Technical ReferenceManual tells that we have to use 4 as the function code (auxiliary output)and the character to be output as arguments.andP;  The code parameter is not used;we deliberately set it to zero.andP;  Listing One (see page 92) shows theresulting function.andM;The second example is of much higher level.andP;  Suppose we have two characterstrings, S and T, and one character transformation function XTRANS, whichaccepts one character and delivers an arbitrarily transformed character.andP;  Theobjective is to design a function SFILT, which appends S to T, but by doingso applies XTRANS to every character of S.andP;  For this example, we assume thatthe array holding T must be large enough to also accommodate S.andM;As an application, imagine that you want to send one record of a binary fileto the printer.andP;  Because the data may also contain nonprintable characters,such as escape sequences, we cannot blindly output the record.andP;  Instead, eachnonprintable character should be replaced by a dash.andP;  This could beaccomplished with SFILT in the following way: Let S be the record to beprinted, let T be a sufficiently large buffer containing the string.andP;  &quot;RECORD#12 (non-printables replaced by '-'):&quot; and finally let XTRANS be the functionthat maps nonprintable characters into dashes and leaves others unchanged.andM;For the sale of brevity assume in the example a fixed function named XTRANS;in practice, this function itself would be passed as a parameter for addedflexibility so that different calls of SFILT could use differenttransformation functions.andP;  For the same reason, no concrete implementation ofXTRANS is given.andM;The resulting C program is shown in Listing Two (page 92).andP;  Efficiency is notthe primary goal, however, because FUTURES86 and CDL2 are biased towardsrecursive function calls, we will also use recursion in the C example.andP;  Thismakes it easier to compare the examples.andP;  In a real project, of course, youwould use a loop.andM;The FUTURE86 LanguageandM;The history of FUTURE86 dates back to 1979.andP;  At this time Akira Katagiri, aJapanese scientist, implemented a Forth compiler for a Z-80-basedmicrocomputer system.andP;  During this work, he found some deficiencies in thislanguaguage, most notably the lack of readability.andP;  He then devised asuccessor, appropriately called FIFTH, and implemented it on differentenvironments.andP;  FIFTH is widely used in Japan.andM;FUTURE86 is an evolution of FIFTH created during the 1980s.andP;  The firstcompiler was commercially available in 1987.andP;  Like FIFTH, it augmented thepower of Forth without being just another Forth dialect.andP;  Despite its shorthistory, FUTURE86 has already been used to implement numerous projects.andP;  Forexample, software for sophisticated, automatic postal scales and a naturallanguage compiler has used FUTURE86.andP;  Like Forth, every FUTURE86 programimplicitly operates on two stacks, called the data stack (that is, &quot;stack&quot;)and the return stack.andP;  These names are a little bit misleading, because thereturn stack may also contain temporary data in addition to return addresses.andO;Most predefined functions, however, operate on the data stack.andM;An expression is written in reverse polish notation (RPN).andP;  The sentence 1527 101 + for instance pushes the numbers 15, 27, and 101 sequentially ontothe data stack.andP;  The operation &quot;+&quot; then consumes the two topmost elements, 27and 101, and replaces them by their sum.andP;  The data stack now contains thenumbers 15 and 128.andP;  For readers unfamiliar with Forth or the Hewlett-Packardpocket calculators, this may look strange.andP;  In practice, you soon getacquainted with this type of operation.andM;Not everything in FUTURE86 is RPN, however, because this paradigm onlyapplies to the evaluation of programs.andP;  Compile time expressions, on theother hand, are written in the more traditional infix notation.andP;  Thefollowing statements, for instance, set MAXLENGTH to 1024.andP;  BUFSIZE  EQU 256NO-OF-BUFFERS  EQU 4 MAXLENGTH EQU  BUFSIZE * NO-OF BUFFERSandM;In fact, every sentence may contain compile time expression in infix notationby enclosing them in parentheses, like this: 17 (34 * 45 + 8) VAR @ OVER -andM;Other differences from Forth concern the dependency between words: BecauseFUTURE86 was designed as a compiled language, two-pass compilation allowsextensive forward referencing.andP;  This even applies to different compilationunits: It is common practice for words in different modules to mutually calleach other.andM;FUTURE86 also contains an assembler.andP;  Unlike Forth, assemblerstatements--which may be freely intermixed with FUTURE83 words--follow thesyntax generally available on the target machine.andP;  On a 80186 system, youcould for example, write: BOUND BX,[TEST-LOC] inside any high-leveldefinition.andP;  It is therefore the responsibility of the programmer to selectthe desired abstraction level at every single line of code!andM;Other minor differences from Forth concern the usage of some reserved words.andO;The FUTURE86 version of LOOP functions, for example, is slightly differentthan its Forth counterpart.andM;Now let's look at how the sample programs are written in FUTURE86.andP;  ListingThree (page 92) demonstrates one possible solution of the AUXOUT problem.andO;The definition of AUXOUT, as every definition of a new word, starts with acolon, followed by the name of the function.andM;We assume that the character to be output is located on the stack.andP;  That is,to send the escape character to the serial interface you write: 27 AUXOUT.andO;The predefined word !DL pops the top value from the stack and stores it inthe pseudo CPU DL register.andP;  Of course, words like !DL are hardwaredependent.andP;  The next word, AUXOUT-FUN, pushes this constant onto the stack,which now contains the number 4 only; the 27 is still in pseudoregister DL.andO;Then, the word INT_21H is called.andP;  This function removes the top value of thestack (4), uses it as DOS function code (that is, pushes it into AH) andperforms an interrupt (21 hex).andP;  The semicolon closes the definition.andM;At first, words like !DL seem strange for programmers getting used totraditional languages such as Fortran or Pascal.andP;  In reality, however, eventhis enhances readability.andP;  Because FUTURE86--such as Forth or Lisp--is notcommitted to the traditional &quot;Letter+Digit&quot; identifiers, one can devise moremeaningful names, like: IS-THERE-STILL-ROOM-IN-THE-BUFFER? which, by the way,is a perfectly legal FUTURE86 word.andP;  In the case of !DL, one needs tounderstand that the exclamation mark is generally used in the context &quot;storefrom stack into ...,&quot; while the character &quot;@&quot; does the inverse.andM;The SFILT program in Listing Four (page 92) is more complicated.andP;  Thefunction XTRANS was--for testing purposes--defined as nonoperation, which isthe shortest possible function definition.andP;  To comprehend SFILT, you have tounderstand FUTURE86's unique string concept.andM;A string always consists of two parts: A string buffer somewhere in memory,holding left justified the string characters, and a control block calledSINFO (String INFOrmation), consisting of a pointer to the buffer and alength field.andP;  For string operations the SINFO is stored in the data stack.andO;The simplest way to create a string is to place it within a quote, like this::HELLO &quot;Hello world!&quot; SPRINT;andM;The execution of HELLO would allocate a place in memory, large enough to holdall the characters, place the appropriate SINFO on the data stack and callthe word SPRINT (String PRINT), which causes the string to be printed.andM;Our definition of SFILT assumes that the SINFO's of the destination string Tand the source strings S (in that order) are placed on the stack.andP;  On return,these SINFOs should be replaced by the updated SINFO of the destinationstring.andP;  This behavior of SFILT is depicted in the comment line labeled&quot;stack flow.&quot;andM;Following the C example SFILT starts by determining the source stringslength, which is the second part of its SINFO and therefore on top of thestack.andP;  Because IF consumes its argument, this data item has to be duplicatedby the word SLEN.andP;  Many FUTURE86 functions remove their arguments from thestack, so this is quite a common operation.andM;The next steps (CGET and XTRANS) remove the first character from the sourcestring and transform it.andP;  The following three lines temporarily save thecharacter to the return stack, interchange the stack position of the twoSINFOs, then restore the character to the stack.andM;The word C+ appends the character to the destination string.andP;  Then, theSINFOs stack position is interchanged again SFILT is recursively called.andM;The ELSE part simply discards the now empty SINFO of the source string fromthe stack to fulfill the functional description of SFILT.andP;  The word THENmatches the IF and is similar to Fortran's ENDIF statement.andM;The lines below demonstrate the usage of SFILT.andP;  The destination buffer iscalled DEST and may hold up to 80 bytes.andP;  This buffer is initialized with thefunction SETUP.MAIN calls SETUP, then SFILT, and finally prints the resultingstring using SPRINT.andP;  This also shows how words work together: As mentioned,SFILT leaves the destination string's SINFO on the stack which, in turn, isconsumed by SPRINT.andM;The CDL2 LanguageandM;CDL2 is a radically different language.andP;  It's precursor was CDL (compilerdescription language), a generator used to produce compilers from a givenaffix grammar.andP;  The first implementation of CDL took place at the MathemticalCenter in Amsterdam (The Netherlands), and soon it became popular at a numberof European universities.andM;In 1974 the language was extended by adding modularity and the ability toserve as a general-purpose programming language --CDL2 was born.andP;  Since 1980it has become available outside the university community.andP;  It has been usedfor numerous commercial applications: A Cobol compiler from the Germancompany MBP, the Prolog compiler MProlog, Mephisto (a chess computer), andEUMEL are but a few examples.andP;  EUMEL is a German operating system featuringthe programming language Elan, which is targeted to education institutions(high schools, universities, and so on).andM;There are four basic elements of a CDL2 program: actions, tests, predicates,and functions.andP;  The most traditional form is the action: A piece of code thatperforms some operations, possibly changing its environment.andP;  The function isa similar construct, but preserving the environment like a mathematicalfunction.andP;  A test is a special function that delivers a Boolean result.andM;Depending on the outcome, succeeding statements in a clause are skipped orexecuted.andP;  Finally, a predicate is an action that may either fail or succeed.andO;Failure causes backtracking so the behavior is similar to Prolog clauses.andM;Every building block (action, test, and so on) may itself call other buildingblocks, in the same way FUTURE86 words may call other words.andP;  There are,however, no primitives in CDL2!andP;  The programmer therefore has to define thebottom layer himself.andP;  This is accomplished by defining an Action as a Macro,that is, consisting of assembly language instructions only.andP;  The same istrue, of course, for tests, predicates, and functions.andP;  For simplicity, Irefer in the sequel to &quot;actions&quot; only when I mean all four kinds of buildingblocks.andP;  Unlike FUTURE86, assembly statements and high-level CDL2 statementscannot be intermixed when defining an action.andM;To put different actions together is, however, not sufficient to produce aCDL2 program.andP;  The language was definitely designed forprogramming-in-the-large, for projects requiring a large staff, anddelivering tens of thousands of code lines.andP;  Therefore, the design of theproject is an integral part of the language.andM;All actions belonging to the same topic are grouped in a SECTION.andP;  A set ofsections forms a LAYER (see Listing Five, page 92).andP;  Layers can be thought ofas stacked one on top of another.andP;  Each layer must explicitly state whichactions are exported to or imported from other layers.andP;  The top layer, forinstance, could represent the specification of the problem.andP;  The next layerthen could be a prototype, and by step-wise refinement, we reach the bottomlayer, consisting of the applications low-level words.andP;  Therefore, mostassembly language will be found in this bottom layer but not necessarily all:This is completely up to the designer.andP;  So, variable-level programming maynot only be accomplished by thinking in words or statements but in a moregeneral abstract entity, the layer.andM;Different layers together form a MODULE.andP;  A module is vaguely related toseparate compilation units in other programming languages.andP;  In practice, eachprogrammer on a CDL2 project will work on one and only one module at a time.andM;Finally, different modules together form a PROGRAM.andP;  It should be clear bynow that CDL2 was designed to be only used for large applications.andP;  Wetherefore only sketch our example programs by defining a few actions, leavingout the lowest part and overall program organization.andM;Listing Six (page 92) shows the layout of the AUXOUT action.andP;  As in theprevious examples, the DOS function code is defined by a compile timeconstant.andP;  Note that for improved readability CDL2 identifies may containembedded spaces as that constant has been called &quot;AUXOUT FUN.&quot;andM;The action AUXOUT expects one parameter C, the character to be output.andP;  EveryCDL2 statement consists of a procedure evocation (where a procedure could beaction, test, predicate or function) and actual parameters are separated byplus signs (+).andP;  Statements are separated by commas (sequential execution) orsemicolons (parallel alternatives).andM;The action header follows the same format but states the formal parameters.andO;In addition, the type of the parameter (input, output, or inout) is specifiedby placing the 'andgt;' character to the appropriate side (left, right, or both)of the parameter name.andP;  In this example C is therefore an input parameter.andP;  Acolon at the end of the header line specifies the ACTION as containing CDL2statements.andP;  An equal sign would specify it as assembly language action.andM;The subsequent three lines load the registers and perform the interrupt.andP;  Inthis particular example I also enclosed the definitions necessary to get theassembly instructions: The CDL2 words used in this small example are definedin the last three lines of Listing Six.andM;SFILT is only loosely sketched, because a complete CDL2 implementation wouldbe beyond the scope of this article.andP;  As can be seen from Listing Seven (page92), the destination string TARGET is defined as an out parameter because itwill be modified during evaluation of the action.andP;  Note also the differentusage of semicolon and comma to separate the statements.andM;ConclusionandM;Today there is no generally accepted opinion on how a programming languageshould look.andP;  This begins with the schism between functional programming (noassignment statements, no state change, no loops, no history),object-oriented programming (every object has its own history) andtraditional imperative programming (&quot;let Cobol and Fortran live forever!&quot;)andO;and ends with debates if Basic should be allowed/forbidden in high schools.andO;Industry programmers and scientists agree only on the fact that we have somekind of software crisis (we would like to do much more programming but we donot know how to manage it).andM;Variable-level programming is certainly a good compromise for those projectswhere performance considerations prevent the complete usage of a high-levellanguage.andP;  Very likely this will still be true for at least the next 20years.andM;Due to its roots in grammar analysis CDL2 may attract even more attention inthe near future.andP;  As parallel processing becomes more feasible, rule-basedlanguages, like CDL2 or Prolog, could benefit immediately by new technologiesbecause they are easily expandable to cope with simultaneous exploration ofdifferent, but parallel branches or rules.andM;In the next century we will likely have hardware that runs Smalltalk, Prolog,or Miranda at the speed of a today's 8086 object code.andP;  Maybe then we will nolonger require FUTURE86, CDL2, or their future successors.andP;  My opinion,however, is that the requirements of projects will increase--at more orless--the same rate of the performance of new hardware.andP;  The problems mayshift slightly, but they won't disappear.andM;NotesandM;The examples have been developed using the POWER C compiler by MIX Software.andO;This is one of the least expensive C compiler available but is complementedwith the debugger CTRACE, a very powerful development tool and probably the Ccompiler with the best price/performance ratio available.andP;  For furtherinformation, contact Mix Software, 1132 Commerce Dr., Richardson, TX 75081.andM;At present, only one implementation of FUTURE86 is available in the U.S.,andO;although in Japan a similar version is sold by RIGY Corp. The U.S.andP;  versionis available from Development Associates.andP;  It runs under PC/MS-DOS andcontains code generators for both the 8086 and 80186.andP;  Other instructionsets, like the protected mode instructions of the 80286 processor, can beuser defined with a CODEMACRO facility.andM;The compiler comes complete with debugger (FDT86) and libraries for CGAgraphics, serial communications, Hayes and XModem protocols, and floatingpoint.andP;  Libraries are delivered in source code; thus, the graphics librarymay be extended to accommodate EGA or VGA formats.andP;  An optional debugger(REM86) is available for target use the functions via the serialcommunication line.andM;Although the debugger commands are line oriented and remind me of the nowobsolete Microsoft SYMDEB, it has a powerful operation mode called &quot;F-mode.&quot;andO;In this mode, FUTURE86 commands may be entered interactively, and it is evenpossible to compile new words.andP;  In this respect FDT86E acts similarly to aninteractive Forth environment and had proven useful for debugging the exampleprograms.andP;  For more information, contact Development Associates, 1520 SouthLyon, Santa Ana, CA 92705andM;The implementation used was the PC-DOS version of CDL2LAB from the Germancompany epsilon.andP;  Several other versions are available from epsilon,including versions for OS/2 (IBM PS/2), VMS (VAX), NOS(Cyber 180), BSD Unix(VAX), and Unix V (Sun 3/50, PCS Cadmus, Nixdorf Targon).andP;  Code generatorsfor cross compilation are also available for TOS (Atari) and even the goodold CP/M.andM;CDL2LAB extends the CDL2 compiler by providing an integrated environment,grouped around a central database.andP;  Documentation is available in English.andO;For further information on CDL2, contact epsilon, Kurfurstendamm 188/189, D1Berlin 15, W. Germany.andO;</TEXT></DOC>