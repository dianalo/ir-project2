<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO> ZF32-041-205 </DOCNO><DOCID>11 370 117</DOCID><JOURNAL>AI Expert  Oct 1991 v6 n10 p13(3)* Full Text COPYRIGHT Miller Freeman Publications 1991.andM;</JOURNAL><TITLE>Lists and recursion in Prolog. (programming techniques) (AIApprentice) (tutorial)</TITLE><AUTHOR>Minasi, Mark.andM;</AUTHOR><SUMMARY>PROLOG uses lists as its only complex data structure.andP;  Lists aredesignated by square brackets, and have a head and a tail.andP;  Thelast variable in the list is not used.andP;  Programmers usually invokethe matching power of PROLOG to use lists.andP;  To use looping inPROLOG, programmers must define iterative statements recursively.andO;Recursive programs are self-referencing.andP;  Variable definitionsrefer back to a condition under which the definition is true.andO;Recursion requires at least two rules - the iteration rule and thestopping rule.andP;  PROLOG looks at the two rules to see if they canbe satisfied.andP;  If the anchor rule is not satisfied, it moves tothe iteration rule.andP;  It tries to find matches with successivemembers of the list until it finds a match or the list ends.andO;Details of using recursive programming in PROLOG are discussed.andM;</SUMMARY><DESCRIPT>Topic:     Artificial IntelligencePROLOGProgramming InstructionProgram Development TechniquesTutorialProgramming Languages.andO;Feature:   illustrationchart.andO;Caption:   How Prolog assembles its agenda. (chart)Prolog tries to match both rules. (chart)andM;</DESCRIPT><TEXT>This month, I'll introduce two important and related concepts.andP;  A list is aProlog data structure, virtually the only complex data structure that thelanguage has to offer - or that the language needs, depending on how you lookat it.andP;  Lists won't take long, because they're just a prologue (no punintended) to recursion.andP;  Recursion is a programming technique of second-orderimportance in many procedural languages but of vital importance in Prolog dueto Prolog's lack of loop control commands.andM;Another Prolog data type is the list.andP;  Lists are designated with squarebrackets, and every item in a list is separated with commas.andP;  andlsqb;a,b,aardvark,&quot;hum dinger&quot;andrsqb; is a typical list.andP;  You can use lists just about anywheresimple atoms go:andM;andgt;loves(jack,andlsqb;racing,&quot;pina coladas&quot;, musicandrsqb;).andM;Lists are said to have a head and a tail.andP;  The head is the first list item.andO;The tail is the list composed of all of the remaining lists.andP;  A one-item listandlsqb;xxandrsqb; has a head xx and a tail andlsqb;andrsqb;, the &quot;empty list.&quot; An alternative way ofidentifying the head and tail is the vertical bar (|).andP;  The atom on the leftof the bar is the list head, the part to the right is the list tail:andM;andgt;loves(jack,andlsqb;Firstpart|Lastpartandrsqb;)?andM;Firstpart andequals; racingandM;Lastpart andequals; andlsqb;&quot;pina coladas&quot;, musicandrsqb;andM;Extend this:andM;andgt;loves(jack,andlsqb;First,Second|Lastpartandrsqb;)?andM;First andequals; racingandM;Second andequals; &quot;pina coladas&quot;andM;Lastpart andequals; andlsqb;musicandrsqb;andM;andgt;loves(jack,andlsqb;First,Second,andM;Third | Lastpartandrsqb;)?andM;First andequals; racingandM;Second andequals; &quot;pina coladas&quot;andM;Third andequals; musicandM;Lastpart andequals; andlsqb;andrsqb;andM;andgt;loves(jack,andlsqb;First,Second,andM;Third,Fourth | Lastpartandrsqb;)?andM;NOandM;Here, there was no pattern to match; a four-item list didn't exist.andM;WRITING PROGRAMSandM;To introduce list programming, let us define a commonly used rule, whichextracts the head of a list:andM;andgt;headof(andlsqb;Firstpart|Lastpartandrsqb;,andM;Firstpart).andM;This Prolog rule says, &quot;The first argument should be a list, since you havedescribed it as a list composed of a head and a tail.andP;  The second argument isan atom that is bound to (must be equal to) the head of the first argument.&quot;andO;As with many Prolog rules we've seen, it's the power of Prologpattern-matching that does most of the work.andP;  For example, in querying thisrule:andM;andgt;headof(andlsqb;a,b,candrsqb;,X)?andM;X andequals; aandM;notice that the variable Lastpart doesn't really do anything; once somethingis bound to it, it is useless.andP;  It must, however, be there to indicate thelist as a head and tail.andP;  Here's a candidate for the the anonymous variable &quot;_.&quot; This variable takes the place of a variable that is not used once bound.andO;The previous rule could be rewritten with the same result:andM;andgt;headof(andlsqb;Firstpart|_andrsqb;,Firstpart).andP;  Prolog tried to match andlsqb;a,b,candrsqb; against thepattern of the first argument.andP;  The first argument looks like andlsqb;H|Tandrsqb;, a listdivided into its head and its tail.andP;  It then bound Firstpart with the value aand &quot;_&quot; with andlsqb;b,candrsqb;, then looked at the second argument.andP;  If we had bound thesecond argument, it would look like:andM;andgt;headof(andlsqb;a,b,candrsqb;,r)?andM;NOandM;andgt;headof(andlsqb;a,b,candrsqb;,a)?andM;YESandM;andgt;headof(andlsqb;a,b,candrsqb;,b)?andM;NOandM;RECURSION IN PROLOGandM;Suppose, however, that we must write a rule that involves looping.andP;  A commonexample is member (X,L), where member succeeds if X is a member of list L.andO;How would we write this argument? The FORTRAN programmer would reach for a DOloop, the BASIC programmer for a WHILE ...andP;  WEMD block, and the COBOLprogrammer for a PERFORM block.andP;  What do we have in Prolog? Nothing.andP;  Due toits nonprocedural nature, Prolog doesn't have any looping constructs.andP;  Theonly way to do something iteratively is to define it recursively.andM;To review recursive programming quickly, recursive definitions of programsare self-referencing: the most common example of recursive definitions is afactorial (in pseudocode, not Prolog):andM;Factorial(n) andequals; n * Factorial(n_1).andP;  butandM;Factorial(O)andequals;1andM;Recursion can be a handy tool for some programming tasks.andP;  Sure, you've seenthe factorial example so many times that you skipped the last paragraph, buthere's an algorithm that's useful' simple, and recursive:andM;Trim(string A) andequals; string AandM;(if the first character of A is not aandM;blank),andM;orandM;Trim(string A from the second characterandM;to the end)andM;Trim(null string) andequals; null stringandM;Trim, here, refers to a routine to trim leading blanks from a string.andO;Recursion requires a stopping rule (anchor) and an iteration rule (therecursion).andP;  This routine is easily understood with an example.andM;Suppose we want to define a rule member (X,Y), where X is an atom and Y is alist.andP;  It would succeed if X was a member of the list Y:andM;andgt;member(a,andlsqb;b,a,c,dandrsqb;)?andM;YESandM;andgt;member(a,andlsqb;b,dandrsqb;)?andM;NOandM;It would be reversible, of course:andM;andless;member(X,andlsqb;b,a,candrsqb;)?andM;Xandequals;bandM;Xandequals;aandM;Xandequals;candM;YES The example of member could be written in Prolog as two rules, the anchorand the iteration rule:andM;member(X, andlsqb;X|_andrsqb;).andM;/* rule 1-the anchor */andM;member(X, andlsqb;_ | Yandrsqb;) : _ member(X, Y).andM;/* rule 2-iteration rule */andM;The first rule says, &quot;member succeeds if X is the head of the list.&quot; Again,the &quot;_&quot; is a Prolog construct that stands for a variable - any variable.andP;  Wecould have included A or B, but we didn't need it to bind to anything, so thegeneral &quot;_&quot; was used.andP;  This rule is the anchor.andP;  Note that Prolog does notcall one rule the anchor and the other the iteration rule, nor must there beonly one of each.andM;The second rule, which is the iteration rule, says,  &quot;member succeeds if X isa member of the tail of the list.&quot; Successive application of it should findthe answer.andM;I know that looking at it requires a certain amount of brain torque, so let'sfollow the execution of member(a,andlsqb;b,d,aandrsqb;).andP;  Prolog assembles its agenda asshown in Figure 1.andP;  Rule 1, member  (a,andlsqb;b|_andrsqb;), is definitely not satisfied.andO;We must then try to satisfy Rule 2.andP;  If we can't, the root goal is notsatisfied.andP;  This new &quot;subgoal&quot; is member(a, andlsqb;d,aandrsqb;)? Prolog says, &quot;How can Ianswer that question?&quot; Upon examination of its database, it sees that the twopossible ways are Rule 1 and Rule 2.andP;  it then tries them out in order (Figure2).andM;Just failures so far.andP;  We're not done yet, however: evaluate the sub-subgoalmember(a,andlsqb;aandrsqb;)? As before, two possible rules could prove this statement, Rule1 and Rule 2.andP;  Explore member(a,andlsqb;aandrsqb;), shown in Figure 3.andM;Finally we have a successful goal: member(a,andlsqb;a|_andrsqb;) matches.andP;  This goalpropagates back up and the root goal is solved.andP;  But we're still not done.andO;The last branch includes the undetermined query (sub-sub-subgoal)member(a,andlsqb;andrsqb;)? As always, the query member(a,andlsqb;andrsqb;) could be satisfied in twopossible ways: Rule 1, which looks like member(X,andlsqb;X|_andrsqb;), and Rule 2,member(X,andlsqb;_|Yandrsqb;) :member(X,Y).andP;  Prolog tries to match both rules.andP;  The firstone does not match - the head of the empty set is not equal to a. The secondone cannot be matched because it seeks to match its second argument with itstail,  (andlsqb;_|Yandrsqb;).andP;  This rule cannot even be explored, because there is no tailin andlsqb;andrsqb; to match (Figure 4).andP;  Everything is explored, so success can beassigned to the tree, as shown in Figure 5.andP;  This is how tree generationfinally stops.andM;If you've followed the tree from start to finish, you're tired by now.andM;Next month, more recursion.andM;Mark Minasi is a managing partner at Moulton, Minasi, and Co. in Columbia,Md.andP;  He teaches AI seminars across the country and provides consultingservices in systems development and troubleshooting.andP;  He con be reachedthrough AI Expert.andP;  Figuration Omitted</TEXT></DOC>