<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF109-409-211  </DOCNO><DOCID>09 409 211.andM;</DOCID><JOURNAL>Hewlett-Packard Journal  June 1990 v41 n3 p36(12)* Full Text COPYRIGHT Hewlett Packard 1990.andM;</JOURNAL><TITLE>The HP SoftBench environment: an architecture for a new generationof software tools. (an integrated software development environmentfor computer-aided software engineering)</TITLE><AUTHOR>Cagan, Martin R.andM;</AUTHOR><SUMMARY>Hewlett-Packard's SoftBench suite of integrated softwaredevelopment tools combines program editor, static analyzer,program debugger, program builder, mail and other computer-aidedsoftware engineering tools.andP;  The HP Encapsulator in the toolkitallows existing tools to be integrated with the environment andlets it be customized to specific software development processes.andO;HP SoftBench is intended to improve programmer productivity duringdevelopment, testing and maintenance by supporting integrated toolsets, interchangeable tools, a distributed computing environment,software development teams, multiple work styles and other lifecycle tools.andP;  The primary components in the environment'sarchitecture are tool communication, distributed support and userinterface management; each is described.andM;</SUMMARY><DESCRIPT>Company:   Hewlett-Packard Co. (products).andO;Ticker:    HWP.andO;Product:   HP SoftBench (Program development software) (design andconstruction).andO;Topic:     Program Development ToolsComputer-Aided Software EngineeringSoftware DesignSoftware MetricsIntegrated SystemsProductivitySoftware Maintenance.andO;Feature:   illustrationchart.andO;Caption:   An example of an HP SoftBench distributed development environment.andO;(chart)HP SoftBench tools communicate through the broadcast messageserver. (chart)andM;</DESCRIPT><TEXT>The HP SoftBench product improves programmer ProductivitY by integratingsoftware development tools into a single unified environment, allowing theprogram developer to concentrate on tasks rather than tools.andM;THE HP SOFTBENCH PRODUCT is an integrated software development environmentdesigned to facilitate rapid, interactive program construction, test, andmaintenance in a distributed computing environment.andM;The HP SoftBench environment provides an architecture for integrating variousCASE (computer-aided software engineering) tools.andP;  Many of the tools mostoften needed-program editor, static analyzer, program debugger, programbuilder, and mail-are included in the HP SoftBench product.andP;  Another HPSoftBench component, the HP Encapsulator, makes it possible to integrateother existing tools into the BP SoftBench environment and to tailor theenvironment to a specific software development process.andP;  Fig.andP;  1 illustratesthe HP SoftBench user interface.andM;This article describes the HP SoftBench tool integration architecture.andP;  TheHP SoftBench program editor, static analyzer, program debugger, programbuilder, and mail are described in the article on page 48.andP;  The HPEncapsulator is described in the article on page 59.andM;Design ObjectivesandM;The overall goal of the HP SoftBench product is to improve the productivityof programmers doing software development, testing, and maintenance.andP;  Toachieve this goal, the following objectives were defined for the toolintegration architecture:andM;* Support integrated tool sets.andP;  The tools should cooperate to present atask-oriented environment that lets users concentrate on what they want todo, not how to do it.andM;* Support interchangeable tools.andP;  HP's CASE strategy is based on the beliefthat there is no single solution appropriate for all users.andP;  The type ofapplication being developed, the size of the team, the delivery constraints,and the development methodology all impact the optimal tool set.andP;  Theintegration architecture should permit any tool to be replaced such that nochanges need to be made to the other tools and the new tools cooperate withthe other tools in the environment at least as well as the original tools do.andM;* Support a distributed computing environment.andP;  The architecture needs tosupport software development in a distributed computing environment composedof combinations of X terminals, workstations, midrange computers, andservers, possibly in geographically dispersed locations.andP;  Tool execution,data, and display should all be designed for a network environment.andM;* Leverage existing tools.andP;  Users need to be able to integrate tools theyalready use, which they have either purchased or developed, into theirsoftware development environment.andP;  To do so, they should not have to modifythe source code of any tool or change the other tools in the environment.andO;Support software development teams.andP;  The tools and architecture shouldsupport team coordination and the management of project files in adistributed development environment.andM;* Support multiple work styles.andP;  The HP SoftBench product should not dictatea single style of work.andP;  The style should be based on the task.andP;  For example,if the user is primarily doing maintenance the environment should be centeredaround the maintenance task, and if the user is primarily doing rapidprototyping, the environment should be centered around the programconstruction task.andM;* Support other life cycle tools.andP;  The HP SoftBench architecture shouldfacilitate the integration of additional life cycle tools such as projectmanagement, documentation, analysis, and design tools.andM;* Build on standards.andP;  The HP SoftBench architecture should build on theUNIX' operating system, NFS and ARPA networking, the X Window System- Version11, and the OSF/Motif appearance and behavior.andM;Architecture OverviewandM;We define a software engineering environment to be an ensemble of tools thatcollaborate to support the user's software engineering process.1 There areseveral types of tool integration.andP;  The HP SoftBench tool integrationarchitecture concentrates on providing mechanisms that support toolcollaboration in a distributed computing environment.andP;  This type ofintegration is often called control integration or process integration.andM;The architectural facilities provided by the HP SoftBench product arecomplementary to those in other integration architectures that concentrate onproviding services for sharing data between tools and managing datarelationships.andM;Over the last several years, university and industrial research laboratorieshave been addressing the issues of improved software tool integrationfacilities.andP;  The HP SoftBench tool integration services are an implementationof much of this research in a commercial product.andP;  There are three primarycomponents in the HP SoftBench tool integration architecture:andM;* Tool communicationandM;* Distributed supportandM;* User interface management.andM;Tool CommunicationandM;HP SoftBench tools communicate in a networked environment via a broadcastcommunication facility designed to support close communication of independenttools.andM;In the UNIX operating system, tool communication is typically limited tosingle-direction, point-to-point data streams (pipes).andP;  In the HP SoftBenchenvironment, tool communication is two-way, one-to-many or many-to-one, andevent-driven.andM;Message-Based Application Program interfaceandM;All HP SoftBench tools, as well as nonSoftBench tools that have been properlyintegrated using the HP Encapsulator, provide access to their functionalitythrough a message-based application program interface (API).andP;  Any action thatcan be initiated through the tool's user interface can be initiated throughthe message interface.andM;When an HP SoftBench tool or an encapsulated tool wants to cause another toolto perform an operation, it sends a request message.andP;  The tool requesting theservice does not know the particulars of the tool that will service therequest.andP;  It only deals in terms of an abstract tool protocol.andP;  There areseveral predefined tool protocols in the HP SoftBench environment, one foreach class of tool (e.g., DEBUG, EDIT, BUILD).andP;  Each tool protocol iscomposed of a set of operations (e.g., STEP, SET-BREAKPOINT, CONTINUE).andP;  Aslong as a new tool fully supports the appropriate tool protocol, that newtool can be substituted for the original tool, and the other tools in theenvironment continue to operate with the new tool just as they did with theoriginal tool.andP;  With the HP Encapsulator, users can define new tool protocolsor develop new tools for existing protocols.andM;There are several important benefits of having a message-based interface toall tools in the environment, but the primary reason is for task automation.andO;Tools can be controlled by other tools instead of a person.andM;Other benefits of a message-based interface include programmatic applicationtesting (see &quot;Architectural Support for Automated Testing,&quot; page 37),computer-based training, and on-line help (see &quot;Integrated Help,&quot; page 57).andO;The value of a message-based API has been demonstrated in several systems.andO;Most influential in the HP SoftBench design were the FIELD system done atBrown University,&quot; the FSD system done at USC_ISI,  and the HP NewWaveenvironment.andM;Event TriggersandM;An important extension to the message-based API model is that all HPSoftBench tools and all external tools that have been integrated using the HPEncapsulator announce the action they just took after each operation theyperform.andP;  This notification message is sent whether the operation wasinitiated from the user interface or from the message interface.andP;  Thenotification message also indicates whether the operation was successful (see&quot;Broadcast Message Server Message Structure,&quot; above).andM;These notifications are the key to a powerful HP SoftBench concept known asevent triggers.andP;  A trigger is a set of operations to be executed when anevent occurs somewhere in the user's software engineering environment.andP;  As asimple example, when an HP SoftBench tool modifies a file, it announces thisfact, so that other tools that are operating on the file can be updatedappropriately.andP;  The notion of a tool announcing its operations comes from theresearch on FIELD at Brown University.andM;In the HP SoftBench environment, certain triggers are predefined in thetools.andP;  More important, users can define their own triggers with the HPEncapsulator, keying off any notification in the user's environment.andP;  Forexample, the user might define an event trigger that automatically notifiesthe team whenever a successful build occurs, or metrics might be collectedwhenever a file is checked into version control.andM;Broadcast CommunicationandM;The HP SoftBench environment uses a broadcast model of tool communicationprovided by the facility known as the broadcast message server (BMS).andP;  TheBMS is the dispatcher of messages between the various tools in the user'ssoftware engineering environment.andP;  Like a communications satellite, the BMSreceives messages from tools in the environment and rebroadcasts thesemessages to all tools that have expressed an interest in each type of signal.andM;When an HP SoftBench tool or a tool integrated using the HP Encapsulatorstarts up, it establishes a connection to the BMS and announces its commandclass (that is, the tool protocol it supports) and the operations it willservice (its message-based API).andP;  It also tells the BMS what events it wouldlike to be notified about if and when they happen elsewhere in theenvironment (that is, the messages for which it wants to define eventtriggers).andP;  See &quot;Broadcast Message Server Message Structure,&quot; page 39.andM;There are two types of messages in the HP SoftBench environment:notifications and requests.andP;  A notification is an announcement of an action,and a request is a tool asking the environment to perform an action.andM;When a notification message is received by the BMS, it forwards the messageto the tools that have informed the BMS that they would like to receive thosemessages.andP;  For example, in Fig.andP;  2, the program builder tool has sent anotification that a DIRECTORY-BUILD was successfully completed.andP;  The BMSforwards the message to tools that have expressed an interest in this event.andO;In this case, the development manager will use the message to trigger adirectory update and the static analyzer will use it to trigger a reanalysisof its program data base.andM;Often, no tools have expressed interest in a given message.andP;  When this is thecase, the message is discarded.andP;  Tools get only messages they have requested.andO;This serves to simplify a tool's message processing and substantially reducethe message traffic on the network.andM;Tool ExecutionandM;When a request message is received by the BMS, the HP SoftBench environmentfirst checks to determine whether an already running tool has indicatedthrough its API that it will service this type of request.andP;  If there is sucha tool running, the HP SoftBench environment forwards the request message tothat tool.andP;  If there is no such tool running, the HP SoftBench environmentchecks a user customizable data base that contains the name of theappropriate tool to start and instructions for starting it.andP;  The HP SoftBenchenvironment then starts the tool and waits for confirmation from the toolthat it will indeed handle the request.andP;  Once this confirmation is received,the HP SoftBench environment forwards the queued request message to the tooljust started.andP;  The HP SoftBench module that monitors the tools that arecurrently executing and invokes tools when necessary is referred to as theexecution manager.andM;In the BP SoftBench environment, as in the HP NewWave environment, but unlikethe UNIX operating system, users do not have to start tools explicitly.andP;  Theyrequest actions on objects, and if a tool needs to be started, the executionmanager starts it for them correctly and automatically.andM;Distributed SupportandM;It is a fundamental goal of the HP SoftBench environment to supportdevelopment in a distributed computing environment.andP;  This is defined toinclude configurations of several hundred computers, composed of arbitrarycombinations of X terminals, workstations, servers, and larger computers.andO;The goal of HP SoftBench distributed computing support is to facilitate theuse of the network and to hide from the user any complexities the networkintroduces.andM;Remote ExecutionandM;In the HP SoftBench environment, any tool can execute on any host in thenetwork.' To support this remote execution, HP SoftBench includes adistributed execution mechanism designed to make the remote executiontransparent to the HP SoftBench tools.andM;To communicate with processes running on a local or remote computer, ahigh-level protocol is used.andP;  When communicating with a remote computer, asmall daemon program known as the HP SoftBench subprocess control (SPC)daemon is used.andP;  This remote daemon is automatically invoked through theHP-UX inetd facility.andP;  Process control between the initiating tool and theremote process is then conducted through the SPC daemon.andM;HP SoftBench tools communicate in a distributed environment via the BMS, asdescribed earlier.andP;  This communication mechanism is network-based so thattool communication works identically whether all tools are local or each ison a different computer in the network.andM;One of the most powerful applications of distributed execution is forspecial-purpose execution servers.andP;  For example, a project of ten softwaredevelopers might wish to designate a dedicated (or otherwise lightly loaded)computer on the network to be used for all program builds (compiling andlinking).andP;  With the HP SoftBench distributed execution capability, the team'senvironment can be customized to execute every user's builds on the dedicatedcompile server.andP;  This allows the team members to maintain full performance ontheir personal workstations while their compiles are performed on the server,which is not burdened with other tasks that might slow down the compilations.andO;The same notion can be applied to any of the tools.andM;Remote DataandM;In the HP SoftBench environment, data can reside on any host in the network.andO;Regardless of where a tool is running, it can access the data.andP;  The userprovides an HP SoftBench file specification, which may contain an optionalhost field  e.g., (machinel:/usr/src/projecti/filel.c).andP;  If a remote host isspecified, the distributed data facilities are automatically employed toestablish the path to the remote file.andM;With large teams, it is often easier to manage and administer data centrallythan to have the data duplicated on each workstation in the network.andP;  Forexample, configuration management, tape backup and archiving, and projectmanagement are typically easier when the project files are centralized.andP;  Thiswas and remains one of the benefits of timesharing systems.andM;The most common application of the remote data feature is the use of a dataserver.andP;  For projects that prefer or require dedicated computing power foreach engineer, yet wish to have a common location for project data, the HPSoftBench distributed data capability facilitates this.andP;  Project members canrun their tools locally but designate and use a common computer and filesystem location for project files (e.g., fileserver:/usr/src/projectl).andM;Remote DisplayandM;HP SoftBench tools are built on the X Window System Version 11, which is anetwork-transparent window system.andP;  One of the benefits of the X WindowSystem is that X programs can run on one system and display visually onanother.andP;  In fact, to run the HP SoftBench environment, the only process thatmust actually be observable to the user is the X display server, whichrequires a bit-mapped display and adequate RAM.andM;The extreme example of this is the X terminal products that are nowappearing.andP;  These act as smart terminals that run the X display server andconnect to the network.andP;  The HP SoftBench tools the user runs actuallyexecute on other computers in the network.andP;  Moreover, the computers thatactually run the HP SoftBench tools do not need to be running X11.andP;  They mustsimply support the X11 client library interface and be connected to thenetwork.andM;The HP SoftBench remote execution, data, and display capabilities describedabove enable diverse configurations of workstations, servers, and largercomputers to be employed, based on the needs of the user's team, to increasesoftware development throughput and decrease per-seat cost (see &quot;DistributedData, Execution, and Display,&quot; page 40).andM;User Interface ManagementandM;To provide a consistent appearance and behavior among the many BP SoftBenchtools, and to facilitate the use of the OSF/Motif user interface style, theHP SoftBench integration services contain user interface management software.andO;This software provides support for schemes (see &quot;Schemes: InterfaceConsistency,&quot; page 41), pervasive code editing and viewing (see &quot;PervasiveEditing in the HP SoftBench Environment,&quot; page 42), native languages (see&quot;Native Language Support,&quot; page 43), and interactive help (see &quot;IntegratedHelp,&quot; page 57).andM;User ModelandM;The HP SoftBench tools have been designed so that they can support manydifferent styles of work.andP;  A programmer doing rapid prototyping may use thesame set of HP SoftBench tools as one doing maintenance, but they may be usedquite differently, since the task is different.andM;The programmer doing rapid prototyping may keep a &quot;home base&quot; in the programeditor, while one doing maintenance may have a home base in the staticanalyzer.andP;  However, both have easy, integrated access to the other HPSoftBench functions such as file version management and program builds.andM;In the HP SoftBench system model, each tool provides the actions that areappropriate based on the type of data managed by the tool.andP;  For example, inthe program editor, source files are viewed and manipulated.andP;  However, theprogrammer can also check in and out the currently edited file, cause thefile to be compiled, and ask static analysis queries, such as where a givenfunction is defined.andP;  The static analyzer provides cross-reference and codebrowsing information, yet the programmer can edit the files being viewed,check them in and out of version control, and cause the files to be rebuilt.andO;This remote access to other tools' functionality is provided by the HPSoftBench tool communication architecture.andP;  It lets the programmerconcentrate on the task at hand, while the tools cooperate among themselvesto perform requested operations.andM;Human interfaceandM;The HP SoftBench environment provides an object-action user interface model.andO;The user first selects the object that will be operated on, and then selectsone or more actions to be performed on that object.andP;  The environment works toprovide a task-oriented, rather than a tool-oriented view of the environmentto the user.andP;  The HP SoftBench user interface style was significantlyinfluenced by the HP NewWave user interface work.'andM;The HP SoftBench environment follows the OSF/Motif appearance and behavior.andO;This interface technology is largely mouse- and menu-driven, withhuman-computer interaction occurring primarily through dialog boxes (see Fig.andO;3).andM;Several benefits are provided by the OSF/Motif technology:andM;A rich set of primitives on which to build sophisticatedandM;user interfaces.andM;* Keyboard traversal for users who prefer to perform some or all operationsfrom the keyboard rather than with a pointing device.andM;* Native-language input and output for accepting and displaying languagesrequiring 8-bit and 16-bit character sets.andM;* User-definable keyboard accelerators for common menu actions.andM;* Consistency with PC-based applications to facilitate interoperabilityacross computing platforms.andM;ConclusionandM;We have described the various mechanisms provided by the HP SoftBench toolintegration architecture for tool communication, distributed data, execution,and display, and user interface management.andP;  The communication facilities areexploited by the HP SoftBench software development tools to collaborate inpresenting a task-oriented environment to the programmer.andP;  The distributedexecution, data and display services are used by the tools to allow the userto make effective use of the computational, file storage, and presentationcapabilities available on the network.andP;  This can improve performance, reduceper-seat workstation cost, and facilitate development for large softwareteams in a distributed environment.andP;  The user interface management facilitiesallow the tools to present a consistent, localizable, customizableenvironment that is easy to learn and use.andM;The HP Encapsulator provides these integration services to existingnonSoftBench tools, without requiring access to the tools' source code.andM;AcknowledgmentsandM;The HP SoftBench product began as a research project in the SoftwareTechnology Laboratory of HP Laboratories in Palo Alto, California, under theinternal name Ivo.andP;  The decision was made to build a product based on thisresearch at the Software Engineering Systems Division in Fort Collins,Colorado.andP;  The HP SoftBench product involved a great many people in Randamp;D,marketing, and the field.andP;  Special thanks to HP SoftBench product marketingengineer Becky Hennig, our human factors engineer Greg Foltz, the HPSoftBench QA team led by Don Watt, Roy Williams, and Kirsten Duff, thedocumentation team of Mary Edelmaier, Dave Koons, and David Wolpert, and ourpartners at the Corvallis Workstation Operation, the California and ColoradoLanguages Laboratories, HP Laboratories, and the Software Engineering SystemsDivision in Palo Alto.andM;The HP SoftBench integration platform was designed and built by MichaelBaumann, John Diamant, Jerry Duggan, Colin Gerety, Warren Greving, BillKwinn, Kathy Kwinn, Sam Sands, Gerrie Shults, Tim Tillson, Jack Walicki, andJudy Walker.andM;ReferencesandM;1.andP;  R. Ison, &quot;An Experimental Ada Programming Support Environment in the BPCASEdge Integration Framework,&quot; Proceedings of the International Workshop onEnvironments, Chinon, France, September 1989.andM;2.andP;  B. Balzer, &quot;Living in the Next Generation Operating System,&quot; IEEESoftware, November 1987, pp.andP;  77-85.andM;3.andP;  I. Fuller, &quot;An Overview of the HP NewWave Environment,&quot; Hewlett-PackardJournal, Vol.andP;  40, no.andP;  4, August 1989, pp.andP;  B-8.andM;4.andP;  G. Boudier, F. Gallo, and 1.andP;  Thomas, &quot;Overview of PCTE and PCTE+, &quot; ACMSIGPLAN Notices, Vol.andP;  24, no.andP;  2, February 1989.andM;5.andP;  S. Reiss, Overview of the FIELD Environment, Brown University, Departmentof Computer Science, November 1987.andM;6.andP;  M. Cagan and A. Ishizaki,  Ivo: An Integrated CASE Environment,&quot;preceedings of the Hewlett-Packard Software Engineering ProductivityConference, 1986.andM;7.andP;  M. Cagan and D. Young, &quot;The Ivo Tool Integration Platform,&quot; Proceedingsof the Hewlett-Packard European Software Engineering Productivity Conference,1987.andM;8.andP;  G. Steams, &quot;Agents and the HP NewWave Application Program Interface,&quot;Hewlett-Packard Journal, Vol.andP;  40, no.andP;  4, August 1989, pp.andP;  32-37.andM;9.andP;  P. Showman, &quot;An Object-Based User Interface for the HP NewWaveEnvironment,&quot; Hewlett-Packard Journal, Vol.andP;  40, no.andP;  4, August 1989, pp.andO;9-17.andM;Architectural Support for Automated TestingandM;The importance of software testing does not have to be argued anymore.1 Therealso exists a relative wealth of sources describing various aspects ofsoftware testing.andP;  Unfortunately, most of the published literatureconcentrates on elegant approaches to limited subproblems derived fromtraditional software (that is, batch-oriented input/output).andP;  Additionally,the published body of knowledge almost completely ignores the issue of howthe testing activity should fit modern project life cycles (reference 2 is arare exception).andM;This section is about testing a large software system: the HP SoftBenchproduct described in the accompanying article.andP;  The goal is to describe boththe process and the various tools and utilities developed to exploit thearchitectural advances of the HP SoftBench product to support the testingprocess.andP;  The problem of testing a system such as the HP SoftBenchenvironment is difficult and therefore interesting.andP;  The problem has thefollowing major attributes:andM;* Development of the HP SoftBench system followed the spiral life cyclewhich, because of its crucial aspect of rapid prototyping, presents a realchallenge for formal testing.andM;* The formal testing activity started early in the project life cycle andclosely tracked the project development.andM;* The system being tested consists of several tightly integrated tools and isevent-driven.andM;* The system has a sophisticated user interface (window-based andmouse-driven).andM;* Black-box tests had to be automated (which in the case of the userinterface meant developing an  automatic user&quot;).andM;* The testing proceeded along an unorthodox path-from blackbox testing,through &quot;grey-box testing&quot; (driven by branch flow and complexity analysis),to white-box testing.andM;Automatic Regression TestingandM;Traditional testing methods focus on exercising and testing programs bystimulating them using controlled inputs and observing their outputs.andP;  If theinput and output sets are &quot;well-behaved&quot; (e.g., numeric values) then it maybe possible to prune the test space using the techniques of equivalencepartitioning or boundary analysis.andM;The HP SoftBench product presents a special challenge.andP;  Its user interface isalmost completely mouse-driven and makes heavy use of hierarchically arrangedwindows.andP;  The system integrates actions of several tools through a messageinterface.andP;  The output is mostly visual.andP;  Finally, the system can run in adistributed environment on many processing units and varying displays.andO;Automatic testing of such a system implies the need for a robot tester,&quot;blindfolded and handcuffed but capable of entering input and verifyingoutput.andP;  One possibility is to operate at the pixel level and generaterequired actions (pushing buttons, etc.) at specific points on a screen.andP;  Theverification of output would then require taking screen snapshots andcomparing them with the expected screens.andP;  The problem is that this approachis tied directly to the screen's appearance.andP;  A mere change in fonts or otherscreen attribute (e.g., color scheme) would completely invalidate thistesting approach.andP;  A higher-level approach is needed.andM;An HP SoftBench tool has two major interfaces: the user interface(mouse/keyboard/window) and the message interface.andP;  We used both interfacesto exercise and verify HP SoftBench behavior.andP;  To deal with the userinterface challenge, we used two mechanisms that allowed us to stimulateinputs and register outputs independently of screen parameters.andP;  On the inputside we identified inputs  buttons to be pushed or editing windows) not bytheir screen coordinates but by symbolic names associated with these objects.andO;Thus, the automatic testing tools are able to find some window no matterwhere that window is placed on the screen (or even if it is completelyobstructed by other windows).andP;  To obtain higher-level verification of outputswithout resorting to pixel-level screen dumps, we instrumented the code sothat any window could be probed and forced to dump its contents (strings or apointer position in the case of the edit widget, or a label in the case of abutton).andP;  This approach allows selective probing of software objects (verymuch like having testing probes in hardware).andM;Testing ToolsandM;Two companion testing tools were used to drive both HP SoftBenchinterfaces-user and message.andP;  Tool A allows the tester to send messages tothe message server.andP;  It can intercept messages and match them against a listof expected messages.andP;  Tool A can also act on widgets.andP;  Tool A's companionutility, tool B, is capable of automatically and interactively creating atest file that mixes message and widget operations.andP;  This file becomes theinput to tool A.andM;Tool A allows the user to send messages to the message server.andP;  Tool A willthen wait for the tools to respond to the messages.andP;  The order in which themessages are sent and received is restricted by a partial order relationgiven by the user.andP;  This ordering can be totally unrestricted, strictlysequential, or anything in between.andM;Tool A maintains an active list of commands as it runs a test.andP;  As eachcommand is executed it is removed from the active list and all of itssuccessors are checked to see if they should be added to the active list.andP;  Acommand is not added to the active list until all of its predecessors havebeen executed.andM;Actions and Software ProbesandM;Tool B can be used to log two types of events.andP;  it can intercept messages andit can also log operations on widgets into a test file.andP;  All of thewidget-based commands search Xl l's window tree for the named widget at thetime the command is executed.andP;  The search is done at this time becausewindows are constantly being created, destroyed, and moved about within thetree.andP;  The search algorithm does a breadth-first search of the window treefor the first name of the widget.andP;  As each match is encountered a secondbreadth-first search is started on the subtree of the matched window, lookingfor the second name of the widget.andP;  These searches continue until the tree isexhausted or all of the names of the widget are found.andP;  The search algorithmremembers that it has touched a particular application, and as a result allthe subsequent widget searches use that shortcut (resulting in about a 90%speed-up in the search time).andM;When capturing tests with tool B, the tester can identify a widget that needsto be probed at the test time.andP;  The information dumped for a widget includesall text seen on the display, whether the text is sensitive (grayed out), andwhether it is set or marked (only for menu buttons and toggles).andP;  This schemeallows us not only to describe the events to execute the actions, but also tospecify what needs to be checked to verify that the actions happenedcorrectly.andM;Supporting UtilitiesandM;Our tests were stored in the HP-UX revision control system (rcs) and ran inthe proprietary HP Scaffold testing harness.5 We used branch flow analysis(BFA) to monitor the coverage of the code and to steer the testingactivities.6 We combined the BFA information (annotated source code) and theresults of the complexity analysis (McCabe's ACT') to focus on testing theareas of the code that have high complexity and low BFA coverage (grey-boxtesting).andM;ReferencesandM;1.andP;  B.W.andP;  Boehm and P.N.andP;  Papaccio, &quot;Understanding and Controlling SoftwareCosts,&quot; IEEE Transactions on Software Engineering, 1988.andM;2.andP;  R.A.andP;  Sulack, R.J.andP;  Lindner, and D.N.andP;  Dietz, &quot;A new development rhythmfor AS/400 software,&quot; IBM Systems Journal, no.andP;  3.andP;  1989.andM;3.andP;  B.W.andP;  Boehm, &quot;A Spiral Model of Software Development and Enhancement,&quot; EEE Computer, no.andP;  5.1988.andM;4.andP;  G.J.andP;  Myers, The Art of Software Testing, John Wiley andamp; Sons, 1979.andM;5.andP;  C.D.andP;  Fuget and B.J.andP;  Scott, &quot;Tools for Automating Software Test PackageExecution.&quot; Hewlett-Packard Journal, Vol.andP;  37, no.andP;  3.andP;  March 1986, pp.andO;24-28.andM;6.andP;  D. Herington, et al,  Software Verification Using Branch Analysis,&quot;Hewlett-Packard Journal, Vol.andP;  38, no.andP;  6, June 1987, pp.andP;  13-22.andM;7.andP;  T. McCabe, &quot;A Complexity Measure.&quot; IEEE Transactions on SoftwareEngineering, Vol.andP;  SE-2, no.andP;  4, December 1976.andM;Broadcast Message Server Message StructureandM;HP SoftBench tools communicate by sending messages, which are dispatched bythe broadcast message server (BMS) to appropriate other tools.andP;  HP SoftBenchmessages have the following structure:andM;Originator Request-id Message-Type Command-ClassandM;Command-Name Context [Arguments]andM;Originstor.andP;  The originator is the tool that sent the message.andP;  However, byconvention, this field is not used by the HP SoftBench tools themselvesbecause they do not send messages to a particular tool; they send them to theBMS so that other tools interested in the events can be notified.andM;Request-Id.andP;  The request ID is constructed from the triple  message number,process-id, host).andP;  This network-wide unique ID is used so that responses canbe associated with their original requests.andP;  In other words, a notificationsent as the result of a request has the same request ID as the originalrequest to which it is responding.andM;Message-Type.andP;  The defined message types are:andM;R = Request messageandM;N = Success notificationandM;F = Failure notification.andM;Command-Class.andP;  The command class is the type of operation (e.g., EDIT,DEBUG).andM;Command-Name.andP;  The command name is the name of the operation within thecommand class (e.g., SAVE-FILE, STEP, STOP).andP;  The combination of the commandclass with the command name defines a unique operation, (e.g., EDIT SAVE-FILEOr DEBUG STEP).andM;Context.andP;  The context is the triple (host, base directory, file).andP;  Thisindicates the location of the data being operated on.andP;  The context is used todistinguish between multiple instances of the same tool.andP;  For example, if theuser is working on two projects at once and has two debuggers running, thecontext ensures that the right messages get sent to the right debugger.andM;Argument.andP;  Each message may have optional, variable-format argument lists,which provide additional information regarding the operation-for example, thename of a function or variable.andP;  In the HP SoftBench product, complex data ispassed by reference rather than by value.andP;  For example, if the message is anotification from the static analysis tool with the response to a request fora complex query, the arguments contain a pointer to a file containing thedata.andM;Distributed Execution, Data, and DisplayandM;The distributed computing support capabilities of the HP SoftBenchenvironment can support a variety of machine configurations.andP;  Fig.andP;  1 showsan example of a configuration.andP;  Assume that an engineer has a small,inexpensive X display machine (possibly a diskless HP 9000 Model 340workstation or an X terminal).andP;  Also assume that the HP SoftBench environmentis installed on an HP 9000 Model 370 server machine, and that the engineer isdeveloping software for an HP 9000 Series 800 machine, which is used as acentral data storage facility.andP;  Atypical HP SoftBench configuration willprobably have one or two machines instead of the three in this example.andO;However, it is possible to come up with configurations that use moremachines.andM;In this example, first the engineer would start the HP SoftBench environmenton the Model 370 HP SoftBench server, with the DISPLAY environment variablepointing to the X display server.andP;  One of the features of the HP SoftBenchdistributed execution facility is that the current environment of a processis always maintained when executing a child process, even over a networkconnection.andP;  Thus, if any X clients are spawned, the child X client willpoint to the correct display machine.andP;  Next, the engineer starts the HPSoftBench build tool, with the context set to the Series 800 machine.andO;Finally, the engineer selects the build tool's build button.andP;  The HPSoftBench subprocess control (SPC) facility will now do two things.andP;  It willset the working directory to match the context host and directory, and itwill spawn a make process on the Series 800 machine in this workingdirectory.andP;  Alternatively, the build tool can be configured to spawn the makeprocess on a different, possibly less loaded machine, but the workingdirectory will still point to the same context directory.andM;What if a bug is discovered in this program? The engineer can start theprogram debugger on the Model 370 HP SoftBench server.andP;  This can beaccomplished using the Actions:Debug menu pick of the development manager orthe Tool:Start...menu pick of the tool manager, or by starting the HPSoftBench program debugger manually.andP;  The debugger again uses the distributedexecution feature of the SPC to start an xdb process on the Series 800machine, debugging the object files created by the build tool.andP;  Finally, theengineer can start the static analyzer to browse through the static analysisinformation generated by the build tool.andP;  The static analyzer is running onthe Model 370 HP SoftBench server and accessing data on the Series 800 dataserver.andM;Schemes: Interface ConsistencyandM;In the HP SoftBench environment, we wanted to distinguish regions accordingto the following functions:andM;* Unchanging system information: e.g., prompt stringsandM;* Changing system information: e.g., the function being executed in thedebuggerandM;* User area: anywhere the user can enter textandM;* Read-only user area: a view of a read-only fileandM;* Selectable regions: buttons.andM;The X11 window toolkit allows a choice of fonts, colors, and shadows for eachregion of an application main window.andP;  With the OSF/Motif appearance, regionscan also be distinguished by 3D appearance.andP;  Areas can appear to be raised,lowered, or flat on the window panel.andP;  These collections of visual attributesorganized by function are called schemes.andM;information presented by the system, such as the current line number in theHP SoftBench program debugger, appears flat in the window.andP;  The label forsystem information uses a bolder font than the value.andP;  In the main window fora tool, there is a single background color for all system areas.andM;Areas where the user can enter information appear recessed in the window andhave a different background color from system areas.andP;  Sometimes the user isprevented f rom entering information in a user area-for example, when a filebeing viewed has read only protection.andP;  in these read-only user areas thebackground color is the same as the system areas.andM;Regions where the user can select using the mouse  buttons, for instance) usea large bold font and appear raised.andM;Windows that pop up (both menus and dialog boxes) use colors that associatethem with the pull-down menu bars.andM;Much of the human interface is implemented in HP SoftBench library routinesshared by all applications.andP;  These high-level calls create widgets of knownnames.andP;  As a result, human interface consistency is ensured and the number ofresources needed to specify a scheme is minimized.andP;  Widget classes are usedwhere possible to distinguish scheme components, but where a single widgetclass is used for more than one purpose, widget names or widget classhierarchies must be used.andM;Choosing a SchemeandM;Schemes for monochrome and color are provided in three different font sizes.andO;If the user does not specify a particular scheme by setting the Schemeresource, a scheme will be chosen based on screen resolution, visual class,and screen depth.andP;  Font size is chosen based on the screen resolution.andP;  Acolor scheme will be used only if the screen has at least four color planesand the desired colors are available.andM;ImplementationandM;Scheme files are ordinary X11 resource files.andP;  X11 resources are used toconfigure tools.andP;  Each application constructs a resource data base foritself.andP;  Some resources apply to all instantiations of a took-for example,the arrangement of windows in an application.andP;  Others, the scheme resources,may depend on the particular display being used.andP;  Users can override resourcevalues.andM;HP SoftBench tools have resource files not used by other X11 applications.andO;This was done to permit the sharing of resources between applications.andO;Resources for code implemented in shared libraries are stored in the LibXeresource file.andP;  Scheme resources are placed in their own file.andP;  This approachallows easy configuration with all font and color specifications isolated andshared.andM;Pervasive Editing in the BP SoftBench EnvironmentandM;All HP SoftBench tools have common editing needs.andP;  All must prompt the userfor input, and many provide views into source files.andP;  For consistency of thehuman interface, it is an HPS SoftBench requirement that a common set ofediting commands be used in all editable areas.andP;  The editing functionalityexists in the HP SoftBench library and is shared by all the tools.andP;  Becausethe code is shared by all applications, consistency of appearance andbehavior is ensured.andM;The Edit WidgetandM;All of the underlying functionality needed by the editor was put into theedit widget.andP;  This includes insertion and deletion of text, cut, copy andpaste, language dependent selection such as tokens or statements, and undohistory.andP;  The edit widget supports 16-bit characters and haslanguage-sensitive editing capabilities.andP;  The availability of the widgetmakes it inexpensive to have this exact functionality in numerous placesthroughout an application.andP;  in fact, this single copy of code is shared amongall the HP SoftBench applications.andP;  An edit widget is used in all areas wherea user can type information.andM;A variant of the edit widget is used to provide selection from a list ofalternatives, such as a list of filenames in the development managerdirectory list, function names resulting from a query in the static analyzer,or a list of mail messages in the HP SoftBench mail subsystem.andM;One-Line EditablesandM;The human interface needed to include many areas for displaying small userinput windows that could be labeled with concise prompts, such as for afilename, an execution hostname, or a search string.andP;  These are implementedwith a packaged combination of a static text widget for the prompt and anedit widget for the user data.andP;  Called a one-line editable, this type ofentity provides the application writer with a single widget to specifygeometry placement.andP;  The individual constituent widgets allow specificationof different fonts and background colors to inform the user which areas areconstant and which are modifiable.andP;  Using such an editable gives theapplication all the power provided by the editor in each input field, with noadditional code.andP;  One-line editables are used in dialog boxes as well as inthe application's main window.andM;View SpaceandM;Applications often need one or more windows to display a view into a possiblylarge piece of text, such as the contents of a file or a set of debuggeroutput messages.andP;  Each such screen area is associated with a view space.andP;  Aview space provides a scrollable area for an edit widget, a place for atitle, a filename, and a collection of indicators or buttons.andM;The size of the view space is driven by the size of the edit widget, whichcan be specified in character rows and columns instead of pixels.andP;  Themodifiability of the region is indicated by the background color.andP;  Theapplication can choose to hide the indicators selectively.andP;  Buttons notprohibited by the application automatically appear as needed.andM;If several files or buffers share the same view space, an index buttonappears.andP;  This allows the user to select from a list which of the views inthat space should be displayed.andM;Viewing FilesandM;To insert a file into a view space, the application makes a call such as:andM;DisplayFile(ViewSpace, DataHost, DataDirectory, DataFile, LineNumber);andM;Access to a host other than the execution host is provided transparently tothe application.andM;A similar interface allows the application writer to add annotations to agiven line of a file.andP;  These annotations are displayed as small pictures in awindow adjacent to the edit widget.andP;  These pictures ride with theirassociated line as the file is edited or scrolled.andP;  Annotations are used, forexample, to denote debugger breakpoints or the program counter position.andM;File SynchronizationandM;Since several applications may be viewing the same file, the file-viewinglibrary routines provide for keeping these views synchronized with the filesystem, using the broadcast message server (BMS).andP;  When the edit widgetsuccessfully saves a file, a FILE-MODIFIED message is sent, alerting otherapplications interested in the file.andP;  By default, the other applicationsautomatically load the new file from disk.andP;  If there is risk of destroying auser's modifications, or if the user has so requested, a prompt box appearsasking whether or not to reload the file.andM;Native Language SupportandM;Localizability has been one of the goals for the HP SoftBench product fromthe beginning.andP;  To this end, all of the code has been written to handle both8-bit and 16-bit data (see Fig.andP;  1).andP;  The only limitations are imposed bysome of the underlying HP-UX tools, such as rcs and mkmf.andP;  The HP SoftBenchedit widget can receive 16-bit input from the native language I/O facilities(see below).andP;  The fonts designed for the HP SoftBench environment include allof the HP Roman8 characters.andM;The HP SoftBench environment uses the configurability of X11 applications tofull advantage.andP;  instead of putting localizable strings in message catalogs,we have opted to put them in Xl 1 resources.andP;  Localizers can redefine thevalues of X11 resources to translate HP SoftBench pull-down menus, buttonlabels, prompts, and error messages.andP;  Because we have made maximal use ofwidgets that autoscale in size, there should be few places where localizersneed to adjust screen layout parameters.andP;  By setting a single resource value,localizers can change editing commands from chorded combinations with theExtend char key to sequence combinations with the ESC key.andP;  They can also useX11 resources to specify appropriate font schemes, and even to refer toalternate icon bit maps.andM;In response to a request from the HP SoftBench developers, the Xl 1 teamadded support for an environment variable that causes the system to searchfor application defaults in a specified directory, rather than inusrAib/X11/app-delaufts.andP;  This allows the unlocalized version and one or morelocalized versions of the HP SoftBench environment to reside on the samesystem.andM;By setting a few environment variables and adding at most several lines toXdefaults, the user can use a localized HP SoftBench environment withvirtually no speed penalty.andM;Edit WidgetandM;The HP SoftBench edit widget is the core of all 8.-bit and 16-bit datahandling in HP SoftBench applications.andP;  The user's textual data, either inthe form of files loaded from the file system or text entered into editablefields, is stored and presented to the user through the edit widget.andP;  Thisuse of the edit widget makes it much easier for each tool to provide dataintegrity.andM;Native language I/O support is part of the consistent editing facilitiesdescribed in &quot;Pervasive Editing in the HP SoftBench Environment&quot; on page 42.andO;Wherever the user can enter text within HP SoftBench tools, native languageI/O is available.andP;  Because it is provided by the edit widget, it istransparent to individual tool implementors.andM;The edit widget is built on the R2 version of the XtIntrinsics.andP;  Atapplication start-up, it determines from the HP-UX environment variable,LANG, whether it needs to handle 8-bit or 16-bit data and makes appropriatelyconfigured buffer structures.andP;  It also checks whether an Asian languagekeyboard is attached to the X server.andP;  If the keyboard is Asian or if anenvironment variable, KBDAMG, is set to an Asian language, the widget willactivate a native language 1/0 server process.andP;  In the final product versionbuilt on the HP-UX 7.0 release, the HPX extension library provides much ofthe support necessary to handle all of HP's supported keyboards correctly.andM;The design of the edit widget is based on object-oriented principles.andP;  Sincea supported object-oriented language was not available on the HP-UX operatingsystem at the start of development, we used a set of C macros to code in asimple but effective object-oriented style.andP;  The 8-bit and 16-bitcapabilities are provided by specialized subclasses of base objects, whichprovide most of the drawing and data storage functionality.andP;  At creation timethe edit widget decides whether to create 8-bit or 16-bit pseudo-objects.andO;This allowed significant code sharing.andP;  The language-sensitive actions of theHP SoftBench environment were added in a similar manner.andP;  in this case one ofthe primary benefits was to allow two different engineers to work on tightlycoupled code with minimal interference.andM;Mechanisms for Efficient DeliveryandM;The HP SoftBench environment is composed of several communicating processes,all running under the HP-UX operating system and the X Window System Version11.andP;  Each HP SoftBench tool is built on the X Version 11 C library interface,the X toolkit, the HP widgets, and the HP SoftBench common code library.andO;Most X toolkit applications are very large because of the sizes of therequired libraries.andP;  Each of the dozen HP SoftBench processes would be wellover a megabyte in size if it were linked in the standard fashion, having itsown private copy of all the library code.andM;To deliver the HP SoftBench environment effectively, we developed a deliverytechnology that significantly reduces the size of the tools and improves theperformance.andP;  To the user, these facilities are completely transparent.andP;  Theuser runs HP SoftBench tools just like any HP-UX program or shell script.andO;These facilities are not available to the end user.andP;  They are used only toensure effective delivery of the HP SoftBench tools.andM;The large executable size is a problem, but not only because of the diskstorage space required.andP;  With several of these programs all running at once(as they typically are in the HP SoftBench environment), the physical RAM inthe computer can be exceeded by a large factor.andP;  The virtual memory systemallows the system to continue to run, but performance degrades as more pagesof memory are moved to the swap device.andM;The solution was to have just one copy of the library code, rather than many.andO;The common library for all the HP SoftBench applications is about onemegabyte in size.andP;  All of the SoftBench tools (except the HP Encapsulator)are less than 200K bytes in size when stripped of their private copies of thelibrary.andP;  implementationandM;The idea of shared libraries is not new.andP;  Many UNIX implementations supportthem.andP;  However, no shared library facility existed on the HP-UX operatingsystem at the time we needed it for our product, so we implemented our own.andO;There were some technical choices to be made:andM;*  Where should the shared code physically reside so that it can be accessedsimultaneously by all of the tool processes?andM;*  How can the individual tools be linked to the shared code so that theaddresses of entry points and globals are properly resolved?andM;*  How can the various tools be invoked such that the attachment to theshared library is transparent to the user?andM;Storing the CodsandM;Our first approach was to use shared memory segments.andP;  These are regions ofmemory that can be created by one process and then accessed by many others.andO;We loaded the library code into one or more of these segments.andP;  Any toolcould then attach to these segments and execute code directly out of them.andO;This was conceptually very simple.andP;  We could put each separate library(libe.a, libX11.a, libXt.a, etc.) into its own segment, and each applicationonly had to attach to as many segments as it needed.andM;However, there were problems with this approach.andP;  First of all, it requiredan explicit step in the initialization of the environment to create thesesegments and load them.andP;  it also required some user action to deallocate themwhen taking down the environment.andP;  Also, on HP PA-RISC computers, there was aperformance degradation if an application needed more than two of thesesegments.andM;The solution was to put all the library code into a demand-loadableexecutable program.andP;  The HP-UX system automatically shares the code of suchan executable if it is being executed simultaneously by multiple processes.andM;Linking the CodeandM;At first we tried to link each of the tools statically to the library code.andO;The HP-UX linker id has a special option to do this.andP;  This approach wouldhave been the most straightforward way of delivering the product to users,but we found that it was too inflexible.andP;  Once the tools had been staticallylinked to a particular library, any changes to the library required relinkingall the tools.andP;  We needed rapid prototyping: as we changed or added featuresto the library, we wanted to test the changes quickly without having torebuild everything.andM;The solution was to delay linking the tools until run time.andP;  A dynamic loaderresolves external symbols and relocates the code when the application isloaded.andP;  This link step is very fast (1 to 2 seconds) because it all happensin memory.andP;  The tools themselves reside on disk as standard unlinked o files.andM;Invoking the ToolsandM;As a result of the decisions just described, all HP SoftBench tools areinvoked by running a single, large, demand-loadable program that contains adynamic loader and all of the common library code for the product.andP;  Thisprogram is called runprog until it becomes part of the HP SoftBench product.andO;It is possible to run any of the HP SoftBench tools by executing runprogexploitly, but there is a quick trick that hides what's going on.andP;  We use theHP-UX in command to give runprog several aliases.andP;  There is still only onerunprog, but each of the HP SoftBench tools is actually just another name forit.andP;  Runprog figures out which tool to run by looking at its own invocationname, argv[0], then appends o to that name and invokes the dynamic linker.andO;Now HP SoftBench tools can be executed transparently as in any other HP-UXprogram or shell script.andM;Application of a Reliability Model to the BP SoftBench EnvironmentandM;The HP SoftBench team decided to incorporate a statistical reliability modelinto the data gathering process during the system test phase to help usbetter understand the current quality level of the code and predict how longit might take to attain a given quality level.andP;  The model is based on thework of Kohoutek, with additional results from Musa, Okumoto, and Goel.andO;Similar models have been used in other HP Divisions.4,5,6 We learned of itfrom Doug Howell.andM;The basic idea is to fit a logarithmic Poisson execution time model to theplot of defects found versus time.andP;  At time t (in hours), the number ofdefects found, u(t), is given by:andM;u(t) = [Theta](1 - [e.sup.lambdal.t/[theta])andM;where [theta] is a scale parameter and [lambdal] is-the defect finding rate.andO;Each week, when we had a new data point on the graph of defects found versustest hours, we used nonlinear least squares iteration to find the 0 and Athat produced a best fit of the u(t) curve to our data.andP;  From the verybeginning, the fit of the curve to our data points was remarkable.andM;The scale parameter [theta] is the limit of the function u(t) as t approachesinfinity-that is, it is the number of defects the model predicts are in theproduct.andP;  We found the stability of [theta] over time to be an interestingsubject; we will say more about this below.andM;The first derivative of u(t) is the rate at which defects are being found.andO;The reciprocal of the finding rate is the instantaneous mean time betweendefects (MTBD) at time t:andM;MTBD = 1/u'(t) = (1/[lambdal])[e.sup.lambdal.t/[theta]andM;This equation was extremely useful, since it allowed us each week to predictwhen a given MTBD would be achieved.andP;  We solved this equation for t forvarious values of MTBD, given the current values of  and \.andP;  We thenconverted t from hours into calendar time by dividing by the average numberof test hours we were logging per week.andM;This gave us a weekly prediction of the calendar date when we would achievean instantaneous MTBD equal to our goal.andP;  We noticed that 0 (hence theprediction) was fairly unstable at first.andP;  Then we fitted u(t) to differentdata.andP;  Instead of computing  based on the plot of raw unweighted defectsversus test hours, we used what we call filtered weighted defects.andP;  Duplicatereports and enhancement requests were removed from the count, and defectswere weighted according to the severity assigned to them by the project team(on a scale from 0 to 1).andM;This of course gave us an MTBD that meant something different than before.andO;it was now the instantaneous mean time between virtual defects of weight 1instead of the time between any defects found, regardless of severity.andP;  Wedecided that this new MTBD number actually meant more, given that theSoftBench product is user-interface-intensive and many people were submittinglow-weight defects that were stylistic, personal preference issues.andM;When we switched to computing [theta] based on the filtered weighted defectplot, it became quite stable.andP;  Several months ahead, we predicted that wewould reach our MTBD goal on a particular date.andP;  The actual MTBD on that datewas 95.7% of the goal, and we reached the goal and did our final build fivedays later.andM;We feel that the use of this simple model was very successful in achievingthe objectives of understanding where we were and providing a rational (asopposed to emotional or schedule imposed) prediction of when we would befinished.andM;ReferencesandM;1.andP;  H. Kohoutek, &quot;A Practical Approach to Software Reliability Management,&quot;Proceedings of the 29th EOQC Conference on Quality and Development, 1985, pp.andO;211-220.andM;2.andP;  J.D.andP;  Musa and K. Okumoto, &quot;A Logarithmic Poisson Execution Time Modelfor Software Reliability Measurement,&quot; IEEE Transactions on Reliability, Vol.andO;R-33, 1984, pp.andP;  230-381.andM;3.andP;  A.L.andP;  Goel and K. Okumoto,  Tirrie-Dependent Error Detection Rate Modelfor Software Reliability and Other Performance Measures,&quot; IEEE Transactionson Reliability, Vol.andP;  R-28, 1979, pp.andP;  206-21 1.andM;4.andP;  H.D.andP;  Drake and D.E.andP;  Wolting, &quot;Reliability Theory Applied to SoftwareTesting,&quot; Hewlett-Packard Journal, Vol.andP;  38, no.andP;  4, April 1987, pp.andP;  35-39.andM;5.andP;  G.A.andP;  Kruger, &quot;Project Management Using Software Reliability GrowthModels,&quot;Hewlett-Packard Journal, Vol.andP;  39, no.andP;  3, June 1988, pp.andP;  30-35.andM;6.andP;  G.A.andP;  Kruger, &quot;Validation and Further Application of Software ReliabilityGrowth Models.andP;  &quot;Hewlett-Packard Journal, Vol.andP;  40, no.andP;  2, April 1989, pp.andO;75-79.andM;7.andP;  D. Howell, &quot;A Simple Method for Predicting the Duration of Software QA,&quot;internal Memo.andO;</TEXT></DOC>