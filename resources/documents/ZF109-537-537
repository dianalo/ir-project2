<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF109-537-537  </DOCNO><DOCID>09 537 537.andM;</DOCID><JOURNAL>Computer Language  Nov 1990 v7 n11 p49(9)* Full Text COPYRIGHT Miller Freeman Publications 1990.andM;</JOURNAL><TITLE>Using CASE for object-oriented design with C++. (tutorial)</TITLE><AUTHOR>Taylor, David K.; Hecht, Alan.andM;</AUTHOR><SUMMARY>A project is presented using an object-oriented design method andcomputer-aided software engineering (CASE) tools.andP;  Effectivedesign notation should express all the important design conceptsand needs to focus the designer's attention on its criticalaspects.andP;  Object-oriented design can be divided into class andmethod design, with class design determining the framework formethod design.andP;  Designers select the classes that are needed alongwith the functions and member variables for each class.andP;  They alsodetermine which classes refer to other classes through membervariables and which ones are inherited from other classes.andP;  Theconcepts of coupling and cohesion aid designers in determining howto apply basic object-oriented design concepts of encapsulation,classification and inheritance.andP;  The project design method isdiscussed in detail.andM;</SUMMARY><DESCRIPT>Topic:     Object-Oriented ProgrammingComputer-Aided Software EngineeringC Programming LanguageSoftware DesignTutorial.andO;Feature:   illustrationdiagram.andO;Caption:   Object-oriented analysis of animal game. (diagram)Object-oriented class design of animal game. (diagram)Object-oriented method design of animal game. (diagram)andM;</DESCRIPT><TEXT>For the past few years, we have been building software using theobject-oriented programming language C++.andP;  In the absence of matureobject-oriented design methods or tools, we have had to improvise, buildingon and extending existing methods and tools.andP;  We've used entity-relationshipdiagrams (ERDs) for class design and Ada structure graphs (ASGs) for methoddesign, as supported by an existing CASE tool.andP;  We found that two views of anobject-oriented design (for class and method design) are necessary forcomplicated systems.andM;Although we have not yet developed a product nor a complete method, we havehad some success.andP;  We feel that this knowledge will help build the nextgeneration of methods and tools and provide an intermediate solution forthose who want to use object-oriented design before the methods and toolsmature.andM;Project historyandM;Our experience with C++ has involved building several commercially availableproducts for the Teamwork CASE tool family.andP;  Our 10 worker-years worth of C++development have resulted in about 150K lines of code.andP;  Sever new projectsare under way in C++, and some products are being rewritten in C++.andP;  (1)andM;The problems we encountered doing object-oriented design for these projectswere:andM;*  C++ is not a sufficiently rich language in which to design directly, eventhough it is a high-level language.andM;*  When we started our project in 1986, no object-oriented design methods orCASE tools supported object-oriented design.andM;*  Cadre's own products for object-oriented analysis (2) and Ada design(Teamwork/ADA) have only recently become available.andM;*  When we began, some of the currently proposed methods had neither gainedwidespread acceptance nor been published.andM;These problems caused us to invent an Object-oriented design method usingCASE tools that had been built to automate the support of older, structuredmethods.andP;  (3)andM;Object-oriented designandM;For traditional reasons, we distinguish analysis from design: analysisclarifies the problem and design sketches a solution to it.andP;  Here we'll focuson design but still use analysis before design to be sure we understand theproblem.andM;An effective design notation not only must be able to express all of theimportant design concepts, but must also focus the designer's attention oncritical aspects of the design.andP;  In traditional structured design, (4) thecoupling between modules is critical, so the couples are prominentlydisplayed.andP;  In object-oriented design, the class inheritance hierarchy iscritical, so it should be easy to see.andP;  Also, since the design notation is alanguage used by people, it should be easy to write and read.andM;To discuss certain critical concepts, object-oriented design can be dividedinto class and method design.andP;  Class design is a new task required byobject-oriented design.andP;  It is like high-level design or architectural designsince it has a broad perspective that includes all classes in a problem orsubsystem.andP;  Since it determines the framework for method design, a good classdesign is critical to a successful project.andM;The designer determines which classes are needed, along with the membervariables and functions for each class.andP;  Analysis provides a set of classesfor the problem.andP;  The designer adds classes not directly related to theproblem or optimizes classes from the analysis.andP;  The designer also decideswhich classes are inherited from other classes and which ones refer to otherclasses through member variables.andM;Two traditional concepts from structured design-coupling and cohesion--applyuniversally.andP;  Obviously, the specialization of these concepts to modules doesnot apply to classes, but it does to methods.andP;  The general concepts, however,apply to classes.andM;Coupling tells us to reduce the knowledge one class has of others, so whenone class changes, it is less likely to change the others.andP;  Cohesion tells usto make sure all the member variables and methods of a class make sense aspart of the class.andP;  Coupling and cohesion help the designer determine how toapply the basic object-oriented design concepts of classification,encapsulation, and inheritance.andP;  (5)andM;Method design is similar to traditional procedure design.andP;  Methods passmessages to other objects, thereby invoking those objects' methods.andP;  Thedesigner should be concerned that each method has good cohesion and is nottightly coupled with other methods or objects.andM;Designing with existing toolsandM;As a CASE vendor, it was natural for Cadre to use CASE for object-orientedprojects.andP;  Since C++ had no leading object-oriented design method, we usedexisting tools where applicable.andP;  Thus, our proposed alternatives should beseen more as a misuse of old notation than a proposal for new notation.andP;  Wethink some of the concepts expressed in this notation are important toobject-oriented design, but we continue to look for ways to improve thedetails.andM;Our design method assumes you start with an object-oriented analysis model.andO;This model consists of an ERD for all classes, a state-transition diagram(STD) for each class, and data-flow diagrams (DFDs) for each state of eachclass.andP;  (2) The model also has a data dictionary that describes all theclasses and their member variables.andP;  These classes are not introduced tosolve the problem, but are found in the problem itself An ERD shows theclasses, member variables to provide substance to the class names, and theinheritance and relationships between classes.andP;  An STD shows the life cycleor behavior of a class.andP;  A DFD shows the essential methods needed for aclass.andM;During object-oriented analysis, we are concerned about encapsulation.andP;  Weneed to find out which objects to include in our analysis and what are theirattributes.andP;  This information is noted on the ERD.andP;  Consider the classicexample of a computer game that guesses an animal by asking yes-no questions:(6-8) !!! BEGIN TABLE Does it have a long neck? andgt; yes Is it a giraffe? andgt; no Iguessed wrong.andP;  What animal were youandM;thinking of? andgt; an ostrich What is an additional question IandM;should have asked? andgt; Does it have feathers? Is the correct answer yes or no?andO;andgt; yes !!! END TABLEandM;The player chooses an animal and the game tries to guess it.andP;  The game asksthe player simple questions about the animal's characteristics before itmakes its guess.andP;  After each wrong guess, the game adds to its knowledge byasking the player about a new characteristic.andP;  Making an ERD from an analysisof this game is simple.andM;This problem involves animals and their characteristics.andP;  Animals have namesand an article (&quot;a&quot; or &quot;an&quot;).andP;  Characteristics have questions such as &quot;Doesthe animal swim?&quot; Each animal has many characteristics, and eachcharacteristic applies to many animals.andM;Since object-oriented analysis expresses classification and inheritance onERDs and we already have ERDs from the analysis, we also use them for design.andO;Think of the design ERD as a design-class browser.andP;  A design-class browser islike any other class browser except the source code for the classes doesn'texist yet, so the design is easier to change and only shows classes for oneproblem.andM;The design ERD graphically emphasizes the class design.andP;  Each class is shownas a rectangle with the class name and the member variables to tell what thename means.andP;  (Member variables are optional when the name is sufficient.) Thename and member variables help the designer determine class cohesion.andM;The class design is also emphasized by the connections between the classes.andO;These connections show inheritance and relationships.andP;  Usually only one ortwo connections exist between any two classes.andP;  From the design ERD, theoverall inheritance structure is easy to see and evaluate.andP;  Class coupling isshown by the number and type of class connections.andM;Analysis to designandM;We start design by copying the analysis ERD into a design ERD.andP;  The analysisclasses become first-cut design classes.andP;  Later we get a first cut of methodsfrom DFDs.andP;  Other support classes, such as collections, are introduced fromour development environment.andP;  Relationships represented by correlation tablesor referential attributes are often replaced by pointers to objects.andP;  Addingthis physical information to the analysis model is rather mechanical.andM;The next step is less mechanical and less well-defined.andP;  Some analysisclasses are merged together as a single design class.andP;  Other new designclasses are introduced to represent the &quot;mechanisms&quot; chosen by the designer.andO;The collection classes we added mechanically are common examples of thisstep.andP;  Other member variables are also added to classes to representredundant data or design mechanisms.andM;In our example, we've chosen to use the design of a binary tree.andP;  (Theanalysis does not imply a binary tree.andP;  This is strictly a design choice.) Westart our design ERD from our analysis ERD and add the class andrelationships for the binary tree.andM;The design introduces the game-node design class and implements thecharacterizes relationship as the parent_of, yes_branch, and no_branchrelationships.andP;  Since the parent_of relationship is separate from the othertwo, this points out early in the design that we must be careful aboutkeeping these relationships synchronized.andM;In going from design to analysis, the keys for the classes also changed.andP;  Thegame_node introduced its address as its key.andP;  The animal and characteristicclasses inherit the address key as well.andP;  The animal_name key of animalbecomes a secondary key.andP;  The article attribute from analysis has beencombined with animal_name, and the answer attribute is now implied by therecursive descent into the binary tree.andM;So far we have focused on the broad perspective of object-oriented classdesign.andP;  After sketching out the class design, we focus on individual classesand their methods.andP;  For this detailed design of a class we use ASGs.andP;  (9) Aclass is represented as a large rectangle with other icons inside for all ofthe pieces of the internal design.andP;  Messages passed between classes are drawnas invocations from one class method to another.andM;It is important not to cram all the design information--both class and methoddesign--into a single view.andP;  Since class and method design are different,they should have separate views.andP;  A software architect uses an ERD to sketchout many classes and a programmer uses an ASG to fill in the detail for eachclass.andP;  A combined view of class and method design has these disadvantages:andM;*  Since method design has much more detail, it has a lot more informationand visually overwhelms the class design.andP;  When you can't see the classdesign, you can't work with it.andP;  Since the class design is the architecture,a combined view obscures a critical part of the design.andM;*  Method design contains a lot of information by itself.andP;  Adding classdesign information to method design information would make the method designtoo obscure to read.andM;*  Because of the larger volume of information in a method design, a singlemethod design view typically focuses on only one class.andP;  Other classes may bedrawn without internal detail to show the interface to the primary class.andP;  Soa class design hierarchy that spans several classes, like an inheritancetree, would be split across several combined views.andM;Each class is represented as a package on an ASG.andP;  We realize that Adapackages are not classes.andP;  Each instance (object) of a class has the samestructure; that's what it means for them to be of the same class.andP;  We wouldnot want to have a package for each object since they would all be the sameexcept for some names and any change to a class would have to be repeated foreach instance ASG.andP;  We could use a generic for a class, which is a littlecloser than a package, but generics are even closer to parameterized classes.andO;Parameterized classes have only recently been standardized, andimplementations are rare.andM;Each method for a class is represented as a subprogram in the package for theclass.andP;  As a first cut, the processes on the analysis DFDs are renamed withphysical names as methods.andP;  The member variables are represented as dataobjects in the package.andP;  The attributes of the entities provide the membervariables.andM;Representing messagesandM;For each method in the class, we represent each message it passes to otherclasses as an invocation to a method.andP;  If only one method in one class hasthe method name, we simply draw the invocation to this method.andP;  Since we areconcerned with object-oriented design, we also have to account forpolymorphism and dynamic binding.andM;All messages are sent to an object (to an instance of a class).andP;  Within amethod, you may not know the specific class of an object to which a messageis passed during design.andP;  However, you know something about the class of theobject.andP;  In C++, you know at least a specific superclass of the object.andP;  InSmalltalk, you may assume a superclass or, in the worst case, assume theclass Object.andP;  In general, find the lowest class that is a superclass to allclasses with the method in which you are interested.andP;  In all cases, you knowat least one class for the object.andM;We show the invocation to the method of this known class only.andP;  We do notshow invocations to all the subclass methods that may be invoked duringexecution.andP;  This may seem wrong at first.andP;  Indeed, you could argue that thisdefeats the point of object-oriented design.andP;  In Smalltalk, this class maynot have this method at all because it is only implemented in all of itssubclasses.andM;However, we think showing only the invocation to the known class is betterfor a few reasons.andP;  First, the mechanism of dynamic binding is integral toobject-oriented programming.andP;  To model this mechanism in detail for eachmessage would be like modeling register saving during each subroutine call ina high-level procedural programming language.andP;  Second, multiple invocationswould make the diagrams more difficult to read.andP;  Third, the invoking methodis more tightly coupled to all possible subclasses that could implement theinvoked method.andP;  The level at which a method is implemented should beirrelevant to the invoking method, so the design should reflect this.andO;Instantiation is shown by invoking a constructor method with the same name asthe class, as in C++.andM;The visibility of member variables and methods may be indicated on the ASG byplacing the subprogram or data object on the edge of the package.andP;  This showsthat the member is public.andP;  If the member is private, it is placed away fromthe edge.andP;  The parameters passed in the message are shown as couples on theinvocation.andP;  We also show the object as a couple because it helps identifythe object being passed by the message if several are possible.andP;  The coupleson the invocation help evaluate coupling between methods.andP;  From theinvocations between methods we can evaluate fan-in, fan-out, and cohesion.andM;Even though we are misusing modeling tools, they are effective forobject-oriented design.andP;  The two views provide high- and low-levelperspectives on the problem.andP;  The complexity of the design is reflected inthe complexity of the diagrams.andP;  However, since we are misusing thesediagrams, some problems occur.andP;  The ASGs and ERDs use Ada andinformation-modeling terminology instead of object-oriented designterminology.andP;  Some more sophisticated techniques, such as typed constructors,are not well supported.andP;  Nevertheless, we feel this is a practical solutionusing existing technology for object-oriented design.andM;Structure chart alternativeandM;We have also &quot;misused' the structure chart (SC) from traditional structureddesign for method design.andP;  The general design approach is the same as usingERDs for class design, but SCs are used for the detailed method designinstead of ASGs.andP;  Various members of our development team have had successusing SCs to design their C++ projects.andM;A data-hiding module on an SC is similar to an ASG package.andP;  Both show theprocedural interface to hidden data.andP;  A data-hiding module does not show thedetails of how the procedures access that data, though an ASG package mayshow internal detail.andM;If you prefer to leave the internal details in module specifications(M-Specs) and data dictionary entries (DDEs), you can follow the previousdesign approach and leave the internal details out of the ASGs of use SCs.andO;To use SCs, you create the same design ERD, but draw an SC instead of an ASGfor each class.andM;A class is represented by a data-hiding module named for the class.andP;  A methodis represented by a sub-module of the data-hiding module.andP;  If a singledata-hiding module gets too crowded, simply use several with the same classname.andP;  Invocations and couples are used just as on ASGs.andP;  The membervariables of the class are listed in the DDE and on the design ERD.andP;  Thedetailed design of each method is described in M-Specs.andM;The choice between ASGs and SCs depends on your design conventions andpriorities.andP;  While ASGs represent the network nature of object interactionbetter than SCs, the hierarchy of SCs makes the flow of control a littleeasier to follow.andP;  ASGs show the packaging of methods within a class betterthan SCs.andP;  SCs do not show visibility as ASGs do, if visibility is importantin a particular design.andP;  SCs have more couple and module types than ASGs.andO;Indeed, for a particular project, some parts may be better represented withASGs and others with SCs.andP;  In either case, the detailed design of the methodsin an object-oriented design can be effectively represented.andM;Future workandM;The work described here can be expanded in several directions.andO;Obect-oriented design must be more tightly integrated with the rest of theobject-oriented software development life cycle.andP;  In particular, we wouldlike to see tight integration with the object-oriented analysis tools usedboth before design and, iteratively, during design.andP;  After design iscompleted, tools should be able to automatically generate code for C++ andother object-oriented languages.andM;ERDs should evolve into design-class browsers to be truly useful as anobject-oriented design CASE tool.andP;  A design-class browser would allow thedesigner to quickly and easily browse through the class hierarchies.andP;  Thison-line navigation aid should be used with additional hypertext-likeintegration of all views (ERD, ASG, and DDE) used in the method.andP;  (10)andM;Several object-oriented design methods have been published recently.andP;  (11-18)We are tracking them to see which are the best candidates for automation.andO;Object-oriented design methods will ultimately prove successful when the CASEtools are built to support them.andM;Using and extending ERDs and ASGs or SCs can support realworldobject-oriented design problems.andP;  Two views of an object-oriented design (forclass and method design) are necessary for complicated systems.andP;  We have usedthese approaches successfully on several projects and plan to expand theiruse.andP;  As the methods and notations mature, CASE tools will be built tosupport them.andM;This article would not have been possible without Cadre's managementcommitment to support object-oriented development, nor without theobject-oriented design and development work done by various members of theTeamwork development team.andP;  Special thanks- to Fred Barrett, Lou Bershad, joeCascio, Read Fleming, Dave Fortin, and to this article's many reviewers.andO;This work was done while Alan Hecht was employed by Cadre.andM;ReferencesandM;1.andP;  Wybolt, N. &quot;Experiences with C++ and Object-Oriented SoftwareDevelopment,&quot; in US.ENIX C++ Conference Proceedings, San Francisco, Calif.,andO;Apr. 9-11, 1990, pp.andP;  1-9.andM;2.andP;  Shlaer, S., and S.J.andP;  Mellor.andP;  Object-Oriented Systems Analysis: Modelingthe World in Data.andP;  Englewood Cliffs, N.J.:Yourdon Press, 1988.andM;3.andP;  Hecht, A., and A. Simmons.andP;  &quot;The Automation of Structured Analysis andStructured Design,&quot; in Sixth Phoenix Conference on Computers andCommunications, Scottsdale, Ariz., Feb. 1987.andM;4.andP;  Page-Jones, M. The Practical Guide to Structured Systems Design, 2nd ed.andO;Englewood Cliffs, NJ.: Yourdon Press, 1988.andM;5.andP;  Loy, P.H.andP;  &quot;A Comparison of Object-Oriented and Structured DevelopmentMethods,&quot; in Proceedings, 1989 Pacific Northwest Software Quality Conference,Portland, Ore., Sept. 1989, pp.andP;  12-26.andM;6.andP;  Glockenspiel.andP;  Advanced Object-Oriented Design and Hands- On C++.andP;  Coursematerial, Providence, R.I., 1988.andM;7.andP;  Cooper, D., and M. Clancy.andP;  Oh! Pascal!, 2nd ed.andP;  New York, N.Y.: W.WNorton, 1985.andM;8.andP;  Kaehler, T., and D. Patterson.andP;  &quot;A Small Taste of Smalltalk,&quot; BYTE 11(8):145-159, Aug. 1986.andM;9.andP;  Buhr, R.J.A.andP;  System Design with Ada.andP;  Englewood Cliffs, N.J.: PrenticeHall, 1984.andM;10.andP;  Hecht, A. &quot;The Hypertext Features of the Teamwork Analysis and DesignSystem,&quot; in Proceedings of CASE  88-Second International Workshop onComputer-Aided Software Engineering, Cambridge, Mass., July 1988.andM;11.andP;  Booch, G. &quot;Tutorial on Object-Oriented Design,&quot; OOPSLA 89, New Orleans,La., Oct. 1-6, 1989.andM;12.andP;  EVB Software Engineering Inc. Object-Oriented Software for Ada Software.andO;Frederick, Md.: Benjamin/ Cummings, 1987.andM;13.andP;  European Space Agency.andP;  HOOD Reference Manual 3.0, ref.andP;  WME/89-173-JB,Sept. 1989.andM;14.andP;  Page-Jones, M., and S. Weiss.andP;  Synthesis: Object- Oriented Analysis andDesign.andP;  Course material, Wayland Systems, Seattle, Wash., 1989.andM;15.andP;  Seidewitz, E., and M. Stark.andP;  &quot;Toward a General Object-Oriented SoftwareDevelopment.&quot; ACM Ada Letters VII(4): 54-67, July/ Aug. 1987.andM;16.andP;  Thomas, D., and I. Jacobson.andP;  &quot;Managing Object-Oriented SoftwareEngineering.&quot; Tutorial at OOPSLA '89, New Orleans, La., Oct. 1-6, 1989.andM;17.andP;  Ward, P.T &quot;How to Integrate Object Orientation with Structured Analysisand Design.&quot; IEEE Software, Mar. 1989, 74-82.andM;18.andP;  Wasserman, A.I., P.A.andP;  Pircher, and R.J.andP;  Muller.andP;  &quot;An Object-OrientedStructured Design Method for Code Generation.&quot; A CM SIGSOFT SoftwareEngineering Notes 141l): 32-55,jan.andP;  1989.andM;David K. Taylor is a consultant software engineering with Cadre TechnologiesInc. in Providence, R.I.andM;Alan Hecht is a principal of Mesa Systems Guild Inc. in Providence, R.I.andO;Artwork: Designosaur</TEXT></DOC>