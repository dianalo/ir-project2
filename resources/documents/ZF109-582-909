<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF109-582-909  </DOCNO><DOCID>09 582 909.andM;</DOCID><JOURNAL>Hewlett-Packard Journal  Oct 1990 v41 n5 p32(7)* Full Text COPYRIGHT Hewlett Packard 1990.andM;</JOURNAL><TITLE>HP IVIBuild: interactive user interface builder for HP IVI. (HPInteractive Visual Interface)</TITLE><AUTHOR>Witten, Steven P.; Bienz, Hai-Wen L.andM;</AUTHOR><SUMMARY>HP IVIBuild is the editor/builder component of HP IVI.andP;  It is usedinteractively to build user interfaces.andP;  It promotes softwaredevelopment in rapid prototyping and the design and modificationof user interfaces.andP;  The interface areas supplied by HP IVIBuildare the utility box, which displays current object information andthe menus for object manipulation; the tool box, the area wherethe user selects the objects to be manipulated; and the workspace,the area that displays the windows being created.andP;  The content ofthe user's input can be controlled by HP IVIBuild.andP;  HP IVIBuildcan handle native language support and user customization.andP;  Theobjectives in designing HP IVIBuild were to make it a powerful,easy-to-use tool to complement the HP IVI application programinterface functions and to be the first API application to providefeedback to the API development team.andM;</SUMMARY><DESCRIPT>Topic:     User InterfaceSoftware EngineeringObject-Oriented ProgrammingProgram Development ToolsGraphical User InterfaceProduct Development.andO;Feature:   illustrationchart.andO;Caption:   The components that make up the HP IVIBuild architecture. (chart)Interface areas of HP IVIBuild. (chart)the state transition process. (chart)andM;</DESCRIPT><TEXT>HP IVIBuild: Interactive User Interface Builder for HP IVIandM;THE EDITOR/BUILDER COMPONENT OF THE HP Interactive Visual Interface productis HP IVIBuild.andP;  As its name implies, HP IVIBuild is a tool that is used tobuild user interfaces interactively.andP;  The windows and objects that make upthe user interface can be saved in a file and reused later by otherapplications using the API functions (see Fig.andP;  1).andP;  HP IVIBuild is itself anHP IVI application program because it uses the API functions described onpage 11 as a platform.andP;  Fig.andP;  2 shows the architecture of HPIVIBuild.andM;Early in the design of HP IVIBuild we realized that although the HPIVIapplication program interface (API) functions are several orders of magnitudeeasier to use than Xlib, the X toolkit, and widgets, they are still verycomplex to many users.andP;  Therefore, an interactive user interface design tool,HP IVIBuild, was developed to complement the API functions.andM;HP IVIBuild helps promote software development productivity in areas such asrapid prototyping and the design and modification of user interfaces.andP;  Forrapid prototyping, HP IVIBuild allows developers to create complex prototypeuser interfaces.andP;  The user can interactively place and size all of theprimitive graphics and widget objects in a window.andP;  Once the objects areplaced and sized, many of their physical attributes such as colors, shadows,strings, and fonts can be changed easily within HP IVIBuild.andP;  Even someonewho does not have any software background, such as a human factors expert,can use HP IVIBuild to design a complex user interface.andP;  This means that anapplication's user interface can be prototyped and evaluated separately fromthe operations performed in the application.andM;Besides restoring the user interfaces created with HP IVIBuild, the APIfunctions in the application also make the objects in the interface react touser input.andP;  Callback functions, which are invoked in response to user inputto the application, can be attached to those objects that should respond touser input.andP;  If the application requires changes to the user interface inresponse to application or customer needs, the previously saved userinterface can be modified with HP IVIBuild.andP;  If the changes involve addingnew objects, callbacks can be added to the new objects using the APIfunctions in the application program.andP;  However, if changes are made toexisting objects, no changes need to be made to the application program.andM;Fig.andP;  3 shows the interface areas provided by HP IVIBuild.andP;  The functions ofthese areas are:andM;* Utility box.andP;  This area displays current object information and the menusfor object manipulation.andM;* Tool Box.andP;  This is the area in which the user selects the objects to bemanipulated.andM;* Workspace.andP;  This area displays the windows being created.andM;Object-Oriented Design in HP IVIBuildandM;HP IVIBuild uses the API functions and the facilities provided by the HP IVIobject-oriented environment to build its own object-oriented system.andP;  Theobject-oriented concepts of objects, polymorphism, and inheritance areincorporated into the design of HP IVIBuild.andM;Objects.andP;  In HP IVIBuild objects are very simple data structures calledstates.andP;  A state is the context of user input (i.e., the operation inprogress) at any particular point in time.andP;  All states are static (bound atcompile time) and have the same structure.andP;  Only one field in the structure,called a message selector, is filled in at run time.andP;  This field is used tobind HP IVIBuild's user interface presentation to its functionality.andP;  Userinterface binding and functionality are discussed later in this article.andP;  Thefollowing is the C language structure of a typical state object.andM;CLASSVARDS(ClassVars)  /* This macro is included for */ /* compatibility withthe HP IVI */ /* object-oriented environment and */ /* is not used by HPIVIBuid.andP;  */andM;extern struct ClassDef_DzRect;  /* Structure containing pointers to */ /*this state's method dispatch */ /* tables.andP;  This structure is */ /* createdby the API rtc tool.andP;  */andM;static INT32 groupmembership []  {/* Array containing a state's */ =NULL  /*group membership information.andP;  */ };  /* The purpose of this array is to *//* help limit state transitions */ /* at certain times.andP;  Currently */ /* thisfeature is not used in */ /* HP IVIBuild.andP;  */andM;static char objectname[] = &quot;s_rect&quot;; /* this state's name */andM;/* All state objects have the following structure.andP;  */andM;static struct DzRect{ struct ClassDef*class; /* Pointer to the dispatchtables.andP;  */ char*statename; /* Pointer to the state's name.andP;  */ INT32clsindex; /* A unique id assigned to this state.andP;  */ INT8 autoterm; /* Thisstate's autotermination */ /* flag (if TRUE the state machine */ /*terminates the state and if FALSE */ /* an action by the user must */ /*terminate the state).andP;  */ INT32 selector; /* Message sent to the currentstate */ /* to cause a transition to this */ /* state.andP;  */ INT32*group;  /*Pointer to this state's group */ /* membership information.andP;  */ }andM;/* Data values assigned to the fields defined above */andM;_state_rect = { /* Initialization.andP;  */ andamp;_DzRect, /* Pointer to dispatchtables.andP;  */ objectname, /* Pointer to name.andP;  */ 27, /* State's id number.andP;  */FALSE, /* State is NOT autoterminating.andP;  */ _s_rect, /* Message selector thatcauses */ /* transition to this state.andP;  */ groupmembership /* Pointer togroup membership */ /* information.andP;  */ };andM;idState s_rect = (idState)andamp;_state_rect; /* A pointer to this state */ /* thatis used by HP IVIBuild */ /* to access and manipulate */ /* data in thisstructure.andP;  */andM;Inheritance.andP;  In HP IVIBuild, as in most object-oriented systems, stateobjects are arranged in a hierarchy.andP;  At the root of the hierarchy is aspecial state known as the root state (see Fig.andP;  4).andP;  The root state in HPIVIBuild manages interstate transitions.andP;  Since the root state is at the topof the object hierarchy, it implements many more methods than the otherstates in HP IVIBuild.andP;  Using inheritance, the lower-level objects inheritall the methods from the root state.andP;  This inheritance mechanism is used toimplement state transitions in HP IVIBuild.andM;Polymorphism.andP;  HP IVIBuild's central input handling facility, which is calledthe state machine, depends on the concept of polymorphism.andP;  All states in HPIVIBuild have the same operational interface (i.e., the state object ispolymorphic).andP;  Therefore to the state machine, all states look the same andare able to respond to the same set of messages.andP;  The state machine does notknow or care which state is currently active.andP;  It only knows that the currentstate either implements or inherits all the methods that are the targets ofmessages being sent to it.andM;The box on page 29 provides a brief review of object-oriented concepts andthe HP IVI object-oriented environment.andM;Input HandlingandM;Messages sent by the state machine to a particular state can result in eitheran interstate transition or an intrastate transition depending on the messagethat is sent.andP;  Interstate transitions are transitions among the various stateobjects of HP IVIBuild, and intrastate transitions are transitions within aparticular state object.andM;A new state becomes current by an interstate transition.andP;  Interstatetransitions are handled by the state machine.andP;  All input in HP IVIBuild goesthrough the state machine.andP;  The state machine is an API callback functionthat is attached to all the components of HP IVIBuild's user interface andall of the workspace windows created by the user.andP;  The objects in the HPIVIBuild user interface are called user-interface objects, and the objectscreated by the user during an HP IVIBuild session are called user-workspaceobjects.andP;  Using this mechanism, HP IVIBuild is able to control the context ofthe user's input.andP;  This is an important requirement of any interactive designtool.andM;The state machine performs the following functions:andM;* It changes the active workspace windows when the user requests it.andM;* It interprets the meanings (context) of the mouse buttons when they arepressed in the active workspace window according to a user-definable mousebutton map.andM;* It sends messages to the current state.andM;* It manages the state stack.andP;  The state stack is an array of mesageselectors for the state objects.andM;* It makes new states current and terminates others that have completed.andM;The Current StateandM;There is always a state that is active.andP;  This state is called the currentstate.andP;  The current state is always the state to which the state machinesends any messages.andP;  It is up to the current state to provide a target methodfor any messages that the state machine may sent it.andP;  The target method islocated either by implementation or by inheritance.andP;  If no operation is inprogress (i.e., only one state on the stack), the current state is the rootstate.andP;  If an operation is in progress, the current state is the state thatimplements that operation (e.g., creation of an object such as a polyline orwidget).andM;No state knows which state was current before it became current and no stateknows which state will become current after it ceases being current.andP;  Theserules were strictly enforced to ensure the black-boxe nature of each state'smethods during design and testing.andM;Once current, a state controls the context of the user's input according to astate transition mechanism of its own.andP;  These state transition mechanisms arecalled intrastate transitions and are controlled entirely by the state itselfusing a local variable called a substate.andP;  For example, moving forward orbackward in a sequence of actions that are part of one particular operation,such as creating a polyline, is controlled entirely by the state itself.andP;  Thesubstate mechanism is described later in this article.andM;State Stack ManagementandM;During the execution of HP IVIBuild the states that are activated by the userare organized in a LIFO (last-in, first-out) stack (see Fig.andP;  5).andP;  The statemachine provides a mechanism to suspend operations in progress to do anotheroperation and then resume the suspended operation when the new operationfinishes.andP;  The state at the top of the stack represents the current contextof the user's input and is the current state.andP;  Only the current state canreceive any messages.andP;  The maximum depth of the state stack is defined to beten states.andP;  This is an adequate depth because there are other mechanisms inHP IVIBuild that prevent the state stack from growing to a depth of more thanthree or four states.andP;  The root state enters the state stack first andremains there during the entire execution of HP IVIBuild.andP;  Therefore, theroot state is always in the stack regardless of the depth of the stack.andM;At each interstate transition, the state machine checks the autoterminationflags of each state in the state stack.andP;  If the autotermination flag is TRUE,that state is terminated immediately by the state machine and removed fromthe state stack.andP;  The state stack is then compacted and the state ending upat the top of the stack is started.andP;  If the autotermination flag is FALSE,only an action by the user can terminate the state.andM;State Transition and InheritanceandM;As mentioned earlier, an interstate transition is the process of making a newstate (a state not currently on the state stack) the current state.andP;  The newstate is placed at the top of the state stack and started by the statemachine.andP;  The state transition process begins when an event occurs such as abutton release over an object on the display.andP;  The first thing to happen isthat the state machine function is called as part of the normal API callbackprocessing (see page 23).andP;  The state machine function is passed a pointer tothe ZtUSER_DATA attribute of the object that received the event, which has apointer to the message selector that, when sent to the current state, willcause an interstate transition to a new state.andP;  The state machine sends themessage to the current state.andP;  This process works the same way for HPIVIBuild user-interface objects and user-workspace objects, except thatuser-workspace objects always send a hit message to the current state.andP;  Awindow created by the user is the only user-workspace object that functionslike a user-interface object.andP;  A hit message results when a user presses amouse button in a workspace window.andM;If the current state can handle the message, the method that is called willeither return a pointer to the current state or a NULL.andP;  This pointer isreturned to the state machine as part of the normal message sending mechanismof the HP IVI object-oriented environment.andP;  States return pointers tothemselves when they want to remain current.andP;  This will cause an intrastatetransition.andP;  States return NULL when they receive an exit message and want tocease being the current state.andP;  This will cause an interstate transition.andO;Fig.andP;  6 shows a portion of the state transition process.andM;Since the root state is the parent of all other states, the interstatetransition process depends heavily on inheritance.andP;  Each state inherits allthe methods from the root state.andP;  When a state receives a message for whichit does not have a method, the HP IVI object-oriented environment will searchthe current state's lineage (object hierarchy) until it finds the targetmethod for will always be found in the root state.andP;  The target method in theroot state returns a pointer via the object-oriented environment's messagingsystem to the state object that is to be made the current state.andP;  This is thepointer that the state machine compares to the value of the pointer for thecurrent state.andP;  When it sees that the two pointers are different, it placesthe new pointer at the top of the state stack (making the state current) andsends a start message to the new state.andP;  Thus, by inheritance, every stateobject has the ability to activate any other state object.andM;When an intrastate transition occurs, there is no change to the current state(i.e., the pointers are equal).andP;  The current state handles the incomingmessage itself.andM;State ProtocolandM;All states follow a specific protocol that is implemented in the statemachine of HP IVIBuild.andP;  Fig.andP;  7 illustrates this protocol.andP;  An interstatetransition (Fig.andP;  7a) occurs when the current state receives an exit messageand it returns a NULL to the state machine indicating that it wants to ceasebeing the current state.andP;  The state machine makes the new state the currentstate and sends a start message to the new state.andP;  The new state remains thecurrent state as long as it continues to return a pointer to itself to thestate machine (e.g., Current State in Fig.andP;  7b).andP;  Following this protocolallows a state to control the meaning of user input within its own context.andO;Each state implements or inherits five standard methods that constitute itsoperational interface: start, hit, backup, undo, and exit.andM;Start.andP;  As shown in Fig.andP;  7, the start message is the first message a statereceives before any other message is sent to the state (except exit).andM;Hit.andP;  A state gets a hit message when the user presses a mouse button in theworkspace window that is currently active.andP;  HP IVIBuild allows the user toconstruct and edit as many windows as desired but only one can be active at atime.andP;  To activate another window, the user only has to press a mouse buttonover the window that is to become active.andP;  Depending on their hit methods,states are classified as either multiaction or single-action states.andM;A multiaction state requires the user to select multiple points in the activewindow to perform the operation implemented by the state.andP;  An example of amultiaction state is one that allows the user to create polylines or splines.andO;When the user presses a mouse button in the active window and a multiactionstate is the current state, the action of the state is said to go forward.andO;Fig.andP;  8 shows the interstate transition diagram for a multiaction state thattranslates objects.andM;A single-action state does not require a hit in the active window to goforward.andP;  Single-action states can only do one thing.andP;  An example of this areselections (i.e., states that select certain kinds of objects for furtheroperations).andP;  Once the class of objects that are to be selected is known, theobjects are selected and no further input from the user is required.andP;  Anysingle-action state that receives a hit message is terminated and removedfrom the state stack.andP;  The hit message is sent to the the new current state.andO;Fig.andP;  9 shows the interstate transition diagram for all single-action states.andM;Backup.andP;  All multiaction states implement backup.andP;  This is the reverseoperation of a hit message because it allows the user to cause the action ofthe state to go backward over a previously sent hit.andP;  No single-action statesimplement back-up.andM;Undo.andP;  All states implement undo.andP;  Undo allows the user to back a state up tothe point right after it received its first start.andP;  This has the effect ofundoing any actions that had been performed by the state.andP;  Undo may also besent immediately after a previous undo to effect a redo operation.andM;Exit.andP;  A state is sent an exit immediately before its removal from the statestack.andP;  This allows the state to reinitialize itself for its next activation.andM;The SubstateandM;Once current a state controls its own actions using a local variable calledthe substate.andP;  During a sequence of operations, the messages start, backup,hit, and undo may be sent repeatedly to the current state.andP;  These actions donot cause interstate transitions.andP;  Rather, they cause interstate transitions.andO;The current state does not change but the meaning of the next input event mayhave to be interpreted differently depending on the sequence of messages thestate has received since it was made current.andP;  The value of the substate ischanged to reflect the context of the next hit, backup, or undo.andP;  Note thatstart is always sent after every action whether the action causes anintrastate or interstate transition.andP;  This is part of the protocolestablished for a state by the state machine.andM;UniformityandM;Great care was taken to ensure that the same actions have uniform behavior nomatter which state is current.andP;  The HP IVIBuild team developed guidelines fordeveloping states, and intrastate transition diagrams were developed beforethe development of a particular state so that the uniformity of actions couldbe assessed by the whole team.andP;  The result is a tool with very modular unitsof functionality that all behave in a consistent and intuitive manner.andM;The HP IVIBuild User InterfaceandM;HP IVIBuild's user interface was designed as a collaborative effort betweenthe HP IVIBuild team members and the industrial design department at HPSoftware Engineering Systems Division (see the article on page 39).andP;  Theobjective of the collaboration was to design a user interface for HP IVIBuildthat was both attractive and intuitive to the user.andM;Besides the appearance, HP IVIBuild is structured to handle native languagesupport and user customization.andP;  One other interesting feature is that the HPIVIBuild user interface presentation is not bound to the functionality untilrun time.andM;Native Language Support and CustomizationandM;HP IVIBuild's user interface conforms to HP standards regarding support fornative languages and cultures.andP;  All text that is presented to the user suchas labels, prompts, and error messages is contained in message catalogs andis retrieved by HP IVIBuild at run time.andP;  To localize HP IVIBuild, the useronly needs to change the contents of the catalogs.andP;  In general, these tasksare performed by HP personnel in the country whose native language is thetarget language.andP;  This way, text can be presented with as much contextsensitivity as possible.andP;  Idiomatic nuances of text presentation are not lost(as they sometimes are with straight translations).andM;Another feature of HP IVIBuild's user interface presentation is that colors,tiles, fonts, mouse button bindings and icons can be customized forindividual users by modifying the X Window System configuration fileXdefaults.andP;  This mechanism allows individual users to customize thepresentation of IVIBuild's user interface to suit their own needs (e.g.,andO;left-handedness, black-and-white display).andM;Presentation and Functionality BindingandM;The Presentation of the components that make up the user interface of HPIVIBuild (i.e., the buttons, menus, windows, etc.) and the functionality (thestates) associated with these components are bound together at run time.andP;  Thefunctionality of HP IVIBuild, that is, the result of pressing a certainsequence of buttons, is not dependent on the user interface presentation.andO;For example, in one user interface presentation, drawing a rectangle might beaccomplished by selecting buttons labeled P1 and P2 for the lower-left andupper-right corners of a rectangle and typing the coordinates into a pop-updialog box.andP;  In another user interface, drawing a rectangle might be athree-button sequence in which the user presses the Rectangle button and thenclicks on the desired coordinates with the mouse.andP;  In either interface, thestate operations result in a rectangle.andM;The binding of functionality to user interface presentation is done when HPIVIBuild starts up.andP;  At this time the objects (windows, menus, buttons, etc.)andO;that make up the HP IVIBuild user interface are restored from a file.andO;Pointers to objects (Ztids) that activate states or send messages to thestate machine are looked up using the name of the object that was assignedwhen the object was created with the API functions.andP;  This lookup isaccomplished using an API function.andP;  When the Ztld for an object is returned,the message selector for the state to be activated is retrieved.andP;  At thispoint a callback object (ZtCALLBACK_OBJ), which will call the state machinewhenever an event occurs on the user interface object, is created for theuser interface object.andP;  Also, the message selector from the state object ismade an attribute (ZtUSER_DATA) ot the user interface object.andP;  Once thecallback object is attached to the user interface object, the binding iscomplete (see Fig.andP;  10).andP;  When a specified event occurs on a particular userinterface object, the interstate transitions described earlier occur.andP;  Thisscheme makes the state machine a callback for every IVIBuild user interfaceobject and for every workspace window the user creates.andM;Separating the user interface presentation from functionality means that thepresentation can be developed independent of functionality and the samefunctionality can be easily given a new presentation.andP;  New functionality canbe added and tested in a straightforward way without worrying about itspresentation.andM;ConclusionandM;HP IVIBuild was conceived with two objectives in mind: to be a powerful,easy-to-use tool to complement the HP IVI application program interfacefunctions and to be the first API application and as such to provide feedbackto the API development team.andP;  Both of these objectives have beenaccomplished.andP;  We believe theat HP IVIBuild's functionality and designed-inextensibility based on an object-oriented architecture are among the firstfor tools of this type.andM;Steven P. WittenandM;The principal architect of the HP IVIBuild portion of the HP interactiveVisual Interface, Steve Witten implemented the state machine and window andmodel handling for the project.andP;  Now an Randamp;D engineer at HP's IndustrialApplications Center, he joined HP's Data Systems Division in 1978.andO;Initially, he worked on Datacap/1000 and supported HP 307x terminals, andthen developed an energy management system for HP using the PMC/1000 system.andO;Before joining HP, he worked for Environmental Research and Technology, Inc.,andO;where he compiled a data base of airborne sulfate/particulate measurementsfor the Electrical Power Research Institute's study of acid rain.andP;  Steve is afrequent contributor INTEREX, the HP users group, writing techical articleson object-oriented programming.andP;  A member of the Institute of IndustrialEngineers, his professional specialty centers around object-orientedtechnology.andP;  He received a BS degree in computer science in 1974 and an MEdegree in industrial engineering in 1976 from the California PolytechnicState University in San Luis Obispo.andP;  Born in Bakersfield, California, Steveis married, has two daughters, and lives in San Jose.andP;  His hobbies includecomputers and reading detective novels.andM;Hai-Wen L. BienzandM;Hai-Wen Bienz was responsible for the development of the graphic objects anddynamics in the HP IVI application program interface.andP;  She joined HP in 1985and served as a publications engineer at HP's Santa Clara Division, and lateras a marketing engineer for the Strategic Grants program at HP Laboratories.andO;Hai-Wen's professional interests include designing user interfaces andsoftware tools to enhance productivity.andP;  Before joining HP, she was a coopstudent and engineer at General Motors Corp., where she developed real-timedigital control systems.andP;  Hai-Wen earned a Bachelor's degree in electricalengineering from the General Motors Institute in 1983 and an MS degree inelectrical engineering from the University of Illinois at Urbana-Champaign in1984.andP;  She is married and lives in Naperville, Illinois.andP;  Her interestsinclude mountaineering, skiing, photography, cooking, and hiking.andO;</TEXT></DOC>