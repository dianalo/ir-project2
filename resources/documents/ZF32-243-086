<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO> ZF32-243-086 </DOCNO><DOCID>09 754 755</DOCID><JOURNAL>PC Magazine  Jan 15 1991 v10 n1 p435(4)* Full Text COPYRIGHT Ziff-Davis Publishing Co. 1991.andM;</JOURNAL><TITLE>Environments: showing your colors: GPI functions for implementingcolor. (column)(Graphics Programming Interface) (tutorial)</TITLE><AUTHOR>Petzold, Charles.andM;</AUTHOR><SUMMARY>Users can create a new logical color table using theGpiCreateLogColorTable function to go beyond the standard 16colors under the OS/2 Graphics Programming Interface (GPI).andP;  Usersperform the function to use different mapping of color indexes to24-bit RGB color values in the GpiSetColor function.andP;  They canalso create an RGB color table that lets them use 24-bit RGBvalues directly in the GpiSetColor function.andP;  Users create the newlogical color table for a presentation space by callingGpiCreateLogColorTable.andP;  Users should be aware of the GpiErasefunction when creating a new logical color table since it willerase the background oa window that uses the color correspondingto color index 0.andP;  They should use WinFillRect or GpiBox insteadto erase the window background.andP;  Extensive details are presentedon querying and creating the logical color table.andM;</SUMMARY><DESCRIPT>Topic:     OS/2ColorTutorialProgram Development SoftwareComputer graphicsGraphics SystemsProgrammingInterface.andM;</DESCRIPT><TEXT>In the last issue, I showed how to select color under the OS/2 GraphicsProgramming Interface (GPI) using GpiSetColor and some other functions.andP;  Thesecond parameter to GpiSetColor is a color index.andP;  Normally, the color indexis one of the constants defined in the PMGPI.H header file that begins withthe CLR prefix, such as CLR_BLUE and CLR_DARKRED.andM;You use the color indexes to select one of 16 standard colors.andP;  These 16colors are familiar to anyone who has done character-mode programming for theIBM CGA, EGA, or VGA video boards, because they're derived from the 4-bitIRGB (intensity-red-green-blue) color encoding used on these adapters.andM;I also showed how you can use Gpi-QueryRGBColor to obtain the 24-bit RGBcolor value associated with each color index.andP;  A 24-bit color value consistsof 3 bytes for the levels of red, green, and blue.andP;  (This value is stored asa 32-bit long integer with the most significant byte set equal to 0.) Thecomplete mapping of color indexes to 24-bit RGB color values is known as thelogical color table.andM;In addition, I showed how you can use GpiQueryRealColors to obtain thephysical color table.andP;  The physical color table is the complete collection of24-bit RGB color values currently available on the output device.andP;  Thesevalues correspond to the video adapter's palette registers as set by thepresentation driver for the video board.andM;Only 16 colors can be displayed simultaneously on the standard IBM EGA andVGA boards when used in the high-resolution video mode required by the OS/2Presentation Manager.andP;  Hence, the physical color table has 16 entries.andP;  Usingthe color indexes allows you to select any of these 16 colors.andM;However, the IBM 8514/A and some Super VGA adapters can display 256 colorssimultaneously, so the corresponding physical color table has 256 entries.andO;But using the color indexes allows you to select only 16 of these colors.andO;The color indexes are certainly convenient for simple color selection, butthey're inadequate for any extensive use of color.andM;In this issue we'll explore how to go beyond the standard 16 colors.andP;  Thisinvolves creating a new logical color table using the GpiCreateLogColorTablefunction.andP;  You can use this function to specify a different mapping of colorindexes to 24-bit RGB color values and then use these new indexes in theGpiSetColor function.andP;  You can also use GpiCreateLogColorTable to create anRGB color table that allows you to use 24-bit RGB values directly in theGpiSetColor function.andP;  But before we create a new logical color table, let'sexamine how we can query it.andM;QUERYING THE LOGICAL COLOR TABLEandM;As I mentioned, the logical color table is the complete mapping of colorindexes to 24-bit RGB color values.andP;  For any particular color index, you canobtain the 24-bit RGB color value by calling GpiQueryRGBColor.andP;  To obtain thecomplete logical color table (or a subset of it), you use theGpiQueryLogColorTable function.andP;  Generally, you'll need to preface a call toGpiQueryLogColorTable with a call to GpiQueryColorData.andM;You begin by defining an array of three LONG numbers:andM;LONG alData[3] ;andM;You use this array as the last parameter to the GpiQueryColorData function:andM;GpiQueryColorData  (hps, 3L, alData);andM;The third parameter can be set to less than 3 if you don't need all theinformation, but you'll almost always want it all.andP;  The function sets thethree elements of the alData array.andP;  You can then index the array using threeconstants that begin with the prefix QCD_LCT (query color data for thelogical color table).andM;The first element of the color data array can be obtained usingandM;alData [QCD_LCT_FOMAT]andM;This particular value will be either LCOLF_DEFAULT, LCOLF_INDRGB, orLCOLF_RGB.andP;  The LCOLF prefix stands for logical color format.andP;  A value ofLCOLF_DEFAULT indicates the default logical color table.andP;  This is what you'llget if you haven't created a new logical color table for the presentationspace by calling GpiCreateLogColorTable or if you've used theGpiCreateLogColorTable function to reset the default logical color table.andM;A value of LCOLF_INDRGB (index-RGB) indicates that GpiCreateLogColorTable hasbeen used to create a new logical color table that maps color indexes to24-bit RGB color values.andP;  I'll show you how to do this shortly.andM;A value of LCOLF_RGB indicates that GpiCreateLogColorTable has been used tocreate an RGB color table in which you use 24-bit RGB values directly whensetting colors.andP;  I'll also demonstrate how you do this.andM;You obtain the second and third elements of the color data array usingandM;alData [QCD_LCT_LOINDEX)andM;andandM;alData [QCD_LCT_HIINDEX)andM;These two values are the lowest and highest color indexes in the logicalcolor table.andP;  Depending on the format of the logical color table, they'll beset as follows:andM;Format             Low   HighandM;LCOLF_DEFAULT      0     15andM;LCOLF_INDRGB       ?andP;     ?andM;LCOLF_RGB          0     0andM;The question marks for LCOLF_INDRGB indicate that the low and high colorindexes depend on the range of indexes specified when the logical color tablewas created.andM;If the format is LCOLF_RGB, you already know everything there is to knowabout the logical color table.andP;  The RGB color table allows you to use 24-bitRGB values directly in the GpiSetColor function.andM;Otherwise, let's set a couple of variables using the second and thirdelements of the color data array:andM;1Lo= alData [QCD_LCT_LOINDEX];andM;1Hi = alData [QCD_LCT_HIINDEX];andM;The number of entries in the logical color table can be calculated usingandM;1Num = 1Hi - 1Lo + 1 ;andM;Actually, this may not be exactly the number of entries, because some of theindexes in the range between 1Lo and 1Hi may be undefined.andM;You can now allocate a block of memory to  store the logical color tableandM;alTable = malloc (1Num *andM;sizeof(LONG)) ;andM;where alTable is defined as a pointer to LONG.andP;  You pass this pointer as thelast parameter to GpiQueryLogColorTable:andM;GpiQueryLogColorTable (hps, 0L,andM;1Lo, 1Num, alTable) ;andM;On return, the alTable array will contain the 24-bit RGB color valuesassociated with the color indexes ranging from 1Lo to 1Hi.andM;The general syntax of GpiQueryLogColorTable isandM;GpiQueryLogColorTable (hps,andM;flOption, 1Start, 1Num, alTable) ;andM;The flOption parameter can be set to either 0L or LCOLOPT_INDEX.andP;  If thelatter, then alTable will contain alternating color indexes and RGB colorvalues.andP;  In this case, the memory block allocated for the color table must betwice as large and 1Num must be doubled.andM;CREATING A LOGICAL COLOR TABLEandM;You can create a new logical color table for a presentation space by callingGpiCreateLogColorTable.andP;  This function is somewhat complex, so I'll beginwith some examples.andM;Suppose you've spent years (perhaps almost a decade) programming incharacter-mode on IBM color video displays.andP;  The IRGB color encoding is soingrained in your head that you simply can't use anything else.andP;  What you'llwant to do is use GpiCreateLogColorTable to create a new color table thatlets you use these IRGB values in the GpiSetColor function.andM;First, initialize an array that contains the 24-bit RGB values thatcorrespond to the 4-bit IRGB color encoding:andM;static LONG alTable[16] =andM;{ 0x000000,   0x000080,andM;0x008000,   0x008080,andM;0x800000,   0x800080,andM;0x808000,   0x808080,andM;0x404040,   0x0000FF,andM;0x00FF00,   0x00FFFF,andM;0xFF0000,   0xFF00FF,andM;0xFFFF00,   0xFFFFFF, } ;andM;after this is done, call GpiCreateLogColorTable in the following manner:andM;GpiCreatLogColorTable (hps,andM;LCOL_PURECOLOR,andM;LCOLF_CONSECRGB,andM;0L, 16L, alTable) ;andM;The second parameter is a flag that indicates you want the color indexes tomap to pure (that is, undithered) colors.andP;  The third parameter indicates thatthe color table contains consecutive 24-bit RGB color values.andP;  The next twoparameters indicate that the table begins at color index 0 and contains 16entries.andP;  The alTable array is the last parameter.andM;You can now use IRGB color values in the GpiSetColor function.andP;  For example:andM;GpiSetColor (hps, 4L);andM;will be dark red.andM;Let's try another example.andP;  Suppose your program needs to incorporate variousgray shades for filling areas.andP;  You would prefer to use color indexes thatindicate the level of gray, beginning with 0 for black and ending with 16 forwhite.andP;  You can define the color table array like this:andM;static LONG   alTable[17] =andM;{ 0x000000,  0x101010,andM;0x202020,  0x303030,andM;0x404040,  0x505050,andM;0x606060,  0x707070,andM;0x808080,  0x909090,andM;0xA0A0A0,  0xB0B0B0,andM;0xC0C0C0,  0xD0D0D0,andM;0xE0E0E0,  0xF0F0F0,andM;0xFFFFFF   } ;andM;then call GpiCreateLogColorTable: Notice that I didn't use the LCOL_PURECOLORflag here.andP;  On video adapters, such as the VGA, that have only a couple ofgrays in the physical color table, you'll want to use dithered colors for thegrays that aren't supported.andM;To restore the logical color table to its default values, you useandM;GpiCreateLogColorTable (hps,andM;LCOL_RESET,andM;LCOLF_CONSECRGB,andM;0L, 0L, NULL) ;andM;The GpiCreateLogColorTable function has the following general syntax:andM;GpicreateLogColorTable (hps,andM;flOption, 1Format, 1Start,andM;1Num, alColors);andM;The flOption parameter can be any combination (or none) of the followingflags:andM;*  The LCOL_PURECOLOR flag indicates that the color table should use onlypure (undithered) colors.andP;  (Dithering is the process of combining pixels ofdifferent colors to yield simulated colors that don't exist in the physicalcolor table.) GPI uses dithering only for filled areas or paths, not for theother graphics primitives (lines, text, markers, or images).andM;*  The LCOL_REALIZABLE flag, which I'll discuss shortly.andM;*  The LCOL_RESET flag indicates that you want to restore the logical colortable to its default values.andP;  In this case, the 1Num parameter can be 0L andthe alColors parameter can be NULL.andM;The 1Format parameter must be one of the following:andM;*  LCOLF_CONSECRGB indicates that the logical color table in the alColorsarray is a series of RGB color values associated with the color indexbeginning with the 1Start parameter and continuing for 1Num indexes.andM;*  LCOLF_INDRGB indicates that the alColors array contains alternating colorindexes and RGB color values.andP;  In this case, the 1Start parameter is ignoredand 1Num must be doubled.andM;*  LCOLF_RGB indicates that you want to create an RGB color table.andP;  In thiscase, the 1Start, 1Num, and alColors are ignored and can be set to 0 or NULL.andM;*  The 1Start parameter is of importance only at times when 1Format isLCOLF_CONSECRGB.andP;  It indicates the starting color index.andP;  And the 1Numparameter is only important when 1Format is LCOLF_CONSECRGB or when it isLCOLF_IMRGB.andP;  It indicates the number of values in the alColors array.andP;  ForLCOLF_INDRGB, 1Num must be an even number.andM;You can create a logical color table piecemeal by using various values of1Start and 1Num.andP;  However, the highest color index you use must not exceedthe value you obtain from the DevQueryCaps function using theCAPS_COLOR_INDEX parameter.andP;  This value will always be high enough to allowyou to create a logical color table that supports all the colors in thephysical color table.andM;THE RGB COLOR TABLEandM;Perhaps the most important--and certainly the most common-use ofGpiCreateLogColorTable is to create an RGB color table.andP;  This lets you useRGB color values directly in the GpiSetColor function.andP;  You do this usingeitherandM;GpiCreateLogColorTable (hps, 0L,andM;LCOLF_RGB, 0L, 0L, NULL);andM;orandM;GpiCreateLogColorTable (hps,andM;0L, 0L, NULL);andM;In the first case, GPI will use dithering to approximate colors not availablein the physical color table.andP;  As I mentioned, GPI uses dithering only forfilling areas and paths.andP;  In the second case, if an RGB color value passed toGpiSetColor is not in the physical color table, it will be approximated withone that is.andM;If you want to use dithering in some cases but not in others, you can createthe logical color table as shown in the first example.andP;  When you want to useundithered colors, you can use GpiQueryNearestColor to get the nearest purecolor that approximates an RGB color value.andP;  Pass this nearest pure color toGpiSetColor.andM;The PMGPI.H header file contains several constants for working with an RGBcolor table:andM;#define RGB_BLACK     0x00000000LandM;#define RGB_BLUE      0x000000FFLandM;#define RGB_GREEN     0x0000FF00LandM;#define RGB_CYAN      0x0000FFFFLandM;#define RGB_RED       0x00FF0000LandM;#define RGB_PINK      0x00FF00FFLandM;#define RGB_YELLOW    0x00FFFF00LandM;#define RGB_WHITE     0x00FFFFFFLandM;After creating an RGB color table, you can use these constants directly inthe GpiSetColor function:andM;GpiSetColor (hps, RGB_RED)andM;Unfortunately, PMGPI.H does not include a general macro for creating an RGBcolor value from its three components, but you can define one easily enough,like so:andM;#define MAKERGB(r,g,b) MAKEULONG \andM;(MAKEUSHORT  ( (b),  (g)), (r))andM;If you want a color that is 25 percent of the maximum red intensity, 50percent of the maximum green intensity, and 75 percent of the maximum blueintensity, you useandM;GpiSetColor (hps, MAKERGBandM;(0x40, 0x80, 0xC0)) ;andM;If you'd like to explore the range of colors available using an RGB colortable, the COLORSCR (color scroll) program in my book Programming the OS12Presentation Manager  (Microsoft Press, 1989) lets you set RGB colors usingscroll bars.andM;THE GPIERASE PROBLEMandM;When you're creating a new logical color table, watch out for the GpiErasefunction.andP;  GpiErase erases the background of a window using the color thatcorresponds to color index 0.andP;  In the default logical color table, colorindex 0 happens to be CLR_BACKGROUND, which is the window background coloryou set using the Control Panel.andP;  By default it is white.andM;In all the examples using GpiCreateLogColorTable I've presented here, thecolor table is defined with the color index of 0 corresponding to black.andO;This seems a natural way to define a logical color table, because 0 isintuitively no color.andP;  However, windows with black backgrounds look ugly in awindowing environment.andP;  White is almost always used instead.andM;Of course, one way to get around this problem is to define the logical colortable so that an index of 0 corresponds to white.andP;  But you can't do this whencreating an RGB color table.andP;  A better alternative is to use WinFillRect orGpiBox rather than GpiErase to erase the window background.andM;PALETTES AND WINDOWSandM;As I discussed in an earlier installment in this series on color, most videoadapters in common use today have some kind of palette control.andP;  For example,although the EGA can display only 16 colors simultaneously, these 16 colorscan be chosen from a palette of 64 colors.andM;VGA and 8514/A video adapters use analog monitors and have more-extensivepalette control.andP;  While these adapters can display only 16 or 256 colorssimultaneously, the colors may be chosen from a palette of 262,144 colors.andO;(That's 2 [.sup.18andrsqb;: The palette registers use 6 bits each for the levels ofred, green, and blue.)andM;The presentation driver is responsible for loading the palette registers onthe video board.andP;  The complete set of 24-bit RGB values corresponding to theloaded palette registers is the physical color table obtained fromGpiQueryRealColors.andM;It would be nice if the OS/2 Presentation Manager let an application changethe physical palette.andP;  For example, a program running on a VGA may want touse eight undithered gray shades for reproducing a bitmap originating from ascanned image.andP;  (Bitmaps can't use dithered colors.) The program can't dothis if it isn't able to change the palette.andP;  Even a program on the 8514/Amay find some inadequacies in the palette.andP;  As I discussed in the last issue,the physical color table for the 8514/A is defined so that only four levelsof blue are available, namely:andM;0x000000andM;0x000055andM;0x0000AAandM;0x0000FFandM;The first one doesn't even count, because it's black, which is not blue atall.andP;  If you need to display more shades of blue, all you can do is rely onthe presentation driver to use dithering.andM;But changing the video board palette is also a problem.andP;  The OS/2Presentation Manager is a graphics windowing environment.andP;  Multiple programsshare the video display.andP;  The settings of the palette registers on the videoboard affect all programs running under PM.andP;  The palette is thus a limitedresource.andM;Suppose that two PM programs are running on a VGA system.andP;  One program wantsto use 16 shades of blue and the other wants 16 shades of gray.andP;  They can'tbe satisfied simultaneously.andM;The developers of PM have come up with two different solutions to this.andP;  Thefirst approach was in OS/2 1.1 and is called the realizable color table.andM;REALIZABLE COLOR TABLESandM;The first shot at allowing the program access to the physical palette isthrough the GpiCreateLogColorTable function.andP;  If you include theLCOL_REALIZABLE flag in the second parameter, then you're indicating you wantthe physical palette to be changed in accordance with the color table you'vedefined.andM;This change does not go into effect immediately after callingGpiCreateLogColorTable.andP;  Another call is required:andM;GpiRealizeColorTable (hps) ;andM;This function causes the presentation driver to load the video board'spalette with values corresponding to the 24-bit RGB color's m the logicalcolor table, thus changing the physical color table.andM;The OS/2 documentation states that GpiRealizeColorTable should be called onlywhen the program's window is maximized to fill the whole screen.andP;  Any PMprogram that was using realizable color tables would trap a message (probablyWM_MINMAXFRAME) indicating when the program was being maximized.andP;  It wouldthen call GpiRealizeColorTable.andP;  When the program's window was being restoredor minimized, the program would callandM;GpiUnrealizeColorTable  (hps)andM;This causes the presentation driver to restore the video board paletteregisters to their default values.andM;You'll recall from the last issue that some GPI color functions (namely,GpiQueryColorlndex, GpiQueryNearestColor, GpiQueryRealColors, andGpiQueryRGBColor) can accept an optional parameter named LCOLOPT_REALIZED.andO;When this parameter is specified, these functions return information as ifthe logical color table were already realized.andM;There are several problems with realizable color tables:andM;The first is that realizable color tables were never really implemented.andO;(You must admit that this is a serious problem if you want to use them!)andO;Before a program attempts to define a realizable color table, it should callDevQueryCaps with the CAPS_COLOR_TABLE_SUPPORT parameter and test the returnvalue with the CAPS_COLTABL_REALIZE flag.andP;  If you do this, you'll find thatno video display presentation driver supports realizable color tables.andM;The second problem is that the OS/2 documentation states that a program canchange the palette only when the program's window has been maximized.andO;However, a program could easily break the rule, and this might cause anotherprogram's window to look funny.andP;  Moreover, there might be cases where twoprograms use realizable color tables but in a compatible manner.andP;  These twoprograms should be allowed to be displayed side-by-side on the same screenand use the colors they want.andM;In addition, there has always been some question about how realizable colortables would affect system colors, such as those used in title bars, scrollbars, and menus.andP;  It's not inconceivable that changing the video boardpalette would render the text on a menu unreadable.andP;  This is becauserealizable color tables are only part of the GPI subsystem.andP;  The windowingsubsystem doesn't know anything about them.andM;Finally, palette control can be used not only for selecting colors, but alsofor animation.andP;  The realizable color table just isn't adequate for this task.andM;Of course, these problems with realizable color tables were quite evident tothe PM developers, and it appears now that realizable color tables are beingphased out of the 32-bit API of OS/2 2.0.andP;  Although the functions are stilldocumented in the second beta release of OS/2 2.0, a little snooping into thePMGPI.H header file reveals that the GpiRealizeColorTable andGpiUnrealizeColorTable functions are not defined for the 32-bit API.andM;THE NEW PALETTE MANAGERandM;Does this mean that we won't have any way to change the physical palette inOS/2 2.0? Not at all.andM;OS/2 2.0 has a new set of functions that allow programs to change thephysical palette.andP;  These correct the deficiencies of realizable color tables.andO;Most importantly, now this palette control is really being implemented.andO;Although it's still a little buggy in the second beta release of OS/2 2.0, itworks well enough to begin experimenting.andP;  I'll discuss OS/2 2.0's newpalette manager in the future.andO;</TEXT></DOC>