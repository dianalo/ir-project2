<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-522-230  </DOCNO><DOCID>07 522 230.andM;</DOCID><JOURNAL>Dr. Dobb's Journal of Software Tools  Sept 1989 v14 n9 p16(7)* Full Text COPYRIGHT Mandamp;T Publishing Inc. 1989.andM;</JOURNAL><TITLE>Autorouting with the A* algorithm. (circuit design; includesrelated article on distance calculations)</TITLE><AUTHOR>Nevin, Randy.andM;</AUTHOR><SUMMARY>Artificial-intelligence algorithms can simplify the tedious,error-prone process of creating the best possible layout for thetraces on a microcomputer circuit board.andP;  Search algorithms for'autorouting' optimization of circuit design are presented.andO;Autorouting is a collection of search problems which deal withfinding routes and laying down traces, and autorouting algorithmsgenerally treat the board as a matrix of cells and use Open queueand Closed set data structures.andP;  A 'breadth-first search'algorithm processes a first-in-first-out queue of open cells untilit finds a target cell or the open queue is empty.andP;  The A* searchalgorithm uses a priority queue which places cells on the shortestestimated path from source to target at the head of the queue andre-checks neighboring cells after each repositioning.andP;  It requiresmore memory than breadth-first search, but is more efficient.andM;</SUMMARY><DESCRIPT>Topic:     AlgorithmsProgram Development TechniquesBoards-CardsCircuit DesignProgrammingArtificial Intelligence.andO;Feature:   illustrationprogramchart.andO;Caption:   Pseudocode for the breadth-first algorithm. (program)Behavior of Lee's algorithm while searching for a path. (chart)Pseudocode for the A* algorithm. (program)andM;</DESCRIPT><TEXT>Autorouting with the A* AlgorithmandM;A few years ago, a friend of mine designed an adapter board for the IBM PC.andO;The tools he used were blue and red strips of tape, a sharp knife, largesheets of clear plastic, and a generous amount of patience.andP;  It took himseveral weeks, and after the first board was tested he discovered that someof the traces were incorrect and had to be cut with the knife and reroutedwith a solder and wires.andP;  This caused me to start thinking about ways to usethe power of the computer to simplify this tedious, error-prone job.andM;The design of a printed circuit board implements an electronic circuit.andO;First you create a schematic.andP;  From this you derive a list of chips and othercomponents that perform the required functions, and a list of the pins thatneed to be connected.andP;  Together, these lists are referred to as the&quot;net-list.&quot;andP;  As long as the connections are made correctly, you usually don'tcare where the traces (the wires embedded in the board) are placed.andM;As you can imagine (or may already know), designing a PC board is a complexsearch problem with a seemingly infinite number of possible solutions.andO;Luckily, there are algorithms from the field of artificial intelligence thatwe can use to design computer programs called &quot;autorouters&quot; that do thissearching for you.andP;  In this article, I'll look at two algorithms: Thebreadth-first and A* (pronounced as &quot;A Star&quot;) search algorithms.andP;  Thisarticle is actually based on an application I wrote to layout, view, andlaser-print circuit board designs.andP;  Because of the length of that application(nearly 2500 lines of C code), I'll focus my discussion here on thepseudocode that implements the two algorithms mentioned and the source codethat implements the A* algorithm.andP;  The entire C source code that implementsthe printed circuit board layout system is available on DDJ's Forum onCompuServe, DDJ's on-line service, and on the disks mentioned at the end ofthis article.andM;What Is Autorouting?andM;Autorouting is one of a class of global optimization problems that aredifficult to solve.andP;  A good circuit board layout, for example, minimizesthings like:andM;* Physical problems (trace lengths, board size, number of routing holes,holes that transfer a trace from one side of the board to the other, alsocalled vias)andM;* Signal crosstalkandM;* Number of layersandM;At the same time, the layout maximizes things like signal strength,reliability, and ease of debugging.andP;  The overall value of a board design is afunction of all of these often conflicting variables.andP;  It is usuallyacceptable to find a solution that satisfies a set of constraints, becausefinding the globally optimal solution is infeasible for all but the mosttrivial problems.andM;Autorouting can also be viewed as a collection of search problems.andP;  Theindividual problems deal with finding a route and laying down a trace betweentwo locations.andP;  There are many algorithms for solving search problems, eachwith different running time characteristics and data space requirements.andM;Autorouting search algorithms typically operate in two phases, treating theboard as a matrix of cells.andP;  The first phase starts at the source cell andsearches for the target cell, usually by going in several directions at thesame time.andP;  The algorithm builds an auxiliary data structure to keep track ofhow each cell was reached (this is referred to as &quot;Pred&quot; in the algorithms inFigures 1 and 2).andP;  The first phase ends when the target cell has been found,and the second phase begins.andP;  If the first phase exhausts all possibilitieswithout reaching the target cell, then no route exists between them, andthere is no reason to do the second phase.andM;The second phase uses the auxiliary data structure to trace the route fromthe target cell back to the source cell, actually laying down the electricalconnections.andP;  The second phase is identical for the breadth-first and A*search algorithms.andP;  But the first phase is different, and it is this phasethat gives these algorithms different behaviors.andM;The main data structures used in the first phase are the Open queue and theClosed set, which hold cell coordinates.andP;  Because a cell's coordinatesuniquely identify it, we'll say that the Open queue and Closed set containcells.andP;  Cell coordinates will be represented as r2c3s1 for the cell at row 2,column 3, side 1, or as r2c3 when it is understood that all cells are on thesame side of the board.andP;  To remind ourselves that Open is a queue and Closedis a set, when we talk about adding cells to them, we will put the cells &quot;on&quot;the queue and &quot;in&quot; the set.andP;  Initially, the Open queue contains the sourcecell and the Closed set is empty.andM;The first phase is a loop, which removes an element from the head of the Openqueue, puts it in the Closed set (which indicates that it has been searched),and checks to see if it is the target cell.andP;  If so, the first phase is done.andO;Otherwise, the neighbors of the cell (those adjacent to it) are placed on theOpen queue, and the loop continues.andP;  As we'll see later, the essentialdifference in the breadth-first and A* search algorithms is the order inwhich the neighbors are placed on the Open queue.andM;Breadth-First SearchandM;Figure 1 contains pseudocode for the breadth-first search algorithm.andP;  Thisalgorithm works by processing a first in/first out (FIFO) queue of opencells; that is, cells that have been reached, but not yet searched.andO;Initially, the open queue contains only the source cell.andP;  A cell is removedfrom the head of the open queue, placed in the set of closed cells (cellsthat have been searched), and checked to see if it is the target cell.andP;  Ifnot, its neighbors are placed at the tail of the open queue.andP;  Neighboringcells that have already been reached are ignored.andP;  (If a cell's coordinatesare on the open queue or in the closed set, then it has been reached,otherwise, it has not.)andP;  This continues until one of two things happens:andM;* The target cell has been foundandM;* The open queue is empty, in which case the target cannot be reached fromthe source cellandM;A version of breadth-first search known as Lee's algorithm has served as thebasis for some autorouters since the early 1960s.andP;  The original algorithmdoes not consider diagonally adjacent cells as neighbors, and consequently,the backtracking phase can create only horizontal and vertical traces.andP;  We'llenhance the algorithm so that diagonally adjacent cells are neighbors, thusenabling it to produce diagonal traces.andP;  Unfortunately, Lee's algorithmsuffers from a behavior inherent in the breadth-first search technique, whichlimits its application to problems of relatively small size.andP;  As the distancebetween the source and target cells increases by a factor of N, the number ofcells processed by Lee's algorithm -- and therefore processing time --increases by the square of N.andM;Figure 2 shows the behavior of Lee's algorithm while searching for a pathbetween the source cell S (r5c5) and the target cell T (r8c8).andP;  Lee'salgorithm does not specify the order in which neighboring cells are placed onthe open queue, but we'll use the compass directions north, east, south, andwest, followed by northeast, southeast, southwest, and northwest.andP;  This ordertends to produce traces with a minimal number of turns.andM;In Figure 2a, the source cell (r5c5) has been searched, and its eightneighbors have been placed on the open queue.andP;  The arrows indicate thedirection from which each cell was reached, and correspond to the Pred datastructure.andP;  After the first eight cells on the open queue have been reachedand moved to the closed set, the algorithm searches the configuration inFigure 2b, where there are sixteen cells on the open queue.andP;  Once thesesixteen cells have been searched, the configuration in Figure 2c is reached.andO;Now the target cell (r8c8) is fourth from the end on the open queue, and asolution is imminent.andP;  Searching r8c8, the algorithm recognizes it as thetarget cell, and uses the Pred data structure to construct a trace back tothe source cell.andM;You can see that the search progresses outward from the source cell in alldirections, like ripples when you throw a pebble into the water.andP;  If wedouble the size of the problem so that S and T are six cells apar, the numberof cells searched and therefore the processing time will be about four timesas great.andP;  If we triple the size of the problem, the number of cells searchedwill be roughly nine times more.andP;  Thus, the behavior of Lee's algorithm isquadratic in the size of the problem, which makes it infeasible for largeproblems.andM;A* SearchandM;Figure 3 gives pseudocode for the A* search algorithm, while Listing One,page 82, shows it implemented in C.andP;  This method also works by processing aqueue of open cells, which initially contains only the source cell.andP;  But thisis a priority queue, which means cells are inserted according to theestimated distance to the target.sup.3., not just at the end.andP;  Cells that areon the shortest estimated path from source to target go to the head of thequeue.andP;  The A* algorithm removes the cell from the head of the open queue andchecks to see if it's the target.andP;  If not, the neighboring cells are put onthe open queue at the proper position.andP;  The algorithm checks neighboringcells that have already been searched to see if the new path between them andthe source is shorter than the previous one.andP;  If it is, they are repositionedon the open queue according to the new estimated path length from source totarget.andP;  As in breadth-first search, this continues until the target cell hasbeen found or the open queue is empty.andM;A* depends on being able to estimate the distance between a cell and thetarget cell.andP;  In the case of autorouting, a simple measure of this distanceis available, and this helps A* to concentrate the search in the directionmost likely to succeed.andP;  The more accurate the estimate, the faster thesearch.andM;In practice, A* does not suffer from the quadratic behavior of Lee'salgorithm, it solves similar problems faster and can be applied to largerproblems where Lee's algorithm performs poorly.andP;  As the distance between thesource and target cells increases, the number of cells processed by A*increases, but not as dramatically as with Lee's algorithm.andM;Figure 4 shows the behavior of the A* search algorithm.andP;  A* does not specifywhether new cells go in front of or behind cells already on the open queuethat evaluate to identical estimated path lengths.andP;  We use the conventionthat they are placed in front.andP;  This minimizes the time to insert a cell onthe open queue.andM;In Figure 4a, the source cell (r3c3) has been searched, and its eightneighbors are on the open queue.andP;  Each cell on the open queue also includesthe estimated length of the shortest path from S to T that goes through thatcell.andP;  After the first cell (r4c4) has been searched and moved to the closedset, the configuration in Figure 4b is reached, where there are 12 cells onthe open queue.andP;  After searching the next cell (r5c5), the algorithm reachesthe configuration in Figure 4c.andP;  Now the target cell (r6c6) is at the head ofthe open queue, and a solutio will be found on the next iteration of theloop.andP;  Searching r6c6, A* recognizes it as the target and uses the Pred datastructure to construct a trace back to the source cell.andM;You can see that the search progresses more directly toward the target cell.andO;The target draws the search much as the earth's gravity pulls objects towardthe center of mass.andP;  If we double the size of the problem, the search willprocess about twice as many cells, and if we triple its size, the search willrun through three times as many.andP;  This linear behavior makes A* moreattractive for autorouting than the quadratic Lee's algorithm.andP;  With theincorporation of the heuristic -- the rule, that guides the search in thedirection most likely to succeed--it is difficult to estimate worst casebehavior.andP;  However, A* will never take more time than Lee's algorithm, and itwill never search any cells that Lee's algorithm could avoid.andM;Optimizations and GeneralizationsandM;The algorithms in Figures 1 and 3 solve the general search problem.andP;  Whenthese algorithms are implemented and customized to a particular application,there are ways to speed them up.andM;The A* algorithm in Figure 3 recomputes the heuristic H(y) when it discoversa better way to reach a cell.andP;  Depending on how difficult this heuristic isto compute, you can probably save some work at the expense of complicatingthe algorithm.andP;  When lines 20 and 21 of Figure 3 are executed, the previousvalues of G[y] and F[y] are destroyed.andP;  But F[y] = G[y] + H(y), so you couldsave F[y] - G[y](which is H(y)) in a temporary variable, and use thatvariable instead of recomputing H(y) on line 21.andP;  Also, the commonsub-expression G[y] + Distance(x,y) should be placed in a temporary variable,instead of being computed twice (lines 18 and 20).andM;Often, rather than searching for a path between two individual cells, what isreally desired is a path between one of a set of source cells and one of aset of target cells (as when connecting power and ground pins).andP;  Bothalgorithms can be modified by adding the entire set of source cells to theinitial open queue, and checking for a member of the set of target cells oneach iteration.andP;  When this is done, the heuristic used by the A* algorithmbecomes more complicated.andP;  It must estimate the minimum distance from thecurrent cell to any of the target cells.andM;For breadth-first search, once the target cell is placed on the open queue,it is pointless to add any more cells to the open queue because when thishappens, the problem is solved.andP;  An appropriate shortcut would be to insert acheck before line 13 in Figure 1 to see if y is the target cell.andP;  If it  is,use Pred[y] to construct the trace back to the source cell, and return.andM;Memory RequirementsandM;Both search algorithms use quite a bit of memory to solve problems ofnon-trivial size.andP;  The breadth-first search algorithm needs memory torepresent the board, the predecessor structure, and the closed set.andP;  The A*search algorithm needs these also, plus structures for F[x] and G[x] (seeFigure 3).andP;  In addition, both algorithms dynamically allocate memory for theopen cell queue.andM;The board is represented as a pair of two-dimensional array--one for thefront side, the other for the back--in which the dimensions are the number ofrows and columns of cells.andP;  Not counting holes and traces relating to holes(Figure 5, groups A, B, and C), there are 30 possible cell contents, whichcan be presented with 5 bits per cell.andM;The hole-related cells are more difficult to enumerate; they can be combinedin many ways.andP;  If we simply assign 1 bit to each of the eight traces ingroups B and C, and add one more bit to indicate a hole, 14 bits will besufficient to represent any cell.andP;  On a board of N rows and M columns, we'llneed N*M*28 bits total.andM;The predecessor structure is also a pair of two-dimensional arrays, where anentry must be able to represent one of the eight compass directions or anindication for the opposite side of the board.andP;  This takes 4 bits per cell,or N*M*8 bits total.andM;The closed set can be represented by a pair of two-dimenstional, single-bitarrays, where a bit is one if the corresponding cell has been searched, andzero otherwise.andP;  This will take N*M*2 bits total.andM;F[y] and G[x] will be similar to the board array, but they must contain a16-bit integer for each cell, requiring N*M*64 bits total.andP;  Note that ifmemory usage needs to be minimized at the cost of increased processing time,we could omit the F[x] arrays, and calculate the F values as they are neededfrom the G[x] arrays and the heuristic function, H(x).andM;Breath-first search thus requires N*M*38 bits, and A* needs N*M*102 bits ofstatic memory.andP;  For a printed circuit board 4 x 13 inches (80 cells x 260cells), breadth-first search will need 98,800 bytes and A* will need 265,200bytes.andP;  Different algorithms that solve the same problem often trade offmemory against processing time to achieve better performance.andP;  This is thecase with A* versus the breadth-first search.andM;Locality of ReferenceandM;Despite the fact that A* requires more memory than breadth-first search, A*exhibits better memory usage patterns.andP;  This is because it shows betterlocality of reference than breadth-first search.andP;  Locality of reference dealswith the sequence in which memory locations are used, and consists of tworules of thumb: 1.andP;  The memory location currently being referenced is likelyto be referenced again the near future, and 2.andP;  Memory locations near the onecurrently being referenced are likely to be referenced in the near future.andM;When the first rule holds true for a given program, that program can probablybenefit from a memory cache.andP;  When the second rule holds true, the programcan probably benefit from a virtual memory environment with aleast-recently-used page preemption policy.andP;  Most computer systems withvirtual memory and caches apply them to both code and data, so programs thatexhibit good locality of reference should benefit from both rules.andM;This becomes a factor when solving large problems (say, routing a printedcircuit board that is 10 inches in both dimensions).andP;  In a virtual memoryenvironment, improved locality of reference can minimize swapping.andP;  In anenvironment with cache memory, improved locality of reference can increasethe cache hit rate.andP;  Both of these tend to decrease the total running time.andM;The memory references in the breadth-first search algorithm go around andaround in circles of constantly increasing size, and do not reflect a commonlocality of reference.andP;  Thus, the breadth-first search algorithm is not ableto take good advantage of virtual memory or a memory cache.andP;  The memoryreferences of A* tend to be from the same area of the printed circuit boardfor extended periods of time, taking better advantage of these mechanisms.andO;In a large problem, this helps to offset the extra memory that A* requires byadding speed beyond that provided by the basic algorithm.andP;  Improved localityof reference by itself may not be a sufficient reason to select A* overbreadth-first search, but it is icing on the cake.andO;</TEXT></DOC>