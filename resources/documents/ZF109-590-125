<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF109-590-125  </DOCNO><DOCID>09 590 125.andM;</DOCID><JOURNAL>EXE  Sept 1990 v5 n4 p64(3)* Full Text COPYRIGHT Process Communications Ltd. (England) 1990.andM;</JOURNAL><TITLE>Programming language/micro. (The Third Side ) (tutorial)</TITLE><AUTHOR>Jones, Ray.andM;</AUTHOR><SUMMARY>PL/M is a high-level, block-structured language created for usewith Intel processors.andP;  PL/M lacks console I/O because it isintended for use in embedded systems, so it is not suited for usein most applications programming, but it can be used in place ofassembly language in complex programs.andP;  PL/M procedures can takeparameters and can be typed or untyped.andP;  Arguments are passed byvalue, so pointers are used to alter parameters within procedures.andO;PL/M allows only byte, word, double word, integer, real,structure, selector and pointer data types.andP;  The PL/M pointers arespecific to Intel microprocessors and are 32 bits long and aredivided into 16-bit selectors and 16-bit offsets.andP;  The selectordata type usually holds a segment address.andP;  The BUILD$PTR functioncreates a pointer by combining a selector and a word data type.andO;PL/M also includes functions to process byte arrays.andM;</SUMMARY><DESCRIPT>Topic:     PL-MTutorialProgramming LanguagesMicroprocessorsStructured Programming.andO;Feature:   illustrationprogram.andO;Caption:   PL/M's solution to the triangle problem. (program)andM;</DESCRIPT><TEXT>Programming Language/Micro Almost inevitably, the first high-level languagethat most people come across is BASIC.andP;  This is unfortunate, since thatparticular language does not contain the elements of structured programmingthat the programmer will need to come to grips with when he enters the realworld of C or Pascal.andP;  I was lucky: the language that I first encountered wasPL/M.andM;I must admit that the encounter was a rather brief one - I didn't get muchfarther than the manual - and I was to very soon afterwards start programmingin BASIC.andP;  Nevertheless, that exposure to a block structured language at thebeginning of my programming career ws a valuable one, giving me a flavour ofgood programming discipline and design.andP;  This happened way back in 1979, inthe days of 8-bit processors.andP;  More recently, I have used PL/M in anger onmore modern 16-bit machines.andM;Unless you too live in the world of embedded systems, you may not have comeacross PL/M.andP;  It combines much of the high-level functionality of C with someof the more processor-specific attributes of assembler.andP;  It was originallyinvented by Intel as a high-level language alternative to assembler for their8080 microprocessor.andP;  Since then, it has grown a few suffixes and is nowavailable for a number of Intel processors; the version that I use isPL/M-86, for the iAPX86 range of processors (in my case the 80188).andM;PL/M is clearly a derivative of Algol, and as such is not very remarkable.andO;Its claim to fame is that it has been designed specifically for Intelprocessors and consequently has some additional features that therun-of-the-mill language does not.andP;  I will highlight these features in mydescription of the language.andM;StructureandM;As I mentioned before, PL/M is a block structured language, blocks beingdelimited by the keywords DO and END - these have the same function as BEGINand END in Pascal, or the braces in C.andP;  As one might expect all the usualconstructs are supported - the WHILE loop, the iterative loop, the CASEstatement and IF ...andP;  THEN ...andP;  ELSE.andM;The form of each of the statements is shown in Figure 1.andP;  there is nothingvery strange about these, except that the DO CASE statement is rather crudecompared with the equivalent in C or Pascal.andP;  The selection expression mustyield a positive integer result, and this is used as an index into the listof statements within the CASE statement.andP;  So if the result is zero, then thefirst statement is executed, if one, then the second and so on.andP;  Only onestatement is executed, after which control passes to the end of the block.andM;Procedures in PL/M may be typed or untyped, and can take parameters.andP;  As inC, all arguments are passed by value, so if you need to alter the value of aparameter within a procedure, you have to pass a pointer.andM;Both procedures and data may be given attributes that determine the way thecompiler treats them.andP;  The PUBLIC and EXTERNAL attributes are PL/M's way ofallowing modular programming; a PUBLIC procedure is available to othermodules, whereas an EXTERNAL declaration is a reference to a proceduredefined elsewhere.andM;Local variables are static by default (that is they are allocated permanentspace in the processor's data segment).andP;  By use of the REENTRANT attribute,they may be made dynamic and allocated space on the stack when the procedureis invoked.andM;The final attribute is INTERRUPT.andP;  This is a procedure attribute which causesthe compiler to generate the correct code for an interrupt routine.andP;  Thecompiler produces a prologue that saves all the registers, sorts out thestack and sets up the segment registers, and an epilogue that restores thingsto their original state.andP;  It will even load the address of the interruptprocedure into an interrupt vector supplied by the programmer.andP;  An example ofa procedure declaration is shown in Figure 2.andM;Data TypesandM;PL/M supports a limited set of data types compared with most high-levellanguages.andP;  However, they are usually quite adequate for the sort ofmicroprocessor applications that PL/M is generally used for.andM;The supported data types reflect the underlying hardware's architecture.andP;  InPL/M-86, the supported data types are byte, word, double word, pointer,selector and (as a sop to the real world) integer, real and structure.andP;  Asyou can see, most of these are very obviously microprocessor-oriented.andM;Byte, word and double word are straight-forward, as all are effectivelyunsigned integers of increasing size.andP;  Reals and structures are very similarto any other language.andP;  Pointers, however, are a slightly different kettle offish - although this will be of no great surprise to 80x86 aficionados.andM;The Triangle ProblemandM;More of that later, however, because now we have discussed enough of thelanguage to solve the Triangle Problem.andP;  There is one slight problem - PL/Mhas no console I/O.andP;  This is not like the I/O that C doesn't have (C cheatsby always providing library routines), this is real nonexistent I/O.andP;  Thereason for this apparent glaring omission is that PL/M assumes nothing aboutthe hardware architecture of the target system except the processor type.andO;This is not unreasonable, considering that PL/M is aimed more at embeddedsystems than applications programming, and these type of systems are quitelikely not to have any conventional console I/O (typical embedded systemsmight be a car engine management system, an Ethernet card, or a satellitenavigation system).andM;But I have not let a minor inconvenience like no I/O deter me; I haveinvented some.andP;  It takes the form of EXTERNAL function declarations forreading and writing strings and integers (unfortunately a general purposefunction such as C's print () cannot be programmed, as PL/M does not supportthe variable number of parameters required).andP;  Functions like these couldeasily be provided by a tame assembler programmer who is familiar with thetarget system architecture.andM;The solution to the Triangle Problem is shown in Figure 3.andP;  You've probablyseen more elegant solutions.andP;  However, it is a fairly conventional program,easily understood if you know one of the major block structured languages.andO;The inelegance is due to the treatment of the strings.andP;  Not surprisingly fora language with no conventional I/O, PL/M does not handle strings well - bothof these are for communicating with people, and that is not what PL/M isabout.andP;  It is for these reasons that PL/M is not really a 'TriangleProblem-oriented' programming language.andP;  Enough of triangles - let's have alook at the more low-level features of PL/M.andM;Pointers AgainandM;Pointers are one of the data types that are attuned to the underlyinghardware.andP;  Not only are they microprocessor specific, they're Intelmicroprocessor specific.andP;  Those familiar with the segmented architecture of80x86 micros will understand the use of the two halves of the pointervariable.andP;  I'm afraid that those who don't will have to find themselves agood book, because it is beyond the scope of this article to explain it here.andM;Pointers are 32-bit entities and are divided into two parts, a 16-bitselector (the most significant part) and a 16-bit offset.andP;  They are usuallyused to store the address of an entity and may not be manipulated in the sameway as other variables, ie no arithmetic operations may be performed.andM;There is Also a SELECTOR variable type.andP;  This is used in the construction ofpointers, and is normally used to hold a segment address.andP;  The selector of aparticular entity may be found with the built-in function SELECTOR$OF.andO;Similarly, the offset of a variable may be found using OFFSET$OF and thisvalue would normally be placed in a WORD variable (where it can be treated asan unsigned integer).andM;Pointers may be created with a special built-in function, BUILD$PTR.andP;  Thistakes two arguments, of types SELECTOR and WORD, and returns a properlyconstructed pointer.andP;  Thus by using built-in functions, pointers may becreated and manipulated.andM;One use for pointers is as the base address of a based variable.andP;  This is avariable which is declared as being located at an address contained inanother variable, the real address of the variable being calculated at runtime.andP;  These can be useful for mapping a variable onto a particular piece ofhardware of memory, or dynamically shifting the variable around at run-time -now where did I leave that structure?andM;Byte ArraysandM;There is a group of built-in functions for manipulating arrays of bytes.andO;These need not be formally declared byte arrays but any contiguous chunk ofmemory, since they are referred to via pointers.andP;  The arrays may be moved,searched and translated.andP;  This last function builds an array by translatingeach byte from another array using a translation table (a third array) - itseems to me that this ought to be a really useful function, but I can't forthe life of me think why.andM;Typical of low-level operations are shifts and rotates.andP;  PL/M has, of course,a full complement of functions to deal with these.andP;  Additionally, the HIGHand LOW functions can be used to chop double words into words and words intobytes without recourse to shifting or rotating.andP;  Other hardware specificfunctions, such as INPUT and OUTPUT, allow the programmer to read theprocessor's I/O ports directly.andM;Since the processor status flags can be affected by these low-leveloperations, PL/M allows the testing and alteration of these flags.andP;  Thefunctions CARRY, SIGN, ZERO and PARITY return the state of those flags.andP;  TheFLAGS variable contains the whole of the status flag register and may be bothread and written to.andM;ConclusionandM;So, you might ask, what is PL/M good for?andP;  Generally, any application thatsuits assembler because of the low-level or processor-specific programmingrequired, but is too big or too complex for comfort.andP;  Perhaps PL/M isn't asflexible as most high-level languages, but its limitatios often reflect thoseof the hardware beneath it.andM;Ray Jones is a Principal Software Engineer who has spent many years (somewould say too many) developing technical and real time software.andO;</TEXT></DOC>