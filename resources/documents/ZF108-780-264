<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-780-264  </DOCNO><DOCID>08 780 264.andM;</DOCID><JOURNAL>Dr. Dobb's Journal  Sept 1990 v15 n9 p70(13)* Full Text COPYRIGHT Mandamp;T Publishing 1990.andM;</JOURNAL><TITLE>Kermit for OS/2 part 1. (technical)</TITLE><AUTHOR>Anderson, Brian R.andM;</AUTHOR><SUMMARY>Moving to OS/2 from DOS is worth the increased overhead and memoryand learning curve.andP;  OS/2 permits multitasking, which is a bigadvantage, and eliminates the need to reboot because of systemcrashes.andP;  A reasonably extensive set of tools is needed to developprograms for OS/2.andP;  Also needed are a compiler or assembler thatsupports OS/2 and Presentation Manager and a resource set: iconeditor, dialog editor, font editor, and resource compiler.andO;Instructions for porting PCKermit to the OS/2 Presentation Managerare given.andM;</SUMMARY><DESCRIPT>Topic:     Software MigrationOS-2ProgrammingTutorial.andM;</DESCRIPT><TEXT>I am one of the many DOS curmudgeons who eschewed OS/2 since its introductionthree years ago.andP;  Too expensive, said I. Too slow.andP;  Requires too much memory.andO;Why does one user need multiple tasks? Why is protected memory necessary on asingle-user system? In retrospect, this seems to be a case of sour grapes: Icould not afford to upgrade my personal computer to allow me to run OS/2.andM;I recently purchased a new machine with a 33-mHz 80386, a VGA monitor, and afast 150-Mbyte hard drive.andP;  Everything looks very different from this newperspeCtive.andP;  Sure, OS/2 has much more overhead than DOS, but at 33 MHz, youdon't really notice.andP;  Sure, 4 Mbytes is a lot of memory, but the price of RAMhas declined significantly.andP;  Multitasking really does make sense - neverhaving to wait for the machine to finish one task before I can start anotherincreases productivity.andP;  And, finally, while developing new software,protection from your own errant programs is a real advantage - it virtuallyeliminates having to reboot because of system crashes.andP;  So with thatconfession and recantation out of the way, let's talk project:andM;Kermit is a file-transfer protocol that allows diverse computers tocommunicate.andP;  In May 1989, my article  Kermit Meets Modula-2&quot; (also here inDDJ) described the PCKermit protocol and my implementation in Modula-2.andP;  Thisarticle describes how I ported PCKermit over to the OS/2 Presentation Manager(PM).andM;OS/2 Mini-PrimerandM;OS/2 and PM are very large systems.andP;  The OS/2 kernel has over 250 functions;PM has over 500.andP;  This collection of functions is referred to as theApplication Program Interface, or API.andP;  The Kernel API provides all of thetraditional operating system services, including memory management, processcontrol, and input/output.andP;  Using only the Kernel API, a programmer can writesophisticated character-based programs without ever having to resort todirect access to the hardware (as was often required under DOS).andM;The Kernel API is divided into four sections: Dos, Kbd, Mou, and Vio.andP;  TheKbd, Mou, and Vio provide fast, flexible access to the keyboard, mouse, andvideo systems, respectively, and are used mainly in traditionalcharacter-based applications.andP;  Presentation Manager takes control of thekeyboard and mouse, so the Kbd and Mou group of functions is not used in a PMapplication.andP;  PM has many options available for controlling the screen;graphics support (both vector and raster) is available, as is support forvarious proportional and non-proportional fonts.andP;  The Vio group of functions,in a slightly altered form called &quot;Advanced Vio&quot; (AVio) is also available toa PM application.andP;  (My implementation of Kermit uses AVio functions toemulate a standard video display terminal (VDT) and thereby allowsinteraction with mainframe computers.) The DOS portion of the OS/2 kernelprovides for disk I/O, task management, and memory management for bothcharacter-based and PM applications.andM;The Presentation Manager API is also divided into sections: Dev, Gpi, andWin.andP;  The functions in the Dev group are used to access PM device drivers,which allows for device-independent graphics.andP;  The Gpi group provides thedrawing routines (lines, curves, bitmaps, fonts, and so on) for PM.andP;  The Winfunctions manage the PM windows including menus, scroll bars, and dialogboxes.andP;  Each Win function is quite &quot;low level,&quot; which often makes forconvoluted code (several functions, each with many parameters, must be calledto accomplish some small task).andM;Besides the function libraries just described, PM makes use of resource filesto store application-specific information about menus, dialog boxes, and soon.andP;  A resource file is a text file of source code that describes, forexample, the form of a pull-down menu.andP;  The resources are compiled (with aresource compiler), and eventually linked to the application.andP;  The sourcecode for many types of resources can be either developed manually orgenerated automatically using a dialog editor, for example.andM;On the WorkbenchandM;To develop programs for OS/2 and PM you will need a fairly extensive (andexpensive) set of tools.andP;  Probably the most important &quot;tool&quot; is thedocumentation.andP;  The Microsoft OS12 Programmers's Reference (volumes 1-3) isessential.andP;  There is also a fourth volume which covers OS/2 v1.2; that volumehas remained on my shelf because I am running OS/2 v1.1.andP;  Because theMicrosoft manuals are a bit light on examples, you will also want to getCharles Petzold's Programming the OS/2 Presentation Manager (Microsoft Press,1989), and either Ray Duncan's Advanced OS/2 Programming (Microsoft Press,1989) or Peter Norton and Robert LaFore's Inside OS12 (Brady Books, 1988) onthe kernel.andP;  Gordon Letwin's Inside OS/2 (Microsoft Press, 1988) is also agood overall OS/2 primer.andP;  For setting up and running (not programming) OS/2,you might consider Using OS12 by Halliday, Minasi, and Gobel (Que Books,1989).andM;Of course, you will need a compiler or assembler that supports OS/2 and PM.andO;Many of the Microsoft products obviously qualify.andP;  And other compilers arestarting to support OS/2 and PM.andP;  Whatever language you choose to use, youwill need at least the ability to read C code - all of the Microsoftdocumentation is written in C.andM;For this project, I used Stony Brook Modula-2, in part because my originalimplementation of Kermit was written in Modula-2  albeit using the Logitechcompiler), and in part because I prefer Modula-2 to C. The Stony Brookcompiler proved an excellent choice; although much of the system was still inbeta test, I found only one problem (which I was able to correct easilybecause I had the source code for the offending module).andM;Finally, you will need the resource set: Icon editor, dialog editor, fonteditor, resource compiler, and a few other miscellaneous tools.andP;  All of thesetools are available from Microsoft as the OS/2 Softset.andP;  Alternately, you canpurchase the OS/2 PM Software Development Kit which includes the Microsoftdocumentation, Petzold's book, and the tools (but no compiler).andP;  Whilepurchasing the books and tools separately seems to be more economical, theSDK includes example code and useful programs (for example, PMCAP -- a screencapture utility) that are not included with the Softset.andP;  Format of a PMProgram Most GUIs (that is, GEM, Windows, Macintosh, and OS/2-PM) have a verysimilar structure:andM;1.andP;  The main program sits in a loop fetching messages from the operatingsystem and dispatching those messages to a window procedure.andM;2.andP;  The window procedure intercepts the messages (usually with a very longCASE statement) and processes the messages, often by calling other functions.andM;3.andP;  Any other part of the program that wants to get anything done mustcommunicate with the window procedure by posting messages (which the mainfetches and dispatches: see steps 1 and 2).andM;Virtually everything is done with messages.andP;  For example, a PM program nevercalls a function such as getchar() or Read() to get a character from thekeyboard.andP;  Instead, a program must continually look for a WM_CHAR message,and then translate the parameters that come along with the message to findout what key has been struck.andM;One tremendous advantage with OS/2 (compared to the other GUIs) is thatpreemptive multitasking allows independent threads to execute in thebackground and post messages to the main window (to let the user know what isgoing on).andP;  PCKermit makes use of multiple threads for terminal emulation(connecting to the host), as well as for sending and receiving files.andM;Down to BusinessandM;The main program module, PCKERMIT.MOD (see Listing One, page 109), begins online 1.andP;  (Note that the listings are sequentially numbered for easyreference.) PCKermit initializes the window system and message queue,registers two window classes (for the main window and a child window - thechild window is used during file transfer), creates and resizes the mainwindow, and then sits in the message loop waiting for termination.andM;PCKermit is fairly traditional (for PM), except that after creating the mainwindow, PCKermit immediately determines the size and position of the desktop(see line 99), records this in the global variable Pos, and then expands thewindow to nearly full size (line 100-102).andP;  The variable Pos is used again inthe Shell module to ensure that the window is always correctly sized andpositioned.andP;  The window is either sized to three device units smaller thanthe desktop (during file transfer), or is maximized (during terminalemulation).andP;  When the window is maximized or restored from maximum (bycalling the WinSetWindowPos function again), an extra term must be includedin the final parameter: Either SWT_RESTOPE (line 543-544) or SWT MAXIMIZE(line 552-554).andP;  A similar strategy is used to keep the child window properlysized (the child window is used for displaying status messages during filetransfer).andM;SHELL.DEF and SHELL.MOD represent the most important module, as it is whereall messages are processed (mostly in WindowProc, DoMenu, andChildWindowProc).andP;  Several global variables and constants are defined here(that is, Class and ClientWindow).andP;  Besides the two window procedures, thereare a number of ancillary procedures for controlling the windows: SetFull,SetRestore, and SetMaximize control the size of the window (PCKermit&quot;insists&quot; on a full window to properly emulate the TV1950 video screen);Enable and Disable  gray out&quot; any menu item that is not currently accessible;Check and Uncheck indicate the currently selected video color scheme; DoMenuis called from WindowProc to process WM_COMMAND messages (these are mainlycommands that result from the user interacting with menus); several dialogprocedures (for example, BaudDlgProc) allow the user to make choices viapop-up dialog boxes (each dialog box is a window, and therefore needs its ownwindow procedure); Key Translate processes keyboard messages and translatesthem into standard codes (for use by the Term module).andM;The window procedure, WindowProc (line 1088), is called only by PM.andP;  Itspurpose is to process messages (including standard system messages such asWM_CREATE, WM_INITMENU, WM_COMMAND, and WM_PAINT, as well as PCKermitmessages such as WM_SETFUL, WM_SETRESTORE, and WM_TERM).andP;  Besides the messageitself (which is really just an integer), the window procedure is passed twomessage parameters (mp1 andamp; mp2).andP;  The form of these two parameters dependsupon the particular message.andP;  For example, in the case of the WM_TERMmessage, the message parameters are used to pass only a single character.andP;  Inthe case of the WM_CHAR message, the parameters contain a wide range ofkeyboard information (ASCII code, scan code, Control/Alt/Shift condition,time of keypress, and several flags).andP;  In some cases, the message parametersare not used at all.andM;One of the messages processed by WindowProc, WM_COMMAND, is passed on toDoMenu (line 743).andP;  This procedure processes all messages that result fromthe user clicking on a menu or using one of the accelerator keys.andP;  This userinteraction often results in other child windows, called &quot;dialog boxes,&quot;being created.andP;  When the dialog box is on the screen, another windowprocedure takes over.andP;  For example, if the user clicks on the Options menu,and then chooses baud rate .... a dialog box (with radio buttons and an OKpush button) appears on the screen.andP;  While this dialog box is on the screen,the BaudDlgProc (line 863), takes over control of the window (until the userclicks on OK, or presses the Return or Esc key).andP;  Each of the dialog boxes ormessages boxes (PCKermit has nine) has its own window procedure.andM;The child window procedure, ChildWindowProc (line 1203), is also called onlyby PM (as are all window procedures), and processes a variety of system andPCKermit messages.andP;  The WM_PAD and PM_DL messages are from the PAD (PacketAssembler Disassembler) and DataLink Modules, respectively, and are usedmainly to allow these modules (which are running as independent threads) tokeep the user informed: The message parameters indicate what message shouldbe displayed on the screen.andM;When the user selects Send or Receive (either through the menus or viaaccelerator keys), a fairly complex chain of events is brought into play.andP;  InDoMenu at lines 776 or 780 the IDM_SEND or IDM_REC messages are recognized.andO;In the case of IDM_SEND, a dialog box is invoked.andP;  The dialog box procedureSendFNDlgProc on line 983 allows the user to enter a filename; PM returns apointer to the filename that the user enters.andM;in the case of either IDM_SEND or IDM_REC, the MakeChild procedure (line 630)is called next.andP;  This procedure first forces the main window to full size,then disables several menu items (because we don't want the user to try tochange the baud rate halfway through a file transfer, line 639), next createsa standard window (line 649), sizes and positions the window (line 661), putsan appropriate message in the window  line 666), and finally makes the newchild window the active window (line 668).andM;After the window is ready, we must set it up so that we can send messages.andO;PCKermit uses the AVio for this, and lines 671-673 set up the hvps (Handle toVio Presentation Space).andP;  Back in DoMenu, on lines 779 or 782, a new threadis created.andP;  OS/2 will then schedule that thread (which will either send orreceive a file) on the next available time slice.andP;  The thread will terminateitself when file transfer is complete (or if five consecutive errors occur).andO;Before the thread actually terminates itself (by calling DosExit), it sendsmessages to its window procedure to remove the window and restore the menus.andM;When the user selects Connect mode (either through menus or via keyboardaccelerator), the IDM_CONNECT message is recognized (line 762).andP;  As in thecase of Send and Receive, various menu items are disabled, and a presentationspace is set up.andP;  Unlike Send and Receive, a new thread is not started, butan existing thread is resumed (line 774); the thread was set up duringinitialization (line 1145) and then immediately suspended (next line).andM;Next TimeandM;If you've examined the listings up to this point, you'll notice that Ihaven't mentioned Listings Three through Eight.andP;  These are the definition(.DEF) files for the modules to be covered in Part 11.andP;  Listing Three, (page109) for example, is the DEF file for the Term module which performs TV1950terminal Emulation.andP;  Also note the definition of the Dir procedure (line 176)in Listing Three.andP;  Besides displaying a directory, this function allows theuser to log onto a different drive, or to change to a different directory.andO;This feature is necessary in a Kermit program, as only a file name must bespecified when sending (you cannot send a file based upon a complete path).andO;Part II examines these issues in greater detail.andM;Screen.DEF gives you a flavor of the Screen module to be presented in PartII, which performs low-level screen and video I/O using OS/2's VIO functions.andO;And CommPort.DEF (Listing Seven, page 111) presents a module originallysupplied by Stony Brook that I've enhanced by adding extra buffering, forinstance, to get around an OS/2 limitation.andP;  Of course, I'll also examinesome of the unexpected problems associated with porting PCKermit to OS/2.andO;Until next time....andM;Brian is an instructor of computer systems technology at the British ColumbiaInstitute of Technology.andP;  He can be reached at 3700 Willingdon Ave., Burnaby,B.C., Canada V5G 3H2.andO;</TEXT></DOC>