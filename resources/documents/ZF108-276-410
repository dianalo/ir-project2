<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-276-410  </DOCNO><DOCID>08 276 410.andM;</DOCID><JOURNAL>PC Magazine  April 24 1990 v9 n8 p273(4)* Full Text COPYRIGHT Ziff-Davis Publishing Co. 1990.andM;</JOURNAL><TITLE>Short-term efficiency, long-term productivity for database users.andO;(guidelines for novice database users)(Databases) (column)</TITLE><AUTHOR>Neuhaus, Trudy.andM;</AUTHOR><SUMMARY>A discussion of database programming, geared to novice users, ispresented.andP;  The dBASE programming language is one of the bestlanguages for beginners because it is interpreted, has strongmemory-handling capabilities, and encourages structuredprogramming.andP;  High-level languages, such as C, can access and thenwrite over any part of memory, but dBASE addresses only thosememory variables it creates.andP;  This feature makes it 'safe' becauseerrors are less likely to cause a system crash, but the programmerhas little or no control over data base management system memoryoverhead.andP;  Data base languages hide file-handling details andnetwork communications from the application.andP;  Implementing a largeapplication on a large network is costly because a LAN pack isneeded for each small group of workstations.andP;  Optimizingperformance in dBASE-like systems is difficult.andM;</SUMMARY><DESCRIPT>Topic:     Data base management systemsProductivityTutorialGuidelinesData Base DesignData Base LanguagesProgram Development Techniques.andM;</DESCRIPT><TEXT>Short-term Efficiency, Long-term Productivity For Database Users In theprevious issue, Craig Stark introduced a new column to the Productivitylineup: The Working Word.andP;  In his introduction Craig explained that itreplaces Power User and is strictly devoted to word processing.andM;There is a second part to that announcement: For all of you who read PowerUser for the database tips, you haven't been forgotten.andP;  In fact, Databasesis a column that has been created just for you.andP;  Devoting a column strictlyto databases allows us to take an in-depth look at applications and add-insthat space and format previously prohibited.andM;Yet apps and add-ins do not a column make--at least not in Productivity.andP;  Wewill also investigate current database issues and ways to make you moreefficient when working with databases.andP;  After all, that's what Productivityis all about.andP;  But to do this requires something else.andP;  Feedback.andP;  I need tohear from you: what products you want to explore, what topics you want totackle, and what problems you need to solve.andP;  I'm especially interested inhearing about useful tricks and techniques you've learned or uncovered.andP;  Fromtime to time I will publish the best of what our readers have to offer inthese pages.andP;  But everyone's contribution will affect the editorial coursethis column pursues.andM;While tips and techniques make you more productive at a local level, they cango only so far.andP;  If you have written a useful utility in MASM, for example,that can be linked to dBASE, this is the place for you to be heard.andO;Likewise, we will also be exploring more-global issues such as which languageis best to use.andP;  For example, both Clipper and FoxPro have providedenhancements to their languages that make them incompatible with dBASE.andO;Which should you choose?andP;  When should you switch?andP;  Stay tuned: this is onetopic we will visit in depth in upcoming issues.andM;Another important topic is choosing between high-level languages (HLL) andthe database languages--which is our focus in this issue and in the nextseveral columns.andM;My goal in this column is twofold.andP;  First, I want to give you a handle onshort-term increases in productivity through tips and techniques.andP;  Andsecond, but perhaps more important, I am also keenly interested in coveringthe subjects necessary to long-term, long-range productivity improvements.andM;DATABASE VS.andP;  HIGH-LEVEL LANGUAGESandM;With the relatively recent introduction of HLL database libraries, such asBorland's Paradox Engine, it's fast becoming easier and easier to createcomplex database applications using HLLs either in place of or in combinationwith dBASE-type languages.andP;  So in this issue I'll tackle the question thatalways arises whenever we're given an alternative: which is better?andP;  Usingthe dBASE language and C as examples, let's take a look at some of the prosand cons of using each.andM;dBASE FOR THE NOVICEandM;If you're a novice programmer, you should seriously consider using dBASE.andO;It's one of the best &quot;first&quot; languages for beginners, mainly because itencourages structured programming.andP;  Its modularity and relatively simple yetpowerful structure make it easier to write clean code quickly.andP;  As you wouldexpect, dBASE also has more built-in database capabilities--featuresgenerally lacking in C and other HLLs.andP;  But perhaps most important to abeginner are its memory-handling capabilities and interpreted language; aswe'll see next, they are constructed so that you won't experience a seriouscrash of dBASE or your computer, and you can always return to the dot promptno matter how bad your errors are.andM;MEMORY HANDLINGandM;C and other HLLs have the capability of accessing and then writing over anypart of memory.andP;  dBASE, on the other hand, addresses only the memoryvariables it creates.andP;  By managing its applications' memory variables, dBASEprovides a big layer of protection between the program and the objects theprogram addresses.andP;  In addition, there are no pointers in dBASE as there arein c: one variable cannot hold the address of another variable where theaddress is used to access the latter variable.andP;  So the mistakes of a noviceare apt to be minor.andM;Like everything else, however, being once more removed from memory has itsadvantages and disadvantages.andP;  While it's generally safer to program usingdBASE and its clones, this also means you have little or no control over theoverhead used by the DBMS, whether memory or disk space.andP;  A good example ofthis is the end-user support: while the user interface of dBASE and itsclones is a very attractive feature, it consumes a lot of memory and diskspace, and it adds overhead to the entire system.andP;  But without using an HLL,there's very little you can do to optimize the interface.andM;THE dBASE LANGUAGEandM;When you consider all of the steps that a single dBASE command encapsulates(including updating and reordering indexes), the value of a DBMS languagebecomes obvious.andP;  In dBASE IV, for example, issue the commandandM;USE contactsandM;where contacts is the name of the database file, and dBASE IV willautomatically open the database file, read the database structure of the fileas well as the statistics recorded in the file header (number of records,last update, and so on), open any related multiple index (MDX) file,determine which record is the first in MDX order, and read that record intoan internal buffer.andP;  Depending on which database library or engine you use,each of these operations may require many lines of C code to implement.andM;DBMS languages hide many of the file-handling details inherent in databasesystems from the application, including the underlying database and indexfile formats.andP;  And for the most part, the application does not need to knowthe file formats, nor does it need to know the file formats, them.andP;  This isthe single greatest advantage of DBMS languages.andP;  But you pay a priceforthis.andM;Inevitably, some day some application will need to know how the databasefiles are managed.andP;  Then what do you do?andP;  There's no facility in the dBASElanguage for going around dBASE.andP;  And anyway, a dBASE application can onlyread, write, and update dBASE files.andP;  It can use dBASE's import and exportfacilities to move data from one file format to another.andP;  But it can onlyaccess the formats it supports (text and comma-delimited formats, forexample) and cannot read these formats directly.andP;  Ultimately, you'll have tocustom-write a program in C or some other high-level language in order toaccess the database data.andM;Another disadvantage to programming in dBASE is that since you can't get veryclose to the machine--if at all--it's difficult if not impossible for dBASEto access external devices such as serial ports.andM;dBASE AND NETWORKSandM;dBASE also hides network communications and network file handling from theapplication.andP;  If it knows the file- and record-locking commands to preventother applications or users from changing data, an application can access alot of database information without being aware that the database resides ona network.andM;Unfortunately, it's costly to implement a large application on a largenetwork.andP;  Network applications are implemented via LAN packs.andP;  Each LAN packsupports a specific number of workstations.andP;  The more workstations, the moreLAN packs you need.andP;  So unless you can find a LAN pack that supports anunlimited number of workstations, the cost can be prohibitive.andM;PERFORMANCEandM;Generally there's little you can do to optimize performance in dBASE-likesystems.andP;  A few DBMSs offer &quot;hooks&quot; that let you improve their performance;for example, by setting the number of internal buffers.andP;  And, of course, theway in which your application uses the system can affect its performance,too.andP;  To create an efficient application, make sure you close files as soonas possible.andP;  Also, check which indexes you're using.andP;  Are you making dBASEsearch more than it needs to?andP;  Keeping more files open than necessary takesup memory that could be put to better use.andP;  And making dBASE performunnecessary searches can slow your machine to a crawl.andM;But more likely than not, the system is operating at its peak.andP;  For althoughinterpreted applications simply cannot run as fast as compiled HLLapplications, performance is strictly a factor of the underlying DBMS.andP;  Thisshifts the bulk of the blame for poor performance from the application to theunderlying database system--or from the developer to the person who chose thesystem!andM;PORTABILITYandM;The rule here is: if the DBMS is available on the platforms where yourapplication must run, then portability is usually not an issue.andP;  You can, forexample, port dBASE applications to FoxBASE and other clones without too muchdifficulty; you can even port an application between platforms that supportdBASE.andM;The level of difficulty of porting an application is in direct proportion tothe extent that the application you're porting uses unique features of dBASE,or FoxBASE, or a particular version of either.andM;If the DBMS is not on a platform where your application needs to run (such asMicrosoft Windows, OS/2, or Unix), too bad.andP;  And vendors can't be counted onto release a new version for all platforms simultaneously.andP;  For instance,long after dBASE III Plus and dBASE IV had been released for DOS, the onlyversion available for Unix was dBASE III.andM;DEBUGGINGandM;In general, dBASE programs are easier to test and debug than those of ahigh-level language.andP;  There's much less than can go wrong.andP;  The uniquememory-handling features make it almost impossible for a dBASE program tocrash dBASE or its debugger.andP;  dBASE programs are also easier to debug becausethe language is inherently an interpreted one.andP;  Interpreted languages let youindividually test each line of code at the dot prompt--an impossible exercisewith HLLs.andP;  An interpreted language also means a shorter debugging process.andO;There's no time-consuming edit-compile-link-run cycle, as there is withcompiled languages.andM;dBASE IS ALL YOU NEEDandM;Unlike HLLs, dBASE and its clones do not require a compiler or linker.andP;  Theyhave built-in facilities for interpreting dBASE programs and executingprogram instructions.andM;However, this capability also limits what you can do with dBASE; if yourequire a feature that dBASE doesn't support, you simply have to wait until anew version supports that feature--or find an alternative.andP;  For instance, ifthe statistical analysis capabilities of a DBMS aren't up to speed, or if theprogram offes windowing but not a graphical user interface, you're stuck whenyour application demands these things.andM;QUICK STARTUPandM;Interactive front ends, such as that of dBASE, lend themselves to quickstartups because you don't have to complete a program before users can beginto enter data.andP;  Instead, using EDIT and BROWSE commands, users can enter dataearly in the life of a database.andM;The nature of the dBASE language also allows end users to access and use thedatabase without having to learn any programming skills.andP;  With a few simpledot-prompt commands, end users can access a lot of database information.andM;Aside from the obvious benefits of quickly getting a usable system in place,this also saves a lot of programming time.andP;  When you have people using asystem, entering and accessing data, you'll quickly hear what's wrong (andmaybe even what's right) with your program.andP;  You'll also know what they likeand what they find difficult to use or understand.andP;  A smart programmer knowshow valuable this information is in the early development stages--not onlybecause it saves programming, testing, and debugging time, but also becauseheeding users' advice and suggestions as much as possible will go a long waytoward their ultimate acceptance of a given program.andM;ARCHITECTURAL RESTRICTIONSandM;The dBASE database model was originally conceived over ten years ago; it'sbased on mainframe technology that was available in 1979.andP;  Although theunderlying implementations have changed, there are some limits inherent inits structure, particularly when you want to perform relational operations.andO;A fully relational database system would make an application easier to writeand maintain.andP;  Thus, you might find yourself redesigning your application tofit the DBMS where the latter is simply not flexible enough to do the jobrequired.andM;HLLS: PROS AND CONSandM;Increased performance is perhaps the biggest reason to develop applicationsusing an HLL: a database engine application doesn't include the overhead ofan interactive end-user interface, and the application code is compiled, notinterpreted.andM;HLLs also give you greater control over an aplication's use of a library ordatabase engine.andP;  However, unless you have the source code, your influence isstill limited (although certainly better than with dBASE).andP;  If the databaselibrary or engine source code is available, you can fine-tune the databasesystem for performance purposes.andP;  You can also prevent unused databaseroutines from being included in the application unnecessrily, or add overlaycapabilities.andP;  However, if the code is unavailable, your only alternative isto &quot;roll your own&quot; library.andM;FLEXIBILITYandM;After performance, flexibility is perhaps the next reason to consider writinga database application with an HLL combined with database library or engine.andO;You can do almost anything you like and yet still retain enough flexibilityto make the database engine fit the application.andM;Creating an application that's database-independent is one example.andP;  Using anHLL, you can add a &quot;database-knowable&quot; layer to the application.andP;  This layercould make calls to specific engine functions, shielding &quot;knowledge&quot; for theengine from the rest of the application.andP;  Thus, future versions of theapplication would not be tied to any specific database.andP;  For instance,andM;open database();andM;migh be a call ot a function that would open a dBASE database (as in the USEexample given above).andP;  But to move to another database (FoxBASE, forexample), just change the open database function and its siblings.andP;  Theapplication is never tied to the database, since the function can be alteredto use any database engine or library.andM;HLLs allow your application to get closer to the underlying hardware.andP;  Forinstance, if you need to add a facility to download data from a serial portinto your database, you can write an interface into the application to do so.andM;You can also add other capabilities via third-party libraries.andP;  Instead ofwriting a serial-port interface as in the previous example, you might be ableto buy a library that provides serial-device support routines.andP;  Then you'dsimply have to link it into your application.andP;  Other capabilities such asstatistical services or windowing facilities, can be added to the applicationin this manner.andM;An HLL database application doesn't have the file-handling and networkrestrictions common to those created with dBASE.andP;  It can know the underlyingdatabase file format and access method as well as other file formats, and canupdate data in any file whose format it understands.andP;  Furthermore, mostdatabase libaries don't limit the number of network workstations yourapplication can support.andM;HLL applications, particularly those written in C, are also more flexiblebecause they will be more portable than dBASE applications.andP;  C is availableon every machine from a Commodore 64 to a Cray-2.andP;  And a vendor is morelikely to port a database library from one platform to another than an entireDBMS like dBASE.andM;HLL DEBUGGINGandM;HLL applications, particularly those written in C and Pascal, are moredifficult to debug than dBASE applications.andP;  Not only is it easier tointroduce bugs in these applications, but then you have to distinguishbetween application bugs and library bugs.andP;  And because you use more than onebody of software developing HLL applications, you are more vulnerable to bugsintroduced by compiler code generation and optimization.andM;HLLS CALL EXPERIENCEandM;To build well-structured HLL-based applications using a language that neitherdemands nor enforces structure definitely requires experience.andP;  It also takesskill to build a strong library interface where the application doesn't haveto know a great deal of underlying detail about the library and engine, andwhere many tasks are encapsulated into a single library function call.andM;A seasoned developer knows the consequences of recklessly using a pointer: itcan destroy program data and data files, and cause the application and thesystem to crash.andP;  Experience also teaches you that certain bugs may&quot;disappear&quot; when you change the program (as by adding a debugging statement)only to &quot;reppear&quot; later; and database libraries implemented as TSRs are proneto crashing the system and conflicting with other TSRs or devicedrivrs--particularly network drivers.andP;  They can also take up more memory,since the entire engine remains resident, whereas an overlayed system doesnot.andM;OVERHEADandM;Unless you're using an engine or library that's linked to an interactivefront end, you'll have to write programs just to set up data entry screens.andO;This could prevent data entry from beginning early in the development cycle,or could unnecessarily delay the early stages of program development.andM;Also, there's a high likelihood that it will take more work to write the codefor implementing multiuser file handling on a network, whereas this may betransparent with dBASE.andM;You usually need additional software to create an HLL application: compiler,linker, and so on.andP;  And you may need to purchase updated versions of thedatabase library or engine as updates of the compiler software are released.andM;NEXT TIMEandM;One of the most recent database engine releases is Paradox Engine fromBorland.andP;  In the next issue, we'll dig in and take a close look at ParadoxEngine and why it makes a strong case for developing applications using HLLs.andM;LET US HEAR FROM YOUandM;Share your database experience, tips, and techniques, and we'll pay you $50for any tips we print.andP;  Please send them on-disk and include a printout.andO;Mail your contributions to DATABASE, PC Magazine, One Park Avenue, New York,NY 10016.andM;Research for this article was provided by Richard Hale Shaw, a contributingeditor of PC Magazine.andO;</TEXT></DOC>