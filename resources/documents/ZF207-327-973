<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-327-973  </DOCNO><DOCID>07 327 973.andM;</DOCID><JOURNAL>Datamation  Feb 1 1989 v35 n3 p29(5)* Full Text COPYRIGHT Cahners Publishing Co. 1989.andM;</JOURNAL><TITLE>New life for SQL. (Structured Query Language) (rebuttal to 'FatalFlaws in SQL' article series by E.F. Codd) (includes relatedarticle on optimization)</TITLE><AUTHOR>Beech, David.andM;</AUTHOR><SUMMARY>Structured Query Language has its flaws like any other programminglanguage, but none of these flaws appears fatal despite thearguments advanced by E.F.andP;  Codd in a series of articles appearingin Datamation under the title, 'Fatal Flaws in SQL.' Codd, therecognized 'father of relational technology,' noted that thepopular data base management system interface is flawed in threeways.andP;  It permits duplicate rows, it supports the nesting of aquery within a query, and it provides inadequate support forthree-valued logic.andP;  In fact these flaws are far from fatal.andP;  SQLwill not only overcome them, it will outlive the relational modelon which Codd bases his theory.andP;  The duplicate row 'flaw' isactually a useful 'abstraction.' The query structure needscosmetic but not critical changes.andP;  The logic values also canaccept some cosmetic changes.andP;  Real merits of SQL are alsodelineated.andM;</SUMMARY><DESCRIPT>Topic:     Relational DBMSStructured Query LanguageProduct Life CycleQuery LanguagesData Base LanguagesAnalysis.andO;Feature:   illustrationtable.andO;Caption:   Differing views of SQL. (table)andM;</DESCRIPT><TEXT>NEW LIFE FOR SQLandM;In a pair of fine, polemical articles in DATAMATION (Aug.andP;  15, 1988, p.andP;  45and Sept.andP;  1, 1988, p.andP;  71), E.F.andP;  Codd asserted that the SQL language hadfatal flaws, specifically in permitting duplicate rows, supporting nesting ofa query within a query, and providing inadequate support for three-valuedlogic.andP;  It would be risky to disagree with the father of relational databaseswhen he evaluates the most widely used--indeed, the standard--interface tosuch systems.andP;  Yet, the suggestion that the flaws might prove fatal to SQLseems extreme.andP;  Are we really about to witness the early demise of thelanguage, despite present indications of its good health, increasing vigor,and market acceptance?andM;SQL, like any language that actually exists, has some flaws, but they canmostly be repaired so that the results would be as near to perfection as weshould be likely to attain even if we had made a completely fresh start.andM;Codd's thesis aside, SQL has some real merits.andP;  Ironically, the major flawsin SQL are where it is most faithful to the relational model, rather thanwhere it departs from it.andP;  Fortunately, these limitations can be overcome,opening up exciting vistas for SQL, as will be shown in a subsequent article.andO;The language will not merely avoid fatality; instead, it can enjoy a newlease on life and outlive the relational model, or at least its dominantinfluence, as a child may become emancipated from a parent.andM;This is not to suggest that there are flaws in the relational model--as atheoretical achievement, it has its place in history as one of the fewpinnacles of computer science, and it has been effective for a very largenumber of applications.andP;  Its advantages are the simplicity of its tabulardata structures, and the thoroughness with which the operations on thosestructures have been thought through.andP;  Any application whose data can(without too much effort) be made to fit this rectangular model stands tobenefit from the intelligibility of the database system and the flexibilityof the queries that may be addressed to it.andM;But what about applications with more complex and irregular data structures?andO;For them, the advantages of the relational model may be more than outweighedby the &quot;impedance mismatch,&quot; as it has been named by David Maier of theOregon Graduate Center, Beaverton, Ore.andP;  This is the mismatch that oftenoccurs between the natural programming structures for an application and thestructures supported by current database systems--not only relational ones.andO;Achieving the necessary mapping is costly in both programming labor andrun-time performance (which can suffer further from fragmentation of thestructures in the database).andP;  Are we ready to build on experience with therelational model and SQL to widen the effective range of database systems andimprove their usability?andP;  I believe we are, but before we get too optimisticabout the long-term prognosis for SQL, we should check on the patient'shealth in view of the three apparently serious symptoms diagnosed by Codd.andM;The Duplicate-Rows ArgumentandM;First, there is SQL's willingness to tolerate duplicate rows in a relation.andO;The arguments against this are presented at two different levels--those thatallege specific technical problems, and those that are more broadlyconceptual.andM;On the conceptual level, Codd poses the following question: &quot;If [duplicaterows] represent distinct objects [abstract or concrete], why is theirdistinctiveness not represented by distinct values in at least one componentof the row [as required by the relational model]?&quot;andP;  The answer may be givenin a word: abstraction.andP;  Although abstraction is one of the quint-essentialproperties of mathematics, it is also familiar to people with more concreteinterests, such as buying groceries.andP;  The check-out receipt from asupermarket is more informative than it used to be, and in a simple formcould correspond to something like a relation, with columns to describe thearticles purchased and their cost.andM;For example, the row &quot;cat food 0.39&quot; could appear three times with asignificance that would not escape many shoppers.andP;  The three distinct objectsmay or may not be of different flavors, although they will certainly differin some sufficiently detailed ways, even apart from their spatiotemporalcoordinates.andP;  But at the level of abstraction at which it is useful to recordthe information, there are no value components that distinguish the objects.andO;What the strict relational model then does is to force people to lower thelevel of abstraction, often inventing meaningless values to be inserted in anextra column whose purpose is to show what we knew already, that the cans ofcat food are distinct.andP;  Supermarkets are too cost-conscious to indulge in theextra labor of generating and printing a transaction number for eachindividual purchase, so they permit duplicates.andP;  And the SUM function workscorrectly, without being given that extra column to ignore.andM;Thus, there seems to be a well-established precedent for treating informationthis way, so that it would be &quot;natural&quot; for a database model to permit it,provided that there were no serious drawbacks.andP;  Yet, before we get into thistechnical level of debate, there is an even stronger challenge from Codd:&quot;The relational model is based on at least 11 fundamental laws.andP;  One of themis as follows: every row in a relational database, taken together with thename of the relation in which it occurs, must uniquely identify some objectin the microworld being modeled.&quot;andM;The Origin of the 11 LawsandM;This is all rather puzzling.andP;  When were these 11 laws promulgated, and why&quot;at least&quot;?andP;  Perhaps they are all being discovered, like natural laws--but ifso, how can the relational model, as a human artifact, have been based onthem?andP;  And how fundamental are they--why were they not listed in the originalpapers that established the theoretical basis of the model?andP;  The particularexample of a law cited here is especially surprising, because a notablefeature of the relational model is that it does not have a concept of anobject or entity.andP;  Yet, each row in a relation is now having to support theonerous duty of uniquely identifying some object in a microworld, althoughthere is often a poor correspondence between a row in a normalized relationand what the user might consider an object.andM;The relational &quot;law&quot; encountered above does not so much provide reasons forexcluding duplicates as almost directly legislate against them.andP;  The onlyduplicate rows that could possibly slip through its net (depending on theforce of &quot;uniquely identify&quot;) would be those that identified the same object,but our three different but undistinguished cans of cat food are outside thelaw.andP;  We should have to put values like 1, 2, and 3 alongside the differentrows, even though these correspond to nothing in the microworld.andP;  Why shouldwe?andM;We are not being less than respectable mathematically if we considercollections containing duplicates, because mathematicians deal with suchcollections, called multisets or, in more homely style, bags.andP;  Of course, ifpressed to discuss cat food in detail, mathematicians would deal with itrather differently.andP;  For example, let x, y, and z be cans of cat food wherex, y, and z are not equal, and cost(x)=cost(y)=cost(z)=0.39.andP;  The identity ofthe objects is bound to variable names, rather than being deduced fromselected properties of the objects, and the properties are given as functionsof those variables.andM;Because duplicate rows seem to have emerged as sound and useful conceptualabstractions, we are ready to consider the technical questions about them.andO;According to Codd, the case to be answered is essentially that theirtheoretical basis was not thoroughly explored, and that this has led to twokinds of problems: inhibition of optimization, and unexpected results toqueries.andM;The optimization point rests on an example that claimed to show that &quot;somedegree of immunity to the sequence of operators is lost when duplicate rowsare permitted.&quot;andP;  However, the example compared apples with oranges.andP;  It didnot show that there was any problem when comparing like with like (see &quot;TheOptimization Example&quot;).andP;  Therefore, the claim that &quot;What this example showsis that changing the sequence in which relational operations are executed canyield different results if the DBMS permits duplicate rows within a relation&quot;is highly misleading.andP;  It would be true only with the further assumption thatduplicates are necessarily removed in making a join, which is not the case inSQL.andM;Equally innocuous are the charges about unexpected results due to &quot;the user'sburden in determining the sequence of relational commands, when the userchooses to make this explicit.&quot;andP;  SQL tends more to the relational calculus,with heavy reliance on the unordered evaluation of the predicate in its WHEREclause, rather than to the ordered operations of the relational algebra;thus, the emphasis on ordering seems to be misplaced as far as the SQL useris concerned.andP;  Care is needed in expressing complicated queries in SQL, aswith natural language; we know this from experience in converting,natural-language queries to any unambiguous formal language.andM;Improving Nested QueriesandM;The debate over nested queries will take on a more mellow tone because Coddsaw some attractions in the original idea, and it is true, as he states, thatnesting one query inside another does not provide the full power of predicatecalculus.andP;  The keywords EXISTS and ALL in SQL are not used exactly likelogical quantifiers, and this is a flaw that should, and can, be fixed.andO;Because a query produces a relation as its result, and a relation (admittingduplicates) is a bag of tuples, the nesting of queries allows operations tobe performed on bags.andP;  Thus, the &quot;X IN subquery&quot; construct used in theexamples is a test of bag membership, which is a legitimate predicate to findin a predicate calculus expression.andP;  It would also be a welcomegeneralization, as Codd requests, to be allowed to write &quot;(xl, .andP;  .  .  xn)IN subquery&quot; when a subquery returned a relation with n columns.andP;  Thisextension has already been adopted by the ANSI SQL committee.andM;While on the subject of potential improvements in SQL, one major improvementwould be the addition of a function notations for invoking queries.andP;  Theclumsy syntactic nesting of queries becomes attractive when replaced byfunction calls in the WHERE clause.andP;  Relational views (and, indeed, tables)can also be regarded as functions, taking no arguments and returningrelations as their results.andM;So, there is no disagreement over whether SQL needs to be improved in itsquery structure, only whether the required surgery is cosmetic orlife-threatening.andM;The examples that were used to show how different results can arise fromqueries expressed differently in SQL do not appear surprising if interpreteddirectly according to SQL semantics.andP;  The problem seems to arise if they arebeing mentally mapped into some other relational language.andP;  However, SQL doesintroduce needless confusion into the understanding of its semantics by theorder in which it uses the SELECT ...andP;  FROM ...andP;  WHERE ...andP;  clauses.andM;If the SELECT clause were moved to the end, there would be two ways in whicheverything would become clearer.andP;  First, the lexical scope would follow theconventional pattern of block structure in programming languages, with thevariables introduced in the FROM clause having a scope extending to the endof the statement, except where interrupted by redefinition in the FROM clauseof a nested query.andP;  Second, the semantics would follow the syntactical order.andO;The FROM clause first determines the tables and views over which thevariables are to range, the WHERE clause selects those rows from theCartesian product of the variables that satisfy its search condition, and theprojection and function evaluation specified by the SELECT clause are thencarried out to produce the result.andP;  This syntactic permutation would be atrivial language change to specify and implement.andP;  Similar remarks apply tothe iterative UPDATE statement.andM;Another important point is that a variety of user-oriented languages need tomap to a single underlying language providing some kind of canonical form.andO;Because SQL is already becoming widely used as a common interface todifferent systems, a tempting solution would be to try to improve it to apoint where it would do a better job serving as the canonical form itself,rather than mapping to something else.andM;Logic Problems Beyond SQLandM;The problems of many-valued logics can be dealt with more quickly, notbecause of their simplicity, but because they are deeper than what can beblamed on SQL.andP;  ANSI SQL recognizes three-valued logic in evaluating queriesand iterative updates, although it allows retrieval only of the results thatare definitely known to be true.andP;  Retrieval of the MAYBE results would alsobe valuable, as suggested.andP;  Again, additional options on the aggregatefunctions would provide more complete functionality--yet we must notunderestimate the massive implementation efforts required to build databasesystems with all of the robustness and pragmatic characteristics that aredemanded.andP;  These extra features have to be prioritized, but that wouldrequire more considerations of customer needs than can be dealt with here.andM;There is no dispute over the need, in the future, to have a strong treatmentof uncertainty in SQL.andP;  But there is a real problem with the truth-tableapproach to uncertainty, lightly passed over by Codd.andP;  It is important not toignore this, not only because the standards in relational theory should beupheld in case unforeseen consequences ensue, but also because as we try tomove from today's databases to tomorrow's knowledge bases, the problembecomes more pervasive.andP;  We are talking about simple usage of logic now, butthis soon becomes theorem proving--the definition of a Grandparent view overa Parent table corresponds to a simple rule in Prolog, for example, so whatother propositions might we want to store in a database and reason with inanswering queries?andM;The problem is that the truth tables are pessimistic about what is decidable,because they assume in evaluating P AND Q that P and Q are independent.andO;Thus, if both are MAYBE, the result is MAYBE.andP;  But the situation is ratherlike that of combining probabilities--the simple rules fail if there isinterdependence between the terms.andP;  Suppose that P is X and Q is NOT X.andP;  WhenX is MAYBE, both P and Q are MAYBE, yet the P AND Q is provably FALSE.andP;  So, abusiness decision might be influenced by a query showing something as MAYBE,which, in fact, could never occur.andM;There are two replies to the suggestion that users should be advised not towrite tautologies or contradictions in their queries.andP;  The first is thattautologies or contradictions can take far less obvious forms, so that we mayeasily overlook them in parts of queries.andP;  Secondly, queries may often begenerated by programs that would then have to do the theorem proving, whenthe general problem, as noted by Codd, is unsolvable.andM;This is not a happy situation, however much we tell users that the &quot;true&quot;results given by a query are only those that the system has been able toprove true.andP;  They may still attribute greater powers to the system than itpossesses, and assume that they are getting a complete answer.andP;  Theintroduction of a fourth logical value for INAPPLICABLE would make anotherimportant semantic distinction, but at the cost of greater complexity.andM;So, we may conclude that SQL could make some cautious adjustments of itsaggregate functions and perhaps offer queries for MAYBE results, but that theoverall problem of uncertainty and iference is more general and no one hasyet demonstrated a completely satisfactory solution.andO;</TEXT></DOC>