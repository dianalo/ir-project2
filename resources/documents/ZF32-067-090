<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO> ZF32-067-090 </DOCNO><DOCID>11 270 731</DOCID><JOURNAL>Communications of the ACM  Sept 1991 v34 n9 p16(8)* Full Text COPYRIGHT Association for Computing Machinery 1991.andM;</JOURNAL><TITLE>ACM forum; readers argue teaching methods. (letter to the editor)</TITLE><AUTHOR>Berens, Tim; McCarthy, Thomas J.; Fekete, Alan D.; Clune, ThomasR.; Grune, Dick; Endrizzi, Michael; Gries, David.andM;</AUTHOR><DESCRIPT/><NOTE>Only Text is presented here; see printed issues for graphics.andO;</NOTE><TEXT>David Gries argues rather forcefully for changes in the methods used to trainsoftware engineers.andP;  The majority of the article advocates increasing theamount of mathematics taught to undergraduate students.andP;  I, too, have asuggestion about how to improve the curriculum.andM;Gries's ideas reflect his background as a professor with a Ph.D.andP;  inmathematics.andP;  My suggestion reflects my background as simply a programmer whowrites many thousands of lines of code per year.andM;Professors of computer science should take a lesson in teaching from theircolleagues in the music department.andP;  For centuries the art and craft ofplaying a musical instrument has been taught by the same method--privatelessons.andM;A master of the instrument meets privately with a student, typically once perweek for one hour.andP;  During the lesson, they discuss the techniques which werepracticed the previous week and also those to be learned the next week.andP;  Therest of the week the student practices what he learned during the lesson.andM;In a college setting, the private lessons are blended with a variety of othercourses such as music theory, music history, ear training, etc.andP;  While theother courses have the same rhythm of a standard college course(introduction, midterm exam, research paper, final exam, out the door), theprivate lessons maintain a sense of continuity in the student's education.andO;Generally, a student will study privately with the same teacher during thestudent's entire four years in college.andM;The sense of continuity this creates allows a student and teacher to probedifficult musical pieces in depth.andP;  It allows the student to begin adifficult piece in September and work on it with his teacher until thefollowing September, if necessary.andP;  This type of in depth work is generallynot possible in the traditional semester or quarter length classes.andM;One of the major criticisms of the current method of teaching CS is itsemphasis on projects which fit neatly into the artificial boundaries ofsemesters.andP;  Students learn how to develop top compilers, parts of texteditors, mini-operating systems, etc.andM;With private lessons, a CS student could be assigned the types of tasks hewill face in the &quot;real world.&quot;andP;  These tasks could take months or years tocomplete.andP;  For example, a student could spend many months developing alibrary of tools.andP;  Then he could use these tools to develop a next editor,which could in turn be used for editing on future projects.andM;When he uses the tools he developed, he will see first hand how poor designand implementation practices can haunt a programmer.andP;  After he has used histext editor for a while, he can enhance it to include the functions he hasnoticed are lacking.andM;In the process of this enhancement, he would learn some valuable lessons inboth maintenance of code and how to write maintainable code.andP;  Somehow, thispoint is driven home much better when the person who wrote the rotten codeyou must work with is staring back at you in the mirror.andM;While the student is doing these tasks, the instructor can pass along thethousands of little things which are generally not discussed in a classroomsetting.andP;  Through this one-on-one interaction, the student would also beginto get a feel for the intuitive processes used in the development ofsoftware.andM;There are those who wish computer programming were pure engineering or puremathematics, but it quite simply is not.andP;  There is something else involvedwith developing fine software, let us call it art for lack of a better word,and private lessons could be used to pass along some of the art of computerprogramming.andM;Of course, there is one major problem--money.andP;  This would be an expensive wayto educate students.andP;  In music circles there is never a shortage of highlyqualified teachers.andP;  (You would be amazed at how many people with doctoratesin music are barely scraping out a living.)andM;This, unfortunately (or fortunately, as I believe every other Friday), is notthe case with the world of computers.andP;  These private lessons would mostlikely require additional fees on the part of the student, and additionalwork on the part of teachers.andP;  To help shoulder the burden, teachers could(and perhaps should) be recruited from local companies.andP;  Who knows more aboutprogramming professionally than professional programmers?andM;While I applaud Gries's efforts to reform the curriculum of CS students, Ifeel he overstates his case when he implies that adding more courses inmathematics will &quot;solve the ills of the profession.&quot;andM;A solid background in theory is essential, but at some point, a musician mustpick up his instrument and make music.andP;  Likewise, a programmer musteventually sit at a computer and write code.andP;  At this point, the theoryprovides a solid foundation, but the more nuts-and-bolts experience themusician/programmer has with his instrument/language, the better themusic/program will turn out.andM;Private lessons would be of immeasurable assistance in acquiring thisexperience.andM;Tim Berens Back Office Applications, Inc. Dayton, OH 45459andM;While I do not have anything like Gries's qualifications, I cannot allow hissuggestios to go unchallenged.andP;  We both agree that programming (the use ofcomputer instructions to achieve a desired result) must be taughtdifferently, but our solutions diverge rapidly.andM;We both agree on the fact that software engineering is careening out ofcontrol, and getting worse.andP;  In part this is due to a lack of properinstruction, but also due to a lack of learned judgement and the associatedethics.andP;  I use the term learned judgement deliberately, to distinguish itfrom a natural skill.andP;  For example, the ability to judge the distance ofobjects is a natural skill, while catching a moving object is a learnedskill.andP;  In the same way, a software engineer learns how to apply his/herjudgement to the solution of a problem.andM;I believe that where we disagree is fundamental to the problem.andP;  Gries seemsto believe that size is irrelevant to using mathematical logic for solvingproblems, instead of growing more necessary as it increases.andP;  Additionally,he seems to believe that all practitioners can/should be able to usemathematical notation with skill equal to students of advanced math.andM;I had two and a half years of engineering curriculum before switching to acomputer major, and I learned a great many skills as a result.andP;  However, Ialso learned that mathematics is only a means of modeling reality.andP;  Avaluable means, but not necessarily the absolutely, best way.andP;  All too manytimes, a problem would be presented and the solution would be A ismanipulated by some process B giving C.andP;  Worse yet the validity of thisunknown process was left to the student to &quot;prove.&quot;andP;  In some cases I neverdid learn how to get from A to C by way of B, except by way of black boxes.andO;I came to realize that math can be used to express reality, but it is not theonly way to describe reality.andP;  If a mathematical model is the only way toexpress reality, but the average person needing to use the reality cannotfollow the math, that model is of little value.andP;  For example, when I grind amirror for a telescope, I do not care if light is a particle, or a wave, orboth.andP;  I only care that I can predict the path in gross form.andP;  If I amdesigning an optical computer chip I care very much about what light reallyis.andM;I believe that this is part of our problem today.andP;  We are trying to modelreality without remembering that the model must be understandable to make itworth using.andP;  One of the reasons that I left engineering was the idea that anengineer is first and foremost a theorist, not an expert on application oftheory.andP;  I see the same lack of focus taking place in CS studies today.andP;  Wehave a great need of theorists, but even more need of those who can applytheory to the real world.andM;Having criticized Gries's solution, I must propose an alternative.andP;  In thisrespect I have several to advance:andM;1.andP;  All CS/CPT students should receive a multi-credit class in programminglogic.andP;  This means they learn how and when to apply algorithms to thesolution of a problem.andP;  I have spent the last six years learning how to dothat on my own, and would still take a class to learn how to do it better.andP;  Iapply processes from mathematics, engineering, philosophy, and who knows howmany other disciplines to all my programs.andP;  A properly written program haselements of communications, as well as logic, and philosophy in itsconstruction.andM;2.andP;  Students should spend more time learning to apply fundamental structuresto problems.andP;  This can and should be a part of a programming logic classcurriculum.andP;  Teach us the thought process that gives us the tools to dosoftware engineering right.andP;  Students need to learn the process, not just thelanguage, of proving theories.andP;  I do not need to know how to design a saw inorder to cut a piece of wood.andP;  If we choose to go after an advanced degree,and do research, then we need an advanced understanding of the language aswell as the process.andP;  Focusing solely on the theory of any process becomesivory tower inbreeding, and risks becoming irrelevant.andM;3.andP;  Theory and applications need to receive equal weight in the curriculum.andO;Perhaps one in three-to-five students, can/will/should go on to theMasters/Ph.D.andP;  level, but most will not.andP;  Currently the student that will notgo on is made to feel inferior to those that will deal with advanced theory.andO;One of my engineering classes was on transistor theory.andP;  The instructor wasbrilliant, but the class was taught at a level appropriate to those headingfor the advanced degrees, not the &quot;average&quot; student.andP;  Challenge me to exceedby abilities, but do not try to make a &quot;pure&quot; theorist of a pragmatist.andP;  Wedon't mix well.andM;As a software engineer/programmer, I must have at least some understanding ofhow a compiler works, but that does not mean I have to be able to write one.andO;My classes in digital systems analysis taught me enough about the hardware tobe a better programmer, but I would not dare design a computer chip.andP;  In thesame respect, students need an exposure to the theory and minimalapplications, but not to the exclusion of all else.andP;  Give them enough theoryto see how it works for themselves, then let them decide how much more theyneed or want.andM;In summary, what I propose is a restructuring of the way computer classes aretaught.andP;  Teach the fundamental structure of how to program in some form, thenshow the theory behind the structure in general form.andP;  Follow this with aconcentration on how to use the processes that come out of the theory.andP;  I maynot be able to follow the theory as well as someone else can, but I can learnthe theory from seeing it applied.andP;  &quot;What I see, I understand.andP;  What I do, Iknow.&quot;andP;  This supposed old Chinese proverb applies to the art of programmingas much as any learned skills.andM;Thomas J. McCarthy Box 1605 Indianapolis, IN 46206andM;David Gries's article raises important issues about what computer sciencecourses should teach.andP;  I feel that his approach risks bringing into disreputea most important aspect of the subject, that of making judgements betweenalternatives.andP;  In his description of &quot;discrimination,&quot; I find both anunrealistic simplification of the fundamental idea, and pedagogic folly thatcould destroy its credibility.andP;  (His other emphasis, on manipulation of logicas a paradigm for programming, has been adequately discussed in earlierletters in response to the article by Dijkstra (Communications, Dec. 1989, p.andO;1398), and I will not address it further).andM;In teaching the programmers, system designers, managers, and researchers ofthe future, we need to prepare them to choose wisely.andP;  They will all facechoices:  between possible algorithms for a task, between competing hardwareplatforms, between proposals for a new product.andP;  These choices will not beblack-and-white, with one answer.andP;  Instead the decision will always come to atrade-off.andP;  Thus we need to sensitize students to the process of evaluation.andO;First they will identify all the absolute requirements of a system orcomponent, and determine goals that are desirable but not crucial.andP;  Next theywill analyze each competitor for its performance in each criterion.andP;  Thosethat fail any requirement will be removed from consideration, and choiceamong the rest will depend on the comparative advantages on each goal, withdue regard for the relative importance of different goals.andM;This process is not obvious (indeed Gries's own suggestion for a change inthe curriculum neglects to discuss the requirements of a course -- what thestudents should be able to do at the end).andP;  We can do a lot to train studentsto choose well.andP;  For example, teaching them logic as a language forspecifying requirements may help them to abstract away from unimportantaspects of existing system behavior to the true requirements.andP;  As anotherexample, courses in algorithms may teach them methods to analyze performance.andO;At present, these methods are too often taught in isolation, with theirpurpose, as tools to aid in making judgements, left implicit.andM;In contrast to this complexity, Gries offers us a trivial criterion as anexample:  judge proof techniques based on how short the proofs are produced.andO;Practicing mathematicians use many criteria to judge proofs: how general theresult, how well the proof-technique works in related areas, how muchmachinery is used from other subdisciplines, and even a subjective sense of&quot;elegance.&quot;andP;  If we present the idea that one can evaluate the quality ofproofs on the basis of length, as the first model for discriminating betweenalternatives, the students may well get the wrong idea: they will think it iseasy to make choices, that there is no room for debate.andP;  They will scarcelybe ready for any of the subtle choices they will need to make aftergraduation.andM;The other major weakness of Gries's proposal is pedagogic.andP;  Whatever we wantto teach needs to be related to the things our students want to do, or elsethe majority of students will not see it as worth learning.andP;  Students may dothe exercises, and use the techniques on exams, because they want a passinggrade, but if they cannot see any importance in the methods, the skills willthen be forgotten: they will not enter the students' toolbox for use in theirprofessional life.andP;  For a small group of potential mathematicians abstractreasoning is a joy, and the fun of the game of finding clean proofs isimportance enough.andP;  But these are definitely exceptional, and the bulk ofstudents (like the bulk of the profession) are pragmaticists.andP;  In mydepartment, we survey students about their reason for taking our courses.andO;These surveys make it clear that what most students care about is makingworking programs.andP;  Few care about why the programs work, and almost none havereached the philosophical sophistication to worry about proving that theywork.andP;  Mathematicians and logicians have established proof as a fundamentalgoal, but the notion is subtle, and it takes a lot of work to teach studentsto tell a proof from a non-proof.andP;  This work may be well-spent, but it shouldmake clear that to use proof as a vehicle to teach discrimination ismisguided.andP;  The motivation will be insufficient for many who will enter theprofession, and will need some skill in judgement.andM;What can be done instead?andP;  I teach 13 hours (as part of an introductoryone-year course) whose theme is choosing between programs.andP;  We discussspecification (by writing pre- and postconditions).andP;  We discuss how tounderstand that a program meets its requirements by identifying loopinvariants.andP;  We also analyze performance (worst-case running time, spaceneeded).andP;  Each is illustrated on standard problems that the students havealready met in programming exercises, such as finding the largest value in asequence, or looking for an entry in a sequence.andP;  We can discuss complexchoices, for example between binary search and sequential search, or betweeninsertion sort and merge sort:  issues include which is more generallyapplicable, which runs faster on small cases and which on large cases, howcommon are the inputs that are worst-case, and which code is easier tounderstand and thus to maintain.andM;Theoretical (that is, mathematical) computer science has an important placein the education and later practice of any computing professional.andP;  Finiteautomata are important for designing clocked digital circuits and for usingregular expressions as an input description language (as is done throughoutmodern system software).andP;  Predicate Logic serves as a language for databasequeries, general-purpose programming, and automatic verification methods.andO;Category theory can serve as a basis for implementing functional languages.andO;The key, in my judgement, is to motivate any theory course by basing theteaching firmly on the applications.andP;  The mathematical purity allowed to amath department (studying the equivalence of different axiom sets, orconcentrating on the proof techniques) must give way for us to the imperativeof convincing our students to use the techniques throughout their careers.andO;Thus theory needs to be seen always as an aid to effective practice.andM;Alan D. Fekete Basser Dept.andP;  of Computer Science University of Sydney N.S.W.andO;2006 AustraliaandM;Reading Gries's article brought to mind the old saying, &quot;For a man with onlya hammer, all the world's a nail.&quot;andP;  Gries's thesis, bizarrely, is that thecure for what ails computer science education is teaching yet more logic.andP;  Ifthis notion were unique to Gries, I would enjoy it as a pleasant bit ofidiosyncrasy from a man who is unarguably my better.andP;  Unfortunately, however,his perspective seems to be gaining ascendancy in academia.andM;If one is to propose changes in the computer science curriculum, it seems tome that the first question that must be answered is: what are computerscience students being educated for?andP;  One way to answer that is to look atwhat computer science graduates end up doing.andP;  In general, they providesupport services for activities unrelated to computer science:  business,science, medicine, manufacturing, and the like.andP;  Unlike chemists andchemistry, nurses and nursing, or lawyers and law, the business of computerscience graduates is not computer science.andM;If we take seriously the idea that computer science is a support service, oneeducational reform becomes obvious: computer scientists should receive abroad liberal education.andP;  It seems to me that a minimum of one year each ofphysics, chemistry, and biology; mathematics through the usual calculussequence; at least an introductory course each in business and engineering;and enough English to allow the computer science major to communicateproperly with people from different disciplines are minimum corerequirements.andM;As for logic, it seems to me that computer science students suffer from toomuch of it, rather than too little.andP;  The emphasis in computer science is onthe tools for teaching computer science, not on the tools for producingreliable programs.andP;  But this bias is seldom understood by the computerscience students.andP;  I have yet to meet a recent computer science graduate whodoes not believe that recursion is a reasonable approach to generating aFibonacci sequence!andP;  In reality, except for the rather obscure area of treesearches, there is very little that recursion is good for.andP;  Of course, theinterest of computer science teachers is in laying the groundwork forteaching the Turing form of Church's thesis.andP;  But even this is ofquestionable value for computer science undergraduates--for those who will becreating programs, &quot;will it halt in my lifetime?&quot; is a much more appropriatequestion than, &quot;will it halt?&quot;andP;  And logic will not help us with that.andM;Instead of the arcana of computing theory, undergraduate computer sciencestudents need to understand the standard tools, techniques, and references ofcomputing practice.andP;  It is amazing how few computer science students areversed in even such routine concepts as using XOR for graphical cursors.andO;Routine aspects of computing, such as serial communications, are almostuniversally unknown to the computer science student.andM;The widespread inability of computer science students to develop generaltools in the process of solving particular problems is, for me, the mostsurprising failure of a computer science education.andP;  Even after twenty yearsof beating the structured-programming drum, computer science leaves most ofits students ill-equipped to evaluate simple problems with an eye toidentifying what is general in the task.andP;  It appears that computer sciencecourses spend insufficient time practicing the concepts that they discuss.andM;A general goal of education is to instill in students an appreciation oftheir debt to their predecessors.andP;  More than most fields, computer scienceseems to fail in this task.andP;  In fairness, much of the problem resides inthose who choose computer science for their course of study.andP;  A significantfraction of the people who enter the field seem to want to be thought of ascomputer geniuses or wizards.andP;  They often seem to value creativity overcraftsmanship.andP;  Creating their own answers to problems that were solved welldecades ago, they expect to be praised for their intelligence rather thancondemned for their ignorance.andP;  But computer science must share the blame tothe extent that it rewards rather than reshapes such behavior.andM;In summary, I believe that the problems that face computer science requiremore mundane solutions than Gries proposes.andP;  Just as set theory was not theanswer to Johnny's inability to add, so mathematical logic is not the answerto young John's inability to program.andM;Thomas R. Clune Director of Software Development Medical andamp; ScientificEnterprises, Inc. Sudbury, MAandM;David Gries argues that academic programming practitioners should exploit andteach more theory.andP;  My reaction to this is, &quot;What theory?&quot;andP;  I have twoarguments for my reaction.andP;  The first is indirect, and is: that in thosefields of computer science in which adequate theory exists, it is bothexploited and taught.andP;  The second is direct, and is: that indeed there is atpresent no adequate theory of program construction.andM;The oldest field in which a full theory is available (and has been availablefor quite some time) is parsing, and its theory is certainly being used andtaught.andP;  No professional programmer writes parsers by hand; they are allcrafted by tools, in the best engineering fashion.andP;  Any book on compilerconstruction covers parsing techniques more or less extensively, oftenincluding considerable mathematics, witness Goos and Waite's book [1].andP;  Inaddition, there are several other examples: network protocols are verifiedusing automaton theory, set theory is used extensively in database design,and I know of at least one code generator that utilizes Hall's theorem.andP;  Itwould be a strange anomaly if the practitioners of one particular branch ofcomputer science would ignore existing theory.andM;It is difficult to argue that there is no adequate theory of programconstruction yet without sounding offensive, but in the next paragraph Ishall demonstrate that no offense is meant nor is even applicable.andP;  I have topoint out that even the present article does not give any application of thetheory that could by any stretch of imagination be used in the real world ofsoftware engineering.andP;  The author is not alone in this; the recent and veryfundamental book by Dijkstra and Scholten [2], quoted in the article, givesmore detailed theory, but the authors explicitly do not address real worldlimitations like integer overflow either (see page 123 of [2], although theyhint at some hardware approach).andP;  The only work that applies theory toproblems of real-world size I know is that of Partsch [3].andM;It is not amazing that no such theory is yet available: the mass of theoremsengineering is built on was developed over a considerably longer period thanthe forty or so years that lie behind us.andP;  But in my opinion there is a moreprofound reason.andP;  The comparison often made between engineering andprogramming is a false and misleading one.andP;  Gries asks if we have ever heardphysicists say that their problems are too big and too complicated to behandled by mathematical techniques.andP;  Perhaps the surprising answer is &quot;Yes,all of them.&quot;andP;  Any physicist or engineer knows that real-world problems aretoo complicated to be handled by theory alone.andP;  So s/he approximates, ignoresfriction, ignores third order terms in a Taylor series, assumes purecylindrical symmetry, or some such expedient.andP;  When in doubt, she then adds asafety factor, the magnitude of which is often conventional.andP;  And as a resultthe bridge stands and does not fall, so it is good engineering theory.andO;However, approximating and ignoring higher-order terms is not good enough incomputer science: The answer has to be 100% correct not 99.999%; this mayhave to do with the continuous nature of engineering, where small errors aredamped out, and the discontinuous nature of computers, where there are smallerrors tend to magnify.andP;  The nearest equivalent of a safety factor incomputer science is the Ada exception; no more needs to be said.andP;  It seems tome that basing our view of software engineering on the limping analogy withengineering will lead us into a swamp.andM;Unlike engineering problems, computers require completely correct solutions.andO;Fortunately computers are less complicated than the real world, with itsfriction, turbulence, etc., but still a full algebraic treatment of adatabase system, while probably theoretically feasible, is surely beyond myintellectual grasp.andP;  I think theory needs to be extended to the point that itcan cover such a programming endeavor, and tools need to be developed that dothe algebraic treatment.andP;  But neither is available at the moment.andM;In summary, I think that the reaction of the computing community to programconstruction theory is sane and correct: we teach what exists of it to thosewho are interested in developing and extending it, but we do not sendpractitioners into the field, armed with inadequate tools; to do so would beirresponsible.andP;  Program construction theory is somewhat like controllednuclear fusion: it is possible in theory but not practical at present, but Iam sure we will one day have it and then everyone will use it withoutquestioning.andM;Dick Grune Faculteit der Wiskunde en Informatica Universiteit AmsterdamandM;In my response to Gries, I do not wish to initiate an argument on thedifference between a software engineer and a hacker, similar to the meleeDijkstra initiated in his December 1989 ACM editorial, &quot;Cruelty of ReallyTeaching Computing Science.&quot;andP;  Rather, I wish to present my views on why Ifeel formal methods do not enjoy wide acceptance in the software developmentcommunity.andM;Gries devoted a section of his article to presenting various notations forproving a theorem that well-foundedness and the validity of mathematicalinduction are equivalent.andP;  Gries claims that his calculational notationresults in &quot;crisper, shorter and more precise work.&quot;andP;  Gries decries anEnglish-style proof of the same theorem as too wordy and hard to internalize.andO;I must disagree.andM;Gries's proof and his accompanying narrative are an example of why formalmethods are not being accepted in software development.andP;  By failing toexplain what the notation stands for (parallel assignments,&quot;wp,&quot;&quot;::,&quot;[P]S[q], unconventional negation operators), the very audience heis attempting to convince is unable to decode the core of his argument.andO;While not the first or last person to lose an audience in pursuit of logicalperfection, IEEE Transactions on Software Engineering is filled with articlesthat few people in the profession are capable of comprehending.andP;  Even afterthe notation is described, many times a simple symbol such as &quot;*&quot; willrepresent a plethora of semantics that are impractical to reason with.andM;The product of software development is more than an abstract symbolmanipulator computing the &quot;correct&quot; solution to a problem.andP;  The product (ie.andO;source code) is a communication medium used by the developer in the &quot;socialprocess&quot; of convincing customers, management, evaluators, teaming partnersand co-workers that the product is indeed producing the &quot;correct&quot; answers.andO;If the communication media is encrypted in a way that isolates it from thereal world, then it will fail the &quot;social process&quot; with only the developerappreciating its supreme aura.andP;  For example, if I contract with a civilengineer to build a bridge and s/he presented the design using stressequations (which I do not understand), how would i be able to tell if thebridge will be built out of toothpicks or iron?andP;  When I drive my family overa bridge, I like to see lots of iron.andP;  This is not to say that the stressequations are incorrect or that iron bridges will never fall down, it onlymeans I have more confidence in iron than stress equations and toothpicks.andM;Consider the following example from the software world.andP;  I contract withDeveloper A and Developer B to build control software for a pacemaker.andO;Developer A uses Booch's OOD methodology to specify and build a pacemakerprogram while Developer B uses CSP formal notation.andP;  Developer A producespretty charts, module diagrams, object diagrams, class diagrams, etc., withmeaningful descriptors and labels.andP;  In contrast, Developer B produces 200pages of Xs and Ys.andP;  While Developer B may have derived a &quot;correct&quot; solution,it is so &quot;short, crisp and precise&quot; that I (customer, manager, field support,co-worker) am unable to decrypt it in order to pass the &quot;social process&quot; ofassuring its correctness.andP;  In contrast, Developer A produces a design that isamiable to the &quot;social process&quot; because of its modularity and approximationto the real world.andP;  In addition, it is possible to apply formal methods toassure its correctness which permits Developer A to combine developmentmethods from both worlds.andP;  Can Developer B make the same claim?andP;  Developer Bmay have derived a correct solution, but now that solution must be manuallytranslated to a programming language that may or may not be complimentarywith the specification language.andP;  The resulting program remains encryptedwith no modular structure and still hostile to the &quot;social process.&quot;andM;Overall, I agree with Gries that the software development process andcomputer science curriculum must encompass more rigor and preciseness.andP;  Afterreviewing Unix source code, I too realize that it is possible to encrypt aprogram without the aid of formal methods.andP;  I raise my objections to Gries inthe hope of bringing the worlds of formal and informal methods into asymbiotic relationship.andM;In closing, I would like to issue a challenge to Gries and comrades.andP;  If youdevelop a notation for formal methods that can be used as a communicationmedium in the real world, I will use the pacemaker that it specifies.andM;Michael Endrizzi 1210 West County Road E, Suite 100 Arden Hills, MN 55112andM;ResponseandM;First let me respond to Tim Berens's comment that my article reflects mybackground as a professor with a Ph.D.andP;  in mathematics, as opposed to hisbackground as a programmer writing many thousands of lines of code each year.andO;I received the impression that he thought a lack of &quot;real&quot; programmingexperience had colored my approach to programming.andP;  However, being aprofessor does not mean that one has been a professor all one's life.andP;  On myfirst full-time job, as a programmer.andP;  I programmed extensively in FORTRANand assembly language (1960-62).andP;  I was also a major player in the design andimplementation of the 7090 ALCOR-ILLINOIS compiler, one of the first fullAlgol 60 compilers, written completely in the assembly language of the IBM7090 (1962-64).andP;  I still have the flaw charts from that project.andP;  Myexperiences with &quot;real&quot; programming and later with trying to teachprogramming are what led me to study the programming task so intensely.andM;I applaud Berens's idea of private lessons for programmers, but it isunrealistic at this point because of the lack of enough professionalprogrammers qualified to give such lessons.andP;  To teach well requires knowledgeof principles and the ability to consciously apply them, and relatively fewprofessional programmers fit the bill.andM;Next, let me try to rectify some misconceptions that come through in theletters.andP;  First, I do not want to add much mathematics to the computerscience curriculum; I simply want to teach some of it better and in adifferent style.andP;  Many students already get a dose of logic, but they see itonly as an object of study and not as a tool.andP;  I proposed to convey the useof logic as a tool to be used in many places, including many (but not all)programming tasks.andP;  Also, the mathematics I want to instill is not veryadvanced.andP;  It calls only for skill in symbol manipulation, something that allprofessional programmers should be able to master.andP;  My experience is thatskill in the use of logic as a tool is a tremendous asset in several aspectsof programming.andP;  No one can honestly argue against this use of logic untilthey have mastered it and tried it themselves.andM;McCarthy argues that our courses should &quot;teach the thought processes thatgive .andP;  .  .  the tools to do software engineering right,&quot; that &quot;theory andapplications need to receive equal weight in the curriculum,&quot; and thatstudents should &quot;learn to apply judgement to the solution of a problem.&quot;andP;  Iagree wholeheartedly.andP;  In fact, this is basically the message that my paperwas trying to make.andM;Alan Fekete feels my proposal is pedagogically weak because students areinterested mainly in making working programs.andP;  &quot;Few students care about whytheir programs work,&quot; he says, &quot;and almost none have reached thephilosophical sophistication to worry about proving that they work.&quot;andP;  Theconclusion seems to be that we should not teach them about program proofs.andO;To me, that is a strange view.andP;  I feel that my duty is to persuade thestudents that they better care about why their programs work if they want toget the job done efficiently and effectively, that knowing how to proveprograms correct, or, better, how to develop program and proof hand-in-hand,makes the programming task easier.andP;  For me to do otherwise would beunconscionable.andM;A few weeks of a little theory can do wonders in helping students understandprograms, and it allows me later to present algorithms to students in a farmore effective and efficient manner.andP;  Further, in my junior-senior levelcourse on &quot;a science of programming,&quot; where we go into far more detail on theformal development of programs, many students have asked why we did not teachthe material to them as freshmen, instead of letting them rattle around withad hoc techniques.andP;  When the material is taught effectively, most studentsare quite happy with it.andM;I do agree with Fekete about discussing and comparing specifications, runningtimes, and the like, and if he has read any of my texts in the past he willknow that I cover these important considerations extensively.andP;  My articlecould not mention everything, and it concentrated on one new basic point, amore calculational use of logic.andP;  If he reads the paper again, with a moreopen mind, he will find that we probably agree more than he thought earlier.andM;To me, Dic Grune (from academia) and Thomas Clune (from industry) representthe huge problem our field faces:  teachers and managers standing in the wayof progress.andP;  Grune believes &quot;there is no adequate theory for programconstruction,&quot; presumably, as he mentions later, because the theory does notadequately address all &quot;real world limitations,&quot; like integer overflow.andP;  Thisis similar to refusing to use Newton's law of gravity because it does nottake into account the theory of relativity and perhaps as-yet-undiscoveredlaws of nature that might require a change in Newton's law.andP;  It is ludicrousnot to use a useful theory for what it is suited because it does not solveall problems.andM;Even if we manage to educate the Grunes of our field so that ourundergraduates can be educated, they will later suffer under managers likeClune.andP;  He seems to have a 1950's mentality, as evidenced by his statementthat &quot;ther is very little that recursion is good for.&quot;andP;  His remarks lead meto believe that he knows little about undergraduate computer scienceeducation in the highly ranked departments.andP;  I am sure it is mainly a matterof education, and I would love to be able to give him a few courses, becauseI believe I could change his mind on this issue.andP;  I do agree wholeheartedlywith Clune that computer scientists need a broad liberal education, withcourses in physics, chemistry, math, English, and the like.andP;  I was fortunateenough to have had such an education and I value that experience very much.andM;Like Clune, Michael Endrizzi suffers from a lack of exposure to foundationalideas and notations.andP;  He claims that, in my proper, I should have defined themultiple assignment and the notations wp and [P]S[Q].andP;  But the multipleassignment and these notations were introduced over 16 years ago, have beenused extensively ever since, and should have been taught to everyundergraduate computer science student in the past ten years.andP;  Our problem isthat they were not so taught.andP;  (I am sorry for the unconventional symbol for&quot;not.&quot;andP;  Then request by the ACM editor and me to use the conventional signwas ignored by the typesetter.)andM;In conclusion, I thank the letter writers for their remarks.andP;  To me, theywere enlightening.andP;  I saw that my paper did not get my point of view acrossas well as I had hoped, and for that I extend my apologies.andM;David Gries Cornell University Ithaca, NY 14850andM;ReferencesandM;andlsqb;1andrsqb; Waite, W.M., Goos, G. Compiler Construction.andP;  Springer-Verlag, New York,1984.andM;andlsqb;2andrsqb; Dijkstra, E., Scholten, C. Predicate Calculus and Program Semantics.andO;Springer Verlag, New York, 1990.andM;andlsqb;3andrsqb; Partsch, H. Specification and Transformation of Programs -- A FormalApproach to Software Development.andP;  Springer Verlag, Berlin, 1990.andO;</TEXT></DOC>