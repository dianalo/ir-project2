<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO> ZF32-042-109 </DOCNO><DOCID>11 407 115</DOCID><JOURNAL>Computer Language  Oct 1991 v8 n10 p44(7)* Full Text COPYRIGHT Miller Freeman Publications 1991.andM;</JOURNAL><TITLE>The journey of a thousand miles. (reusable object-oriented code)(Cover Story)</TITLE><AUTHOR>Lee, Elgin.andM;</AUTHOR><SUMMARY>Object-oriented programming (OOP) increases productivity throughthe reuse of code and provides a clearer and more easilymaintained program structure.andP;  Traditional programmers will findOOP requires a change in their approach to programming.andP;  The firststep is learning to identify objects, which will allow thedevelopment of programs with clarity and elegance.andP;  Allobject-oriented code is reusable to some degree; guidelines arepresented for writing reusable code.andP;  A first step is to examinethe classes in the code to see if any can be generalized.andP;  Large,complex classes may be difficult to generalize and will need to bebroken into subsets.andP;  New types of objects can be composed fromold ones.andM;</SUMMARY><DESCRIPT>Topic:     Programming LanguagesObject CodeObject-Oriented ProgrammingProgramming Instruction.andO;Feature:   illustrationchart.andO;Caption:   Initial class hierarchy for Array and LinkedList. (chart)Class hierarchy after generalization. (chart)Partial view hierarchy in Objectworks/Smalltalk. (chart)andM;</DESCRIPT><TEXT>Elgin LeeandM;By now, most software developers are acquainted with the many benefits ofobject-oriented programming.andP;  Foremost is increased productivity throughreuse and, for many types of problems, a clearer and more maintainableprogram structure.andM;Newcomers to object-oriented programming, however, quickly discover that theycannot fully realize the benefits without making major changes in the waythey approach programming-simply switching from a traditional to anobject-oriented programming language isn't enough.andP;  For programmers used totraditional programming methods, full understanding of the object-orientedapproach may initially be elusive.andP;  (For the tale of one person's firstobject-oriented program, see Jack W. Crenshaw's &quot;A Perfect Marriage,&quot; June1991.)andM;Understanding how to identify objects is the first passage programmers mustmake on their way to object-oriented paradise.andP;  Newcomers can expect tofumble around a bit before making the first &quot;Aha!&quot; of object-orientedprogramming: the realization that objects are active entities.andM;Alan Kay (of Xerox, Atari and Apple fame) has characterized traditionalprogramming as a puppetmaster approach to programming.andlsqb;1andrsqb; You, as thepuppet-master, identify the entities in your program (your puppets).andP;  In yourprogram, you are always present and in control.andP;  Your puppets may at timesdance together, but you are always there pulling the strings.andP;  Here, you pullthe string to make one puppet raise a graceful hand.andP;  There, you make anotherexecute a pirouette.andM;In object-oriented programming, you cut the strings and the puppets come tolife.andP;  When they dance, it's their dance, not yours.andP;  You may have taughtthem the steps, but it is they who are dancing.andP;  Your job as a programmer isto identify the entities in your problem's domain, their responsibilities,who they deal with, how they communicate, and then set them free to performtheir appointed tasks.andM;(For two useful articles on identifying objects, their responsibilities, andtheir patterns of communications, see Kent Beck and Ward Cunningham's &quot;ALaboratory for Teaching Object Oriented Thinking&quot; and Rebecca Wirfs-Brock andBrian Wilkerson's &quot;Object-Oriented Design: A Responsibility-Driven Approach,&quot;in the OOPSLA '89 Conference Proceedings, published as SIGPLAN NOTICES.andO;24andlsqb;10andrsqb;, Oct. 1989.)andM;Once you're able to identify the objects in your programs, you've made thefirst passage.andP;  Are you in object-oriented paradise yet? Well, no, notcompletely.andP;  All you've reached is the first sphere, which, admittedly, is apretty nice place.andP;  Your ability to identify objects lets you write programsof surpassing clarity and elegance.andP;  If you've mastered a substantial classlibrary, you're able to reuse code and be amazingly productive.andP;  But thesoftware you're writing is not necessarily reusable.andM;All object-oriented code is reusable to some extent.andP;  Your software heirs cansubclass your classes and override or extend them, but doing so may not beeasy if you haven't designed your software with reusability in mind.andM;Fortunately, entry into the second sphere of object-oriented paradise, thesphere of reusability, doesn't require the same sort of world-shatteringchange in perspective needed for the first.andP;  Designing for reuse does,however, require consideration of new issues.andP;  In general, reuse can occur atmany levels, for example knowledge acquisition, analysis, design, andimplementation.andP;  I will be focusing on issues of implementation reuse,including some guidelines on writing reusable object-oriented code.andM;David Bulman's &quot;Refining Candidate Objects&quot; (Jan.andP;  1991) also discusses thecreation of reusable objects.andP;  Bulman approaches the problem from a moreformal software engineering perspective and emphasizes choice of operationsand encapsulation of data.andP;  This article uses a more informal, heuristicapproach and emphasizes structural relationships among classes.andM;IS REUSABILITY WORTH IT?andM;How important is reusability for your software product? Making softwarereusable takes time and effort.andP;  For some products, that expenditure isclearly unwarranted.andM;If you're building an analysis prototype, for example, your task is toproduce the prototype quickly so you can move on to explore userrequirements.andP;  Although your productivity in building the prototype willdepend on the reusability of existing software artifacts, the design and codefor the prototype will be thrown away.andP;  Any time spent making the prototypesoftware reusable is time wasted.andP;  (See Adele Goldberg and Kenneth S. Rubin's&quot;Taming Object-Oriented Technology,&quot; Oct. 1990, for a high-level descriptionof object-oriented software projects, including the role of analysis anddesign prototypes.) At the other extreme, an application framework reused bymany people over a long period of time (a GUI architecture, for example)could dictate a large effort to improve reusability.andM;Between these extremes are normal applications-a spreadsheet, say, or amultimedia guide to Tibetan religious art.andP;  (The Asian Art Museum in SanFrancisco, Calif., contains just such an exhibit, controlled by softwareimplemented in Smalltalk-80.) This type of application may not appear to be agood candidate for reuse, but, in fact, opportunities for reuse abound.andP;  Thespreadsheet may contain a reusable table abstraction, while the multimediaguide may include a device-control framework for reusable devices other thanthe videodisk.andM;Finding generic parts of an application and making them reusable can bebeneficial not just to future applications but to future versions of the sameapplication.andP;  In the multimedia guide, generalizing the videodisk interfacemay enable later addition of frames from a CD-ROM or VCR.andM;GENERALIZATIONandM;Once you've determined that improving reusability is worthwhile, how do yougo about it? If the problem is well understood, you might be able to design areusable framework from the beginning.andP;  Often, however, designing for reusefollows the initial determination of object structure.andP;  In that case, yourfirst step would be to examine the classes in your code to see if any can begeneralized.andM;If you have conceptually similar classes that are unrelated in the classhierarchy, consider whether they might logically fit into a higher level ofabstraction.andP;  If they might, create a new class representing that abstractionand insert it as a common ancestor in the class hierarchy.andM;Consider the Array and Linked List classes in Objectworks\Smalltalk.andP;  If youwere to write such classes from scratch, you might build each one separately,as shown in Figure 1.andP;  Examining those classes more closely, however, you canbegin to see similarities.andP;  They each represent a sequence of objects thatyou can enumerate in Smalltalk using the do: message.andP;  You can ask Arrays andLinkedLists for the value of their nth element using the at: message and theindex of the first occurrence of a specified value using the indexOf: ifAbsent: message.andP;  If you consider those similarities, you might observe thatArrays and LinkedLists can be characterized by a higher-level &quot;sequenceablecollection&quot; abstraction, which you could add as a common superclass holdingthe common protocol, shown in Figure 2.andM;Such a common superclass serves a number of purposes.andP;  First, it defines thecommon protocol its subclasses are expected to understand.andP;  If you write codeusing the message protocol of Sequenceable Collection, the code will operateequally well on Arrays and Linked Lists.andP;  Second, it allows increased sharingof code and therefore better maintainability.andP;  The definition ofindexOf:ifAbsent:andM;indexOf: anElement ifAbsent:andM;exceptionBlockandM;1 to: self sizeandM;do: [:i | (self at: i) =andM;anElement ifTrue: [^i]].andM;^exceptionBlock valueandM;is identical for Arrays and Linked Lists.andP;  You can move that piece of codeinto SequenceableCollection and remove the individual implementations inArray and LinkedList, as shown in Figure 3.andP;  Any further code you write forSequenceableCollection, whether an implementation of new protocol or amodification to old code, is automatically inherited by Array and LinkedList.andM;Some messages may be defined in a common ancestor but not be suitable forimplementation there.andP;  In the previous example, the do: message should bedefined in SequenceableCollection because it is common protocol for Array andLinkedList.andP;  But its implementation depends on a representation choiceSequenceableCollection can't make.andP;  Because SequenceableCollection doesn'tmake any choice in representation, it cannot be instantiated and, thus,becomes an abstract superclass.andM;An abstract superclass defines message protocol and holds genericimplementations for concrete subclasses (subclasses that can have realinstances).andP;  New concrete subclasses need only provide implementations forthe subclass-responsibility messages in the abstract superclass;implementations of other common messages are inherited.andM;You can generalize messages as well as classes.andP;  If similar classes definemessages that are almost, but not quite, semantically identical, may bebetter off devising a more general message and rewriting your code to use it.andO;Besides increasing the opportunity to share code, you can decrease the numberof messages people reusing your code must master.andM;The process of generalization can be repeated as often as necessary.andP;  Figure4 shows the portion of the actual Objectworks\Smalltalk class hierarchycontaining Array and LinkedList.andM;Danger lurks, however, and its name is premature generalization.andP;  Likeoptimization, generalization can be detrimental if performed too early andwith too little experience in use.andP;  The problem is that ostensibly generalcode and protocol may turn out to be not so general after all.andP;  At best, insuch a case, all the effort spent in generalization will be wasted.andP;  Atworst, the generalization effort may prematurely bind the code to anunsuitable architecture, complicating the present code and making the task ofreusing or extending the software much harder in the future.andP;  Beware ofgeneralization without more than one example of actual reuse to demonstrateits applicability.andM;DECOMPOSITIONandM;A large and complex class may indicate insufficient generalization.andP;  Forexample, Figure 5 shows the View class in Smalltalk-80 v. 2.5, which combinesviewport semantics (translation and transformation), view composition(subviews), inclusion in a display hierarchy (superview), bordering, anddependence on a model.andP;  The monolithic, omnibus nature of such a classreduces its suitability for reuse.andM;If you want some subset of the features (say, a leaf view or a view without aborder) you must either use the omnibus class, ignoring all the unwantedfeatures, or make a subclass, taking care to &quot;underride&quot; all the unwantedinherited protocol.andP;  If you wish to create some other type of object thatshares only one feature of the omnibus class, you must either copy code orrefactor the class hierarchy for greater generality.andM;In contrast, Objectworks\Small talk 4.0 decomposes View functionality intomultiple classes, as shown in Figure 6.andP;  Such a decomposition increasesflexibility and reusability.andP;  If you wish to create an input-only leaf viewwithout a border, use View directly.andP;  To define a displayable leaf view, makea subclass of View.andM;A view with translated, bounded text subviews can be constructed by combininga CompositePart, BoundedwIrappers, and TextViews, as shown in Figure 7.andP;  Inthe Objectworks\Smalltalk framework, wrappers modify and forward messages totheir wrapped objects.andP;  A TranslatingWrapper, for example, translates allcoordinates before forwarding messages to the wrapped object.andP;  ABoundedWrapper specifies clipping before forwarding display messages.andM;Breaking a single large class down into smaller, single-function classes isanalogous to the UNIX tool approach.andP;  Instead of providing a few large,omnibus tools, UNIX provides many small tools that can be combined in analmost endless variety.andP;  In both cases, improved reusability is the result.andM;COMPOSITIONandM;As the View example shows, forming new types of objects by composition of oldones can sometimes be preferable to creating new classes.andP;  For example, atranslating, bounded composite view can be better formed by combining aComposite-Part with BoundedWrappers than by creating a BoundedCompositeViewclass.andM;Why is composition better in such cases? A small number of composable classescan express the same variety of entities as a large number of noncomposableclasses.andP;  As an exaggerated example, you can either master (or write) fivecomposable classes and a composition rule or [2.sup.5andrsqb; -1 andequals; 31 differentnoncomposable classes.andP;  The use of composition reduces the number of classesto learn (or write) and the complexity of the class hierarchy.andM;The use of composition can also improve the class structure by emphasizingthe distinctness of logically orthogonal concepts.andP;  The Smalltalk-80 2.5 Viewclass, for example, combines five different concepts.andP;  Because concepts aremixed without encapsulation boundaries in a single class, interdependenciesare liable to creep into the code, making it less clear and harder to modifyand reuse.andP;  Separating those concepts into distinct classes distills them,and their interdependencies are limited to a small and precisely describedset of messages.andM;Some caveats apply, of course.andP;  Composition replaces an instance of a singleclass with a network of objects.andP;  Although the monolithic-class approachsuffers from some disadvantages, it's easy to use once you've found theproper class.andP;  You simply instantiate it.andP;  The monolithic class explicitlydescribes the makeup of its instances.andP;  In the composition approach, on theother hand, the makeup of an object network is implicit in the compositionrules and composable classes.andP;  If you don't have a good understanding of thecomposition framework, you might have difficulty coming up with the exactnetwork of objects that you need.andM;If you're designing a composition framework, you can reduce that difficultyin a couple of ways.andP;  Providing thorough documentation of the compositionframework is essential.andP;  You can also implement convenience messages thatbuild and return common combinations.andM;In Smalltalk-80 2.5, binary-choice (yes or no) and fill-in-the-blank(prompter) dialogues are implemented by the classes BinaryChoice andFillinTheBlank.andM;Objectworks\Smalltalk 4.0 eliminates those classes and implements alldialogues using composition-but it provides convenience messages forconstructing binary-choice and fill-in-the-blank dialogues.andP;  Sending theconfirm: message to the DialogView class brings up a binary-choice dialogue.andO;Sending the request: message brings up a fill-in-the-blank dialogue.andP;  Theconvenience messages hide the details of the construction, making thedialogues easier to use.andP;  Also, simple code that only uses conveniencemessages is protected from any changes you make to the framework.andM;Composition isn't always the best approach.andP;  A tradeoff exists between theflexibility afforded by decomposition and the simplicity of a singlemonolithic class.andP;  As Figures 5 and 6 show, the Smalltalk-80 2.5 viewhierarchy is much simpler than the Objectworks\Smalltalk 4.0: the singleclass View is the only one you need to know.andP;  It's great, as long as it doeswhat you want.andP;  As soon as you need to do something more sophisticated,however, its limitations become maddeningly apparent.andP;  But if thoselimitations never arise in practice, the monolithic approach might be thebetter choice.andM;THE END OF THE ROAD?andM;With these guidelines (and Bulman's more formal methodology) in mind, youshould now be able to do more than just write impeccably object-orientedsoftware.andP;  When conditions warrant, you can transform your softwarearchitecture into one that is eminently reusable as well.andP;  You've entered thesecond sphere.andM;Are you in object-oriented paradise yet? Perhaps not.andP;  If Dante was correct,you'll need to pass through seven more spheres before reaching the ultimateobject-oriented paradise.andP;  But you'll have to find another guide to lead you.andM;ReferenceandM;1.andP;  Kay, Alan.andP;  &quot;Inventing theandM;Future,&quot; in Patrick H. Winston andandM;Karen A. Prendergast (eds.) The AIandM;Business.andP;  Cambridge, Mass.: TheandM;MIT Press, 1984.andM;Elgin Lee is a computer scientist withandM;ParcPlace Systems in Palo Alto, Calif.andO;</TEXT></DOC>