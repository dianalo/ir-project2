<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF109-514-527  </DOCNO><DOCID>09 514 527.andM;</DOCID><JOURNAL>IBM Systems Journal  Sept 1990 v29 n3 p408(13)* Full Text COPYRIGHT International Business Machines Corp. 1990.andM;</JOURNAL><TITLE>Personal systems image application architecture: lessons learnedfrom the ImagEdit program. (technical)</TITLE><AUTHOR>Ryman, A.andM;</AUTHOR><SUMMARY>Image applications require complex processing on large amounts ofdata.andP;  The application designer is presented with difficultchallenges that are exacerbated on personal systems which havelimited processor speed and constrained memory.andP;  This paperdiscusses the problems relevant to personal systems imageapplication architecture and how these problems were solved in theImagEdit program.andP;  A virtual array manager (VAM) consisting of avirtual memory manager (VMM) and an access scheduler was used tosolve the data management problem.andP;  The VAM divided each imageinto segments and transferred them to the VMM for storage.andP;  Thesesegments were swapped between memory and disk in response to asequence of access requests, controlled by the access schedulerusing performance-maximizing heuristics.andP;  Object-oriented designwas used to address the functional complexity problem.andP;  Theprocessing functions were divided into two classes.andP;  Thedata-stream class included scanning, printing, and filing, witheach data-stream function decomposed into a series ofdemand-driven pipe objects.andP;  The editing class included cut andpaste, textual and graphical annotation, and freehand drawing.andO;(Reprinted by permission of the publisher.)andM;</SUMMARY><DESCRIPT>Company:   International Business Machines Corp. (products).andO;Ticker:    IBM.andO;Product:   ImagEdit (Computer program) (usage).andO;Topic:     Image ProcessingEditingWorkstationsUser Interface.andO;Feature:   illustrationphotographchart.andO;Caption:   Virtual array manager. (chart)ImagEdit V2.0 class hierarchy. (chart)ImagEdit V2.0 toolbox. (chart)andM;</DESCRIPT><TEXT>Personal systems image application architecture: Lessons learned from theImagEdit programandM;This paper discusses software design issues that pertain to personal systemsimage applications.andP;  The first section defines the category of imageapplications that can be controlled effectively by current hardware anddescribes the main problems faced by software designers in creating efficientand functional applications in this domain.andP;  The next section describes theimage types under consideration and breaks down their processing intohigh-level and low-level functions.andP;  The virtual array manager, which is themain architectural component, is then discussed.andP;  The final section describesthe means by which object-oriented design (OOD) can be used as a guidingprinciple to organize the diverse collection of image processing functions.andM;Image applications on personal systemsandM;The discussion is based on experience gained from developing the ImagEdit[R]program, a personal computer image editing application, at the Image SystemsCentre, IBM Canada Laboratory.andP;  Frequent references are made to thatexperience for purposes of illustration.andP;  ImagEdit V1.0 was designed foroffice applications and was shipped in 1987.andP;  ImagEdit V2.0 includedenhancements to support desktop publishing and was shipped in 1988.andP;  The userinterface of ImagEdit V2.0 is illustrated in Figure 1.andM;Characteristics.andP;  For purposes of this paper, personal systems imageapplications are those that have general-purpose personal computer hardware,medium image size, and low transaction rate.andM;General-purpose personal computer hardware.andP;  Systems that havegeneral-purpose hardware can integrate the image application with otherfunctions, so that the user has a multitask workstation.andP;  Special-purposeimage peripheral equipment, such as scanners and video cameras, are includedif they allow the workstation to be used for (nonimage) purposes.andP;  The imageapplication should work adequately with standard displays and printers buttake advantage of any higher-resolution equipment that is available.andM;Medium image size.andP;  A medium image size is defined as approximately onemegabyte.andP;  Typical images in this range would be letter-size pages scanned inbilevel at up to 300 pixels per inch (ppi), or 8- by 10-inch photographsscanned as gray halftones up to 120 ppi.andP;  A bilevel image uses just twolevels, black or white, as in the display of line drawings.andP;  Halftone imagesdisplay various shades of gray, as in a photo of a person's face.andP;  From asoftware design point of view, the most important thing about the medium-sizerange is that it requires more bytes than the amount of available memory, andless storage than the amount of available disk space.andM;Low transaction rate.andP;  The expected transaction rate, meaning capturing,viewing, or editing, is under 10 images per hour.andP;  Although the system may becapable of higher rates, the user is probably performing an unstructured taskunder these circumstances, and so is not pushing the hardware to its limit.andM;Examples.andP;  Some typical examples of personal systems image applicationsinclude office applications, desktop publishing, and low-end technicalrecords handling.andM;Office applicaitons include image notes and composite documents.andP;  Imagenotes, which are widely used in Japan, give users the ability to send andreceive bilevel images from their desktops as if they had a personalfacsimile (FAX) machine.andP;  A composite document contains a combination ofscanned images with computer-coded word processing documents.andP;  ImagEdit V1.0was designed to address this domain, using IBM's Mixed Object DocumentContent Architecture [1] (MO:DCA) as the carrier data stream for both notesand composite documents.andM;Desktop publishing allows the user to lay out text, images, and graphics innewsletters, brochures, and other common in-house publications.andP;  Here, bothbilevel and halftone images are used.andP;  Line drawings are scanned as bilevelimages, photographs as halftone images.andP;  The resulting images have to bemodified in size and edited before inclusion in a pulbication.andP;  ImagEdit V2.0was designed for this application domain, using as data streams IBM's ImageObject Content Architecture [2] (IOCA) and the industry standards of TagImage File Format [3] (TIFF) and Encapsulated PostScript[R] Format [4](EPSF).andP;  While IOCA and TIFF are used for document interchange, EPSF is usedonly for exporting documents; its greater complexity requires a PostScriptinterpreter (typically a dedicated processor in a printer).andM;Technical records handling is potentially a new application area.andO;Engineering drawings are typically scanned as bilevel images at 200 ppi; thusA-size (8 1/2- by 11-inch) and B-size (11- by 17-inch) drawings fall withinour definition of medium-size images.andM;Software design challenges.andP;  The job of any software designer is to createapplications that provide timely, usable, and cost-effective solutions toproblems.andP;  Some of the challenges faced are especially acute when designingimage applications for personal systems.andP;  They include large amounts of data,complex processing functions, evolving industry standards, new applications,and the technical constraints of personal computers.andP;  These are discussedbelow.andM;Large amounts of data.andP;  The most obvious challenge is to efficiently managethe large amount of data contained by images.andP;  Not only does a single imagecontain a great deal of data, but many applications require several images tobe in use at the same time.andP;  (For example, editing may involve cut-and-pasteoperations between images.)andP;  This challenge will increase in severity as newtechnologies, such as color scanning and color printing, become commonplace.andM;Complexity of processing functions.andP;  Image processing is functionallycomplex.andP;  A typical application must support capture, display, and print fora range of peripheral equipment, as well as build and parse a variety of datastreams--each with its own compression and decompression algorithms.andP;  Therange of possible editing functions is even more extensive (these aredescribed later).andP;  Organizing this complexity into a coherent software designis a difficult challenge.andM;Evolving industry standards.andP;  Image applications are relatively new, andstandards are still evolving.andP;  For example, there is no standard method forcompressing gray images, and image interchange formats are also in a state offlux.andP;  Consequently, designers must be prepared to plan for change.andM;New application domains.andP;  As new technologies become available, more power isput on the desktop and new application domains are made possible.andP;  Thechallenge is to design an application for reuse, so that new opportunitiescan be realized in a timely fashion.andM;Memory and speed constraints of personal computers.andP;  Even as personalcomputers become more powerful, memory and speed constraints remain majorobstacles.andP;  This is because with more power come more demands and more layersof system software between the application and the hardware.andP;  Applicationswill continue to compete with each other and the operating system forresources.andP;  Careful attention to efficient application design is stillrequired.andM;Functional specificationsandM;This section describes the type of images under consideration and breaks downtheir processing into high-level and low-level functions.andM;Image types.andP;  Images can be described by the characteristics of pixel depth,resolution, and extent.andM;Pixel depth is defined as the number of bits assigned to each pixel.andP;  Twodepths, namely 1 and 8 bits per pixel are used.andP;  Line art and text arenormally captured at 1 bit per pixel, giving two colors (usually black andwhite).andP;  Photographs and video images are normally captured at 8 bits perpixel, giving 256 shades of gray.andP;  (Although the capture and display hardwareis usually only accurate to 6 or 7 bits, 8 bits are stored to simplifyprocessing.)andM;Resolution assigns a physical size to the pixels.andP;  The upper end of theresolution range, which is attained by some phototypesetters, is 2540 ppi.andO;The lower end of the range is set to be 100 times smaller than this, namely25 ppi.andP;  Typical bilevel resolutions are 200 ppi for FAX, 240 ppi for officeprinters, 300 ppi for desktop publishing, and 1270 or 2450 ppi forphototypesetters.andP;  Common gray resolutions are 60 ppi for desktop publishing,and 100 or 120 ppi for phototypesetters.andM;The extent of an image is the number of pixels along each dimension.andP;  Extentsare typically on the order of 1000 pixels.andP;  Although an image could consistof a single pixel, a useful minimum extent is 8 X 8 pixels.andP;  This size ishandy for defining repeating patterns used to fill areas.andP;  Other usefulexamples of small images are 16 X 16 cursors, and 32 X 32 icons.andP;  Imageshaving such small extents are usually handled by special-purpose applicationssuch as icon editors.andP;  A convenient upper limit for extents is 5100 pixels;this value was chosen to accommodate a bilevel tabloid image (17 inches wide)at 300 ppi.andM;The choice of a maximum extent influences the design of an application in twoways.andP;  First, some compression and decompression algorithms allocate workingbuffers whose size depends on an image's horizontal extent: the wider theimage, the more temporary storage is required for compression ordecompression.andP;  Second, the data storage scheme may assume that all pixels inthe same row are stored together.andP;  The storage unit size therefore limits thehorizontal extent.andM;High-level function.andP;  Most image applications will include some combinationof high-level functions, named file, scan, print, view, and edit.andP;  Each isdescribed in a subsequent paragraph.andM;File.andP;  Filing consists of moving images between the temporary working storageused by the application, and the permanent storage of a file system.andP;  Severalfile formats exist to ensure that applications can interchange images.andP;  Atypical file format contains the image data and descriptive information aboutit such as pixel depth, resolution, and extent.andP;  As an option, the image datamay be compressed to reduce storage requirements.andM;IBM office applications use IOCA, while industry applications in the desktoppublishing domain (such as Aldus PageMaker[R] and IBM InterLeaf[TM]) of useTIFF.andP;  Both these formats are easily interpreted by applications and maintainthe image in a form that can be readily edited.andP;  EPSF is used as an imageinterchange format when the image is in final form, such as when it isintended to be sent to a printer or display.andP;  An EPSF file may contain textand graphics in addition to images.andM;Filing may also involve a number of image conversions.andP;  An image in oneformat may be saved in another; or the pixel depth, resolution, extent, andcompression may be changed when the image is saved.andM;Scan.andP;  Scanning consists of capturing an image from an external source.andO;Scanning hardward includes video digitizers and flatbed and feed-throughdocument scanners.andP;  A workstation may have more than one scanning device; forexample, creating a parts catalog may require a video camera for capturingactual parts, and a scanner for capturing photographs of parts.andP;  The usermust be able to select the source device.andM;The user must also be able to control a number of parameters that govern thecapture.andP;  For example, with the IBM 3119 PageScanner[TM] one can specify thepixel depth, resolution, extent, gray response curve, enhancement, andhalftoning.andP;  The gray response curve permits compensation for courcedocuments that are too dark or too light.andP;  Enhancement can bring out detail(sharpen) or eliminate noise (smooth).andP;  Halftoning affects the way a bilevedimage is created: the user can specify thresholding or a dither matrix.andM;Print.andP;  Printing provides a hard copy of the image.andP;  The user can specify theportion of the image to be printed, the number of copies, and how the imageis scaled to fit the paper.andP;  Most printers can actually only print black andwhite; they simulate shades of gray by halftoning.andM;The majority of office printers offer a simple interface for printing images.andO;The image is sent as raster data, which require the application to convertthe resolution and pixel depth of the image to match that of the printer.andP;  Incontrast, desktop publishing printers usually offer a high-functioninterface.andP;  For example, the PostScript processor transfers an imagedevice-independent form; the printer microprocessor converts the pixel depthand resolution.andP;  This has the advantage that a document can be proofed on alow resolution printer and then printed as camera-ready copy on a highresolution printer without losing image quality.andM;View.andP;  Viewing lets the user see all or portions of the image at variousmagnifications.andP;  It must be possible to move to the area of interest (scroll)and select the desired magnification (zoom), or see several images at once.andM;Scrolling can be handled in a number of ways.andP;  ImagEdit V2.0 offers three:scroll bar controls, a grabber tool, and an overview window.andP;  Scroll barcontrols are standard in most window managers.andP;  Here, two bars are placedalong a vertical and a horizontal edge of the image window, and the relativeposition of the window over the image is indicated by movable boxes in thebars.andP;  The image can be moved horizontally or vertically by dragging one ofthese scroll boxes.andP;  The grabber tool lets the user reposition any visiblepart of the image within the window by simply dragging the part to where itis wanted.andP;  (This is an example of direct manipulation in user interfacedesign.)andP;  The overview window displays a reduced view of the image.andP;  Here,the user can center the image window over any point in the image by clickingthe mouse on the corresponding point in the overview window.andM;Zooming is controlled by menu commands.andP;  (Most of these have keyboardshortcuts.)andP;  High magnification views are useful for detailed pixel editing,while low magnification views are useful for large-scale cut-and-pasteediting.andM;Several images can be viewed at once.andP;  ImagEdit V1.0 directly supportsmultiple image windows, while ImagEdit V2.0 uses the multitaskingcapabilities of the Microsoft Windows[R] [5] operating environment.andM;Edit.andP;  Editing is the most complex application area.andP;  Editing operations canbe classified as either annotation or block operations.andP;  Annotation isassociated with the change and entry of data.andP;  This includes text, graphics,and freehand.andP;  Block operations are associated with the manipulation ofportions of pages or images.andM;Text annotation allows paragraphs to be overlaid on the image, which isuseful for labeling diagrams.andP;  The user can select the font, size, leading,alignment, color, and transparency of the text.andM;Graphical annotation is useful for diagramming.andP;  The user can draw lines,polylines, rectangles, ellipses, rounded rectangles, and polygons; haveclosed shapes either filled or outlined; and select line color, width, andstyle, and fill color.andM;Freehand editing consists of drawing, painting, and erasing.andP;  Drawing is donewith a pencil tool that creates a stroke one pixel in width.andP;  Painting isdone with a paintbrush tool.andP;  The user can specify the shape and size of thebrush tip, as well as the paint color.andP;  Erasing is the same as paintingexcept that the paint color is only black or white.andP;  The eraser normallypaints white.andP;  This can be changed to black via a menu command.andM;Block operations include the following operations: cut, copy, paste, clear,duplicate, reverse color, gray response curve, flip, rotate, position, andsize.andP;  Most block operations can be applied to the entire image, to aselected portion of it, or to a clipping.andM;Cut, copy, and paste functions are handled through a standard temporarystorage area called the clipboard, which is maintained by the window manager.andO;The user selects a rectangular area and can clear (erase) it, or cut or copyit to the clipboard.andP;  (Cutting is a combination of copying and clearing.)andO;The contents of the clipboard can then be pasted anywhere on the image, ormoved between applications.andP;  The user controls how the pasted clippingcombines with the image to produce a variety of special effects.andP;  Images withnonrectangular outlines can be handled in this way.andM;With color reversal, the user can interchange the color of every selectedpixel, reversing black and white or dark gray and light gray.andP;  Using the grayresponse curve, every pixel can also be mapped to a new color.andM;A selection can be rotated by any multiple of 90[degrees] or flipped along ahorizontal, vertical, or diagonal axis.andP;  It can also be positioned and sizedanywhere over the image.andP;  The user controls target position and sizenumerically or interactively and can also control how the clipping isconverted prior to pasting.andP;  This may involve smoothing if the resolutionneeds to be changed, or halftoning if a gray image is pasted on a bilevelimage.andM;All high-level functions described above are built up from combinations oflow-level functions.andP;  These are described below.andM;Low-level functions.andP;  The low-level functions are the basic building blocksused to create, modify, and specify new high-level functions.andM;Building and parsing data streams.andP;  Image data are interchanged in standardformats, which contain the data along with descriptive information about theimage such as resolution, extent, and pixel depth.andP;  The image data may beoptionally compressed to reduce storage requirements.andP;  ImagEdit V2.0 supportsthe formats IOCA, TIFF, and EPSF.andP;  These formats are mainly used tointerchange image files between applications, but may also be used totransmit images from scanners to applications, and from applications toprinters.andM;Compression and decompression.andP;  Image interchange formats often support avariety of compression algorithms, especially for bilevel images.andP;  ImagEditV2.0 supports Modified Modified READ (MMR) in IOCA and Modified Huffman (MH)in TIFF.andP;  (Gray compression standards are currently being defined.)andM;Magnification and reduction.andP;  The resolution and extent of images are oftenchanged in viewing, printing, and editing.andP;  The fastest techniques for doingthis are pixel replication for magnification, and pixel skipping forreduction.andP;  However, while these techniques are usually adequate for viewing,they may not be satisfactory for editing or printing since they can createartifacts in the images--replication may cause staircasing (also referred toas &quot;jaggies&quot;) on diagonal lines, while skipping may cause thin lines todisappear.andP;  Thus, when image quality is critical, pixel interpolation is usedfor magnification and pixel averaging for reduction.andM;Rotations and flips.andP;  The rotation and flip functions are mainly used inediting, but are also useful for viewing and printing images with landscapeorientation.andP;  ImagEdit V2.0 supports rotations by right angles and flipsalong vertical, horizontal, and diagonal axes.andP;  Rotation by small angles inuseful for correction of images that are scanned slightly out of alignment,while rotation by general angles is useful for advanced editing.andM;Text, image, and graphics annotation.andP;  Annotation functions are normallyprovided by an operating environment kernel such as the Microsoft WindowsGraphical Device Interface.andP;  In practice, these kernels are not tuned forhandling large images, so the application typically has to divide editingtasks into small pieces.andP;  Also, the general-purpose image magnification andreduction algorithms may lack the necessary performance, and may requirereplacement by application-supplied routines.andP;  This is a symptom of therelative newness of the image as a data type.andP;  We can expect future operatingenvironment graphical kernels, such as the OS/2[R] Graphics ProgrammingInterface, to provide much higher image function.andM;Halftoning and anti-aliasing.andP;  Halftoning changes gray images to bilevedimages, while anti-aliasing is a technique for preserving image quality underreduction by converting a high-resolution bilevel image into a low-resolutiongray one.andP;  These operations are used for viewing and displaying gray imageson bileved devices, and for combining images with different pixel depths whenediting.andM;Intensity mapping.andP;  Intensity mapping is a useful technique for enhancinggray images.andP;  It can be used to bring out detail in poorly expoedphotographs.andP;  ImagEdit V2.0 supports it in scanning, editing, and printing.andM;Digital filtering.andP;  Digital filtering is another flexible image enhancementtechnique.andP;  For example, graininess or noise can be removed with a smoothingfilter, while blurriness can be removed with a sharpening filter.andP;  ImagEditV2.0 only supports digital filtering when scanning.andM;The virtual array managerandM;As stated previously, one of the main chalenges in the design of imageapplications is to efficiently manage large amounts of data within a smallamount of memory.andP;  This section describes the main architectural componentfor achieving this, the virtual array manager (VAM).andM;Virtual arrays.andP;  Image data may be regarded as defining a two-dimensionalarray of pixel values.andP;  These values may be packed eight to a byte forbilevel images, or one to a byte for gray images.andP;  The arrays are typicallylarge, and the application may require access to several arrayssimultaneously.andP;  Therefore, when the data requirements of the images arecombined with the code requirements of the application, the operatingenvironment, and other resident applications, the designer must make adecision whether or not to support configurations in which all the image datacannot be stored in memory.andM;For personal systems image applications, it is normally a requirement tosupport small memory configurations.andP;  This means that the application mustsupport a disk-based array management architecture.andP;  We refer to disk-basedarrays as virtual arrays since they make use of the same concepts asoperating system (OS) virtual memory.andP;  [6]  However, some of these conceptsneed to be altered in order to achieve peak performance.andP;  This will bediscussed in more detail below.andM;Image segmentation.andP;  The VAM is responsible for dividing an image intosegments.andP;  The general method for doing this is two-dimensional tiling.andP;  Itis also appropriate for handling images that are already tiled, such as largetechnical drawings.andP;  Tiling is very efficient for random access operationssuch as viewing, editing, and especially rotations, and this method was usedin ImagEdit V1.0.andP;  However, there is significant processing overhead whenopening or saving an image that is not already tiled.andP;  For this reason, alimiting form of tiling called banding was used in ImagEdit V2.0.andP;  In thismethod the tiles are full width, which improves essentially sequentialoperations such as opening and saving.andP;  It reduces the performance of viewingand editing slightly, and that of rotations to a greater extent.andP;  Tiling andbanding are illustrated in Figure 2.andM;The virtual memory manager.andP;  The VAM passes image segments to the virtualmemory manager (VMM) for storage.andP;  The VMM swaps segments between a region ofmemory called the cache, and a disk file called the spill file in response toaccess requests.andP;  This architecture is illustrated in Figure 3.andP;  When theapplication performs an operation on a virtual array, the VAM must determinewhich segments are involved and schedule access to these segments.andP;  Thisalgorithm can greatly affect performance.andM;If the cache is large, the segments stay in memory and the operations run atfull speed.andP;  Both ImagEdit V1.0 and V2.0 let the user increase the cache sizeby installing expanded memory.andP;  When the cache becomes full, segments and beswapped from memory to disk to make room for new segments.andP;  In thissituation, performance depends on disk access speed.andM;The VMM is based on the same concepts as OS virtual memory management.andP;  Imagesegments correspond to memory pages, the cache corresponds to real memory,and the spill file corresponds to virtual memory.andP;  The strategy used tocontrol swapping between real and virtual memory affects system performance.andO;The goal here is to minimize the average number of swaps required to performtypical image processing operations.andM;In OS virtual memory, swapping between real and virtual memory is usuallycontrolled by the least recently used (LRU) algorithm.andP;  When a page has to beswapped from real to virtual memory, the least recently used page isselected.andP;  This means that the most recently used pages are preferentiallyretained in real memory.andP;  This algorithm assumes locality of reference.andO;Roughly, this means that the probability that a page will be accessed isproportional to how recently it has been accessed.andP;  This often makes sense.andO;For example, in code, statements in a loop are repeatedly accessed.andP;  However,it often does not make sense for image processing.andM;In image processing, the assumption of locality of reference is oftenviolated.andP;  In some operations, every pixel in the entire image is accessedprecisely once.andP;  For example, consider the operation for displaying an entireimage.andP;  In this case, the most recently used pixel is the least likely to beaccessed next.andP;  If the entire image is too large to fit in real memory, theLRU algorithm segment must be swapped each that every image segment must beswapped each time the operation is performed.andP;  In fact, using the LRUalgorithm leads to worse performance than a disk-based array managementscheme that has no cache, since the memory devoted to the cache isunavailable for usefully storing code or data.andM;Access scheduling.andP;  There is a better swapping algorithm than LRU, one thatschedules swapping based on access requests.andP;  We refer to this as theModified LRU (MLRU) algorithm.andP;  (This technique is sometimes also calledclairvoyant caching because the access scheduler is given information aboutwhat will happen in the future.)andP;  In this approach, the application makesaccess requests to the VAM that specify a region of a virtural array andwhether it will be read or written.andP;  The VAM maintains information about thecontents of the cache, including how recently the segments have beenaccessed, whether they have been modified since the last time they wereswapped out to the spill file, and whether or not they are involved in anypending read or write access requests.andM;After the application notifies the VAM that it is about to make a request, itcan ask it to recommend which segment in a given list is the best to processnext.andP;  The VAM uses its knowledge of the cache contents to select the bestsegment.andP;  For example, segments currently in the cache are given the highestpreference, and of these, modified segments are given preference tounmodified ones.andP;  In general, the VAM assigns a heuristic &quot;cost&quot; to eachelement in the list and recommends the cheapest one.andP;  The cost isconceptually the expected cost to access the segment.andP;  The use of thisfeature improves the performance of random access operations (operations thatcan process the segments in any order).andP;  For example, annotation is a randomaccess operation since each segment can be annotated independently.andP;  Otheroperations, such as writing an image to a disk file, require sequentialaccess, and so cannot alter the order in which they process the segments.andM;If the application requests access to a segment that is not in the cache, theVAM must swap it in from the spill file.andP;  If the cache is full, it first mustselect a segment to swap out.andP;  The VAM also maintains a heuristic cost forswapping out segments, and again selects the cheapest one.andP;  For example,segments involved in pending operations are preferentially retained in thecache.andM;The main difference between the VAM and os virtual memory is that the VAM isnot transparent to the application, whereas the os is.andP;  This means thatapplications must be written to explicitly take advantage of VAM features.andO;However, this may be a necessary price to pay if performance is a criticalrequirement.andP;  Using an LRU-based os virtual memory will lead to diskthrashing in some circumstances; this can be avoided by using an MLRU-basedVAM.andM;Object-oriented designandM;While the VAM solves the data management problem, object-oriented design(OOD) solves that of functional complexity.andP;  This section describes theprinciples of OOD and how they were used in ImagEdit.andM;Dynamic binding and inheritance.andP;  Software design is mainly a process ofdecomposition.andP;  There are several principles that guide the designer in thisprocess, of which OOD has recently been recognized as an important set.andP;  OODis based on the proven concepts of data abstraction, information hiding, andencapsulation, which are embodied in such conventional programming languagesas Ada, and extends these with two additional concepts: dynamic binding andinheritance.andM;Dynamic binding and inheritance are generalizations of programming techniquesthat are often used in the design of operating systems.andP;  The followingdiscussion illustrates these concepts by casting an example that should befamiliar to readers with a programming background, namely that of filesystems, into the language of OOD.andP;  Later it will be shown how OOD can beapplied to image processing.andM;Dynamic binding is a technique for improving the generality and reusabilityof code, by deferring to run-time the binding of functions to requests.andP;  Thisis implemented by linking functions to the data on which they act.andP;  Forexample, when an application program opens a file, the operating systemassigns an identifier to it.andP;  This identifier is sometimes called a filehandle, and all future references to the file are through its handle.andP;  Thehandle points to a device driver that implements requests to read, seek, andwrite.andP;  The actual device is transparent to the application.andP;  For example,the file could be stored on a floppy disk, or a virtual disk, but theapplication code is the same in all cases.andP;  If a new file device is added tothe computer, the application program will not have to be changed.andM;In the language of OOD, the file device drivers are called classes.andP;  When afile is opened, an object (i.e., the file handle) belonging to theappropriate class is created.andP;  The requests to read, seek, and write arecalled messages, and the functions that implement these request are calledmethods.andM;Inheritance is a technique for basing new classes on existing ones.andP;  Forexample, a file device driver to handle 1.44 MB diskettes might be based onone that handles 720 KB diskettes.andP;  The new class is said to inherit from itssuperclass.andP;  The inheritance relation defines a hierarchy on the classes.andO;The complete class inheritance hierarchy for ImagEdit V2.0 is illustrated inFigure 4, and is described in further detail below.andM;Object-oriented programming (OOP) languages, such as Smalltalk-80[TM], [7]C++[R], [8] and Objective-C[TM], [9], support dynamic binding andinheritance.andP;  Smalltalk-80 is a pure OOP language; here, all data items areobjects.andP;  This can lead to performance problems for some classes ofapplications.andP;  C++ and Objective-C are hybrid languages; they both addprogramming language support for objects to standard C, [10] and are usuallyimplemented by preprocessors that generate standard C.andP;  ImagEdit V2.0 isbased on the OOD model of Objective-C, but was coded directly in standard Cbecause appropriate language support was unavailable when developmentstarted.andM;Data-stream classes.andP;  Although images are conceptually two-dimensionalarrays, they can also be regarded as one-dimensional, by considering each rowas a one-dimensional stream of bytes and then stringing all the rowstogether.andP;  This is how images are stored in files and created by scanners.andM;The data-stream (DS) classes take this view of images, which lets many imageprocessing functions be decomposed as a sequence of pipes and filters in thesense of the UNIX[R] operating system.andP;  [11]  For example, consider theoperation of reading a compressed bilevel IOCA image from a disk file into avirtual array.andP;  Each pixel of image data passes through the followingsequence of processing functions:andM;1.andP;  Read the IOCA data stream from the disk file and parse it to extract thecompressed image data.andM;2.andP;  Decompress the image data.andM;3.andP;  Reverse the color of the image data, since bilevel compression algorithmsuse 1 for black and 0 for white, while displays use 0 for black and 1 forwhite.andM;4.andP;  Word-align each row of image data, since graphic kernels require rows tostart on word boundaries.andM;5.andP;  Write the image data into the virtual array.andM;Functions that generate a data stream as output are called sources, whilethose that consume one as input are called sinks.andP;  Functions that are bothsources and sinks are called filters.andP;  The communication channel for passinga data stream between functions is called a pipe.andP;  In the above example,reading the disk file is a source, writing the virtual array is a sink, andall the other functions are filters.andM;In UNIX, which is a multitasking operating system, each function could beimplemented as a separate program that reads from its input pipe and writesto its output pipe.andP;  The operating system would control the sequence ofexecution, giving each program a slice of processing time.andP;  Each program isable to execute write requests freely since these can be buffered by theoperating system.andP;  However, when a program makes a read request, itsexecution may get suspended if not enough input data are yet available.andM;This scheme gets modified when it is implemented by a single-taskingapplication.andP;  In this approach, the processing is organized as a sequence ofdemand-driven functions.andP;  Each source or filter becomes a class that cancreate a data-stream object, and the data-stream objects can only respond toread requests.andP;  The sink is implemented as a loop that repeatedly reads itsinput data stream and disposes of the data until the data stream isexhausted.andM;In ImagEdit V2.0, the above example would use the following data-streamclasses:andM;*DSImageFromIMDS--This class transforms an IOCA file into an image datastream that has the alignment and color interpretation expected by a virtualarray.andP;  It links together the required sequence of data-stream objects fromclasses that perform the elementary operations of parsing, decompression,comor reversal, and word alignment.andM;*DSDataFromIDMS--This class parses and extracts an image data stream from anIOCA file.andP;  The image data may be either bilevel or gray.andP;  They may requirefurther decompression, color reversal, and/or word-alignment.andM;* DSImageFromMMR--This class decompresses a bilevel MMR data stream.andM;* DSReverse--This class reverses the color of an image data stream.andM;* DSImageFromData--This class word-aligns an image data stream.andM;The remaining data-stream classes handle the following functions:andM;* Other image sources (TIFF files, scanners, virtual arrays)andM;* Other image sinks (IOCA, TIFF, and EPFS files)andM;* Scaling (replicate, skip, interpolate, average)andM;* Color conversion (bilevel to gray, halftoning)andM;Refer to Figure 4 for the complete set of data-stream classes in ImagEditV2.0.andM;Editing classes.andP;  Interactive image editing is implemented with two more orless parallel families of classes.andP;  Tool classes handle user interaction,while Edit classes represent the editing operations created by the tools.andO;The user selects a tool from a toolbox (see Figure 5), and uses it to createand edit operation.andP;  Edit classes describe actual edit operations; forexample, the paintbrush tool is used to draw a stroke.andP;  Here, the paintbrushis an object in the ToolPaintbrush class, while the stroke is an object inthe EditPaintbrush class.andP;  This application of OOD is well documented in theliterature [7,9] and is often used as an example to illustrate the benefitsof object-oriented design.andM;The main benefit of OOD here derives from dynamic binding, which allowsgeneral-purpose functions to be written for handling generic tools and editoperations.andP;  For example, several edit operations may be stored together in aqueue; then when the queue is drawn on the display, a draw message is sent toeach object in the queue.andP;  Similarly, the queue is used to control the &quot;Undo&quot;and &quot;Redo&quot; commands.andP;  The queue itself is independent of the type of objectsit contains.andP;  If new types of edit operations are added at a later point indevelopment, the queue management functions will not be affected.andP;  Thisfeature makes software more adaptable to changing requirements and alsoprovides a sound basis for decomposing the system into independentlyconstructible parts.andM;An additional benefit of OOD comes from inheritance: allowing similar classesto be based on common pieces of code.andP;  The result is less code and moreassured consistency of behavior.andP;  For example, consider the user interactionrequired to draw a rectangle and an ellipse.andP;  In both cases the user pressesthe mouse button down at one point, drags the mouse to another point, andreleases the button.andP;  The two points are used to define opposite corners of abox that is either the border of the rectangle or the bounding box of theellipse.andP;  This commonality of user interaction is reflected in the classhierarchy by making ToolRectangle the superclass of ToolEllipse.andP;  ToolEllipseinherits &quot;MouseButtonDown&quot; and &quot;MouseMove&quot; methods from ToolRectangle.andP;  Itoverrides the &quot;MouseButtonUp&quot; method by creating an EditEllipse objectinstead of an EditRectangle object.andP;  Similarly, ToolRoundRect (rectangleswith rounded corners) and ToolLine (straight lines) also inhrit fromToolRectangle.andP;  (Refer to Figure 4 for the complete set of Tool and Editclasses in ImagEdit V2.0.)andM;ConclusionandM;The move to operating systems with virtual memory, such as OS/2 and AIX[R],may solve data management problems in the short term.andP;  However, as captureand printing technology for new application domains (such as color andhigh-end technical records) becomes available, the limitations of LRU-basedmemory management may become apparent: disk thrashing will occur once imagesize becomes large enough.andP;  To overcome performance problems, eitheroperating systems must provide access scheduling functions, or applicationsmust implement their own virtual array managers.andM;Our experience with OOD has been positive.andP;  It appears to be a veryappropriate paradigm for decomposing functionally complex systems, and itshould scale well as applications become larger.andP;  The widely reportedbenefits of OOD were realized our use of it for interactive image editing.andO;In addition, the use of demand-driven pipe objects greatly simplifieddata-stream handling.andP;  Finally, we confirmed that the slight additionaloverhead incurred by dynamic binding had no measurable effect on systemperformance; memory management continued to be the most important issue.andM;Cited referencesandM;[1] Mixed Object Document Content Architecture, SC31-6802, IBM corporation;available through IBM branch offices.andM;[2] Y. Hakeda &quot;The Image Object Content Architecture,&quot; IBM Systems Journal29, No.andP;  3, 333-342 (1990, this issue).andM;[3] Tag Image File Format Specification Revision 5.0, Aldus/MicrosoftTechnical Memorandum, Aldus Corporation, Seattle, WA (1988).andM;[4] PostScript Language Reference Manual, Adobe Systems Incorporated,Addison-Wesley Publishing Co., Reading, MA (1986).andM;[5] Microsoft Windows Software Development Kit Version 2.0, MicrosoftCorporation, Redmond, WA (1987).andM;[6] Introduction to Virtual Storage in System/370, GR20-4260-1, IBMCorporation (1973); available through IBM branch offices.andM;[7] A. Goldberg and D. Robinson, Smalltalk-80: The Language and ItsImplementation, Addison-Wesley Publishing Co., Reading, MA (1983).andM;[8] B. Stroustrup, The C++ Programming Language, Addison-Wesley PublishingCo., Reading, MA (1986).andM;[9] B. J. Cox, Object-Oriented Programming: An Evolutionary Approach,Productivity Products International, Addison-Wesley Publishing Co., Reading,MA (1986).andM;[10] B. W. Kernigham and D. M. Ritchie, The Programming Language,Prentice-Hall Inc., Englewood Cliffs, NJ (1978).andM;[11] D. M. Ritchie and K. Thompson, &quot;The UNIX Time-Sharing System,&quot; The BellSystem Technical Journal 57, No.andP;  6, Part 2, 1905-1929 (July-August 1987).andM;General referencesandM;IBM ImagEdit Version 1.0 User's Guide, 6476113, IBM Corporation (1987);available from IBM branch offices.andM;IBM ImagEdith Version 2.0 User's Guide, 75X3255, IBM Corporation (1988);available from IBM branch offices.andM;R.M.andP;  Helms, &quot;Introduction to Image Technology,&quot; IBM Systems Journal 29, No.andO;3, 313-332 (1990, this issue).andM;Arthur G. Ryman IBM Canada Centre for Advanced Studies, 844 Don Mills Road,North York, Ontario, Canada M3C IV7.andP;  Dr. Ryman is currently the associatehead of the IBM Canada Centre for Advanced Studies where he is also theprincipal investigator of the Advanced Software Design Technology program.andO;He received a B.Sc.andP;  in physics from York University, Toronto, in 1972, anM.S.andP;  in mathematics from the University of London in 1973, and a Ph.D.andP;  inmathematics from Oxford University in 1975.andP;  After performing postdoctoralresearch in computational atomic and nuclear physics at York University inToronto, Memorial University in St. John's, and the University of Toronto, hebecame a mathematician at the W. P. Dobson Research Laboratory, OntarioHydro, in 1979.andP;  He joined the IBM Canada Laboratory, Toronto, in 1982, wherehe worked on office systems and image processing.andP;  His last developmentassignment was as the designer and manager of the ImagEdit program.andP;  Dr.andO;Ryman's current research interests are in the applications of logicprogramming and graphical visualization to systems software design.andP;  He is amember of the Institute of Electrical and Electronics Engineers and theAssociation for Computing Machinery.andO;</TEXT></DOC>