<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF109-452-467  </DOCNO><DOCID>09 452 467.andM;</DOCID><JOURNAL>Communications of the ACM  Sept 1990 v33 n9 p90(14)* Full Text COPYRIGHT Association for Computing Machinery 1990.andM;</JOURNAL><TITLE>Class management for software communities. (object-orientedprogramming techniques)</TITLE><AUTHOR>Gibbs, Simon; Tsichritzis, Dennis; Casais, Eduardo; Nierstrasz,Oscar; Pintado, Xavier.andM;</AUTHOR><SUMMARY>Successful dissemination and reuse of classes in object-orientedprogramming requires a well-organized community of softwaredevelopers ready to share concepts, tools and techniques.andP;  Such acommunity needs the support of software information systems thatmanage and provide access to class collections.andP;  Softwaredevelopment requires considerable creative and intellectualeffort, which makes it difficult to automate.andP;  Industrynevertheless still dreams of software 'factories' producinghigh-quality software cheaply and quickly.andP;  Object-orientedprogramming offers a paradigm promoting a method of developmentcalled cooperative large-scale reuse; this is described using ananalogy in which software development is compared to building andpresenting a legal case.andP;  Software information systems, classpackaging, class organization and class selection and explorationare discussed.andM;</SUMMARY><DESCRIPT>Topic:     Object-Oriented ProgrammingProgram Development TechniquesNew TechniqueModular ProgrammingSoftware EngineeringAutomationInformation Systems.andO;Feature:   illustrationchart.andO;Caption:   PIE network layers. (chart)Alternative views. (chart)C++ class relationships. (chart)andM;</DESCRIPT><NOTE>Only Text is presented here; see printed issues for graphics.andO;</NOTE><TEXT>CLASS MANAGEMENT FOR SOFTWARE COMMUNITIESandM;Object-oriented programming may engender an approach to software developmentcharacterized by the large-scale reuse of object classes.andP;  Large-scale reuseis the use of a class not just by its original developers, but by otherdevelopers who may be from other organizations, and may use the classes overa long period of time.andP;  Our hypothesis is that the successful disseminationand reuse of classes requires a well-organized community of developers whoare ready to share ideas, methods, tools and code.andP;  Furthermore, thesecommunities should be supported by software information systems which manageand provide access to class collections.andP;  In the following sections wemotivate the need for software communities and software information systems.andO;The bulk of this article discusses various issues associated with managingthe very large class collections produced and used by these communities.andM;SoftwareandM;CommunitiesandM;Software development and maintenance cause major headaches for mostorganizations.andP;  Although it has been recognized as a problem for many yearsnow, software development still costs too much and induces overruns anddelays.andP;  Advances have been made over the years, particularly in the area ofComputer-Aided Software Engineering (CASE) tools which aim to improveproductivity.andP;  In spite of these improvements, software development hasresisted efforts at mechanization or automation.andP;  It is perhaps time torecognize that there is something intrinsically different about softwaredevelopment which does not allow easy automation.andM;It is widely recognized that software development is not repetitive butrequires much creative and intellectually taxing effort.andP;  Therefore, it isdifferent from most manufactured products.andP;  Nevertheless, we still dream of&quot;software factories&quot; which will cheaply produce high quality software (see[20] for an early expression of this idea).andP;  The problem, perhaps, is that weapproach software development with the wrong paradigm.andP;  If we approachsoftware using a mathematical paradigm, the program resembles a proof of astated problem (the theorem).andP;  The emphasis is on structure, methodicaldevelopment and proof of correctness.andP;  If we approach software with anengineering/manufacturing paradigm, we view the program as a product built bya well-known procedure whose steps have to be streamlined.andP;  Over the years,as a result of considerable research activity we have achieved some successusing these paradigms.andP;  However, the fact that software development andmaintenance are still a problem should encourage the search for otherparadigms.andM;One new paradigm is offered by object-oriented programming.andP;  This paradigm,when fully applied, promotes a method of development we call cooperativelarge-scale reuse.andP;  This method can be illustrated by use of a legal analogy.andO;Suppose a program corresponds to a legal case: its development andmaintenance parallel the legal effort associated with building and presentinga legal case.andP;  Such an analogy would have been natural if the pioneers ofcomputer science had been lawyers rather than mathematicians and engineers.andO;Note that, within this analogy, it is difficult to talk about the correctnessof software, or software factories, for the analogy immediately points outthe difficulties in considering correctness of a legal case or a legal casefactory.andM;The most interesting insights, however, come in a positive sense when weconsider how lawyers go about building a case.andP;  First, they base theirarguments on past experience accumulated not only by themselves, butespecially by their colleagues.andP;  Recording this experience is an integralpart of the legal process.andP;  Second, a legal case continuously evolves.andP;  Thereis no notion of separating design from implementation or development frommaintenance.andP;  Instead, each legal case continuously develops (through theappeal procedure) and links up to previous and eventually future cases.andP;  Twooutstanding characteristics of legal effort seem, therefore, to be thereusability of past experience and a continuously evolving effort.andM;We will now draw parallels from the analogy and apply the characteristics oflegal effort to software.andP;  The two outstanding characteristics of softwaredevelopment and maintenance should be reusability of experience and evolvingsoftware.andP;  To increase productivity of software development one should reusepast experience, in the same way a lawyer building a legal case uses pastideas, arguments and cases.andP;  By the term past experience we mean to includerequirements, specifications, models, designs and software components.andP;  Topromote evolving software we should be able to interchange parts, such asdocumentation, designs, and software components, and link them in variousways, just as a lawyer enhances his case by continuously rearranging hisarguments, drawing in new ones and abandoning those that are unsuccessful.andM;Like legal work, software development and maintenance are intellectuallytaxing.andP;  Both can benefit from proper organization and appropriate use oftechnology to help manage and locate information.andP;  The prevailing softwareengineering methods tend to cover all phases of software development forevery single project, from requirements collection, analysis andspecification, all the way to coding.andP;  Reuse of experience and software iseffectively discouraged by restricting the context to a single application ata time [22].andP;  We argue, on the other hand, that long-term gains in softwareproductivity and reliability can only be achieved by adopting a more globalview of software development.andM;In particular, software development can be viewed as taking place within thecontext of a software community.andP;  Just as there are legal communities--groupsof lawyers with common areas of legal expertise and a shared history of legalcases--so there should be software communities: groups of people engaged inthe development, and also the dissemination and end use, of pieces ofsoftware.andP;  An essential characteristic of any community is its history: anaccumulation of collective past experience.andP;  The history of a softwarecommunity would be the experiences gained in the design, development, use andmaintenance of software for particular application domains.andP;  For a softwarecommunity to function efficiently it must learn from and take advantage ofthis wealth of experience.andM;In our ideal scenario, applications would be based on generic softwarecomponents accumulated by a software community familiar with the applicationdomain.andP;  To build a new application, a developer could collect requirementsaccording to an existing, well-defined model of the domain, select genericsoftware components according to these requirements, and initialize andcompose the selected components to construct the running application.andP;  Byanalogy, lawyers would like to handle all legal cases as though they wereslight variations on textbook cases.andM;Although this scenario is rather idealized, we believe it can be realized toa greater on lesser extent, depending on how well an application domain canbe characterized, and on how routine the required applications will be.andP;  Infact, commercially available generic software, (such as spreadsheets,relational databases, and hypertext systems), is already proving thisscenario workable for certain application domains.andP;  Even in cases whereclients have very specific requirements, we believe a large part of anapplication should be boilerplate, with only a few software components beingdesigned specifically to meet the new requirements.andM;To approach this scenario as closely as possible for any given applicationdomain, it is clear that we must support the process of developing generic,reusable software.andP;  To this end we mustandM;1.andP;  organize and manage software and information about software development,andM;2.andP;  make it easy to find information concerning prior projects that may berelevant to new projects, andandM;3.andP;  provide support for the gradual evolution of software and softwarecomponents.andM;SoftwareandM;Information SystemsandM;The use of software information systems is one way of achieving the abovethree goals and improving the efficiency of software communities.andP;  A softwareinformation system is a repository, likely very large, containing all theinformation, including documents, designs, and software components, relevantto the functioning of a particular software community.andP;  The system should bereadily available to members of the community and continuously augmented assoftware is developed or refined.andM;To make the notion of a software information system more concrete we shallassume that applications are developed using an object-oriented approach andthat individual software components are primarily classes written in anobject-oriented programming language.andP;  Object-oriented languages, throughmechanisms of encapsulation, data abstraction, instantiation, inheritance,genericity, and strong typing, have demonstrated their potential indeveloping toolkits and libraries of reusable software components.andP;  Althoughwe make few assumptions about the nature of the particular mechanismssupported by the language of choice, we feel it reasonable to suppose thatobject classes and some form of class inheritance will play an importantrole.andP;  A starting point, then, is to consider a software information systemas a collection of object classes.andM;There are a number of advantages to collecting and organizing classes withinan information system.andP;  First, the classes will be indexed to help withretrieval.andP;  Second, by applying quality control procedures to classes addedto the system, developers can be more certain of the reliability of classesobtained from the system.andP;  Furthermore, a software information system withknowledge about dependencies between classes can ensure that its contents becomplete (missing files or definitions are often problems when reusingsoftware).andP;  Finally, by obtaining a class from a repository, developers aremore likely to get a standard version rather than a version full ofundocumented local modifications.andM;There has been considerable work in the area of database support for softwaredevelopment [3, 4, 15, 28], primarily in the context of extending progrmamingenvironments with database facilities for project and configurationmanagement.andP;  We view a software information system in a rather differentlight, as an autonomous service, not necessarily tightly coupled with theprogramming development tools but, nevertheless, easily accessible by thesetools.andP;  The closest existing systems of this nature are electronic bulletinboards and the various software repositories scattered over Internet.andP;  Suchfacilities, while useful, are very limited in their functionality.andM;We will call the task of maintaining a collection of classes classmanagement.andP;  Class management includes many traditional database managementissues such as data modeling, access methods and authorization.andO;Additionally, class management encompasses new issues specific to classes.andO;For instance, as requirements change or designs improve, classes must change;we call this class evolution.andP;  When the collection is large, developers mayrequire assistance in finding a class for reuse; we call this classselection.andP;  There is the problem of preparing classes for reuse: classpackaging.andP;  Other class management issues pertain to security and pricingpolicies.andP;  These include keeping the class collection free from viralinfection or, when a class is proprietary to particular groups, helping toenforce licensing contraints.andM;Next we explore the basic issues in class management by discussing approachesto organizing and managing classes so as to support software development andreuse, approaches to browsing and querying a collection of object classes,and techniques for the controlled evolution of object classes and classhierarchies.andP;  Our objective is not to propose a design for softwareinformation systems, but rather to identify and categorize some of thecritical issues that must be addressed when designing these systems.andM;Class PackagingandM;Object-oriented programming has been described as a &quot;packaging technology&quot;[9].andP;  Class packaging is the problem of representing an object class so th atthe information needed to use the class can be easily located andincorporated within an application.andP;  A straightforward approach to packagingwould be to represent classes by source text and store these representationsin a file system.andP;  The information could be organized using simple mechanismssuch as file-naming conventions and directories, and accessed throughstandard utilities such as editors and file browsers.andP;  However, even if thenumber of classes is small, this representation may present difficulties.andO;For instance, on a UNIX [TM] system a [C.sub.++] programmer typicallyrepresents a class X by two files: a source file, X.c, and header file, X.h,containing public declarations.andP;  Suppose X.h consists of: #include &quot;common.h&quot;#include &quot;Y.h&quot; #include &quot;Z.h&quot; class X : public Y, public Z { int  x;protected: void  setx(int); int  getx(); public: X(int); ~X(); };andM;Given X.h, a programmer who wants to make use of class X would have to locateat least the following information:andM;* the include files common.h, Y.h, and Z.h,andM;* the source code or object code for the methods X::setx, Y::getx, X::X, andX::X, andandM;* the source code or object code for methods of the classes Y and Z.andM;In addition the programmer would have to considerandM;* whether the names (classes, structures, type definitions, etc.) used incommon.h, Y.h, or Z.h, are in conflict with names already in use,andM;* whether any of common.h, Y.h, or Z.h, in turn refer to other include files,andM;* if object code is available, whether it is suitable for the run-timeenvironment (processor, operating system) the programmer intends to use,andM;* if source code is available, whether it is suitable for the developmentenvironment (compiler, operating system) the programmer intends to use,andM;* whether X will be reused directly or refined.andP;  In the first case theprogrammer may want to examine the source of public methods of X; in thesecond case the programmer may also want source of private and protectedmethods.andM;As the number of classes increases, more problems appear with thisrepresentation: it becomes difficult to find classes, relationships betweenclasses are not  explicitly represented and so must be deducted from thesource code, and adding new classes may involve rearranging the file system.andO;By choosing a richer, more explicit representation of class structure, thesoftware information system can be of greater assistance in managing largenumbers of classes.andP;  For instance, advanced querying and browsing facilities,versioning, and high-level interfaces to development tools all require, tosome extent, knowledge of the structure and relationships of classes.andM;An early example of class packaging can be found in Xerox's PIE (PersonalInformation Environment) [14].andP;  PIE is an extension of the Smalltalkprogramming environment in which Smalltalk classes are represented by layerednetworks.andP;  The nodes of these networks contain various chunks of code for theassociated class, (see Figure 1 for a simplified example).andP;  Each layercorresponds to a different design of the class (in the example shown, class Xhas one method in the initial layer and a second method added by thesuperseding layer).andP;  One advantage of representing classes by data structuresrather than text is that software can then be integrated with other forms ofinformation.andP;  This is illustrated by PIE since it supports th e creation ofhypertext-like links between nodes contianing code and nodes containingdocumentation.andM;A more recent example of packaging is found in the Trellis programmingenvironment [27].andP;  As a programmer defines new classes using the Trellis/Owllanguage, representations consisting of the soruce code of these classes areadded to a database.andP;  This information is shared and augmented by theprogramming tools within the environment, including a cross-referencing tooland a compiler which adds object code and possibly error information.andP;  Asecond advantage of representing classes by data structures, rather thantext, is that it is easier to build tools which examine and manipulateclasses.andP;  Trellis is an open-ended environment where tools can be added ormodified.andP;  This is, at least in part, a result of the packaging and sharingof class definitions provided by the database.andM;It is natural to ask what are the characteristics of useful classrepresentations.andP;  We believe three things are important: First, therepresentation should allow a structural decomposition of the class into anumber of logical components.andP;  Second, the representation should permit theattachment of descriptive information.andP;  Third, the representation shouldsupport multiple views.andM;Structural Decomposition.andP;  By structural decomposition we mean breaking therepresentation of a class into a number of interrelated components.andP;  Inchoosing a decomposition for classes written in a particular programminglanguage, one can be guided by the constructs provided by the language.andP;  Soif the programming language supports class and instance variables, therepresentation should contain structural components corresponding to bothclass and instance variables.andP;  Similarly, if methods may be private or publicit should be possible to capture this distinction within the representation.andO;However, there is a tradeoff between the granularity of structuraldecomposition and simplicity of the representation: as the representationbecomes more finely detaileD, its use by tools such as browsers becomes morecomplex.andM;Discriptive Attachment.andP;  Not all components of the class representation needbe derivable from source code.andP;  The representation should allow one to attachcomponents corresponding to descriptive attributes.andP;  Possible attributesinclude the author of the class, the date it was written, version and releaseinformation, and comments or documentation.andP;  For retrieval purposes it isuseful to attach textual descriptions of the class.andP;  This could be a set ofkeywords, or descriptors from a software classification scheme such asdescribed in [34].andM;Multiple Views.andP;  Structural decomposition of classes is a very generalmechanism which can be used in a number of ways.andP;  One use is in versioning,the advantage being that only those components differing from a previousversion need be stored.andP;  This is demonstrated by PIE.andP;  Structuraldecomposition is also useful for browsing--since the browser can then displayor highlight different parts of the class in different ways, and forquerying--since it is then possible to express and evaluate queries whichrefer to different parts of the class.andP;  However, the representation of aclass may become rather complex.andP;  Considering only versioning there are manycomplications.andP;  Versions may have different designs (i.e., differentsignatures), may refer to different stages of development, theirimplementations may differ (i.e., different choices for internal datastructures and algorithms), and their compilations may differ (i.e., objectcode for various machine architectures).andP;  In order to cope with thiscomplexity is useful if multiple views of a class are supported.andM;Some examples of views include the private and publci parts of a class, theimplementations of a class (see Figure 2), and owner-versus-user views of aclass [42].andP;  Other examples of views can be found in the ways variousobject-oriented languages organize methods.andP;  For instance, Smalltalkconventionally groups methods into categories.andP;  In CV++ [37], an extension ofC++, methods can be grouped into a number of interfaces.andP;  Other proposalsgroup methods into roles--each object has a current role and will onlyrespond to methods associated with that role [30, 36].andP;  In such cases one maywant to be able to view a class from the perspective of a particularcategory, interface, or role.andP;  Finally, in a multilanguage environment where,for instance, both C++ and Smalltalk classes are needed, it may be useful tohave a coarse language-independent view, showing perhaps only class names andmethod names, in addition to more detailed, language-dependent views.andP;  Ingeneral, as these examples show, a view mechanism allows classes to be dealtwith at different levels of detail and in more flexible ways.andM;Class OrganizationandM;Class packaging deals with the representation of single classes.andP;  Classorganization, on the other hand, deals with the relationships anddependencies that occur in collections of classes.andP;  A software informationsystem should capture the relationships between classes for a number ofreasons.andP;  FirsT, it is needed for reuse; although classes have been proposedas units of code reuse, it is often the case that one class depends onanother and so it is not single classes but groups of classes which arereused.andP;  Second, knowledge of class relationships can help with browsingsince a browser needs to identify related pieces of information.andP;  Finally,class relationships can also help to detect inconsistencies orincompleteness.andP;  For example, a software information system would beincomplete if it contained a class but but its superclass.andM;It is useful to distinguish two categories of relationships involvingclasses.andP;  The first, structural relationships, are derivable from sourcecode.andP;  Examples include the SubclassOf or inheritance relationship,Instance-Of, and a DependsOn relationship.andP;  Relationships of the secondcategory are those which are not derivable from source code; instead theseare explicitly defined by some agency external to the software informationsystem.andP;  For example, a project could define a relationship for the purposeof collecting the classes which it uses.andP;  We now look at some of the issuesinvolved in representing relationships among classes.andM;SubclassOj (inheritance) Inheritance is one of the standard features ofobject-oriented languages [44].andP;  Thus we would expect a software informationsystem to keep track of which classes are subclasses of other classes.andO;Representing this relationship itself is straightforward; single inheritanceis a 1-n relationship between classes while an m-n relationship is needed formultiple inheritance.andP;  An interesting question is to what extent the softwareinformation system need model the semantics of inheritance.andP;  There are manyvarieties of inheritance [25, 39].andP;  To take one example, object-orientedprogramming languages differ on whether the instance variables of asuperclass are visible to the methods of a subclass.andP;  If we want the softwareinformation system to provide a view of a class showing all availableinstance variables or all available methods, as does the &quot;flat&quot; view ofEiffel [21], then it will be necessary to model some of the semantics ofinheritance.andP;  Furthermore, such views involve calculating the transitiveclosure of the SubClassOf relationship, so efficient traversal of thisrelationship must be possible within the software information system.andM;InstanceOf.andP;  the role of the InstanceOf relationship within softwareinformation systems requires some clarification.andP;  We see software informationsystems are contianing representations of classes, but generally notinstances of these classes.andP;  Instances would be created and managed byapplications constructed using the classes provided by a software informationsystem.andP;  However, there are situations when an inter-class InstanceOfrelationship is useful.andP;  Some object-oriented languages contain metaclasses.andO;In this case classes can be viewed as instances and the software informationsystem would need to represent both classes and metaclasses as well as therelationship between the two.andP;  A second potential use is in modelingparametric polymorphism.andP;  Some object-oriented languages contain constructswhich can be expanded into class specifications by binding type parameters.andO;Such polymorphic class specifications could be modelled as metaclasses, inwhich case the derived class would be an instance of the metaclass.andM;DependsOn (ClientOf, PartOf).andP;  One class may depend on another in a varietyof ways: A class may be a ClientOf (i.e., invoke) the methods of anotherclass.andP;  One class may be PartOf a second, as when a class has instances ofother classes among its instance variables.andP;  In strongly-typedobject-oriented languages a class may depend on another by declaring it asthe type of a method parameter.andP;  These are examples of a general DependsOnrelationship that identifies the various syntactic references betweenclasses.andP;  A software information system should be able to determine for agiven class, which classes it depends on, and conversely, which depend on it.andM;These relationships are common to many object-oriented languages.andP;  There areother relationships which are more language-dependent, such as the &quot;friend&quot;relationship found in C++ [40].andP;  If one class declares a second as itsfriend, then the private methods and instance variables of the first classare available to the second.andP;  Other examples result from aggregations ofclasses such as &quot;features&quot; [17] and &quot;frameworks&quot; [45].andP;  Both features andframeworks involve groups of classes: a feature is a language construct thatspecifies an interface to some group of classes while a framework is asubsystem design based on an inter-working group of classes.andP;  In theseexamples, one class may be related to another via participation in the samefeature or framework.andP;  In general, any language-dependent softwareinformation system may have to represent a number of additional relationshipsderived from the language concerned.andP;  Figure 3 shows an example of a moreextensive group of relationships used to represent a C++ class collection.andM;In addition to structural relationships such as SubClass, InstanceOf, andDependsOn, class organization also requires relationships not derivable fromsource code.andP;  These include relationships that associate documentation andother design information with classes.andP;  The nature of these relationshipsdepends on many factors such as the procedures for adding a class to thesoftware information system and documentation conventions and formats.andP;  Forexample, Figure 3 shows a simple &quot;DocumentationOf' relationship between C++classes and documents.andP;  In practice, however, a more refined and versatileinter-linking of classes and documentation is likely to be necessary.andM;In addition to organizing classes in terms of inter-class relationships, itmay be useful to have more abstract groupings of the class collection.andP;  Inmany object-oriented programming languages the class name space isessentially flat.andP;  This can be problematic in a multi-user environment sincea monolithic class hierarchy constrains the designer of new objects to avoidname clashes.andP;  A simple example would be a CAD programmer who wants toprovide a &quot;Window&quot; object class for use in architectural applications but isunable to because of a conflict with a user-interface &quot;Window&quot; class.andP;  A moresubtle form of this problem may also occur in object design.andP;  There is atendency for the initial choice of object classes within a given applicationdomain to prescribe the design of future applications for the domain.andP;  It canbe difficult for a designer to break out of the prescribed design by classspecialization:andM;1.andP;  inheritance is now working against the designer andandM;2.andP;  the designer really wants a reorganization of the class hierarchy.andM;As a result, the class hierarchy may become a rigid constraining structurethat hampers innovation and evolution.andM;For large software information systems it appears that a single classhierarchy is just too simple.andP;  What is needed is a context mechanism, so, forinstance, the object classes deriving from a particular design for aparticular domain can be grouped together.andP;  One possible solution may becontext hierarchies, each context corresponding to a class name space.andP;  As anexample, figure 4 shows three contexts: A, B and C.andP;  The class hierarchyvisible within a given context consists of those classes visible within thecontext's parent and any additional classes defined within the context inquestion.andP;  For instance, context B includes classes [C.sub.1], [C.sub.2] and[C.sub.3] from its parent, A, and the locally-defined class [C.sub.4].andP;  A mapof the context hierarcy, such as the small tree appearing in the left ofFigure 4, provides a high-level global view of the class collection.andM;Class SelectionandM;and ExplorationandM;We now discuss the general problem of retrieving information from a classcollection.andP;  There are many programming situations where retrieval isnecessary.andP;  A user (such as a programmer or application developer) may, forexample, be looking for a specific class--perhaps the class of complexnumbers or a particular version of a window class.andP;  Alternatively, the usermay be looking for functionality that is provided by any of a number ofclasses in the system, or simply trying to get a feel for the scope of theclass collection.andP;  We can divide these retrieval activities into two groups:class selection and class exploration.andP;  Class selection refers to thesituation in which the user has fairly specific selection criteria, such asthe name of a class or method, or an area of functionality.andP;  With classexploration, on the other hand, the user is not interested in individualclasses but rather in the relationships among classes and the overallorganization ofandM;the collection.andP;   This is the case, forandM;instance, when a programmer is implementing a new application and wants todetermine which classes may be relevant to the application.andP;  The two methodscommonly used for retrieval are querying and browsing.andP;  Querying is usefulwhen search criteria are known, it is thus more appropriate forselection--while browsing is more appropriate for class exploration.andM;Class browsersandM;Currently most programming environments do not contain extremely largenumbers of classes--thus a single tool, a class browser, is used for bothselection and exploration.andP;  This approach is exemplified by the Smalltalk-80browser [13] which allows a user to browse through the class inheritancehierarchy, display instance variables and methods, and determine whichclasses send or receive a given message.andP;  Classes are grouped byfunctionality into possibly overlapping categories, and it is possible tobrowse through categories of classes and methods.andP;  The Small-talk browser hasbeen extended in many ways.andP;  For instance with the PIE browser [14], it ispossible to associate textual components to classes, categories and otherentities of the system in order to help in the understanding of the system.andO;The PIE browser also provides multiple views.andP;  It is possible, for example,to present the user with a set of views adapted to different applicationdomains.andP;  One such view might correspond to a development project whereclasses are being developed incrementally and thus should be kept hidden fromother users not involved in the development effort.andP;  The ability to definepartial views can reduce the complexity of the system as it appears to aparticular user.andM;Most of the existing browsers have been tested on small- or medium-scalesoftware projects.andP;  Although extrapolating their usefulness is not an easytask, it is natural to ask whether the Smalltalk approach is scalable andwhether it will be able to cope with the potential size of softwareinformation systems.andP;  We believe that current browsers are unlikely to beadequate for selection when class collections increase in size by a feworders of magnitude.andM;As the size of the class collection increases, class selection becomes moredifficult and query facilities are of greater benefit.andP;  There has beenrelatively little work in the area of class selection, although informationretrieval techniques may be applicable [10].andP;  One proposal that appearspromising is the software classification scheme developed by Prieto-Diaz andFreeman [34].andP;  This scheme uses a six-tuple of facets or descriptiveattributes, to classify software components according to such things asfunctional area, medium and system type.andP;  Furthermore, a conceptual distancebased on facet values can be used to estimate the match of a component to aparticular query.andM;Another question is whether browsing is sufficient for users who areinterested in exploring the functionality of a class collection.andP;  The primarynavigational structure used by browsers based on the Smalltalk approach isthe inheritance hierarchy.andP;  However, in most object-oriented programminglanguages, the semantics of inheritance is not sufficiently constrained forit to give useful insight into the functionality of subclasses.andP;  This isillustrated by the following examples:andM;* A subclass may add behavior to that of its superclass.andM;* A subclass may provide the same interface as its superclass but reimplementthe methods.andM;* With multiple inheritance, a subclass may override a method from onesuperclass with that from another.andM;In genreal, it is possible that classes related by inheritance providedissimilar functionality while classes unrelated by inheritance may providesimilar functionality, so merely knowing the inheritance relationshipsbetween classes gives little indication of how the functionality of asubclass differs from its superclass or why the subclass appears where itdoes in the hierarchy.andP;  Typically the user will resort to comparing the codebelonging to the two classes.andP;  However, determining the structure anddependencies of a set of classes by examining the code is difficult [41] andcontrary to encapsulation.andM;The problem of guiding a user engaged in exploring the class space is similarto the problem of providing navigational assistance in hypermediaenvironments, a subject that has received much attention recently [43].andO;Possible features that could be integrated in a class browser are globalviews of the organization of the system and navigation charts that help usersvisualize their position and the structure of the surrounding space.andM;Affinity browsingandM;Another approach to guiding exploration is by providing means for determiningthe similarities between classes, their interfaces and their functionality.andO;In this case the &quot;nearest neighbors&quot; of a class are not simply its super andsubclasses but rather those classes which it somehow resembles.andP;  We call thisaffinity browsing.andP;  The principal assumption of this approach is that in asoftware information system containing a large collection of inter-dependentclasses, the relationships among these classes are complex and can be viewedin many ways.andM;The affinity browser [32] is an attempt to intergrate navigational aspects ofconventional browsing with query capabilities.andP;  The affinity browser providesthe user with a set of two-dimensional views, each displaying somerelationship among a set of classes.andP;  One view could be based on the usualinheritance relationship while another could portray a grouping of classesbased on their relevance to some query.andP;  An affinity function, which definesthe intensity of a relationship, is associated with each view.andP;  When the viewis displayed, distances between classes convey their affinity (i.e., pairs ofclasses with strong affinity are displayed close together) while those withless affinity lie further apart.andP;  For example, classes that implement similarfunctionality, or have similar signatures, could have a higher affinity, andwould then cluster together when displayed.andM;In order to apply affinity browsing to class exploration we need to defineaffinity functions for classes.andP;  Clearly there are many such functions, somemore useful than others.andP;  Some potential candidates include the distancebetween two classes on the inheritance hierarchy, the conceptual distancebetween two classes using some classification scheme such as facets, thetextual similarity of the signatures of two classes, the amount of codeshared between two classes, or a measure based on class dependency (where twoclasses are similar if they depend on the same classes).andM;As a specific example of an affinity function and view generation, considerFigure 5 which shows the inheritance structure of a set of classes, C={[C.sub.0], ..., [C.sub.8]}, and the methods defined (and redefined) by eachclass.andP;  Assume that classes recursively inherit methods from theirsuperclasses.andP;  Let M(X) be the set of methods in the interface to class X.andO;For instanceandM;M([C.sub.7]) = {a, b, e, f, i, j, o, p}.andM;We want to define an affinity function that conveys the extent to whichclasses provide similar functionality.andP;  As a candidate function, suppose wedefine A(X, Y), the affinity between class X and class Y, asandM;A (X, Y) = card (M (X) [union] m (Y)) / card (M (X) [intersection] M (Y))andM;where card() is a function that returns the cardinality of a set.andP;  Forexample, to evaluate A([C.sub.3], [C.sub.4]), we haveandM;M([C.sub.3]) = {a, b, g, h} and M([C.sub.4]) = {a, b, i, j}, socard(M([C.sub.3]) [union] M([C.sub.4])) = 2 and card(M([C.sub.3])[intersection] M([C.sub.4])) = 6.andP;  Hence, A([C.sub.3], [C.sub.4]) = 1/3.andM;Of course other definitions are possible and it may be necessary to perform afew interations before one obtains views which convey a good intuition of theunderlying relationship.andP;  To illustrate this point, the above function couldbe modified slightly in the case of redefinition of an inherited method (suchas method a of class [C.sub.1]).andP;  Suppose we want to emphasize that redefinedfunctionality differs from inherited functionality.andP;  Let m be the inheritedmethod and m' be its redefinition.andP;  In the case where both m and m' appear inM(X) [intersection] M(Y) then in the affinity calculation we consider m = m'in M(X) [union] M(Y) while in M(X) [intersection] M(Y) we take m [is notequal to] m'.andP;  This produces a slight reduction of the affinity betweenclasses where one redefines a method of the other.andM;Figure 6 depicts a typical view generated by the affinity browser using thepreviously defined measure of affinity.andP;  The highlighted class, [C.sub.4], isthe current class.andP;  The Inspect Window displays the names of the classeswithin the view, these can be selected to obtain further information abouteach class.andM;The affinity browser promotes the local exploration of the class space.andP;  Theuser selects a class, it becomes the current class, and the tool displays theclasses that are within a user-defined affinity neighborhood (i.e., thosethat have an affinity with the current class that is greater than auser-defined limit).andP;  Selecting a new current class causes a shift in theneighborhood; new classes enter the view while others disappear.andP;  Views canbe connected in the sense that they can be constrained to have the samecurrent class.andP;  Each view then provides a different exploration context; theyare centered on the same class but have different neighborhoods sincedifferent affinity functions are involved.andM;It should be pointed out that given a measure of affinity it is not possible,in general, to generate a two-dimensional representation that satisfies allthe affinity constraints.andP;  The view layout algorithm [31, 33] attempts tofind a good approximate solution.andP;  For example, it does not assign the sameweight to each affinity constraint.andP;  It assumes that it is more important toprovide an accurate representation of affinity between the current class andthe other classes of the view than between two arbitrary classes.andM;Class EvolutionandM;IssuesandM;Class developed with an object-oriented language frequently undergoconsiderable reprogramming before they become readily reusable in a widerange of applications or domains.andP;  There are a number of reasons for thisphenomenon:andM;* Experience shows that stable, reusable classes are not designed fromscratch, but are &quot;discovered&quot; through an iterative process of testing andimprovement [16].andM;* Classes are difficult to arrange in predefined taxonomies.andM;* Because user's needs are rarely stable, additional constraints andfunctionalities have to be constantly integrated into existing applications.andM;* Reusing software raises complex integration problems when teams ofprogrammers share classes that do not originate from a common, standardhierarchy.andM;To apply such powerful techniques as inheritance, genericity, and delayedbinding efficiently, real-world concepts have to be properly encapsulated asclasses so they can be specialized or combined in a large number of programs.andO;Inadequate inheritance structure, missing abstractions in the hierarchy,overly specialized classes or deficient object modeling may seriously impairthe reusability of a class collection.andP;  The collection must therefore evolveto eliminate such defects and improve its robustness and reusability.andM;Several approaches, ranging from class tailoring to class reorganization,have been proposed to improve class collections.andP;  We will now describe somerelevant techniques developed recently for controlling evolution inobject-oriented environments, and discuss their respective merits.andM;Class tailoringandM;Object-oriented languages have always provided simple constructs fortailoring class hierarchies, notably by allowing the redefinition ofinherited properties.andP;  The body of a method, for example, can be completelymodified in a subclass, although its name and its signature remain identical.andO;Therefore, it is possible to implement specialized or optimized versions ofthe same method, rather than using the general, and perhaps inefficientalgorithm defined in a superclass.andP;  Some languages, such as Eiffel, allow thetype of inherited variables, parameters and function results to also beoverriden, provided the new type is compatible with the old one [21].andP;  Withthe object-oriented variants of LISP, the programmer can choose how tocombine inherited methods in a new class [24].andM;A similar, but more formal approach is described in [7].andP;  The author proposesa mechanism for excusing abnormal cases that arise when modeling anapplication domain, and that do not fit wiht the existing class hierarchy.andO;For example, a system for managing information on students may have to copewith the case of people who did part of their studies in foreign countrieswith different grading schemes and academic titles.andP;  Contradictions betweenthe definition of the &quot;foreign student&quot; class and its superclass (&quot;normalstudent&quot;) must be explicitly acknowledged.andP;  The explicit redefinition ofinherited attributes according to a formal model integrating excuses withinheritance facilitates the detection of type violations and the correcthandling of database queries (without overlooking exceptional entities).andO;Moreover, exceptions are handled locally, and do not require the factoring ofcommon properties into numerous intermediate classes.andM;These techniques are useful for performing limited adjustments to a classcollection, but they do not provide any help for detecting design flaws.andO;Over-reliance on tailoring and excuses may quickly lead to anincomprehensible specialization structure, overloaded with special cases anddifficult to manage efficiently with current database technology.andP;  Such asituation is generally a strong indication that the hierarchy does notcontain the proper abstractions and that it should be reorganized.andM;Class surgeryandM;Whenever changes are brought to the modeling of an application domain,corresponding modifications must be applied to the classes representingreal-world concepts.andP;  Modifying a class hierarchy is a delicate operationbecause of the multiple connections between class definitions that must betaken into account to guarantee the consistency of the hierarchy.andM;This problem also arises in the area of object-oriented databases.andP;  There,the available techniques [1, 29] first determine a set of integrityconstraints that a class collection must satisfy.andP;  For example, all instancevariables of a class should bear distinct names, no loops are allowed in thehierarchy, the attributes defined in a class should be inherited by all itssubclasses, and so on.andP;  In a second step, a taxonomy of all possible updatesto the system is established.andP;  These changes concern the structure ofclasses, like &quot;add a method,&quot; &quot;rename a method,&quot; or &quot;restrict the domain of avariable&quot;; they may also refer to the hierarchy as a whole, as with &quot;suppressa class,&quot; or &quot;add a superclass to a class.&quot;andM;For each of these update categories, a precise characterization of itseffects on the class hierarchy is given, and the conditions for itsapplication are analyzed.andP;  Generally, additional reconfiguration procedureshave to be applied in order to preserve integrity constraints.andP;  It is, forexample, illegal to suppress an attribute from a class C if this attribute isreally inherited from a superclass of C; if the attribute can be suppressed,it must also be recursively dropped from all subclasses of C, or possiblyreplaced by another variable with the same identifier inherited throughanother subclassing path.andP;  As another example, deleting a class S from thelist of ancestors of another class C is not allowed if this operation leavesthe inheritance graph disconnected.andP;  If the operation does not cause anyproblems, the inheritance links are reassigned to point from C to thesuperclasses of S.andP;  Of course, the properties of S no longer belong to therepresentation of C, nor to those of its subclasses.andM;Decomposing all class modifications into update primitives and determiningtheir consequences brings several advantages.andP;  During class design, thisapproach helps developers detect implications of their actions on the classcollection and maintain the consistency of class specifications.andP;  Duringapplication development, it guides the propagation of changes to where theclass is reused.andP;  For example, renaming an instance variable of a class,changing its type or defining a new default value, has no impact on anapplication using the class.andP;  Changing or deleting methods, on the otherhand, generally leads to changes in applications.andM;Depending on the class model and on the integrity constraints, a softwareinformation system may provide different forms of class surgery.andP;  Thisapproach, however, limits its scope to local, primitive kinds of evolution;it forms a solid framework for defining &quot;well-formed&quot; class modifications,but it gives no guidance as to when these modifications should be performed.andM;Class versioningandM;Versioning is a particularly appealing technique for managing classdevelopment and evolution.andP;  It enables programmers to try different pathswhen modeling complex application domains and to record the history of classmodifications during the design process.andP;  Versioning also helps in keepingtrack of various implementations of the same class for different softwareenvironments and hardware platforms.andM;A basic problem to deal with concerns the identity of classes.andP;  It is nolonger enough to refer to a class by its name, since the name mightcorrespond to many versions of the same class.andP;  an additional version numbermust be provided to identify unambiguously the class referred to.andP;  When thisversion number is absent, a default class is assumed: the very first versionof the class referred to, or its current version, or its most recent versionwhen the software component making the reference was created.andM;If only the most recent version can give rise to new versions, there is inprinciple no need for an elaborate structure to keep track of the history ofclasses: their name and version number suffice to identify their relationshipto each other.andP;  The case where versioning is not sequential, (i.e., where newversions can be derived from any previous version), requires that thesoftware information system record a hierarchy of versions somewhat similarto the traditional class hierarchy.andM;Another difficulty arises because of the superimposition of versioning on theinheritance graph.andP;  For example, when creating a new version for a classshould one derive new versions for the entire tree of subclasses attached toit as well?andP;  A careful analysis of the differences between two successiveversions of the same class gives some directions for dealing with this kindof problem.andP;  If the interface of a class is changed, then new versions shouldbe created for all its subclasses and all its dependent classes.andP;  If onlynonpublic parts of the class are modified, such as methods visible only tosubclasses, or the types of instance variables, then versioning can belimited to its existing subclasses.andP;  If only the implementations of theclass's methods are changed, no new versions for other classes are required.andM;Application developers may want to consider objects instantiated fromprevious class versions as if they originated from the current version, orthey may want to forbid objects from an old version to refer to instances offuture versions.andP;  These effects are rarely achieved by fully automatic means.andO;For every new version, one must program special functions for mapping betweenold and new class structures [6, 38].andP;  These functions filter the messagessent to objects, so that proper actions can be taken, like translatingbetween method names, returning a default value when accessing a non-existentvariable, or simply aborting an unsuccessful operation.andM;In spite of their overhead, class versioning techniques have provedindispensable in important domains like CAD/CAM and office informationsystems.andP;  They have therefore been integrated in object-oriented systems,such as Orwell [42] AVANCE [5], ORION [1], and IRIS [2].andM;Class reorganizationandM;Class evolution is intimately linked with class design.andP;  Suppose programmersbuild applications chiefly in a bottom-up fashion by reusing existingclasses.andP;  Classes may then require adaptations so that they fully suit theneeds of software developers.andP;  This is achieved by redefining or suppressingattributes (instance variables and methods), reimplementing methods, changingclass interfaces, etc.andP;  Such modifications indicate that the currenthierarchy is not satisfactory: if classes cannot be reused as they are, ifsubclasses cannot be derived from other classes without considerabletailoring, then one needs to look for missing abstractions, to make someclasses more general, to increase modularity, in short, to reorganize, atleast in part, the hierarchy.andP;  Tools that automatically restructure a classcollection and suggest alternative designs can reduce considerably theefforts required for carrying out these tasks.andM;One solution is to algorithmically restructure the hierarchy when introducingnew classes by creating intermediate nodes, shuffling attributes among them,and rearranging inheritance paths, so as to avoid the need for explicitlyredefining or rejecting attributes [8].andP;  In the example of Figure 7, we wantto insert a class that inherits attributes A and D, introduces E, butsuppresses attributes B and C.andP;  The second part of Figure 7 shows how thegraph has to be modified to accommodate class ADE; notice that twointermediate classes are required for its integration in the hierarchy.andO;These additional classes represent shared modules of functionality; theycorrespond to constructs, such as the &quot;mixins&quot; of Lisp with Flavors [23],whose main purpose is not to describe real-world entities, but rather tosupport the implementation of other classes.andP;  More importantly, the classesintroduced during the reorganization process can serve as a rough estimatefor the abstractions that are missing from the modeling of an applicationdomain.andP;  Such defects are unavoidable; it is exceptional to achieve a stable,definitive class design without going through several iterations.andP;  Newclasses and inheritance links correspond to the places in the hierarchywarranting redesign.andM;This approach works incrementally and preserves the structure of all originalclasses, except for their inheritance links.andP;  It can be extended to take intoaccount information on types, on mutual dependencies between attributes, andon multiple inheritance.andP;  When typical evolution patterns emerge, they canhelp guide the design process [18].andM;An analogous technique is used to fully recast a class hierarchy, by gettingrid of obsolete classes or unwanted versions.andP;  Global restructuringalgorithms keep as much information as is needed to reconstruct all originalclasses, if needed; they try to enforce some properties, like allowing anattribute to be introduced at only one point in the hierarchy [8].andM;Reorganization can also improve the quality of classes.andP;  Some class designmethods prohibit certain kinds of references to the attributes of objects[19].andP;  Thus, a method should never access variables that do not belong to theclass where it is defined or are not passed to it as parameters.andP;  Such unsafeexpressions can be detected and replaced with appropriate method callsautomatically.andP;  By eliminating unnecessary dependencies, classes shouldencapsulate functionality more tightly and show better resilience to change.andM;Reorganization algorithms appear useful for detecting missing abstractions,for proposing generalizations of very specialized classes, and for cleaningup a hierarchy.andP;  However, because they perform strictly structuraltransformation on object descriptions, their results require userintervention to compensate for the lack of knowledge concerning theapplication domain and the concepts embodied in the class collection.andM;Object-oriented development has an iterative nature and successive stages ofsubclassing, class tailoring, class modification, version creation andreorganization are needed to build increasingly general, reusable and robustclasses.andP;  We expect, therefore, software information systems to takeadvantage of a spectrum of tools and techniques for managing class evolution.andM;ConclusionandM;In the preceding sections we have argued that object-oriented programming,augmented by the availability of large class collections, leads to a newmethod of software development which encourages the design and reuse ofgeneric components by communities of software developers.andM;In establishing this method there appear to be three sets of issues whichmust be addressed.andP;  First, there are basic questions related to the design ofsystems for maintaining the class collection--what we have called softwareinformation systems.andP;  Second, we need to understand how to integrate suchsystems with software development methods.andP;  And, third, there is the questionof establishing the appropriate infrastucture to assure wide accessibility ofthese systems.andM;We have been more concerned with the first set of issues; in particular wehave focused on class management, or how to organize and maintain large classcollections.andP;  We have looked at various alternatives for representing classesand their relationships, for assisting developers to select classes, and forallowing the class collection to evolve over time.andP;  There has been littleexperience working with very large, shared class collections and so we planto evaluate some of the techniques described above.andP;  Currently we areimplementing a prototype, called Xos, or &quot;external object system&quot; which hasbeen specifically designed for modeling object classes [11, 12].andP;  Xos allowsapplication development tools to concurrently create, query and modify classrepresentations.andP;  We plan to use Xos to capture a large C + + hierarchy andthen evaluate various querying and browsing facilities, such as affinitybrowsing, and experiment with class reorganization algorithms.andM;Regarding the role of sotfware information systems and class collections inthe development life cycle, it is useful to distinguish between two kinds ofdevelopment activity: component development and application development.andP;  Theformer consists of designing and implementing reusable or generic componentswhile the latter consists of constructing applications from primarilypredesigned components.andP;  For reuse to occur there must be an increasedemphasis on the development, evaluation and refinement of components, asopposed to final products or applications.andP;  Furthermore, tools must beprovided taht aid in configuring existing components into new applications.andM;We are exploring this approach by participating in Ithaca [35], a largeEuropean ESPRIT project, the aim of which is to build an environment tosupport the development of object-oriented applications in a variety ofapplication domains.andP;  The environment includes an object-oriented languagewith database support, a software information base (SIB) which stores andmanages information concerning reusable software and its intended use, aselection tool for browsing and querying the SIB and a variety of applicationdevelopment tools built around the SIB.andP;  Among these tools is a visualscripting tool for interactively constructing running applications fromvisual representations of packaged application objects [26].andM;Finally, we believe that the greatest benefits of large-scale class reusewill occur when software information systems are publicly available resourcesrather than confined within single organizations.andP;  Despite facilities such aselectronic mail and bulletin boards, software development is still tooisolated an activity.andP;  The past decade has seen the establishment of on-lineservices in areas such as finance and travel.andP;  These services aredecentralizing and interconnecting workers in many occupations.andP;  Using theclass as a unit of interchange, software development may also become a moreopen, networked, cooperative activity.andP;  This raises a number of pragmaticissues, some of which we have alluded to in this article.andP;  For instance, ifproprietary software is placed in publicly accessible systems will it bepossible to ensure that licensing and copyright conditions are met?andP;  Who willoperate these systems and what services will be provided?andP;  How will they beaccessed?andP;  These pragmatic issues, in addition to the technical problems ofclass management, must be addressed before large-scale reuse of objectclasses can be realized.andM;ReferencesandM;[1] Banerjee, J., Kim, W., Kim, H.-J., and Korth, H.F.andP;  Semantics andimplementation of schema evolution in object-oriented databases.andP;  InProceedings of the ACM (SIGMOD) Conference on the Management of Data.andP;  (SanFrancisco, California, May 27-29), ACM, New York, (1987), pp.andP;  311-322.andM;[2] Beech, D, and Mahbod, B.andP;  Generalized version control in anobject-oriented database.andP;  In proceedings of the 4th IEEE InternationalConference on Data Engineering.andP;  (Feb.andP;  1988).andM;[3] Bernstein, P. Database system support for software engineering.andP;  InProceedings of the International Conferenceon Software Engineering.andP;  (1987),pp.andP;  161-178.andM;[4] Biggerstaff, T., Ellis, C., Halasz, F., Kellog, C., Richter, C., andWebster, D.andP;  Information management challenges in the software designprocess.andP;  MCC Tech.andP;  Rep.andP;  STP0039.87.andP;  1987.andM;[5]  Bjornerstedt, A., and Britts, S.andP;  AVANCE.andP;  An object management system.andO;In Proceedings of OOPSLA '88 (Sept.andP;  1988).andP;  pp.andP;  206-221.andM;[6] Bjornerstedt, A., and Hulten, C.andP;  Version control in an object-orientedarchitecture.andP;  In Object-Oriented Concepts, Databases and Applications.andP;  W.andO;Kim and F. Lochovsky, Eds.andP;  Addison-Wesley/ACM Press, 1989 pp.andP;  451-485.andM;[7] Borgia, A.andP;  Modeling class hierarchies with contradictions.andP;  InProceedings of the ACM SIGMOD Conference on the Management of Data (Chicago,June 1-3).andP;  ACM, New York (1988), pp.andP;  434-443.andM;[8] Casais, E.andP;  Reorganizing an object system.andP;  In Object OrientedDevelopment, D. Tsichritzis Ed., Centre Universitaire d'Informatique,Universite de Geneve.andP;  1989.andM;[9] Cox, B.J.andP;  Object-Oriented Programming: An Evolutionary Approach.andO;Addison-Wesley, Reading, Mass., 1986.andM;[10] Franks, W.B., and Gandel, P.B.andP;  Classification, storage, and retrievalof reusable components.andP;  In Proceedings of the ACM SIGIR Conference onResearch and Development in Information Retrieval.andP;  (Cambridge.andP;  Mass., June25-28).andP;  ACM, New York (1989) pp.andP;  251-254.andM;[11] Gibbs, S.andP;  Querying large class collections.andP;  In Object Management.andP;  D.andO;Tsichritzis Ed.andP;  Centre Universitaire d'Informatique, Universite de Geneve,1990.andM;[12] Gibbs, S. and Prevelakis, V.andP;  Xos: An overview.andP;  In Object Management.andO;D. Tsichritzis Ed.andP;  Centre Universitaire d'Informatique, Universite deGeneve, 1990.andM;[13] Goldberg, A.andP;  Smalltalk-80: The Interactive Programming Environment.andO;Addison-Wesley, Reading, MAss., 1984.andM;[14] Goldstein, I.P., and Bobrow, D.G.andP;  A layered approach to softwaredesign.andP;  Rep.andP;  CSL-80-5, Xerox, 1980.andM;[15] Hudson, S.E., and King, R.andP;  Object-oriented database support forsoftware environments.andP;  In Proceedings of the ACM SIGMOD Conference on theManagement of Data (1987), pp.andP;  491-503.andM;[16] Johnson, R.E., and Foote, B.andP;  Designing reusable classes.andP;  J. ObjectOriented Programming (June-July 1988), 22-35.andM;[17] Kaiser, G.E., and Garlan, D.andP;  MELDing data flow and object-orientedprogramming.andP;  In Proceedings of OOPSLA '87 (Oct.andP;  1987), pp.andP;  254-267.andM;[18] Li, Q., and McLeod, D.andP;  Object flavor evolution through learning in anobject-oriented database system.andP;  In Proceedings of the 2nd InternationalConference on Expert Database Systems, (Tysons Corner, Virginia, April 25-27,1988), 241-256.andM;[19] Lieberherr, K.J., and Holland, I.M.andP;  Assuring good style forobject-oriented programming.andP;  IEEE Softw.andP;  (Sept.andP;  1989), 38-48.andM;[20] McIlroy, M.D.andP;  Mass produced software components.andP;  In SoftwareEngineering, P. Naur and B. Randell Ed.andP;  NATO Science Committee (Oct.andP;  1968),138-150.andM;[21] Meyer, B.andP;  Object-Oriented Software Construction.andP;  Prentice Hall (1988).andM;[22] Meyer, B.andP;  The new culture of software development: Reflections on thepractice of object-oriented design.andP;  In TOOLS '89, 13-23.andM;[23] Moon, D.A.andP;  Object-oriented programming with flavors.andP;  In Proceedings ofOOPSLA '86 (Sept.andP;  1986), pp.andP;  1-8.andM;[24] Moon, D.A.andP;  The common LISP object-oriented programming language.andP;  InObject-Oriented Concepts, Databases and Applications.andP;  W. Kim and F.andO;Lochovsky Ed.andP;  Addison-Wesley/ACM Press, 1989, 49-78.andM;[25] Nierstrasz, O.M.andP;  A survey of object-oriented concepts.andP;  InObject-Oriented Concepts, Databases, and Applications.andP;  W. Kim and F.andO;Lochovsky Ed.andP;  Addison-Wesley/ACM Press, 1989, 3-21.andM;[26] Nierstrasz, O.M., Dami, L., de Mey, V., Stadelmann, M., Tsichritzis, D.,andO;and Vitek, J.andP;  Visual Scripting: Towards interactive construction ofobject-oriented applications.andP;  In Object Management, D. Tsichritzis Ed.andO;Centre Universitaire d'Informatique, Universite de Geneve, 1990.andM;[27] O'Brien, P.D., Halbert, D.C., and Kilian, M.F.andP;  The Trellis programmingenvironment.andP;  In Proceedings of OOPSLA '87 (Oct.andP;  1987), pp.andP;  91-102.andM;[28] Penedo, H.M., and Stukle, E.D.andP;  PMDB: A project master database forsoftware engineering environments.andP;  In Proceedings of the InternationalConference on Software Engineering.andP;  (1985), pp.andP;  150-157.andM;[29] Penney, D.J., and Stein, J.andP;  Class Modification in the GEMSTONEobject-oriented DBMS.andP;  In Proceedings of OOPSLA '87 (Oct.andP;  1987), 111-117.andM;[30] Pernici, B.andP;  Objects with roles.andP;  In Proceedings of the ACM Conferenceon Office Information Systems (Apr.andP;  1990), pp.andP;  205-215.andM;[31] Pintado, X., and Fiume, E.andP;  Grafields: Field-directed Dynamic Splinesfor Interactive Motion Control.andP;  Vol.andP;  13, no.andP;  1, Computers andamp; Graphics.andP;  pp.andO;m7-82, Pergamon Press (1989).andM;[32] Pintado, X., Tsichritsz, D.andP;  An Affinity Browser.andP;  In Active ObjectEnvironments D. Tsichritzis Ed.andP;  Centre Universitaire d'Informatique,Universite de Geneve, 1988.andM;[33] Pintado, X., Tsichritzis, D.andP;  Satellite: A Visualization and navigationtool for hypemedia.andP;  In Proceedings of the ACM Conference on OfficeInformation Systems (Apr.andP;  1990), pp.andP;  271-280.andM;[34] Prieto-Diaz, R., and Freeman, P.andP;  Classifying software for reusabiltiy.andO;IEEE Softw.andP;  (Jan.andP;  1987), 6-16.andM;[35] Profrock, A., Tsichritzis, D., Muller, G., and Ader, M.andP;  ITHACA.andP;  AnOverview.andP;  In Proceedings of the European Unix Users' Group (EUUG)Conference, (Spring 1990), pp.andP;  99-105.andM;[36] Reenskaug, T., and Nordhagen E.andP;  The Description of ComplexObject-Oriented Systems: Version 1.andP;  Senter for Industriforskning, Oslo,1989.andM;[37] Schilling , J.J., and Sweeney, P.f.andP;  Three steps to views: Extending theobject-oriented paradigm.andP;  In Proceedings of OOPSLA '89 (Oct.andP;  1989), pp.andO;353-361.andM;[38] Skarra, A.H., and Zdonik, S.B.andP;  The management of changing types in anobject-oriented database.andP;  In Research Directions in Object-OrientedProgramming.andP;  The MIT Press, Cambridge, Massachusetts, 1987, 393-415.andM;[39] Snyder, A.andP;  Encapsulation and inheritance in object-oriented programminglanguages.andP;  In Proceedings of OOPSLA '86 (Sept.andP;  1986), pp.andP;  38-45.andM;[40] Stroustrup, B.andP;  The C++ Programming Language.andP;  Addison-Wesley (1986).andM;[41] Taenzer, D., Ganti, M., and Podar, S.andP;  Problems in object-orientedsoftware reuse.andP;  In Proceedings of ECOOP 89 Conference, (July 1989),Cambridge University Press, pp.andP;  25-38.andM;[42] Thomas, D., and Johnson, K.andP;  Orwell: A configuration management systemfor team programming in Proceedings of OOPSLA '88 (Sept.andP;  1988), pp.andO;135-141.andM;[43] Utting, K., Yankelovich, N.andP;  Context and orientation in hypemedianetworks.andP;  ACM Transactions on Office Information Systems 7, 1 (Jan.andP;  1989),58-84.andM;[44] Wegner, P.andP;  Dimensions of object-based language design.andP;  In Proceedingsof OOPSLA '87 (Oct.andP;  1987), pp.andP;  168-182.andM;[45] Wirfs-Brock, R.J., and Johnson, R.E.andP;  A survey of current research inobject-oriented design.andP;  In CACM, (see this issue) Sept. 1990.andM;SIMON GIBBS is an assistant professor at the University of Geneva.andP;  Hisresearch interests include database support for software development,computer-supported cooperative work, multimedia systems, and semantic datamodeling.andM;EDUARDO CASAIS is a reseach assistant at the University of Geneva, from whichhe received a &quot;licence&quot; in business-oriented informatics.andP;  He is currentlyworking for his Ph.D.andP;  on clas reorganization in object-oriented systems.andM;OSCAR NIERSTRASZ is currently an assistant professor at the University ofGeneva.andP;  His current research interests include computational models forobject-oriented concurrency, and interactive tools for object-orientedapplication construction.andM;XAVIER PINTADO is a research assistant at the University of Geneva.andP;  He holdsa &quot;diplome&quot; in electrical engineering and a &quot;licence&quot; in information systems.andO;He is currently working for his Ph.D.andP;  on class selection and explorationwithin an object-oriented graphics approach.andM;DENNIS TSICHRITZIS is a professor of computer science and director of theCentre Universitaire d'Informatique at the University of Geneva.andP;  Hisresearch interests include object-oriented environments, databases and officeinformation systems.andO;</TEXT></DOC>