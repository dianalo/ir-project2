<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-584-088  </DOCNO><DOCID>08 584 088.andM;</DOCID><JOURNAL>Digital Review  June 18 1990 v7 n24 p29(3)* Full Text COPYRIGHT Cahners-Ziff Publishing Associates LP 1990.andM;</JOURNAL><TITLE>Translating a venerable language. (C programming language)(Software Review) (includes related articles on testingPromolu.Fortran 2.01 and translating Fortran into C) (evaluation)</TITLE><AUTHOR>Haskin, Denis W.andM;</AUTHOR><SUMMARY>Promula.Fortran 2.01, from Promula Development, allows users totranslate Fortran to the C programming language.andP;  Product testersm discovered that when converting Fortran to C, the VAX C compileris not as fast as the VAX Fortran compiler.andP;  Many Fortran elementsare also in C, in simpler forms.andP;  In general, tests demonstratethat Promula.Fortran is an extremely useful utility for users whomust translate large amounts of Fortran to C. The applicationtranslates quickly, generating C code that is usually immediatelyexecutable.andP;  The program, however, offers less than desirabledefault options and unsatisfactory handling of some I/O and DATAstatements.andP;  Promula.Fortran offers users control over the C codeand the application uses C language conventions.andP;  Extensivetesting procedures and results are discussed.andM;</SUMMARY><DESCRIPT>Company:   Promula Development (products).andO;Product:   Promula.Fortran 2.01 (Program translator).andO;Topic:     C Programming LanguageFORTRANEvaluationSoftware PublishersCode Conversion.andO;Feature:   illustrationprogramchart.andO;Caption:   Translating Fortran common blocks and simple I/O statements.andO;(program)Statistical analysis of benchmarks for VAXstation II/GPX. (chart)andM;</DESCRIPT><TEXT>TRANSLATING A VENERABLE LANGUAGEandM;TEST LABS BRIEFandM;PRODUCT: Promula.FortranandM;DESCRIPTION: Fortran-to-C source code translatorandM;VENDOR: Promula Development Corp. 3620 N. High St Suite 30: Columbus, OH43214 (614) 263-5454andM;TEST CONFIGURATION: Promula.Fortran version 2.01 installed on a VAXstation11/GPX running VMS 5.2andM;PRICE AS TESTED: $995andM;PROS: * Includes many command line options * Can produce various &quot;flavors&quot; ofC code * Supports all VAX Fortran data types except REAL [.sup.*.16] *Successfully translated STRUCTURE and RECORD declarations, including UNIONand MAP statementsandM;CONS: * I/O subroutine library did not work properly with ANALYSIS and PHILCO* Defaulted to pointer notation for representing arrays, which is unclear andless efficient in VAX C * Required dialect and error message files to becopied to current working directory for translation * Used double quotes forinclude file specifications but incorrectly defines VAXC$INCLUDE rather thanC$INCLUDE * Non-VMS-style command line optionsandM;READER SERVICE: Circle No.andP;  400 on Reader Service CardandM;The C programming language is the darling of the software industry.andP;  C ispowerful enough to be used for almost any programming task, such as writingthe Unix operating system, but concise enough to be portable and fairlyeasily implemented on different hardware platforms.andM;Fortran, on the other hand, is one of the doyens of programming languages.andO;While Fortran has enjoyed a long and fruitful life, one would be hard-pressedto argue that it will outlive C or other more modern languages, even with theforthcoming Fortran 8X standard.andP;  Although some applications will still findtheir niche in Fortran, many will be scrapped and migrated to anotherlanguage, no matter what form that language takes in the future.andM;Such migration from Fortran to C is not unreasonable; the two languages havemany common flow-control structures and data types.andP;  Some language features,however, differ significantly and require special attention.andP;  Items such asCOMMON blocks, EQUIVALENCE statements and Fortran's built-in I/O statements,to name a few, all require some expertise to translate into efficient C code.andM;Thus, migrating an application from Fortran to C combines the boring task oftranslating similar items with the difficult job of making Fortran'sidiosyncrasies work in the C style.andM;For many MIS managers, the most sensible route would be to employ atranslator, a program that takes the Fortran source code and produces itsequivalent in C code, which could then be compiled or modified as required.andM;Promula.Fortran from Promula Development is one such translator.andP;  Thisutility accepts an input file of Fortran source code and produces one or moreoutput files of C source code that perform the same task.andM;We tested Promula.Fortran version 2.01 on a VAXstation II running VMS 5.2.andO;The package is also available for MS-DOS.andP;  During our testing we found that,with the exception of I/O statements, Promula.Fortran produced excellent Ctranslations of Fortran source code.andP;  Thanks to Promula.Fortran's rich set ofcommand line options, we were able to produce several variations of C sourcecode from a given Fortran source.andM;We made a very interesting discovery during our evaluation of Promula.Fortranthat VMS users may want to consider before jumping on the Fortran-to-Cconversion bandwagon.andP;  The VAX C compiler is not as clever as the VAX Fortrancompiler, and the execution of even well-written C code may be only one-halfor one-third as fast as equivalent Fortran code.andP;  This is not because ofinherent failings in the C language, but instead from the VAX C compiler'schoices of instructions and addressing modes.andP;  (See &quot;Sneaky Fortran istranslated into lazy C,&quot; page 31.)andM;Many Fortran language elements can be found in C, albeit in simpler forms.andO;The ASSIGN, CALL, CONTINUE, DO, END, GO TO, IF and RETURN statements all haveequivalent C language constructs, although in some cases they may not have adirectly analogous statement and may look quite different.andP;  Thus, a DO can berepresented with a for and a DO..WHILE with a while.andP;  A computed GO TOstatement, however, might need to be translated into a combination of if andgoto statements.andM;The Fortran PAUSE statement has no equivalent C construct and must bereplaced with some I/O statements and a library function call.andP;  The STOP canbe replaced with some I/O statements and an exit call.andM;Promula.Fortran supports all VAX Fortran data types except REAL*16(quadruple-precision floating point).andP;  This is due to the fact that, of allthe data types, REAL*16 is the only one with no equivalent C language type.andO;Even Fortran's COMPLEX*16 has the equivalent dcomplex.andM;Promula.Fortran has no problem with VAX Fortran STRUCTURE and RECORDdeclarations, which it translates using C typedef, or with a STRUCTUREcontaining UNION and MAP statements.andM;Somewhat more difficult are some of the Fortran specification statements,which deal with the definition of variables and data within a program.andO;Although some are relatively straightforward, such as EXTERNAL and INTRINSIC,and others can be accomplished via specific declarations, like SAVE andDIMENSION, the two bugaboos are COMMON and EQUIVALENCE.andM;These are often a bane to Fortran neophytes, especially if users areaccustomed to structured, top-down programming.andP;  Although the global storagecreated by COMMON blocks can be achieved through a variety of means in the Clanguage, the variable interpetation of such COMMON blocks by EQUIVALENCEstatements can be more difficult to deal with.andM;We were impressed with how well Promula.Fortran handled such constructs,making sensible C code out of them.andM;Promula.Fortran provides four methods by which common blocks can betranslated (Fig.andP;  1).andP;  The first is to translate them to external storageareas and rever to them with pointers.andP;  The problem with this approach isthat the resulting pointer expressions (for example, Ta-andgt;c) are difficult toread and can be inefficient.andM;The second way is similar, but treats the external storage area as astructure.andP;  The reulting notation is similar to that in the first method, butis a bit cleaner.andM;The third option also uses a block of external storage, but references toelements in that structure are made via offsets from the beginning of thestructure.andP;  This translated code would be very difficult to maintain in its Cform because the variables themselves would have disappeared and beenreplaced by offsets.andM;The fourth and most desirable method does away with the idea of a commonblock entirely and just promotes each variable in the common block to be aglobal variable.andP;  This is the cleanest, most readable and most efficientmethod.andP;  Unfortunately, it cannot be used if common blocks are defined indifferent ways in different subroutines, a frequent practice in older Fortranprograms designed for machines with limited memory space.andM;For example, two common block statements--COMMON /A/ B,C,I,J and COMMON /A/I,J,B,C--can be defined differently.andP;  The /A/ indicates the same storagearea.andP;  However, azssuming implicit variable typing and default data sizes,the first declaration says the storage area has two single-precision floatsof 4 bytes each, followed by two integers of 4 bytes each.andP;  The seconddeclaration treats the same storage as two integers, followed by two floats.andM;This is a simple example, but it is quite possible that various data typeswould not be of the same size, and one declaration could have variables thatoverlap one or more variables in another declaration.andM;Command line options allow the user to specify which common block trnslationPromula.Fortan is to use.andP;  Unfortunately, this means only one method can beselected for each source file.andM;Finally, there the question of Fortran I/O statements .andP;  Fortran, unlike C,has builtin, predefined I/O statements.andP;  In C, all I/O is accomplished bycalls to to library functions.andP;  A standard I/O library of functions is usedalmost universally by C programmers.andM;Although powerful, that I/O library doesn't match the intricacies of FortranI/O.andP;  Translation of I/O statements is not straightforward in many cases.andO;Promula.Fortran will try to use the standard C library I/O routines whenpossible.andP;  When that isn't possible, however, it tackles this translationproblem by using its own set of I/O library routines.andM;We found that when Promula.Fortran was unable to use the standard C libraryI/O routines, even relatively simple Fortran I/O statements were translatedinto confusing, hard-to-follow code (Fig.andP;  2).andM;IN THE LANGUAGE LABandM;To test Promula.Fortran, we translated the DR labs CPU 2 Fortran benchmarkinto C and examined the resulting code and its efficiency.andM;We were quite pleased with the overall results, especially when we used a fewcommand line options to improve the clarity and efficiency of the C code.andM;Twenty-eight sets of options may be used with Promula.Fortran's PFC command,which invokes the software.andP;  These options govern everything frominterpretaton of the Fortran source code to where the brackets should be putin the C output, often a religious topic among C programmers.andM;Some options we employed included: GP, GS, GR and GV, which govern the commonblock translation method to be used; XS which directs Promula.Fortran to usebracket notation rather than pointer notation for arrays; and CHR, whichindicates that CHARACTER variables are to be translated character arraysrather than character strings.andM;Other command line options affect the interpretation of the Fortran sourcecode, the style and content of the output C code, translation features, andother items such as Fortran dialect, definition and pseudocode.andM;VMS aficionados may find it irksome that Promula.Fortran does not follow VMSconventions for specifying qualifiers to the PFC command, but instead usesUnix and MS-DOS conventions.andP;  The PFC translation command must be followed bythe name of the Fortran source file, which is followed by any command lineoptions to be given.andM;Although we were happy with the translation that Promula.Fortran produced, wedid encounter a few snags en route to that final C file.andP;  For instance, wehad to modify the format of a data file so that the ANALYSIS routine of ourCPU 2 suite could read it in.andM;VAX Fortran required that single quotes be put around the character variablesthat we were reading in.andP;  However, Promula.Fortran's translated code workedonly when we removed those quotes.andM;We also encoutered problems with the PHILCO subroutine because of its DATAstatement.andP;  (It is the only one of our routines that uses that form of datainitialization.)andP;  To make the DATA statement work properly, we had to move itto a BLOCK DATA program in a separate file.andM;One of the most surprising elements of the translation was howPromula.Fortran handled arrays.andP;  Its default setting converts Fortran arraysto C pointer notation, on the grounds that this is more efficient.andM;Thus, if CX is an array of real variables with the dimensions (25,101), theFortran statement AR=CX(5,I), is translated to ar = *(cx+4+i*25).andP;  Note thatPFC has tfaken the array arithmetic that is normally hidden and made itexplicit: cx is a pointer to the storage area, and 4+i*25 specifies theoffset into the storage area.andM;The entire expression is wrapped in *() so that it is used as a pointer andth value at the address the expression points to is copied to ar.andM;If the translation isn't clear, remeber that although multidimensional arraysare possible in higher-level languages, memory is really a single-dimensionarray.andP;  To change the two-dimensional reference into one dimension,Promula.Fortran multioplies the second index by trhe first dimension (i*25);adds it to the first index, which was changed from i5 to 4 becausePromula.Fortran uses zero-based arrays rather than one-based arrays; thenadds taht to the base address of the array (cx).andM;Remeber also that C will scale pointer arithmetic by the size of the dataassociated with the pointer.andP;  Thus, adding 4 to the base address cx willactually result in an address 16 bytes away because cx points tosingle-precision floating-point variables that are each 4 bytes in size.andM;Although pointer notation may be more efficient under other C compilers, thisapproach gains nothing with VMS.andP;  Not only is the code difficult to read, itis less efficient as well.andP;  The C statement ar = *(cx+4+i*25) results in thefollowing machine instructions:andM;MOVAL 20(R2),R0 ADDL2 #16,R0 MULL3 #25,8(R2),R3 ASHL #2,R3,R3 ADDL2 R3,R0MOVF (R0),20220(R2)andM;The equivalent ar = cx[i][4] C statement is compiled to much shortedinstructions:andM;MULL3 #25,8(AP),R0 MOVF 36(AP)[R0],20220(AP)andM;Although the long-word displacement indexed addressing mode used in thesecond statement is less efficient, having fewer instructions more than makesup for this.andP;  The second style runs faster.andM;Another item that Promula.Fortran users on VMS must beware of is single- anddouble-precision floating-point variables.andP;  This is not a problem withPromula.Fortran itself, but it can lead to unexpectedly inefficient code.andO;The VAX Fortran compiler treats REAL variables as single-precisionfloating-point variables, and Promula.Fortran translates them to C float datatypes.andM;This would be acceptable except that the VAX C compiler by default performsall arithmetic operations in double-precision style.andP;  The result is repeatedconversion of float data types of and from double-precision style.andP;  Thesimple solution to this problem is to compile the translated C code with the/PRECISION=SINGLE qualifier.andP;  Note that variables defined as double willstill be done with double-precision arithmetic.andM;We translated our CPU 2 benchmark with the default common blockimplementation and bracket notation.andP;  Propagating common block variables toglobals was not possible because of our inconsistent definitions of somecommon blocks.andP;  The resulting C code was compiled with the /PRECISION=SINGLEqualifier to ensure similar operations to the Fortran code.andM;We found that the translated C code ran, at best, neck-and-neck with theFortran originals, but on average was 0.61 times as fast (Fig.andP;  3).andP;  Theworst-performing kernel was GAMSIM, which ran 0.27 times as fast as itsFortran counterpart.andM;When we allowed Promula.Fortran to use pointer notation for array references(its default) rather than bracket notation, the execution fell to an averageof 0.59 times as fast as Fortran.andP;  The fastest routine was DWHET which, whencompiled with bracket notation, was 1.01 times faster than its Fortrancounterpart and almost exactly the same when compiled with pointer notation.andM;A closer look however, shows that much of the efficiency loss is not due toPromula.Fortran but to the VAX C compiler, which in many cases wasn't as goodas the Fortran compiler in generating efficient code.andM;Installing and using Promula.Fortran was easy.andP;  It was delivered in two VMSBACKUP save sets on a TK50 tape.andP;  We followed the instructions and used VMSBACKUP to copy the files from each save set to a new directory.andM;We used the [PROMULA.PFCTRN] and [PROMULA.PFCLIB] directories.andP;  The firstcontained the translator program itself and supporting files.andP;  The secondheld the object library needed for compiling C programs created withPromula.Fortran.andP;  The package included demonstration programs delivered in athird save set on the tape.andM;In order to use Promula.Fortran, we modified the PFCSET.COM command procedureso the PFC symbol invoked the PFC.EXE images, set the PFCLIB logical to pointto the [.PFCLIB] directory, and added the [.PFCTRN] and [.PFCLIB] directoriesto the list of translations for the VAXC$INCLUDE logical name.andP;  This name isconsulted by the VAX C compiler when resolving #include directives.andM;GOOD HOUSEKEEPINGandM;After executing the PFCSET command procedure, we thought we were ready to usePromula.Fortran, but found we had to attend to a few more housekeeping dutiesfirst.andM;Initially, the translator was unable to find either the PFC.PAK file, whichcontains a description of the Fortran dialect to be translated, or thePFC.ERR file, which contains error messages to be displayed byPromula.Fortran.andP;  The translator functions without the second file, butrequires the first.andM;We discovered a command line option to locate the PFC.PAK file explicitly,but the PFC.ERR file had to be moved into the current directory to be foundby Promula.FORTRAN.andP;  We deemed it easier to copy both files to the currentdirectory, but would have preferred that Promula.Fortran allow us to use alogical name or other means to indicate where these files resided.andM;Another problem arose because Promula.Fortran uses double quotes whenspecifying files to be included (for example, #include &quot;decs.h&quot;).andP;  When theVAXC$INCLUDE logical name is used to complete these references, however, thedouble-quote style does not use the logical name, whereas the single-quotestyle does.andM;The double-quote style would find the file to be included if the logical nameC$INCLUDE is specified, but PFCSET.COM did not specify this logical name.andM;In addition, Promula.Fortran has the interesting ability to write outpseudocode for the program being translated.andP;  The pseudocode is actually morelike machine code.andP;  It is unlikely that this code would be useful except,perhaps, in debugging a translation error or problem.andM;The nature of such translations dictates that the quality of a translation ismore important than its speed, but we also measured how fast Promula.Fortrantranslated Fortran source code into C.andM;Promula.Fortran translated an average of 16.69 lines per second with the 36fiels that constituted our CPU 2 benchmark suite.andP;  (The average number oflines perfile is 157.11.)andP;  On average, it required 7.18 seconds to perform atranslation.andP;  The fastest translation was the AIRREL routine (21 lines),which translated in 3.43 seconds, whereas the LUDD routine (765 lines)required 26.98 seconds.andM;Promula uses an interesting pricing scheme that might make prospective buyersanalyze programs to be translated before purchasing Promula.Fortran.andP;  Twoversions are available: one has a limit of 300 lines per subroutine, and theother has no limit on the number of lines per subroutine.andM;With the exception of some undesirable default options, less-than-idealhandling of some I/O statements and unsatisfactory handling of the DATAstatement, Promula.Fortran is a very useful utility for users who musttranslate large amounts of Fortran to C.andP;  It translates quickly and generateswell-written and--with some exceptions--immediately executable C code.andM;Promula.Fortran has options that give users control over the C code produced.andO;Promula.Fortran's C code is very amenable to C programmers; it uses Clanguage conventions and, to put it simply, &quot;feels&quot; like C.andM;TEST LABS MODELandM;We tested version 2.01 of Promula.Fortran on a VAXstation II/GPX with 13MB ofmemory running VMS 5.2 and DECwindows.andP;  Benchmark results from the VAXstationII are equivalent to those from a MicroVAX II.andP;  The system disk was a 135MBMicropolis 1355 and the two user disks were an identical Micropolis and a DECRD54.andP;  The system was not on a network during the test.andM;We focused on the qualitative aspects of Promula.Fortran's translationbecause the quality and maintainability of the C code produced is the mostimportant criterion for most Promula.Fortran users.andM;We examined how Promula.Fortran translated various data types, arrays,structures, control and conditional statements, and I/O routines.andP;  We wereparticularly interested in whether the resulting C code would be familiar toand could be maintained by an experienced C programmer.andM;To test the efficiency of the C code produced, we compiled it, executed itand compared the execution times for each kernel of the C translation againsthe execution times for the DR Labs CPU 2 Fortran benchmark.andM;Finally, we examined how much time Promula.Fortran required to perform itsFortran-to-C translations.andM;How sneaky Fortran translates into lazy CandM;We had high expectations for the efficiency of the C code produced byPromula.Fortran.andP;  It looked very efficient, and C enjoys a reputation as anefficient language.andP;  We found, however, that Promula's translated C code ranon average 0.61 times as fast as Fortran.andM;This sluggishness is not the fault of Promula.Fortran, but can be blamed onthe VAX C compiler.andP;  It seems that VAX C compiler designers should take heedof a few RISC philosophies.andM;The VAX instruction set is a rich one, full of many powerful instructions anda variety of addressing modes.andP;  Such an environment can often make thingseasier for compiler writers because the compiler needs to do less work andthe burden can be shifted to the hardware.andM;RISC machines are designed so that most, if not all, of their instructionsexecute in a single machines cycle.andP;  CISC machines, such as the VAX, havemore complex instructions and addressing modes available, but there is noguarantee that two similar instructions will execute in a similar amount oftime, or that one instruction will require the same amount of time when usedwith different addressing modes.andM;The LADIFF subroutine of our CPU 2 benchmark serves as a good example ofthis.andP;  The Fortran and C versions of this subroutine are almost identical,except for the syntactical differences between the two languages.andP;  Theprogram consists of two nested loops, with a series of arithmetic operationswithin the innermost loop involving floating-point scalars and arrayelements.andM;The machine code generated by the two compilers is also similar, but thereare some seemingly minor differences that become significant when it comes toexecution speed.andM;First of all, the Fortran compiler &quot;cheats&quot; a bit and uses a MOVL (move longword) instruction when it is really transferring a single-precisionfloating-point value between two locations.andP;  The C compiler uses the expectedMOVF (move floting point).andP;  The two instructions are equivalent in that theymove 4 bytes from one location to another.andP;  However, many VAX machineinstructions set condition bits in the processor status long word (PSL)depending on their result.andM;Both of the move instructions set the N bit if the destination is negativeand the Z bit if it is zero.andP;  Thus, while the function of MOVL and MOVF isthe same (to copy a 4-byte value from one location to another), the need toset these PSL bits makes their performance not quite identical.andP;  Operationsinvolving floating-point values are almost always slower than operationsinvolving integers.andP;  Checking a 4-byte floating-point value to see if it isnegative or zero takes more time than checking a 4-byte integer even if thetwo values are equivalent.andP;  On a MicroVAX II processor, the MOVF is 40.89percent slower than the MOVL.andM;It should be noted that even though all VAXes have identical instruction setsand are binary-compatible, not all implementations are the same.andP;  Thisdifference between MOVL and MOVF may be greater of smaller on other VAX CPUs.andM;Because the Fortran compiler knows it is not going to use the N and Zcondition bits, the MOVF and MOVL instructions are equivalent and it choosesthe faster one.andP;  The MOVL and MOVF instructions both do three things: Theymove 4 bytes from one location to another, set the Z bit in the PSL if whatwas moved is equal to zero and set the N bit in the PSL if what was moved isnegative.andM;If the goal is simply to move 4 bytes from one location to another withoutchecking the status of the N and Z bits (that is, it doesn't matter if it'szero or negative), then using either MOVL or MOVF will have the same effect.andO;Therefore, MOVL is preferred because it is faster than MOVF.andM;Similar performance gains may be made with addressing modes.andP;  In this samekernel, the C compiler used indexed displacement mode with a SUBF3instruction, whereas the Fortran compiler used displacement mode.andM;On a MicroVAX II processor, the SUBF3 is 37.4 percent slower when the firstoperand is addressed via indexed displacement mode than when it is addressedvia the displacement mode.andM;Based on our examination of the machine code produced by the Fortran and Ccompilers, it would be a good idea for DEC to send the VAX C compiler team ona filed trip to the Fortran compiler officers, or better yet, to theRISC/Ultrix compiler team.andO;</TEXT></DOC>