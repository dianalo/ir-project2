<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF107-888-026  </DOCNO><DOCID>07 888 026.andM;</DOCID><JOURNAL>PC Magazine  Dec 12 1989 v8 n21 p337(6)* Full Text COPYRIGHT Ziff-Davis Publishing Co. 1989.andM;</JOURNAL><TITLE>Arithmetic routines for your computer programs, part 3. (Powerprogramming) (column)</TITLE><AUTHOR>Duncan, Ray.andO;AttFile:   PCMAG\V08N21\MPDIV.ASM;0 Program:  MPDIV.ASM  Division routine.andO;PCMAG\V08N21\MPIDIV.ASM;0 Program:  MPIDIV.ASM  Division routine.andO;PCMAG\V08N21\MPMUL2.ASM;0 Program:  MPMUL2.ASM  Multiplication routine.andO;PCMAG\V08N21\TRYMPDIV.ASM;0 Program:  TRYMPDIV.ASM  MPDIV Demo.andO;PCMAG\V08N21\TRYMPDIV.EXE;2 Program:  TRYMPDIV.EXE  MPDIV Demo.andO;PCMAG\V08N21\TRYMPMUL.ASM;0 Program:  TRYMPMUL.ASM  MPMUL Demo.andO;PCMAG\V08N21\TRYMPMUL.EXE;2 Program:  TRYMPMUL.EXE  MPMUL Demo.andM;</AUTHOR><SUMMARY>Classical algorithms for multiplication and division arediscussed, and sample assembly-language code is presented.andP;  Thealgorithms are based on the longhand methods taught in elementaryschools and are applied to binary numbers.andP;  Both multiplicationand division can be simplified into 'shift and add' loops; mostpeople know these procedures instinctively but never attempt tounderstand how they work.andP;  One method of shift-and-addmultiplication involves initializing a buffer that will receivethe product, initializing the loop counter to 8 times the lengthof each argument, clearing the carry flag, logicallyright-shifting the buffer containing each argument and the formingproduct by one bit position each, saving the bit shifted out inthe carry flag, and adding appropriately when the carry flag isset.andP;  Shift-and-subtract division follows an essentially similarprocedure.andM;</SUMMARY><DESCRIPT>Topic:     Programming InstructionAlgorithmsType-In ProgramsTutorialProgramming.andO;Feature:   illustrationprogram.andO;Caption:   MPMUL2.ASM (program)MPDIV.ASM (program)andM;</DESCRIPT><TEXT>Arithmetic Routines For Your Computer Programs, Part 3 The classicalarithmetic algorithms that underlie the longhand procedures we all use forinteger addition, subtraction, multiplication, and division have been wellunderstood for hundreds of years.andP;  Indeed, the term algorithm originallyreferred only to the formalized procedures for these arithmetic operationsand is actually a corruption of the name of renowned Arab mathematicalal-Khwarizmi.andM;The classical algorithms are important not only to schoolchildren but toprogrammers and computer designers as well.andP;  The algorithms are thefoundation for hardware adders, multipliers, and dividers, and for the designof software routines that can carry out arithmetic operations that are notsupported in hardware.andM;Schoolchildren are typically taught the how without the why when it comes tobasic arithmetic.andP;  I found it quite enlightening to look closely at theclassical algorithms (particularly for multiplication and division) and torealize the extent to which I had been basing these longhand procedures onfaith rather than understanding.andM;The aspiring programmer's ultimate resource on the classical algorithms (andon a mind-boggling assortment of other topics as well) is Donald Knuth's TheArt of Computer Programming.andP;  Knuth combines a gift for clear writing with adepth of mathemtical insight and a breadth of knowledge and experience thathave few parallels in these days of superspecialized professors.andP;  Dr. Knuthneeds no favorable reviews from me, of course; although his three volumes (sofar) may at first appear intimidating, it is a truism to say that they shouldbe on the bookshelves of all but the most casual programmer.andM;Knuth's discussion of the classical algorithms appears on pages 229-45 ofvolume 2, Seminumerical Algorithms.andP;  Unfortunately, however, his programexamples are rendered in MIX, the assembly language of a hypothetical CPU forwhich simulators exist only in the halls of academe.andP;  Accordingly, in thelast installment of this column, I presented high-level, radix-independent,pseudo-C translations of Knuth's example routines for addition, subtraction,and multiplication.andP;  We then used this pseudo-code as a guide for theimplementation of corresponding assembly language subroutines.andM;I don't plan to take this approach for division, however, because theclassicial algorithm for radix-independent division is rather complex andsubtle.andP;  If you recall long division as one of the major sore points of yourfirst few years of grade school--something that caused significantly moremental anguish than addition, subtraction, and multiplication--there is agood reason for it.andP;  Long division requires normalizations, groupings, and&quot;trial divides&quot; that do not reduce readily into a simple, easily understoodpiece of radix-independent pseudo-C code.andM;Luckily, however, there is a solution that will suffice nicely for thepurposes of this column.andP;  When working in binary (radix = 2), the classicaldivision algorithm degenerates to a considerably simpler form that wetypically see implemented in a shift-and-subtract loop.andP;  The multiple trialdivides that are often needed for each forward step in the generalized formof the algorithm--not to mention the logic necessary to pick trial divisorsintelligently--go away completely in binary.andP;  Similarly, when used for binarymultiplication, the classical algorithm can be simplified into a short andsweet shift-and-add loop.andM;&quot;Ah yes,&quot; I can almost hear you saying, &quot;the good old shift-and-add andshift-and-subtract methods of multiplication and division.&quot;andP;  Why--even atthis considerable distance--can I almost hear you saying this?andP;  Because ofall the times I've muttered it to myself, of course!andP;  We all are familiarwith these types of routines, and we feel instinctively that we understandhow they work--or could understand easily if we only bothered to try.andP;  Wehave day-to-day experience with using a left shift for a fast multiply by 2and a right shift for a fast divide by 2.andP;  We've all taken the commonly usedmultiply-by-10 shortcut that relies on a couple of shifts and an add.andM;But few of us are actually ever called upon to write one of thesemultiplication or division routines, and in practice they are not quite as&quot;obvious&quot; as we fondly imagine.andP;  On the other hand, there is certainlynothing magical about such routines; they turn out to be quitestraightforward when given the usual attention to detail.andM;In this column, I'll provide cookbook methods for writing multiplication anddivision routines that will serve you well on any reasonable CPU (the nastyCPUs that use 1s'-complement arithmetic or lack a carry flag are betteravoided than conquered), and then I'll illustrate these methods with workingcode.andM;RECIPE FOR SHIFT-AND-ADD MULTIPLYandM;The following procedure assumes that you are multiplying two arguments(sometimes called the multiplier and multiplicand) that are the same length(in bytes) to obtain a product that is twice the length of either argument.andO;The arguments and the product are further assumed to be unsigned; handlingarithmetic signs and checking for zero arguments is best done in a &quot;shell&quot;routine external to the fundamental multiplication procedure.andP;  This allowsroutines that need maximum speed and that have control over their argumentsto call the unsigned routine directly, achieving best performance.andP;  Lastly,it is assumed that your CPU has a carry flag that is under direct programcontrol, and that it has both right and left shift instructions that worktogether with the carry flag, allowing you to remove a bit from one byte andinsert it in another.andM;Given these assumptions, the steps in the recipe are as follows:andM;(1) Initialize the high half of the buffer that will receive the product to0.andP;  (The low half will be discarded by shifting, so its original value isunimportant.)andM;(2) Initialize the loop counter to 8 times the length of each argument (inbytes); this is the number of binary &quot;digits&quot; (bits) in the multiplier thatmust be tested.andM;(3) Clear the carry flag.andM;(4) Logical right-shift the buffer that contains the forming product by onebit position; the value that is in the carry flag becomes the new mostsignificant bit of the product.andM;(5) Logical right-shift the buffer that contains the second argument (themultiplier) by one position; the &quot;lost&quot; bit shifted out is saved in the carryflag.andM;(6) If the carry flag is clear (that is, if the bit shifted out of themultiplier was 0), go to step 8.andM;(7) If the carry flag is set (that is, if the bit shifted out of themultiplier was 1), add the first argument (the multiplicand) to the high halfof the forming product.andP;  Any overflow of this addition is saved in the carryflag.andM;(8) Decrement the loop counter, preserving the carry flag; if the loopcounter is nonzero, go to step 4 and continue.andM;To understand what's going on here, just think back to the longhand techniquefor multiplying decimal numbers.andP;  Each digit of the multiplicand ismultiplied by each of the digits of the multiplier to obtain a set of partialproducts.andP;  After appropriate shifting, the partial products are addedtogether to form the final product.andM;In binary multiplication, each &quot;digit&quot; of the multiplier can only be a 0 or a1, so each &quot;partial product&quot; that needs to be accumulated is either 0 or theappropriately shifted value of the multiplicand.andP;  The rest is just trickeryto make everything end up in the correct position.andM;SHIFT-AND-SUBTRACT DIVIDEandM;In the next procedure, the assumption is that you are dividing an unsigneddividend by an unsigned divisor to get an unsigned quotient and an unsignedremainder.andP;  The dividend is further assumed to be twice the length (in bytes)of the divisor; both remainder and quotient are the same length as thedivisor.andM;Again, signs, zero divisors, overflow, and other odd conditions should behandled outside the core unsigned division routine; this allows routines thatrequire maximum speed and that have control over their arguments to call theunsigned routine directly.andP;  Finally, it is assumed that the characteristics(shifts and carry-flag control) demanded of the CPU for the shift-and-addmultiplication routine also apply for the shift-and-subtract divide routine.andO;The steps in the recipe become:andM;(1) Set the loop counter to the value that is 8 times the length of thedivisor (in bytes); this is the number of bits of quotient and remainder thatneed to be generated.andP;  The initial value in the buffer that will receive thequotient is unimportant because it will be discarded by shifting during theprocedure.andM;(2) Clear the carry flag.andM;(3) Left-shift the quotient by one bit position; the previous value of thecarry flag is inserted into the quotient as the new least significant bit.andM;(4) Left-shift the dividend by one bit position; the bit shifted out is savedin the carry flag.andM;(5) If the carry flag is clear, go to step 7.andM;(6) Subtract the divisor from the upper half of the dividend.andP;  Set the carryflag and go to step 8.andM;(7) If the upper half of the dividend is larger than the divisor, go to step6; otherwise, clear the carry flag and go to step 8.andM;(8) Decrement the loop counter, preserving the state of the carry flag; ifthe loop counter is nonzero, go to step 3.andM;(9) Left-shift the quotient by one bit position, bringing the carry flag intothe quotient as the final least significant bit.andP;  (Moving this last shiftoutside the main loop is not really necessary, but it allows the use of aslightly more efficient control structure.)andP;  The remainder is whatever isleft in the high half of the dividend.andM;Again, when attempting to understand what is going on in this procedure, itis helpful to draw analogies to longhand decimal division.andP;  The importantdistinction, however, is that trial divides are not necessary when we chooseto view each bit as a single digit; either the divisor can fit into theportion of the dividend we are looking at or it can't.andP;  We use shifting as aconvenient shortcut to inspecting groups of the dividend's digits that arethe same length as the divisor.andP;  The rest is just bookkeeping and positioningof the results.andM;MULTIPLE-PRECISION ROUTINESandM;Figures 1 through 3, plus MPIMUL.ASM and MPNEG.ASM presented last time,contain the source code for assembly language procedures that illustrate whatwe've been discussing here and that round out our battery ofmultiple-precision arithmetic routines.andP;  The calling procedures and resultsof each routine are documented in the listings.andM;MPMUL2.ASM, shown in Figure 1, is the unsigned multiple-precision-integermultiplication routine that uses the shift-and-add technique.andP;  You may findit instructive to compare this code with the MPMUL1.ASM published here in theprevious issue.andP;  The latter used the CPU's native 8-bit-by-8-bit multiply,and you may wish to run some timing comparisons of the two routines.andP;  Whenrunning benchmark tests, remember that there are drastic differences in thecost of a hardware multiply as you progress from the 8086/88 to the 80386 and80486.andM;MPIMUL.ASM is the signed multiple-precision multiply routine.andP;  It checks thesigns of the arguments to determine the sign of the eventual result, changesarguments from negative to positive if necessary (using MPNEG.ASM), thencalls MPMUL2.ASM to do the hard work.andM;MPDIV.ASM, shown in Figure 2, is the unsigned multiple-precision divideroutine that implements the shift-and-subtract technique described earlier.andO;If you're feeling spunky, read Knuth (volume 2, pages 237-38) and code a newversion of this routine that exploits your CPU's native DIV instruction.andM;MPIDIV.ASM, shown in Figure 3, is the signed multiple-precision divideroutine that checks and changes signs of arguments and results, much in thesame way as MPIMUL.ASM.andP;  It calls MPNEG.ASM and MPDIV.ASM.andP;  Note that callsto MPIDIV.ASM should be avoided if you know that the sign of your argumentsand results is not important (for example, when manipulating addresses),since MPIDIV is slower than PMDIV.andM;I've tried to make these routines reasonably efficient, though to keep themfrom diverging too far from the recipes presented above, I have forgone anumber of optimizations that I would use in a production program.andP;  Onceyou're sure you understand the code you can entertain yourself for hours bytuning it up further.andP;  Just beware of introducing machine instructions thataffect the carry flag!andM;I've also written two interactive demonstration programs, TRYMPMUL.ASM andTRYMPDIV.ASM, that will facilitate your experiments.andP;  These programs promptyou for arguments, call the appropriate multiply or divide routine, thendisplay the results.andP;  Because of their length, TRYMPMUL and TRYMPDIV are notprinted here, but both are available for downloading from PC MagNet.andM;THE IN-BOXandM;Please send your questions, comments, and suggestions to me at any of thefollowing e-mail addresses: PC MagNet: 72241,52 MCI Mail: rduncan BIX:rduncan</TEXT></DOC>