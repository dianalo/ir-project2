<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-238-544  </DOCNO><DOCID>08 238 544.andM;</DOCID><JOURNAL>Computer Language  March 1990 v7 n3 p17(6)* Full Text COPYRIGHT Miller Freeman Publications 1990.andM;</JOURNAL><TITLE>Setting the standard. (developing standards for programminglanguages)</TITLE><AUTHOR>Plauger, P.J.andM;</AUTHOR><SUMMARY>A discussion of the development of a standard for the Cprogramming language is continued with an emphasis on lessonslearned in the process that can be applied to any standardsdevelopment effort.andP;  Producing a standard is a difficult processmade harder by the fact that few standards committee members haveprevious experience in the process and by the lack of standardsfor making standards.andP;  It is beneficial to think of the standardas a treaty between implementors and users that delineatesfeatures that implementors must provide and that users cantherefore rely on, while allowing implementors some latitude inthe provision of certain features while alerting users to the factthat some features may contain variations.andP;  Clauses in standardsmust be couched in terms of 'shall' and 'must', not 'should'.andO;Standards can not address the quality of implementation, nor canit specify how an implementation is to accomplish what it mustaccomplish.andP;  Terminology must be precise.andM;</SUMMARY><DESCRIPT>Topic:     StandardsC Programming LanguageTutorial.andM;</DESCRIPT><TEXT>Setting the standard Last month I harangued at length about the politics ofdeveloping the C standard.andP;  I endeavored to explain why politics, thatmuch-maligned field, must necessarily spill over into technology.andP;  Much asyou might like to believe that only technical decisions should matter informing a programming language standard, the real world simply doesn't workthat way.andP;  It takes the machinery of politics to work out many of thedifferences that inevitably arise.andM;I continue that discussion with a different emphasis--imparting some of thepragmatic lessons I and other members of X3J11 learned while producing thedraft standard for C.andP;  If you find yourself involved in a similar activity,you can benefit from a few pointers.andP;  (Trust me.)andP;  Even if you don't getinvolved, you should learn to respect the efforts of those who do.andM;Making a standard is not easy.andP;  It is worsened by the fact that few peopleparticipate in more than one standards effort.andP;  (I have a theorem that a saneperson moves between zero and one pianos in a lifetime.andP;  You may never haveoccasion to move one.andP;  But once you move a piano, you learn never to do itagain.)andP;  That means each committee must start afresh in learning to build astandard.andM;Occasionally an old hand drifts into a new venture.andP;  X3J11 was fortunate tohave one or two veterans of FORTRAN and Pascal to give us occasionalguidance.andP;  But we didn't use them enough because of another impediment todeveloping a language standard: the lack of standards for making standards.andO;That makes it very easy for each new committee to ignore the past and do it&quot;right&quot; this time.andM;Look at the major language standards and you will see what I mean.andP;  FORTRANis on its third iteration.andP;  It is evolving under control of a committee thatfeels obliged to reinvent the language every dozen years or so.andP;  COBOL israther similar, except that it is broken into a dozen components, each withdifferent levels of support permitted.andP;  The last time I looked, 4,096acceptable configurations existed for a COBOL implementation.andM;Then you have PL/I, where the committee invented a formal language todescribe the semantics more precisely.andP;  It may be more precise, but it ismuch less approachable than the narrative descriptions favored for FORTRANand COBOL.andP;  And PL/I is still more easily understood than the ALGOL 68standard.andP;  That committee invented a language to describe a language topresent a grammar that expands to a grammar that defines ALGOL 68!andM;C comes closest in spirit to the Pascal standard.andP;  The latter was basedheavily on the classic language description by K. Jensen and N. Wirth.andP;  [1] The Pascal committee worked it over but left many parts intact.andP;  They alsochose not to address the many commercial extensions needed to make Pascal amore pragmatic language.andM;Committee X3J11 began with the widely accepted definition of C given inAppendix A of The C Programming Language.andP;  [2]  We worked the wording overquite a bit but left the language remarkably intact.andP;  Our major addition wasto describe the C operating environment and run-time library in detail.andO;Neither issue was addressed in Appendix A.andM;We spent much of the first few meetings just learning how to proceed.andP;  Onesubgroup studied formal specification methods.andP;  After a bit of anguish, thecommittee stuck with a narrative description.andP;  The C standard contains veryprecise notation for the formal grammar.andP;  Otherwise it relies on reasonablyprecise English descriptions for constraints and semantics.andP;  A few peopleregret this decision, but it was generally agreed that the job would havebeen much harder had we tried for more formality.andM;To me, the most important early decisions we made bordered on thephilosophical.andP;  For example, we accepted from the start that a standard is atreaty.andM;On the one side you have the implementors.andP;  A standard dictates certainfeatures that implementors must provide.andP;  It also provides latitude in howsome features are provided.andP;  On the other side you have the customers.andP;  Astandard promises certain features customers can rely on.andP;  It also warnsabout permissible variations in some features.andM;Every statement in a standard must help delineate the meeting ground betweenimplementors and users.andP;  Otherwise the statement is deadwood.andP;  Some areas canbe intentionally left gray.andP;  Treaties rarely fail to provide some form ofdemilitarized zone where neither side can safely tread.andP;  But there must be nowishy-washy clauses that fail to constrain either side.andM;It does you no good, for example, to have a standard say what animplementation or a program &quot;should&quot; do.andP;  The operative verbs are &quot;shall&quot; and&quot;must.&quot;andP;  Equally, a standard must not have constraints so weak that they aretrivially circumvented.andP;  These provide rubber teeth at best.andM;Having said that, I must report that the C standards has its wimpy moments.andO;On several occasions we describe what we &quot;intend&quot; to have happen withoutreally requiring it.andP;  Those occasions are places where C encounters a variedand sometimes ill-suited external environment.andP;  We did not want to say thatan implementation is nonconforming, for example, because it lets you write toa printer that fails to expand horizontal tabs.andM;The standard is at its wimpiest when trying to mandate certain capacityrequirements on every conforming implementation.andP;  In the end, all we couldagree on was that each implementation had to demonstrate that it couldsuccessfully translate and execute a test program.andP;  That test program had tocontain at least one example of every translation limit being met.andP;  Eachvendor was at liberty to contrive a unique test program.andP;  We all agreed thatthis was worse than rubber teeth.andP;  It was rubber gums.andM;On the other hand, the standard is not the only arbiter in the choice of Ctranslators.andP;  The marketplace is very competitive.andP;  You can contrive animplementation that manages to simultaneously conform to the C standard andbe useless.andP;  That's a wonderful joke on X3J11 and an intellectual curiosity.andO;But it is not a salable product.andM;We had to admit that &quot;quality of implementation&quot; was one vast area thestandard simply could not address.andP;  We couldn't mandate that C be compiledinto efficient code.andP;  We couldn't demand that C use the native data types ofa machine in the obvious way.andP;  We couldn't even dictate that a givenimplementation of C be minimally useful.andP;  We could argue about where to drawthe line (and we often did), but we all admitted that every issue had a linebeyond which the standard had to give up and let market forces reign.andM;Closely allied to these considerations was something we came to call the &quot;asif&quot; rule.andP;  It reminded us that we could only specify so much in tellingimplementors where to get off.andP;  We could specify what an implementation hadto accomplish; we could not specify how it would accomplish it.andP;  This is trueeven when the language seems to require specific underlying machinery.andP;  Allthe standard can dictate is that an implementation behave &quot;as if&quot; themachinery were present.andM;A telling example is the requirement for separate compilation.andP;  Central tothe design of C, and one of its strengths, is that it lets you translate aprogram in pieces and later paste them together.andP;  Many concepts are artifactsof separate compilation, such as external identifiers, constant expressions,and libraries.andP;  Nevertheless, more than one company offers C as an integratedenvironment centered around an interpreter.andM;An interpreter has many advantages in developing and debugging programs.andP;  Thestandard does not outlaw such interpreters.andP;  It merely requires them toperform certain operations as if they had separate translation and linkingphases.andP;  (They can produce smarter diagnostics in many cases, but they don'thave to.)andP;  And it lets traditional compilers and linkers off the hook inseveral critical ways.andP;  The standard requires no diagnostics or other checksthat go beyond the capability of traditional compilers.andM;Once we got comfortable with the &quot;as if&quot; rule, we found it quite liberating.andO;It let us describe semantics in several areas in terms of simple machinery.andO;The machinery need not be efficient in its own right.andP;  It need not evencorrespond to any likely implementation.andP;  It merely has to give a clear andcomplete operational definition of compliance.andP;  So long as an implementationcan do a good job and still behave as if it encompasses the simple machinery,it is blessed as conforming.andM;Treaty points, quality of implementation, and the &quot;as if&quot; rule are delicateconcepts.andP;  They are easily misconstrued in the heat of debate.andP;  More than onediscussion within X3J11 chased its tail until everyone got in sync with themeanings of a few words.andP;  Surprisingly, once the issues were clearlydelineated, they were often quickly dispatched.andM;Occasionally people found they all agreed.andP;  Sometimes a majority decision wasreached.andP;  On a few critical points, several rounds of debate were needed toform consensus.andP;  Rarely did deep rifts appear that took years to resolve.andM;What this taught us was the need for precise terminology in critical areas,the two most critical of which involved how we determined the conformance ofprograms and implementations.andP;  Neither area is as black and white as youmight first believe.andM;The problem with characterizing programs is sorting accusations.andP;  Say aparticular program contains a function call with two argument expressions.andO;Correct execution of this program occurs only when the first argumentexpression is evaluated before the second.andP;  That requirement conflicts with alatitude that has been in C since Dennis Ritchie's first compiler.andP;  Animplementation has traditionally been free to evaluate arguments in whateverorder it chooses.andM;The committee continues this license in Standard C.andP;  So here is a case wherethe treaty says implementors have fewer obligations than programmers.andP;  Theprogram is ill-formed.andP;  The problem is how to characterize such a deformity.andM;If a deformity is serious and easily detected, it may be desirable to requireeach implementation to diagnose the flaw.andP;  (It's not easy to detect orderdependence among function argument expressions, serious as it may be.)andP;  Or itmight be preferable to require no diagnostic but to require eachimplementation to document what it does.andP;  (It's not advisable to giveprogrammers any assurance in this arena.)andM;The committee might also elect to let the implementors off the hookaltogether.andP;  It might be desirable to permit each implementation to vary butnot require it to say what it does.andP;  (An implementation might even dosomething different as the barometric pressure changes.)andP;  Then the issue iswhether the program is branded as flawed simply because it uses a featurethat can vary.andP;  (In this case, programs call functions with multiplearguments all the time.andP;  A program should be flawed only if it is a suckerfor order dependence, not simply because it contains order dependencies.)andM;What all this means is that every sin a program can commit must be sortedinto some bin.andP;  (Yes, we're talking sin bins.)andP;  The bin has a name that givessome hint as to the nature of the transgression.andP;  The bin also has a set ofrequirements that guide both implementor and programmer.andP;  Here are the binsX3J11 eventually settled on:andM;* Erroneous behavior is incorrect program behavior that must be diagnosed.andO;Any C program containing the sequence if if must be erroneous.andP;  It isdetectable with known technology by single-pass compilers with separatelinkers and is too serious to ignore.andM;* Implementation-defined behavior is correct program behavior that can varyamong implementations.andP;  Each implementation must, however, document what itdoes in this area.andP;  The code value for the character constant 'a' isimplementation-defined.andM;* Locale-specific behavior is like implementation-defined behavior exceptthat it is specifically permitted to vary among international locales.andP;  Howcharacters collate is locale-specific.andM;* Unspecified behavior is also like implementation-defined behavior, exceptthat an implementation need not document what it does.andP;  The order ofevaluation of argument expressions, cited previously, is unspecified.andM;* Undefined behavior is incorrect program behavior that an implementation canbut need not diagnose.andP;  Arithmetic overflow during program execution isundefined behavior.andP;  On some implementations it is easily diagnosed.andP;  Onothers the cost of diagnosing every potential overflow would be prohibitive.andO;So the standard puts the burden entirely on the programmer.andM;It took the committee a while to determine all these bins and a little longerto tweak them into shape.andP;  Even now minor disagreements remain overinterpretation.andP;  Some people think you can document implementation-definedbehavior, for example, by saying, &quot;One of the following three things willhappen&quot; or &quot;the computer will halt and catch fire.&quot;andP;  Others feel that theseare cop-outs not in the spirit of the standard.andM;But don't let this distract you from the overwhelming importance of the bins.andO;By defining them early, the committee had a specialized vocabulary fordiscussing the C language, letting people capture subtle thoughts with fewerwords.andP;  That saves repeatedly reinventing the same thought with a hundredvariations.andP;  It also keeps new ideas from getting lost in the welter of olddebates about bins.andP;  We might argue about which bin a given lapse shouldoccupy, but such arguments converge.andM;Arguments that do not converge are rooted in fear.andP;  A sure recipe for heateddebate is to cry, &quot;If the standard says that, it will break my program.&quot;andO;That happens to be a C programmer's shorthand for a more long-windedstatement: &quot;My program works fine right now, thank you, and I want to keep itthat way.andP;  Require me to change my compiler to conform to this standard andthe compiler will cough on my program.andP;  I'll have to change a million linesof code in unspecified places.&quot;andM;The C standard classifies the vast bulk of existing code as potentiallynonportable.andP;  That's not news to anyone with experience porting C code.andP;  Youmay have code that works fine with 10 compilers and that fails on theeleventh.andP;  A principal reason for developing the C standard is to increaseyour chances of writing truly portable C code if you want to.andM;The C standard also &quot;breaks&quot; remarkably little code.andP;  Only where a practicehas been made erroneous must every implementation cough on a program.andP;  (Manyof these are clean breaks, as when one of your identifiers now collides witha new keyword.andP;  They are easily caught and cured.)andP;  Otherwise, existingimplementations are generally at liberty to translate nonportable constructsjust as they always have.andP;  The code is no more broken than it ever was.andM;I can't assert that all tail-chasing debates ceased once the bins gotdefined.andP;  But the bins sure helped.andP;  Creating the bins and sorting theprogramming gaffes into them was probably one of the biggest contributionsthe committee made to clarifying C.andM;The other major problem I mentioned was characterizing implementations.andP;  Thatproblem centers around extensions.andP;  Everybody has them.andP;  Everybody wants tokeep them.andP;  (Or you break their code, in the true sense of the phrase.)andP;  If astandard doesn't permit extensions, it will be ignored.andP;  If a standardpermits too many extensions, it is toothless.andP;  How do you strike asatisfactory balance?andM;The trick we settled on involves a sexy little three-step dance.andP;  First wedefine a &quot;strictly conforming program&quot; as using no extensions.andP;  Further, itproduces no output that depends upon unspecified, undefined, orimplementation-defined behavior.andP;  In other words, &quot;strictly conforming&quot; isessentially synonymous with &quot;portable.&quot;andM;The next step in the dance is to define a &quot;conforming implementation.&quot;andP;  (Theimplementation can be either hosted or freestanding, but that is anothermatter.)andP;  A conforming implementation must successfully translate and executeany strictly conforming program.andP;  (The implementation can fail because theprogram exceeds one of its limitations, but that too is another matter.)andP;  Sofar so good.andM;The final step in the dance is the cute one.andP;  It defines a &quot;conformingprogram&quot; as one acceptable to a conforming implementation.andP;  The program neednot be portable.andP;  It can take advantage of all sorts of extensions.andP;  It justhas to translate and run.andM;At first blush, this looks like more rubber teeth.andP;  What's to prevent a Ccompiler from accepting COBOL and BASIC programs as extensions?andP;  Animplementor's extension of C can be limited in two ways.andM;The first comes from the definition of conforming implementation.andP;  You cannotextend C in any way that alters the meaning of a strictly conforming program.andO;You can give meaning to undefined behavior since no strictly conformingprogram can indulge in undefined behavior.andP;  You cannot, for example, redefineif or printf.andM;The second limitation comes from the definition of erroneous behavior, whichthe standard lists as any violation of the syntax rules or specificallystated constraints.andP;  An implementation is obliged to diagnose suchviolations.andP;  That makes it hard for an implementor to extend C to parselaundry lists and old programming languages.andM;The effect of this balancing act is to leave room for extensions.andP;  At thesame time, the form and scope of extensions are circumscribed.andP;  You can trusta conforming implementation to compile programs that you intend to beportable.andP;  You can also trust it to diagnose obvious nonsense.andP;  But you alsoknow the areas where you can stumble across extensions.andM;That illustrates the final bit of philosophy that committee X3J11 decided onfrom the outset.andP;  We knew that C lets you write surprisingly powerfulportable programs.andP;  We wanted to increase the potential power of suchprograms.andP;  We also knew that C lets you write programs that are intentionallynot portable.andP;  We wanted to endorse this practice and not penalize itspractictioners.andP;  Our goal was thus to give programmers a fighting chance atwriting portable programs.andP;  Not a safe ticket by outlawing nonportableconstructs.andP;  Not a free ride by requiring heroic measures of run-timesystems.andP;  Just a fighting chance.andM;That's more than most languages give.andP;  That's all most C programmers ask for.andO;I think we gave it to them.andM;ReferencesandM;[1] Jensen, K., and N. Wirth.andP;  Pascal User Manual and Report.andP;  Heidelberg,F.R.G.: Springer Verlag, 1974.andM;[2] Kernighan, B., and D. Ritchie.andP;  The C Programming Language.andP;  EnglewoodCliffs, N.J.: Prentice Hall, 1978.andM;P.J.andP;  Plauger has been a writer of textbooks, a prolific programmer, and asoftware entrepreneur.andP;  He has been active in the development of standards,most notably for the C programming language.andO;</TEXT></DOC>