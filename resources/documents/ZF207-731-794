<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-731-794  </DOCNO><DOCID>07 731 794.andM;</DOCID><JOURNAL>Computer Language  Oct 1989 v6 n10 p67(8)* Full Text COPYRIGHT Miller-Freeman 1989.andM;</JOURNAL><TITLE>Intelligent databases and object-oriented languages.andO;</TITLE><AUTHOR>Chignell, Mark H.andM;</AUTHOR><SUMMARY>The combination of expert systems, database management andobject-oriented programming yields substantial computing power,which is an appealing strategy since it allows the user todirectly manipulate the database's semantics.andP;  Other capabilitiesof this integration include: sophisticated transitive-closure andrecursive queries, customized front ends, expert rules on datathat can be programmed without an external expert system tool andintegrity constraints of databases that can be used and enforcedin a natural, nonprocedural way.andP;  The main element in integratingexpert systems and databases is a knowledge-based approach torelations, with access occurring as an important part of inferenceprocesses.andM;</SUMMARY><DESCRIPT>Topic:     Expert SystemsData Base Management SystemsObject-Oriented ProgrammingTutorialIntegrated Systems.andM;</DESCRIPT><TEXT>Intelligent Databases and Object-Oriented Languages Intelligent databasesrequire an advanced development environment that includes hypertext,knowledge engieering, text management, and database management facilities.andO;This article discusses the integration of expert systems and databases withinan object-oriented framework.andM;Such integration is appealing because the user can directly manipulate thedatabase's semantics (in contrast to approaches where the semantics arehardwired into the data model).andP;  This straightforward manipulation makespredefining complex semantic constructs within the database's basic languageunnecessary.andP;  Potential capabilities of an intelligent database systeminclude:andM;* Sophisticated queries, such as transitive-closure queries and recursivequeries, can be expressed.andM;* Customized front ends, such as a flexible language interface orsophisticated front end where the system can give a partial answer to a querythat would have failed otherwise can be developed.andM;* Expert rules dealing with data can be programmed in the same environmentwithout using any external expert system tool.andP;  Ordinary databaseapplications (such as data entry and report and application generation) andintelligent processing of data can be mixed.andM;* Integrity constraints of databases can be expressed and enforced naturallyin a nonprocedural way; concurrent access to the same database from differentexpert system applications can be readily performed.andM;Tight coupling of databases and expert systems within an intelligent databaseenvironment requires much more than a simple I/O link.andP;  Systems and behaviormust be integrated at the language, development-environment,user-environment, concurrency-control, and recovery levels.andM;Due to the different retrieval schemes between a database and an expertsystem shell (set-at-a-time vs.andP;  tuple-at-a-time retrieval), the expertdatabase system's inference engine must be allowed to access the databasedirectly at the lower level without bypassing the multiuser concurrencycontrol and recovery primitives.andP;  Transferring the entire set of tuples of aretrieval request into the expert system workspace is expensive in terms ofboth space and time because the inference engine typically needs only thefirst valid answer to backtrack, after which other answers may be sought.andM;To integrate the development environments of the database system and expertsystem shell, the paradigms of both subsystems must be extended.andP;  Typicalexpert system development facilities such as customized editing, errorchecking, and rule tracing ought to be extended to take the databaseinteraction into account.andP;  Traditional modules such as data entry or reportgeneration in database system must also be modified to accommodateinteraction with an expert system.andP;  An explanation mechanism for theknowledge-based system's reasoning process should be incorporated intodatabase activities such as report and application generation.andM;In a multiuser environment, concurrent access to the same knowledge base mustalso be controlled.andP;  In a shared knowledge base, concurrency conflictssimilar to those in database systems could occur.andP;  These conflicts arise whentrying to assert or retract a fact or rule used by another concurrenttransaction.andP;  Recovery mechanisms for expert systems should provideconventional database services such as undoing changes made by abortedqueries and protecting the database and knowledge base from hardware failure.andM;Knowledge-based approachandM;The key to integrating expert systems and databases is a knowledge-basedapproach to relations; access to relational databases should occur as anintegral part of inference processes.andP;  Expert system shells and relationaldatabases may be closely integrated using relational predicates and objects.andO;The method and notation described here are implemented in theIntelligence/Compiler expert system shell (IntelligenceWare, Los Angeles,Calif.).andP;  The basis of the implementation is transformation of relationalconstructs into objects and predicates that can be embedded within aknowledge base.andM;Database relations may be represented within Intelligence/Compiler using twointerchangeable models: predicate and object.andP;  The predicate model representsrelations within a virtual (disk-based) fact base.andP;  Data are added using theassert predicate, removed with the retract predicate, and retrieved withstandard predicate-matching from within the expert system shell.andP;  In theobject model, relations are represented as instances of objects.andP;  Data areadded and removed through special predicates and retrieved and modifiedthrough standard object access.andP;  The object model has more powerful queryingand easier handling of records with large numbers of fields.andM;An object-oriented system views the world in terms of objects.andP;  Each objectis a conceptual entity associated with a set of attributes.andP;  Each attributein an object may have a value.andP;  We call the definition of a database objectan object schema.andP;  An instance of an object is a record of valuescorresponding to the attributes in the object.andM;In the Intelligence/Compiler, an object with Relation as its first parent isviewed as a database object.andP;  The instances of this object are then viewed asdatabase entries.andP;  For example, an Employee relation can be defined as:andM;Object: Employee Parent: RelationandM;Parent: Person Key: EmpNumber Attribute: Name Attribute: Salary Attribute:DeptNoandM;and an instance of Employee could be:andM;Instance: 1101 Parent: Employee Attribute: Name Value: David Smith Attribute:Salary Value: 36000 Attribute: DeptNo Value: 109andM;Integration of objects, predicates, and relations is achieved using tables torepresent all three structures.andM;Defining schemasandM;Each relational database must have a schema.andP;  In the predicate model, theuser defines relations by defining a series of special predicates,predicates, usually as facts.andP;  The first predicate is the relationalpredicate relational Employees.andP;  Of course, we can define a schema for thisrelation with the SQL data definition method.andP;  However, schemas may also bedefined logically with assertions.andM;To set up the schema for the relation, the fields of the relation must bedefined, as in:andM;ID, Integer, 1 is_a_field Employee Last Name, String, 20 is_a_field EmployeeFirst Name, String, 20 is_a_field Employee Age, Integer, 1 is_a_fieldEmployee Salary, Integer, 1 is_a_field Employee Department, Integer, 1is_a_field EmployeeandM;These facts define the fields, types, and array sizes of Employee.andP;  In theIntelligence/Compiler notation used here, the underlining identifies thepredicate, and its arguments are separated by commas.andP;  Thus in the firstfield definition of the preceding example, ID is the name of the field,Integer is the type of the field, 1 is the array size of the field, andEmployee is the name of the relation.andM;In the object model, relations are defined by a series of special objects,Each has Relation as one of its parents.andP;  The same relation can be definedusing objects:andM;Object: Employee Parent: Person Parent: Relation Attribute: ID  Value:Integer, 1 Attribute: Last Name  Value: String, 20 Attribute: First Name Value: String, 20 Attribute: Age  Value: Integer, 1 Attribute: Salary  Value:Long, 1 Attribute: Department  Value: Integer, 1andM;This object defines Employee and lists its parents (employees are people andthe employee relation is a relation) along with a set of attributes, each ofwhich defines a field of the relation.andP;  Thus the object for the relationdescribes the schema with each attribute defining a field, just as theis_a_field facts defined the schema for the employee relation in thepredicate model.andM;Only explicitly named attributes are interpreted as fields in the objectrepresentation of relations.andP;  Inherited attributes are not interpreted asfields, although they may be accessed by inheritance.andM;In addition to predefined types such as characters, integers, reals, andstrings, field types may also be the name of another relation, allowing arecord to have direct link (pointer) to another record.andM;Defining indicesandM;As with the general relation model, indices may be used to make access moreefficient.andP;  Indices are defined with predicates in a two-step procedure:andM;* Create an index with the Index_name is_an_index Relation predicate.andM;* List the fields to which the index refers with the Index_namehas_index_field Field predicate.andM;This procedure provides necessary flexibility in creating multifield indices.andO;Consider the following definition:andM;Name Index is_an_index Employee Name Index has_index_field Last Name NameIndex has_index_field First NameandM;The first fact creates an index called Name Index for the Employee relation.andO;This index currently has no fields.andP;  The second and third assertions indicatethat fields Last Name and First Name are part of this index.andP;  This creates asingle index whose key consists of two fields.andM;During retrievalor in performing the relational operations, the database willuse all available indices as indicated by the index definitions created usingis_an_index and has_index_field.andM;Modifications and transactionsandM;One a record schema has been defined, new record schemas can be added and newindices created.andP;  Record schemas and indices can also be removed.andP;  Schemasand indices are added and removed if the file is opened with an appropriatepredicate that we will call the open_relations predicate.andM;Record schemas and indices may also be dynamically added and removed byupdating the fact base and/or object base schema and proving an update_schemapredicate that reads the fact base-object base schema information andmodifies it accordingly.andM;All modifications to relations are considered temporary.andP;  they should not become a part of the relation file until explicitly commanded.andP;  In this way,the integrity of the relation file is maintained.andP;  Modifications can begrouped into transactions that are guaranteed to be performed as a singleunit.andP;  This guards against some modifications succeeding and some failing.andM;Transactions are completed with a predicate such as commit_relations, whichmakes all modifications to the relation base permanent.andP;  This predicateaffects all relation and schema modifications.andP;  Conversely, a predicate suchas abot_relations throws away all modifications made to the relation basesince the last time commit_relations was used.andM;Adding and removing dataandM;In the predicate model, records are dynamically added with assert and removedwith retract.andP;  These predicates perform a relational assertion (orretraction) if the asserted or retracted predicate is a relational one.andM;In the object model, a record is added as follows First, fill in theattributes of a child of the relation object with values; for example,(Attribute 1 of Child):= 'Value_1'.andP;  This example may be read as &quot;the firstattribute of the child frame gets the value of the variable 'Value_1'.&quot;andM;Second, prove the predicate add_instance Relation, Instance for the child.andO;For example, if you create a child of Employee with new_Object New Emp,Employee, you can write:andM;(ID of New Emp):= &quot;7494&quot; and (First Name of New Emp):= &quot;John&quot; and (Last Nameof New Emp):= &quot;Smith&quot; and (Age of New Emp):= &quot;26&quot; and (Salary of New Emp):=&quot;25000&quot; and (Department of New Emp):= &quot;14&quot; and add_instance Employee, New EmpandM;The last goal will add this record to the database.andP;  Proving add_instanceagain will add another record.andM;The object model supports record removal with the predicate delete_instances,as in:andM;delete_instances from Employee, where Department = 14, Age andless; 65andM;which removes from the Employee relation all records whose Age field is lessthan 65 and whose Department field is equal to 14.andP;  If no matches are found,the predicate fails.andM;Retrieving dataandM;In the predicate model, retrieving data from a relation is very easy.andP;  Yousimply use the relation name as the predicate, and matching facts are boundusing unification.andP;  Pattern-matching is performed as usual in fact-basesearches within logic programs or expert systems.andP;  Constants and boundvariables are matched to a record.andP;  Unbound variables are bound to therecord's corresponding fields.andM;For instance, Employee 7494, 'Last Name', 'First Name' searches the Employeerelation for the value 7494 in the ID field.andP;  When a match is found, 'LastName' is bound to the Last Name field and 'First Name' to the First Namefield.andP;  If no match is found in the relation base (no employee has the number7494), the rule base is searched and any matching rules are fired.andP;  In thesystem described here, relational predicates generally use backtracking tofind new matches until no more exist.andM;To retrieve data using the object model, we can use a predicate such asget_instance, which incorporates SQL-like syntax for retrieving information.andO;SQL expressions are made up of three clauses: select, from, and where.andP;  Aquery in SQL has the form:andM;select Attribute1, Attribute2, ..., Attributen from Relation1, Relation2,..., Relationm where PredicateandM;The result of a SQL query is a relation.andP;  SQL:andM;* Forms the product of the relations named in from.andM;* Performs a relational selection using whereandM;* Projects the result onto the attributes of select (in the SQL sense).andM;SQL statements may be embedded as standard retrieval operations within anexpert system shell.andP;  Consider the following:andM;get_instance 'Record ID', select First Name, Last Name from Employee whereDepartment = 14, Age andgt; 18andM;In this example, get_instance selects from the Employee relation allemployees older than 18 in department 14 and binds 'Record ID' to a stringthat uniquely identifies the first one.andP;  Upon backtracking, 'Record  ID' isbound to the identifier of the next matching record.andP;  If no more matches arefound, the predicate fails.andM;In Intelligence/Compiler, get_instance may be defined so criteria listed inthe where clause are ANDed together.andP;  Under such a definition, the recordmust qualify all criteria listed in the clause to qualify selection.andO;However, criteria with the same field names are ORed together, meaning onlyone must be satisfied.andP;  In the notation used here, the different criteriawithin the where clause are separated by commas.andM;The use of criteria in a query is illustrated in the following example:andM;get_instance 'Record ID', select First Name, Last Name from Employee whereLast Name=Jones, Last Name=Smith, Ageandgt;=18andM;In this case, get_instance selects all employees 18 years or older who arenamed Jones or Smith.andP;  If select is omitted, all fields are selected.andP;  Ifwhere is omitted, all records will be qualified.andP;  from is required.andP;  Once therecord ID is obtained from the get_instance predicate, data can be retrievedfrom the record by the standard object attribute access.andM;Thus, once a record has been retrieved using a query, it may be accessed asan object and the values of each of its attributes retrieved.andP;  In thenotation defined here, the statement 'C':= (Salary of 'Record ID') definesthe value of the variable 'C' as the salary of the record retrieved by theprevious get_instance command.andP;  The syntax of the previous form may berepresented as 'Variable' gets Attribute of Frame.andM;In the Intelligence/Compiler notation, variables are signified by singlequotation marks.andP;  Any of the attributes could be similarly accessed; forinstance, 'A':= (Age of 'Record ID') sets the value 'A' to the age of therecord.andP;  Records may be updated in similar fashion: (Salary of 'Record ID'):='25000&quot;.andM;Such updates are made immediately but will not be permanent untilcommit_relations or close_relations is called.andP;  Naturally, this is a veryimportant feature since the update may later be invalidated if back-trackingis required.andM;It is also possible to link records of a relation just as you can linkstandard objects.andP;  For example, with objects, you can create a link as (Bossof John):= Jim.andP;  This creates a direct link from the Boss attribute of theobject named John to the object named Jim.andM;Links to relational objects can be created the same way using the recordidentifier instead of an object name.andP;  The record_id predicate facilitatesgetting the record identifier of a record, as in get_identity 'X'.andP;  Thispredicate binds 'X' to the record identifier of the last record added orasserted or to the last record retrieved with a relational predicate orget_instance.andM;The following example illustrates the process of linking Jim to John's bossfield:andM;assert Employee 1112, Johnson, Jim, 120000, 14 and get_identity 'Boss ID' andassert Employee 1113, Smith, John, 0, 21, 'Boss ID'andM;Direct links are then accessed just as in objects.andP;  First we must get John'srecord identifier either by using the object model, as in:andM;get_instance 'Record ID',- select Last Name, First Name, from Employee, whereLast Name = Smith, First Name = JohnandM;or by using the predicate method:andM;Employee 'X', Smith, John and get_identity 'Record ID'andM;Once we have the record identifier, we may use it as if it were an objectname to show information about John's boss:andM;HBoss L':=(Last Name of (Boss of 'Record ID')) and 'Boss F':=(First Name of(Boss of 'Record ID')) and 'Boss Sal':=(Salary of (Boss of 'Record ID')andM;Using intelligent databasesandM;Within an integrated framework for intelligent databases, rules extendrelational databases by providing virtual tables.andP;  Objects can extend them byproviding virtual attributes and value.andP;  Each predicate schema in logic mapsto a relation, suggesting that pattern-matching with logic is a natural wayto extend relations and provide users with a higher level of expressivepower.andP;  Similarly, a clause such as Employee 'Number', 'Name', 'Salary','DeptNo' is used to represent the employee schema.andM;Inference is performed by firing rules, which may contain relationalpredicates and thereby access the relational database.andP;  The following is abackward rule that uses a relational predicate as one of its antecendents:andM;highly_paid_employee 'Name' If Employee 'Number', 'Name', 'Salary', 'DeptNo'and 'Salary' andgt; 60000;andM;Matching Employee 'Number', 'Name', 'salary', 'DeptNo' with a logical factbase is equivalent to accessing a record from the database.andM;A logical language provides a set of predicates to access object instances.andO;For example, to get the list of employees who earn more than $60,000, you canwrite:andM;highly_paid_employee 'X' If 'Emp' is_a Employee, (Name of 'Emp' = 'X' and(Salary of 'Emp') andgt; 60000;andM;In Intelligence/Compiler, the predicate is_a will return an instance of anobject schema, which includes the object name, followed by one or more keys.andO;During rule execution, the backtracking mechanism will go through thedatabase record by record to return the next instance for the object schema.andO;Thus the object system may be fully integrated with the logic system.andM;Again, each object schema maps to a relation, suggesting that relations are asuitable method of integrating objects, logic, and databases.andP;  Integratingrules and logic with SQL provides a knowledge management system.andP;  Theintegration has three basic elements: logic with embedded SQL statements, SQLwith objects, and SQL with logical predicates.andM;Thus a database has three styles of representation: object-, predicate-, andrelation-based.andP;  Relation-based representation is the conventional way torepresent database contents and provides the bridge to conventional databasesystems such as dBASE, ORACLE, and RBASE.andP;  Users can access the database inseveral ways: object-related predicates, facts, and SQL statements.andM;We thus have the three-way mapping between tables, predicates, and objects.andO;Relational databases, objects, and logic may be uniformly integrated in aframework for intelligent databases that supports the combined use of rules,relations, and objects.andM;Objects and attached proceduresandM;The ability to run methods or attached procedures is particularly useful.andO;Attached procedures may be used to supervise integrity maintenance andperform dynamic information retrieval and storage.andP;  In this mode, you caneither directly calculate an attribute's value on the basis of otherinformation or dynamically determine its possible range of values.andP;  Thisfacility is particularly useful in intelligent databases, where informationmay change relatively quickly and must be continuously updated.andM;Consider a database that presents the latest stock prices as part of aninformation system for stock market investment analysts.andP;  Using an attachedpredicate, the latest stock prices could be fed to the user as they becomeavailable.andP;  However, if the value of a particular stock is not queried, thesystem does not have to maintain its latest value in the database.andP;  This typeof feature would be especially attractive where some information is availableexternally on a pay-per-use basis.andP;  Attached predicates could be used todisplay the information and carry out associated accounting operations.andM;Other uses of attached predicates allow values of missing information to beinferred.andP;  For instance, the price-to-earnings ratio of a stock could becalculated on the basis of other information or an if-needed predicate mightcalculate a person's age by retrieving the current date and birthdate of theperson and subtracting the birthdate from the current date to obtain theperson's age.andP;  This provides a deductive retrieval capability, as in:andM;Object: Employee Parent: Person Attribute: Employee Number  Value: Attribute:Year of Birth  Value: Attribute: Age  Value: If_Needed: calculate age Age,Year of BirthandM;Object: Tony Higgins Parent: Employee Attribute: Employee Number  Value:1925364 Attribute: Year of Birth  Value: 1959 Attribute: Age  Value:andM;The attached predicate calculate age may be defined as a backward rule:andM;calculate age 'Age', 'Year' If current year 'Date' and 'Age' :='Date' --'Year';andM;Here current year is again a predicate that retrieves the current year fromthe fact base.andP;  In this way the value of Age is always dynamicallydetermined.andP;  It is not necessary to update this attribute as time changes.andO;This facility may be used in myriad applications, such as simulations andstrategic analysis.andM;Integrating inference, object-orientation, and relations within intelligentdatabases allows you to perform deductive retrieval, handle relationaldatabases as extensions of knowledge bases, and carry out intelligentintegrity maintenance.andP;  Recognizing the essential commonality of objects,predicates, and relations is the key to merging expert systems and databasesinto a uniform framework for intelligent databases.andP;  As well as addingdatabase capabilities to expert systems, integration provides a next level indatabase programming power.andM;ReferencesandM;[1] Parsaye, K., and M.H.andP;  Chignell.andP;  Expert Systems for Experts.andP;  New York,N.Y.: John Wiley and Sons, 1988.andM;[2] Intelligence/Complier User's Manual.andP;  Los Angeles, Calif.:andO;IntelligenceWare Inc., 1988.andM;[3] Parsaye, K., M.H.andP;  Chignell, S. Khoshafian, and H. Wong.andP;  IntelligentDatabases.andP;  New York, N.Y.: John Wiley and Sons, 1989.andM;Mark H. Chignell is an assistant professor of industrial and systemsengineering at the University of Southern california, Los Angeles.andP;  Hiscurrent research involves the use of expert systems and hypermedia inintelligent interface design and information management.andO;</TEXT></DOC>