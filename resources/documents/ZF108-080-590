<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-080-590  </DOCNO><DOCID>08 080 590.andM;</DOCID><JOURNAL>AI Expert  Feb 1990 v5 n2 p32(6)* Full Text COPYRIGHT Miller Freeman Publications 1990.andM;</JOURNAL><TITLE>Inference engines for the mainstream. (designing expert systems)</TITLE><AUTHOR>Brown, Donald E.andM;</AUTHOR><SUMMARY>Expert systems are moving into the business world as inferenceengines are coded in C and Pascal rather than LISP.andP;  LISP has longbeen the language of choice for AI research because it can treatits own code as data and because its unique list data type allowsthe creation of complex data structures.andP;  An 'inference engine'program is the heart of any expert system; it performs reasoningon expertise contained in a knowledge base; its main tasks are toobtain a goal and the name of the knowledge base to use, load theknowledge base into memory, apply knowledge-based rules to derivea value for the goal, and return the value.andP;  LISP is ideal forimplementing expert systems, but inference engines written inconventional languages run up to 100 times faster and can beincorporated into existing business applications.andM;</SUMMARY><DESCRIPT>Topic:     Knowledge-Based SystemsExpert SystemsLISPBusiness PlanningProgram Development TechniquesList Processing.andO;Feature:   illustrationcharttable.andO;Caption:   Linked list representation of knowledge base. (chart)Major expert-system vendors. (table)Platform considerations. (table)andM;</DESCRIPT><TEXT>INFERENCE ENGINES for the MAINSTREAMandM;From its somewhat mystic origins in LISP functions consisting almost entirelyof parentheses, AI has gradually moved into the mainstream of conventionallanguages.andP;  C, Pascal, and even RPG programmers can now choose from a varietyof AI tools.andP;  This article will examine the reasons for the move fromtraditional AI languages such as LISP and PROLOG toward more conventionallanguages, especially in mature AI areas such as expert systems.andM;From the beginning, LISP was the language of choice for American AIresearchers.andP;  The reasons for this choice are many, but primarily result fromthe strong mathematical roots of the language and its ability to treat itsown code as data.andP;  This ability is usually bewildering to C and Pascalprogrammers but allows developers to create programs that modify themselvesat run-time.andP;  Researchers have exploited this capability for research inmachine learning, natural-lanaguage understanding, and other aspects of AI.andM;The other unique feature of LISP is the list data type.andP;  Because lists can beany size and contain objects of any data type (including other lists),programmers can create very complex data structures for representing abstractconcepts such as object hierarchies, natural-language parse trees, andexpert-system rules.andP;  It's this ability to create and manipulate heterogenouslists that makes LISP such an attractive language for AI programming.andM;Perhaps the most successful AI application in the business world isexpert-system technology.andP;  LISP is tailored to expert system creation of itsflexible list data type and its excellent support for recursion--the abilityof a subrountine to call itself.andM;An expert system consists of two components: a knowledge base containing therules (or other structures) embodying expertise in a specific domain, and aprogram that performs reasoning on this expertise to achieve a goal.andP;  Theprogram that performs this reasoning is called an inference engine.andP;  Ingeneral, the same inference engine can be used to reason about all kinds ofproblems because it does not contain domain-specific information.andP;  Theinference engine uses a theorem from propositional logic called Modus Ponens.andO;This theorem states that if we know A implies B and we are given that A istrue, we can safely conclude B is true.andP;  In symbolic terms, this theorem canbe restated as A ==andgt; B, A|- B.andP;  An inference engine repeatedly applies ModusPonens to a set of rules to derive a particular value or solve a particularproblem.andM;The main tasks the inference engine should perform during an expert systemconsultation are:andM;* Get the name of the knowledge base and the goal of the consultantandM;* Load the knowledge base into memoryandM;* Apply the rules in the knowledge base to derive a value for the stated goalandM;* Return the value of the goal.andM;Most of the work in designing and implementing an inference engine occurs inthe second and third steps.andP;  Loading a knowledge base into memory meansdesigning a parser for the rule language and creating data structures torepresent the rules and facts in memory.andP;  Applying the rules means decidingwhich rule can bring us closer to our goal and using that rule to derive newfacts.andM;We can decompose the function of the inference engine even further, as shownin Table 1.andP;  As in any complex program, the key to the design of theinference engine is the choice of data structures to represent what is goingon (in this case, the knowledge base).andP;  In general, two lists must beinvolved: one of the parameters (or &quot;variable&quot;) and one of the rules thatrelate those parameters.andP;  For instance, given the two rules:andM;Rule1: IF Job = 'Doctor' OR Job = 'Lawyer' THEN GoodJob = TRUE.andP;  Rules2: IFgoodJob = TRUE THEN Advice = 'Grant Loan'.andM;the inference engine would create a list of the parameters (Job, GoodJob, andAdvice) and rule (Rule1, Rule2).andP;  In addition to the major lists forparameters and rules, the inference engine would need to create minor listsfor the clauses in the premise and the actions in the conclusion of eachrule.andP;  Therefore, the inference engine would represent the knowledge basementioned earlier, as in Figure 1.andM;This representation allows the inference engine to access each parameter,rule, premise clause, and conclusion action.andP;  In a backward-chainingconsultation, the inference engine can scan the list of conclusion actionsfor each rule to find one concluding something about the goal parameter.andO;Then it scans the premise clauses of that rule to see if they are true.andP;  Ifthey are, the inference engine can rescan the conclusion list and perform theactions indicated there, most frequently adding values to the parameters inthe parameter list.andM;You can probably apprecisely why LISP is such a perfect language forimplementing expert systems.andP;  Programmers can use the built-in list data typefor easy creation of the data structures necessary to represent parameters,rules, premise clauses, conclusion actions, and other objects that constitutea knowledge base.andP;  Notice that this design depends only on the ability tocreate homogeneous lists where each list element is the same data structure(a parameter, rule, premise clause, or conclusion clause).andP;  Nothing in thedesign depends on LISP's unique abilities to represent code as data or tocreate lists of heterogenous objects.andP;  In fact, this design could beimplemented in any language supporting dynamic memory allocation, notably Cand Pascal.andP;  So why used LISP to implement expert systems?andM;Many developers ask themselves the same question.andP;  LISP is a marvelousresearch language that gives a programer the ability to create and experimentwithout paying attention to the data types of variables or the way memory isallocated.andP;  Unfortunately, this latitude incurs a penalty.andP;  Because LISP isan extremely high-level language, it is relatively insulated from the machineit runs on and thus tends to do so rather slowly.andP;  In addition, the abilityto create recursive lists of heterogeneous objects dramatically increasespointer overhead.andP;  In the last few years, developers have started to leveragethe performance advantages of  C and Pascal to create expert-system inferenceengines offering the same functionality as the older LISP-based products butthat run much more quickly.andP;  A look at just a few of the major expert-systemproducts on the market and the languages they were implemented in is quiterevealing (Table 2).andP;  You can tell the age of the product from itsimplementation language.andM;The advantages of implementing an expert-system inference engine in aconventional language are many.andP;  Inference engines written in conventionallanguages run up to 100 times faster than some of the older LISP-basedshells.andP;  Memory requirements are usually lower because there is less pointeroverhead and programmers have more explicit control over memory allocationand deallocation.andP;  Of course, many more programmers are familiar with C andPascal than LISP--an obvious benefit, especially for large organizations.andM;Perhaps the greatest benefit of implementing expert systems in conventionallanguages is the ease with which they can be embedded in applications writtenin those languages.andP;  At least two companies, Neuron Data and SoftwareArtistry, offer inference engines that can be embedded directly into Capplications and function through simply subroutine calls; Software Plus hasa product that translates knowledge bases into C source code.andP;  SoftwareArtistry offers inference engines that can be embedded into applicationswritten in Pascal and Modula 2 on PCs, as well as.andP;  COBOL and RPG on IBM'sAS/400 minicomputer.andM;The ability of an inference engine to be embedded as a library of simplesubroutine calls is a milestone in the integration of expert-systemstechnology into the mainstream.andP;  Adding an inference engine to a conventionalapplication is as simple as:andM;char value[25]; int confidence; if (load knowledge base(&quot;RULES.KB&quot;))solve(&quot;Advice&quot;,'B',value,andamp;confidence); /* 'B' for backward-chaining */andM;in C, or:andM;VAR value: STRING[25]; confidence: INTEGER;andM;IF LoadKnowledgeBase('RULES.KB') THENSolveFor('Advice','B',value,confidence);andM;in Pascal, or:andM;in RPG.andM;In all three languages, we simply load the relevant knowledge base via onesubroutine call and then initiate a consultation with a second one.andP;  Theinference-engine libraries from Neuron Data and Software Artistry containdozens of such calls to add facts to working memory, get current parameterbindings, and so on.andP;  This ability to embed an inference engine directly inan existing application heralds new opportunities for AI in the businessworld.andM;Even though conventional languages can be used to implement bothexpert-system inference engines and applications, different considerationsarise as different platforms are scrutinized.andP;  An inference engine designedto run on a PC is necessarily quite different from one designed to run on anIBM AS/400 minicomputer.andP;  The matrix shown in Table 3 illustrates some of theimportant points.andM;Creating expert-system applications on PCs under MS-DOS is especially easydue to the development tools available and the simple single-user operatingsystem; however, the 640K memory limitations is a big headache.andP;  Althoughshell vendors have worked hard to circumvent this limitation with expandedmemory, overlays, and other techniques, the 640K wall is formidable.andM;Most products provide facilities to break a large application into modulesand thereby work on only one piece of the problem at a time.andP;  In ourproducts, we include an agenda construct.andP;  For instance, an expert system fordiagnosing mechanical problems in a car would be broken down into knowledgebases for the electrical, air conditioning, and braking systems, and so on.andO;An initial expert system would be used in an effort to determine which of thesystems was involved and then load the appropriate knowledge-base module.andO;The agenda in the scheduler controlling this process is shown in Figure 2.andM;Decomposing a large knowledge base into smaller modules is not all bad.andP;  Amodular structure not only decreases memory requirements but promotes moreconsideration of the overall knowledge-base design.andP;  In addition, small rulemodules are much easier to maintain than a monolithic knowledge base.andM;Designin an inference engine to run under UNIX is not that different from onefor MS-DOS.andP;  The memory limitations disappear, but it's not a bad idea todecrease memory requirements anyway.andP;  However, designers and programmers canfall into the trap of using increased processor speed and memory capacity tohide sloppy design and implementation.andP;  For that reason, shells originallycreated to run on PCs have traditionally done very well when ported to largerenvironments, and products designed for mainframes and minicomputers tend torun poorly when ported to smaller machines.andP;  IBM discovered this fact whileporting its Expert Systems Environment (ESE) product from the mainframe 370to the AS/400 minicomputer.andP;  The port was successful but the product ran sopoorly it was never released.andM;The AS/400 is a very special case for expert systems in general and inferenceengines in particular.andP;  Only two expert-system products are available for themachine: IBM's Knowledge Tool and Software Artistry's Application SoftwareExpert; the machine's architecture is the main reason for the relativepaucity of tools.andP;  The AS/400 was designed as the ultimate database machine.andO;It has a huge address space, reflected in the 16-byte pointer size, whichallows the operating system to access all of storage directly (both RAM andhard disk) in a simple, linear fashion.andP;  Further, the database facilities arebuilt into the operating system and supported by the machine's microcode.andM;This ingenious design has been very successful in satiating the intensedatabase needs of its target audience (mainstream business users) and evenoutperforming the low end of IBM's mainframe line.andP;  It is probably accurateto say that the AS/400 is the most specialized large-scale computer everinvented and the current lineup of machines represents only the tip of theiceberg for the architecture's potential.andM;All this makes life wonderfully simple for COBOL and RPG programmers whocreate fast, efficient business applications ivolving many users with hightransaction levels, but it also makes life miserable for the poor soul whotries to create processor-intensive, pointer-based applications.andP;  Because ofthe machine's specialization in database applications, it is not easy to makenondatabase applications (such as expert system inference engines) run wellon it, especially at the low end (the small B10 and B20 machines).andP;  The16-byte pointer size causes linked lists to incur tremendous pointer overheadand pointer traversal to take much longer than should be expected.andM;Because of these considerations and the block (as opposed to character) I/Ofacilities and lack of floating point support, our company was forced tooverhaul its inference engine when designing the product for the AS/400.andO;Every possible pointer was removed from the design, totally recording theuser interface and using hash tables and other less pointer-intensive datastructures.andP;  All of this extra work was mitigated by the AS/400's cleanarchitecture, which compiles all applications to the same object code formatregardless of the language they were written in, allowing us to create aninference engine callable from COBOL, RPG, PL/I, Pascal, and C applications.andO;Needless to say, LISP would not be a development alternative on a machinesuch as the AS/400.andM;Expert systems have clearly migrated from the ivory tower to corporateAmerica where they belong.andP;  It is almost always true that once you understandsomething, part of the magic goes away: an expert-system inference enginerepresents just another technique of meeting business needs and should beconsidered in the same light as a screen handler or database manager.andP;  Codinginference engines in conventional languages moves them into the mainstream ofbusiness computing, and offering them as libraries of subroutine calls allowsmillions of programmers to add expert-system capabilities to commonapplications.andP;  But the old-fashioned, standalone shells will always have aplace--at least in the ivory tower.andM;Donald E. Brown, MD, is president of Software Artistry Inc., an IBM BusinessPartner specializing in embeddable inference engines for various IBMplatforms.andP;  He may be reached at (317) 876-3042.andO;</TEXT></DOC>