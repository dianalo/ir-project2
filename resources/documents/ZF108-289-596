<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-289-596  </DOCNO><DOCID>08 289 596.andM;</DOCID><JOURNAL>Microsoft Systems Journal  March 1990 v5 n2 p1(26)* Full Text COPYRIGHT The Microsoft Corporation 1990.andM;</JOURNAL><TITLE>Using the OS/2 National Language Support Services to writeinternational programs.andO;</TITLE><AUTHOR>Freytag, Asmus; Leu, Michael.andO;AttFile:   MSJ\V05N02\OS2_NLS.EXE;2 Program:  OS2_NLS.EXE  Self-extracting archive.andM;</AUTHOR><SUMMARY>OS/2 is designed an an international operating system.andP;  Localizededitions of OS/2 1.2 have been created for Korea, Japan and mostEuropean localities.andP;  Applications developers use the NationalLanguage Support (NLS) system of OS/2 to create applications tosupport many language automatically.andP;  Applications requiring morecomplicated linguistic knowledge may bypass the OS/2 defaultfunction to utilize NLS's more advanced features.andP;  'Localization'is the method of modifying a program for use in another country.andO;The article covers the NLS functions of OS/2 along withlocalization principles.andP;  They are demonstrated with two sampleprograms.andM;</SUMMARY><DESCRIPT>Product:   OS-2 1.2 (Operating system) (product development).andO;Topic:     Foreign LanguagesOS-2JapanKoreaEuropeApplications ProgrammingProgram Development Tools.andO;Feature:   illustrationphotographtable.andO;Caption:   Key meanings of different country formats. (table)OS/2 NLS functions. (table)andM;</DESCRIPT><TEXT>Using the OS/2 National Language Support Services to Write InternationalProgramsandM;The OS/2 operating system is designed to be an international operatingsystem.andP;  Localized editions of OS/2 (1) Version 1.2 now exist for Japan,Korea, and most of Europe.andP;  Application writers can use the National LanguageSupport (NLS) system services provided by OS/2 to write programs that supportmany national languages automatically (see Figure 1).andP;  Programs such as wordprocessors that require more detailed linguistic knowledge can bypass thedefault functionality of OS/2 to exploit its more advanced NLS features.andM;The process of modifying a program for use in a different country is calledlocalization.andP;  Ideally, applications have only one set of source code for alllanguages, instead of one version for each market.andP;  Localization decreasessource code maintenance costs and makes it much easier to release the productsimultaneously in multiple markets.andP;  This article discusses OS/2 NLSfunctions and localization principles and demonstrates them using two sampleprograms.andM;Localizing a piece of software involves much more than merely translatingtext messages.andP;  Methods of processing and formatting data as well as handlinginput may differ from country to country.andP;  In addition, an application mayhave to deal with specialized, country-specific hardware.andM;Code Pages and Country CodesandM;First, you must understand how OS/2 uses code pages to represent text data.andO;Data is merely a stream of bytes.andP;  A code page is a table that maps bytevalues (or code points) to a set of characters or glyphs (picturecharacters).andP;  Code pages are uniquely numbered (for example, 437 is the U.S.andO;code page), so if you specify a code page number with a stream of bytes, youhave ensured that your data can always be interpreted correctly.andM;Another factor in determining how data will be processed is the country code.andO;A country code is a three digit number based on those used by theinternational phone system to designate countries (001 represents the U.S.,andO;081 represents Japan, and so on).andP;  In OS/2, country codes specify the countryrules that should be used in operation (for example, how to format number,date, and time strings); it also restricts the list of possible valid codepages.andP;  Unlike the code page, the system country code cannot be changed atrun time.andP;  However, different values can be specified to OS/2 function callsthat take the country code as an argument.andM;Code pages 850 and 863 are shown in Figure 2.andP;  As you can see from the codepage 850 and 863 tables, the same code point may reference differentcharacters in different code pages.andP;  However, while code pages differ intheir representation of non-English characters and symbols, most map thebytes in the 20H to 7EH range to the printable ASCII characters.andP;  This allowsASCII strings to be preserved when the code page is changed.andM;As expected, many system functions depend on the characters or glyphs of thepassed arguments, not on their binary value.andP;  When the application calls afunction, the code page to be used for interpreting the binary values must beestablished.andM;Specifying the Code Page and Country CodeandM;In the CONFIG.SYS file, there are two statements that initialize the codepage and country code for all OS/2 Vio sessions.andP;  The COUNTRY configurationcommand specifies the country code and the location of the file COUNTRY.SYS,which contains country-specific information.andP;  The CODEPAGE configurationcommand allows you to specify up to two code pages (restricted by the countrycode), which are prepared, and which can be selected by the Change Codepagecommand.andM;The DosGetCp call can be used by applications to obtain the prepared codepages.andP;  If no code pages are specified, DosGetCp returns zero for the codepage value, and the system uses the character set supported in the hardware(the ROM code page).andP;  For an application that needs to know its code page,use the code in Figure 3.andP;  Usually this code is unnecessary since most DosAPIs will accept zero as a code page argument and will then use the processcode page.andM;Each OS/2 process has an associated process code page.andP;  The process code pageis used by Dos API functions, such as the file system calls DosOpen,DosFindFirst, and DosFindNext to interpret string parameters.andP;  This code pageis initially the primary code page defined in CONFIG.SYS.andP;  Furthermore, everyOS/2 subsystem, such as Vio for screen output and Kbd for keyboard handling,has its own code page.andM;Given this, the code page is inherited as follows: DosSetCp will set theprocess and all subsystem code pages or DosSetProcCp can be called to set theprocess code page but not the subsystem code pages.andP;  The default code pagesettings from CONFIG.SYS can be overridden by calling subsystem-specificalls, such as VioSetCp and KbdSetCp.andP;  However, note that subsystems areshared among all processes of a session and there is no notification of acode page switch to the other processes.andM;In OS/2 Presentation Manager (hereafter &quot;PM&quot;), code pages are associated withmessage queues and presentation spaces (PSs).andP;  To change the message queuecode page, call WinSetCp.andP;  This changes the keyboard translation tables forthat message queue (WM CHAR messages will contain characters in the specifiedcode page); and it also defines the default code page of all new PSsassociated with the message queue.andP;  To override this inheritance mechanismexplicitly, the PS code page can be switched by calling GpiSetCp.andP;  This willcause all output to the PS to be interpreted according to the newly specifieccode page.andP;  Existing PSs are not affected by a switch of the queue code page;however, WinBeginPaint implicitly creates a new PS each time it is called.andO;Thus, after a WinSetCp call, WinBeginPaint will create PSs with the new queuecode page.andM;Queue code pages may only be set to those code pages available to non-PMprograms as indicated by DosGetCp.andP;  (The only exception to this is theoutput-only desktop publishing code page 104.)andP;  If DosGetCp returns 0, thequeue code page will default to 850 (the multilingual code page) if thecountry setting is European or American.andP;  In Asian OS/2, the queue code pagewill default to the primary Asian code page.andM;The set of code pages available for PSs is a superset of the set of availablequeue code pages.andP;  WinQueryCpList provides a list of all available code pagesfor the GpiSetCp call.andP;  This allows the use of special desktop publishingcode pages as well as EBCDIC code pages for output purposes.andM;Note that even though WinSetCp and GpiSetCp have been used to set the queueand PS code pages, the file system code page will still be dependent on theprocess code page (which may be set using DosSetCp or DosSetProcCp).andM;Country settings can be set in the Control Panel.andP;  These options are storedin the system profile and can be referenced with the appropriate Prf calls.andO;If these calls fail, it is recommended that DosGetCtryInfo be used.andM;Message SubstitutionandM;Once you understand code pages, you can tackle localization concerns.andP;  Thefirst step in localizing applications is the translation of the relevantapplication strings.andP;  To make this translation step easy, the messages shouldbe separable from the source code.andP;  Furthermore, the strings should beflexible, allowing simple word replacement.andM;OS/2 provides several means by which messages and program strings can beisolated from the code.andP;  One method available to all OS/2 programs is to keepstrings in message files, using the DosGetMessage API to retrieve themessages.andP;  Not only does this isolate the message text from the programsource, but it also has the advantage that DosGetMessage can take a variablenumber of arguments that can be inserted into the text of the message.andP;  Thisallows program strings to be generated regardless of the word order of thesentence in the language (see Figure 4).andM;Most PM strings, such as those used in dialog boxes, menus, and other systemcontrols, are already stored in resource templates.andP;  Other programinformational strings (such as error messages) should be placed into stringtables and then loaded at run time with the WinLoadString instruction.andP;  PM iscapable of substituting strings using the WinSubstituteStrings instruction.andM;Besides the mechanics of replacing strings, there are other considerations.andO;Arrays that store messages should allocate up to 30 percent more storage formessages, because the strings may grow when translated into other languages.andO;Dialog boxes should always be the right size to accommodate their stringcontents.andP;  Also, since the byte values of frame characters are codepage-dependent, three MSG APPL system messages have been defined inOSO001.MSG to allow the user to access the appropriate frame characters.andO;These messages should be retrieved and used whenever frame characters are tobe drawn in Vio or DOS mode (see Figure 5).andP;  This facility is not as usefulin PM, because frame characters may not line up with proportional fonts, andbecause frames can be drawn with GPI calls.andM;Country-Specific FormattingandM;Numbers, dates, and other information are formatted differently in differentcountries.andP;  For example, January 1, 1990 is formatted 1 January 1990 inEngland.andP;  OS/2 allows these settings to be customized in the Control Panel.andO;These options are then written to the OS2.INI system profile, with theAppName PM National and with the keys shown in Figure 6.andP;  Note that thesesymbols are code page-dependant.andP;  For example, if a code page is specifiedthat does not contain the Yen (yen) symbol, the Yen marker cannot bedisplayed.andM;The strings in Figure 6 can be retrieved from the system profile by makingthe appropriate Prf calls (see Figure 7).andP;  If these profile queries fail, theapplication writer can still fall back on the DosGetCtryInfo call, which willretrieve these values from the COUNTRY.SYS file.andP;  It is a good idea to usethe Prf calls, because the formatting information can be specified by theuser at run time using the Control Panel.andP;  The information retrieved byDosGetCtryInfo is more of a default, as it statically comes from the fileCOUNTRY.SYS.andM;Data ProcessingandM;When data is processed in different code pages, special care must be taken.andO;In code page 850 (multilingual), there are accented characters, which havecode point values greater than 7FH.andP;  Because of this, be sure to declarecharacters unsigned.andP;  (The-J switch can be specified to the Microsoft [R] Ccompiler Version 5.1 to make all characters default to unsiged.)andP;  Anotherdifficulty that arises is that many standard U.S.C.andP;  run-time functions, suchas isalpha and strcmpi, will not work correctly when given strings that arenot in code page 437, the U.S.andP;  code page.andP;  (The C run-time functions strlenand strcpy will work with all code pages, because they look only for the NULLterminator.)andP;  To avoid these problems, use OS/2 system services to performcode page-dependent operations such as case conversions (use DosCaseMap,WinUpper, or WinUpperChar) and string comparisons (DosGetCollate orWinCompareStrings).andP;  Two more useful instructions are WinCpTranslateChar andWinCpTranslateString, which allow conversion between code pages.andP;  By usingthese calls, files that are stored in one code page can be used by anapplication running in a different code page.andM;String comparison is tricky because the order in which characters are sorteddepends on the language of the text.andP;  For example, some European languagessort accented characters between the unaccented characters; some, like theScandinavian languages, sort them at the end.andP;  To make your program sortcorrectly in every country, you can use DosGetCollate.andP;  DosGetCollate returnsa table of sorting weights for each character.andP;  Instead of sorting by thebyte value of the original characters, replace them by their sort weights andcompare these against each other.andP;  The sorting table returned byDosGetCollate gives the same weights for uppercase and lowercase characters.andO;WinCompareStrings uses this collating table to sort strings correctly.andM;Another consideration is how accented characters can be entered.andP;  If thekeyboard does not have keys representing the accented characters, deadkeysmay be used.andP;  Deadkeys are keys that produce an accent mark used incombination with another character.andP;  Deadkeys do not advance the cursor.andO;Deadkey handling is made much easier by internal PM handling; the WM CHARmessage has three special KC flags that tell the state of deadkey processing.andO;The KC DEADKEY flag means that the key pressed is a deadkey; the character KCCOMPOSITE means that the deadkey's accent mark has been fused with thecurrent character to form a new character; and the KC INVALIDCOMP flagdenotes an invalid composition, and returns the last character selected.andP;  IfKC INVALIDCOMP is specified, and the current character is not a space, theapplication should keep the speaker and display the new character code.andP;  Foran example of proper WM CHAR message handling, refer to the TyperCharsubroutine discussed below.andM;Device HandlingandM;This concern is not localization-specific, but a reminder that OS/2 is anoperating system that runs on many platforms.andP;  The application writer shouldtherefore be sure to use device-independent units as much as possible.andP;  Forexample, an image of size 53-by-53 pixels is much smaller on ahigh-resolution screen than on a low-resolution screen.andP;  Also, directmanipulation of hardware devices (such as writing characters directly to thephysical video buffer) should be avoided at all costs.andM;Double Byte Character SetandM;European editions of OS/2 are essentially equivalent to the U.S.andP;  version.andO;The Japanese and Korean versions of OS/2, however, require support forcharacter sets that contain more than 256 characters.andP;  Support for the largecharacter sets is available in Japanese OS/2 Version 1.1 and in the U.S.andP;  andEuropean OS/2 with PM Version 1.2.andP;  U.S.andP;  and European PM can use code page932, but since Japanese display drivers and ROM fonts are not included, thespecial characters cannot be displayed.andM;Up to this point, we have only discussed code pages that have 256 entries(one for each possible byte value).andP;  But Japanese has more than 5000characters!andP;  Japanese is written in a mix of Kanji (ideograph) characters andKana (phonetic) signs.andP;  There are two kinds of Kana signs: Hiragana, theJapanese alphabet of sounds, and Katakana, which is used to write foreignwords phonetically.andP;  Kana-Kanji conversion is a convenient method for typingKanji characters; Japanese keyboards are often labeled with Katakana to allowthe typing of Japanese words phonetically (see Figure 8).andP;  There are 118Katakana and Hiragana characters and about 3500 Kanjis in general use today.andM;To handle all these characters, a double byte character set (DBCS) wasintroduced.andP;  (In this article, DBCS refers to a character set that containsboth single and double byte characters.andP;  Purists would call this type ofcharacter set a mixed byte character set--MBCS.andP;  They would use &quot;DBCS&quot; for aset that is strictly double byte.)andP;  In a double byte character set, certainranges of code points in the code page are designated as leading bytes.andO;Leading bytes have no character value themselves; instead, they indicate thatthey together with the following byte represent a single character.andP;  Thissecond byte is called a trailing byte or trail byte.andP;  You must make certainthat the two bytes of a double byte character are always treated as a unit;if they become separated, the character and/or the byte stream of data willbe processed incorrectly.andM;This article restricts itself to DBCS code page 932, the primary code pageused in Japan today.andP;  Figure 9 shows the first 256 bytes, which are dividedinto several ranges.andP;  There are two main single byte ranges, in which onebyte corresponds to one character.andP;  In the range from 00H to 7FH, the bytevalues are treated as ASCII (as in the European code pages; the differencesare that the byte value 5CH is used for the Yen marker instead of thebackslash, and that the character assignments in the control area from 01H to1FH represent different graphic characters).andP;  The second single byte range isfrom A0H to DFH, and contains codes for the Japanese Katakana syllabary.andO;These codes correspond to keys on some standard Japanese keyboards, such asthe Architecture Extended (AX) (see Figure 8).andM;In code page 932, the ranges from 81H to 9FH and from E0H to FCH have beenreserved as lead bytes.andP;  (Each DBCS code page has a different set of leadbyte ranges.andP;  To determine these ranges, call DosGetDBCSEv; if no ranges arefound, you are in a SBCS code page.)andP;  In essence, each lead byte &quot;points&quot; toa subsequent block of 256 characters.andP;  This scheme provides for therepresentation of the characters in the first two Japanese IndustrialStandard (JIS) character set levels (see Figure 10) and leaves room forfuture additions.andP;  A disadvantage is that trail bytes may have any valueexcept NULL, so applications must be careful when performing stringprocessing.andM;Data ProcessingandM;There are guidelines that will prevent DBCS data processing errors.andP;  Forinstance, problems will arise any time a character stream is scanned linearlyfor a particular byte value.andP;  This problem arises because the only byteguaranteed never to be a trail byte is NULL (00H) and many applications willscan a string for a special delimeter (such as backslash, space, or tab).andO;(Some delimeters such as the period and tab are not valid trailing bytes incode page 932, but this may change in the future.)andP;  For example, 5CH is avalid trail byte in code page 932 and it is also used in OS/2 as a pathdelimeter.andP;  Therefore, it is necessary to scan a string by characters, notingdouble byte characters as they occur.andM;DBCS string truncation must be performed carefully.andP;  Never allow a string toend in a lead byte or begin with a trailing byte.andP;  If a string somehow startswith a trailing byte, it should be either replaced with a single byte paddingcharacter (such as a space), or the string pointer should be advanced by abyte.andP;  When a string ends with a leading byte, the string can be eithershortened by a byte, or again, the offending byte can be replaced by a singlebyte padding character.andP;  Note that backspace and delete processing shouldalways remove double byte characters completely.andP;  While this sounds easyenough, from within a string it is not easy to determine what the DBCScharacter boundaries are.andP;  Figure 11 demonstrates how DBCS strings can becomecorrupted.andP;  A sure way to identify DBCS characters is to scan from thebeginning of the string, which can be done by calling WinNextChar andWinPrevChar instead of blindly incrementing string pointers.andP;  Also, as inother code pages, WinCompareStrings can be used to compare strings properly.andM;DBCS output should be performed a full line at a time.andP;  By using systemservices to do this, DBCS bisection problems can be dealt with by OS/2.andP;  Forexample, the WinDrawText cal performs correct word breaking, whatever thelanguage, based on the country code and code page.andM;Another guideline is always to scan strings forward.andP;  You should replacebackward searches by forward searches and replace pointer decrements by safemacros or function calls.andP;  Using a forward search from the beginning of thestring is the easiest and safest way to ensure that characters are scannedcorrectly.andM;Do not increment or decrement string pointers.andP;  Although the ++ operator in Cis a convenient way to scan an SBCS string, it does not take double bytecharacters into consideration.andP;  Instead of incrementing string pointers, skipentire DBCS characters by using safe functions such as WinPrevChar andWinNextChar, or define your own macros if speed is critical.andM;Be very careful when matching special characters.andP;  Many special charactersare in the trail byte range (for example, backslash and tilde).andP;  Avoidproblems by skipping entire double byte characters when moving through thestring.andM;You should pass pointers to lead bytes or single byte characters, because allsystem functions (except VioWrtTTY) assume that pointers point to a lead byteor a single byte character.andP;  Application functions should also be writtenthis way, as a rule.andM;Most importantly, always treat double byte characters as a unit.andP;  Never allowpartial selection of double byte characters and never allow the cursor torest on the second byte of a double byte character.andM;Character Input and OutputandM;To input DBCS characters in Vio sessions, the same API calls previouslydiscussed can be used.andP;  An application might use the KbdCharIn call to readcharacters into a buffer.andP;  Since KbdCharIn returns characters a byte at atime, the application writer must keep track of double byte handling,buffering leading bytes as necessary, to make sure that partial DBCS stringsare not displayed.andP;  Trail bytes should never be left in the typeahead buffer;either read the second byte, or discard the leading byte and flush the inputqueue.andP;  Again, the delete and backspace keys should always deleteor back upentire DBCS characters.andM;PM input handling is easier, because double byte characters are returned as aunit in mp2 by the WM CHAR message.andP;  Singel byte characters are also returnedin mp2, with the second byte to be ignored.andP;  This reinforces the idea thatdouble byte characters should be handled as a unit.andM;As for DBCS output, in Vio sessions all Vio text output calls may be used(for example, VioCharStringAtt).andP;  However, two rules should be followed.andO;First, display updates must never result in the display of partial doublebyte characters.andP;  To prevent this, never pass a string starting with a trailbyte, and never pass a string containing a lead byte with no trail byte.andO;(This rule does not hold for VioWrtTTY, which will buffer lead bytes that itencounters at the end of strings.andP;  However, this feature may require theapplication to keep track of when a lead byte is buffered.)andP;  The second ruleis that if character attribute such as reverse video are specified, use theworldwide Logical Video Buffer (LVB) format (see Figure 12).andM;DBCS character handling is easier in PM than in full screen mode.andP;  As long ascomplete DBCS strings are output, they will be clipped properly to the windowboundary.andM;Another useful OS/2 facility is the DT WORDBREAK flag that can be specifiedwith the WinDrawText call.andP;  In European languages, word breaking occurs whenspaces are encountered; however, in Japanese, word breaks may occur betweendouble byte Kanji characters because each character may represent a conceptor word.andP;  WinDrawText will use the current PS code page to determine thewordbreaking rule to use.andP;  (The hook HK FINDWORD can be used to defineword-breaking rules.)andM;Given the preceding, you should avoid detailed text handling by callingsystem APIs with a full line of text or more at a time.andP;  In this manner,word-breaking logic can be handled for you, as well as correct handling ofproportional fonts; the system will also handle the special cases where DBCSstrings can become corrupted.andM;Asian Input MethodsandM;A PM facility introuced in Japanese OS/2 Version 1.1 is the ability tospecify alternative mnemonics.andP;  As you may know, a mnemonic is an underlinedcharacter in menu items or on buttons in dialog boxes.andP;  Typing that characteron your keyboard selects the menu item or button.andP;  The mnemonic keystroke isdefined as the character following the tilde in the menu string provided inthe menu template, &quot;~Item&quot;, for example.andP;  But because there are two types ofkeyboards in Japan (labeled in Katakana or Hiragana and the Latin alphabet)the simple U.S.andP;  scheme had to be extended.andP;  There are two kinds of touchtypists in Japan, those who are accustomed to the standard QWERTY layout andthose who are used to one of the native-Japanese layouts.andP;  (The operator cantoggle between English and Japanese keytops with a special shift key.)andM;To solve this problem, mnemonics can be specified with either the tilde orwith the sequences \036 and \037.andP;  For example, consider a string &quot;Item(\036x\037X)&quot;, where &quot;x&quot; is the U.S.andP;  keyboard mnemonic, and &quot;X&quot; is theKatakana mnemonic.andP;  Then if the U.S.andP;  keyboard mnemonic is active, the menuitem would appear as &quot;Item (x)&quot;; otherwise you'd see &quot;Item (X)&quot;.andP;  The usercan select which of the two mnemonics is to be displayed by setting thesystem value SV ALTMNEMONIC from the Control Panel.andP;  SV ALTMNEMONIC is TRUEif the non-Latin mnemonic is active.andP;  The action of the mnemonic keystrokesis such that when one of the sets of mnemonics is selected, the systemresponds to that key regardless of the shift state of the keyboard.andP;  For anillustration of how mnemonics appear, see Figure 13.andM;The most visible difference in the Japanese input scheme is that the bottomof most screens (Vio screens and PM windows) contains a keyboard status area.andO;This status area should always be present if characters can be entered.andP;  Itis used to reflect the state of the keyboard and to allow Kana-Kanji (KK)conversions.andP;  The possible keyboard states are whether the keyboard is inEnglish, Katakana, Hiragana, or Romanji (Roman character) mode; whether theshift key is depressed; and whether or not KK conversion is enabled.andM;As you might imagine, with more than 3500 Kanjis in use, it would be verydifficult to have a key cap for each possible Kanji character.andP;  Touch typingwould be rather tedious!andP;  To solve this problem, OS/2 allows the user toenter Kana-Kanji conversion mode.andP;  In this mode, all typed input is placed ina conversion window.andP;  The user inputs a Kana string (usually in Hiragana),which is sent to a dictionary when the user presses the VK DBE CONV key.andP;  Thedictionary then returns a Kanji character with that Kana pronunciation.andP;  Ifthe Kanji character is not acceptable, the VK DBE CONV key can be used toselect an alternative Kanji string.andP;  If this Kanji character is acceptable,it is selected with the VK ENTER key, upon which the conversion areadisappears and the characters are relayed to the application.andM;The visual effect of this conversion is shown in Figure 14.andP;  In the Vioscreen, pop-up windows (conversion areas) are placed on the screen at thecurrent cursor location.andP;  In PM, the system sends the WM QUERYCONVERTPOSmessage to the window, asking where to place the conversion window.andP;  Thewindow can either process this message by specifying the coordinates to beused, or it can pass the message to its parent.andP;  The standard frame windowprocedure will place the conversion window on its status line if FCF DBEAPPSTAT has been specified (which is why this flag must be supplied on framewindows when input is occurring).andM;In Vio screens, the bottom of the screen may have several lines reserved forthe status line and input conversion area.andP;  Applications can determine thesize of this area (in lines) by calling function number 7 of VioGetState.andO;Scrolling and cursor positioning are restricted automatically to exclude thestatus area; therefore, to clear the screen without overwriting the statusarea, VioScrollUp should be called with FFFFH as the number of lines toscroll.andM;For PM applications from OS/2 Version 1.2 (OS/2 Version 1.1 in Japan)onwards, the flag FCF DBE APPSTAT should be added to any frame window thathas children that process input (such as dialog boxes that contain entryfields or list boxes).andP;  This flag currently has no effect in the U.S.andP;  andEurope, but creates the status line if the queue code page is a DBCS codepage.andP;  This can be seen on the Japanese window in Figure 1.andP;  Note that otherthan the fact that the client area is smaller by the height of the statusarea, the application behavior is no different.andM;Other ConsiderationsandM;The standard U.S.andP;  and European fonts (Times [R] Roman, Helvetica, andCourier) do not contain DBCS glyphs.andP;  Therefore, if a PM program loads thesefonts, Japanese characters cannot be displayed, even when running under codepage 932.andP;  As a result, the font name string of font resources should becontained in a resource file, just like the other language-dependent strings.andO;Another implication is that the code page of the font must be specified oncreation; if code page 0 is passed to GpiCreateLogFont, the font is createdas a U.S.andP;  and European font.andP;  (Technically, a Universal Glyph List, UGL,font is created.andP;  However, the UGL in OS/2 Version 1.2 contains only U.S.andO;and European characters, so UGL fonts are not sufficient for Japan.)andM;The layout of the LVB in DBCS countries is often quite different from that inthe United States.andP;  There are many proprietary LVB formats; changing theattribute bytes of a Vio screen may yield unpredictable results on differenthardware.andP;  The best approach is to use the worldwide LVB format (see Figure12), which is a superset of the 3-byte attribute format in PM AVIO PSs.andM;You should not directly manipulate the Physical Video Buffer (PVB) in textmode.andP;  Doing this not only exposes your program to vastly different hardwarestandards, but it may also collide with the Asian input method conversionsoftware.andM;Printers must be switched explicitly to the code page of your print job,which is done by calling DosDevIOCtl with the PRT ACTIVEFONT command.andP;  Inaddition, some printer drivers may support other IOCtl commands in othercountries (for example, to select Shift-JIS to JIS character encodingtranslation and the like).andM;A few miscellaneous concerns: always use DosGetDBCSEv to find lead byterange.andP;  Never hardcode ranges for lead bytes.andP;  Add FCF DBE APPSTAT to allframe windows within which input can take place.andP;  Process the WMQUERYCONVERTPOS message if your application deals with general input streams.andM;Sample Vio ProgramandM;MAKEBOX (see Figure 15) is a sample program that simply pops up a messagebox.andP;  The first step in building MAKEBOX is constructing the message panel.andM;In DBCS countries, DosGetMessage retrieves system messages from differentfiles, depending on the process code page.andP;  This allows error messages to bedisplayed in English when the process is not in a DBCS code page.andP;  However,the process code page may or may not be the code page of the video subsystem.andO;Since DosGetMessage uses the process code page, you must explicitlysynchronize the process code page with the current video code page for theduration of the message retrieval.andP;  A worldwide program is likely to be runon machines, especially in Japan, where the familiar frame drawing charactersare not all available or have different character codes, so be sure to usethe MSG APPL messages defined in Figure 5.andM;Traditionally, another area of hardware incompatibility is the layout ofcharacter attributes.andP;  However, OS/2 Version 1.2 and Japanese OS/2 Version1.1 introduced the worldwide LVB format with a standard layout for thecharacter attributes.andP;  This LVB format is fully supported by windowed Vio andfull screen sessions, as far as the hardware is capable.andP;  Unsupportedattributes are ignored.andP;  For example, in Japan, a common limitation is thateither the foreground color or the background color must be black.andP;  Thesolution is to virtualize the character colors of your application and letthe user customize them in the installation process, with suitably restricteddefaults.andP;  MAKEBOX has a color definition table, although in this sample itsvalues are filled with constants.andM;Now that you know how to construct the message panel, the next considerationis how to save and restore the original screen contents.andP;  This presents asmall challenge in the case of DBCS code pages.andP;  You will see shortly why itis so necessary to plan ahead to write a truly wordlwide program; designingsupport for DBCS code pages from the start is much easier than trying tograft it on after the fact.andM;The main problem with saving a rectangular section of a screen containingJapanese text is that double byte characters often occupy two cells on thedisplay.andP;  Often, several of them straddle the boundary of the rectangle thatwill be covered.andP;  When the message box is drawn, it will obscure part ofthese characters.andP;  Since most display hardware is not capable of interpretingpartial characters, Vio automatically replaces the leftover half with a spacecharacter.andP;  Therefore, the area to be saved should be wider by 1 column thanthe sides of the message box, so that the padded characters will be entirelyrestored.andP;  However, the saved rectangle may now contain other halfcharacters; Vio will not let us write cell strings that start or end withincomplete DBCS characters.andP;  There are several solutions to this: the bestchoice depends largely on the architecture of your program.andM;MAKEBOX relies entirely on the Vio API, so that its message box can be usedindependent of the LVB format.andP;  This is especially important since many OEMsin Japan provide LVB formats that are compatible.andP;  If you have a compellingreason to manipulate the LVB directly, you should make your program moreportable by using the worldwide LVB format.andP;  Avoiding direct LVB manipulationmakes it possible to use this sample code in a transparent Vio pop up.andM;MAKEBOX.C saves an area of the screen, draws a message panel, and thenrestores the original screen.andP;  To save the area underneath the message box,use VioReadCellStr on each partial line, extending one column to the left andright around the width of the message box.andP;  (A Vio cell consists ofcharacters and attributes.andP;  The Vio cell calls always handle completecharacters, whether single or double byte.andP;  They will never return half of adouble byte character; they will pad the screen with spaces if necessary.)andO;This may cause you to start by reading the trail byte of a DBCS character orend by reading a lead byte cell.andP;  These orphaned halves of double bytecharacters that start or end cell strings must be taken care of later whenyou restore the rectangle.andM;Vio functions are used to draw the message box.andP;  Vio will replace anyorphaned halves of DBCS characters on the screen with spaces.andP;  When theunderlying rectangle is restored, the original DBCS characters must berestored as well, but you m ust not partially overwrite any DBCS charactersalready on the screen, lest Vio blank out additinal cells.andP;  The functionVioCheckChartType is available to inspect any screen location and determinewhether it is a single cell (that is, alphabetic character) or a leading ortrailing half of a DBCS character.andP;  This function is called for each line'sboundary cells; if you encounter orphaned double byte characters, callVioWrtCellStr with the entire saved cell string for that line.andP;  Thus, you cancorrectly restore the screen contents.andM;Sample PM ProgramandM;As you might suspect, PM controls all handle deadkeys and double bytecharacters properly.andP;  Therefore, the easiest way to write programs thathandle NLS concerns properly is to use PM controls wherever possible.andP;  TYPER(see Figure 16) is a sample PM program.andP;  It allows the user to type in theclient area and has very primitive wordwrapping capability (see Figure 17).andO;The easiest way to write this application is to create a multiline editcontrol (WC MLE) in the client area and have the client window procedureroute WM SIZE messages to it.andP;  However, to demonstrate proper NLS handling,it has been modified to run in all OS/2 environments.andM;In the main routine of a simple PM application, the program will callWinInitialize, WinCreateMsgQueue, create the main application window, code amessage loop, then clean up.andP;  In the main routine of TYPER.C, anInitLeadByteTable call has been added to initialize the global arrayvfIsLeadByte.andP;  After the call, this array will contain Boolean values thattell whether value i is a DBCS lead byte in the current code page.andM;The other modifications in the main routine have been to load strings such asthe program title from the resource file (using WinLoadString) and to add theFCF DBE APPSTAT flag to the frame window.andP;  Note that none of themodifications made above have any effect when running the U.S.andP;  version ofOS/2; the lead byte table would contain FALSE for all entries, the stringscan always be loaded from resources, and FCF DBE APPsTAT has no effect innon-DBCS code pages.andM;WM CHAR ProcessingandM;The TyperChar subroutine is contained within TYPER.C (see Figure 16).andP;  Thiscall performs WM CHAR processing, which involves adding characters to afixed-length line.andP;  The new concerns are deadkey combinations and making surethat double byte characters are not mangled.andM;Deadkeys are handled as follows (assuming that deadkey and compositecharacters are always single byte):andM;* Do not increment the &quot;cursor&quot; (vcchLine).andM;* If the next message is a composite character, overwrite the deadkey (itwill do this automatically since you write at cursor location vcchLine).andM;* If the next message is an invalid composite and the character is a singlebyte space, leave the deadkey character as is.andP;  Increment the characterpointer.andM;* If the next message is an invalid composite and the character is not aspace, wipe out the deadkey.andM;There are two major concerns in handling DBCS characters.andP;  If there is onlyone byte free at the end of the line, you must &quot;wrap&quot; the double bytecharacters to the next line.andP;  Also, remember that if you backspace or deletedouble byte characters, you must delete both bytes.andM;One nice OS/2 feature is that WM CHAR will give entire double byte charactersin a dBCS code page.andP;  This makes it easy to check if you've been given adouble byte character.andP;  If you have, the application will just insert bothbytes into the string.andM;When deleting the character, since you cannot determine whether the precedingbyte is a trail byte or a single byte character, pass the beginning of thestring and the current offset to WinPrevChar and let it compute how far youshould retreat the character pointer.andM;WM QUERYCONVERTPOS ProcessingandM;The WM WUERYCONVERTPOS function is sent by OS/2 to ask where the Kana-Kanjiconversion window is to be placed.andP;  If this message is not processed by theapplication, the conversion wil occur on the status line.andP;  If you choose toprocess the message, set the fields of the mp1 parameters, which points to aPRECTL structure.andP;  The yBottom and xLeft values you specify will be used toplace the conversion window if QCP CONVERT is returned.andP;  If QCP NOCONVERT isreturned, KK conversion is not allowed.andM;In TYPER (see Figure 16), the conversion window is placed at the end of thebottom text line.andP;  It determines the length of the text by callingWinDrawText with the DT QUERYEXTENT flag and uses WinQueryWindowRect todetermine the bottom of the client area of the window.andM;Resource FilesandM;The resource file is essentially equivalent to the message file, in that itstores all the strings that the application will display (such as prompts,menu strings, and titles).andP;  For these resources, the default code page thatthe resource compiler uses is code page 850 (the multilingual code page).andP;  Ifthis default is unacceptable (for example, if you are writing doubel bytemenu items in code page 932), the resource code pages can be specified byusing the CODEPAGE resource directive or by specifying the -cp flag toRC.EXE.andP;  (This flag is -k in some versions of rc.exe.)andP;  In this sampleapplicatin, the strings should be translated in order to be read in thelanguage concerned.andM;The resource file is also the place that alternate mnemonics may be specifiedon the menu items, if you are writing applications for Asian OS/2.andM;SummaryandM;As you can see, PM programs hadnle NLS concerns better than Vio-basedprograms.andP;  The WM PAINT routine does not usually need to be modified sinceclipping does not cause DBCS characters to be bisected.andP;  Wordwrappingbehavior already works properly because WinDrawText was used (with DTWORDBREAK).andM;The code modifications that had to be made to TYPER included initializing thelead byte table, putting strings into the resouce file, adding CFC DBEAPPSTAT to the frame window, fixing the WM CHAR processing, and addingprocessing for the WM Queryconvertpos messages.andP;  Nontrivial work, but theresult is a program that will run corectly with all versions of OS/2, wherethe only additional localization has been restricted to the resource file.andO;</TEXT></DOC>