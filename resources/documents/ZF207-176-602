<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-176-602  </DOCNO><DOCID>07 176 602.andM;</DOCID><JOURNAL>AI Expert  April 1989 v4 n4 p36(6)* Full Text COPYRIGHT Miller-Freeman 1989.andM;</JOURNAL><TITLE>How to print a file: an expert system approach.andO;</TITLE><AUTHOR>Selfridge, Peter G.andM;</AUTHOR><SUMMARY>Printing a file in a UNIX environment can pose surprisingdifficulties.andP;  Printing such files, considered as a developmentsituation, illustrates a class of software problems that involverecombining existing programs.andP;  Here, the printing problem isexamined, a model of printing is presented, and an implementationis described that tests the model and identifies research issues.andM;</SUMMARY><DESCRIPT>Topic:     UNIXPrintersExpert SystemsFile ManagementKnowledge-Based SystemsModelingSoftware Engineering.andO;Feature:   illustrationprogram.andO;Caption:   Pipeline for printing 'memo.' (program)AutoPrint recognizes three options in user's request. (program)AutoPrint prevents user from producing erroneous output. (program)andM;</DESCRIPT><TEXT>How to PRINT A FILE:andM;Printing a file in a UNIX environment is a real-world problem that can posesurprising difficulties to UNIX users.andP;  Printing files also illustrates aclass of software problems characterized by the recombination of existingprograms.andP;  Automating the printing process involves designing knowledgerepresentations to capture knowledge of both the printing software and theprinting process and designing a reasoning system that uses those knowledgerepresentations in a working implementation.andP;  This article will examine theprinting problem, present a model of printing, and describe an implementationdesigned to test the model and identify the next set of research issues.andP;  Theimplementation, AutoPrint, successfully automates the printing process andillustrates a knowledge-based approach to software problems.andM;Developing knowledge representations for software and software systems is animportant research topic and a prerequisite to solving practical AI problems.andO;Developing expert level systems to do software tasks is increasinglyimportant as programming and using large systems becomes more complicated.andO;Such expert systems will need explicit knowledge representations of software,software components, and reasoning mechanisms that use those representations.andO;High-level automatic programming, in which existing software modules arerecombined for new purposes, will need knowledge representations that capturethe invocation rules, input and output behavior, and software side effects.andM;The research goal is to take a specific software domain (printing files inUNIX), model the domain and the software used in that domain, developknowledge representations and reasoning mechanisms based on this model, andfinally, test the representations and reasoning mechanisms in a workingimplementation.andP;  A corollary of this strategy is that the implementationshould be specific enough so it clarifies the next set of research issuesthat should be addressed.andM;THE PRINTING PROBLEMandM;The UNIX operating system allows programs to be combined so the output of oneprogram becomes the input to the next program; several programs can becombined into a pipeline.andP;  A program designed to be included in a pipeline iscalled a translator.andP;  Listing 1 is a pipeline for printing the file memo on aparticular printer in our laboratory.andM;UNIX interprets this pipeline as follows.andP;  In step 1, memo is opened by theprogram cat and sent as a stream of data to step 2, the translator eqn, whichtranslates equation text into troff format, the primary document format.andP;  Instep 3, the resulting stream is sent to the translator tbl, which does thesame thing to the table text.andM;In step 4, the result is received by the primary formatting translator,troff.andP;  Troff also takes the option indicator --mm from the command line,step 4b, which tells it to use a particular macro package for decipheringcertain macro commands present in the text.andP;  The output of troff is a trofffile, in which the text has been completely replaced by troff commands.andP;  Thefinal destination of the data stream, step 7, indicated by lpr -- Plw, is aparticular printer, the lw (laser writer) printer.andP;  This is a PostScriptprinter, which takes data in the PostScript format.andP;  Therefore, step 5 isrequired, in which the translator dpost translates troff format intoPostScript format.andP;  Dpost is given another option in step 5b, which specifieswhat subset of the document should be printed; in this case, pages 1 through9.andP;  Finally, the translator postreverse is needed in step 6 to order thepages properly front to back.andM;Generating an appropriate pipeline can be difficult for many reasons: thedifferent kinds of text present in the file, what translators are needed toprocess the file, how to invoke them, and the order in which they must appearmust be known.andP;  Additionally, some options (such as --mm) are critical to thefinal appearance of the printed document and must be included in the properplace.andP;  An appropriate printer must be chosen, and not all printers can printall kinds of files.andP;  Other translators may be needed and other optionsdesired that must be properly invoked and included in the pipeline.andO;Occasionally it is necessary to detect that a printer is down or otherwiseinaccessible or has a prohibitively long queue of current printing jobs.andO;Finally, people typically use a given printer and options most of the time,so using defaults correctly becomes part of the problem.andM;Automating the printing process is an important research project for tworeasons.andP;  First, such a system would be quite useful.andP;  More importantly, theprinting problem is representative of a class of software problems thatinvolve recombining existing programs.andP;  Recombining existing programs islikely to become a very important mechanism for creating software and aidingin understanding, debugging, and revising it.andP;  Progress on the printingproblem should identify the next set of research issues relevant to thelarger problem of automatic programming by program recombination.andM;The problem of representing software knowledge for automatic programming hasbeen addressed by a number of researchers.andP;  C. Rich, R. C. Waters, and othershave developed the &quot;programmer's apprentice&quot; framework and various techniquesfor representing knowledge of specific program constructs.andP;  Their methodsaddress a lower level of automatic programming and representation of softwareknowledge and are not directly applicable to the problem of automaticrecombination of existing programs.andM;R.andP;  Wilensky's UNIX consultant project addresses the representation ofsoftware knowledge to help the user find particular UNIX commands but doesnot address command combination to achieve other goals.andP;  Other research intoautomatic programming almost exclusively uses the transformation approach,which represents programming knowledge as correctness-preserving syntactictransformations applied to a semantically correct program &quot;specification.&quot;andO;Transformation approaches are not usually applied to recombining programssince they are tailored to the construction of small programs for specificlow-level computations.andM;Thus the problem of printing files in UNIX and the goal of automating thistask are practically and theoretically important.andP;  They generate thefollowing problems that must be addressed in the domain model andimplementation:andM;* How are translators and options chosen?andM;* How are they properly ordered?andM;* How are printers selected?andM;* How can user defaults be handled?andM;*How can erroneous printer output be minimized?andM;FILE TYPE/PRINTING MODELandM;The general model of printing files in a UNIX environment is based on theobservation that the file (including data flowing through a pipeline) can beviewed as an object with a set of properties or types, each type representingone kind of text in the file.andP;  With this view, a translator can be modeled asan operator that changes the set of types of the data object, a printer canbe modeled as a terminal operator that can only accept data of a specifictype; user defaults can be modeled as demons; and the printing process can bemodeled as a sequence of operations to detect the file types, select aprinter and translators, and order them to produce the final pipeline.andM;With this model in mind, the specific types of knowledge needed and theirgeneral representation should be identified.andP;  For example:andM;Knowledge of file typesandM;* Text patterns that indicate file types.andM;Knowledge of translatorsandM;* Translator input typeandM;* Translator output typeandM;* Translator orderandM;* Translator invocationandM;* Possible options.andM;Knowledge of printersandM;* Printers statusandM;* Printer queue lengthandM;* Printer hostandM;* Host statusandM;* Printer invocationandM;* Printer input.andM;Each kind of knowledge can be represented as a frame, or knowledge structure,which is a named object with slots.andP;  Two such frames are shown here: FRAMETYPE:  translator name:  tbl input:  tbl output: troff order:  10 help:  tblprocesses tbl commands to format tables FRAME TYPE:  printer name:  dp2invocation:  lpr -Pdp2 input: postscript status:  unkown host:  vivaceh-status:  unknown loc: rm.3c-441 help:  &quot;large, fancy laser printer&quot;andM;For the translator frame, the input slot is used after the file types aredetected.andP;  For each detected file type in the user file, the translatorknowledge base is searched for a translator that can translate that type.andO;The output slot indicates what output type is produced, and this is used toselect more translators.andP;  The order slot is used to order the translators inthe final output command line.andP;  (In this domain, translators have a fixedorder that can be represented by an integer; that is, the translator troff isgiven a higher order because it always follows tbl in the command line.) Thehelp slot is used when a user requests information about a particulartranslator or all translators.andM;The printer frame is similar.andP;  The invocation slot indicates how to invokethe printer in a command line.andP;  The input slot indicates the type of input itneeds, the status and host-status slots store whether that printer and itscomputer host are up or down, and the help and location slots provide summaryinformation about the printer.andP;  Knowledge about file types and options issimilarly encoded in frames.andM;User defaults, an important part of automating the printing process, can bemodeled as small demons that fire when a specific pattern is observed.andP;  Forexample, if the user's default troff macro package is --mm, when troff is tobe used in the final output, --mm can be automatically generated andincluded.andM;The printing process is modeled as follows:andM;* Determine the printability of the file.andM;* Determine the set of types of the file.andM;* Select a printer if one is not indicated.andM;* For each type of file, select a translator that will translate the typeinto one that is eventually printable on the selected printer.andM;* Select other translators if necessary.andM;* Determine the order of the translators and options and construct the finalcommand line.andM;This model is based on the flow of typed data and the translation of typesinto other types.andP;  Knowledge of file types, translators, and printers isencoded in frames, and procedural knowledge is encoded in scripts.andM;IMPLEMENTATIONandM;The AutoPrint implementation was written to evaluate this approach.andO;AutoPrint consists of 200 OPS5 rules and another 20 routines written in C,which encode in procedural form several kinds of low-level knowledge aboutfiles and file types.andP;  AutoPrint was initially implemented using C5, aUNIX-based version of OPS5 developed at ATandamp;T Bell Laboratories.andP;  AutoPrintcan be used as a stand-alone program to print files, examine the knowledgebases of printers, translators, and options, examine printer queues, removejobs from printer queues, and get help.andP;  In addition, it can be calleddirectly from the shell by typing &quot;print&quot; followed by a file name and,optionally, a printer and other option specifications.andP;  Implementationdetails will not be presented here, but the frames described in the lastsection are represented as OPS5 literals and the 200 rules encode the flow ofcontrol.andP;  Rather, AutoPrint is illustrated using the five questions listed atthe end of &quot;The Printing Problem&quot; section.andM;The first example illustrates AutoPrint selecting translators based ondetected types of the input file, the use of knowledge about the indicatedprinter to refine the set of translators, and the use of user defaults.andP;  Theuser requests that AutoPrint print the file memo on the xpp2 printer.andO;AutoPrint determines the types of file memo and uses knowledge of the printerto remove troff from the list of types while retaining nroff, which thatprinter can handle.andP;  This knowledge is derived from the fact the xpp2 canhandle only ASCII text, and no known translator can translate troff to ASCII.andO;AutoPrint also uses knowledge of the user's defaults to select the option --mm and include it in the final command line.andP;  What the user types is in bold:% print memo xpp2 'memo' CONTAINS ascii tbl troff nroff TEXT APPROPRIATETRANSLATORS: tbl troff nroff REMOVING troff - nroff PRINTER INDICATED: xpp2DEFAULT OPTION --mm SELECTED FOR TRANSLATOR nroff TRANSLATORS AND OPTIONSORDERED GENERATED PRINT COMMAND: cat memo ! tbl ! nroff --mm ! lpr -Pxpp2 %andM;Listing 2 illustrates AutoPrint's response to a more complicated request.andO;AutoPrint uses its knowledge to recognize the three options in the user'srequest.andP;  It recognizes that one option conflicts with a default option, andthe user is informed the default will not be used.andP;  Knowledge that a troffprinter is available and that troff is generally preferred over nroff is usedto select troff.andP;  It uses additional knowledge to select eqn (negn is usedwith nroff).andP;  A default printer, set of translators for handling the filetypes, and two other required translators (dpost and postreverse) areselected.andP;  Finally, the detected options are inserted into the command lineusing option knowledge.andM;Listing 3 shows the use of knowledge to prevent a user from producingerroneous output: a directory and executable file.andP;  Then, AutoPrintrecognizes that a tex file can't be printed on the eps2 printer and producesan explanation of a sort (producing better explanations will require furtherresearch).andP;  The user then relies on the default printer and the requestsucceeds.andP;  Thus the implementation successfully automates most of theprinting process and results in a very useful tool.andP;  The problems discussedare all handled adequately, and AutoPrint's output is sufficient to printfiles and allow the user to follow the processing required.andM;PROBLEMS FOR USEandM;AutoPrint is used daily by technical and nontechnical people.andP;  Althoughadequate for the initial printing domain, the underlying software modulemodel is relatively shallow.andP;  It consists essentially of type knowledge forinput and the output, similar to D. E. Perry's work, (which focuses onseveral &quot;programming in the large&quot; problems, including interfacespecifications).andP;  This knowledge is adequate for the printing implementationbut not for a more complicated domain such as information retrieval.andP;  Thereis no knowledge encoding other kinds of side effects nor, more importantly,representation of some of the underlying objects.andP;  For example, the systemhas no knowledge that --mm tells troff to open a particular file in aparticular directory.andP;  If that file is not available, the system has no wayof intelligently handling that situation or providing any help to the user.andO;A much more comprehensive model of the underlying objects and behavior, alongthe lines of Wilensky's representation, is needed.andM;The system has no representation for the invocation of a piece of software;it assumes all translators can be included in a UNIX pipeline.andP;  In fact, thiswas not the case with the programs latex and dvi2ps (they had to be embeddedin a shell script to be pipeline compatible).andP;  The invocation pattern andside effects of using latex are complicated: latex takes a command-lineargument that is the first part of the file name, and the extension tex isassumed.andM;In addition, several log files are created s a side effect and particularthings happen when certain kinds of errors occur.andP;  For a system to cope withthese kinds of things intelligently, it needs a comprehensive representationof the invocation patterns, side effects, and normal behavior of software andsoftware systems.andP;  To do this, an underlying process model of the entireenvironment, including the file system, terminal input and output, andstorage allocation is needed.andM;Research into representing knowledge of software and software systems is animportant and growing area, and this discussion has only touched the surface.andO;Several areas for future work suggest themselves.andP;  First, a more complicateddomain is needed.andP;  One possibility is to try to apply the software knowledgerepresentation techniques used here to software information retrieval,allowing the retrieval of appropriate modules based on a functionaldescription of the software and its behavior, including I/O.andM;To do this, more advanced representation techniques will be necessary.andP;  Thesetechniques should first be applied to representating the underlying softwareenvironment of UNIX: the file system, UNIX invocation patterns, and terminalinteractions, all of which can get very complicated.andP;  Once the environment isdescribed, software embedded in that environment can be more completelyrepresented.andM;Finally, this work has not been concerned with how people think aboutsoftware.andP;  A more cognitive approach should elucidate the kinds of modelspeople have about software and software systems (how a file gets printedwould be a good initial domain) and how people detect and fix errors in theprocess and their model of the process.andP;  Such knowledge should help us designfuture software knowledge representations and systems.andM;FUTURE POSSIBILITIESandM;We identified a domain: printing files in a UNIX environment, which is a goodexample of a complex software system, yet tractable from the representationpoint of view.andP;  We explored the kinds of knowledge that needed to berepresented and built representations of the different software components ofthe printing process.andP;  The implementation, AutoPrint, used thoserepresentations and achieved almost all the performance goals.andM;This work serves to hihglight the next set of research issues to be addressedin software knowledge representation, such as deeper representations ofsoftware objects (including module invocation and side effects),representation of the underlying software environment (including the filesystem, memory allocation, and terminal interface), and investigation ofhuman cognitive models of software.andO;</TEXT></DOC>