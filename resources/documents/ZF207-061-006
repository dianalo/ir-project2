<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-061-006  </DOCNO><DOCID>07 061 006.andM;</DOCID><JOURNAL>Communications of the ACM  Feb 1989 v32 n2 p239(7)* Full Text COPYRIGHT Assn. for Computing Machinery, Inc. 1989.andM;</JOURNAL><TITLE>An approach to the recursive retrieval problem in the relationaldatabase. (technical)</TITLE><AUTHOR>Tillquist, John; Feng-Yang Kuo.andM;</AUTHOR><SUMMARY>Extensions to the QUEL language of RT-Ingres have becomeincreasingly important as a means to facilitate the recursiveretrieval function of query language based relational databases.andO;QUEL is examined as a way to simplify the user interface becausehost query languages often impede data retrieval in recursivedatabase structures.andP;  Examples of commonly used recursive datastructures are used to illustrated the problem and the solution.andO;Functional extensions of the QUEL language based on the idea oftransitive close are shown to reduce the complexity in accessingdata that have recursive structures.andP;  The result is a moreaccessible user interface on the database, with subsequentreduction of demands on technical staff.andP;  Research is still neededon the functional extensions into form based query languages suchas QBE or Query By Forms.andM;</SUMMARY><DESCRIPT>Topic:     RecursionRecursive DescentInformation Storage and RetrievalRelational DBMSQuery Languages.andO;Feature:   illustrationgraph.andO;Caption:   Parts explosion of a bicycle. (graph)The ORGANIZATION graph. (graph)andM;</DESCRIPT><NOTE>Only Text is presented here; see printed issues for graphics.andO;</NOTE><TEXT>AN APPROACH TO THE RECURSIVE RETRIEVAL PROBLEM IN THE RELATIONAL DATABASE Inrecent years, there has been an emphasis on extending relational databaselanguages to effectively retrieve information from recursive data structures.andO;Commonly used recursive data structures are those for EMPLOYEE(employee-MANAGING-employees) and PARTS (parts-MAKE-parts).andP;  In the EMPLOYEEdata structure, an employee may supervise many other employees but can onlybe supervised by one other employee (e.g., a one-to-many relationship).andO;Information can be retrieved from these data structures to answer queriessuch as: find all employees who directly or indirectly report to Susan andcalculated quantities for all required parts for the Model-350 bicycle.andM;Such recursive data structures are especially important to decision making.andO;For example, the EMPLOYEE data structure can be used to determine budgetallocation, and the PARTS data structure can be used for productionscheduling.andP;  Most existing relational database languages, however, havefailed to facilitate retrieval from recursive data structures.andP;  Themethodologies used are often procedural and require expert programming skillswith a traditional programming language.andP;  To an end-user, the retieval taskthus becomes a nightmare due to his or her lack of this technical knowledge.andM;This article examines extensions to the QUEL language of RT-Ingres tofacilitate this recursive retrieval function using the Theory of TransitiveClosure.andM;METHODOLOGIES USEDandM;Initially, a recursive data structure is converted to a directed graph, inwhich a node represents a data instance and an arc represents a relationshipinstance.andP;  An intermediate data structure is generated to represent the treestructure that is equivalent to the directed graph.andP;  Finally, a new datastructure which describes transitive closure can then be derived.andP;  Giventhese data structures, extended QUEL operators can be used to performfunctions such as (1) for any given starting node to reach an ending node,determine what intermediate nodes are required, and (2) for a given node,determine all its destination nodes that do not have any outgoing arcs.andO;Furthermore, additional operators can be used to associate values to the arcsof the directed graph and to traverse the graph based on an arc's value.andP;  Byapplying those operators, queries mentioned in the first paragraph can beeasily answered.andM;RECURSIVE RETRIEVAL FUNCTIONSandM;Under the Relational Theory, the primary key is always unique with theforeign key capable of having multiple instances.andP;  This imposes the conditionof structures using the foreign key as the transversal to be one-to-many.andP;  Inthe ORGANIZATION relation in Table I, each EMPLOYEEE has a unique name, whilea particular foreign key MANAGER has multiple occurrences.andM;From the depiction of the ORGANIZATION structure, the relationship of FOSTERto ALLEN is seen as an indirect reporting structure, with BROWN acting as thetransitive bridge between FOSTER and ALLEN.andP;  In the tabular format, BROWNacts as a transitive bridge by appearing as the foreign key (as MANAGER) tothe primary key (as EMPLOYEE).andM;The directed graph of this relation may be represented as a tree structure.andO;This is illustrated in Figure 1.andM;Recursive element graphs are also limited in that they may not contain anycyclic closures; or in the ORGANIZATION graph, an employee does not report tohimself at any level within the structure.andM;A method of traversing these types of graphs is the transitive closureoperation.andP;  Transitive closure is the iterative or recursive assimilation ofthe subordinate record to the parent record via a pair of attributes sharinga common value.andP;  Alternatively, this may be expressed as closing thetransitive bridge between two records to create a separate composite record.andM;An example of the transitive closure would be to solve the query: Name theemployees who work for manager ALLEN.andP;  Under QUEL, a query stated throughsimple selection: RANGE OF O IS ORGANIZATION RETRIEVE (O.MANAGER, O.EMPLOYEE)WHERE (O.MANAGER = &quot;ALLEN&quot;) would yield only those employees directlyreporting to Manager ALLEN (i.e., BROWN and CARTER).andP;  Through an iterativeprocedure performing transitive closure (maintaining the intermediate nodesthrough the traversal), all employees who work for manager ALLEN areobtainable in the resultant relation TEMP1 shown in Table II.andP;  RANGE OF O ISORGANIZATION RETRIEVE INTO TEMP1 (O.ALL) WHERE (O.MANAGER = &quot;ALLEN&quot;) !andO;Retrieve tuples where MANAGER = &quot;ALLEN&quot; /GO RANGE OF T1 IS TEMP1 /MARKITERATION RETRIEVE INTO TEMP2 (O.EMPLOYEE, T1.MANAGER) WHERE (O.MANAGER =T1.EMPLOYEE) ! Bridge closure on MANAGER /GO RANGE OF T2 IS TEMP2 APPEND TOTEMP1 (T2.EMPLOYEE, MANAGER = &quot;ALLEN&quot;) ! Close bridge on MANAGER = &quot;ALLEN&quot;/GO /BRANCH ?(TUPLECOUNT) [left arrow] 0 ENDITER ! Branch until no moretransitives DESTROY TEMP2 /GO /BRANCH ITERATION ! Walk down next recursionlevel /MARK ENDITER DESTROY TEMP2 /GOandM;Extension of the retrieval language may be written as non-proceduralfunctions embedded within the language, allowing the transitive closureoperation to be expressed in the form of a generalized grouping function: X =TCLOSE(R.A, R.B) where the resultant subgraph, X, is the transitive closureof relation R over the attributes A to B.andP;  Note that the TCLOSE operationclosing A to B may produce results significantly different than that of B toA in more complex graphs.andM;Expounding on the TCLOSE function, an application to the ORGANIZATIonrelation would allow for the inclusion of subordinate salaries (as shown inTable III) RETRIEVE (O.SALARY BY TCLOSE(O.MANAGER, O.EMPLOYEE)) WHERE(O.MANAGER = &quot;ALLEN&quot;) from which the total salary budget for ALLEN'ssubordinates may then be calculated through the built-in SUM function.andP;  Usingthe SUM function through traversal recursion to calculate arc distances(termed Associative Closure) is consistent with properties of path algebra.andO;Other built-in functors may also be combined with traversal recursion tocompute reachability, duration, critical pathing, and other difficultqueries.andM;Consider the project management graph, where each node of the graphquantifies the duration of a task.andP;  By applying associative closure, thetotal duration of each leg of the graph may be calculated, and the built-inMIN function would then isolate the critical (shortest duration) path fromthe resultant subgraph.andM;Carre demonstrated that summarization and join functions based on thefundamental transitive closure operation could be reduced to a series ofsimultaneous equations, facilitating implementation of transitive extensionsto data manipulation languages.andP;  These operations may then be used tofacilitate end-user retrieval problems as embedded functions to the hostlanguage.andP;  This would allow for simplified manipulations of distance,duration or other quantitative aggregations along the nodal pathways of arecursive structure.andM;Some relations, while complying with primary key integrity, describe acomplex graph as having an underlying many-to-many structure.andP;  An example ofsuch a structure (Figure 2) is the parts explosion problem, where subordinateparts in an assembly constitute many subassemblies.andM;Here, the BOLT element is used in the assembly of both the CRANK and theAXLE, and the representation of the graph is not a simple tree.andP;  If theMAJOR_PART and MINOR_PART attributes form the composite primary key for therelational depiction of this graph, then the relation maintains primary keyintegrity of uniqueness, and therefore maintains the appearance of aone-to-many relation.andM;By defining the MAJOR_PART and MINOR_PART attributes as the composite primarykey, the MINOR_PART may not be a foreign key since by definition a foreignkey must contain the full value of the referenced primary key.andP;  The TCLOSEfunction remains valid, however, because the operands need not be key values.andO;For transitive closure, the operational attributes need only to be drawn fromthe same underlying domain.andP;  It is this property of a recursive traversalthat allows a relation to describe complex structures such as the COMPONENTSrelation (Table IV).andM;By explicitly defining the projection attributes within the TCLOSE function,specific endpoints of the closure may be assigned.andP;  The TCLOSE function maybe applied to the COMPONENTS relation in the resolution of the query, Whatparts are necessary to build a BICYCLE?andP;  by binding an explicit value (inthis case, &quot;BICYCLE&quot;) to MAJOR_PART: RETRIEVE (TCLOSE(C.MAJOR_PART,C.MINOR_PART)) WHERE (C.MAJOR_PART = &quot;BICYCLE&quot;)andM;And conversely, applied to the query, &quot;What assemblies require the use of aBOLT?&quot; RETRIEVE (TCLOSE(C.MINOR_PART, C.MAJOR_PART)) WHERE (C.MINOR_PART =&quot;BOLT&quot;)andM;Note that the first query will produce applicant tuples in the resultantrelation, as shown in Table V, with the first tuple being from theCRANK--BOLT branch of the graph, and the second from the AXLE--BOLT branch.andO;Implementations of the transitive closure operation must have the capabilityto uniquely retain intermediate nodes in order to avoid replicants and toprovide a traceback capacity from the resultant subgraph.andP;  This may beaccomplished by retaining the transitive attribute (the bridge) within theresultant relation, (as shown) as an enhancement to the previous QUELprocedure: RANGE OF C IS COMPONENTS RETRIEVE INTO TEMP1 (C.ALL) WHERE(C.MAJOR_PART = &quot;BICYCLE&quot;) ! Select tuples with Major_Part = BICYCLE /GORANGE OF T1 IS TEMP1 RETRIEVE INTO TEMP2 (BRIDGE = T1.MINOR_PART,C.MINOR_PART) WHERE (T1.MINOR_PART = C.MAJOR_PART) ! Create an explicittransitive bridge /GO RANGE OF T2 IS TEMP2 MARK ITERATION APPEND TO TEMP1(MAJOR_PART = T2.BRIDGE, T2.MINOR_PART) ! Store bridged composite tupleRETRIEVE INTO TEMP3 (BRIDGE = T2.MINOR_PART, C.MINOR_PART) WHERE(T2.MINOR_PART = C.MAJOR_PART) ! Bridge next level of recursion DELETE FROMT2 /GO RANGE OF T3 IS TEMP3 ! Store bridges for next iteration APPEND TOTEMP2 (T3.ALL) /GO DESTROY TEMP3 /GO /BRANCH ? [left brace'TUPLECOUNT[rightbrace] andgt;0 ITERATION ! Walk down next level of recursion APPEND TO TEMP1(MAJOR_PART = T2.andP;  BRIDGE, T2.MINOR_PART) ! Store all levels into TEMP1DESTROY TEMP2 /GOandM;This enhancement may be expressed as a built-in NODES function: RETRIEVE(NODES(C.MAJOR_PART, C.MINOR_PART)) WHERE (C.MAJOR_PART = &quot;WHEEL&quot;) whichproduces Table VI:andM;If the traversal tuples (those tuples where the referencing attribute existsas a referenced attribute within the relaiton) from the NODES function arethen eliminated through selection, the endpoint leaves of the graph areisolated, shown in Table VII.andM;In the case of the above relation, the resultant describes the indivisibleparts necessary for the assembly of a WHEEL.andP;  The functional description ofthis operation is: X = LEAVES(R.A, R.B) where subgraph X results from thedeletion of tuples (X.A, X.B) from NODES(R.A, R.B), where X.B exists in thesource relation R as R.A.andM;This operation will return all leaves of the graph, including those leavesterminating at different levels of recursion.andP;  If explicit values are boundto the traversing attributes, however, and a leaf is not on a direct pathwaybetween the attributes (i.e., the leaf originates outside of the directpathway of the subgraph), then it will not be included in the resultant ofthe LEAVES function.andM;AGGREGATE FUNCTIONSandM;If in a complex graph entire assemblies were used at various levels ofaggregation instead of being leaves of the structure, the closure operationsdescribed above could lose information when combined with built-in functions.andO;Consider Figure 3.andM;If the QTY attribute describes the amount of time necessary to assemble theMINOR of the MAJOR part, then the summation of the replicant-free resultantof a NODES function would not describe the total time required to assemblepart A, shown in Tables VIIIa and VIIIb.andP;  RANGE OF MLA IS ASSEMBLIES RETRIEVEINTO TEMP1 (MLA.QTY BY NODES (MLA.MAJOR, MLA.MINOR)) WHERE (MLA.MAJOR = &quot;A&quot;)RANGE OF T1 IS TEMP RETRIEVE (TTL =SUM(T1.QTY)) TEMP1 relation (beforeremoval of replicants):andM;The SUM of the resultant TEMP1 would not be the total duration of buildingpart A.andP;  Although, if the SUM function were applied prior to the removal ofthe replicant tuples, then the correct total for the duration of A wouldresult.andP;  Application of the built-in functions such as SUM, MIN, MAX, AVG,etc.andP;  must be able to be performed before replicants have been eliminated, oron the intermediate result of each iteration of the transitive closure.andP;  Withthis in mind, the use of the NODES function may then be expressed: RETRIEVE(TTL = SUM(MLA.QTY BY NODES(MLA.MAJOR,MLA.MINOR))) WHERE (MLA.MINOR = &quot;A&quot;)with the final result of the query as show in Table IX.andM;To perform the multiplicative traversal, the problem becomes even morecomplicated for the end-user.andP;  To retrieve the number of components necessaryfrom the ASSEMBLIES relation, the quantity of parts is contingent on thenumber of assemblies necessary to build the next level of component.andP;  Forexample, to answer the query, How many Fs are necessary to build an A?, it isnecessary to compute the number of Cs (as the traversal intermediate) thatmay be built from a quantity of Fs, and then to compute the number of these Cassemblies are necessary for a single A.andM;Obviously, the solution requires multiplying F.QTY by C.QTY upwards to A.andO;Once again, the use of an aggregate function when used in conjunction with aclosure operation must use the intermediate results of the closure.andP;  Here,however, the multiplication must occur at each level of recursion, ratherthan at the end of the closure operation.andP;  Borrowing the syntax from theassociative closure, a new functor, COMPOUND, may be introduced to identifythe operation: RETRIEVE (TTL = COMPOUND(MLA.QTY BY LEAVES(MLA.MAJOR,MLA.MINOR))) WHERE (MLA.MAJOR = &quot;A&quot; AND MLA.MINOR = &quot;F&quot;) producing therelation as shown in Table X.andM;CONLUSIONandM;Functional extensions of the QUEL language based on the concept of transitiveclosure have been shown to reduce the complexity in accessing data that haverecursive structures.andP;  They can facilitate end-user operations on thedatabase in ad hoc situations; this results in less reliance on technicalstaff to develop specialized programs.andM;Although expressed in QUEL, the extended functions described in this articlemay be applied to Structured Query Language (SQL).andP;  The QUEL query forperforming a transitive closure operation on a recursive relation R istranslated into SQL: RANGE OF R IS X RETRIEVE (TTL = SUM (X.QTY BY LEAVES(X.A, X.B))) WHERE (X.A = &quot;xx&quot;) in SQL: SELECT  SUM (QTY) FROM  R WHERE  A =&quot;xx&quot; GROUP  BY LEAVES (A, B) as well as for NODES: RANGE OF R IS X RETRIEVE(TTL = COMPOUND) (X.QTY BY NODES(X.A, X.B))) WHERE (X.A = &quot;xx&quot;) in SQL:SELECT  COMPOUND (QTY) FROM  R WHERE  A = &quot;xx&quot; GROUP  BY NODES (A, B)andM;The full BNF syntax of the group-by-clause, as described in [10], is enhancedto include the transitive closure functionality: group-by-clause :: = GROUPBY [column-ref-commalist ! NODES (Column-ref, column-ref) ! LEAVES(column-ref, column-ref)[right brace] and the distinct-function-ref isappended: distinct-function-ref :: = [left brace]AVG ! MAX ! MIN ! SUM !andO;COUNT ! COMPOUND)[right brace] (DISTINCT column-ref)andM;Previously, Zloof employed &quot;levels&quot; as a qualifier to Query By Example (QBE)column entries to traverse a recursive structure.andP;  This approach is limitedin use because of its inability to close complex recursions and to performassociative or multiplicative Closure.andM;In the future, research is necessary to study the incorporation of thesefunctional extensions into form-based query languages, such as QBE or QueryBy Forms (QBF).andP;  Work is needed to investigate a suitable presentationmetaphor for a casual user to gain an operative understanding of recursivetraversal.andO;</TEXT></DOC>