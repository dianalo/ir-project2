<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-646-912  </DOCNO><DOCID>07 646 912.andM;</DOCID><JOURNAL>Communications of the ACM  Sept 1989 v32 n9 p1134(2)* Full Text COPYRIGHT Assn. for Computing Machinery, Inc. 1989.andM;</JOURNAL><TITLE>Abstracts from other ACM publications. (programming languages andsystems, database systems, and mathematical software) (technical)</TITLE><AUTHOR>Kaiser, Gail E.; Cameron, Robert D.; LaLonde, Wilf R.; Weihl,William E.; Burns, James E.; Yu, C. T.; Embley, David W.andM;</AUTHOR><DESCRIPT/><NOTE>Only Text is presented here; see printed issues for graphics.andO;</NOTE><TEXT>Abstracts from Other ACM PublicationsandM;ACM Transactions on Programming Languages and Systems April 1989andM;Incremental Dynamic Semantics for Language-BasedandM;Programming Environments Gail E. KaiserandM;Attribute grammars are a formal notation for expressing the static semanticsof programming languages--those properties that can be derived frominspection of the program text.andP;  Attribute grammars have become popular as amechanism for generating language-based programming environments thatincrementally perform symbol resolution, type checking, code generation, andderivation of other static semantic properties as the program is modified.andO;However, attribute grammars are not suitable for expressing dynamicsemantics--those properties that reflect the history of program executionand/or user interactions with the programming environment.andP;  This paperpresents action equations, an extension of attribute grammars suitable forspecifying the static and the dynamic semantics of programming languages.andP;  Itdescribes how action equations can be used to generate language-basedprogramming environments that incrementally derive static and dynamicproperties as the user modifies and debugs the program.andM;For Correspondence: Columbia University, Department of Computer Science, NewYork, NY 10027.andM;Efficient High-Level Iteration with Accumulators Robert D. CameronandM;Accumulators are proposed as a new type of high-level iteration construct forimperative languages.andP;  Accumulators are user-programmed mechanisms forsuccessively combining a sequence of values into a single result value.andP;  Theaccumulated result can either be a simple numeric value such as the sum of aseries or a data structure such as a list.andP;  Accumulators naturally complementconstructs that allow iteration through user-programmed sequences of valuessuch as the iterators of CLU and the generators of Alphard.andP;  A practicaldesign for  high-level iteration is illustrated by way of an extension ofModula-2 called Modula Plus.andP;  The extension incorporates both a redesignedmechanism for iterators as well as the accumulator design.andP;  Severalapplications are illustrated including both numeric and data structureaccumulation.andP;  It is shown that the design supports efficient iteration bothbecause it is amenable to implementation via in-line coding and because itallows high-level iteration concepts to be implemented as encapsulations ofefficient low-level manipulations.andM;For Correspondence: School of Computing Science, Simon Fraser University,Burnaby, British Columbia V5A 1S6, Canada.andM;Designing Families of Data Types Using Exemplars Wilf R. LaLondeandM;Designing data types in isolation is fundamentally different from designingthem for integration into communities of data types, especially wheninheritance is a fundamental issue.andP;  Moreover, we can distinguish between thedeisgn of families--integrated types that are variations of each other--andmore general communities where totally different but cohesive collections oftypes support specific applications (e.g., a compiler).andP;  We are concernedwith the design of integrated families of data types as opposed to individualdata types; that is, on the issues that arise when the focus is intermediatebetween the design of individual data types and more general communities ofdata types.andP;  We argue that design at this level is not adequately served bysystems providing only inheritance hierarchies and that systems whichadditionally provide a coupled subtype specification hierarchy are still notadequate.andP;  We propose a system that provides n unlimited number of uncoupledspecification hierarchies and illustrate it with threed a subtype hierarchy,a specialization/generalization hierarchy, and a like hierarchy.andP;  We alsoresurrect a relatively unknown Smalltalk design methodology that we callprogramming-by-exemplars and argue that it is an important addition to adesigner's grab bag of techniques.andP;  The methodology is used to show that thesubtype hierarchy must be decoupled from the inheritance hierarchy, somethingthat other researchers have also suggested.andP;  However, we do so in the contextof exemplar-based systems to additionally show that they can already supportthe extensions required without modification and that they lead to a betterseparation between users and implementers, since classes and exemplars can berelated in more flexible ways.andP;  We also suggest that class-based systems needthe notion of private types if they are to surmount their currentlimitations.andP;  Our points are made in the guise of designing a family of Listdata types.andP;  Among these is a new variety of lists that have never beenpreviously published: prefix-sharing lists.andP;  We also argue that there is aneed for familial classes to serve as an intermediary between users and themembers of a family.andM;For Correspondence: School of Computer Science, Carleton University, Ottawa,Ontario K1S 5B6, Canada.andM;Local Atomicity Properties: Modular Concurrency Control forandM;Abstract Data Types William E. WeihlandM;Atomic actions (or transactions) are useful for coping with concurrency andfailures.andP;  One way of ensuring atomicity of actions is to implementapplications in terms of atomic data types: abstract data types  whoseobjects ensure serializability and recoverability of actions using them.andO;Many atomic types can be implemented to provide high levels of  concurrencyby taking advantage of algebraic properties of the type's  operations, forexample, that certain operations commute.andP;  In this paper we analyze the levelof concurrency permitted by an atomic type.andP;  We introduce several localconstraints on individual objects that suffice to ensure global atomicity ofactions; we call these constraints local atomicity properties.andP;  We presentthree local atomicity properties, each of which is optimal: no strictlyweaker local constraint on objects suffices to ensure global atomicity foractions.andP;  Thus, the local atomicity properties define precise limits on theamount of concurrency that can be permitted by an atomic type.andM;For Correspondence: MIT Laboratory for Computer Science, 545 TechnologySquare, Cambridge, MA 02139.andM;ECCS and LIPS: Two Languages for OSI Systems SpecificationandM;and Verification Vincenza Carchiolo, Antonella Di Stefano, Alberto Faro, andGiuseppe PappalardoandM;An issue of current interest in the Open Systems Interconnection (OSI) fieldis the choice of a language well suited to specification and verification.andO;For this purpose, two languages based on Milner's communication calculi areproposed, respectively intended for the specification of asynchronous andsynchronous OSI systems.andP;  A formal verification method, relying upon thealgebraic foundations of the two languages, is introduced and illustrated bymeans of examples based on nontrivial protocols and services.andM;For Correspondence: V. Carchiolo, A. Di Stefano, and A. Faro, Istituto diInformatica e Telecommunicazioni.andP;  Facolta di Ingegneria, Universita diCatania, Viale A. Doria 6, 95125 Catania, Italy; G. Pappalardo, ComputingLaboratory, The University of Newscastle upon Tyne NE1 7RU, UK.andM;Uniform Self-Stabilizing Rings James E. Burns and Jan PachlandM;A self-stabilizing system has the property that, no matter how it isperturbed, it eventually returns to a legitimate configuration.andP;  Dijkstraoriginally introduced the self-stabilization problem and gave severalsolutions for a ring of processors in his 1974 Communications of the ACMpaper.andP;  His solutions use a distinguished processor in the ring, whicheffectively acts as a controlling element to drive the system towardstability.andP;  Dijkstra has observed that a distinguished processor is essentialif the number of processors in the ring is composite.andP;  We show, by presentinga protocol and providing its correctness, that there is a self-stabilizingsystem with no distinguished processor if the size of the ring is prime.andP;  Thebasic protocol use [Theta]([n.sup.2]) states in each processor when n is thesize of the ring.andP;  We modify the basic protocol to obtain one that uses[Theta]([n.sup.2]/ln n) states.andM;For Correspondence: J. E. Burns, School of Information and Computer Science,Georgia Institute of Technology, Atlanta, GA 30332-0280; J. Pachl, IBMResearch Division, Zurich Research Laboratory, Saumerstrasse 4, 8803ruschlikon, Switzerland.andM;ACM Transactions on Database Systems June 1989andM;A Framework for Effective Retrieval C. T. Yu, W. Meng, and S. ParkandM;The aim of an effective retrieval system is to yield high recall andprecision (retrieval effectiveness).andP;  The nonbinary independence model, whichtakes into consideration the number of occurrences of terms in documents, isintroduced.andP;  It is shown to be optimal under the assumption that terms areindependent.andP;  It is verified by experiments to yield significant improvementover the binary independence model.andP;  The nonbinary model is extended tonormalized vectors and is applicable more general queries.andM;Various ways to alleviate the consequences of the term independenceassumption are discussed.andP;  Estimation of parameters required for thenonbinary independence model is provided, taking into consideration that aterm may have different meanings.andM;For Correspondence: Department of Electrical Engineering and ComputerScience, University of Illinois at Chicago, IL 60680.andM;NFQL: The Natural Forms Query Language David W. EmbleyandM;A means by which ordinary forms can be exploited to provide a basis fornonprocedural specification of information processing is discussed.andP;  TheNatural Forms Query Language (NFQL) is defined.andP;  In NFQL data retrievalrequests and computation specifications are formulated by sketching ordinaryforms to show what data are desired and update operations are specified byaltering data on filled-in forms.andP;  The meaning of a form depends on a storeof knowledge that includes extended abstract data types for definingelementary data items, a database scheme defined by an entity-relationshipmodel, and a conceptual model of an ordinary form.andP;  Based on this store ofknowledge,  several issues are addressed and resolved in the context of NFQL.andO;These issues include automatic generation of query expressions from weakspecifications, the view update problem, power and completeness, and aheuristic approach to resolving computational relationships.andP;  A brief statusreport of an implementation of NFQL is also given.andM;For Correspondence: Brigham Young University, Provo, UT 84602.andM;Efficient Optimization of Simple Chase Join Expressions Paolo Atzeni andEdward P. F. ChanandM;Simple chase join expressions, are relational algebra expressions, involvingonly projection and join operators, defined on the basis of the functionaldependencies associated with the database scheme.andP;  They are meaningful in theweak instance model, because for certain classes  of schemes, includingindependent schemes, the total projections of the representative instance canbe computed by means of unions of simple chase join expressions.andP;  We show howunions of simple chase join expressions can be optimized efficiently, withoutconstructing and chasing the corresponding tableaux.andP;  We also presentefficient algorithms  for testing containment and equivalence, and foroptimizing individual simple chase join expressions.andM;For Correspondence: P. Atzeni, IASI-CNR, Viale Manzoni 30, 00185 Rome, Italy;E. P. F. Chan, Department of Computer Science, University of Waterloo,Waterloo, Ontario N2L 3G1, Canada.andM;File Organization Using Composite Perfect Hashing M. V. Ramakrishna andPer-Ake LarsonandM;Perfect hashing refers to hashing with no overflows.andP;  We propose and analyzea composite perfect hashing scheme for large external files.andP;  The schemeguarantees retrieval of any record in a single disk access.andP;  Insertions anddeletions are simple, and the file size may vary considerably withoutadversely affecting the performance.andP;  A simple variant of  the schemesupports efficient range searches in addition to being a completely dynamicfile organization scheme.andP;  These advantages are achieved at the cost of asmall amount of additional internal storage and increased cost of insertions.andM;For Correspondence: M. V. Ramakrishna, Computer Science Department, MichiganState University, East Lansing, MI 48824-1027; P.-A Larson, Department ofComputer Science, University of Waterloo, Waterloo, Ontario, Canada N2L 3G1.andM;Maintaining Availability in Partitioned Replicated Databases Amr El Abbadiand Sam TouegandM;In a replicated database, a data item may have copies residing on severalsites.andP;  A replica control protocol is necessary to ensure that data itemswith several copies behave as if they consist of a single copy, as far asusers can tell.andP;  We describe a new replica control protocol that allows theaccessing of data inspite of site failures and network partitioning.andP;  Thisprotocol provides the database designer with a large degree of flexibility indeciding the degree of data availability, as well as the cost of accessingdata.andM;For Correspondence: A. El Abbadi, Department of Computer Science, Universityof California, Santa Barbara, CA 93106; S. Toueg, Department of ComputerScience, Cornell University, Ithaca, NY 14853.andM;ACM Transactions on Mathematical Software June 1989andM;Finding All Isolated Solutions to Polynomial Systems UsingandM;HOMPACK Alexander P. Morgan, Andrew J. Sommese, and Layne T. WatsonandM;Although the theory of polynomial continuation has been established for overa decade (following the work of Garcia, Zangwill, and Drexler), it isdifficult to solve polynomial systems using continuation in practice.andO;Divergent paths (solutions at infinity), singular solutions, and extremescaling of coeeficients can create catastrophic numerical problems.andP;  Further,the large number of paths that typically arise can be discouraging.andP;  In thispaper we summarize polynomial-solving homotopy continuation and report on theperformance of three standard path-tracking algorithms (as implemented inHOMPACK) in solving three physical problems of varying degrees of difficulty.andO;Our purpose is to provide useful information on solving polynomial systems,including specific guidelines for homotopy construction and parametersettings.andP;  The m-homogenous strategy for constructing polynomial homotopiesis outlined, along with more traditional approaches.andP;  Computationalcomparisons are included to illusrate and contrast the major HOMPACK options.andO;The  conclusions summarize our numerical experience and discuss areas forfuture research.andM;For Correspondence: A. P. Morgan, Mathematics Department, General MotorsResearch Laboratories, Warren, MI 48090-9057; A. J. Sommese, MathematicsDepartment, University of Notre Dame, Notre Dame, IN 46556; L. T. Watson,Department of Computer Science, Virginia Polytechnic Institute andamp; StateUniversity, Blacksburg, VA 24061.andM;An Algorithm for Generating Interpolatory Quadrature Rules of theandM;Highest Degree of Precision with Preassigned Nodes for GeneralandM;Weight Functions T. N. L. PattersonandM;The construction of an algorithm is described for generating interpolatoryquadrature rules of the highest degree of precision with arbitrarilypreassigned nodes for general constant signed weight functions.andP;  It is ofvery wide application in that to operate, only the definition of the 3-termrecurrence relation for the orthogonal polynomials associated with the weightfunction need be supplied.andP;  The algorithm can be used to produce specificindividual quadrature rules or sequences of rules  by iterative application.andM;For Corespondence: Department of Applied Mathematics and Theoretical Physics.andO;The Queen's University of Belfast, Belfast, BT7 1NN, Northern Ireland.andM;Table-Driven Implementation of the Exponential Function in IEEEandM;Floating-Point Arithmetic Ping Tak Peter TangandM;Algorithms and implementation details for the exponential function in bothsingle- and double-precision of IEEE 754 arithmetic are presented here.andP;  Witha table of moderate size, the implementations need only working-precisionrithmetic and are probably accurate to within 0.54 ulp as long as the finalresult does not underflow.andP;  When the final result suffers gradual underflow,the error is still no worse than 0.77  ulp.andM;For Correspondence: Mathematics and Computer Science Division, ArgonneNational Laboratory, 9700 South Cass Avenue, Argonne, IL 60430-4801.andM;ALGORITHMandM;Dynamic Huffman Coding Jeffrey Scott VitterandM;We present a Pascal implementation of the one-pass algorithm for constructingdynamic Huffman codes that is described and analyzed in a companion paper[3].andP;  The program runs in real time; that is, the processing time for eachletter of the message is proportional to the length of its codeword.andP;  Thenumber of bits used to encode a message of t letters is less than t bits morethan that used by the well-known two-pass algorithm.andP;  This is best possiblefor any one-pass Huffman scheme.andP;  In practice, it uses fewer bits than allother Huffman schemes.andP;  The algorithm has applications in file compressionand network transmission.andM;For Correspondence: Department of Computer Science, Brown University,Providence, R.I.andP;  02912.andM;ALGORITHMandM;FORTRAN Codes for Estimating the One-Norm of a Real orandM;Complex Matrix, with Applications to Condition Estimation Nicholas J. HighamandM;FORTRAN 77 codes SONEST and CONEST are presented for estimating the 1-norm(or the [infinity]-norm) of a real or complex matrix, respectively.andP;  Thecodes are of wide applicability in condition estimation since explicit accessto the matrix, A, is not required; instead, matrix-vector products Ax and[A.sup.T]X are computed by the calling program via a reverse communicationinterface.andP;  The algorithms are based on a convex optimization method forestimating the 1-norm of a real matrix devised by Hager [Condition estimates,SIAM J. Sci.andP;  Stat.andP;  Comput.andP;  5 (1984), 311-316].andP;  We derive new resultsconcerning the behavior of Hager's method, extend it to complex matrices, andmake several algorithmic modifications in order to improve.andM;For Correspondence: Department of Mathematics, University of Manchester,Manchester M13 9PL, England.andO;</TEXT></DOC>