<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-073-636  </DOCNO><DOCID>07 073 636.andM;</DOCID><JOURNAL>Data Based Advisor  March 1989 v7 n3 p52(5)* Full Text COPYRIGHT Data Based Solutions 1989.andM;</JOURNAL><TITLE>Database directions for the 90's. (The open database architectureof the 90's.)andO;</TITLE><AUTHOR>Kalman, David.andM;</AUTHOR><SUMMARY>The term data base management system is used to describe softwarethat allows the user to store, report, manipulate, maintain andanalyze data.andP;  In multiuser environments there are benefits inseparating the data base server from the user interfacecomponents, resulting in a client-server architecture (CSA).andP;  CSAresults in more reliable concurrency control, increasedperformance and improved security.andP;  As local area networksproliferate, this function will remain essentially the same.andP;  Database architecture for the 90's will feature multiple accessmethods, including direct access to the server's low levelfunctions via an application programming interface (API).andP;  Apyramid approach to managing a data base provides a solid base forproductive applications development.andM;</SUMMARY><DESCRIPT>Topic:     Data BasesData Base LanguagesData Base DesignData Base Management Systems.andM;</DESCRIPT><TEXT>DATABASE DIRECTIONS FOR THE 90sandM;When we discuss PC database management systems, do we really know what we'retalking about?andP;  The answer is no--not because we're all a little slow, butbecause we can't seem to agree on a common terminology.andP;  The Eskimos havedozens of words for &quot;snow.&quot;andP;  We use the term database management system todescribe perhaps as many kinds of software tools.andP;  Different software toolsstore, report, maintain, manipulate, and analyze data, yet we lump themtogether in one category.andP;  For example, many people still claim to use Lotus1-2-3, a spreadsheet, as their favorite database management system.andP;  Tounderstand the direction of database technology for the 1990s, we mustdiscard our assumptions of the 80s and refine our understanding of theterminology.andM;In this issue of Data Based Advisor, we look at companies and products thatwe believe will shape PC database management in the coming decade.andP;  Ourspecial section, &quot;Database Directions for the 1990s,&quot; offers a uniquecombination of industry news, expert analysis, and opinion.andM;Our goal is to provide a resource that outlines both marketing strategies andtechnical developments.andP;  Whether you're a programmer, end user, DP manager,or systems analyst, &quot;Database Directions for the 90s&quot; will give you a newperspective on the database world (and in 10 years, we can dig out our dustyMarch 1989 issues and see how we did).andP;  The fact that we soon begin both anew decade and a new era in database management may be just a coincidence.andO;This month, we're taking advantage of this coincidence, if only to convey thedrama being played out in the database industry.andM;A range of toolsandM;Trying to categorize database management systems in a progression from easyto difficult, simple to complex, or end user to developer proves futile.andO;However, we can describe them as conceptual layers of tools upon tools.andP;  Aswe move away from the center, the tools rely on those that came before.andO;Programming languages rely on data handling functions.andP;  Program generatorsrely on programming languages.andP;  Graphical modeling tools rely on programgenerators, and so on.andP;  The different database layers represent entry pointsthrough which users and developers can tap into the power of the database.andO;In the 1990s, the increasing power of desktop computers will support evenmore robust layers of tools.andM;At the center of the database management system is the &quot;engine&quot; (a termpopularized by Wayne Ratliff's Emerald Bay).andP;  The engine executes thefunctions that read, write, and organize data.andP;  In multiuser databases, theengine also handles security (passwords, etc.) and concurrency control(giving users the most current view of the data without trashing it).andM;For the most part, the low level machinations of PC database products havebeen accessible only through menus or high-level command languages such asdBASE and R:BASE.andP;  In addition, the database engine and user interface layershave been sandwiched together in one program.andP;  On single user systems thisworks just fine.andP;  But in multiuser environments, there are advantages tophysically separating the database engine, or server, from its user interfacecomponents.andP;  Each user interface (a.k.a.andP;  front end, application, surface, orclient) operates independently of the server.andP;  Called client/serverarchitecture (CSA), this design provides more reliable concurrency control,improved security, and increased performance.andP;  In the 1990s, as local areanetworks proliferate and connect with larger computers, applications of manykinds will have access to centralized data.andP;  The applications may vary, butthe interface to the data will be standard.andM;Client/server architecture also provides a better way for applications toshare data, even on standalone systems.andP;  A single database engine can serveword processors, spreadsheets, and traditional database applications.andP;  Ingraphical interface systems, such as Microsoft Windows, Presentation Manager,and Apple Macintosh, diverse applications appear on the desktop as one.andO;Application-independent database engines make it possible for theapplications to share data seamlessly, without messy conversions.andM;The new database architecture also provides multiple access methods,including direct access to the engine's low level functions via functioncalls, or &quot;hooks&quot; (also called APIs, for application programming interface).andO;Experienced programmers can write custom systems in languages such as C,Pascal, Fortran, or COBOL.andP;  This provides maximum performance andflexibility, and makes it possible to integrate database management systemswith external devices such as robots, sensors, and modems.andP;  In addition,organizations with applications already written in other languages can adaptthem to new database management systems without re-coding.andM;To take full advantage of relational database engines, programmers can embedStructured Query Language (SQL) statements in the low level language for datadefinition, control, and manipulation.andP;  Among its many attributes (seesidebar), SQL provides a standardized access language that makes it possiblefor diverse applications to share data intelligently.andM;Application tools: High levelandM;procedural languagesandM;At the next database management layer we find high-level procedural languagessuch as dBASE, Paradox's PAL, and R:BASE.andP;  High-level means English-like (ormore French-like if you speak French).andP;  Procedural essentially means&quot;step-by-step.&quot;andP;  In a procedural language, the programmer specifies dataentry screens, program flow, reports, and queries, manipulating data onerecord at a time.andP;  These languages differ from general purpose languages inthat they include file handling commands and functions specific to a databaseengine.andM;The benefits of procedural languages include flexibility andcomprehensiveness.andP;  They allow programmers, ranging from novice to expert, tocontrol every aspect of an application with program statements.andP;  By theircomprehenesiveness, these languages often provide several ways to accomplishthe same goals, giving beginners an opportunity to get the job done whilelearning to program.andM;Procedural languages provide line-by-line control of the user interface.andO;Boxes, colors, windows, input fields, and on-screen reports can bemanipulated individually.andP;  A wide range of functions provide numeric, string,and data manipulation.andP;  Experienced programmers can use procedural languagesto create amazing screen effects or complex reports.andM;The major disadvantage of high-level procedural languages is productivity fornon-programmers, or lack thereof.andP;  For the non-programmer, learning and usinga procedural language can consume more time than ultimately saved.andP;  Learningand using the many commands and functions is half the battle.andO;Non-programmers may find the concepts of program control and input/outputequally intimidating.andM;For the programmer, high-level procedural languages are more productive thanC, COBOL, or Pascal; however, low level languages such as C run faster andprovide better control of the computer hardware.andP;  Also, learning a newlanguage still takes considerable time.andP;  Except for dBASE, high levellanguages are considered &quot;non-standard,&quot; and a knowledge of PAL or R:BASE, orany other non-standard language, may not apply to the next job or project.andM;Non-procedural languagesandM;At the next layer we find non-procedural languages (also called &quot;4thGeneration Languages&quot; or &quot;4GLs&quot;).andP;  Products noted for their 4GLs includeProgress, Informix, NPL/R, and generally all SQL databases (since SQL is a4GL).andP;  The non-procedural approach treats data not so much as strings ornumbers, but as entities or sets.andP;  Non-procedural commands manipulate datawithout the programmer necessarily specifying each detail (such as SKIP orGOTO RECNO()).andP;  By moving the developer from string-handling to entity- orset-handling, the development process better reflects real worldrelationships--an advantage to the non-technical business person.andM;4GLs are often associated with data dictionaries--tables containing dataabout the database.andP;  Any data entered into a table is validated according tothe rules in the dictionary.andP;  By giving the database some facts about itself,such as relationships between tables and values, screen display formats,calculations, and security controls, the 4GL can contain fewer, yet moreexpressive, commands.andP;  (In distributed systems, the data dictionary may alsoindicate the location of data on other computers).andM;The data dictionary may define a column, or field, as the sum of four otherfields.andP;  Or it may describe a display attribute, such as a color.andP;  In moreevolved 4GLs, the data dictionary may also contain business rules.andP;  Forexample, a rule may prevent the deletion of a DEPT without first deletingEMPLOYEEs in the DEPT.andP;  Generally, the more information in the datadictionary, the less code complexity in the 4GL application, and the moreproductive the development cycle.andP;  The data dictionary also enhances dataintegrity, both within and across applications, because all input isvalidated centrally.andM;Despite their advantages, 4GLs share some of the disadvantages of procedurallanguages.andP;  Because they are so closely tied to proprietary datadictionaries, 4GLs (other than SQL) are non-standard.andP;  4GL syntax is specificto each vendor's database management system.andP;  And despite the non-proceduralhandling of data, 4GLs often rely upon procedural statements for reportwriting and forms design.andP;  Even with report writing programs and screenpainters, 4GLs still require significant training for non-programmers.andM;Non-proceduralandM;programming toolsandM;At the next database layer we find object-oriented programming languages.andO;These have many of the characteristics of 4GLs, except they extend the entitymetaphor to procedural programming constructs.andP;  Commonly used procedures,such as windows, forms, and reports, are saved in libraries or in a datadictionary.andP;  Each procedure becomes a self-contained, modular &quot;object&quot; thatcontains information about itself.andP;  Standard object libraries may be providedwithin the programming language.andP;  More importantly, programmer-definedobjects become part of the language.andP;  Objects may be modified, copied, andre-used.andP;  As a programmer develops more objects, application developmentproductivity can increase dramatically.andP;  According to Nantucket's VPs ofDevelopment, Brian Russell and Rich McConnell, the next version of Clipperwill take the object-oriented approach (see our interview with Brian and Richin next month's Data Based Advisor).andM;dBASE programmers may already recognize object-oriented characteristics fromWallsoft's UI Programmer.andP;  UI templates are objects (written in a templatelanguage) that convert to dBASE code.andP;  As the developer builds a templatelibrary, productivity increases dramatically.andP;  The UI Programmer doesn'tqualify as a complete object-oriented language, however, since there's no way(yet) to modify the dBASE code, then regenerate the template object.andM;Like 4GLs, object-oriented languages reduce the complexity of the applicationcode.andP;  They also provide a programming metaphor once removed from proceduralcomplexity.andP;  With object-oriented user interfaces (either graphical orcommand-driver), non-programmers will find a closer correlation betweenapplication development and real world relationships.andP;  For example, objectscould represent departments, company divisions, locations, or reports.andP;  Sinceeach object could have its own rules and attributes, the end user could thenmanipulate the objects using a program or graphical specification.andM;Code generatorsandM;The layered approach to database management, from low level toobject-oriented programming, provides a solid foundation for productiveapplications development.andP;  But as we enter the 1990s, we'll find that theproblem with programming is that you still have to learn to write code.andP;  Ifthe ultimate goal of application development is to reduce development time,maintenance cost, and training cost, it's clear that there's room for evenmore layers on the database pyramid--layers that eliminate coding.andM;Most of us are familiar with code and application generators.andP;  These programsinterpret a user's input (through menus, pictures, or dialog responses) andproduce the specified program code.andP;  The code may range from low levellanguage output (e.g., C, COBOL, and Pascal), to procedural language output(e.g., dBASE IV AppGen, Genifer, and R:BASE Express) to 4GL output (Informixand SQL Forms).andP;  Some generators specialize in specific pieces of anapplication, such as Russ Freeland's SCRIMAGE screen designer.andP;  Others, suchas R:BASE Express, produce full working applications.andM;The good news...generators spare developers from having to rewrite tedious,repetitive procedures.andP;  They also allow developers to quickly createapplication prototypes.andP;  In experienced hands, a code generator can cutdevelopment time substantially.andP;  Generators also extend the capabilities ofnovice programmers.andP;  Writing a complex report is best handled by a capablereport generator, especially in a crunch.andP;  At the same time, code generatorsprovide many code examples from which to learn.andM;A problem with generators is that they accept input and generate code--aone-way process.andP;  If you modify the code of a generated system, and thenregenerate it, you would wipe out the modifications.andP;  This wouldn't be aproblem if you never had to modify the generated code.andP;  However, reality isdifferent.andP;  Generated systems, invariably, require changes.andM;For non-programmers, code and applications generators pose a differentproblem.andP;  Although they may eliminate the need to write code, even the bestgenerators still require an understanding of how an application works.andP;  Thisunderstanding includes the concepts of program flow, input/output, anddatabase design.andP;  Of course, these concepts can be (and perhaps should be)learned.andP;  However, code generators are often sold with a &quot;no programming, nospecial training&quot; promise.andP;  As always, anything that seems too good to betrue, probably is.andM;So what is too good to beandM;true?andM;At the top layer of the database of the 1990s, we find application generatorsthat don't necessarily produce code.andP;  In these systems, the designenvironment and the application are inseparable.andP;  The design environment mayconsist of Macintosh icons moved around the screen as in Odesta's DoubleHelix, or Entity-Relationship diagrams tied to a 4GL as in Zanthe's Zim.andP;  Outof the dBASE world comes Quiktek's Schooner, a data driven applicationdesigner based on the Clipper engine.andP;  The application you create it itselfdata that you never see.andP;  With these systems the specification and designprocess produces a working application.andP;  The design, generation, testing, andmaintenance phases are integrated into a common developer-interface.andM;This development approach is the basis of Computer Aided Software Engineering(CASE) tools.andP;  CASE is based on the notion that you can analyze, design,generate, test, and maintain an application by translating a designspecification directly into a working application.andP;  Programming is replacedby drawing flow charts, manipulating icons, embedding procedures, anddepicting relationships graphically.andM;Where CASE differs from similar generators is in its emphasis on designmethodologies such as Chen's Entity Relationship Analysis (ERA) and Orr'sData Structured Systems Development (DSSD).andP;  A carry-over from CASE's rootsin the large systems world, this emphasis promotes group development.andO;Programmers and systems analysts can join development projects without aknowledge of the source code, only of the methodology.andP;  The emphasis onmethodology depends on a high level of training in systems analysis anddesign.andP;  So, in its most parochial implementations CASE does not respond tothe needs of PC developers and users.andM;In its most innovative forms, PC CASE tools have already begun to break thedependence on systems analysis expertise by building that expertise into thesystem.andP;  For example, Syscorp's Microstep lets the user design a systemintuitively, by moving icons on the screen.andP;  The result is a rigorous systemwritten in C that is maintained entirely through the design environment.andO;After Microstep generates an executable program, it even erases the C sourcecode (you can preserve it if you so choose).andP;  In the 1990s, we can expect PCCASE tools to provide even more design guidance.andP;  Using artificialintelligence and expert systems techniques, these tools will replace theapplication generators used on PCs today.andM;Database architectureandM;The client/server architecture and the layers of database tools arethemselves a microcosm of database management in the 1990s.andP;  Separating thedatabase engine from the front end lets many front ends access common backends, a model that translates well to single user, multiuser, and distributedsystems.andM;On single user systems this design allows true integration at the databaselevel, just as systems such as Smart, Enable, Symphony, and Framework, firstallowed integration at the user interface level.andP;  For example, you could havea set of OS/2 EE-compatible or Emerald Bay-compatible applications that looknothing alike, yet use the same data.andP;  As another example, C applications,WordTech's Oracle dBXL, and Lotus 1-2-3 could access Oracle data.andM;On multiuser and distributed systems, you have these same benefits and more.andO;With a database server, workstations can share data simultaneously.andP;  dBASEIV, Microsoft Excel, and Paradox could share data on an Ashton-Tate/MicrosoftSQL Server.andP;  Paradox, Microsoft Excel, and Revelation might share data onGupta Technologies' SQL Base server.andP;  C and Eagle programs could shareEmerald Bay data.andP;  In distributed systems, PC applications can access dataresiding on a combination of microcomputers, minicomputers, or mainframes.andO;What makes &quot;distributed&quot; data different from &quot;multiuser,&quot; is the ability totreat remote tables in different locations as if they were part of onedatabase.andP;  Products in this category, or moving toward it, include GuptaTechnologies' SQLBase, Paradox, the yet-unreleased Lotus DBMS, and theyet-unnamed Microrim DBMS (code-named &quot;Atlas&quot;).andP;  In all these cases, SQLmakes the distribution of data possible.andM;One Step BeyondandM;The separation of tasks, as in the client/server model, is the precursor topowerful multi-tasking, multi-processor systems.andP;  WE now have databaseservers as back ends to client applications on a LAN (multiple processesconnected by a wire).andP;  We'll soon have multi-tasking database engines andapplications running on the same processor.andP;  Eventually, we'll see thephysical separation of tasks, running on separate processors, within the samedesktop computer (such is the promise of IBM's Micro Channel Architecture).andO;The multi-layered database of the 1990s will make these advances possible.andM;PortabilityandM;Despite the connectivity of the future, there will still be a need to run thesame application on different platforms without recoding.andP;  For example,instead of using a PC application as a front end to a minicomputer ormainframe database, you could run the application itself on the minicomputeror mainframe.andP;  Products such as Oracle and Ingres offer multiple versions,making it possible to move the application as well as the data.andP;  In the dBASEworld, you can run Ashton-Tate's dBASE III PLUS and dBASE IV onIBM-compatible microcomputers, FoxBASE+/Mac, Nantucket's McMax, orVersaSoft's dBMAN on a Macintosh, Recital on a VAX under VMS or UNIX, SCOFoxBASE+ under Xenix, or even dBMAN for Atari.andP;  Ashton-Tate has alsoannounced plans for versions of dBASE IV for the VAX.andM;In a new approach to portability, Microrim is developing what they call aGraphical User Interface Engine (GUIE, pronounced gooey) as part of their newDBMS.andP;  The GUIE is an interpreter, residing on the target system, that letsyou move applications to different computers without losing the advantages ofthe target user interface.andP;  For example, under OS/2 Presentation Manager, theapplication has a typical Presentation Manager user interface.andP;  The sameapplication, when moved to a Macintosh, looks like a Macintosh application.andO;For improved performance, Microrim will also provide 4GL compilers for eachtarget system.andP;  Like interpreted GUIE applications, compiled applicationsretain the look of the target system.andM;SummaryandM;The database direction for the 1990s is connectivity, but not necessarilycentralization as feared by some PC users and developers.andP;  PC users canretain their individuality and independence, as software vendors providetransparent access to distributed data.andP;  Distributed databasing allows remoteaccess without limiting the capabilities of client applications.andP;  Many typesof front ends may co-exist.andM;In fact, the client/server architecture promotes diversity in the front end,offering more opportunities for creative developers.andP;  With robust relationalengines already available, developers who produce front ends can concentrateon their specialties.andP;  The diversity of the front end market will continue,as product such as Paradox, DataEase, Magic PC, dBASE IV, and others, exploitthe potential of database servers.andM;The flagship PC database products of the current decade have been powerful,complex tools useful primarily to developers or to those willing to becomedevelopers.andP;  Even with excellent code generators and menu systems, developingrobust applications has required an understanding of data structures andprogram logic that most users cannot acquire productively.andP;  In coming yearsthe demand for database applications will certainly grow, and with it, anapplication backlog affecting companies of all sizes.andP;  In turn, more userswill need to productively develop and maintain their own applications.andP;  Withthe layered approach to database management--providing entry points rangingfrom assembly language to CASE tools--both developers and end users will findthe right tool for the job.andO;</TEXT></DOC>