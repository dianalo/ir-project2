<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-789-334  </DOCNO><DOCID>07 789 334.andM;</DOCID><JOURNAL>Microsoft Systems Journal  Nov 1989 v4 n6 p35(12)* Full Text COPYRIGHT Microsoft Corp. 1989.andM;</JOURNAL><TITLE>Simplifying pointer syntax for clearer, more accurate programming.andO;(C language) (includes related article on in-line C programdebugging)</TITLE><AUTHOR>Comeau, Greg.andM;</AUTHOR><SUMMARY>The derivations of pointer syntax in C language programming arepresented.andP;  Pointers can simply and clarify code if they are usedcorrectly.andP;  A programmer can do three basic things with a pointer:assign a value to it, assign its value to another pointerexplicitly or implicitly or dereference the pointer.andP;  Other areascovered include unary * operators, side effects, expressionstatements, sequence point and comma operators and debugging code.andM;</SUMMARY><DESCRIPT>Topic:     C Programming LanguageProgramming InstructionPointersType-In ProgramsSyntax.andO;Feature:   illustrationchartprogram.andO;Caption:   Memory maps. (chart)DEBUG.H. (program)PTRINC.C source code. (program)andM;</DESCRIPT><TEXT>Simplifying Pointer Syntax for Clearer, More Accurate ProgrammingandM;Pointers containing the address of functions, variables, or objects clarifyand simplify your code.andP;  They are tricky, though, and confusing if carelesslywritten.andP;  The derivations of pointer syntax that are presented in thisarticle should make pointer usage perfectly clear to you.andP;  While thesederivations are simple, some of them may be new to you or may produce resultsyou would not have predicted.andP;  For example, the output of the program inFigure 1 may not be obvious, although it is a common and basic C construct.andM;An analysis of Figures 2A and 2B will give us a common frame of reference forthis article.andP;  In these figures, the value c is 'a', and the value of p when= andamp;c executes is 1000.andP;  The value 1000 is the address of c (randomly chosenfor this discussion), and the andamp; signifies that we want to take the address ofthe accompanying object operand c.andM;Therefore p = andamp;c implies that the data contained in p is actually the addressof another variable, which also contains its own data.andP;  This seems logical,since c and p each have their own storage space and can hold independent datawithin that storage space.andP;  It is easy to forget this when your declarationsand programs become more complex.andM;Pointer UsesandM;Basically, you can do three things with pointers: assign another value to thepointer, assign the pointer's value to another pointer explicitly by means ofan assignment or implicitly as an argument to a function, or dereference thepointer.andM;Assigning another value to the pointer is as simple as coding the assignment(see Figure 3A).andP;  The memory map of the program as it executes will help youunderstand exactly how this works (see Figure 3B).andP;  Notice how thereassignment to p simply causes p to change values; this is the normalfunctioning of a variable and applies even though we are dealing with apointer.andP;  The reassignment of a pointer, however, can have devastatingeffects on some programs.andP;  This is especially true with heap space when freesubroutine calls are not issued between the assignments.andM;Using the pointer in an expression such as an rvalue shows once again that apointer is just another variable.andP;  In Figures 4A and 4B, the statement p = andamp;cassigns the address of c to p.andP;  Then the statement p2 = p assigns to p2 theaddress of c by using the value contained in p.andP;  This does not imply that p2points at p.andP;  Instead the value of p gets copied into p2.andP;  This is nodifferent fromandM;int i; int j;andM;i = 5; j = i;andM;where we know that j will also contain its own copy of the value 5.andP;  To provethis, run the code from Figure 4A to see what the output will be.andP;  Note thatit will not print out numbers, like 1000, used in the memory maps.andP;  Insteadthe %p format specifier of printf will encode the output in segment:offsetformat.andM;The last use of pointers involves the value that the pointer contains throughthe unary * operator.andP;  The unary * operator is one way to accomplishindirection and dereferencing of pointers.andP;  For the moment, let's take a lookat the last line of Figure 5A.andP;  As you can see from the memory map, theresult of this statement is to change the value of c from 'a' to 'A.'andP;  Sincep2 becomes another name for c, we can codeandM;*p2 = 'A';andM;instead ofandM;c = 'A';andM;The indirection ability of pointers is very powerful.andP;  It allows us to accessnamed symbolic variables and unnamed variables (identifiers) with the sameease--without requiring that you keep a lot of information about whichobjects you are pointing to, where they are located, and so on.andP;  Thisindirection can result in faster and smaller code (depending upon thecompiler and hardware in question).andM;Unary * OperatorandM;Near the end of Figure 5A, c is a char object whose value is 'a' and p2 is apointer to a char object whose value is the address of c. *p2 represents whatp2 points to, not the contents of p2 as it may appear to read.andP;  For example,using i and j from the previous example, we know that j=i says j is equal tothe contents of i.andP;  There is no reason to expect pointer notation to functiondifferently.andP;  For example, Figure 5A contains the statementandM;p2 = p;andM;which requests that the contents of p be placed into p2.andM;To explain further why *p2 does not mean &quot;the contents of p2,&quot; it is worthnoting that when we say j = i, it actually means j = *andamp;i.andP;  Read *andamp;i as &quot;apointer to the contents of the address of i.&quot;andP;  A memory map of Figure 5A isshown in Figure 5B.andM;Besides mapping the contents of what p2 points to, *p2 can represent thecontents of the address of p2.andP;  Since in this case the content of p2 is 1000,this expression implicitly becomes * char *1000--meaning the contents ofmemory location 1000, taken to be a char, which is 'A'.andM;DerivationsandM;Now that we've gotten some of the background out of the way, we can analyzesome concrete pointer examples.andP;  PTRINC.C (see Figure 6) shows a small groupof simple pointer operations.andP;  These pointer operations illustrate that thereis more going on behind the scenes than is apparent at first glance.andP;  Thefollowing discussion is based on a debugging technique described in thesidebar &quot;In-Line C Program Debugging.&quot;andP;  For further information, refer to&quot;Pointers 101: Understanding and Using Pointers in the C Language,&quot; MSJ (Vol.andO;4, No.andP;  4).andM;The debug.h file explained in the sidebar is included in the first line ofPTRINC.andP;  Examining lines 9 and 10 you will find the declarations char *p andchar *origp, which are two pointers to char objects.andM;On line 12, p is assigned to the address of a string literal--a group ofcharacters next to each other in a source program, prefixed and suffixed bythe double-quote character.andP;  Internally, this kind of construct is a staticarray of characters containing each character that is enclosed in the quotes,including a terminating null byte which is added by the compiler.andP;  Thisformat is known as ASCIIZ.andM;A string literal is a good example of an unnamed area of storage.andP;  To use astring literal, we must either set a pointer to its address as PTRINC hasdone or use it as an argument to a function where its address becomesapparent.andP;  Most of us have used this context in our first C program byspecifying a string literal as an argument to printf.andM;For a complete explanation of string literals, especially those involvingmultibyte characters, refer to the ANSI C draft (the latest version,published December 7, 1988, is available from the Computer and BusinessEquipment Manufacturers Associatioin in Washington, D.C.) or a relatively newC text such as The C Programming Language, Second Edition, Kernighan andRitchie (Prentice-Hall Inc., 1988).andM;Line 13 of PTRINC prints the characters 'a' through k in our debug format.andO;Line 14 assigns origp to array--the same place that p is pointing to.andP;  For avisual representation of the statements in lines 12 to 32, see Figure 7.andM;At line 17, the value printed for the contents of p is 1234, which is thesame as andamp;array [0].andP;  Note that line 17 does not print the address of p.andP;  Ifwe wanted that, we would have coded printp(andamp;p) to produce an output of andamp;p =1200.andP;  The address of p is a given, in accordance with the top of Figure 7.andO;An arbitrary location for it has been chosen since it will not affect thisdiscussion (actual execution of the code will give another result).andO;Therefore, like any occurrence of text which only mentions p, printp(p)produces the contents of p; origp = p functions similarly.andP;  The value printedby the execution of line 17 should point at the beginning of the array sincewe have not incremented or reassigned a value to p.andM;Line 18 increments p.andP;  As with all pointers, the increment value iscontingent upon the derived or base type of the pointer.andP;  In PTRINC, p is apointer to char, therefore the increment will be 1, the sizeof(char).andM;If PTRINC had been written so that p was a pointer to an integer (an int *),p++ would have a scaling factor of sizeo(int), which typically evaluates to 2or 4 bytes depending upon the compiler.andP;  In C, scaling factors allow pointersto be manipulated without forcing the programmer to worry about adjusting thegiven pointer by hand.andP;  The pointers, however, must be of the proper type.andO;This can cause a problem because the C language does not let you createpointers to an object with variable size.andP;  The objects may be created in theheap via the various alloc routines.andP;  This concept will be covered in afuture article.andP;  Note that such objects do not need to be a linked list andthat there are useful cases in which a method for obtaining the object'slength after the allocation is unnecessary (dynamic copies of ASCIIZ strings,for example).andM;The output of line 19 reflects the increment of p by 1.andP;  Line 18 allowed p topoint at the b within the array, as expected.andM;Before continuing our examination of PTRINC, we need to discuss side effects,sequence points, expression statements, and the comma operator--features ofthe C language that relate directly to line 20 of PTRINC.andM;Side EffectsandM;A side effect is a change in an object's value due to the evaluation of anexpression.andP;  Side effects happen as a result of function calls, assignmentexpressions, auto-increment expressions, and auto-decrement expressions.andO;Unless an expression is void, it produces a value; in the process, it alsoproduces a side effect.andM;Side effects involving functions can modify the value of a variable in a waythat might not be clear in a large or complex program.andP;  For example, inandM;int i;andM;void f(void) { i++; }andM;main () { f(); }andM;it may appear that the call to f is innocent, but actually it modifies thevalue of i.andP;  No real harm is done here, although the increment of i may notbe apparent in a larger program or in a program with many statementsoccurring in f and main.andP;  If, however, we modify this code slightly byintroducing another function named gandM;int g(void) { i++; f();andM;return (5); }andM;and addandM;j = g() + i;andM;to main, the resulting value of j may not be clear.andP;  Either way we aredealing with a side effect.andM;Code such as this assignment statementandM;i = 5;andM;has the side effect of replacing the value of i with 5.andP;  As long as anexpression modifies an object, a side effect occurs.andP;  Therefore a side effectcan have ill effects.andM;The classic example of a side effect with an expression statement is:andM;a[i] = i++;andM;In this situation, the compiler has the choice of computing the value of thesubscript before or after it computes the value on the right-hand side of theequal sign.andP;  We would expect this unpredict-ability to be incorrect, but thecompiler nevertheless makes this decision on its own.andM;Three more examples are represented by the code:andM;i = 5; func(i++, i++);andM;In the first scenario, the compiler chooses to generate code to perform thepost increment after both i's are evaluated.andP;  Both arguments will be 5; thevalue of i after the expression can be either 6 or 7.andM;The i's are post-incremented in the second scenario in the order shown; thefirst argument will be 5 and the second one will be 6.andP;  The value of i afterthe expression will be 7.andM;The i's are post-incremented in the last scenario in reverse of the ordershown; the compiler is not constrained to evaluate the arguments of afunction in left-to-right order.andP;  The second argument will be 5 and the firstone will be 6.andP;  The value of i after the expression will be 7.andM;Generally speaking, the third scenario will usually be true, since mostcompilers put the arguments to functions on the stack in reverse order.andO;This, however, does not necessarily imply that the arguments are evaluated asthey are put on the stack.andP;  All side effects of function arguments areevaluated before calling the function, which makes them consistent and doesnot conflict with any of the scenarios given above.andM;As tricky as these examples are, we can accept them after giving them somethought.andP;  In fact, these examples appear much more sensible than thestatement:andM;j = i++ + i++;andM;I will leave this one as an exercise.andP;  The possibilities it presents will besimilar to those discussed above.andM;Expression StatementsandM;Most C programmers do not realize that C is more expression-based than any ofthe other popular general-purpose languages.andP;  For instance, even though wetypically refer to a statement such asandM;i = 5;andM;as an assignment statement, it is actually an assignment expression.andP;  Astatement in C can be one of the standard flow control statements such asfor, goto, and break.andP;  In the Microsoft [r] C Version 5.1 Optimizing Compilermanual, the syntax summary on page 229 in Appendix B of the User's GuideLanguage Reference manual informs us that a statement may be of the form:andM;expression;andM;The assignment listed above is actually an expression statement containing anassignment.andM;We've already examined several situations in PTRINC that prove that thisexample is an assignment expression statement.andP;  For instance, line 18 ofPTRINC contains p++.andP;  Even though this resembles p = p + 1, the syntax isclearly a construct that allows it to stand alone.andP;  Even p = p + 1 results ina value--this statement not only assigns p + 1 to p, it also returns p.andP;  Thereturn value of the expression is often ignored; this is how statements suchas j=i=5 can occur without wreaking havoc.andM;Sequence PointsandM;A sequence point invokes the concept of a hypothetical C machine.andP;  In such amachine, the compiler's code generator must completely follow your C code.andP;  Amore precise definition is shown in Figure 8.andP;  Every statement in this Cmachine must be executed in the order in which it has been coded: statementorder followed by flow of control order.andP;  This means that the hypothetical Cmachine allows few if any optimizations to take place.andM;This C machine exists only in theory; in practice no compiler will follow it.andO;The comma operator and the volatile keyword (which many compilers still donot support) serve the same function as the hypothetical C machine.andP;  Thecomma operator is explained in the next section.andP;  The volatile keyword wasexplained in &quot;A Guide to Understanding Even the Most Complex C Declarations,&quot;MSJ (Vol.andP;  3, No.andP;  5).andP;  Their purpose is to ensure that agreement pointsexist at appropriate places.andM;Comma OperatorandM;As with all sequence point operators, the comma operator ensures that itsoperand expressions are evaluated in left-to-right order.andP;  The result of thecomma operator is always the value of the last expression in the expressionlist.andP;  Generally, the comma operator cannot force the evaluation of a givenstatement sequence, such as a for or block compound statement.andP;  The commaoperation is only valid within expressions--it does not control statements,though it may be used within the controlling expression of a conditionalstatement.andM;The comma operator is different from a semicolon; it occurs in expressions,while the semicolon terminates statements.andP;  Also, note that the commaoperator has nothing to do with the comma that is used to separate functionarguments.andP;  In the latter case, the comma serves strictly as punctuation.andM;PTRINC.CandM;We've just discussed many features of C; I'll now explain how they pertain toline 20 of PTRINC.andP;  Line 20 of PTRINC contains the statement *p++.andP;  Todetermine what this means, look at the operator precedence table (see Figure7 for the output of line 20).andP;  A precedence table can be found on page 137 ofthe Microsoft C 5.1 Optimizing Compiler Language Reference.andM;The precedence table reveals whether line 20 increments the contents of p,increments p, changes the address of p, increments the contents of the objectp points to, or performs some combination of these.andM;Some of these cases are obvious.andP;  The first two cases are the same for thereasons stated earlier.andP;  Case c cannot be true, since we do not have theability to change the address of a variable, especially when that variable isan identifier.andM;We are left with the following possibilities: line 20 increments the contentsof p, increments the contents of the object p points to, or performs somecombination of the above.andM;We know that the associativity of the ++ operator from the operatorprecedence table chart means &quot;do not perform the increment until after the(simple) expression has been evaluated&quot; because it is a post-incrementoperator.andP;  Since the ++ immediately follows p, it's p that's beingincremented, not the contents of the object p points to.andM;The simple expression referred to in the preceding paragraph is *p.andP;  However,like the case presented in the previous sections, we don't assign or use thevalue of *p.andP;  It is discarded--*p goes nowhere and then p is incrementedafterwards.andP;  This is equivalent to having coded the following:andM;*p, p++;andM;This syntax is a valid C expression and a valid C statement.andP;  It demonstratesthat we wouldn't normally want to write code this way.andP;  For all practicalpurposes, line 20 increments only p; the implication is that it wasn'tsupposed to be written that way.andP;  We should be cautious of such situations,because it's too easy to code a construct such as *p++ without stopping for asecond to see what is actually happening, especially since the compiler isnot going to object.andM;Sometimes, however, it makes sense to write code that uses the value of thiskind of expression.andP;  For example, the assignment to c in the following codeis legitimate and powerful:andM;char *p; char c;andM;p = ...; c = *p++; ...;andM;Statements like the assignment to c present a style issue because such codingpractices can create hard-to-read code.andP;  Instead you could write theassignment on two lines:andM;c = *p; p++;andM;Such constructs, however, are idioms of C, so whether or not you should usethem is simply a matter of style.andM;Next CaseandM;In line 22, (*p)++ might increment the contents of p or increment thecontents of the object to which p points.andM;Since the ++ is outside the parentheses, it is doubtful that they modify p.andO;Of course, (*p)++ is a legal expression that modifies the contents of p and++ occurs outside the parentheses in that case.andP;  Also, if we envision a casesuch asandM;i++;andM;being at some point equivalent toandM;(i) = (i) + 1;andM;line 22 could be interpreted as:andM;(*p) = (*p) + 1;andM;Therefore line 22 increments the contents of the object to which p points.andO;Case c wasn't worth considering since there is only one ++ operator in thestatement.andP;  Figure 7 shows that p has not changed when we print it on line23.andP;  What has changed is that we've added 1 to c; under the ASCII characterset this changes the c to a d.andP;  Line 22 could also have been written aseither of the following:andM;++(*p) ++*pandM;since a standalone statement such as i++ could be rewritten as ++i.andP;  If theresult of these statements were to be used, however, this would not be truesince it makes a difference where ++ is placed, according to the precedencetable.andP;  For example, the expression ++(*p) is evaluated and then incremented,but the expression ++*p is incremented first and then evaluated.andM;It may not be clear whether the ++ on line 24 applies to the * or the p.andP;  Itcan't apply to the * without the introduction of some other operand, like the++*p above, which is mentioned as a syntax level reference since the twostatements have different meanings.andP;  As with all these examples, the operatorprecedence table provides the key.andP;  Since the ++ binds with the p and is apre-increment, the compiler will not let the dereference occur without firstperforming the increment.andP;  Therefore, line 24 could have been codedandM;p++, *p;andM;or:andM;++p, *p;andM;Much of what is true about line 20 is also true of this statement.andP;  Theeffect of 24 is that p is incremented.andP;  Line 25 confirms this.andP;  On line 26,we simply check to make sure we know where we are.andM;Turmoil strikes again on line 27 and this time we have two sets of problems.andO;First we are going to use the value of the expression instead of ignoring itas we did in earlier statements.andP;  We are left with:andM;*(p++)andM;Clearly, p will be incremented, but what's not clear is when this willhappen.andP;  At first glance, we would say that it's the same asandM;p++, *pandM;which is the same thing line 24 mapped into because expressions inparentheses must be performed first.andP;  We'd be wrong.andP;  The statement actuallymaps toandM;*p, p++andM;which is the same as line 20.andP;  The explanation of this is that p++constitutes a complete subexpression involving a long value no different fromwhatandM;while ((c = getchar()) != EOF)andM;does in its assignments to c.andP;  In this case, the subexpression has a sideeffect involving a post operator.andP;  We know that the side effect will occursometime during that statement and before the next statement in thissituation.andP;  The operator precedence table clarifies the situation by showingthat the post ++ operator and the unary * operator are alwaysright-associative.andP;  This means that if we look at the reverse situation of*p++, it must be interpreted as *(p++) rather than (*p)++.andP;  Therefore, theparentheses on line 27 only order the p, not the p++, since the increment isperformed afterwards.andM;Line 27 has a second problem.andP;  We can see that when line 27 is output and fedfrom the C pre-processor into the C parser it looks something like this:andM;fprintf ((andamp;_iob [2]), &quot;* (p++)=%d/%c\n&quot;, *(p++), *(p++));andM;(This code should all be on one line; it is broken here due to spaceconsiderations--Ed.)andM;Notice that we have ended up with two *(p++) expressions--a statementcontaining a macro with a side effect.andP;  This is a very subtle problem.andP;  Thedecimal value of the character printed by the first *(p++) in this examplemay actually be different from the character value we expected because westill do not know when the p++'s will occur.andP;  On my UNIX machine, the p'swere incremented in the reverse of the order shown, probably because of theway the arguments on the stack were put.andP;  The value for the d is correct, butthe decimal value 101 represents an e (see Figure 7).andM;Line 28 verifies that there were two increments on my machine.andP;  There mightnot have been since we cannot predict whether both increments start using thesame value of p or whether one is based on the other.andP;  Lines 29, 31, and 32are self-explanatory except for the third character of the array, which isnow a d rather than a c.andP;  This change occurred in line 22.andM;SummaryandM;This article has introduced and explained many pointer derivations and shownsome common and often unexpected side effects of using pointers in your code.andO;A solid understanding of how pointers work, and a willingness to examine evensimple pointer constructions for hidden errors, will help you to writeconcise, fast code.andM;In-LineandM;C ProgramandM;DebuggingandM;DEBUG.H is a header file that performs in-line program debugging.andP;  An exampleof DEBUG.H (see Figure A) is shown in TESTDEBUG.C (see Figure B).andO;TESTDEBUG.C includes DEBUG.H in a source file and uses it and three macrovariables to control the output.andP;  One macro controls the occurrence of anydebug output, another controls the printing of subroutine entry and exitpoints, and the third controls the printing of subroutine names with therespective debugging information.andM;The output shown for TESTDEBUG.C demonstrates the advantage of using DEBUG.H,which is that the argument to the print* and DEBUG* macros allows the code tobe less tedious and more easily read (assuming the debug information is to beleft in).andP;  In this program, a statement such asandM;printd (somevariable)andM;producesandM;somevariable = the value of somevariableandM;as its output.andP;  This avoids having to code fprintf(stderr, &quot;i=%d\n&quot;, i); or asimilar statement whenever you want to see what value a variable holds.andP;  Forinstance, line 16 in TESTDEBUG.C produces i = 5.andP;  The expanded form canbecome a nuisance, especially with more complicated variables such as amember of an element of an array of structures.andP;  As in DEBUG.H, there arefive categories of output statements controlled by the last character of theprintx statement.andP;  (You can add more.)andP;  Use s to print the value of a string,d to print an int or short, ld to print a long, p to print a pointer, and cto print a character.andM;Also note that DEBUG.H contains a group of macros, the printx macros, whichyou can use to print unconditionally.andP;  This is in contrast to the DEBUGxmacros which have an effect on your code only if you define DEBUGL1 beforeyou include DEBUG.H.andP;  Therefore, TESTDEBUG.C will always print the value ofi, but whether it prints any of the other output, including the subroutinetrace, depends upon DEBUGL1 being an active macro.andM;Space does not permit us to elaborate upon the internal workings of DEBUG.H.andO;Remember that for the purposes of this article, print? (var); allows you toproduce var = value.andP;  TESTDEBUG.C should be sufficient to demonstrate theinterface to DEBUG.H.andM;Greg Comeau is a principal of Comeau Computing, an independent softwaredevelopment firm specializing in UNIX[R] and C productivity tools.andP;  He alsodoes consulting and training for UNIX and C users.andO;</TEXT></DOC>