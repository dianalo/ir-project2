<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-180-004  </DOCNO><DOCID>07 180 004.andM;</DOCID><JOURNAL>Hewlett-Packard Journal  April 1989 v40 n2 p50(7)* Full Text COPYRIGHT Hewlett Packard 1989.andM;</JOURNAL><TITLE>A structured approach to software defect analysis. (technical)</TITLE><AUTHOR>Nakajo, Takeshi; Sasabuchi, Katsuhiko; Akiyama, Tadashi.andM;</AUTHOR><SUMMARY>Flaws in software design that occur as the result of human errornegatively affect quality and productivity.andP;  Effective softwaredefect analysis investigates the relationships between programfaults, human errors and flaws in the design process.andP;  Theseelements must be characterized before corrective measures can betaken.andP;  The two types of defect prevention are investigation ofdesign methodologies and procedures and analysis of problemsresulting from current design methodologies and procedures.andP;  Thefirst approach is not sufficiently accurate.andP;  The second approachhas been used only for solution of problems on a short-term basis.andO;Presented are the results of error analysis done by YokogawaHewlett-Packard (YHP) and Tokyo University's Kume Laboratory, toidentify flaws in YHP's software design methodologies andprocedures and to study the usage of structured analysis andstructured design methods.andM;</SUMMARY><DESCRIPT>Company:   Yokogawa-Hewlett-Packard Ltd. (computer programs).andO;Topic:     Software DesignSoftware PackagesProgram ErrorsTokyo, University ofMethodsProgramming.andO;Feature:   illustrationtablegraph.andO;Caption:   Types of program faults. (table)Distribution and types of module interface matching faults forproject A. (graph)Distribution and types of module function faults for project A.andO;(graph)andM;</DESCRIPT><TEXT>A Structured Approach to Software Defect AnalysisandM;PROBLEMS THAT OCCUR IN SOFTWARE DEVELOPMENT because of human error negativelyaffect product quality and project productivity.andP;  To detect these problems asearly as possible and prevent their recurrence, one approach is to identifyflaws in present software development methodologies and procedures andrecommend changes that will yield long-term defect prevention and processimprovement.andP;  Typical approaches to software defect prevention have been to:andM;* Investigate only design methodologies and procedures and then recommendsuch things as different languages or more tools as defect preventionmeasures.andM;* Analyze the problems resulting from current design methodologies andprocedures and develop solutions for each class of problem.andM;The first approach is the most widely used and has tended not to bedata-driven, thus making the investigation tedious and the results ambiguous.andO;In contrast, the analysis of problems tends to produce less ambiguous resultsand data collection is easier, but it has typically been used only to solveimmediate problems and therefore has produced only short-term solutions.andM;To break out of the status quo, the instrument division of YokogawaHewlett-Packard (YHP) joined with Kume Laboratory of Tokyo University toanalyze 523 software defects that occurred in three products developed byYHP.andP;  We tried to identify the flaws hiding in our current software designmethodologies and procedures, and examine the impact of using the structuredanalysis and structured design (SA/SD) methods.andP;  This paper discusses theresults of this joint investigation.andM;Projects InvestigatedandM;The 523 software defects used for our investigation occurred during thedevelopment of three projects at YHP, which shall be called projects, A, B,and C in this paper.andP;  Project A is a large all-software measurement systemfor analog-to-digital and digital-to-analog converters, and projects B and Care firmware for measurement instruments.andP;  360 defects were studied fromproject A and 163 defects from projects B and C.andP;  These software systems havethe following common characteristics:andM;* They are intended to control hardware, that is, initialization, settingregisters, data retrieval, and so on.andP;  Therefore, they are greatly affectedby the accuracy and clarity of hardware specifications.andM;* Their main parts are intrinsics, which are functions that can be used inmeasurement programs, or commands, which can be used sequentially to controldevices.andM;* They are used to control hardware status, which means that they need manyglobal variables to keep track of hardware states.andM;Analyzing Software DefectsandM;Three types of information useful for a defect analysis can be derived from asoftware defect: the human error (on the part of the developer), the programfaults caused by the human error, and the ilaws in the process causing thehuman error.andP;  Human error is an unintended departure from work standards orplans.andP;  Program faults are outright errors in the software which result inthe system's crashing, producing wrong results, and in general not behavingas specified.andP;  Flaws are imperfections in the design methodologies ordeveloment procedures that affect the occurrence rate of human errors and thepossibility of detecting human errors before they become program faults.andO;Examples of flaws include no documentation, confusing specifications,nonstandard coding practices, bad methodology, no inspections, poor testplanning, and so on.andM;To identify the flaws hiding in the design methodologies and procedures, weneed to understand the mechanisms that cause human errors, and determine therelationship of these errors to program faults.andP;  This analysis is not easybecause the human error process cannot be observed by objective methods, andusually, there isn't enough error data to analyze the relationship to programfaults.andP;  However, the flaws must have some common factors, and they arereflected in the program faults caused by the human errors that occur duringthe design process.andP;  By design process we mean the portion of the softwarelife cycle devoted to the definition and design of a product's features,software architecture, modules, and data structures.andM;Program FaultsandM;To identify the types of faults that occur in programs, it is necessary tostudy what caused the problem and what corrections were made to fix theproblem.andP;  Classification of faults based only on their outward appearancedoes not work well.andP;  Categories of faults such as &quot;wrong range of loopcounters in DO statements&quot; or &quot;omission of conditions in IF statements&quot;define the coding problem, but they do not provide a clear correspondencebetween the fault and the design process.andP;  We still need to know the role ofeach program segment in the system.andP;  For instance, in the DO loop rangeproblem, was the range error related to the number of hardware units, or thelength of the data file?andP;  Understanding program faults from the designer'spoint of view can help us link program faults to flaws in the design process.andO;Fig.andP;  1 shows our categorization of program faults along with examples ofeach category.andP;  Module interface faults relate to transferring data betweenmodules, global variables, and hardware.andP;  Module function faults relate to amodule's performing the wrong function.andP;  Module internal process faultscorrespond to logic errors, internal inconsistency, and programming ruleviolations.andM;Based upon the program fault classification given in Fig.andP;  1, Fig.andP;  2 showsthe distribution of these faults among the three projects studied in thispaper.andP;  The percentages of module interface faults and module function faultsare similar for all three products (91%, 81%, and 85%).andP;  Since our designprocess was relatively the same for all three projects, we guessed that theremust be some flaws in our design process associated with the way we do moduleinterface definitions and module function definitions.andP;  Since module internalprocess faults had the lowest frequency of occurrence and because thesefaults are more directly related to the coding phase, they were not givenfurther analysis.andM;Module Interface Faults.andP;  From Fig.andP;  1, interface faults can be furtherclassified into matching faults (mismatched data transfer between modules orhardware), and restriction faults (omission of checks on transferred data).andO;The ratio of the number of matching faults to restriction faults turns out tobe the same for all three projects and is about four to one.andP;  Consequently,we decided to focus our attention on matching faults for further study.andP;  Fig.andO;3 shows the five types of matching faults and their distribution for projectA.andP;  These five types of matching faults are defined as follows:andM;* Wrong correspondence between values of data and their meanings (e.g.,andO;storing the value r into a global variable that is supposed to contain thevalue r-1, or selecting the wrong destination hardware)andM;* Wrong data type, structure, or order (e.g., mismatch in the structure ororder of arguments passed between programs, or mismatch in the order ofarguments read from a data file or a hardware interface)andM;* Wrong correspondence between names and their meanings (e.g., using thewrong argument in a calling sequence, reading from the wrong global variable,or setting the wrong hardware registers)andM;* Wrong method of processing data (e.g., omission of certain steps whensetting up hardware for some task such as a DMA transfer, or omission ofinitialization conditions or variables when calling other routines)andM;* Wrong name (e.g., using the wrong name to call a module or to access aglobal variable).andM;Module Function Faults.andP;  Function faults are program faults resulting from amodule's performing the wrong internal operations.andP;  Fig.andP;  4 shows the fourtypes and the distribution of module function faults for project A.andP;  Thesefour types of function faults are defined as follows:andM;* Missing or unnecessary operations (e.g., failure to save calculated data toa global variable, or unnecessary calibration of hardware)andM;* Missing condition checks (e.g., saving data to a global variable beforechecking to see if it is permitted to save data to that particular variable)andM;* Wrong behavior of functions (e.g., making the wrong decision, orcalculating the wrong value because the wrong coefficients are used in anequation)andM;* Wrong order of functions (e.g., checking whether a hardware unit existsafter setting it).andM;The Design ProcessandM;Our design process for instrument control software consists of the followingsteps:andM;* Definition of unit functions and product features which are documented inthe system external reference specifications (ERS)andM;* Definition of data structures and module interfaces which are documented inthe internal reference specifications (IRS)andM;* Coding of each moduleandM;* Iteration through the previous steps as necessary.andM;Each of these steps includes the appropriate deliverables (specifications,test plans, etc.), and verification activities, such as design reviews andcode inspections.andP;  Design reviews are done on the external and internalreference specifications, and code inspections are performed on selectedmodules.andM;These documents and procedures are intended to ensure that a defect-freeproduct is eventually produced.andP;  However, this goal cannot be attained if wedo not have a clear knowledge of the types of human errors that occur in thedesign process and of the features of the documents and procedures thataffect the error occurrence rate and error detection.andP;  Consequently, we needto identify the types of human errors that cause program faults, the flaws inthe present design documents and procedures, and the relationships betweenthem.andP;  From this perspective, we used the information gathered frominvestigating the two prevalent program fault types--module interfacematching faults and module function faults--to derive the human errorsassociated with each fault type.andP;  These relationships were derived frominterviews with the design engineers and our own analysis.andP;  Fig.andP;  5summarizes the relationships between the two main types of program faults,human errors, and flaws in the design process.andM;Human Errors and Process FlawsandM;Fig.andP;  6 shows the distribution of the different types of human errors wediscovered during our analysis.andP;  The human error that caused each of softwaredefect was not always clearly recorded, however, as we did for deriving theinformation in Fig.andP;  5, we analyzed various documents and interviewed thedesigners and programmers who developed the system to come up with thenumbers and percentages shown in Fig.andP;  6.andM;Human Errors and Matching Faults.andP;  The human errors responsible for causingmodule interface matching faults are defined as follows:andM;* Module or Variable Specifications.andP;  Module interfaces and global variabledefinitions are missing or misunderstood.andM;* Hardware Specifications.andP;  Software developers overlook and misinterprethardware specifications or other technical requirements of the hardware.andM;* Design Changes.andP;  Changes to the hardware interfaces, other related systems,or module interfaces are not communicated properly.andM;* Related System Requirements.andP;  Technical requirements are not communicatedclearly between development groups and other related systems.andM;As shown in Fig.andP;  6a, human errors associated with hardware interfacespecifications and module interfaces were the most frequent.andP;  Therefore, weexamined the design process and found the following flaws associated withthese error types.andM;* Hardware Specifications.andP;  Hardware specifications are difficult to read andunderstand for software engineers, and as a result, some important technicalrequirements about their interfaces were omitted.andP;  The flaw affected ourexternal and internal design steps.andP;  We found that hardware interfaceinformation for writing software drivers was being derived from circuitdiagrams, which were difficult for software developers to use without error.andM;* Modue or Variable Specifications.andP;  The results of defining interfaces inthe lower-level modules were not well-documented before defining internalalgorithms and coding modules.andP;  Therefore, it was difficult to find moduleinterface mismatching faults in design reviews.andP;  There was a lack ofuniformity in the definition of certain features, and complicated interfacesbetween modules were not taken into consideration.andP;  These flaws also affectour internal design activities.andM;Human Errors and Functions Faults.andP;  The human errors responsible for causingmodule function faults are defined as follows:andM;* Module Specifications.andP;  Errors in the translation from externalspecification to internal module specifications or misunderstanding of modulespecifications.andM;* Commands and Intrinsic Specification and providing the the system externalspecification and providing the wrong or incomplete functionality for systemfeatures.andM;* Status Transition.andP;  Missing or misunderstanding the values of globalvariables that define the different state transitions of the system orhardware.andM;* Related System Requirements.andP;  Missing or misunderstanding the technicalrequirements of other related systems or hardware, resulting in such mishapsas the use of the wrong information from another subprogram to set hardward.andM;As shown in Fig.andP;  6b, human errors associated with commands, instrinsics, andmodule functions were the most frequent.andP;  Therefore, we examined the designprocess and found the following flaws associated with these error types.andM;* Commands and Intrinsics.andP;  During the first part of our design process, whenthe external specification is defined, the independence between the functionsof the commands and intrinsics was not sufficiently defined.andP;  For example,functions associated with the user interface were not partitioned properly,resulting in overlap in functionality, thereby causing program faults.andO;Another problem was that the external specification documenting the commands,intrinsics, and other system requirements was not systematic.andP;  Thespecifications were mainly written in natural languages, which resulted inambiguity regarding the uses and functions of commands and intrinsics.andM;* Module functions.andP;  During the internal design phase of our design process,when the modules and data structures are defined, developers designed themodule structures based mainly on considerations about system performance.andO;This resulted in modules that had no clear correspondence with the systemexternal specification.andP;  Another problem was that module functions were notcompletely specified before the internal algorithm and coding of each modulewere started.andP;  Intrenal design specifications also suffered from a lack ofsystematic documentation, resulting in ambiguous module functions.andM;Design Process IssuesandM;In the previous section we determined the flaws in our design process thatcaused the human errors resulting in program faults in our products.andP;  Boardupon what we learned about these flaws, three issues were derived from ouranalysis.andP;  Fig.andP;  7 shows an example of the relationship between these issuesand our design process.andM;Issue 1.andP;  A systematic method is needed to translate system features definedduring product investigation into the details of a clear system externalreference specification.andM;Issue 2.andP;  A systematic method is needed to translate external specifciationsinto module structure and module functions.andM;Issue 3.andP;  A systematic method is needed to specify the technical requirementsof hardware and to translate these requirements into software moduleinterface specifications.andM;The above issues are vital to our design process.andP;  Since most of our productshave similar characteristics, any solutions to these issues would pertain toall our software products.andP;  Issues 1 and 2 indicate that we need a method totranslate from one level of abstraction to another, with each translationmaking it easier to perform a systematic engineering analysis of the system.andO;With a good analysis methodology we can check the independence andsufficiency of functions and review their specifications to find unsuitablefunction definitions.andP;  Issue 3 requires that we have a methodology thatenables hardware engineers to communicate hardware interfaces effectively tosoftware engineers, and enables software engineers to communicate moduleinterfaces and other system interfaces among themselves.andP;   With such amethodology, module structure and design can be effectively reviewed by thehardware and software engineers of the design team as well as those who musttest and support the product.andM;SA/SD and Design Process IssuesandM;Our investigation led us to believe that the structured analysis andstructured design (SA/SD) methodology is the most suitable candidate fordealing with the three design process issues.andP;  We believe that SA/SD designmethods can help prevent program faults by enabling us to detect and correctthese problems before they become real defects.andP;  Fig.andP;  8 shows thecorrespondence between the three design issues and the solutions offered bySA/SD methods.andM;Proposed Solution for Issue 1.andP;  The key elements of structured analysis wefound useful for dealing with issue 1 include:andM;* Context diagrams, which define the relationship between the software systemand its environmental (e.g., relationship between the hardware and thefirmware elements in an instrument)andM;* Data flow diagrams, which define the action of processes (modules orfunctions) in the system, and the data and control flows between thesemodulesandM;* Process specifications, which define the functions and behavior of theprocesses in a precise structured language.andM;The functions we define for our systems are are organized based on theirrelationship with data.andP;  Functions that depend on each other are difficult toclassify into simple groups.andP;  In structured analysis, detailed functions ofeach intrinsic or command and their relationship can be represented by dataflow diagrams.andP;  Also, the data relationships are clearly specified, and theoperation of each function is defined in a structured language in the processspecification.andM;Proposed Solution for Issue 2.andP;  The system external specification can besmoothly translated to the module structure by using the transformationanalysis technique provided by SA/SD.andP;  Transformation analysis enables us totake each data flow diagram and transform it into more detailed data flowdiagrams or module structure.andP;  By applying this method, we can make a modulestructure that has a clear correspondence to the system externalspecification.andM;Proposed Solution for Issue 3.andP;  The key elements of structured design wefound useful for dealing with issue 3 include:andM;* Structure charts, which define the module hierarchy within a data flowdiagram or within a moduleandM;* Module specifications, which define in a structured language the functionof each moduleandM;* Data dictionaries, which define the data that flows between modules.andM;Among the elements, the data dictionary provides us with the greatestleverage to solve issue 3.andP;  With the data dictionary we can systematicallyspecify the interfaces to the hardware and the interfaces between thesoftware modules.andP;  With these interfaces consistently defined we can easilydetect mismatches between modules and hardware.andM;ConclusionandM;In this investigation, we tried to identify the flaws hiding in our currentsoftware design methodology and procedures and examine possiblecountermeasures against them.andP;  We analyzed about five hundred actual problemsthat occurred during software development for the instruments and used thesedefects as a basis for our investigation.andM;We believe that SA/SD methods can solve some of our design problems.andO;However, there are still some challenges, which include:andM;* Elimination of the inconsistencies between the present specifications usingnatural languages and the new specifications using the SA/SD methodsandM;* Installation of automated tools for using the SA/SD methodsandM;* Establishment of an appropriate education and training system on the SA/SDmethods for the software engineersandM;* Preparation of other groups in our division for dealing with documentswritten using SA/SD methodsandM;* Establishment of design review methods based on the SA/SD methodsandM;* Investigation and use of other tools and techniques provided by SA/SD, suchas state transition diagrams and tranactional analysisandM;* Investigation to find ways to model software behavior that cannot beanalyzed with current SA/SD methods.andM;AcknowledgmentsandM;The authors wish to thank the following people: YHP instrument divisionmanager Mitsutoshi Mori for his useful advice, Drs.andP;  H. Kume and Y. Iizuka ofTokyo University for their valuable comments, I. Azuma in the productassurance section for his help with the analysis of the software defects forone project, and the software engineers in the research and developmentsections for their help with the collection of the software defectinfomation.andO;</TEXT></DOC>