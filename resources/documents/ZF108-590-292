<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-590-292  </DOCNO><DOCID>08 590 292.andM;</DOCID><JOURNAL>MacUser  August 1990 v6 n8 p259(5)* Full Text COPYRIGHT Ziff-Davis Publishing Co. 1990.andM;</JOURNAL><TITLE>Under the hood. (memory states in the Macintosh)(includes relatedarticles on ANSI function definitions, sample generic functions)(tutorial)</TITLE><AUTHOR>Matthies, Kurt W.G.; Hogan, Thom.andM;</AUTHOR><SUMMARY>A guide to memory management in the Apple Macintosh is presented,together with a technical discussion of the programming issuesinvolved.andP;  A Mac application consists of machine-languageinstructions produced by a compiler from source code; eachinstruction is a binary word, and machine code is kept on disk inCODE resources created during the linking step of a programmingproject.andP;  This code must be in RAM to execute.andP;  Large applicationsalso control which code segments are in RAM at any given time.andO;Program data is stored in 32-bit address registers when theprogram is running; careful use of 'register' variables in a Cprogram can speed execution dramatically.andP;  'Scope' of an object isthe length of time it contains valid data.andP;  Memory stacks andheaps are also described.andP;  A stack consists of rigidly structureddata; a heap holds a variety of data objects.andP;  Improper relocationof heap objects causes many program bugs.andM;</SUMMARY><DESCRIPT>Company:   Apple Computer Inc. (products).andO;Ticker:    AAPL.andO;Product:   Apple Macintosh (Microcomputer) (programming).andO;Topic:     Programming InstructionTutorialRAMMemory Management.andO;Feature:   illustrationtableprogramchart.andO;Caption:   C and Mac data types. (table)Sample code. (program)The heap before and after compaction. (chart)andM;</DESCRIPT><TEXT>Under the HoodandM;Programs need memory for their instruction store -- the processor executesinstructions from this in-RAM store -- as well as memory in which to storedata.andP;  Memory makes the Mac go round.andP;  You can't run a program without it.andM;The going-on in memory ordinarily lie below the consciousness of applicationprogrammers.andP;  Usually we can ignore the details of low-level actions such asthe allocation of automatics on the stack, but as certainly as death, taxes,and the ubiquitous bomb box, there comes a time when things go wrong, thesource code is slow in revealing its secrets, and your only recourse is todig in at the machine level.andP;  That's when you need an intimate knowledge ofwhat's happening &quot;under the hood.&quot;andP;  Knowing how your code and data look inRAM at run time is the most important facet of the black art of debugging.andM;This month we'll take a look under the hood of a Mac application.andP;  We'llexplore the stack and heap as they relate to C programming, keeping an eyeout for the potential pitfalls of working with data objects.andM;Program Code in MemoryandM;Under the hood, code consists of the lists of machine-language instructions,created by THINK C's compiler and built-in assembler and derived from yoursource code.andP;  An instruction is a binary word that instructs the machine todo something simple, such as load a value into a register, move data from onememory location to another, or add the contents of two data objects.andM;We've known people who could read and edit machine code, poking bits here andthere into RAM to fix a problem, but most people think of these instructionsin terms of their mnemonics.andP;  The set of mnemonics for a processor is calledits assembly language.andP;  Machine-level debuggers such as ICOM Simulations'TMON and Jasik Designs' Debugger contain a disassembler that converts thebinary form of an instruction into its mnemonic.andP;  Using a debugger is theonly practical way to view machine code.andM;Machine code is kept on-disk, as a part of your application file, in CODEresources, which are created by THINK C when it links the project.andP;  Eachresource corresponds to a code segment that you define in the compiler'sProject window.andM;Machine code must be in RAM while it is executing, and segments are limitedto 32K, so it's necessary to segment a program.andP;  A Toolbox manager called theSegment Loader is responsible for automatically moving these segments fromdisk as they are needed.andP;  THINK C's Get Info menu selection reports the sizeof your code segments.andM;Large applications manage memory by controlling which code segments are inRAM at a given time.andP;  This is how a program with 600K of segmented code canrun in a MultiFinder partition of 512K -- some code segments are removed fromRAM when others are moved in.andP;  The Toolbox call UnloadSeg marks a CODEresource as &quot;purgeable,&quot; making it a likely candidate for being replaced whenanother resource is brought into RAM.andP;  Some applications call UNloadSeg on aset of program segments each time through the event loop.andP;  Another strategyis to call it before attempting to save a document.andP;  You may notice thatGeneric App, our sample application of the past three months, never callsUnloadSeg -- small applications usually don't.andM;Program Data in MemoryandM;The data of a running program is a dynamic collection of values associatedwith the program, kept in known locations of the computer's memory.andP;  Theprogram reads and writes a location with its address, loading the contents ofa 32-bit address register with this address and using an instruction to fetchor store the value.andP;  Memory is organized with its beginning at address 0 andthe maximum possible address at 4,294,967,295, which correspondds to[2.sup.32] -- 1.andP;  Addresses are usually specified in hexadecimal, so theaddress space of a 32-bit machine is 0x00000000 through 0xFFFFFFFF; Appleuses only the lower 24 bits of an address, limiting the Mac's address spaceto 16 megabytes, although System 7 is slated to allow the use of all 32 bits.andM;The Mac's processors have eight 32-bit address registers, named A0 to A7, andeight 32-bit data registers, named D0 to D7.andP;  Address registers are used todo address calculations and to access values in RAM.andP;  Data registers are usedas scratch space for arithmetic calculations.andP;  Register access is faster thanRAM access, and clever use of register variables in your C program candramatically speed up a sluggish application.andM;A data object or variable begins at its address and occupies zero or more ofthe bytes that follow.andP;  The number of bytes that a data object occupiesdepends on its type.andP;  If you're looking at data objects in RAM, there are novisible boundaries between consecutive variables.andP;  To know where one objectends and another begins, you need to know the sizes of these basic types.andO;Table 1 lists these data types and their sizes in both C and Mac-basedPascal.andP;  You should know this material as well as you know yourmultiplication tables or the alphabet.andM;Scope of VariablesandM;Some data objects are long-lived; others last only for as long as a functioncall.andP;  The scope of an object is the length of time it contains valid data.andO;The scope of a global object is the entire program, since it is initializedwhen the program is loaded and space for it is reserved in the applicationheap until the program exits.andP;  On the other hand, variables declared inside afunction -- the local, or so-called automatic, variables -- have a scope thatis limited to the life of that function.andP;  Local variables are not initializedwhen they're created; their values are unknown, and you must initialize thembefore using them -- not doing so is a common mistake of beginningprogrammers.andM;Another common programming error is using a variable outside its scope.andP;  Forinstance, foo(), in Example 1, copies a null-terminated string of characters(the string ends with a byte whose content is 0) and returns a pointer to thecopy.andM;foo() has a serious flaw: The destination buffer is defined inside thefunction as a local variable.andP;  The function returns a pointer to a bufferthat ceases to exit as soon as foo() returns.andP;  This function really needs tobe passed a pointer to the destination buffer, declared in the caller.andP;  Thefix appears in Example 2, and while we're at it, let's call foo() by its realname, strcpy().andM;Notice that strcpy() returns a pointer to one of its arguments, so it knowsthe address of this string.andP;  Why would a function return a pointer to avariable that was passed to it as a parameter?andP;  So that you can writeone-line programs that look like LISP programs, as in Example 3.andM;The StackandM;Automatic variables come into and go out of existence with a function becausethey're created on the application stack.andP;  A stack, sometimes called apush-down list, is known as a LIFO (last in, first out), an acronym thatdescribes how it gives and receives data.andP;  The stack grows and shrinks asdata objects are pushed onto and popped off the stack.andP;  Access to theseobjects is through the top of the stack.andP;  Figure 1 uses a stack of baseballcards to demonstrate the stack mechanism.andM;On the Mac, the top ot the stack is maintained in register A7.andP;  The stackbase starts in high memory and grows downward -- thus register A7's valuedecreases as items are added to the stack.andM;In the normal sequence of a running program, one function calls another andthat called function in turn calls another.andP;  This process proceeds accordingto the program's design.andP;  Programs use the stack to keep track of the flow.andM;A quick note on terminology: If function foo () calls function bar (), thenfoo () is the caller and bar () is the callee, or called function, as inExample 4.andM;The stack is used to store three kinds of data for each function call.andP;  Toillustrate this, we'll use the foo-bar code fragment.andP;  Say that bar () isabout to be called from foo ().andP;  Before bar (e is called, foo () first savesthe machine's current state on the stack.andP;  The state data includes allmachine registers that bar () will use and the return address in foo () atwhich the instruction stream should continue when bar () returns.andM;Next, the values of the parameters arg1 and arg2 are pushed onto the stack.andO;(C compilers push parameters in last-to-first order -- arg2 before arg1 inour example -- and Pascal compilers push their parameters first to last.andO;There are also other differences in the calling conventions of the twolanguages.andP;  Look up calling conventions in the index of Symantec's THINK CUser's Manual if you're interested.)andM;Finally, the space required for local variables of bar () is added to the topof the stack.andM;This collection of stack objects -- the caller's state, the function'sparameters, and the automatic variable space -- is called the current stackframe and is pointed to by 680x0 register A6.andP;  All of a function's localvariables are accessed as offsets from A6.andP;  The compiler generates the coderesponsible for creating the frame and, when the function returns, forupdating both the stack and frame pointers.andP;  This is the reason why localvariables have a scope limited to their owning function's lifetime -- thestack frame in which they reside disappears after the function returns.andM;The HeapandM;Whereas the stack mechanism is rigidly structured and its contents arelimited to function-call-related data, the heap contains a varied collectionof data objects.andP;  The Mac actually has at least two heap zones: one for thesystem and the other for the application.andP;  The system heap is off-limits toyour application.andP;  It contains the system code, fonts, DAs, INITs,device-management data, and other esoteric stuff important to the health ofyour Mac.andP;  The application heap is yours to use as needed, but step lightly:It contains your application resources, including the code segments of yourapplication.andP;  Many a bomb box is the result of writing over a code resourcein the heap.andP;  We'll refer to this application heap zone as &quot;the heap,&quot; butremember that multiple heap zones can be resident in RAM and that thefollowing discussion can apply to any one of them.andM;A heap consists of blocks -- groups of contiguous memory locations -- thatare accessible to your program indirectly, through the Macintosh MemoryManager.andP;  They come in three flavors: free, nonrelocatable, and relocatable.andO;You must allocate a block of memory from the heap before you can use it, aprocess analogous to renting a locker at the bus station -- only oneapplication can use a block at a given time.andM;Free blocks are those that aren't allocated.andP;  Most blocks in the heap fallinto this category when an application begins.andP;  Free blocks are allocatedwith the Memory Manager procedures NewHandle or NewPtr, which accept aparameter that specifies the size of the block, in bytes.andP;  The callsDisposPtr and DisposHandle free an allocated block (Apple disposed of the ein dispose).andM;Nonrelocatable blocks are allocated in the heap, and their location neverchanges.andP;  You allocate one of these blocks with NewPtr, which returns apointer to the block.andP;  Those of you familiar with the library function malloc() will recognize its similarity to NewPtr.andP;  Nonrelocatable blocks areundesirable, because of the Mac's memory-allocation method.andM;Relocatable blocks are preferable and are allocated with NewHandle, whichreturns a handle to the object.andP;  A handle is a pointer to a master pointer --that is, a char ** data type in C.andP;  Relocatable blocks move around in theheap.andP;  Unlike with a sedentary nonrelocatable block, the data in arelocatable block is moved by the Memory Manager when the Mac is trying tocreate a large block of memory in the heap.andP;  This movement is calledscrambling the heap.andM;When NewHandle is called, the Memory Manager collects runs of contiguous freeblocks until it has one large enough to meet the request.andP;  Sometimes it needsto move relocatable objects out of the way to find the required space.andP;  Theproblem with nonrelocatable blocks is that they cause a logjam in the heap --the Memory Manager can't move them and has to restart its search for freeblocks on the other side of this object.andM;Figure 2 illustrates this problem, called heap fragmentation, which limits ablock's maximum size.andP;  The potential maximum size of a block is limited tothe maximum size of a free-block run in the heap, which in a badly fragmentedheap might be much less than the total available memory.andP;  Relocatable handlesavoid the problem, because the Memory Manager can move them out of the middleof long runs of free blocks.andM;Because your data is moved around in RAM, you need a method for keeping trackof it.andP;  Appel's solution relies on a bank of system-maintained masterpointers that hold the addresses of relocatable blocks.andP;  After the MemoryManager moves a block, it changes the value of the master pointer to point tothe block's new location.andP;  The handle returned by NewHandle points at themaster pointer, which never moves, and an application can find its data withdouble-dereference of the handle.andM;Example 5 demonstrates this double-dereference: We've created a liststructure of four ListElm elements.andP;  Note the double-dereference of thehandle to assign the value 4 to the count member of the List structure.andP;  Nomatter where the block ends up in the heap, we can always get to the contentswith a double-dereference.andM;In a user-interface-intensive Mac application, allocations happen all thetime without your knowledge as a result of calls to the Toolbox.andP;  Displayinga dialog box is a good example.andP;  Your application may have calledGetNewDialog and ModalDialog, but the various Toolbox Managers involved increating, displaying, and tracking user events for the dialog box are callingNewHandle behind the scenes and the heap is being scrambled.andM;Another cause of block movements is an intersegment function call.andP;  Wementioned earlier that the Segment Loader makes sure that code is RAM when itneeds to be.andP;  The process of loading a CODE resource just might moverelocatable objects in the heap, to make room for the new code segment.andM;May bugs are due to this relocation of heap objects.andP;  One example occurs whenyour program calculates the address of an object, calls a function or Toolboxcall that scrambles the heap, and then uses the no-longer-valid address.andM;Example 6 demonstrates such a location mixup: The unwary programmer has put acopy of the dereferenced handle into a pointer variable.andP;  Next, he allocatesa handle with NewHandle and then uses the pointer to assign the fields ofTERec.andP;  Because the call to NewHandle moved the teh block, the pointer is nolonger valid and the program is writing to an area in the heap wheresomething vital may exist.andM;You can avoid such problems if you choose to always access the data in therelocatable object by double-dereferencing the handle, as in Example 7.andM;The first problem with this method is its inefficiency.andP;  You're calculatingthe address of the TERec object for each assignment.andP;  This string ofinitializations should be done with a pointer so that the address calculationhappens only once -- it's even better to use a register for the pointer.andO;Just don't do anything to move objects in the heap in the interim.andM;Example 8 has the Power Programming Seal of Approval: Notice that allallocation is done before the handle is dereferenced and the pointer is used.andM;But even if you always double-dereference the handle, you can still get intotrouble.andP;  Example 9 illustrates this premature-address-calculation problem:The address of menuData in the heap is pushed onto the stack, and thenGetIndString scrambles the heap and the address becomes invalid.andM;At times it's necessary to do what we attempted in Example 6.andP;  How do youpass an address of a relocatable object when the object has the potential tomove?andP;  The easiest solution is to lock the object in the heap with HLock,which has the effect of turning a relocatable object into a nonrelocatableone.andP;  Of course, doing so opens the door to heap framentation, so it's a goodidea to first move the object from the center of things to the top of theheap with MoveHH before you lock it.andP;  Example 10 demonstrates the process.andM;You can pass the address of a relocatable object to a Toolbox call that willmove memory if you first lock the handle.andP;  Remember to unlock the handle withHUnlock as soon as possible.andM;Not all Toolbox calls move memory, and locking a handle is not alwaysnecessary.andP;  Certain Toolbox calls, such as OffsetRect, SetPort, FixMul, andInfoScrap, perform operations that really have no business moving relocatableobjects in the heap, and locking handles when using these calls is a waste oftime.andP;  Another class of Toolbox calls, such as NewRgn, GrowWindow, andTESetText, are used for indirectly creating objects in the heap, and whenappropriate, handles should be locked.andM;Inside Macintosh lists all the Toolbox calls that can potentially reorganizethe heap.andP;  They're listed as &quot;Routines that may move or purge memory,&quot; whichis not strictly accurate - memory doesn't really go anywhere, but the objectsin the heap are relocated.andP;  This information is also available from othersources, such as Them's The Programmer's Apple Mac Sourcebook.andP;  It's a goodidea to check your code against these lists if you're going to do things withdereferenced pointers to relocatable heap objects.andM;Now that you know the circumstances under which the heap is scrambled, youdon't need to lock a block every time you assign one of its fields.andP;  Youprobably won't be returning pointers to local variables anymore either.andP;  Wehope you haven't misunderstood this month's message -- we're not advocatingassembly-language programming; rather, we're trying to make you a moreeffective C programmer.andO;</TEXT></DOC>