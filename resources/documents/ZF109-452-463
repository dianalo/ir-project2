<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF109-452-463  </DOCNO><DOCID>09 452 463.andM;</DOCID><JOURNAL>Communications of the ACM  Sept 1990 v33 n9 p68(21)* Full Text COPYRIGHT Association for Computing Machinery 1990.andM;</JOURNAL><TITLE>Lessons from the design of the Eiffel Libraries: tools for the newculture. (component-based software development in the Eiffelenvironment using the Basic Eiffel Libraries) (includes relatedarticles on classifying data structures and major Eiffeltechniques)</TITLE><AUTHOR>Meyer, Bertrand.andM;</AUTHOR><SUMMARY>The use of the Eiffel programming environment, and specificallythe Basic Eiffel Libraries, to promote component-based softwaredevelopment is described.andP;  Eiffel includes seven libraries: theKernel Library, the Support Library, the Data Structure Library,the Lexical Library, the Parsing Library, the Winpack Library andthe Graphics Library.andP;  All seven combined hold 300 classes withabout 5,000 visible operations, or features, although the numbercontinues to grow rapidly.andP;  The libraries described here weredeveloped by Interactive Software Engineering, but third-partydevelopers have created several user interface toolkits anddatabases.andP;  Among the Eiffel techniques described are classes andclusters, assertions, the contract theory, bottom-up development,interface documentation and inheritance.andP;  Design issues arediscussed as well.andM;</SUMMARY><DESCRIPT>Company:   Interactive Software Engineering Inc. (products).andO;Product:   Basic Eiffel Libraries (Program development software) (design andconstruction).andO;Topic:     Program Development TechniquesObject-Oriented ProgrammingProgram Development ToolsProgram LibrariesModular Programming.andO;Feature:   illustrationcharttableprogram.andO;Caption:   The cluster model of the software life cycle. (chart)A contract. (table)A class interface. (program)andM;</DESCRIPT><NOTE>Only Text is presented here; see printed issues for graphics.andO;</NOTE><TEXT>LESSONS FROM THE DESIGN OF THE EIFFEL LIBRARIESandM;The nature of programming is changing.andP;  Most of the software engineeringliterature still takes for granted a world of individual projects, where thesole aim is to produce specific software systems in response to particularrequirements, little attention being paid to each system's relationship toprevious or subsequent efforts.andP;  This implicit model seems unlikely to allowdrastic improvements in software quality and productivity.andM;Such order-of-magnitude advances will require process of industrialization,not unlike what happened in those disciplines which have been successful atestablishing a production process based on the reuse of quality-standardizedcomponents.andP;  This implies a shift to a &quot;new culture&quot; [14] whose emphasis isnot on projects but instead on components.andM;The need for such a shift was cogently expressed more than 20 years ago byDoug McIlroy in his contribution, entitled Mass-Produced Software Components[10], to the now-famous first conference on software engineering:andM;Software production today appears in the scale of industrialization somewherebelow the more backward construction industries.andP;  I think its proper place isconsiderably higher, and would like to investigate the prospects formass-production techniques in software.andP;  [...]andM;My thesis is that the software industry is weakly founded [in part becauseof] the absence of a software components subindustry [...] A componentsindustry could be immensely successful.andM;Although reuse has enjoyed modest successes since this statement was made, byall objective criteria McIlroy's prophecy has not been fulfilled yet; manytechnical and non-technical issues had to be addressed before reuse couldbecome a reality on the scale he foresaw.andP;  (See [1] and [20] for a survey ofcurrent work on reuse.)andP;  One important development was needed to make thispossible: the coming age of object-oriented technology, which provides thebest known basis for reusable software construction.andP;  (That the foundingdocument of object-oriented methods, the initial description of Simula 67,was roughly contemporary with McIlroy's paper tends to confirm a somewhatpessimistic version of Redwine and Riddle's contention [18] that &quot;it takes onthe order of 15 to 20 years to mature a technology to the point that it canbe popularized to the technical community at large.&quot;)  Much of the currentexcitement about object-oriented software construction derives from thegrowing realization that the shift is now technically possible.andM;This article presents the concerted efforts which have been made to advancethe cause of component-based software development in the Eiffel environment[12, 17] through the construction of the Basic Eiffel Libraries.andM;After a brief overview of the libraries, this article reviews the majorlanguage techniques that have made them possible (with more background aboutEiffel being provided by the sidebar entitled &quot;Major Eiffel Techniques&quot;); itthen discusses design issues for libraries of reusable components, the use ofinheritance hierarchies, the indexing problem, and planned developments.andM;The Eiffel LibrariesandM;The standard Eiffel delivery currently includes seven libraries:andM;* The Kernel Library includes classes for basic system needs: handling arraysand strings; input and output; exception handling; universal features; accessto command-line arguments; arithmetic conversions.andM;* The Support Library provides classes for &quot;browsing&quot; (accessing theproperties and structure of Eiffel classes), persistent storage and retrievalof objects, debugging and interactive testing of classes, access to internalobject structures, pattern-matching in strings, mathematical operations,memory management.andM;* The Data Structure Library contains implementations of many fundamentaldata structures and algorithms: lists, trees, stacks, queues, hash tables andnumerous others.andM;* The Lexical Library makes it possible to produce lexical analyzers forregular languages.andM;* The Parsing Library offers facilities for developing parsers and compilers.andM;* The Winpack Library supports the development of window-based applicationsfor character-oriented (non-graphical) terminals.andM;* The Graphics Library allows programmers to write applications usingwindows, menus, mouse input and geometric figures.andM;Together, these libraries currently include 300 classes totaling about 5000visible operations (features).andP;  They are rapidly growing.andM;The libraries discussed here only cover the standard Eiffel librariesdeveloped by Interactive Software Engineering.andP;  Third parties are developingother libraries, especially in fields such as user interface toolkits anddatabases.andM;TechniquesandM;It suffices to consider the amount of time that has elapsed since thepublication of McIlroy's article to realize that achieving industrial reusetakes more than wishful thinking.andP;  A solid set of methods and techniques isneeded.andM;Providing the basis for a realization of McIlroy's dream was the major designgoal for Eiffel.andP;  The various components of the language and environmentresulted directly from our first attempts at building general-purposelibraries, and an analysis of what was needed beyond the mechanisms of Simulaand Ada.andM;The sidebar &quot;Major Eiffel Techniques&quot; reviews the most important ideas andtechniques.andP;  This section concentrates on some of the aspects that mostdirectly affect the contents and style of the libraries.andM;Classes and ClustersandM;The unit of reuse is the class.andP;  This seems to provide the right level ofgranularity; in particular, an individual routine does not constitute areusable module independently of the class to which it belongs.andM;It is useful in practice to gather classes into groups, which may be calledclusters and play a key role in a suggested life-cycle model forobject-oriented desing (see [18] and below).andP;  For the present discussion,&quot;cluster&quot; is really a synonym for &quot;library&quot;: for example we may talk aboutthe Kernel cluster, the Data Structure cluster etc.andP;  The notion of clusteralso applies, however, in the case of non-library classes.andM;In practice, the classes of a given cluster are usually kept in the samedirectory on a hierarchial file system such as Unix or MacOS.andP;  A furthercriterion for clusters is that cycles in the client relation between classesshould usually be constrained to occurring within clusters rather thanbetween different clusters.andM;AssertionsandM;Perhaps the most immediately visible aspect of the library classes is thepresence of elements of formal specification, called assertions, associatedwith each routine and class.andM;Three language constructs using assertions are particularly relevant to theconstruction and use of libraries: preconditions, postconditions andinvariants.andP;  As an example of the first two, routine put_left_sibling, whichreplaces the sibling to the left of a tree node, has the following form:andM;put_left_sibling (other: TREE [T]) isandM;--Make other the left sibling --of current node require not is_root; notleft_sibling.Void do ...Routine implementation ensure left_sibling=otherend--put_left_siblingandM;The require clause introduces the precondition, which is the condition underwhich a call is correct (here the node must not be a root, and must have aleft sibling).andP;  The ensure clause introduces the postcondition, whichcharacterizes the situation resulting from a successful execution of the call(here the new left sibling of the tree passed as argument to the routine).andM;The same class includes an example of the third major construct usingassertions, an invariant clause:andM;invariant arityandgt; = 0; is leaf=(arity=0); ...Many other invariantproperties...andM;Here areity is the number of children of a node.andP;  The second propertyindicates that query is_leaf (an attribute or function) must return true ifand only if the node's arity is 0.andP;  The invariant expresses properties whichmust be ensured on instance creation and maintained by every exportedroutine.andM;A hardware analogy is useful for understanding why assertions are essentialto reusable libraries.andP;  Few people would buy an amplifier without at leastthree elements of information:andM;* What range of input voltage is acceptable--the precondition.andM;* What the corresponding output voltages will be--the postcondition.andM;* What general conditions, such as the temperature range, will be bothexpected and maintained--the invariant.andM;Without such information, there would be no way to use the amplifier otherthan by resorting to internal implementation information (such as wiringdiagrams).andM;The same applies in software.andP;  Although some reusability may be achieved (asthe Smalltalk example shows) in a context where &quot;reusers&quot; must peruse thesource code of the modules themselves, large-scale reuse in the industrialsense seems to require mechanisms for understanding the purpose of reusableelements based on their external, abstract properties.andM;Assertion are not a control structure; in other words, they are not asubstitute for conditional instructions (such as &quot;if the node is a rootthen...&quot;).andP;  In the execution of a correct system, no assertion should ever beviolated; a violated assertion is always the manifestation of an error in thesoftware--a bug.andM;As a consequence, assertions provide an excellent debugging tool; on option,assertion checking may be enabled at runtime, making it possible to catchmany defects.andP;  It is also possible to check preconditions only (PRECONDITIONScompilation option).andM;The Contract TheoryandM;The presence of assertions illustrates the underlying theory of softwareconstruction, &quot;programming by contract&quot; [13], which plays an important rolein the design and use of libraries.andM;Reusing a software component, rather than writing a new component, is similarto contracting for a job, rather than doing the job yourself.andP;  In softwarecontracts, as in human ones, both parties are entitled to some benefits andsubject to some obligations.andP;  Assertions are the contract document, whichexpressly specifies each party's obligations and benefits as follows:andM;* The precondition is an obligation for the client and a benefit for thesupplier.andM;* The postcondition is a benefit for the client and an obligation for thesupplier.andM;This is illustrated for the above example in Table I.andM;The bottom-right box of Table I is particularly important.andP;  It shows theprecondition as a protection for the supplier--limiting the set of cases thatthe supplier must be prepared to handle.andP;  Without such limitations, it wouldbe difficult to write effective reusable components; the sheer burden ofdealing with all possible cases (those which make sense and those which donot) would make components far too complicated, decreasing the likelihoodthat they are correct, efficient--or just usable.andM;This goes against much of the conventional wisdom in software engineering,which favors &quot;defensive programming&quot;--the principle according to whichprograms elements should be as general as possible.andP;  For example, awell-known text about &quot;abstraction and specification in program development&quot;[8] warns sternly against partial routines (that is to say, routines withpreconditions other than true) by stating (page 53) that:andM;Partial [routines] are not as safe as total ones, since they leave it to the[client] to satisfy the constraint in the [precondition].andM;As the only argument in favor of partial routines, the authors citeefficiency.andM;Our experience with designing reusable software leads to a different view.andO;Although restricting the scope of routines certainly helps improve theirefficiency, the main argument is the very one used against them in the abovequotation: reliability.andP;  By taking a system approach to the construction ofreliable software, one realizes that reliability is not obtained by trying tomake every software element responsive to every kind of possible input, afutile pursuit which usually results in elements that are too complex--andhence in less reliability, since in software complexity breeds bugs.andP;  Moreconducive to the production of reliable systems is an approach which ensuresthat every element is characterized by a precise indication of its duties aswell as its rights.andM;The programmer of a client module does not expect the supplier to perform inevery imaginable case; he knows this is unrealistic.andP;  Much more important tohim is the precise definition of what constraints must be satisfied by theclient, and the knowledge that this performance will be guaranteed if theclient abides by those constraints.andM;This assurance that the precondition is sufficient to guarantee correctfunctioning--in other words, that the contract has no hidden clauses--is whatmakes it possible to write correct client modules.andP;  This appears to be a morefruitful approach to software reliability than an endless race for moregeneral supplier modules.andM;Software may have bugs, of course, leading to contract violations.andP;  Thisjustifies the presence of a general-purpose mechanism to monitor satisfactionof assertions--observance of contracts.andP;  This software equivalent of the&quot;Better Business Bureau&quot; is the run-time assertion-checking mechanism.andP;  Ifassertion monitoring is on, the result of an assertion violation is totrigger an exception (see the sidebar entitled &quot;Major Eiffel Techniques&quot;).andM;Bottom-up DevelopmentandM;The preceding discussion also illustrates the precise role of assertions inthe general bottom-up strategy of software development which library-basedobject-oriented design naturally implies.andM;A violated precondition is a bug in the client (which has not observed theconsistency condition on calling a routine); a violated postcondition is abug in the supplier (which has been unable to produce the expected result).andM;This has an important consequence on the run-time checking of assertions.andO;Checking all assertions (preconditions, postconditions, invariants) may implysignificant overhead.andP;  If, however, classes are developed in clusters, assuggested above, and the clusters are built in a bottom-up order.andP;  Accordingto the &quot;Cluster Model&quot; of the software life cycle (see [14] and Figure 1),you will release a cluster for general use as part of a library only once ithas been thoroughly validated and you have good confidence in itsreliability.andP;  This means that you may be prepared to switch off the run-timemonitoring of its postconditions (and also invariants).andP;  But the clientmodules (the higher-level clusters) may not have reached the same degree ofreliability yet and may still contain bugs, which would manifest themselvesas violated preconditions.andP;  In such a case it is useful to monitorpreconditions only, as obtained with the PRECONDITIONS compilation option.andM;As a trivial but typical example, an incorrect client class could call anarray operation with an out-of-bounds index, violating the following routineprecondition in class ARRAY:andM;require lowerandless;=i; iandless;=upperandM;Precondition monitoring will catch the error by triggering an exception.andP;  Ofcourse, the exception is raised in the client: class'ARRAY will not even seethe call.andM;Interface DocumentationandM;One of the major problems confronting the designers of reusable components ishow to document them.andP;  Beyond documentation of a general explanatory natureon clusters and classes, there is a need for very precise documentation whichspells out the way each class and feature may be used by clients--thecontracts.andM;A method which would handle this second part of the documentation as aproduct separate from the classes themselves would face severe obstacles.andO;First, producing such detailed documentation is a tedious process, requiringas much attention as actual programming but intellectually far lessrewarding.andP;  Then, perhaps even more importantly, it is next to impossible toguarantee that the documentation will be updated when the components evolve.andO;Yet (as will be discussed below) library evolution is an inevitablephenomenon.andM;The solution used in Eiffel is to extract the documentation, as much aspossible, from the class texts.andP;  This is made possible by the structure ofthe language and in particular by the presence of assertions.andP;  The short formof a class (also called its abstract form) shows the interface propertieswhich are relevant to client programmers--but no implementation details.andO;This excludes any information on non-exported features and, for exportedfeatures, includes only the signature declarations (types of arguments andresult), the assertions and header comments.andM;For example, the routine put_left_sibling given above appears in the shortform of its class asandM;put_left_sibling (other: TREE [T]) --Make other the left sibling --of currentnode require not is_root; not left_sibling.Void ensure left_sibling=otherandM;A short form of a complete class, extracted from the Library Reference, isgiven in Figure 2.andP;  (This is in fact a &quot;flat-short&quot; form, as explainedbelow.)andM;In the Eiffel environment, the short form is produced automatically from aclass text by a command called short.andP;  For an Ada or Modula-2 programmer,this would amount to having the &quot;interface&quot; or &quot;definition&quot; part of a moduleproduced automatically on demand by a software tool rather than being writtenand maintained by programmers.andP;  All standard documentation on the Eiffellibraries in the library reference book [16] is produced in this way.andP;  Ofcourse, chapters still begin with general explanations, corresponding to thefirst kind of documentation mentioned at the beginning of this section.andM;InheritanceandM;It is not possible to manage a library, with its potentially large number ofcomponents, without a classification scheme for these components.andP;  Thearguments made in the discussion of documentation apply even more forcefullyhere: no classification can be successful unless it is built into thecomponents themselves.andP;  This is shown a contrario by the difficulty ofbuilding satisfactory libraries in languages such as Ada, which do notinclude any classification mechanism.andM;In Eiffel, inheritance provides the basic classification mechanism, and oneof the two reuse mechanisms, the other being the client relation (see thesidebar entitled &quot;Major Eiffel Techniques&quot;).andP;  Two main properties distinguishthese mechanisms:andM;* Being a client means reusing the specification.andP;  You access the features ofa class through its official interface.andM;* Being an heir (or more generally a descendant) means having access to theimplementation.andP;  You can access all of the class properties and redefine themas needed to adapt them to a more specific context.andM;Design IssuesandM;Producing and using the libraries has taught us a number of lessons.andP;  Thissection and the accompanying sidebar discuss some of the principles that seemto have been successful as well as some of what we have learned from ourmistakes.andM;ClassificationandM;The organization of the libraries is not arbitrary.andP;  In particular, thearchitecture of the Data Structure Library is the direct result of an ongoingtheoretical effort to provide a general taxonomy of the fundamental datastructures of computer programming.andM;The taxonomy uses several orthogonal criteria:andM;* Access method: Do clients access elements through keys (as with arrays orhash tables), on the basis of the order of insertions (as with stacks orqueues), with respect to a client-controlled cursor position (as with listsand other &quot;active data structures&quot;, as discussed below), or through someother access method?andM;* Traversing: Is the data structure traversable?andP;  If so, what defines thetraversal order or orders?andM;* Storage: Does the representation use a fixed storage structure, one that isinitially fixed but resizable, an unbounded one?andM;Each of these criteria gives rise to an inheritance hierarchy.andP;  Classesdescribing specific structures--for example, &quot;linked tables,&quot; with akey-based access method, a linearly traversable structure, and an unboundedrepresentation--are obtained by combining classes from all three hierarchies,using multiple inheritance.andM;The three inheritance hierarchies corresponding to the above criteria areshown in the sidebar entitled &quot;Classifying Data Structure.&quot;andP;  (They are fullyused in the version of the Data Structure library to be released at the endof 1990.)andM;Other criteria could also have been used: for example, some structures areread-only, others are read-write; some are persistent (files), others onlyexist for the duration of a session; and so on.andP;  But this would have pushedthe granularity of the classification too far.andP;  Any classification resultsfrom a set of choices: deciding which criteria are essential and which aresecondary.andP;  The decisions we have made are not the only possible ones; theguiding principle has been to try to get the simplest and most convincingstructures.andM;The taxonomy process has been one of trial and error, and more work remainsto be done.andP;  This effort at a multi-threaded classification of datastructures and the associated algorithms--in other words, of some of thefundamental tools of our discipline--has been one of the most challenging andexciting aspects of the library design.andM;NamingandM;An interesting issue is the choice of names for class features.andM;Name choices illuminate the problems that library designers and users facewhen libraries reach industrial size.andP;  At that stage, the concern forconsistency and regularity takes over the concern over the individualproperties of each class and feature.andM;When you only have a few dozen classes, you tend to select names based on theprecise functionality of each feature.andP;  Standard names for operations arealso an immediate influence.andM;The &quot;container&quot; classes of the Data Structure Library (in other words,classes describing various ways of storing and accessing objects such asarrays, trees, stacks and the like) provide good examples.andP;  Some of theclasses in the original version of the library had among their features thoseshown in Table II.andM;A typical call, a.enter (i, x), would enter value x at index i in array a thecall h.insert (x, k) would enter value x associated with key k in thehash-table h; and so on.andM;These name choices reflected the traditional terminology employed for thecorresponding data structures in computer science textbooks.andP;  In other words,the naming criterion was an internal one, adapted to each structure.andM;When the usage of the libraries and its size started to grow, however, werealized that it was preferable to use more external criteria.andP;  All the abovecontainer data structures have a basic mechanism for inserting an element,another for accessing an element, yet another for removing an element and soon.andP;  Because the overall goal of each of these operations is the sameregardless of the variant chosen, it is preferable in the long term to forgetabout traditional, specific terminology and to use consistent names.andP;  As aresult, a small set of standard names was chosen; for example, the names ofthe above example are replaced by those of Table III.andM;Table IV shows some of the standardized names used throughout the libraries.andM;After the initial shock of seeing a STACK module without a push operation,the change appeared to be welcomed by users for the consistency andregularity it brought.andM;At first sight the use of a single name, such as item, for operations whichhave a quite different practical behavior might seem confusing for clientprogrammers.andP;  What is important is the difference of signature andspecification.andP;  For exampleandM;* item for stacks takes no argument and returns an element (the stack top)chosen by the supplier.andM;* item for hash tables takes a string argument chosen by the client andreturns the element associated with the corresponding key in a hash table.andM;These differences are expressed clearly by the signature and specification(assertions) as they appear in the flat-short form of the class.andP;  A clientprogrammer will have to understand them to use the classes effectively.andO;Having to learn different names would bring no benefit to the clientprogrammer, but would only add to the effort of understanding and rememberingthe interface.andP;  With the new conventions, a client programmer can approach anew class and recognize the feature names; this helps him grasp quickly whateach feature is about and removes the need to learn unfamiliar terminology.andO;This is confirmed by the experience of Smalltalk libraries, where therecommended style also favors consistency over specificity.andM;One exception to the generally favorable response to the above name changeswas the use of put for operations which appear to add an element in somecases and merely replace an element in others.andP;  This caused some confusion.andO;Further analysis has led to the following finer-grain characterization:andM;* A routine which replaces an existing element, associated with a certain keyk, with a new value v, will be called replace.andP;  This applies for example toarrays and hash tables.andP;  The rough postcondition in this case isandM;item (k)=vandM;* A routine which adds a new value v will be called add.andP;  The roughprecondition in this case is that the structure now includes one moreoccurrence of v than before.andP;  Examples are lists or &quot;dispenser&quot; structures(stacks, queues).andM;* There is still a need for a basic put operation which simply ensures thatits argument, v, is present in the structure.andP;  In other words, the visiblepostcondition in this case is has (v).andP;  This specification is less strongthan for the other two operations; indeed, put will normally be a synonym foreither replace (for arrays, etc.) or add (for stacks, etc.).andP;  Having such agenerally available feature, with a well-understood semantics, is essentialto enable client programmers to grasp the essentials of a new class quicklyand feel immediately at ease with it.andM;Note how the reasoning which led to this solution required (as almost alwaysin such cases) a precise analysis based on assertions, here postconditions.andM;Other Naming IssuesandM;Further criteria must be applied to the choice of names in a successfullibrary.andM;Names should be both simple (which usually implies that they should be short)and chosen according to consistent conventions.andM;One consequence is that library authors should resist the temptation toover-qualify names (a typical beginner's mistake).andP;  For example a procedurefor handling an event in class EVENT in a graphics system should not becalled handle_event or event_handle, but just handle.andP;  (1)andM;This would not necessarily be true in a less-typed language because ofambiguities that might result if many classes use the same simple names suchas handle, put, item, etc.andP;  Typing averts these problems.andP;  When you seeandM;e,handle (...)andM;the declared type of e immediately tells you which version of handle is meant(while leaving the desirable ambiguity provided by dynamic binding).andM;To facilitate quick recognition and understanding of the role of eachfeature, the Eiffel libraries usually follow uniform rules as to thesyntactic category of feature names:andM;* Names for procedures are verbs in the imperative, as in put.andM;* Names for attributes or functions of type other than Boolean are nouns, asin item.andM;* Names of Boolean queries are adjectives, as with full, or verbs suggestinga question, as with is_leaf.andM;Because English is the default language for the libraries, these rules cannotbe absolute; we need additional conventions regarding the use of words suchas empty, which may be used both as an adjective and as a verb.andM;Feature ObsolescenceandM;Name changes such as the ones experienced when the library moved to the newnaming system, as described above, are only a special case of changes to theinterface to a class.andP;  Internal implementation changes do not affect clients(the Eiffel automatic recompilation mechanism in fact guarantees that clientswill not be recompiled in such a case); but of course interface changes willaffect them.andM;This raises as key question, which surprisingly does not seem to have beenaddressed in the reuse literature: feature obsolescence.andM;PErfect reusable components are not obtained at the first shot.andP;  Yet if oneis aiming at a full-fledged industry of reusable software components,perfection is what we should eventually strive for.andM;This raises the question of what you do when you have produced a firstversion of a reusable class, or even a second and a third, and you realizethat you could have done better.andP;  Two spirits are at odds:andM;* The Great Tempter of Perfectionism exhorts: &quot;Correct it here and now beforeit is too late!&quot;andM;* The Guardian Angel of the Installed Base warns: &quot;Think of the currentusers!&quot;andM;To try to placate both, the library designer or maintainer needs a mechanismto phase out obsolete features progressively without impairing the correctfunctioning of existing client classes whose programmers may not with to&quot;migrate&quot; immediately.andM;Eiffel includes a language mechanism devised to support this process.andP;  Aroutine may be declared as &quot;obsolete.&quot;andP;  For example, the new ARRAY classstill has a feature enter of the formandM;enter (i: V; v: T) obsolete &quot;Use 'put (value, index)'&quot; is do put(v, i)end--enterandM;Such a feature is normal in every respect but two.andP;  It can be used by clients(if it is exported) and by descendants, but such uses will triggercompile-time warnings, listing the message given after the obsolete keywords.andO;Furthermore, an obsolete feature does not appear in the short form of theclass.andM;Because they cease to be documented in the official reference, obsoleteroutines pose no immediate threat to the simplicity of the class as perceivedby new users.andP;  This is different from what would occur if both old and newfeatures were merely kept as synonyms.andM;More sophisticated effects could have been devised for obsolete features; forexample, one may imagine a mechanism which would on option take care ofupdating client calls (although this is not so trivial when the new routinehas different arguments or, as in the above example, changes the order ofarguments).andP;  As it is, however, the mechanism has played a key role inallowing Eiffel library developers to take advantage of bouts of esprit del'escalier without disturbing existing clients too much.andP;  (Esprit del'escalier, or &quot;wit of the staircase,&quot; is a great thought which unfortunatelyis an afterthought, like a clever reply that would have stunned all the otherdinner guests--if only it had occurred to you before you started walking downthe stairs after the party was over.)andM;Of course, if you uncover a serious design mistake in the original version ofthe class you should not leave it around but just rewrite the class.andP;  In thisclass, the first spirit (the Tempter) wins handily.andP;  Feature obsolescence isuseful in the following cases:andM;1)  You can think of a better name for a routine.andM;2)  You want to advise programmers not to use the routine any more.andM;3)  You can think of a better signature or specification (assertions).andM;Situation 1 may occur as you are doing an after-the-fact cleanup of yourlibrary and realize that naming conventions could be made more consistent (asdiscussed above).andM;Situation 2 may arise when the routine's action is not needed any more (aswith a routine which performed some initialization which you later realizecan be carried out automatically on object creation).andM;Situation 3 may occur (among other cases) when you realize that a routine hastoo many arguments and should be split into two or more routines.andP;  Forexample, you may have a procedure adding a subwindow to a window, under theformandM;w.add[subwindow (other[window, horizontal[position, vertical[position)andM;but then you realize that it would have been better to omit the last twoarguments and have the subwindow be initially positioned at the top leftcorner of the parent window, and let clients move it if necessary by using aspecific move procedure, which is needed anyway.andM;Cases 1 and 3 often involve changes small enough that it is tempting to heedthe Angel's advice and resist any change at all.andP;  But in the long term thisis dangerous.andP;  Here the Angel is really a front man for the hideous Devil ofEternal Compatibility with the Horrors of the Past, whose nefarious influenceis all too visible in the computer industry.andM;Arguments and OptionsandM;The last example illustrates a general guideline about choosing the properarguments for library routines.andM;In general, a routine should only include among its arguments what may becalled &quot;indispensable arguments,&quot; as opposed to &quot;options.&quot;andP;  An option isrecognized by the class's ability to set reasonable default values, as forhorizontal[position and vertical[position above.andP;  In contrast, there is noreasonable default for other[window, which should thus be an indispensableargument.andM;A widely applicable guideline is to avoid including options among thearguments to a routine.andP;  Rather, the creation procedures of the class shouldset defaults for each option, and there should be saparate routines to changethe option's values.andP;  (Some of these issues were discussed, in the context ofmuch more primitive technology, in [11].)andM;Obtaining the ProperandM;Inheritance StructuresandM;By reading theoretical discussions of object-oriented techniques, it wouldseem that one always gets the inheritance structure--theclassification--right from the start.andP;  The reality, however, is usually morepainful.andM;Classification tends to be the result of hard work as much as of immediateinsight.andP;  This work may be called generalization and is worth moreattention.(2)andM;Class AbstractionandM;Object-oriented library design is a quest for abstraction.andP;  Using inheritancemeans that one writes classes that are more general than what is immediatelyneeded for the problem at hand.andP;  Deferred classes are particularly usefulhere.andP;  Once you have captured a general pattern through a deferred class, youor others may produce specific variants by writing nondeferred classes whichimplement the parts of the pattern that had been left open in the deferredclass.andP;  Object-oriented techniques ideally support this remarkably elegantprocess of working from the abstract to the concrete, from the general to thespecific.andP;  (3)andM;In practice, however, the scheme is not always as smooth and intellectuallysatisfying as the theory would have it.andP;  Even library developers tend toproduce classes which intially are often too specific: particularimplementations of a certain abstraction, rather than the abstraction itself.andO;It is hard to blame them: programmers are inherently problem solvers.andP;  Fewwill complain if they get the job done first.andM;If reusable products are part of the goal, however, the process cannot stopthere.andP;  When you realize that a certain class is less general than it couldhave been, you should use this discovery as an opportunity to reorganize theinheritance hierarchy.andP;  There have been numerous examples of this type ofreorganization in the evolution of the Eiffel Libraries:andM;* The Data Structure Library originally contained a TREE class, which hasproved powerful and useful, serving as a basis for the hierarchical windowingsystem of the Graphics and Winpack libraries, for the data structures of theParsing library, and for the abstract syntax tree of our Cepage structuraleditor.andP;  But it was too specific, describing just one implementation of treesrather than the general concept.andP;  Recognition of this situation led to adeferred class, of which the original became an heir.andM;* In the version of the library available at the time of this writing, filesand strings are still treated as special classes, intead of inheriting frommore general &quot;chain&quot; or &quot;stream&quot; classes (used for example as ancestors toclasses describing lists).andP;  Here the taxonomy effort mentioned aboveobviously did not go far enough.andP;  After taking a closer look, we came to therealization that strings should be treated just as sequences of characters,based on a SEQUENCE Data Structure Library class.andP;  As for text files, theycame out just as a specific variant of strings, with only one clearlydistinctive propert: their persistence.andP;  The class hierarchy has been bothenriched and simplified as a result.andM;The need for an a posteriori abstraction process was discussed in theSmalltalk context by Johnson and Foote (4) [7].andM;The process is aided in the Eiffel environment by a variant of the shortclass abstracter.andP;  The commandandM;short-e class[nameandM;will produce a deferred version of class[name, with all implementationdetails removed.andP;  This is usually a good basis for obtaining a more abstractclass while keeping the interface for clients.andM;Extraction ofandM;CommonalitiesandM;A related activity arises from the a posteriori realization that duplicationof efforts has led to similar classes being written by different people, oreven by the same person at different times.andM;Inheritance is the ideal mechanism for capturing commonalities betweensimilar components.andP;  If the developers initially missed the commonalities,then it is always possible to reconstruct the inheritance structure aposteriori.andM;As with the previous case, the result is to produce more abstract classes,often deferred, of which the original classes become descendants.andM;As an example, both the Winpack non-graphical windowing library and theGraphics library use hierarchically structured windows, with many concepts incommon.andP;  The two WINDOW classes are not, however, part of the sameinheritance hierarchy.andP;  This is clearly a mistake, which is in the process ofbeing corrected.andP;  The result should yield a library which supports theexecution of the same applications both on a graphical terminal and, insomewhat degraded mode, on a character-oriented terminal, at the cost of aminimal change to the client software (such as a different call atinitialization time).andM;Switching to ReverseandM;What is common to the previous two activities--abstraction, extraction ofcommonalities--is that they depart from the view of inheritance which isusually suggested in the object-oriented literature: the idea that the brightdesigner will somehow obtain the proper inheritance structure the first timearound.andM;It is always preferable, of course, to get the inheritance right initially.andO;But it serves no useful purpose to pretend that this will always be the case.andO;Better recognize that the process may involve trial and error, as a result ofour yearning for the concrete, and of our frequent failure to detectcommonalities early enough.andP;  It is best to be prepared for the inevitablechanges of direction--switching to reverse, as it were--in building theinheritance structure.andP;  What counts is that in the end we should get theuseful and elegant inheritance hierarchies that condition effectiveobject-oriented reuse of components.andM;An important aspect of both abstraction and extraction is that they normallydo not affect the clients of the classes being restructured, since theinterface of a class will not change if it is rewritten with a differentancestry.andP;  In Eiffel, clients will not even be recompiled, since theautomatic (makefile-free) recompilation mechanism will recognize that aninterface has remained untouched and that the clients are hence still validas compiled before.andM;This observation highlights a fundamental, although often misunderstood,aspect of inheritance: inheritance is a supplier's mechanism, not a client'smechanism; it does not affect the interface.andP;  For the clients of a class,what the class inherits from is irrelevant.andP;  Such tools as the flattenersupport this view by providing inheritance-free versions of a class whenneeded for the benefit of clients.andM;As a result of the abstraction and extraction activities, a generalphenomenon may be observed in organizations (such as our own) that have madea serious effort at producing, using and maintaining libraries.andP;  Thisphenomenon, also noted in [7], is a progressive elevation of the level ofabstraction of the classes produced by a group or organization committed toobject-oriented programming.andP;  As one starts reusing previous classes,cataloging them, archiving them into libraries, the need for more generalversions becomes apparent.andP;  It does not make sense to lament that theseversions were not produced right from the start; what counts is the constantimprovement in quality and generality that the process yields if properlyimplemented.andM;Storing and AccessingandM;ComponentsandM;A common problem in the component-based approach to software development isdetermining how to enable client programmers to find out about availablecomponents and retrieve them easily.andP;  Obviously, the seriousness of thisproblem grows with the number of components.andM;The concern over this issue, especially among managers, is exaggerated.andO;Compared to the need for reusable components, the libraries that now existare only a small beginning.andP;  A manager or programmer who hesitates aboutreuse for fear of being overwhelmed by the potential number of resultingcomponents is similar to someone who refuses a pay raise for fear of notknowing what to do with the money.andP;  The natural reaction of a coworker (insuch an unlikely situation) is: &quot;why don't you give me the money as well asthe troubles--I'll handle both.&quot;andP;  Similarly, the first problem in introducingthe new culture is not to keep on top of the components, but to build enoughhigh-quality components initially.andM;BrowsingandM;This being understood, the retrieval problem must of course be addressed.andO;The first step was provided by &quot;browsers,&quot; a concept introduced by theSmalltalk environment [4].andP;  The graphical Eiffel browser (GOOD) makes itpossible to obtain information about all the classes in a &quot;universe&quot; (set ofdirectories).andP;  The information is displayed in graphical form (see Figure 3).andO;By clicking on a class bubble, one can request the display of other bubblesand their relation to the original class: parents, ancestors, clients,suppliers etc.andP;  One can also obtain information about the class, for examplethe list and signatures of its features or the class text in its variousforms (full, short, flat-short).andM;Beyond the browser stage, what is required are variable database of softwarecomponents.andP;  Standard database technology seems directly applicable here tosupport archival operations and queries.andM;The use of database tools is consistent with a principle stated in the abovediscussion of documentation: all information about a class should bededucible from the class text--as opposed to information kept separately, forwhich it would be difficult to guarantee that consistency is maintained asthe class evolves.andM;IndexingandM;This suggests a need for including in class texts higher-level informationthan is given just by the executable class text.andP;  Examples of suchinformation include keywords, hardware requirements, and more generallyelements of &quot;domain analysis&quot; [1].andP;  To cater to this need, Eiffel classes mayinclude an initial indexing clause, which is part of the language.andP;  This is aclause of the formandM;indexing index: value, value, value, ...andP;  ...andM;where each subclause lists the values associated with a given index.andP;  Forexample, the ARRAY_LIST class from the Data Structure Library has thefollowing clause:andM;indexing names: list, sequence; representation: array, linked; access: fixed,cursor; size: resizable; contents: genericandM;Once included in a class, such information may be used by various querytools.andP;  Such tools are currently being written for the Eiffel environment.andM;Indexing GuidelinesandM;The choice of indices and values is free (values may be identifiers, integersetc).andP;  This makes it possible to define a precise style for a given libraryor installation.andP;  Such a standardized style has been defined for and appliedto the current libraries [17].andP;  It includes the following guidelines:andM;* Keep the Indexing clauses short (2 to 5 entries is typical).andM;* Avoid repeating information which is in the rest of the class text.andM;* Use a set of standardized indices for properties that apply to manystructures, such as choice of representation.andP;  (Examples of such indices aregiven below.)andM;* For values, define a set of standardized possibilities for the commoncases.andM;* Include positive information only.andP;  For example, a representation index isused to describe the choice of representation (linked, array, ...).andP;  Adeferred class does not have a representation.andP;  For such a class the clauseshould not contain the entry representation: none but simply no entry withthe index representation.andP;  A reasonable query language will make it possibleto use a query pair of the form andless; representation, NONE andgt;.andM;The indices chosen for the library, along with typical values, are thefollowing.andM;An entry of index names is used to record the names under which thecorresponding data structures are known.andP;  Although a class has only oneofficial name, the abstraction it implements may be known under other names.andO;For example, a &quot;list&quot; is also known as a &quot;sequence.&quot;andP;  Also, the official namemay need to be of an abbreviated form; in such a case, the names entry maygive the expanded form of the abbreviation.andM;An entry of index access records the mode of access of the data structures.andO;Standard values include:andM;* fixed (only one element is accessible at any given time, as in a stack orqueue).andM;* fifo (first-in-first-out policy).andM;* lifo (last-in-first-out).andM;* index (access by an integer index).andM;* key (access by a non-integer key).andM;* cursor (access through a client-controlled cursor, as with the listclasses).andM;* membership (availability of a membership test).andM;* min, max (availability of operations to access the minimum or the maximum).andM;Obviously, more than one of these values may be used.andM;An entry of index size indicates a size limitation.andP;  Among common values:andM;* fixed means the size of the structure is fixed at Create time and cannot bechanged later (there are few such cases in the library).andM;* resizable means that an initial size is chosen but the structure may beresized (possibly at some cost) if it outgrows that size; for extendiblestructures without size restrictions this entry should not be present.andM;An entry of index representation indicates a choice of representation.andP;  Valuearray indicates representation by contiguous, direct-access memory areas.andO;Value linked indicates a linked structure.andM;An entry of index contents is appropriate for &quot;container&quot; data structures.andO;It indicates the nature of the contents.andP;  Possible values include generic(for generic classes), ini, real, bool, char (for classes representingcontainers of objects of basic types).andM;For example, the ARRAY_LIST class describes lists implemented by one or morearrays, chained to each other.andP;  Its indexing clause, as given above, reflectsthe preceding guidelines.andM;Evolution of theandM;LibrariesandM;Much work remains to be done, of course, on the Eiffel libraries.andP;  The mainareas of improvement are the following:andM;* Improve the regularity and consistency of the existing classes, applyingmethods of &quot;abstraction&quot; and &quot;extraction of commonality&quot; as described above.andM;* Build more arhival and query tools, based on indexing clauses and relatedconcepts.andM;* Add uniform mechanisms to the classes, for example iterators on every datastructure.andM;* Add many classes used as examples in the object-oriented literature (inparticular [12]) in the form of full-fledged reusable components.andM;* Extend the Data Structure Library to cover the essential part of theclassical textbooks on this subject.andM;* Extend the graphical and user-interface classes.andM;* Develop more specialized libraries: database access, numerical software,etc.andM;The list of attractive new areas to cover is considerable and beyond thereach of any single group.andP;  We do hope that a real &quot;software componentssubindustry&quot; (using McIlroy's terms) will join us in producing thehigh-quality components which are needed to make the new culture a reality.andM;(*1) The fashion of using in-word capitalization, as in EventHandle, does notconform to normal English usage and is frowned upon in the recommended Eiffelstyle.andM;(*2) This section draws heavily on an earlier publication [12]andM;(*3) Because of the common graphical representations for inheritancediagrams, this process is sometimes mistakenly viewed as &quot;top-down.&quot;andP;  It isin fact a typically bottom-up process of particularizing general-purposetools.andM;(*4) Many of the design rules of that article are confirmed by ourexperience.andP;  One point of divergence is its recommendation that inheritancehierarchies be narrow and deep.andP;  Although it is always rewarding to obtaindeep classifications, in some cases inheritance just serves to classify apotentially large set of alternate cases, all at the same level.andP;  Forexample, class EVENT in the graphical library has many heirs describingvarious event types.andP;  The same situation occurs in classifications of naturalobjects such as plants or animals: sometimes the categories are complex; atother times they are just numerous.andM;ReferencesandM;[1] Biggerstaff, T.J.andP;  and Perlis, A.J.andP;  Eds.andP;  Software Reusability.andP;  ACMPress, Addison-Wesley, Reading, Mass., 1989.andM;[2] Dahl, O.-J., Myrhaug, B. and Nygaard, K. (Simula) Common Base Language.andO;Norsk Regnesentral Norwegian Computing Center, Oslo, February 1984.andM;[3] Floyd, R.W.andP;  Assigning meanings to programs.andP;  In Proceedings of theAmerican Mathematical Society Symposium in Applied Mathematics, vol.andP;  19(1967), pp.andP;  19-31.andM;[4] Goldberg, A. and Robson, D.andP;  Smalltalk-80: The Language and itsImplementation.andP;  Addison Wesley, Reading Mass., 1983.andM;[5] Hoare, C.A.R.andP;  An axiomatic basis for computer programming.andP;  Commun.andO;ACM, 12, 10 (October 1969), 576-580, 583.andM;[6] Hoare, C.A.R.andP;  and Wirth, N.A.andP;  Contribution to the development of ALGOL.andO;Commun.andP;  ACM, 9, 6, (June 1966), 413-431.andM;[7] Johnson, E. and Foote, B. Designing reusable classes.andP;  J. Object-OrientedProg.andP;  1, 2 (June-July 1988), 22-35.andM;[8] Liskov, B. and Guttag, J.andP;  Abstraction and Specification in ProgramDevelopment.andP;  MIT Press, Cambridge, Mass., 1986.andM;[9] Luckham, D. and von Henke, F.W.andP;  An overview of Anna, a specificationlanguage for Ada.andP;  IEEE Softw.andP;  2, 2 (March 1985), 9-22.andM;[10] McIlroy, M.D.andP;  Mass-produced Software Components.andP;  In SoftwareEngineering Concepts and Techniques (1968 NATO Conference on SoftwareEngineering), J.M.andP;  Buxton, P. Naur and B. Randell, Eds., Van NostrandReinhold, 1976, pp.andP;  88-98.andM;[11] Meyer, B.andP;  Principles of package design.andP;  Commun.andP;  ACM, 25, 7 (July1982), 419-428.andM;[12] Meyer, B.andP;  Object-Oriented Software Construction.andP;  Prentice-Hall 1988.andM;[13] Meyer, B.andP;  Programming as contracting.andP;  Tech.andP;  Rep.andP;  TR-EI-12/CO,Interactive Software Engineering, Santa Barbara, Calif, 1988.andM;[14] Meyer, B.andP;  The new culture of software development: Reflections on thepractice of object-oriented design.andP;  In TOOLS '89 Technology ofObject-Oriented Languages and Systems, (Paris, November 1989), pp.andP;  13-23.andM;[15] Meyer, B.andP;  Static typing for Eiffel.andP;  Tech.andP;  Rep.andP;  TR-EI-18/ST,Interactive Software Engineering Inc., 1989.andM;[16] Meyer, B. Eiffel: The libraries.andP;  Tech.andP;  Rep.andP;  TR-EI-7/LI, InteractiveSoftware Engineering Inc., Stanta Barbara, Calif., October 1986 (version 2.2,August 1989).andP;  To be published by Prentice-Hall in 1990.andM;[17] Meyer, B. Eiffel: The language.andP;  Tech.andP;  Rep.andP;  TR-EI-17/RM, InteractiveSoftware Engineering Inc., Santa Barbara, Calif, 1989.andP;  To be published byPrentice-Hall in 1990.andM;[18] Redwine, S.T.andP;  and Riddle, W.E.andP;  Software technology maturation.andP;  InProceedings of the Eighth International Conference on Software Engineering(London, August 1985), pp.andP;  189-200.andM;[19] Sada, F. and gindre, C.andP;  A development in Eiffel: Design andimplementation of a network simulator.andP;  J. Object-Oriented Prog.andP;  2, 2 (May1989).andM;[20] Tracz, W. Software Reuse: Emerging Technology (Tutorial).andP;  Catalognumber EH0278-2, IEEE, 1988.andM;CR Categories and Subject Descriptors: D.2.2 [Software Engineering]: Toolsand Techniques--Software Libraries; D.2.4 [Software Engineering]: ProgramVerification--Reliability; D.2.7 [Software Engineering]: Distribution andMaintenance--Corrections, Documentation, Enhancement, Extendibility; D.2.9[Software Engineering]: Management--Life Cycle; D.2.10 [SoftwareEngineering]: Design--Methodologies; D.2.m [Software Engineering]:Miscellaneous--Reusability; D.3.3 [Programming Languages]: LanguageConstructs--Abstract Data Types; I.3.4 [Computer Graphics]: GraphicsUtilities--Graphics Packages, Software Support; K.6.3 [Management]: SoftwareManagement--Software MaintenanceandM;General Terms: Design, Documentation, Languages, Management, Reliability,VerificationandM;Additional Key Words and Phrases: Assertion, class, cluster, clusterlife-cycle model, component, defensive programming, invariant, librarydesign, object-oriented design, object-oriented programming, postcondition,precondition, software obsolescence.andM;BERTRAND MEYER is president of Interactive Software engineering (SantaBarbara) and Societe des Outils du Logiciel (Paris).andP;  His research hascovered several aspects of software engineering, particularly design methods,reusability, programming languages, formal specification, interactive systemsand object-oriented techniques.andP;  He is chairman of the TOOLS conference(Technology of Object-Oriented Languages and Systems).andP;  His two latest booksare Object-Oriented Software Construction and Introduction to the Theory ofProgramming Languages, both published by Prentice-Hall.andP;  The next two,Eiffel: The Language and Eiffel: The Libraries are scheduled to be publishedat the end of 1990.andP;  Author's Present Address: Interactive SoftwareEngineering, Inc., 270 Storke Road Suite 7, Goleta, CA 93117;email-bertrand@eiffel.com.andM;Major Eiffel TechniquesandM;The Eiffel libraries make full use of the facilities provided by the languageand tools.andP;  This sidebar reviews some of the basics of Eiffel programming.andO;More details may be found in [2] and [7].andM;The various components of the method were designed as a whole: assertionscondition documentation tools, genericity complements inheritance, dynamicbinding is the natural associate of static typing, and so on.andP;  It would bedifficult to remove any of these elements without impairing the consistencyof the overall construction.andM;ClassesandM;The object-oriented approach to reusability begins with the premise thatpractical reusable components should be organized around objects (datastructures) rather than functions (action structures).andP;  This leads to thefundamental modular construct of object-oriented programming, introduced bySimula [2], which is the class, a module built around a data abstraction.andP;  Aclass is a model for a set of data structures (objects).andP;  Typical examples ofclasses extracted from the Basic Eiffel Libraries include:andM;* TREE, describing objects which are trees (or, equivalently, tree nodes),from the Data Structure Library.andM;* MENU, describing objects which are pull-down menus, from the GraphicsLibrary.andM;* CONSTRUCT, describing objects which are components of structured texts,from the Parsing Library.andM;Such a class is a descriptive program text specifying the properties ofrun-time objects.andP;  An object conforming to a class specification is said tobe an instance of the class.andP;  For example, an instance of class MENU is anindividual pulldown menu, created during the execution of a software system.andO;A system using a certain class may, during its execution, create an arbitrarynumber of instances of the class.andM;A class definition introduces a number of features representing operationsapplicable to instances of the class.andP;  Examples of features of class MENU arethe following (whose non-obvious names are explained in the text):andM;* count an integer, which for any instance of the class indicates the numberof its menu entries.andM;* item, which for a suitable integer i indicates the i-th menu entry.andM;* put, which replaces a menu entry by another.andM;The first two examples are &quot;query&quot; features, which merely return informationabout an object; the third is a &quot;command,&quot; which may change the object.andP;  Aquery with no arguments, such as count, may be implemented as either:andM;* An attribute of the class, in which case each class instance includes afield containing the corresponding value.andM;* A function, represented by an algorithm for computing the value for anygiven instance.andM;A query with arguments, such as item, must be represented by a function.andM;A command, such as put, is represented by a procedure.andP;  Procedures andfunctions constitute the routines of a class.andM;This technique of describing a set of run-time objects (such as tree nodes,menus, construct specimens) through the set of operations (the features)follows from the theory of abstract data types, which suggests that objectsshould be known through applicable operations (and the properties of theseoperations, described through assertions) rather than implementation aspects.andM;A class is indeed not just a module but also a type in the traditionalprogramming language sense--obtained here as an implementation of an abstractdata type.andP;  The identification of modules and types is central to theobject-oriented form of software architecture.andP;  In Eiffel, thisidentification is complete: there is no other form of module than the class,and all types (including basic types such as INTEGER and the like) aredefined by classes.andM;This identification goes further than the idea of &quot;programming with abstractdata types&quot; which may be applied, for example, in Ada or Modula-2.andP;  A modulein one of these languages may be based on an abstract data type, but themodule and the type remain distinct notions.andP;  In Eiffel, the module--theclass--is also the type.andP;  Apart from the conceptual simplicity that thisfusion of concepts confers to the method, its main advantage is to open theroad to inheritance, as discussed below.andM;As a result of this summary, it may be noted that &quot;object-oriented&quot; is amisnomer.andP;  Not that objects are unimportant; in fact, the entire execution ofany system is devoted to creating objects and applying features to them.andP;  Butthe same is true, to a large extent, of a Pascal, Ada or C program, even ifthe objects in those cases are called records or structures.andP;  What is reallydifferent with Simula or Eiffel is the notion of class.andP;  Much confusion wouldbe avoided if the field were known by the more accurate term class-orienteddesign and programming.andM;Information HidingandM;Various classes may use each other's facilities.andP;  A class which relies onanother is said to be its client; the other class is the supplier.andM;In the implementation of a class, some features will play a purely internalrole and should not be visible to clients.andP;  The syntax of a class includes anexport clause which lists those features which are available to the class'sclients.andP;  Any other feature is secret.andM;AssertionsandM;As explained in the text, a class and its routines may be characterized byassertions, stating their precise semantic properties.andM;The use of assertions is rooted in work on formal specification andverification, beginning with the original papers of Floyd and Hoare [3, 5],although the idea of supporting assertions in programming languages datesback to Algol W [6] and may be found in more recent designs such as theAda-based language Anna [9].andM;The assertion sublanguage of Eiffel is not a full-fledged formalspecification language but is limited to boolean expressions, with a fewextensions.andP;  Purely applicative expressions are usually sufficient to coverthe most important semantic properties of routines and classes; more advancedproperties are captured by functions.andM;InheritanceandM;Inheritance in Eiffel serves both as a module inclusion facility andsubtyping mechanism.andM;The relation on classes induced by inheritance may be characterized as&quot;is-plus-but-except&quot;:andM;* &quot;Is&quot; since the instances of an heir class may also be used as instances ofa parent class.andP;  For example, an instance of class FIXED_TREE (describingtrees where each node has a fixed number of children) may be used wherever aninstance of the parent class TREE (describing trees in general) is expected.andM;* &quot;Plus&quot; since an heir may (and usually does) add new features to those ofits parent.andM;* &quot;But&quot; since an heir may change the implementation of any feature or itssignature (within the constraints of the type system).andP;  This is theredefinition mechanism.andP;  The specification of a redefined feature must remaincompatible with that of the original by including an equal or weakerprecondition, and an equal or stronger postcondition.andP;  (This means that theredefined version is a subcontractor to the initial version; both client andsubcontractor are subject to the terms of the original contract.andP;  Theprecondition rule means that no additional constraint may be imposed on theclient; the postcondition rule, that the client is entitled to a result whichis as good or better as promised by the original contractor.)andM;* &quot;Except&quot; since an heir may decide not to export a feature exported by aparent if it does not make sense for its own clients.andP;  (The reverse,exporting a previously hidden feature, is also possible.)andM;This combination yields a highly flexible classification mechanism.andP;  (It alsomakes static type checking less trivial than it might appear at first.)andM;Inheritance in Eiffel is multiple: a class may have any number of parents.andO;This is necessary whenever a simple tree-structured hierarchy would notprovide a satisfactory classification.andP;  Many library classes use thispossibility.andP;  For example, class POPUP_MENU in the Graphics Library inheritsboth from MENU and from POPUP (describing &quot;pop-up&quot; objects).andM;Multiple inheritance is also commonly used to combine a parent describing anabstract behavior (a deferred class, see below) and one providing theimplementation.andP;  For example, LINKED_QUEUE inherits from QUEUE andLINKED_LIST.andM;A corollary of multiple inheritance is repeated inheritance, whereby a classinherits from another, directly or indirectly, more than once.andP;  A precisepolicy based on the language's renaming mechanism allows the descendant toselect, for each repeatedly inherited feature, whether it should be just onefeature (sharing) or one per inheritance path (duplication).andP;  This isparticularly useful for obtaining several variants of a common notion, aswith an iterator on trees which achieves several traversal policies (see thesidebar entitled &quot;Classifying Data Structures.&quot;)andM;Only two relations may exist between classes: inheritance and the clientrelationship.andP;  In particular, there is no sharing of information throughglobal variables or equivalent mechanisms.andP;  This is fundamental to achievethe decentralized nature of component-based software development.andM;Deferred ClassesandM;A deferred class provides only a partial implementation of an abstract datatype, or no implementation at all.andP;  (Deferred classes are close to the Simulanotion of class with virtual procedures, and to the Smalltalk notion ofabstract class.)andM;A deferred class will have one or more deferred routines, which have noimplementation (the keyword deferred is used in lieu of a do clause).andO;Behavior may still be specified, however, through assertions.andP;  Actualimplementations in descendants are bound by these assertions (through therules given above for routine redefinition).andP;  An example is class QUEUE, fromthe Data Structure Library, whose &quot;flat&quot; form (with inheritance expanded) isshown in the figure below.andM;QUEUE is almost entirely deferred (implementation-independent).andP;  Classeswhich are only partially deferred are also extremely useful.andP;  They describe aset of components with common properties.andP;  This ability to freeze someelements of behavior, while leaving others open, is essential to softwarereuse where (in contrast, perhaps, with what happens in hardware) reusablecomponents with an entirely fixed behavior are of little practical scope.andO;The ability to reuse must be combined with the ability to extend and adapt.andM;As an example, the Graphics Library includes a class FIGURE, which is fullydeferred.andP;  Its heir CLOSED_FIGURE remains general enough to be also deferred;but it is more specific and includes non-deferred features such asset_fill_style (choose a filling pattern for a closed figure).andM;Polymorphism and Dynamic bindingandM;Inheritance, serving as the basis for the type system, allows an entity(variable) to become attached at run-time, to objects of more than one type.andO;The basic type rule allows assignments or routine calls of the form x: = yr(y)  for a formal argument x if and only if the type of y is a descendant ofthe type of x.andP;  This means that x can become attached to an object of anydescendant type.andP;  An entity such as x is said to be polymorphic.andM;If the type used to declare an entity is called its static type, and the typeof the object associated with it at some run-time instant is called itsdynamic type, the type rule expresses that the dynamic type must be adescendant of the static type.andM;A key property associated with polymorphism is dynamic binding, which ensuresthat if a feature with more than one variant is called on a polymorphicentity (for example in a call of the form x.f where f is redefined in D tohave an implementation different from the default C implementation), then theappropriate variant is selected on the basis of x's dynamic type (that is tosay, the type of the object actually associated with x), not its static type.andM;Static binding (the reverse choice) would abe a grave conceptual mistake: itwould mean that the wrong version of an operation could be applied to anobject, for example the C version of f to an object of type D.andP;  This couldresult in inconsistent objects, since the C version of f is only constrainedto preserve C's invariant, not D's, which may be stronge.andP;  Once you startproducing inconsistent objects, you cannot guarantee any property about yourprograms.andP;  (The only case in which static binding is justified is when ityields the same result as dynamic binding, that is to say, when f is notredefined in D.andP;  But then applying static binding becomes a matter ofoptimization, which should be applied by the compiler, and indeed is in thecurrent Eiffel implementation.)andM;Dynamic binding is important from a client's perspective; it means that anapplication class that manipulates polymorphic entities does not need to testrepeatedly for their dynamic types.andP;  For example, a class that uses a tree tmay include a call of the formandM;i.postorderandM;to perform a postorder traversal of the tree; even though the details of thealgorithm differ for various implementations of trees, the client need notdiscriminate explicitly between them.andP;  Similarly, a call of the formandM;w.displayandM;will automatically select the appropriate display operation for a window w,even though various kinds of windows will be displayed in different ways.andM;Flattened FormsandM;The use of inheritance raises a potential problem for developers who may wantto deliver a class to a user without necessarily delivering the entireinheritance diagram that led to the class.andP;  This is also a documentationproblem: short does not know about inheritance and will not provide usefulinformation about the inherited features of a class.andM;These issues are solved by the notion of class flattening.andP;  The flattenedform of a class is the text of the class with the same features as theoriginal, but with no inheritance clause.andP;  Features inherited directly orindirectly are put in the flattened form at the same level as the featuresdeclared locally.andP;  Of course, the flattening process takes renaming andredefinition into account.andM;From a client's perspective, there is no difference between using a class andusing its flattened form, with the exception of polymorphism and dynamicbinding.andP;  (If C is a descendant of B and b is of type B, then the assignmentb:=c is valid for c of type C, but not if the type of c is a class obtainedby flattening C.)andM;Command flat may be used in conjunction with short to produce a fullinterface documentation of a class, with local and inherited features treatedon an equal footing.andP;  The result is called the &quot;flat-short&quot; version of aclass.andP;  Using Unix-style &quot;piping,&quot; this can be obtained through the command.andM;flat class_name|shortandM;This technique is the one used to produce final library documentation (asdiscussed in the text).andM;TypingandM;Dynamic binding is often confused with dynamic typing.andM;Dynamic typing would mean having to wait until run-time to determine whetheroperations are applicable to their arguments.andP;  In contrast, the Eiffelapproach to typing is static: whenever possible, the applicability of f to xin x.f is determined statically, by examination of the class text in whichsuch a call appears.andP;  Static typing and dynamic binding are equally importantfor the reliability of software systems based on reusable components: theformer means, for every call of the form x.f, a static guarantee that therewill be at least one version of f applicable to x; the former a staticguarantee that, if more than one version is in fact available, the right one(based on the type of the object attached to x) will be used.andM;The presence of a statically-typed language and the use of a type-checkingcompiler are considerable assets in producing correct systems.andP;  (The currentEiffel compiler misses some cases of type mismatches [15].andP;  They are,however, of little practical consequence and work is proceeding to correctthem.)andM;GenericityandM;Typing would be meaningless without the possibility of defining genericclasses.andP;  A generic class is one which has one or more parametersrepresenting types.andP;  This is particularly useful for classes representingcontainer data structures, used to gather objects; most of the classes of theData Structure Library, covering sets, lists, trees and the like, fall intothat category.andM;A class with one generic parameter is declared under the form.andM;class C[T]...andM;and used by clients in declarations of the formandM;x:C[A]andM;where A is some type.andP;  For example, with a generic class LIST [T], you maydeclare entities of types LIST [SIGNAL], LIST [POPUP_MENU], LIST [LIST[POPUP_MENU] etc.andM;Combining inheritance and genericityandM;Of particular interest is the combination of inheritance and genericity.andP;  Oneof its applications is the possibility to define &quot;polymorphic datastructures:&quot; with a declaration of the formandM;a:LINKED_TABLE[C]andM;the type rules allow calls of the form a.put (x) for x not just of type C butof any descendant type of C.andP;  This means that the corresponding lists maycontain objects of different types, subject to the consistency rules of theinheritance-based typing mechanism.andP;  The figure below illustrates thiscombination of inheritance and genericity by showing how a class describing aspecific data structure, say linked tables of points, may be generalized bothhorizontally (to linked tables of objects or other types) and vertically ntomore abstract data structures such as sequential tables, or more specificones such as two-way linked tables.)andM;Another way to combine genericity and inheritance is offered by the mechanismof constrained genericity.andP;  This allows a generic parameter to be restrictedto descendants of a given class.andP;  For example, a VECTOR class needing ageneric parameter on which arithmetic operations are available may bedeclared asandM;VECTOR _T - andgt; NUMERIC]andM;meaning that acceptable actual generic parameters must be descendants of theKernel Library class NUMERIC.andP;  This class, used as ancestor by the classesdescribing standard arithmetic types (INT, FLOAT etc.) has a short formbeginning withandM;deferred class interface NUMERIC exported features infix &quot;+&quot;, infix &quot;-&quot;,infix &quot;*&quot;, infix &quot;/&quot;, prefix &quot;+&quot;, prefix &quot;-&quot; feature specification infix &quot;+&quot;(other: NUMERIC):NUMERIC --Sum of current element and &quot;other&quot; deferred infix&quot;-&quot; (other: NUMERIC):NUMERIC --Difference between current element and &quot;other&quot;deferred ...(etc.)...andM;Any actual parameter corresponding to T must here be a descendant of NUMERIC,meaning that it is equipped with the appropriate operations.andP;  (Because thereis no restriction on multiple inheritance, any class that a programmerdesires to use as actual generic parameter may be made a descendant ofNUMERIC if it was not already one.)andM;This example also illustrates the use of &quot;infix&quot; and &quot;prefix&quot; features, whichwill be called by clients, not through the usual dot notation (as in v.andO;plus(w)), but in operator form (as in v + w).andM;Other AspectsandM;Other important facilities also play a role in building and using qualitylibraries:andM;* Persistence: When a session terminates, not all objects should go away.andO;The environment supports the automatic storage of objects with all theirdependents (including cyclic structures), and their retrieval in latersessions.andM;* Garbage collection: Writing serious object-oriented applications, whichtypically need to manipulate complex dynamic data structures, requires a goodgarbage collector to reclaim space automatically for unused objects.andP;  Thelanguage was designed to make efficient garbage collection possible and thecurrent implementation supports an incremental, tunable garbage collector.andM;* Exception handling: It is essential to offer programmers a way to recoverfrom abnormal cases, or at least to terminate execution gracefully when noother recovery scheme is possible.andP;  One of the contributions of Eiffel is adisciplined exception mechanism, built on the contracting theory, whichprovides for both recovery (resumption) and graceful termination.andP;  Theexceptions handled may be hardware signals or malfunctions, violatedassertions, software bugs, etc.andM;* Tools: Practical usage of the approach requires a number of tools such asautomatic recompilation after a charge, source-level debugging etc.andP;  Thetools of the environment run on top of a modern operating system (such asUnix).andM;* Simplicity: A programming language should be easy to learn and use,enabling client programmers to concentrate on putting library components togood use.andP;  Eiffel's design focuses on a small number of powerful constructs.andO;In particular, it does not try to be &quot;compatible&quot; with older languages whichwould destroy its conceptual integrity and simplicity.andM;* Openness: Refusal of compatibility at the language level by no meansprecludes compatibility with previously written software elements andopenness to other tools.andP;  Both of the latter goals are essential for reuse.andO;As a consequence, Eiffel supports both call-out of utilities written in otherlanguages, and call in (of Eiffel routines from those other languages).andP;  Thismakes it possible to use the languages' structuring capabilities (classes,information hiding, multiple inheritance, genericity) as an encapsulatingmechanism for software whose actual &quot;mealc is written in other languages.andO;For example, a relational database system can be packaged in one or moreclasses.andP;  (We have found that this approach to interfacing with olderlanguages, which keeps each world separate and forces communication to occurthrough well-defined bridges, permits more effective reuse and exchange thanan approach which would, in a single language, mix the object-orientedparadigm with incompatible ideas.)andM;* Cross-development: The implementation supports generation of final code inother programming languages (currently C).andP;  This complements the opennesstechniques described above: one can develop library components on a certainplatform in Eiffel and use them on a different platform in their C form.andM;The StatusandM;of EiffelandM;The Eiffel language was designed by the author and his group at InteractiveSoftware Engineering.andP;  The basic language specification can be found in&quot;Eiffel: The Language&quot; (reference [17]).andM;The language specification is in the public domain and anyone is welcome towrite Eiffel compilers, interpreters, tools or specialized libraries, whichwill of course remain the property of their developers.andM;To ensure wide support and accessibility, the original designers and a numberof users have started the International Eiffel Consortium.andP;  Operational onAugust 31, 1990, the consortium will take full control over the evolution ofthe language, free from proprietary concerns.andP;  Fundamental elements of theBasic Libraries' specification, as described in this article, will also betransferred to the consortium.andP;  In addition, Interactive Software Engineeringwill relinquish the Eiffel trademark to the consortium.andM;Classifying Data StructuresandM;Data Structures are classified according to three criteria: access method,traversal and storage.andM;Access MethodandM;An essential property of &quot;container&quot; data structures is the way elements areaccessed.andP;  The following classification captures some of the most importantvariants.andP;  (The figure below illustrates the top of the hierarchy.)andM;The only two operations on &quot;containers&quot; are has, the membership test; andfill, which fills a certain structure with the elements of another.andO;Procedure fill is variusly redefined at different levels of the hierarchy andprovides a universal conversion mechanism.andM;Containers may be &quot;collections&quot; or &quot;tables.&quot;andM;In a table, every element is stored with and retrievable through a certainkey.andP;  This covers hash tables and &quot;indexable&quot; structures such as arrays.andP;  Thedeclaration of HASH_TABLE begins withandM;deferred class HASH_TABLE[T, KEY -[IS GREATER THAN] HASHABLE]andM;using constrained genericity (see the sidebar entitled &quot;Major EiffelTechniques&quot;) to express that the type of the key must be a descendant ofclass HASHABLE, which has a function hash delivering a hash value.andP;  Anexample of such a descendant is class STRING.andM;In a collection, elements are retrieved through some criterion other than akey.andP;  In a &quot;set,&quot; the only significant property regarding an element iswhether or not it appears in the collection.andP;  For a &quot;bag,&quot; in contrast, thenumber of times an element appears is significant.andP;  Most of our bags areactive data structures which have a notion of current position or cursor;most operations are then relative to the cursor position.andM;Examples of active data structures include &quot;dispensers,&quot; where the client hasno control over the cursor: insertions and retrievals occur at positionsdetermined by the structure's properties.andP;  Typical examples are stacks(last-in, first-out) and queues (first-in, first-out).andM;Other data structures such as lists are &quot;cursor data structures,&quot; where theclient has explicit control over the cursor (see the figure entitled &quot;ActiveData Structure with Cursor.&quot;).andP;  For example, operations on a chain (a generalnotion including non-circular lists as a special case) includeandM;position Current cursor position (integer) forth Move cursor ahead oneposition item Element at cursor position before Is cursor at the left of thefirst element, if any? after Is cursor at the right of the first element, ifany? count Number of elements in listandM;As the specification for before and after indicates, the cursor is allowed togo one position off the right or left edge.andP;  Such properties are captured asinvariant clauses such asandM;0 [is less than]= position [is less than]= count +1; not (before and after);andM;More generally, invariants and other assertions are the principal guide formaking sure that the conventions (regarding default initial states,borderline cases, compatibility between the various features) are sound,consistent and easy to teach.andM;The notion of cursor as it exists for chains is generalized in CURSOR_TREE totwo-dimensional cursors.andP;  Here the features also include the Boolean queriesabove and below (to test whether the cursor has been taken higher than theroot or below a leaf), the procedures up (to parent) and down (i)(to i-thchild), etc.andP;  Again, assertions play a key role in getting the conventionsright.andM;TraversalandM;Many data structures are traversable.andP;  The Data Structure Library includes aset of &quot;iterator&quot; classes which define traversal mechanisms, allowingprogrammers to avoid writing loops; instead, they define the actions to beapplied to every element.andP;  The top of the &quot;traversable&quot; hierarchy is shown inthe figure below.andM;As an interesting use of &quot;repeated inheritance&quot; (inheriting twice or morefrom the same parent), tree iterators (inorder, preorder, postorder) areobtained by inheriting repeatedly from the same basic iterator, with adifferent redefinition of the basic stepping procedure in each case.andM;StorageandM;The top of the &quot;storage&quot; hierarchy is shown in the figure below.andP;  A &quot;box&quot; isfinite or infinite (infinite structures cannot be fully constructed, ofcourse, but may be approximated using &quot;lazy&quot; techniques, and are also usefulto describe predefined concepts such as the set of integers); a finite boxmay be &quot;bounded&quot; or &quot;unbounded.&quot;andP;  A bounded structure may be fixed orresizable.andP;  The tendency in the library is to avoid fixed structures as muchas possible; built-in size limits are a plague of traditional programmingmethods.andP;  In the libraries, even arrays are resizable.andP;  (More precisely, theput operation requires an index within the current bounds, as specified by aprecondition; but the force operation will accept any index, and will resizethe array if needed.)andM;TABLE IV: Some Standard Feature Names.andM;item  Basic access operation.andP;  count  Number of significant items in thestructure.andP;  has  Basic membership test: does a given item appear in thestructure? put  Basic operation to insert or replace an item.andP;  force  Likeput, but will always succeed when in can.andP;  For example, if may resize thestructure if full.andP;  remove  Basic operation for removing an item.andP;  wipe_out Basic operation for removing all items.andP;  empty  Test for absence of anysignificant items.andP;  Should return the same value as count = C. full  Test forlack of space for more items.andM;GraphicalandM;ConventionsandM;The class diagrams in this article use some simple elements of a formalismunder development by Jean-Marc Nerson and the author for graphicalrepresentations of object-oriented system analysis and design.andP;  Classes arerepresented by elliptic bubbles; an asterisk indicates a deferred class;single arrows indicate inheritance; double arrows indicate the clientrelation.andP;  The full formalism also includes conventions (not used here) forrepresenting the class's features, its preconditions, post-conditions andinvarient.andO;</TEXT></DOC>