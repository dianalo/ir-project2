<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-203-116  </DOCNO><DOCID>08 203 116.andM;</DOCID><JOURNAL>PC Week  March 5 1990 v7 n9 p77(2)* Full Text COPYRIGHT Ziff-Davis Publishing Co. 1990.andM;</JOURNAL><TITLE>Choices abound in expert-system shells. (choosingartificial-intelligence development tools)</TITLE><AUTHOR>Van Name, Mark L.; Catchings, Bill.andM;</AUTHOR><SUMMARY>Expert systems can automate many decision-support tasks,simplifying such complex procedures as insurance-claim payments,quality control in manufacturing, and medical diagnosis.andP;  Anexpert system consists of a 'shell' and a knowledge base withassertions and rules about a particular topic, or 'domain.' Theknowledge base may be structured with 'discrete' rules stored assets of 'if-then' statements, or in 'frames' that contain sets ofdata attributes and related rules.andP;  Rule-oriented systems are slowbecause the shell must scan the knowledge base for every query.andO;Frames can represent real-world knowledge in context and in anatural hierarchy.andP;  Common strategies for shell structure includebackward chaining, which starts with an answer and tries rulesuntil it reaches the input assertion, while forward chainingfollows the opposite procedure.andP;  Expert-system shell buyers shouldconsider whether the methodology used is appropriate to theapplication, how much programmers can customize the shell, andease of maintenance when making a purchasing decision.andP;  A goodshell should produce a clear display or printout of the rules itfollowed in making its decision and should support easymodification of the knowledge base.andM;</SUMMARY><DESCRIPT>Topic:     Expert SystemsArtificial IntelligenceDecision Support SystemsSystem SelectionTutorial.andM;</DESCRIPT><TEXT>By Mark L. Van NameandM;and Bill CatchingsandM;Perhaps one of the most natural applications of expert-system technology isin decision support.andP;  An expert system can automate many of the decisionsinherent in complex tasks such as medical diagnoses, insurance-claim paymentsand quality control in manufacturing.andM;In choosing an expert-system shell, buyers must balance the programmingexpertise that different shells require against the available staff (seetable, Page 79).andM;An expert-system shell is basically an expert system awaiting a knowledgebase -- a body of information about the topic, or domain.andP;  Knowledge basestypically contain two basic kinds of information: assertions and rules.andM;In essence, an assertion is a fact about the domain.andP;  Most expert systemsrepresent assertions as text strings.andP;  Some assertions are permanent parts ofthe knowledge base, such as &quot;The normal body temperature is 98.6 degreesFahrenheit.&quot; Users can enter others, such as &quot;The machine that winds thefiber-optic cable is making a loud screeching noise,&quot; as they use the expertsystem to make a decision.andM;Rules are typically &quot;If .andP;  .  .  then&quot; statements that guide the expertsystem in the decision-making process.andP;  Many rules contain a single &quot;If&quot;clause, but can also have many clauses.andM;These rules are not, however, the same as the If .andP;  .  .  then statements oftraditional programming languages.andP;  Standard If .andP;  .  .  then statementsappear at fixed points in a program's flow, and they must list all theconditions that the programmer wishes to check at those precise points.andM;In contrast, users can enter expert-system shell If .andP;  .  .  then rules inany order, and those rules can contain either one or a few conditions.andP;  It isup to the shell to figure out when to use the rules and in what order to usethem.andM;Structuring the Knowledge BaseandM;There are many different ways to store or structure information in anexpert-system knowledge base, but most use one or both of two commonapproaches.andM;The more common method is to store rules and assertions much as users enterthem, as sets of If .andP;  .  .  then rules.andM;This sort of discrete-rule structure works best in applications that havemany assertions and rules that may appear almost unrelated.andM;Despite their popularity, however, rule-oriented structures have severalshortcomings.andP;  A major drawback is the search time required: The shell mustscan the knowledge base looking for candidate rules to try.andP;  As the number ofrules and input assertions grows, the search time can quickly get out ofhand.andM;The other major method is to store knowledge in frames.andP;  In contrast with theindividual statements of rules and assertions, frames are basicallystructures that contain a set of data attributes, or slots, and usually somerules related to those slots.andM;Each of these slots can contain a piece of information (or a rule) aboutwhatever the frame describes, so a single frame can hold a great deal ofinformation.andP;  Frames are very similar in structure to the objects ofobject-oriented programming.andP;  Frames typically fall into classes, or groups,and a frame can inherit traits from their classes.andM;Structural IssuesandM;The biggest advantage of frames is that they can represent knowledge aboutreal-world things simply and easily.andP;  Their inheritance abilities also makeframes the best choice for applications in which the domain knowledge isnaturally hierarchical or depends heavily on context, such as simulation ornatural-language translation.andM;On the downside, however, expert-system shells that use frames generallyrequire more powerful inference engines than those that use discrete rules toorganize their information.andM;This is perhaps the main reason that most PC expert-system shells structuretheir knowledge as rules.andM;Whether an expert-system shell uses rules or frames, buyers should make surethe shell offers good tools for maintaining the knowledge base.andP;  Crucialfeatures include the ability to comment on rules or frames, and the abilityto examine and edit all or part of the knowledge base at any time.andM;Expert-system shells combine a knowledge base with a set of user-enteredinput assertions (the problem description) to try to find a solution (thegoal).andP;  The part of the shell that handles this task is known as theinference engine.andP;  While every expert-system shell's inference engine usesdifferent problem-solving algorithms, most shells employ one or both of twobasic methods.andM;The more common strategy is known as backward chaining.andP;  In general, abackward-chaining shell starts with an answer and tries to work backward toreach the input assertions.andP;  It chooses rules to try (or &quot;fire,&quot; inexpert-system parlance) based on their conclusions, starting first with onegoal and firing all the rules that have that goal as their conclusion.andP;  Theshell repeats this process until either the starting goal leads to the inputassertions or until it cannot find any more rules to fire, in which case itmoves on to the next possible goal.andM;Forward chaining is, as its name implies, the procedural opposite of backwardchaining.andP;  A forward-chaining shell starts with the input assertions andfires every rule that those assertions can possibly trigger.andP;  The shell thenchecks to see if any of those rules led to a goal.andP;  If not, it repeats theprocess, this time firing every rule that the results of the previous triesmade possible.andP;  The shell keeps up this iterative process until it reaches agoal.andM;Inference-Engine IssuesandM;Forward chaining is best for those applications in which the user knowsinitially everything that the shell will need to make a decision and those inwhich input assertions typically outnumber the possible answers.andO;Applications that commonly produce Yes/No answers, such as insurance-claimsystems, are good candidates for forward chaining.andM;Backward chaining is best for applications in which the user can supply agood starting guess.andP;  In addition, it is often better than forward chainingfor applications in which there are many possible answers and fewer inputassertions.andM;The more powerful expert-system shells often offer both types ofinference-engine search strategies.andM;A final and crucial issue regarding any inference engine is speed.andO;Unfortunately, a shell's speed can be extremely difficult to gauge.andP;  Thereare no established benchmarks, because the performance of a shell oftendepends heavily on how closely an application matches the shell's strengths.andM;One performance aid that buyers can consider is the ability to tune the waythe shell searches its rules: Can developers prioritize rules, or does theshell search the rules in a predefined order?andP;  Finer control over the shell'ssearch strategies offers the promise of better performance -- but only fordevelopers who are willing to take the time to study and experiment with thetuning options.andM;Determining a Shell's PersonalityandM;A powerful inference engine and good knowledge-representation facilities areonly part of the story.andP;  Equally important is the set of tools that the shellprovides developers.andM;The most obvious tool is the development interface itself.andP;  Mostexpert-system shells are highly interactive, largely non-procedural programsthat let users define the knowledge base and, in some cases, the inferencestrategies for their applications.andP;  Some shells also provide procedurallanguages.andM;Every shell has a distinctive development method that it encourages.andP;  As withmost products, potential buyers should try to get some hands-on time witheach shell to see if its preferred development method matches their needs.andM;One issue here is ease of use.andP;  If users define rules and otherwise controlthe shell with commands, buyers should examine whether the command languageis reasonably intuitive and consistent.andP;  If the shell is menu-driven, thequestion to ask is whether the menu options are clear and easy to find.andM;Another important consideration is the degree to which developers cancustomize the expert systems they build.andP;  Buyers should decide whether theywant users to be aware that they are in the shell, or whether they prefer thedevelopment team to produce turnkey applications.andM;Buyers must also address how developers must deliver their applications.andO;Expert-system shells typically either generate code for a stand-alone expertsystem or require that users own a run-time version to execute the finalsystem.andP;  Buyers should note whether a run-time version is necessary and, ifso, what it costs.andM;Maintenance FacilitiesandM;Another concern that is easy to overlook initially is maintenance.andP;  As withmost software, the first version of an expert system is usually much more abeginning than an end.andM;Developers will need to refine the system over time, and a shell can providetools to simplify that task.andM;One important tool for both maintenance and regular use is an explanationfacility, which provides a way for users and developers alike to discover howthe shell reached its decision.andP;  Sometimes, as in insurance-claimadjudication, such an explanation can be a vital part of the application ormight even be required by law.andM;The shell should be able to produce a clear, readable display or printedexplanation of the rules that it followed in making its decision.andP;  Ideally,the shell should also be able to show its progress at any point in thedecision process, so that developers can see how it is doing and spot areasthat they should improve.andM;Another key area is the shell's support for maintaining the knowledge base.andO;Central maintenance issues to consider include whether the developers readthe knowledge base a rule or a frame at a time, and whether the shellproduces an overall -- ideally, graphical -- display.andP;  Buyers should alsodetermine whether a shell can spot and flag redundant and inconsistent rules,or if developers must handle those tasks.andM;A final major topic that buyers must consider is the shell's ability to workwith the external world of the target application: target machines, externaldata and other programs.andM;At first, the issue of target machines might seem almost trivial.andP;  But makingsure the shell runs on the target system -- say, an MS-DOS PC -- can provemore complicated than it seems.andP;  Developers might want to work on a morepowerful system -- perhaps a mainframe or a workstation -- and then port theresulting application to a PC.andP;  Thus, the buyer must determine whether theshell runs in both worlds, as must the resulting expert systems.andM;A similar issue is access to external data.andP;  If the target expert-systemapplication is to work with any of that data, the shell's ability to dealwith other data formats is crucial.andM;On PCs, this usually means support for at least the Ashton-Tate dBASE andLotus Development Corp.andP;  Lotus 1-2-3 file formats.andP;  Buyers should also decidewhether they need only read existing data, or read and write it.andP;  If datavital to the expert system is in the format of another database system, thenthe shell must either be able to work with that database system or allowdevelopers to add programs that can.andM;The ability to write programs that communicate with the shell is the lastexternal-world concern.andP;  Some expert-system applications, such as processmonitoring, can require the shell to communicate with physical devices, whileothers may demand only that an enveloping menu system be able to call theshell.andO;</TEXT></DOC>