<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-316-790  </DOCNO><DOCID>08 316 790.andM;</DOCID><JOURNAL>Computing Canada  March 15 1990 v16 n6 p32(1)* Full Text COPYRIGHT Plesman Publications Ltd. (Canada) 1990.andM;</JOURNAL><TITLE>Adapting to a changing environment. (bridging gaps as key toapplications product development) (column)</TITLE><AUTHOR>Venema, Ted.andM;</AUTHOR><SUMMARY>Application software and data system software are becomingcritical components of the strategic planning of informationsystems professionals.andP;  The development of database software ismore readily accomplished than the development of applicationssoftware because the latter is utilized by specialized programmersrather than the general users who require a program thatinterfaces an IBM operating system.andP;  The trend for the 1990s willbe toward radical change in the application development field,enhancing its ability to develop packages of software to addressindividual organizational requirements.andP;  This change will becharacterized by extensive utilization of program generators, theexpansion of fourth generation language, the appearance ofpackaged software geared to the needs of specific systemenvironments and applications packages designed to allow change bythe user.andM;</SUMMARY><DESCRIPT>Topic:     Applications ProgrammingSoftware PackagesCustom SoftwareStrategic PlanningProgram Development ToolsData Base Management Systems.andM;</DESCRIPT><TEXT>The area of application product development has been receiving more and moreattention as the needs of organizations continue to grow.andP;  The necessity forgood application software, either custom developed or pre-packaged, hasbecome critical to the day-to-day operations of large companies.andO;Unfortunately, there is no clear definition of what constitutes goodapplication software.andM;Why is this?andP;  Why is it so difficult for software manufacturers and softwareusers to agree on standards for good application software?andP;  Is softwareportability the key?andM;Ten years ago, there were no manufacturers of software at all -- everythingwas done on-site by `in-house' programmers interacting directly with theoperating systems of the installed computer system.andP;  Since these machineswere usually stamped IBM, the IBM operating systems became the developmentenvironment for the bulk of all programs by default.andM;Although much criticism has been directed at IBM for its operating systems,including peripheral-handling software such as CICS, it is necessary toremember that it functioned adequately in its time.andP;  With the operatingsystem in place, the first application systems could be written.andM;At this point, other software manufacturers began to develop and sellsoftware in both packaged application and data system or database areas.andP;  Thedevelopment in data systems software led to an entirely new environment withits own terminology: database compression, data dictionaries, hierarchical,network and relational data models, transaction logic, and restart/recovery.andO;Each of these terms heralded a new and important development in the scienceof computer usage.andM;The parallel development in application package software also led to a newenvironment with its own terminology.andP;  Application systems that `promised theworld' proved inflexible, forcing the user to adapt the system -- rather thanthe other way around.andM;These rudimentary applications, by accessing the operating system directly,required as much support as in-house developed applications.andM;Why was the development of data system software so much more successful thanthe development of application software?andP;  A close examination will revealthat the complexity of tasks in each area was quite different.andP;  To writesoftware to bridge the gap between an IBM operating system and the averageinexperienced computer user is an immense task in comparison to constructinga database package.andM;This is not to underestimate the effort required to write database software,but database software is intended to be used by specialized programmers andnot the average user.andP;  Essentially, database developers took a smallerproblem and did an excellent job solving it while the application packagedevelopers took on a larger task then they could handle.andM;Attempting changeandM;The early 1980s saw application package developers attempting twochanges:packaging databases and increasing software flexibility through tables andparameterization.andP;  In the meantime, system developers also took another stepand fourth generation languages (4GLs) were born.andM;Previously, the use of the database in application packages was made possiblethrough application bridges to the database.andP;  This approach proved ratherunsuccessful because application packages not written with the database inmind cannot be easily connected to the database concept.andM;Using a database with an incompatibly-designed application package can easilyresult in poorer use of resources than if the package were run directly onthe operating system.andM;A second noticeable weakness was that application software bridged manydifferent databases.andP;  This means the application software had to function inany database environment, including the simplest.andP;  Thus, application packagesoften re-invented mechanisms already available in a database environment.andM;Ironically, bridging application software to a database will often result inthe poorest overall performance when combined with a database that is highlyrated.andP;  This is because many of the most useful and powerful features thatgive a database its high rating are not used by the application.andM;The second major area of change in application package development was theintroduction of more tables and parameterizations into application software.andO;This did have a positive effect on the application user.andP;  Although still farfrom perfect, the degree to which the user was forced to adapt to a packagewas lessened.andM;The parallel development of fourth generation languages was proceeding muchbetter in comparison, although it also ran into the same problem as itsapplication counterpart -- the end-user.andM;Fourth generation languages were touted as the solution to end-user access ofcomputer data.andP;  Unfortunately, most end-users are unable to use any 4GL.andP;  But4GLs have found a home as a development tool and some have fared better thanothers.andM;This brings us up-to-date in our look at application package developmenthistory.andP;  A number of concerns still remain outstanding in the eyes of mostpackage users:andM;* product integration,andM;* flexibility,andM;* user access and,andM;* application integration.andM;Good application software suits an organization's specific needs; takesadvantage of modern database and fourth generation language technology; isintegrated in all respects; and, totally supports novice users allowing themto access data in as many ways as possible.andM;As we enter the '90s, will we see any bridging between our ability to producepackage software and organizational needs?andP;  The answer is yes, provided weaccept some radical changes in our approach to application development.andO;These changes include:andM;* Extensive use of program generators to break the bind of having flexibilityand efficiency in the same program.andM;* The use of a 4GL as a destination language for program generators.andM;* The use of the generator product as a maintenance tool.andM;* Packaged software should be designed and optimized for use in a specificsystems environment.andP;  The design must be integrate with in-house developedsystems.andM;* Application packages must be designed to allow change by the userorganization, which means selling design as well as code.andM;In order to achieve this, both applications and application packages willhave to become more design- and less implementation-oriented.andP;  Databasegenerators will have to be sold with packages to allow integration ofin-house and package development.andM;Applications must capitalize on, and not fight, current systems technology.andO;</TEXT></DOC>