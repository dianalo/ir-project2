<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF107-805-368  </DOCNO><DOCID>07 805 368.andM;</DOCID><JOURNAL>PC Magazine  Nov 28 1989 v8 n20 p327(7)* Full Text COPYRIGHT Ziff-Davis Publishing Co. 1989.andM;</JOURNAL><TITLE>Beyond the consistent user interface of the Presentation Manager.andO;(Environments)</TITLE><AUTHOR>Petzold, Charles.andO;AttFile:   PCMAG\V08N20\POPMENU.C;0 Program:  POPMENU.C  C source code.andO;PCMAG\V08N20\POPMENU.DEF;0 Program:  POPMENU.DEF  Definition file.andO;PCMAG\V08N20\POPMENU.EXE;2 Program:  POPMENU.EXE  Provides pop-up menus.andO;PCMAG\V08N20\POPMENU.H;0 Program:  POPMENU.H  Header file.andO;PCMAG\V08N20\POPMENU.MAK;0 Program:  POPMENU.MAK  Make file.andO;PCMAG\V08N20\POPMENU.RC;0 Program:  POPMENU.RC  Resource script.andM;</AUTHOR><SUMMARY>Methods of changing and extending the OS/2 Presentation Manageruser interface are discussed.andP;  Consistency is important, but someusers fear that a consistent user interface will make applicationsbland or see no need for consistency.andP;  Extending the userinterface increases the power of Presentation Managerapplications.andP;  A discussion of how a new application underdevelopment extends the PM user interface is presented.andP;  Theprogram employs pop-up menus, which are often more convenient thanpull-down menus.andP;  POPMENU is a simple program that demonstratesthese menus; it includes a resource script file with templates forall program menus and a dialog box.andP;  POPMENU.C is the source code,with special functions that create windows, menus, and submenus.andO;It uses some object-oriented techniques, including the creation of'parent' and 'child' windows.andM;</SUMMARY><DESCRIPT>Topic:     Systems ProgrammingProgram Development TechniquesType-In ProgramsTutorialUser InterfaceOS-2.andO;Feature:   illustrationprogram.andO;Caption:   POPMENU: complete listing. (program)POPMENU.C (program)POPMENU.RC. (program)andM;</DESCRIPT><TEXT>Beyond the Consistent User Interface of the Presentation Manager Theconsistent user interface it provides is a major selling point for agraphical environment such as the OS/2 Presentation Manager.andP;  Code to handlethe most common items in the user interface (menus, dialog boxes, text entryfields, scroll bars) is built right into the environment, making it availableto every application.andP;  Thus, even a relatively small PM program can come withall the trappings of a sophisticated user interface.andM;The consistent user interface is a great advantage for users, as well.andP;  Themenu system incorporated into most Presentation Manager programs provides agood illustration.andP;  The main menu bar always appears near the top of theprogram's window, right under the title bar.andP;  Submenus are often invoked byselecting items on the main menu bar.andP;  The use of the keyboard and mouse tochoose items on the menu is entirely consistent among applications.andM;There are even published guidelines for structing the user interface, soprogrammers can deliberately follow conventions established by existingapplications.andP;  For example, programs that work with documents must have amenu option to open an existing documents file.andP;  The conventions establishthat the first item on the main menu bar should be &quot;File.&quot;andP;  Selecting thisitem invokes a submenu that includes the item &quot;Open.&quot;andP;  Users can select thisoption using the mouse or with three keystrokes: Alt, F, and O.andP;  That makesit easy for users to move from one PM program to another.andM;DO WE WANT THIS?andM;The whole idea of a consistent user interface scares some people.andP;  How can webe sure that the user interface chosen by the developers of the system is thebest possible interface?andM;Well, we can't of course.andP;  Such judgment are subjective, and if the bestpossible interface were obvious to everyone, we wouldn't have thousands ofdifferent user interfaces under DOS.andP;  What all these inconsistent interfacesreally show, however, is that PC users seem able to get accustomed to almostanything.andP;  People often identify the best user interface with the one used bytheir favorite application.andP;  This is not because they originally chose theapplication for that style of user interface, but rather because theinterface grew on them.andM;We are entering an era in which the same look and feel will be found in threemajor environments, under three major operating systems: Microsoft Windowsunder DOS, the Presentation Manager under OS/2, and OSF/Motif under Unix.andO;Users will be able to move among these three environments without problems.andM;The PM user interface is also part of the CUA (Common User Access) componentof IBM's SAA (Systems Application Architecture).andP;  This means that when IBM'sminicomputer and mainframe applications begin moving to graphical interface,they too will look and feel like the OS/2 Presentation Manager, Windows, andOSF/Motif.andP;  IBM has also defined a character-mode user interface in SAA thatworks very similarly to the graphical user interface.andM;Moreover, the general style of this user interface is common on othergraphical environments, such as the Macintosh.andP;  Someone conversant withWindows or PM can sit down at a Mac and begin using it immediately.andP;  Evensome character-mode programs under DOS have been adopting the SAA-styleinterface.andM;The key point here is consistency--even if the user interface of PM wereterrible, it would still be useful, because it would at least be consistentwith everything else.andP;  Further, since the user interface code is built intothe operating system, it's even possible for a later version of the operatingsystem to improve it in some way, and (in effect) automatically improve allexisting programs that use it.andM;Another fear that some people have is that a consistent user interface willlead to a bland uniformity among applications.andP;  In fact, however, this hascertainly not been the case with applications for the Macintosh and Windows.andO;Some of the programs for these environments have been among the mostinteresting and powerful ever developed.andP;  When you get right down to it, theenvironment implements only the most common and mundane aspects of the userinterface.andP;  A program's real look, feel, and functionality encompasses muchmore than menus, dialog boxes, and scroll bars.andM;Finally, some people see no need for a consistent user interfce.andP;  After all,it is common knowledge that in many corporations most PC user work with onlyone or two application programs, such as Lotus 1-2-3 or WordPerfect.andP;  Icontend, however, that the extreme differences among user interfaces in DOSapplications are precisely what prevent people from using other programs andextending the productivity of their PCs.andM;When users can move from one application to another without completelyreorienting their fingers and minds, they will do so--especially when theycan use these applications synergistically.andP;  The Presentation Manager allowseasy switching among applications and permits transferring data between themusing the clipboard or DDE (Dynamic Data Exchange).andM;CREATIVE OPPORTUNITIESandM;Programmers are by no means locked into the PM look and feel.andP;  You might wantto write a Presentation Manager program that embodies your own, unique userinterface.andP;  If you so wish, there's nothing to stop you.andM;The most extreme approach of this kind would be to create a blank window thatoccupies the full screen in the Presentation Manager session.andP;  The programcould draw whatever it wants on that window (including its own menus), and doall its own keyboard and mouse input processing.andP;  Indeed, the program couldeven ignore the mouse entirely and hide the mouse pointer.andM;I must observe, however, that historically this approach has been disastrous.andO;In the early days of the Apple macintosh, some developers attempted to portprograms from other environments without adapting them to the Macintoshinterface.andP;  Mac users almost unanimously rejected these applications.andP;  Ithink this indicates that users want a consistent user interface.andP;  Eventhough you are certainly not locked into the Presentation Manager look andfeel, you ignore it at your own risk.andM;MENU EXTENSIONSandM;Of course, it is also possible to extend the user interface in some way.andP;  Inone sense almost every application does this because it requires some userinput beyond the menu, dialog boxes, and scroll bars.andP;  In a broader sense,however, suppose an application were to offer the user an alternative to thestandard interface?andM;I have an example in mind--a new Presentation Manager application I've beenlooking at recently.andP;  I can't discuss the program itself; it's still indevelopment as I write this column (in August).andP;  But I can discuss how theprogram extends its menu interface.andM;The application in question has a standard menu bar, of course, which worksexactly the same as the menus found in other Presentation Manager programs.andO;However, if you press the right mouse button on one of the client windows inthis program, a pop-up menu appears at the mouse pointer position.andP;  After youchoose an item from that menu, the menu disappears.andP;  Although pop-up menusare found on some graphical user interfaces, they are certainly not part ofthe standard PM interface.andM;The more I used these pop-up menus, the more I liked them.andP;  If I happened tobe doing something in the client window with the mouse, it was a lot easierjust to press the right mouse button for the menu instead of moving the mouseto the normal menu at the top of the window.andP;  Because Presentation Managerapplications rarely make use of the right mouse button anyway, giving thebutton this function makes a lot of sense.andM;The program seemed to be using the built-in Presentation Manager menu logicfor the pop-up menus.andP;  I was intrigued, however, that the application'sprogrammers had found some way to force the menu to appear not at the top ofthe window, but at a location based specifically on the mouse position.andM;Naturally, I couldn't resist attempting to reproduce this amazing feat in oneof my own programs.andP;  The task turned out to be less complex than I hadinitially feared.andP;  In fact, it was remarkably easy, which indicates to me ahigh degree of generality in the PM user interface code.andP;  The pop-up menusthat I developed don't work exactly the same as those in the application I'dbeen examining, but they are fairly close and certainly usable.andM;THE POPMENU PROGRAMandM;Figures 1 through 5 contain all the files needed to create POPMENU, a programthat includes both a conventional Presentation Manager menu and a pop-up menuyou can invoke by pressing the right mouse button from any point within theclient window.andM;As usual, if you have the Microsoft C Compiler 5.1 and the OS/2 ProgrammersToolkit (or Presentation Manager Softset) installed, you can createPOPMENU.EXE by runningandM;MAKE POPMENUandM;You can download all source code and POPMENU.EXE from PC MagNet.andP;  You will,of course, need OS/2 1.1 or later to run POPMENU.EXE.andM;POPMENU doesn't do much of anything except demonstrate the pop-up menu.andP;  Theprogram shows many menu options, but it responds to only one of them--the&quot;About PopMenu&quot; option, which displays a dialog box.andM;The screen shot in Figure 6 shows the program's standard menu.andP;  The threetop-level items (File, Edit, and Options) appear across the menu bar near thetop of the program's window.andP;  As seen in Figure 6, the Options item has beenselected to display a submenu descending from the main menu bar; the Speedoption on that submenu has bee selected to display another submenu to theright of the Speed option.andP;  The Presentation Manager's ability to use nestedsubmenus is an advance beyond what Microsoft Windows offers.andP;  Thisenhancement turns out to be important in implementing the pop-up menu.andM;Figure 7 shows the pop-up menu is use.andP;  When you click the right mouse buttonin the client window, the three top-level items are arranged vertically in asmall window.andP;  The upper-left corner of the window is at the mouse pointerposition.andP;  You can then use the left mouse button to select items.andP;  As inFigure 6, I've selected the Options item, which shows a submenu to its right,and the Speed option, which puts another submenu to its right.andM;Unlike a normal Presentation Manager menu, this pop-up menu has no keyboardinterface.andP;  You use the left mouse button to select items; the right mousebutton only invokes the pop-up menu itself.andP;  When you make a selection, thepop-up menu disappears.andP;  To dismiss the menu without making a selection, youpress the left mouse button when its pointer is outside the pop-up menu'swindows.andP;  The pop-up menu then disappears and the mouse click has no effecton the window below.andM;A TALE OF TWO TEMPLATESandM;Let's take a look at the source code to see how this enhancement of thestandard interface is accomplished.andP;  First, direct your attention toPOPMENU.RC.andP;  This is the resource script file, which contains templates forthe program's normal and pop-up menus and for the dialog box, as well.andM;The template for the normal menu begins with the line.andM;MENU ID_NORMALandM;MENU is a keyword recognized by the resource compiler.andP;  ID_NORMAL identifiesa constant defined in the POPMENU.H header file.andP;  The POPMENU.C program usesthis constant to refer to the menu.andM;The normal menu is standard stuff.andP;  The template is organized with the usualhierarchy of menu items.andP;  All items that invoke submenus are indicated by theSUBMENU keyword.andP;  A SUBMENU statement must be followed by a pair of curlybrackets that contain the items on the submenu.andP;  The MENUITEM keywordindicates an option that can be chosen by the user.andP;  The tildes (~) in thetext strings indicate the letter that is underlined in the menu.andP;  This is thekey-letter for the menu's keyboard interface.andP;  All the items the user canchoose are followed by constant identifiers (these are defined in POPMENU.H)that begin with the prefix IDM (ID for a Menu item).andP;  The PresentationManager uses these ID numbers to identify chosen menu items to the program.andM;The pop-up menu begins with the following line:andM;MENU ID_POPUPandM;Its organization is similar to that of the normal menu.andP;  Note, however, thatit begins with a SUBMENU statement in which the rest of the menu nested.andP;  Ifyou were to use such a template for a program's normal menu, only one optionwould appear on the main menu bar; everything else would be in submenus.andP;  Ihave given this item a blank text string (as we will see, it is not displayedanyway) and the identifier IDM_POPUP.andM;I've also removed all the tildes from the text strings in this template,since there is no keyboard interface on the pop-up menu.andP;  Otherwise,everything is the same as in the normal menu template.andM;MENU OVERHEADandM;Now let's turn to POPMENU.C, the C source code file.andP;  Including the normalmenu in the program's window is easy; it involves only some data and codenear the beginning of the main function.andP;  Specifically, all you need to do isinclude the FCF_MENU identifier with all the other FCF (frame creation flag)identifiers and to specify the menu identifier (ID_NORMAL) as the penultimateparameter to WinCreateStdWindow.andM;Whenever the user chooses an item from the menu, the client window receives aWL_COMMAND message.andP;  You'll notice in ClientWndProc (the window procedure forthe client window), that POPMENU ignores all menu items except IDM_ABOUT, towhich the program responds by displaying a dialog box.andM;The overhead for the pop-up menu begins when the client window is firstcreated and receives a WM_CREATE message.andP;  The program calls WnLoadMenu withID_POPUP as the last parameter, in order to load the menu template from theprogram's resources and turn the template into a menu window.andP;  The functionreturns a handle to the menu window, which is stored in the static variablehwndMenu-Popup.andP;  The menu window now exists, but it is not visible, becauseit has horizontal and vertical dimensions of zero.andM;Just to be on the safe side, since the menu window is not documented as beingcreated with a zero size, the WinSet WindowPos function is called to set thesize to zero explicitly.andP;  (This particular function can accomplish quite afew tasks; it will be used later to set the position of the menu window.)andM;ANATOMY OF A MENUandM;Although we speak of a menu and of a menu window, menus are reallycollections of multiple windows.andP;  In the Presentation Manager, windows arealways rectangular.andP;  One window is required for the horizontal menu bar.andO;This is called the top-level menu.andP;  Each submenu requires its own window.andM;The WinLoadMenu function creates all the window and returns the handle to thetop-level menu window.andP;  In POPMENU, the function creates eight windows: thetop-level menu window and one window for each of the seven submenus.andM;The top-level window is not visible, because it has zero dimensions.andP;  If thistop-level menu window had a nonzero dimension, it would consist of ahorizontal menu bar with only one item in it--the item indicated by the firstSUBMENU statement in the template (which, in this case, happens to be a blankstring).andM;The seven submenus are not visible either.andP;  Submenus are always initiallymade children of a special window known as HWND_OBJECT.andP;  The children ofHWND_OBJECT are known as object windows, and object windows are not visibleon the screen.andP;  to display a submenu, the top-level menu changes the parentof the submenu window from HWND_OBJECT to HWND_DESKTOP, the desktop window.andO;(It can do this by calling WinSetParent.)andP;  This causes the submenu to becomevisible on the screen.andP;  When the top-level menu window wishes to hide thesubmenus again, it changes the parent back to HWND_OBJECT.andP;  This is allhandled internally in the menu logic within the Presentation Manager.andM;The first parameter of the WinLoadMenu function is a window handle.andP;  I usedhwnd, the handle to the client window.andP;  The WinLoadMenu Function assigns thiswindow as both the parent and the owner of the top-level menu window.andP;  Theowner relationship is very important: when a user chooses an item from themenu, the menu window will send a WM_COMMAND message to its owner.andP;  Becausewe want the WM_COMMAND messages to come to the client window, the clientwindow must be the owner of the top-level menu window.andM;You'll notice that the final step concludes WM_CREATE processing in POPMENUby calling WinSetParent to set the parent of the top-level menu window toHWND_DESKTOP.andP;  I do this because ...andP;  well, because I couldn't get theprogram to work right otherwise!andP;  I confess I'm not quite sure why this isnecessary, but it is.andM;INVOKING THE POP-UPandM;The pop-up menu must be invoked when the right mouse button is pressed andreleased.andP;  When the client window receives a WM_BUTTON2UP message, it firstcalls WinQueryPointerPos to obtain the coordinates of the mouse pointerrelative to the lower-left corner of the screen.andP;  These coordinates arestored in a POINTL structure named ptlMouse.andP;  For reasons I'll explainshortly, the y-coordinate must be adjusted by adding a value obtained fromthe WinQuerySys Value function.andM;The program then calls WinSetWindowPos to set the position of the lower-leftcorner of the top-level menu window relative to the lower-left corner of itsparent (the desktop window).andP;  This requires passing the two fields of theptlMouse structure, along with the identifier SWP_MOVE, as parameters to theWinSetWindowPos function.andM;Nothing is yet visible on the screen.andP;  The top-level menu window still has adimension of zero, and that will not change.andP;  We now need to force thetop-level menu window to invoke the first pop-up window--the window, as seenin Figure 7, that contains the three items, File, Edit, and Options.andP;  This isdone by simply sending a message named MM_SELECT-ITEM to the top-level menuwindow with a call to WinSendMsg.andP;  This procedure causes the menu to displaythe first submenu window.andM;This submenu window is positioned by the top-level menu window.andP;  The positionof the submenu is set so that the top of the submenu window touches thebottom of the top-level menu window.andP;  Apparently, however, the top-level menucalculates this position by subtracting the standard height of menu bars fromthe top of the window.andP;  This doesn't work quite right because this top-levelmenu happens to have a zero height.andP;  That's why I first adjust the y field ofthe ptlMouse by adding the standard height of menu bars.andP;  (This informationis available from WinQuerySys Value.)andP;  This adjustment causes the upper-rightcorner of the submenu to be positioned at the mouse pointer.andM;The final step required is to call WinSetCapture on behalf of the menu windowin order to force all mouse input to go to the menu window.andP;  This ensuresthat the menu window will recognize when the left mouse button has beenpressed outside the menu and will dismiss all the submenu windows.andM;And that's it!andP;  A total of eight Presentation Manager function calls (andvery little ancillary code) is all that's required to implement pop-up menus.andM;OBJECT ORIENTED?andM;I got the idea to attempt a pop-up menu after looking at an unreleased PMapplication that did something similar.andP;  This is a large application thatcreates several different types of standard windows.andP;  In some of thesestandard windows, the client window is separated into several rectangularareas by child windows.andP;  Each of these child windows is responsible for adifferent task.andP;  In such windows, the program implements several differentpop-up menus.andP;  The pop-up menu you get depends on the child window in whichthe mouse pointer is positioned when you press the right button.andM;This technique seems to me to exemplify a rather object-oriented approach tomenu design.andP;  Each child window has certain commands associated with it, andthe pop-up menu need contain only those commands.andP;  Each child window isresponsible for displaying data (and sometimes receiving user input) of aspecific sort, so the pop-up menu lists only those commands that theparticular child window understands.andP;  The main menu in these windows listsall the commands that all the windows understand.andM;For a program organized in this way, the pop-up menus make a lot of sense.andO;Perhaps someday they will be explicitly supported in the Presentation Managerand will require only one function call rather than eight.andP;  That would be avery nice enhancement to the PM user interface.andO;</TEXT></DOC>