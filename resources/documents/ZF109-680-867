<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF109-680-867  </DOCNO><DOCID>09 680 867.andM;</DOCID><JOURNAL>IBM Systems Journal  Dec 1990 v29 n4 p526(13)* Full Text COPYRIGHT International Business Machines Corp. 1990.andM;</JOURNAL><TITLE>Exponentiation cryptosystems on the IBM PC. (technical)</TITLE><AUTHOR>Comba, Paul G.andM;</AUTHOR><SUMMARY>Several cryptosystems based on exponentiation have been proposedin recent years.andP;  Some of these are of the public key variety andoffer notable advantages in cryptographic key management, both forsecret communication and for message authentication.andP;  The need forextensive arithmetic calculations with very large integers(hundreds of digits long) is a drawback of these systems.andP;  Thispaper describes a set of experimental programs that were developedto demonstrate that exponentiation cryptosystems can beefficiently implemented on the IBM Personal Computer (PC).andP;  Theprograms are organized into four layers, comprising proceduresfor: multiple precision integer arithmetic, modularexponentiation, prime number generation and testing, andcryptographic key generation.andP;  The major emphasis of the paper ison methods and techniques for improving execution speed.andP;  Theitems discussed include: the use of a specialized squaringprocedure; a recursive splitting method to speed up squaring andmultiplication; the computation of residues by usingmultiplication instead of division; the efficient encoding ofresidue information; and the use of thresholds to select the mosteffective primality testing algorithm for a given size number.andO;Timing results are presented and discussed.andP;  Finally, the paperdiscusses the advantages of a mixed system that combines thesuperior key management capabilities inherent in public keycryptosystems with the much higher bulk-encryption speedobtainable with the Data Encryption Algorithm.andP;  (Reprinted bypermission of the publisher.)andM;</SUMMARY><DESCRIPT>Product:   IBM PC (Microcomputer) (Access control).andO;Topic:     CryptographyExponential TimeBufferingEncryptionAccess Controls.andO;Feature:   illustrationtable.andO;Caption:   Average key generation time. (table)RSA and DEA block encryption time. (table)RSA and DEA byte encryption time. (table)andM;</DESCRIPT><TEXT>The need for data security has grown steadily over the years, parallelinggrowth in the use and interconnectivity of computers.andP;  Users require theprotection of data from unauthorized access and alteration.andP;  System expertshave drawn on the discipline of cryptography to meet the increasing needs fordata security.andP;  In the simplest terms, cryptography is a technique forscrambling and disguising information so as to make it appear meaningless orunintelligible.andP;  The scrambling, or coding, process requires the use of asecret key, which is also needed to recover the original text from thescrambled version.andP;  A system that uses such a technique is referred to as asymmetric cryptosystem.andP;  An example is the Data Encryption Algorithm (DEA)defined in the Data Encryption Standard,' which is widely used in banking andtransaction processing.andM;Public key cryptosystemsandM;A revolution in cryptography took place as a result of the publication in1976 of a paper by Diffie and Hellman' that introduced the concept of apublic key cryptosystem.andP;  The novel feature of the proposed system was thatdifferent keys are used for encrypting and for decrypting.andP;  Thus, forexample, an individual A, who is a potential recipient of encrypted messages,generates a public key as well as a private key, and publishes the public key(e.g., in a directory), whileandM;Copyright 1990 by International Business Machines Corporation.andP;  Copying inprinted form for private use is permitted without payment of royalty providedthat (1) each reproduction is done without alteration and (2) the Journalreference and IBM copyright notice are included on the first page.andP;  The titleand abstract, but no other portions, of this paper may be copied ordistributed royalty free without further permission by computer-based andother information-service systems.andP;  Permission to republish any other portionof this paper must be obtained from the Editor.andP;  keeping the private keysecret.andP;  Another individual B, who wants to communicate secretly with A,encrypts the message with A's public key.andP;  After receiving the message, Adecrypts it with A's private key.andP;  For this system to work it must beimpossible to derive, from a public key, the corresponding private key.andM;Once the concept of a public key cryptosystem was introduced, many differentspecific systems were proposed and studied.andP;  References 3 and 4 describethese systems.andP;  Before addressing the technical aspects of these systems,their relevance to the key management problem is briefly discussed.andM;Key management.andP;  The key management problem arises from the fact that asymmetric cryptosystem, while providing protection to the data that have beenencrypted, still requires that a key be exchanged secretly between any pairof communicating parties.andP;  If one visualizes a large network comprisingthousands of workstations and terminals and possibly millions of messages, itbecomes clear that the safe exchange of keys (and their replacement if theybecome compromised) can be a staggering problem.andM;The solution made possible by a public key cryptosystem consists of atwo-tiered arrangement, where the data to be communicated are encrypted usingDEA (for example), and the DEA keys are encrypted using the public keys.andP;  Thepublic keys can be freely exchanged and posted in directories.andM;An actual key management system may involve more complexities and possiblymore tiers, but it rests on the concepts outlined above, namely separation ofdata-encrypting keys from key-encrypting keys, and exchange of keys via thepublic key system.andM;Outline of some exponentiation cryptosystems.andP;  Several public keycryptosystems have been proposed that involve the following elements:andM;The cryptographic key, or part of it, is either a large prime number n, orthe product n = p x q of two large prime numbers p and q. The encryptionprocess entails raising a number to a power and taking the results modulo n,that is, dividing the results by n and using the remainder of the division.andM;The three systems discussed in this paper are now briefly outlined.andM;RSA system.andP;  The best known exponentiation cryptosystem is the one proposedin 1978 by Rivest, Shamir, and Adleman (see Reference 5) usually referred toby their initials as RSA.andP;  Under RSA, a typical size for the modulus n wouldbe 200 decimal digits, which is equivalent to 664 bits or 42 personalcomputer pc) 16-bit words.andP;  The public or encryption key is made up of twoparts: the number n  but not its factors p and q) and an exponent e. Amessage to be encrypted is represented as a number M, which must be less thann, and the process of encryption is represented by the calculationandM;C=[M.sup.e] mod n.andM;To decrypt, the recipient must be in possession of a suitably chosen secretdecryption key d-, with it the original text can be recovered by executingandM;M=[C.sup.d] mod n.andM;Rabin system.andP;  Another similar system, attributed to Rabin, uses the number 2as the encryption exponent and the knowledge of p and q to do decryption.andO;This system has some drawbacks for general use, but may be appropriate forspecial applications.andM;El Gamal system.andP;  Considerable interest has been generated by a public keysystem described by ElGamal.'andM;This system requires n to be a prime number, rather than the product of twoprimes.andP;  The number n, as well as a properly chosen integer a, are known toall users.andP;  In addition, each individual user has a private key x and apublic key y defined by y = ax mod n.andM;To send a secret message M, one first generates a random number k andcomputes K = [y.sup.k]  mod n; the ciphertext consists then of the pair ofnumbers (C.sub.1, C.sub.2) defined byandM;[C.sub.1] = [Alpha.sup.k] mod n, [C.sub.2] = (K x M) mod n.andM;To decrypt, one computes successivelyandM;K = [c.sup.x.sub.1] mod n,  G = [K.sup.-1.andP;  mod n,andM;M = [c.sub.2] x G) mod n.andM;The challenge of exponentiation on the PC.andP;  Modular exponentiation isessential for encryption/decryption in the systems outlined above.andP;  Inaddition, the generation of cryptographic keys involves the search for largeprime numbers; this search requires certain tests that make heavy use ofmodular exponentiation.andP;  Hence modular exponentiation plays a central role inthe investigations reported here.andM;At the start of the work reported in this paper, it was not known whether theextensive calculation for the exponentiation and prime search procedurescould be programmed to execute on a Pc in a reasonable time.andP;  The challengewas to prove that this could be done.andP;  To meet this challenge, great effortwas made to optimize the code and fine tune the algorithms.andP;  The timingresults, obtained on an 8 MHz Personal Computer AT- (PC AT), are discussedthroughout this paper.andP;  Four major programs that have been implemented arediscussed in the following sections.andP;  Each program is dependent on theprevious ones, as listed in the order given.andM;1.andP;  Multiple precision integer arithmeticandM;2.andP;  Modular exponentiationandM;3.andP;  Prime number searchandM;4.andP;  Cryptographic key generationandM;Multiple precision integer arithmeticandM;The starting point of the project was the implementation of a set ofarithmetic procedures to operate on very large integers, i.e., integers thatcontain several hundred digits.andP;  These procedures may be useful in otherapplications as well as cryptography; hence they have been implemented as aself-contained multiple precision integer arithmetic package (MPIA).andP;  MPIAoperates on integers up to 255 words long, corresponding to 4080 bits orapproximately 1220 decimal digits.andM;To understand the organization Of MPIA, consider that computer words aremanipulated similar to the digits in ordinary long-hand calculations.andP;  Forexample, multiplying a 3-word number by a 4-word number is analogous tomultiplying a 3-digit number by a 4-digit number.andM;MPIA implements the standard arithmetic operations of addition, subtraction,multiplication, and division.andP;  A special case of division is the so-calledmodular division, where the quotient is not explicitly computed and theremainder is the desired result.andP;  There are also some computer-orientedoperations such as movement of numbers and shifting.andP;  Multiplication andsquaring are the operations that deserve the most attention.andP;  They areimportant because they are major components of modular exponentiation, theyare relatively time-consuming, and they lend themselves to considerableoptimization.andP;  Squaring, i.e., multiplying a number by itself, is importantbecause it is usually much more efficient to square a number by using aspecialized squaring procedure than by using a multiplication procedure.andP;  Thereason is that in squaring a number there are many cross-product terms thatneed to be computed only once, whereas a multiplication procedure willcompute them twice.andP;  The first description of a multiple precision squaringprocedure that uses this concept seems to be due to Tuckerman.andP;  Our timingtests consistently show that squaring time can always be reduced to about 60percent of multiplication time.andM;Apart from the cross-product procedure, the optimization techniques that areapplicable to multiplication are essentially the same for squaring.andP;  For thisreason, and since multiplication is the more general operation, thediscussion below centers on multiplication.andM;Two approaches to optimization are discussed.andP;  They are called optimizationin the small and optimization in the large.andP;  Optimization in the smallassumes that each word of one factor must be multiplied by each word of theother factor, and endeavors to devise the most efficient possible datastructure and code to carry out this basic multiplication procedure.andO;Optimization in the large aims at reducing the total number of singleprecision multiplication instructions that have to be executed, by splittingthe factors into smaller pieces, rearranging the pieces in various ways, andfeeding them to the basic multiplication procedure.andP;  These rearrangementsentail additional processing time, or overhead; hence the overall optimum isobtained when the reduction in multiplications just balances the overhead.andO;This gives rise to a threshold, denoted by P, such that only numbers oflength greater than or equal to P should be rearranged.andP;  Anticipating laterresults, in the implementation reported here the threshold turned out to beP= 28.andM;Optimization in the small.andP;  The straightforward way to implement amultiplication procedure for two multiword numbers, or factors, is with adouble loop.andP;  In the outer loop each word of the first factor, or multipher,is successively loaded into a register; in the inner loop the contents ofthat register are successively multiplied by each word of the second factor,or multiplicand, and the results are added to the partial product obtained sofar.andP;  The inner loop for this procedure is illustrated in Example A, whichfollows.andM;Example AandM;PUSH BPandM;XOR BP,BPandM;MMUL30:andM;INC SIandM;INC SIandM;;fetch multiplicand wordandM;MOV AX,[SI]andM;;preloaded multiplier wordandM;MUL  DIandM;ADD  AX, BPandM;ADC  DX,0andM;;add to memoryandM;ADD  [Sl][BX],AXandM;ADC  DX,0andM;MOV  BP,DXandM;LOOP  MMUL30andM;POP  BPandM;The loop takes 20 bytes of code, and the time required for one execution ofthe loop has been measured to be 7.55 microseconds.andP;  An exact allocation oftime to the individual instructions cannot be made, since the execution cycleof one instruction overlaps the fetch cycle of the next; nevertheless,numerous timing experiments lead to the following general conclusions:andM;The MUL (multiply) instruction takes only about one-third of the loop time.andM;* The Loop instruction is very time-consuming.andM;* The three memory accesses  one to fetch a multiplicand word, and two whenadding to memory) are also relatively expensive.andM;These conclusions are the bases for the two restructuring steps that lead tothe optimized basic multiplication procedure.andP;  The first step is to removethe LOOP instruction and the jump associated with it.andP;  This is done byunraveling the loop, that is, repeating the code in-line a number of times.andO;(A macro may be used for this purpose.) If the code in Example A isunraveled, the register CX is freed up and can be used to replace theinstruction ADC DX,0 by ADC DX, CX, further reducing the code length.andP;  Theresults are shown in Example B, where the loop is unraveled.andP;  The code takesonly 16 bytes.andM;Example BandM;PUSH BPandM;XOR BP, BPandM;;set to 0 to shorten ADC instructionsandM;XOR  CX, CXandM;INC  SIandM;INC  SIandM;MOV  AX,[SI]andM;MUL  DIandM;ADD  AX, BPandM;ADC  DX, CXandM;ADD  [SI][BX],AXandM;ADC  DX, CXandM;MOV  BP, DXandM;;(the above code is repeated 30 times)andM;POP BPandM;Referring to the threshold P mentioned above, the number of staticrepetitions of the code must be at least P - 1, since any factor of length Por longer is further broken apart.andP;  If n and m are the lengths of the factorsto be multiplied, the outer loop is executed n times; for each of thesecalculations, the inner unraveled loop must be executed m times.andP;  Hence ajump address must be computed, so that only the last m occurrences of theunraveled loop are executed.andP;  This computation is done only once, outside theouter loop.andP;  Timing of the unraveled loop shows that each execution takes6.03 microseconds.andP;  The second restructuring step is intended to reducememory accesses, and can be visualized as follows.andM;If the m words of the multiplicand are represented by points on the X-axiswith abscissas 1, 2,..., m, and the n words of the multiplier are similarlyrepresented on the Y-axis, then the nm word-by-word products to be computedcorrespond to the lattice points of a rectangle in the first quadrant.andP;  Theprocedure described above represents a process in which the lattice pointsare swept row by row, in a rectangular fashion, as shown in Figure 1.andP;  In thealternative procedure, the lattice points are swept in a diagonal fashion, asshown in Figure 2.andP;  The diagonal procedure entails only two memory accesses,instead of three, for each multiply instruction: one access for each word tobe multiplied.andP;  For each diagonal, the products corresponding to theindividual points can be accumulated in the registers; there is no need toexecute an add-to-memory instruction until the entire diagonal has beenprocessed.andM;The code must now provide for the possibility of a double carry when thetwo-word partial products are accumulated.andP;  In the Pc the second carry may beaccumulated in a half register.andP;  A diagonal of length 4 is illustrated inExample C, where each short segment of code is preceded by a comment thatexplains its function.andM;Example CandM;;Z[3]  carry + X[0]xY[3]andM;MOV  AX,[BX]andM;MUL  WORD PTR[SI + 61andM;ADD  BP,AXandM;ADC  DI,DXandM;ADC  CL,CHandM;;Z[3]  Z[3] + X[I]xY[2]andM;MOV  AX,[BX + 2]andM;MUL  WORD PTR[SI + 4]andM;ADD  BP,AXandM;ADC  DI,DXandM;ADC  CL,CHandM;;Z[3]  Z[31 + X[2]xY[1)andM;MOV  AX,[BX + 41andM;MUL  WORD PTR[SI + 2]andM;ADD  BP,AXandM;ADC  DI,DXandM;ADC  CL,CHandM;;Z[3]  Z[3] + X[3]xY[0]andM;MOV  AX,[BX + 6]andM;MUL  WORD PTR[SI]andM;ADD  BP,AXandM;ADC  DI,DXandM;ADC  CL,CHandM;;store Z[3], shift carryandM;MOV  DX,DIandM;POP  DIandM;INC  DIandM;INC  DIandM;MOV  [DI],BPandM;PUSH  DIandM;MOV  BP,DXandM;MOV  DI,CXandM;XOR  CL,CLandM;A drawback of the diagonal method is that: the lengths of the diagonals vary,first increasing, then remaining constant (if n andless; m), then decreasing.andP;  Therequired control code is then rather complicated and time-consuming.andP;  Theproblem can be avoided by a radical solution: unraveling not only the innerloop, but the outer loop as well.andP;  With this approach, code similar toExample C is repeated in-line, with the length of the diagonal (i.e., thenumber of occurrences of the inner loop) increasing from I to 30, say, andthen decreasing down to 1.andP;  At the end of each of the increasing diagonals,two tests are inserted (in most cases only one is executed) to determinewhether to continue with the next longer diagonal, jump to the next shorterdiagonal, or repeat the same one.andM;As shown in Example C, the code for the inner loop is in most cases 12 byteslong.andP;  With appropriate changes in the offsets, this code will then occurinline 900 times.andP;  Adding the code at the end of each diagonal, this resultsin about 12K bytes of code for the basic multiplication procedure.andP;  Theexecution time for the doubly unraveled loop is estimated to be 5.03microseconds, and the actual multiplication time for two factors of length nwords is represented by the formulaandM;T(n) = 5.03n  2 + 10n + 28.andP;  (1)andM;Optimization in the large.andP;  The procedure explained below is described byKnuth9 as a simplification of one attributed to Karatsuba.andM;For the personal computer, with a word length of 16 bits, we denote by B =[2.sup.16] the number base corresponding to one word.andP;  Assume now that u andv are two n-word numbers to be multiplied.andP;  If n is even let m = n/2, and ifn is odd let m = (n + 1)/2.andP;  Also let X = [B.sup.m].andP;  Then u and v may berepresented as u = [U.sub.0], + [U.sub.1.X] and v = [V.sub.0] + [V.sub.1.X],where [U.sub.o] is the low-order m-word piece of u and [U.sub.1], is thehigh-order piece; likewise for V, and V,.andP;  One can then verify the followingidentity:andM;uv = [U.sub.0.V.sub.0] + [U.sub.0.V.sub.0] + [U.sub.1.V.sub.1]andM;-([U.sub.1], - [U.sub.0])(V.sub.1 - (V.sub.o]))X +andM;[U.sub.1.V.sub.1.X.sup.2]andM;The operations required to compute the right-hand side of Equation 2 can nowbe counted, noting that the apparent multiplications by the powers of X arenot actually executed as such; they just indicate that the respectivecoefficients are stored in a shifted position.andP;  For multiplications, thereare 3 products of m-word factors.andP;  For additions (and subtractions), thereare 2 additions of length m inside the double parentheses; 2 additions oflength 2m inside the single parenthesis; and finally the coefficient of X,which is of length 2m, has to be added into the rest of the result.andP;  Notethat the first and third terms on the right-hand side do not overlap and donot require addition.andP;  The total length of the quantities to be added is thus8m.andP;  Restating these counts in terms of n we reach the following conclusion(which is approximate if n is odd): the Karatsuba method replaces onemultiplication of factors of length n with 3 multiplications of factors oflength n/2, plus 4n single precision additions.andM;For large values of n, the Karatsuba method yields a time reduction of almost3 to 4.andP;  Also, the algorithm can be applied recursively, thus compounding theimprovement with each splitting of the factors.andP;  As the length of the factorsdecreases, the improvement also decreases, until the &quot;no-improvement&quot;threshold P = 28 is reached.andM;Table 1 shows the measured multiplication time t(n) in milliseconds, for twofactors of length n, when the Karatsuba method is applied recursively.andP;  Alsoshown is r(n), which is the ratio of t(n) to T(n); T(n) is the basicmultiplication time computed from EquationandM;1.andP;  The value of r(n) represents the improvement attributable to theKaratsuba method.andM;The Karatsuba method is directly applicable when the factors to be multipliedare of equal size, and this is usually the case in the exponentiationcalculations.andP;  However, if the factor sizes are unequal, two procedures areavailable to reduce the problem to the equal size case.andP;  First, if the sizedifference is small, the smaller number is extended at the high end with nullwords.andP;  Second, if the size difference is large, the product can bevisualized as a rectangle; from this rectangle the largest possible square isremoved and treated as a product of equal factors; from the remainingrectangle the largest possible square is removed, etc.; continuing untileither a rectangle consists only of squares, or a rectangle with a size lessthan P is found; the latter is then fed to the basic multiplicationprocedure; the results of the square multiplications are then added withappropriate shifts.andM;Modular exponentiationandM;The standard procedure for exponentiating a number, i.e., raising it to apower, in general requires many multiplications and squarings.andP;  For example,the computation of M' is normally done by first representing e in binarynotation, as a string of bits; then M is squared as many times as there arebits (excluding the leftmost bit), and the partial results are multiplied byM as many times as there are bits with the value 1.andP;  If the exponentiation isdone mod n, after each squaring or multiplication the remainder mod n iscomputed.andP;  For example, let us assume that the numbers M, e, and n are each640 bits long, which is the same as 40 Pc words; let us also assume thatapproximately half the bits of e have the value 1.andP;  Then the computation of[M.sup.e]  mod n requiresandM;* 639 squarings of 40-word numbers-exactlyandM;* 320 multiplications of two 40-word numbers approximatelyandM;* 959 modular divisions of an 80-word number by a 40-wordnumber-approximatelyandM;In the previous section the optimization of multiplication and squaring wasdiscussed.andP;  Here we discuss two more techniques for speeding up modularexponentiation: a procedure to do the remainder (modulo) calculation usingmultiplication rather than division, and a technique for reducing the numberof multiplications required.andP;  For simplicity of notation, these techniquesare described for the case mentioned in the example above, where M, e, and nare each 40 words long.andP;  Modular calculation by multiplication.andP;  As before,we let B = [2.sup.16].andP;  Since M is a 40-word number, M andless; [B.sup.40].andP;  We nowprecompute the numbersandM;[N.sub.0] = [B.sup.40.mod n]andM;[N.sub.1] = [B.sup.41.mod n]andM;..[N.sub.39] = [B.sup.79.mod n]andM;[B.sup.40] is 1 followed by 40 words of 0s.andP;  Hence [B.sup.40] mod n is theremainder of the division of a 41-word number by a 40-word number; this is afairly rapid operation, often involving only one 1 x 40 multiplication.andP;  Tocompute N,, the previously computed No is shifted left one word, then dividedby n; and so on.andP;  Thus the entire precomputation is quite rapid.andP;  Suppose nowthat we have to compute X mod n, where X is an 80-word number with words ...,andO;[X.sub.1] [X.sub.0].andP;  We do this by computing the numberandM;[X.sub.40.N.sub.0] + [X.sub.41.N.sub.1] + .andP;  .  .  + [X.sub.79.N.sub.39], (3)andM;and adding to it the low-order half of X, consisting of X39,..., [X.sub.1],[X.sub.0].andP;  The resulting 41- or 42-word number is divided by n to obtain theremainder.andM;The procedure described can be further improved by doing the multiplicationsindicated in Equation 3 in parallel.andP;  This means that in the inner loop ofthe code, the word [X.sub.40] is multiplied by the ith word of No and theresult is saved in a pair of registers; then the word [X.sub.41] ismultiplied by the ith word of[N.sub.1] and the result is added into the samepair of registers, etc.andP;  This technique is similar to the one used in thediagonal code for multiplication, previously described, and it requires onlytwo storage accesses per single precision multiplication, rather than thethree required by the conventional approach.andP;  A further speedup can beobtained by unraveling the inner loop.andP;  Reducing the number ofmultiplications.andP;  In computing M, instead of executing one multiplication foreach I bit of e, as explained above, it is possible to take the bits in smallgroups or nibbles, for examples of 5 each.andP;  The following quantities are thenprecomputed:andM;[M.sub.2] = [M.sup.2.mod n]andM;[M.sub.3] = [M.sup.3.mod n]andM;..[M.sub.31] = [M.sup.31.mod n]andM;This precomputation requires 15 squarings, 15 multiplications, and 30 modulardivisions.andP;  In the exponentiation procedure the bits of e are then scanned bynibbles instead of individually, and if a nibble has the value j, the currentpartial result is multiplied by [M.sub.j].andM;A further improvement is obtained by working with floating nibbles, i.e.,andO;those having a 1 in the high order position.andP;  This reduces the precomputationto 4 squarings, 15 multiplications, and 19 modular divisions, and alsoreduces the number of nibbles encountered during the scan.andP;  The net result ofthe optimization is shown in the following reduced operation count:andM;639 squarings of 40-word numbersandM;121 multiplications of two 40-word numbersandM;760 modular divisions done by optimized multiplicationandM;Table 2 shows the actual time for modular exponentiation for selected lengthsof the operands.andP;  The time varies approximately as the power 2.77 of thelength.andP;  A straightforward implementation would yield a power of 3; thereduction is due to the use of the Karatsuba method and the otheroptimization devices.andM;Prime number searchandM;The problems of (a) deciding whether a number is prime, and (b) if not,finding its prime factors, have occupied generations of mathematicians.andO;Recent discussions of these problems and their relevance to public keycryptography, together with ample bibliographies, can be found in Knuth,Dixon, and Riesel.&quot; Riesel's book is the most detailed and contains numerousPascal programs that are functionally similar to some of the proceduresdescribed in this paper.andM;Both the RSA and the Rabin cryptosystems require that the modulus n be theproduct of two prime numbers, which are usually denoted by p and q. In bothsystems the number n is part of the public key, while the factors p and q arekept secret.andP;  The security of both systems rests on the extreme difficulty offactoring a large number containing large prime factors.andP;  To make sure thatthe factorization is difficult, certain subsidiary conditions are imposed onp and q; for example p - I must contain a large prime factor, denoted by pl;and p, - 1 must contain a large prime factor, denoted by p,.andP;  Similarconditions apply to q.andM;In the ElGamal system a single prime number n = p is generated, together witha primitive element a. A secret key x is then chosen by each user, and thecorresponding public key y = [Alpha.sup.x] is computed.andP;  The security of thesystem depends on its being very difficult to infer x from a knowledge of y;this is the so-called discrete logarithm problem which, in the general case,is believed to be of the same order of difficulty as the factorizationproblem.andP;  The same subsidiary conditions apply here; for example n - 1 mustcontain a large prime, etc.andP;  Thus the prime search procedure plays anessential role in all these cryptosystems.andM;The prime search is organized so as to take advantage of the connectionbetween p, pl, and p, (and between q, [q.sub.1], and q, if applicable).andP;  Twomain techniques are used: a sieve procedure to eliminate numbers containingsmall prime factors, and a so-called strong pseudoprime test.andP;  Thesetechniques are explained below.andP;  For concreteness assume, in the RSA case,that the goal is to generate a modulus of length 200 digits, or 42 words, andthat this is achieved by finding primes p and q of length 20 and 22 words,respectively.andM;The sieve procedure.andP;  Because of the relationship between the primes p, pl,and  P21 the search must be done in reverse order.andP;  Thus, from the goal ofproducing p of length 20 words, the program establishes the subgoal ofproducing [p.sub.1] of length four-fifths of 20, or 16 words, then thefurther subgoal of producing p2 of length 13.andM;An odd pseudorandom number B of length 13 is now generated, and a sieve tableS2 and a residue table R2 are initialized.andP;  B is the base for the search, andS2 is a set of flags that indicate the results of applying primality tests toB and its odd successors: B + 2, B + 4 .....andP;  The sieve procedure is carriedout with the aid of the Small Prime Table, which is a fixed table containingall the odd primes 3, 5, 7, ..., 65 521 that fit in one Pc word; the tablehas 6541 entries.andP;  The number B is divided successively by each prime in theSmall Prime Table (or a subset thereon and the remainder is stored in thetable R2; also, using the remainder, those flags in S2 are turned on thatcorrespond to numbers that are divisible by that particular prime; thus theodd successors of B that are found to be nonprime are flagged.andM;The numbers that survive the sieve procedure are considered prime candidatesand are subjected to the strong pseudoprime test (explained below); the firstsurvivor of that test is taken as the prime P2' The search for p, is nowinitiated.andP;  Since p, must be of length 16, a pseudorandom even number A oflength 3 is generated, and the search is carried out among the integers ofthe form 1 + (j + A) x p, where j = 0, 2, 4, .... A new sieve table S1 is nowcreated, but unlike the table S2, it does not have to be computed fromscratch.andP;  Instead, using the values of P2, B, A and the residues saved in R2,the sieve computation for S1 is faster than for S2.andP;  Again, the survivors ofthe sieve are run through the strong pseudoprime test, and the first survivorof that test is taken as p,.andM;The calculation of p from p, is very similar to the calculation of p, fromp2' The calculation of the q s is also analogous.andM;The strong pseudoprime test.andP;  The strong pseudoprime test used in the primesearch procedure is described in References 9 and 10; the details of thealgorithm are not repeated here, except to note that, given a number n = 1 +2  km to be tested, where m is odd, the test requires the computationandM;[X.sup.m.mod n]andM;which is an exponentiation.andM;The strong pseudoprime test is probabilistic, in the following sense: of thetwo possible outcomes of the test, one outcome, &quot;fail&quot; guarantees that n isnot prime; the other outcome, &quot;pass&quot; does not guarantee that n is prime, butindicates that the assertion &quot;n is prime&quot; is very probably true.andP;  For thisreason, a number that passes the test is called a pseudoprime.andM;To increase the confidence that n is indeed prime, the test may be appliedrepeatedly, with different values for x. The test is characterized as strongbecause it is an improvement over several tests that had been used before, inthat it has a lower probability of letting nonprime numbers pass.andM;The use of a probabilistic test is generally considered necessary andadequate, in view of the fact that it would be prohibitively time-consumingto execute a deterministic test that identifies prime numbers withmathematical certainty.andM;As mentioned above, the pseudoprime test is applied, as part of the primesearch, to the numbers that pass the sieve procedure.andP;  The first time thatthe test is applied to a prime candidate, it is convenient to choose x = 3,since this makes the exponentiation calculation faster (by 15 to 20 percent)than with a multiword value for x. For subsequent applications, x should be adifferent pseudorandom number each time.andP;  The number of such subsequentapplications is governed by several parameters whose significance isdiscussed further in the following subsection.andP;  Some refinements andthresholds.andP;  Some of the complexities in the prime number search, asdescribed above, are intended to thwart any attempts at factoring the productp x q, or solving the discrete logarithm problem, by using certain knownalgorithms.andP;  Another algorithm that must be considered is one which iseffective when p + I (or q + 1) consist entirely of small prime factors.andP;  Tosafeguard against this possibility, after p is generated, the number p + I isdivided by the Small Primes and any exact divisor is factored out; if theremaining number is too short (according to some ad hoc threshold), p isrejected and a new p is generated, starting from p,.andP;  In the RSA case,further subsidiary requirements must be met:andM;* The numbers p - 1 and q - 1 must have a small greatest common divisor; thisis almost always the case, but the condition must be tested for, and a new qgenerated if necessary.andM;The ratio [p.over.2] must not be close to the ratio of two small integers.andM;In the ElGamal case, the question of additional conditions on n has been theobject of recent studies; 12 it may well be that new requirements will bediscovered that must be met in order to insure the difficulty of the discretelogarithm problem.andM;From a performance viewpoint, an important threshold is determined by therelative efficiency of the sieve procedure and the pseudoprime test.andP;  Supposefor definiteness that we are testing a number n of length 20 words.andP;  If wedivide n by an entry in the Small Prime Table, say s, the probability offinding that n is nonprime is 1/s, while the cost of the test, determined bytiming the division procedure, is about 102 microseconds; thus, over a largeseries of tests with that particular s, it would take an average of 102smicroseconds to identify one nonprime number.andP;  On the other hand, thepseudoprime test is essentially always effective, but it takes a time equalto 80 percent of the exponentiation time (see Table 2), or 1 376 000microseconds.andP;  Equating the two times and solving for s, we find thatapproximately s = 13 500.andP;  This implies that the optimal policy, when testinga number of length 20, is to use the sieve procedure for primes andless; 13 500,then switch to the pseudoprime test.andM;In the program the situation is a little more complicated, because the testsfor [P.sub.2], [p.sub.1], and p are interlinked; however, many timing trialshave proved that there is indeed an optimum threshold for switching betweenthe sieve procedure and the pseudoprime test, and its value is approximatelythe one calculated above.andP;  These empirical tests are essential, in additionto the theoretical calculations, in order to tune the program for goodperformance.andM;Another set of thresholds regulates the sizes of the flag tables and theresidue tables.andP;  The performance of the program is not very sensitive tothese parameters, since the computations are quite fast.andP;  Hence it isconvenient to make the tables large enough so the probability of overflow issmall.andP;  Nevertheless, the probability cannot be reduced to zero; thereforethe program must make provisions for its occurrence and be able to restartthe corresponding section of the sieve procedure.andP;  The computation of theoverflow probability is interesting in its own right, since it sheds somelight on the performance of the prime search.andP;  Consider again the case wherethe number being tested is of length 20 words, i.e., 96 decimal digits, andnote that the frequency of primes among odd numbers of this length isapproximately 2/ In 1096 =  .0090.andP;  If the flag table is taken to be oflength 1000, the probability of overflow is about [0.991.sup.1000] = 0.00011,or slightly over one in ten thousand.andM;The frequency of primes can now be used to estimate how many times thepseudoprime test is executed in each prime search.andP;  Assuming that the sieveprocedure is done, as indicated above, using the small primes andless; 13 500, thefraction of survivors in the flag table is given approximately by the productandM;II (1 - 1/[S.sub.j]) = 0.118andM;[S.sub.j]andless; 13500andM;where s, is the jth odd prime.andP;  Thus on average the sieve procedure leaves118 survivors out of 1000, of which only 9 are primes.andP;  Hence the pseudoprimetest has to be executed an average of 13 times before a prime is found.andO;Also, because the probability of finding a prime on any given occurrence isso small, the number of executions of the pseudoprime test varies a greatdeal between one prime search and another.andP;  So, while it is possible tooptimize the average performance of the prime search, it is impossible toguarantee that the procedure will terminate within a given time.andM;The calculation shown above for the case of a prime of length 20 can berepeated for other lengths, so as to obtain the various thresholds as afunction of that length.andP;  For example, if one seeks a prime of length 40words (192 digits), it turns out that the sieve procedure should be carriedout with the small primes up to 51 000, resulting in about 104 survivors perthousand; since there are only on average 4.5 primes per thousand odd numbersof this length, the pseudoprime test will be executed an average of 23 timesbefore a prime is found.andM;Finally, we discuss briefly the parameters that control the number ofadditional times that the pseudoprime test is applied to a number n after nhas passed the pseudoprime test with x = 3.andP;  First, it must be noted thatthese parameters, while affecting the time required for the prime search, arenot thresholds that can be varied to tune the performance of the program;instead they affect the probability (extremely small in any case) that theprogram will accept as prime some numbers that are not prime.andP;  Second, wenote that in our experience, including an analysis of hundreds of thousandsof tests, the first application of the strong pseudoprime test has alwaysbeen decisive: not a single instance has been recorded of a number thatpassed the test with x = 3 and failed it later with a different x. Third, webriefly summarize the applicable mathematical knowledge, making use of thefollowing terminology introduced by Rabin: if the pseudoprime test applied ton, using a particular value of x, indicates that n is a pseudoprime, when nis in fact not prime, then that x is called a false witness.andP;  For the vastmajority of values of n the false witnesses are extremely rare ornonexistent, while for a very few values of n the false witnesses may be asmany as 25 percent of the possible x s. Unfortunately the  vast majority&quot; andthe  very few&quot; have not been quantified by mathematical analysis.andP;  Hencethere are no firm guidelines.andP;  A further consideration, in the context ofcryptographic key generation, is that the essential goal is to produce theprimes p and q, while the primality of [p.sub.1], [q.sub.1], [P.sub.2][q.sub.2] is of lesser importance.andP;  In view of the above, the number ofadditional executions of the pseudoprime test, as currently set in theprogram, are as follows:andM;0 for P2 and q,andM;1 for p, and q,andM;9 for p and qandM;Cryptographic key generationandM;Once the required primes have been obtained, the process of key generationcan be swiftly completed.andP;  In the case of the Rabin cryptosystem, where thepublic key is the product n = p x q, all that remains to be done is multiplythe two numbers.andM;For the ElGamal system, an integer a andless; n must be found which is primitive modn. This condition is easy to check, since the factorization of n - 1 isknown.andP;  Thus a random a is generated and exponentiated with each factor of n- 1; if any of the results are unity, a is discarded.andP;  Very few trials areneeded in most cases.andP;  Each individual user can then arbitrarily choose hisprivate key x and compute the corresponding public key y by exponentiation.andM;For the RSA system, several additional numbers must be produced.andP;  The firstof these is [Phi] = (p - 1)(q - 1), which must be kept secret.andP;  The publicencryption exponent e may be chosen next, and it must be a number relativelyprime to [Phi].andP;  Since a smaller e tends to result in faster encryption, asmall prime may be a good choice.andP;  The number 3 was once recommended, but ithas since been shown that it is vulnerable in the so-called broadcastsituation (i.e., if the same message is encrypted with three different modulibut with e = 3 in all cases, and if an attacker can intercept and analyze thethree ciphertexts).andP;  The number [2.sup.16] + 1 = 65 537 is now advocated bysome as being sufficiently large to avoid this problem.andP;  The computation ofthe secret decryption exponent d, which must satisfy the equation ed mod  A =1, is accomplished by means of a straightforward and fairly fast procedurethat resembles a greatest common divisor calculation.andP;  If e is chosen first,as indicated, then d will usually turn out to be almost as large a number asn, causing the decryption process, represented by the equation M = Cd mod n,to be quite slow.andP;  The situation can be remedied in part by computing fourauxiliary numbers defined by the equationsandM;[A.sub.p] = [q.sup.p-1.mod n],  [A.sub.q] = n + 1 - [A.sub.p]andM;[d.sub.p] = d mod(p - 1), [d.sub.q] = d mod(q - 1);andM;decryption is then done by computingandM;M = [A.sub.p] x ((C mod p)[sup.dp]  mod p)andM;+ [A.sub.q] x ((C mod q)[sup.dq].andP;  mod q])) mod n.andM;In this calculation, the modular exponentiations are done with the moduli pand q, which are about half the length of n; the time required is usuallyreduced by about 70 percent.andP;  The auxiliary numbers, like all the otherquantities except n and e, must be kept secret.andM;To verify that the computations have been done correctly, the program nowgenerates a random number of the same length as n, encrypts it and decryptsit, and verifies that the end result agrees with the original.andP;  As anadditional test for RSA, another random number is generated, decrypted andencrypted, then compared with its original.andP;  For experimental and testingpurposes, the key generation program was written so it could generate keyswith moduli between 60 and 600 digits long (1 2 to 125 words), although inactual practice the extremes of the range are not useful: less than 160 isprobably not secure enough, and more than 320 seems to be overkill.andP;  Theaverage key generation time is shown in Table 3.andP;  The variability in theprime search procedure, previously discussed, causes the key generation timeto be also highly variable in individual cases, especially for longer moduli;it is not uncommon for a key generation run to take anywhere between half totwice the stated average time.andM;Speed and cryptosystems designandM;The figures in Table 3 show that for moduli in the range of 200 to 250digits, which is generally considered an adequate length, the average RSA keygeneration time on a PC AT iS tWO tO four minutes.andP;  This time seems quitereasonable when one considers that in a public key system the keys shouldrarely be changed Oust like telephone numbers).andM;It is apparent that, for a given modulus length, the average ElGamal keygeneration time is larger by a factor of 4 to 7; the reason is that a singlelarge prime is required, rather than two smaller ones.andP;  However, thedifference may not be very significant, in that with the ElGamal system thesame modulus is shared by many users; hence very few modulus generations areneeded.andM;A different picture emerges when one compares any public keyencryption/decryption time with the corresponding time for the DataEncryption Algorithm.andP;  This comparison is first made with regard to the RSAsystem, then some observations are presented pertaining to the ElGamalsystem.andP;  The first consideration, already mentioned, is that RSA encryptioncan be made quite fast by choosing the number 3, or another small prime, asthe public key; but since each encrypted message has to be decrypted in orderto make sense, it is really the average of encryption and decryption timethat gives a meaningful measure of performance.andP;  Under DEA the two times areessentially the same.andM;The second point is that the comparison can be made in two ways:andM;* By comparing the time needed to encrypt/decrypt a single block-Under DEAthe block, or minimum unit of encryption, is 8 bytes; under RSA it is equalin length to the modulus.andP;  This comparison is appropriate if the intendedapplication requires the encryption of short items, such as DEA keys, orindividual database fields.andM;By comparing the average time per byte-This is appropriate if the applicationinvolves bulk encryption of large files.andM;Table 4 and Table 5 show the results of the two comparisons.andP;  The times forthe DEA were obtained by using a highly optimized implementation of thealgorithm.andM;It is apparent that the speed of the DEA, Compared to the averageencrypt/decrypt speed of a 200-digit RSA, is better by almost three orders ofmagnitude at the byte level, and almost four at the block level.andP;  Suchenormous differences are bound to affect the role that DEA or RSA can play inany integrated cryptosystem.andP;  While DEA is likely to remain the algorithm ofchoice for routine message and file encryption, the increasing recognitionbeing given to the importance of key management, and the difficulty ofaccomplishing it with DEA, have drawn attention to the unique advantages ofthe public key systems.andP;  If a public key algorithm is used only for thespecialized task of exchanging other cryptographic keys, the performanceindicated in the tables-several seconds for each key exchange-is quiteacceptable in many environments.andM;Under the ElGamal system, encryption/decryption is slower than under RSA, ascan be seen by comparing Table 6 and Table 4.andP;  Here encryption requires twomodular exponentiations and it cannot be significantly speeded up by choosinga small key; decryption entails an exponentiation with a modulus that cannotbe factored.andP;  Another disadvantage of ElGamal is that each block of plaintext produces two blocks of ciphertext.andM;On the plus side, one can list two advantages:andM;* Encryption involves a random number, so if a given plaintext is encryptedon two different occasions the corresponding ciphertexts are different; thisis a protection against possible replay attacks.andP;  Under RSA, if the plaintextis assumed to be chosen from a small set of candidates, an attacker canencipher each candidate with the public key and compare the results with theciphertext; under ElGamal this attack does not work.andM;ConclusionandM;This paper has stressed a variety of techniques for increasing the speed ofthe numerical calculations that constitute the core of exponentiationcryptosystems.andP;  The results that can be obtained by using these techniqueshave been illustrated.andP;  A Pc implementation of the major components of thesealgorithms yields a very reasonable performance.andP;  The solutions made possibleby these algorithms are likely to become increasingly important as theinterconnectivity of computers grows.andP;  Personal Computer AT is a registeredtrademark of International Business Machines Corporation.andP;  Cited referencesand noteandM;1.andP;  Data Encryption Standard, Federal Information Processing Standard (FIPS)Publication 46, National Bureau of Standards, Washington, DC (January 1977).andM;2.andP;  W. Diffie and M. Hellman, &quot;New Directions in Cryptography,&quot; IEEETransactions on Information Theory IT-22, 644654 (November 1976).andM;3.andP;  D.E.R.andP;  Denning, Cryptography and Data Security, AddisonWesley PublishingCo., Reading, MA (1982).andM;4.andP;  W. Patterson, Mathematical Cryptology, Rowman andamp; Littlefield, Totowa, NJ(1987).andM;5.andP;  R. L. Rivest, A. Shamir, and L. Adleman, &quot;A Method for Obtaining DigitalSignatures and Public-Key Cryptosystems,&quot; Communications of the ACM 21,120-126 February 1978).andM;6.andP;  M. O. Rabin, &quot;Digitalized Signatures and Public-Key Functions asIntractable as Factorization,&quot; MIT/LCS/TR-212, Massachusetts Institute ofTechnology, Laboratory for Computer Science, Cambridge, MA (January 1979).andM;7.andP;  T. ElGamal, &quot;A Public Key Cryptosystem and a Signature Scheme Based onDiscrete Logarithms,&quot; IEEE Transactions on Information Theory IT-31, 469-472(July 1985).andM;8.andP;  B. Tuckerman, &quot;The 24th Mersenne Prime,&quot; Proceedings of the NationalAcademy of Science 68, 2319-2330 (1970).andM;9.andP;  D. E. Knuth, The Art of Computer Programming, Volume 2 (second edition),Addison-Wesley Publishing Co., Reading, MA (1981).andM;10.andP;  J.D.andP;  Dixon, &quot;Factorization and Primality Testing,&quot; AmericanMathemathics Monthly, 333-352 (June-July 1984).andM;11.andP;  H. Riesel, Prime Numbers and Computer Methods of Factorization,Birkhauser, Boston, MA (1985).andM;12.andP;  Don Coppersmith, private communication.andM;Paul G. Comba IBM Cambridge Scientific Center, 101 Main Street, Cambridge,Massachusetts  2142.andP;  Dr. Comba joined IBM in 1960 and has since worked on avariety of advanced technology projects, mainly in software and applicationdevelopment, including programming languages, simulation, graphics, anddatabase management.andP;  In the last seven years, he has worked primarily in thearea of software implementation of cryptographic systems.andP;  Dr. Comba receivedhis Ph.D.andP;  in mathematics from the California Institute of Technology in1951.andP;  Before joining IBM he was assistant professor, then associateprofessor of mathematics at the University of Hawaii from 1951 to 1960.andO;</TEXT></DOC>