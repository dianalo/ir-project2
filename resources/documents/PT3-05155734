<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO> PT3-05155734 </DOCNO><WKU> 05155734 </WKU><SRC>  7 </SRC><APN>  477424 </APN><APT>  1 </APT><ART>  236 </ART><APD>  19900209 </APD><TTL>  Error correcting device </TTL><ISD>  19921013 </ISD><NCL>  14 </NCL><ECL>  10 </ECL><EXA>  Lebowitz; Henry C. </EXA><EXP>  Smith; Jerry </EXP><NDR>  4 </NDR><NFG>  4 </NFG><INVT> <NAM>  Kashida; Motokazu </NAM><CTY>  Musashino </CTY><CNT>  JPX </CNT></INVT><INVT> <NAM>  Yamashita; Shinichi </NAM><CTY>  Yokohama </CTY><CNT>  JPX </CNT></INVT><ASSG> <NAM>  Canon Kabushiki Kaisha </NAM><CTY>  Tokyo </CTY><CNT>  JPX </CNT><COD>  03 </COD></ASSG><PRIR> <CNT>  JPX </CNT><APD>  19890216 </APD><APN>  1-36924 </APN></PRIR><CLAS> <OCL>  371 371 </OCL><XCL>  371  51 </XCL><XCL>  371 378 </XCL><XCL>  395575 </XCL><XCL>  395775 </XCL><EDF>  5 </EDF><ICL>  G06F 1110 </ICL><ICL>  H03M 1300 </ICL><FSC>  371 </FSC><FSS>  37.1;37.2;5.1;37.8 </FSS></CLAS><UREF> <PNO>  3685014 </PNO><ISD>  19720800 </ISD><NAM>  Hsiao et al. </NAM><OCL>  371 37.2 </OCL></UREF><UREF> <PNO>  4107652 </PNO><ISD>  19780800 </ISD><NAM>  Tanahashi et al. </NAM><OCL>  371 37.1 </OCL></UREF><UREF> <PNO>  4142174 </PNO><ISD>  19790200 </ISD><NAM>  Chen et al. </NAM><OCL>  371 37.1 </OCL></UREF><UREF> <PNO>  4555729 </PNO><ISD>  19851100 </ISD><NAM>  Driessen </NAM><OCL>  371 37.1 </OCL></UREF><UREF> <PNO>  4567594 </PNO><ISD>  19860100 </ISD><NAM>  Deodhar </NAM><OCL>  371 37.8 </OCL></UREF><UREF> <PNO>  4618954 </PNO><ISD>  19861000 </ISD><NAM>  Otobe et al. </NAM><OCL>  371  5.1 </OCL></UREF><UREF> <PNO>  4696007 </PNO><ISD>  19870900 </ISD><NAM>  Moriyama </NAM><OCL>  371 37.1 </OCL></UREF><UREF> <PNO>  4951282 </PNO><ISD>  19900800 </ISD><NAM>  Mester </NAM><OCL>  371  5.1 </OCL></UREF><UREF> <PNO>  4958349 </PNO><ISD>  19900900 </ISD><NAM>  Tanner et al. </NAM><OCL>  371 37.1 </OCL></UREF><OREF> <PAL>  IBM Tech. Disc. Bull., vol. 3, No. 6, pp. 23-26, Nov. 1960. </PAL></OREF><LREP> <FRM>  Fitzpatrick, Cella, Harper andamp; Scinto </FRM></LREP><TEXT><ABST> <PAL>  There is provided an error correcting device for correcting errors of a      received message in accordance with a processing program including a      plurality of error correcting processes for correcting different numbers      of errors, wherein a plurality of check codes which are used to      discriminate the shift to either one of the plurality of error correcting      processes for correcting different numbers of errors and which are formed      by syndromes formed from the reception code are sequentially serially      generated, the plurality of check codes are output in parallel and the      shift of the process in the processing program is executed in accordance      with the check codes which were output in parallel. </PAL></ABST><BSUM> <PAC>  BACKGROUND OF THE INVENTION </PAC><PAR>  1. Field of the Invention </PAR><PAR>  The present invention relates to an error correcting device and, more      particularly, to the realization of its high processing speed. </PAR><PAR>  2. Related Background Art </PAR><PAR>  In an error correcting device using what is called a program control system      in which error correcting processes are executed by a microprocessor or      the like in accordance with a predetermined program, a discrimination of a      jump (shift of the process) of the program and a change in count value of      a program counter in association with the program jump are executed each      time the result of the discrimination is obtained. </PAR><PAR>  A conventional procedure of the processes will now be described with      respect to the syndrome discrimination of the Reed Solomon code as an      example. The Reed Solomon code is a multi-dimension block code of a cyclic      type and, in recent years, it has been applied to various fields and has      widely been known. </PAR><PAR>  A decoding method of the Reed Solomon code having a code length (n) and (k)      information symbols and comprising (n-k) check symbols will now be      described. It is also assumed that each symbol is an element of a Galois      field GF (2.sup.m), a finite field having m binary bits (i.e., 2.sup.m      elements). </PAR><PAR>  In this case, a generating polynomial g(x) of the (t)-ply error correction      Reed Solomon code is expressed by the following equation (1) or (2) in      which (.alpha.) is a primitive element of the Galois field GF (2.sup.m). </PAR><EQU>  g(x)andequals;(xandplus;.alpha.) (xandplus;.alpha..sup.2) . . . (xandplus;.alpha..sup.2t) (1) </EQU><EQU>  g(x)andequals;(xandplus;.alpha..sub.O) (xandplus;.alpha.) . . . (xandplus;.alpha..sup.2t-1) (2) </EQU><PAR>  On the other hand, when a transmission code word is expressed by C(x) and a      reception code word is expressed by R(x) and an error polynomial is      expressed by E(x), the following relation is satisfied among them. </PAR><EQU>  R(x)andequals;C(x)andplus;E(x)                                             (3) </EQU><PAR>  In this case, the coefficients of the polynomial are included in the Galois      field GF (2.sup.m) and the error polynomial E(x) includes only the terms      corresponding to the error location and a value (size). </PAR><PAR>  Therefore, assuming that an error value at a position x.sub.j is set to      Y.sub.j.      ##EQU1##      In the equation (4), .SIGMA.denotes the sum of errors at all positions. </PAR><PAR>  Assuming that the syndromes S.sub.i are defined as follows </PAR><EQU>  S.sub.i andequals;R(.alpha..sup.i) andlsqb;where, iandequals;0, 1 . . . 2t-1andrsqb;       (5) </EQU><PAL>  from the equation (3), </PAL><EQU>  S.sub.i andequals;C(.alpha..sup.i)andplus;E(.alpha..sup.i) </EQU><PAR>  In this case, since C(x) can always be divided by g(x), </PAR><EQU>  C(.sup..alpha.i)andequals;0 </EQU><EQU>  Therefore, </EQU><EQU>  S.sub.i andequals;E(.alpha..sup.i) </EQU><PAL>  From the equation (4), the syndromes can be expressed as follows.      ##EQU2##      However, it is assumed that .alpha..sup.j andequals;X.sub.j and X.sub.j denotes an      error location in the case of .alpha..sup.j. </PAL><PAR>  When the number of errors is set to e, an error location polynomial      .sigma.(x) is defined as follows.      ##EQU3## </PAR><PAR>  The following relation is provided between .sigma..sub.1 to .sigma..sub.e      in the equation (7) and the syndromes S.sub.i. </PAR><EQU>  S.sub.iandplus;e andplus;.sigma..sub.1 S.sub.iandplus;e-1 andplus;. . . .sigma..sub.e-1 S.sub.iandplus;1      andplus;.sigma..sub.e S.sub.i                                    ( 8) </EQU><PAR>  Namely, the above Reed Solomon code is decoded in the following procedure. </PAR><PA1>  (I) The syndromes S.sub.i are calculated by the equation (5). </PA1><PA1>  (II) The coefficients .sigma..sub.1 to .sigma..sub.e of the error location      polynomial are calculated by the equation (8). </PA1><PA1>  (III) A root X.sub.j of the error location polynomial is obtained by the      equation (7). </PA1><PA1>  (IV) The error value Y.sub.j is obtained by the equation (6) and the error      polynomial is obtained by the equation (4). </PA1><PA1>  (V) The error correction is executed by the equation (3). </PA1><PAR>  A practical example of the error correction by the decoding procedure as      mentioned above will now be described with respect to the case where four      check symbols are used in one-block data. </PAR><PAR>  That is, the generating polynomial g(x) in this case is as follows.      ##EQU4##      The correction until the double error can be corrected. </PAR><PAR>  The case of actually executing the error correction will now be considered      with respect to the following four cases: eandequals;0; eandequals;1, eandequals;2, and e.gtoreq.3.      When eandequals;0, this means that the received message word is correct, so that no      error correcting process is executed. On the other hand, when e.gtoreq.3,      this also means that such a case exceeds the error correcting capability,      so that the error correcting process other than the process to set an      error flag into 1 is not executed. That is, the error correcting process      is actually executed only in the cases where eandequals;1 and eandequals;2. </PAR><PAR>  The error correcting process is schematically executed by the following      procedure in correspondence to the above decoding procedures (I) and (II). </PAR><PAR>  (a) The syndromes S.sub.0 to S.sub.3 are calculated. </PAR><PAR>  (b) The syndromes S.sub.0 to S.sub.3 are checked and when S.sub.0 andequals;S.sub.1      andequals;S.sub.2 andequals;S.sub.3 andequals;0, it is determined that eandequals;0 and the error correcting      process is finished. Further, when only one of the values of the syndromes      S.sub.0 to S.sub.3 is equal to 0, this means that e.noteq.1. When any two      or more of the values of the syndromes S.sub.0 to S.sub.3 are equal to 0,      it will be obvious from the equation (6) that e.gtoreq.3. </PAR><PAR>  (c) When the equation (8) is rewritten with respect to eandequals;1 and eandequals;2. </PAR><PAR>  in the case where eandequals;1.      ##EQU5## </PAR><PAR>  and in the case where eandequals;2.      ##EQU6## </PAR><PAR>  It is now assumed that the actual decoder starts the operation from the      case where eandequals;1. Then, the solution .sigma..sub.1 which satisfies the      simultaneous equation (9) must be first obtained. If such a solution does      not exist, the decoder must obtain the solutions .sigma..sub.1 and      .sigma..sub.2 which satisfy the simultaneous equation (10) with respect to      the case of eandequals;2. If no solution is derived here, it can be regarded such      that e.gtoreq.3. </PAR><PAR>  The solution .sigma..sub.1 of the equation (9) is obtained as follows.      ##EQU7##      The solutions .sigma..sub.1 and .sigma..sub.2 of the equation (10) are      obtained as follows.      ##EQU8## </PAR><PAR>  In the above procedures, the values of the various equations are calculated      and compared in each step. It is then necessary to change the program flow      indicative of the processing in accordance with the result of the      discrimination. </PAR><PAR>  For instance, the number e of errors can be determined as shown in Table 1      in accordance with the values of the syndromes S.sub.0 to S.sub.3 in the      step (b). </PAR><TBL>                TABLE 1                                                          ______________________________________                                         S.sub.0   S.sub.1                                                                               S.sub.2      S.sub.3                                                                             e                                           ______________________________________                                         andequals;0        andequals;0     andequals;0           andequals;0   andequals;0                                          andequals;0        andequals;0     andequals;0           .noteq.0                                                                            .gtoreq.3                                   andequals;0        andequals;0     .noteq.0     andequals;0   .gtoreq.3                                   andequals;0        andequals;0     .noteq.0     .noteq.0                                                                            .gtoreq.3                                   andequals;0        .noteq.0                                                                              andequals;0           andequals;0   .gtoreq.3                                   andequals;0        .noteq.0                                                                              andequals;0           .noteq.0                                                                            .gtoreq.3                                   andequals;0        .noteq.0                                                                              .noteq.0     andequals;0   .gtoreq.3                                   andequals;0        .noteq.0                                                                              .noteq.0     .noteq.0                                                                            .gtoreq.2                                   .noteq.0  andequals;0     andequals;0           andequals;0   .gtoreq.3                                   .noteq.0  andequals;0     andequals;0           .noteq.0                                                                            .gtoreq.3                                   .noteq.0  andequals;0     .noteq.0     andequals;0   .gtoreq.3                                   .noteq.0  andequals;0     .noteq.0     .noteq.0                                                                            .gtoreq.2                                   .noteq.0  .noteq.0                                                                              andequals;0           andequals;0   .gtoreq.3                                   .noteq.0  .noteq.0                                                                              andequals;0           .noteq.0                                                                            .gtoreq.3                                   .noteq.0  .noteq.0                                                                              .noteq.0     andequals;0   .gtoreq.3                                   .noteq.0  .noteq.0                                                                              .noteq.0     .noteq.0                                                                            .gtoreq.1                                   ______________________________________                                     </TBL><PAR>  An outline of the flow of the processes according to the determination is      shown in a flowchart of FIG. 1. The step shown by &quot;e.gtoreq.3&quot; in FIG. 1      denotes that the number of errors is decided to be 3 or more and that the      processing routine advances to the processing routine for the excessive      error correcting capability. The step shown by &quot;e.gtoreq.2&quot; denotes that      the number of errors is decided to be 2 or more and that the processing      routine advances to the processing routine for correction of double error.      Further, the step shown by &quot;e.gtoreq.1&quot; denotes that the number of errors      is decided to be 1 or more and that the processing routine advances to the      processing routine for correction of single error. </PAR><PAR>  On the other hand, consider the following as one example in which the flow      of the program is changed as mentioned above, that is, the program is      jumped. When the coefficients .sigma..sub.1 and .sigma..sub.2 of the error      location polynomial are calculated in the foregoing step (c), checks are      made to see if the denominator (S.sub.1 .sup.2 andplus;S.sub.0 S.sub.2) and the      numerators (S.sub.0 S.sub.3 andplus;S.sub.1 S.sub.2) and (S.sub.1 S.sub.3      andplus;S.sub.2.sup.2) are equal to 0 and the program is jumped in accordance      with the results of the discriminations. That is, when the denominator      (S.sub.1.sup.2 andplus;S.sub.0 S.sub.2) is equal to 0, the processing routine      advances to the processing routine for the excessive error correcting      capability. When either one of the numerators (S.sub.0 S.sub.3 andplus;S.sub.1      S.sub.2) and (S.sub.1 S.sub.3 andplus;S.sub.2.sup.2) is equal to 0, the      processing routine advances to the processing routine for correction of      single error. </PAR><PAR>  However, in the above conventional example using S.sub.0, S.sub.1 and      S.sub.2 for discrimination rather than .sigma.1 and .sigma.2, for      instance, assume that the program is jumped in the case where the result      of the discrimination is &quot;Yes&quot; (&quot;Y&quot;) in each of the discriminating step in      the flowchart of FIG. 1. It is then necessary to jump the program one or      two times until the processing routine advances to the double-error      correction processing routine through the step shown by &quot;e.gtoreq.2&quot;. It      is necessary to jump the program about four times until the processing      routine advances to the no-error processing routine through the step shown      by &quot;eandequals;0&quot;. Moreover, it will be obvious from FIG. 1 that a fairly large      program step area is needed to describe the above programs. </PAR><PAR>  On the other hand, even in the procedure to calculate the coefficients      .sigma..sub.1 and .sigma..sub.2 of the above error location polynomial,      there is also an increase in the program step area increases. Even in the      case of sequentially executing the steps of checking to see if      (S.sub.1.sup.2 andplus;S.sub.0 S.sub.2), (S.sub.0 S.sub.3 andplus;S.sub.1 S.sub.2), and      (S.sub.1 S.sub.3 andplus;S.sub.2.sup.2) are equal to 0 or not, the program step      area also similarly increases. </PAR><PAR>  As mentioned above, when the program step area increases and the      possibility of the program jump increases, it takes time to execute the      above programs so that processes cannot be performed at high speed. Thus,      it is difficult to process the received message of a high bit rate. </PAR><PAC>  SUMMARY OF THE INVENTION </PAC><PAR>  Under the aforementioned circumstances, it is an object of the invention to      solve the foregoing problems. </PAR><PAR>  Another object of the invention is to realize the high processing speed of      an error correcting device for processing in accordance with programs. </PAR><PAR>  Still another object of the invention is to provide an error correcting      device which can reduce the number of program processing steps and the      number of program jumping times in the error correcting device. </PAR><PAR>  Under such objects, according to the present invention, as a preferred      embodiment, there is provided an error correcting device comprising: (a) a      processor for executing a processing program which includes a plurality of      kinds of code error correction processing routines and is used to correct      code errors of a received message; (b) first means for sequentially      serially outputting a plurality of check codes to determine a shift to      either one of the plurality of kinds of code error correction processing      routines by using a plurality of syndromes formed from the reception code;      (c) second means for outputting the plurality of check codes in parallel;      and (d) third means for executing the shift of the program in the      processing program in accordance with an output of the second means. </PAR><PAR>  The above and other objects and features of the present invention will      become apparent from the following detailed description and the appended      claims with reference to the accompanying drawings. </PAR></BSUM><DRWD> <PAC>  BRIEF DESCRIPTION OF THE DRAWINGS </PAC><PAR>  FIG. 1 is a flowchart showing the outline of the flow of conventional error      correcting processes; </PAR><PAR>  FIG. 2 is a block diagram showing a construction of a main section of an      error correcting device as an embodiment of the present invention; </PAR><PAR>  FIG. 3 is a flowchart showing the outline of the flow of error correcting      processes according to the device of FIG. 2; and </PAR><PAR>  FIG. 4 is a block diagram showing a construction of the main section in an      error correcting device as another embodiment of the invention. </PAR></DRWD><DETD> <PAC>  DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS </PAC><PAR>  An embodiment of the present invention will be described hereinbelow with      reference to the drawings. </PAR><PAR>  FIG. 2 is a diagram showing a construction of a program processing section      as a main section in an error correcting device as an embodiment of the      invention. </PAR><PAR>  In the diagram, reference numeral 1 denotes an input terminal of a received      message word. A code word train including errors generated in a      transmission path is input to the input terminal 1. Syndrome calculating      circuits 2a, 2b, 2c, and 2d calculate the syndromes S.sub.0, S.sub.1,      S.sub.2, and S.sub.3 in accordance with the foregoing equation (6),      respectively. The error correcting process is executed by operating a      processor 8 in accordance with programs which have previously been      described. </PAR><PAR>  FIG. 3 is a flowchart for explaining the processes according to the above      programs. The processing programs which are executed by the processor 8      will now be described hereinbelow in accordance with the flowchart of FIG.      3. </PAR><PAR>  Step 1 in FIG. 3 will be first executed. In step 1, a gate of the      calculating circuit 2a is opened and the syndrome S.sub.0 is output to a      data bus DB and is temporarily stored into a register REG 3 as a temporary      memory circuit. Next, to check whether S.sub.0 andequals;0 or not, the value 0 is      output from a program memory in the processor 8 to the data bus (DB) and      is temporarily stored into a register REG 4. The operations of the      calculating circuits 2a to 2d, REG 3, and REG 4 can be controlled by the      processor 8 through a control bus (not shown). </PAR><PAR>  At this time, the processor (ALU) as an arithmetic operating unit 8      compares outputs of the REG 3 and REG 4 and outputs the result of the      comparison as a 1-bit data. That is, when the syndrome S.sub.0 is equal to      0, the ALU 8 outputs &quot;0&quot;. When the syndrome S.sub.0 is set to a value      other than 0, the ALU 8 outputs &quot;1&quot;. The output of the ALU 8 is input as a      1-bit data to a shift register 5. </PAR><PAR>  By repeating the above processes with respect to the syndromes S.sub.1,      S.sub.2, and S.sub.3, respectively, four data (check codes) indicating      whether the syndromes S.sub.0 to S.sub.3 are equal to 0 or not are stored      in the shift register 5, so that a 4-bit data is derived. </PAR><PAR>  Table 2 shows the corresponding relations in the case where the results of      the determination of Table 1 are expressed as a 1-bit data as an output of      the ALU 8 and the processing routines to be shifted are expressed by &quot;0&quot;,      &quot;1&quot;, &quot;2&quot;, and &quot;3&quot; in correspondence to the number of errors. </PAR><TBL>                TABLE 2                                                          ______________________________________                                         S.sub.0    S.sub.1                                                                              S.sub.2      S.sub.3                                                                            e                                            ______________________________________                                         0          0     0            0   0                                            0          0     0            1   3                                            0          0     1            0   3                                            0          0     1            1   3                                            0          1     0            0   3                                            0          1     0            1   3                                            0          1     1            0   3                                            0          1     1            1   2                                            1          0     0            0   3                                            1          0     0            1   3                                            1          0     1            0   3                                            1          0     1            1   2                                            1          1     0            0   3                                            1          1     0            1   3                                            1          1     1            0   3                                            1          1     1            1   1                                            ______________________________________                                     </TBL><PAR>  Therefore, in step 2 in FIG. 3, a 4-bit pattern &quot;0000&quot; corresponding to the      routine &quot;0&quot; in Table 2 is input to a comparator 6 from the data bus DB. At      this time, an address (k bits) on the jump destination side of the program      to execute the routine &quot;0&quot; is input to a program counter 7 from the data      bus DB. The comparator 6 compares an output of the shift register 5 with      &quot;0000&quot;. When they coincide, the program counter 7 is set by the jump      destination address data. In association with it, the process of the      routine &quot;0&quot; is executed by a processing section (not shown). </PAR><PAR>  The process of the routine &quot;0&quot; is executed in the case where no error      exists as mentioned above. In this routine, the error correcting process      is not executed but the next process of the received message is executed.      In FIG. 3, the process of the routine &quot;0&quot; corresponds to the process to      jump the program from step 2 to step 7. </PAR><PAR>  In step 2, if it is decided that the output of the shift register 5 is not      &quot;0000&quot;, a 4-bit pattern &quot;1111&quot; corresponding to the routine &quot;1&quot; is input      to the comparator 6 from the data bus DB. In a manner similar to the      above, when the output of the shift register 5 is set to &quot;1111&quot;, the      program counter 7 is set by the jump destination address data      corresponding to step 8 in FIG. 3, namely, the routine &quot;1&quot;. The process of      the routine &quot;1&quot; relates to the single-error correcting process as      mentioned above. In the case where the code stored in a memory 9 was error      corrected by the routine &quot;1&quot;, the processing routine advances from step 9      to step 6 (routine &quot;3&quot;addition of correction flap). If the error      correction cannot be executed, the processing routine advances from step 9      to step 10 (routine &quot;2&quot;). </PAR><PAR>  Further, if it is determined in steps 2 and 3 that the output of the shift      register 5 is neither &quot;0000&quot; nor &quot;1111&quot;, 4-bit patterns &quot;0111&quot; and &quot;1011&quot;      corresponding to the routine &quot;2&quot; are sequentially input to the comparator      6. When the 4-bit pattern coincides with the output of the shift register      5, the program counter 7 is set by the jump destination address data      corresponding to the routine &quot;2&quot;. Thus, the processing routine of the      program advances to the routine &quot;2&quot; (step 10). </PAR><PAR>  The process of the routine &quot;2&quot; relates to the double-error correcting      process as mentioned above. After the processor 8 corrected the code      stored in the memory 9, the processing routine advances to the routine &quot;3&quot;      (step 6). There is no need for an &quot;OK&quot; decision as in step 9 since error      correction is completed in step 10. Therefore, the flag operation of step      6 may be entered directly from step 10. </PAR><PAR>  On the other hand, if data other than &quot;0000&quot; &quot;0111&quot;, &quot;1111&quot;, and &quot;1011&quot; has      been stored in the shift register, the processing routine directly      advances to the routine &quot;3&quot; (step 6). The program is set so as to      automatically execute the shifting from step 5 to step 6 in the case where      the program counter 7 is not preset. </PAR><PAR>  By constructing the error correcting device as mentioned above, the number      of jumping times to change the flow of the program can be reduced and the      error correction processing speed can be made high as a whole and the      program area can be reduced. </PAR><PAR>  FIG. 4 is a diagram showing a construction of a program processing circuit      as a main section of an error correcting device as another embodiment of      the invention. In the diagram, the parts and components similar to those      in FIG. 2 are designated by the same reference numerals and their      descriptions are omitted. </PAR><PAR>  In the construction of the embodiment shown in FIG. 4, the 4-bit data which      is output from the shift register 5 is given to a jump address table 1. In      response to a control signal (CONT) from the data bus DB, the jump address      table 9 outputs data indicative of the jump destination address of each      routine (refer to FIGS. 2 and 3) corresponding to the 4-bit data. The      control signal CONT is also input to the program counter 7. In response to      the control signal CONT, the program counter 7 is preset by the address      data from the table 1. </PAR><PAR>  Even in the embodiment of FIG. 4, it is readily understood that effects      similar to the embodiment of FIG. 2 are obtained. Further, in the      embodiment of FIG. 4, the four comparing operations of the comparator 6 in      the embodiment of FIG. 2 can be executed in a single step, so that the      processing speed can be further increased. </PAR><PAR>  In the above embodiment, the results of the discriminations to see if the      syndromes S.sub.0 to S.sub.3 are equal to 0 or not are used as check codes      and are simultaneously output, thereby realizing the high processing      speed. However, similar effects can be also obtained even when the      invention is applied by using the results of the discriminations to see if      the numerators and denominator of the coefficients .sigma..sub.1 and      .sigma..sub.2 of the foregoing error location polynomial are set to 0 or      not as check codes. </PAR><PAR>  For instance, the construction shown in FIG. 2 is used as it is,      (S.sub.1.sup.2 andplus;S.sub.0 S.sub.2), (S.sub.0 S.sub.3 andplus;S.sub.1 S.sub.2), and      (S.sub.1 S.sub.3 andplus;S.sub.2.sup.2) are sequentially stored into the REG 3,      and 0 is stored into the REG 4, thereby sequentially inputting the 1-bit      check codes indicating whether those data are equal to 0 or not into the      shift register 5. By supplying those data together with the control signal      CONT to the jump address table, the program is shifted to a desired      routine. </PAR><PAR>  Although the embodiments have been described with respect to a particular      example of the double-error correction Reed Solomon code, similar effects      may also obtained by applying the principles of the invention to an error      correcting device using error correction code. </PAR><PAR>  As described above, according to the invention, an error correcting device      in which high processing speed can be realized and the program area can be      reduced can be obtained. </PAR></DETD><CLMS> <STM>  What is claimed is: </STM><NUM>  1. </NUM><PAR>  1. An error correcting device comprising: </PAR><PA1>  (a) a processor for executing a processing program which includes a      plurality of error correction processing routines for correcting different      numbers of errors, said processor being used to correct errors in a      received message; </PA1><PA1>  (b) a data bus which is accessible by said processor; </PA1><PA1>  (c) syndrome calculating means for calculating a plurality of syndromes by      using the received message, said syndrome calculating means serially      outputting the plurality of syndromes to said data bus; </PA1><PA1>  (d) first means for sequentially forming and serially outputting a      plurality of check codes to determine a shift to one of said plurality of      code error correction processing routines, wherein the plurality of      syndromes on said data bus are used in forming said check codes; </PA1><PA1>  (e) second means for outputting said plurality of check codes in parallel;      and </PA1><PA1>  (f) third means for executing the shift of the processing program in      accordance with an output of the second means. </PA1><NUM>  2. </NUM><PAR>  2. A device according to claim 1, wherein said plurality of check codes are      codes indicating whether said plurality of syndromes are equal to 0 or      not. </PAR><NUM>  3. </NUM><PAR>  3. A device according to claim 1, wherein said first means includes means      for calculating a plurality of coefficients of an error location      polynomial by using said plurality of syndromes, and said plurality of      check codes are codes indicating whether a numerator or a denominator of      said plurality of coefficients is equal to 0 or not. </PAR><NUM>  4. </NUM><PAR>  4. A device according to claim 1, wherein said second means includes a      shift register to which said check codes are serially input and which can      output in parallel codes stored in each register. </PAR><NUM>  5. </NUM><PAR>  5. A device according to claim 1, wherein said third means includes a      discriminating device to discriminate whether a pattern of the check codes      which were output in parallel coincides with a special code pattern to      shift the process or not. </PAR><NUM>  6. </NUM><PAR>  6. A device according to claim 5, wherein a plurality of said special code      patterns are prepared and said discriminating device sequentially      discriminates whether said plurality of code patterns coincide with a      pattern of the check codes or not. </PAR><NUM>  7. </NUM><PAR>  7. A device according to claim 5, wherein said third means includes a      program counter to determine a processing step of the processor and said      program counter is set by preset data corresponding to either one of said      plurality of kinds of error correction processing routines in accordance      with an output of said discriminating device. </PAR><NUM>  8. </NUM><PAR>  8. A device according to claim 1, wherein said third means includes a data      table to which the check codes which were output in parallel are input and      which selectively reads out a plurality of preset data corresponding to      said plurality of kinds of error correction processing routines. </PAR><NUM>  9. </NUM><PAR>  9. A device according to claim 8, wherein said third means includes a      program counter to determine a processing step of the processor and said      program counter is preset by an output of said data table. </PAR><NUM>  10. </NUM><PAR>  10. An error correcting device comprising: </PAR><PA1>  (a) a processor for executing a processing program which includes a      plurality of error correction processing routines for correcting different      numbers of errors, said processor being used to correct errors in a      received message, and said processor generating special code patterns to      shift the processing thereof; </PA1><PA1>  (b) first means for sequentially forming and serially outputting a      plurality of check codes to determine a shift to one of said plurality of      error correction processing routines, wherein said received message is      used in forming said check codes; </PA1><PA1>  (c) second means for outputting said plurality of check codes in parallel; </PA1><PA1>  (d) discriminating means for discriminating whether a pattern of the check      codes which were output in parallel by the second means coincides with the      special code patterns or not; and </PA1><PA1>  (e) third means for executing the shift of the processing in the processing      program in accordance with an output of said discriminating means. </PA1><NUM>  11. </NUM><PAR>  11. A device according to claim 10, wherein a plurality of said special      code patterns are prepared and said discriminating means sequentially      discriminates whether said plurality of code patterns coincide with a      pattern of the check codes or not. </PAR><NUM>  12. </NUM><PAR>  12. A device according to claim 10, wherein said third means includes a      program counter to determine a processing step of the processor and said      program counter is set by preset data corresponding to one of said      plurality of kinds of error correction processing routines in accordance      with an output of said discriminating means. </PAR><NUM>  13. </NUM><PAR>  13. An error correcting device comprising: </PAR><PA1>  (a) a processor for executing a processing program which includes a      plurality of error correction processing routines for correcting different      numbers of errors, said processor being used to correct errors in a      received message; </PA1><PA1>  (b) first means for sequentially forming and serially outputting a      plurality of check codes to determine a shift to one of said plurality of      error correction processing routines, said received message being used in      forming said check codes; </PA1><PA1>  (c) second means for outputting said plurality of check codes in parallel; </PA1><PA1>  (d) a data table for selectively reading out a plurality of data      corresponding to said plurality of error correction processing routines in      accordance with an output of the second means; and </PA1><PA1>  (e) third means for executing the shift of the process in the processing      program in accordance with the data which was read out of the data table. </PA1><NUM>  14. </NUM><PAR>  14. A device according to claim 13, wherein said third means includes a      program counter to determine a processing step of the processor and said      program counter is set by an output by the data table. </PAR></CLMS></TEXT></DOC>