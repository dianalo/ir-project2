<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF107-977-282  </DOCNO><DOCID>07 977 282.andM;</DOCID><JOURNAL>Communications of the ACM  Dec 1989 v32 n12 p1467(11)* Full Text COPYRIGHT Association for Computing Machinery 1989.andM;</JOURNAL><TITLE>Parse-tree annotations. (technical)</TITLE><AUTHOR>Purtilo, James J.; Callahan, John R.andM;</AUTHOR><SUMMARY>Extracting simple structural characteristics such as interfacesand control-flow summaries from program source files is frequentlynecessary.andP;  High-level transformations allow optimization,instrumentation, or animation of programs.andP;  A technique forlinking productions in grammars with transformation rules usingthe NewYacc translation tool is described.andP;  NewYacc is anextension of the Unix 'yacc' parser generator specificationlanguage that retains parse trees.andP;  'Traversals' are dynamic pathsof control through parse dags; 'reference' symbols declared fromrule translations are accessible from any subsequent ruletranslation.andP;  Examples of programs modified and annotated withNewYacc are given.andP;  NewYacc will let programmers constructinexpensive tools to translate source files into common notations.andM;</SUMMARY><DESCRIPT>Topic:     Software EngineeringGrammarsTransformsNew TechniqueTechnologyParsing.andO;Feature:   illustrationchart.andO;Caption:   Extraction and parameterization of translation tasks (chart)Outline of an open traversal on the string &quot;4 + 5 = 9&quot;. (chart)Scope of references &quot;var&quot; and &quot;val&quot; in a parse (chart)andM;</DESCRIPT><NOTE>Only Text is presented here; see printed issues for graphics.andO;</NOTE><TEXT>Parse-Tree Annotations In modern software development environmentals, manysituations arise where simple structural characteristics must be extractedfrom a source file: interfaces or other dependencies are extracted so theprogram can be managed effectively; control flow is summarized on astatement-by-statement basis so that the aggregate behavior may be analyzed,and the code may even be transformed at a high level for purposes ofoptimization, instrumentation, or program animation.andP;  In all these examples,the information to be extracted can be described using terms from thelanguage grammar.andP;  Transformation rules can be associated with productions inthe grammar, and, collectively, these rules can guide alternate traversals ofthe parse tree once it has been constructed.andP;  During the traversals, atransformed source can be output for appropriate tools in the developmentenvironment to use.andM;Describing this type of transformation is easily within the power of mostlanguage-based editing systems, as well as newer compiler-compiler resources.andO;The Cornell Synthesizer Generator is a prime example [10].andP;  The overheadneeded to employ such resources, however, even for simple applications, canbe considerable.andP;  This is true whether measured in terms of the run-timetool's size or in terms of the user time needed to construct an attributegrammer with all attributes correctly expressed.andM;The need to extract simple structural characteristics from source codeincreasingly arises in modern software development environments.andP;  Even morefrequently, developers are presented with the need to transform an availablesource program so that it can be adapted for reuse in new applications.andM;In response to these needs, we have constructed a notation, with associatedlanguage processing tools, for annotating a parse tree with transformationrules.andP;  Called New Yacc, this system is an effective tool by itself in theUNIX [TM] environment, although it is most useful when employed inconjunction with additional support tools that are designed at the same timeas the translation rules.andP;  The first goal of this article is to illustratehow well suited our notation is for a wide range of translation tasks.andP;  Suchsource-to-source translation, however, does not leverage this approach to itsgreatest extent; hence, our second goal is to illustrate the utility ofdesigning grammar rewrite rules in conjunction with the design ofenvironment-based tools to operate on the transformed source.andP;  These toolsare language independent and may be parameterized for reuse across manydomains; this capability is made possible by the availability of New Yacc, asillustrated in Figure 1.andM;NEWYACCandM;The translation tool we have devised is called NewYacc, and is derived fromthe original UNIX program called yacc (yet another compiler compiler); yaccis a parser generator specification language for LALR(1) grammars [6].andO;Normally, when yacc parses an input stream the parse tree is not retained.andO;Instead, it is discarded by reductions as in any bottom-up parser, and theonly other actions taken beyond checking whether the input stream is asentence in the language are those described by arbitrary C code interspersedin the yacc BNF by the programmer.andP;  Those actions are strictly limited toparse-time activities.andP;  In New Yacc, the normal yacc parser still works asbefore; however, the parse tree is retained.andP;  After a sentence is accepted,the New Yacc system allows the user to traverse the parse tree and directwhat additional actions should occur.andP;  These actions are controlled by whatare, in effect, rewrite rules associates with language productions in the NewYacc grammer extensions.andM;One problem with other attribute grammar-based approaches is that they are insome sense too powerful in notation and functionality for many simple tasks.andO;Compiler generators, like LINGUIST, are certainly sufficient for performingthese tasks but require extensive setup and editing of the basic languagegrammars [4].andP;  There is considerable user overhead in developing fullattribute grammars for these tasks and considerable run-time overhead inmanaging all synthesized and inherited attributes.andP;  Our approach indeveloping New Yacc was to identify a notation that is as easy to use astraditional yacc-like context-free grammars (CFGs) but one that would alsogive us enough translational power to deal with context sensitive problems.andO;Our decision to extend yacc rather than develop a system from scratch wasbased on purely pragmatic grounds.andP;  Reuse of experience, both for us and forour users, seemed to be an important key in making sure that our productwould be as widely applicable as possible.andM;This idea is closely related to generalized syntax-directed translationschema (GSDTS) [1] and the unparising rules in the Cornell SynthesizerGenerator [10].andP;  By specifying translations on individual rules of acontext-free grammar, we are able to gain much power with minimal annotationsto the grammar.andP;  For example, the classic traslation of infix to postfixnotation of an arthmetic expression E is denoted by the followingsyntax-directed translation scheme (SDTS):andM;A GSDTS allows us to attach multiple translations to individual rules.andO;Instead of building a parse tree, a GSDTS builds a direct acyclic graph (dag)since symbols may be repeated in a rule translation.andP;  By traversing the dagfrom the root in the appropriate ways we are able to obtain several desiredtranslations.andP;  Each traversal or translation in a GSDTS corresponds to asynthesized attribute in a fully attributed grammar approach.andM;NewYacc provides a concise notation for embedding translations in CFGs.andO;Productions not only have semantic actions as allowed in yacc (in the form ofC source code) but also have rule translations.andP;  In New Yacc notation, twotranslations, one for trnaslating infix to postifx and one for infix toprefix notation, are implemented by the following productions and ruletranslations for expressions:andM;[Mathematical Epression Omitted]andM;NewYacc rule translations are contained in the square brackets (the usualyacc actions, if there were any, would still be given as C source code withinbraces).andM;They symbols within parentheses at the start of each NewYacc rule translationidentify display masks, which are symbols intended to direct the traversalpath as will be described.andP;  For instance, in the above grammar, the symbolPOSTFIX indicates rules to be used in a postifx translation (traversal) and,likewise, PREFIX labels rules for prefix translations.andP;  Grammar symbols aredescribed just as in normal yacc productions, where a key symbol (here #instead of symbol $) followed by an integer i identifies the ith term of theproduction.andP;  All rule translations in NewYacc are based on these masks andthe grammar symbols.andM;Rule TranslationsandM;A rule translation in New Yacc is of the form:andM;[(displaymasklist) tbody]andM;where displaymasklist is a (possibly empty) list of display masks, and tbodyis a (possibly empty) list of grammar symbols, strings, statements(assignments and conditionals), and user-defined functions.andP;  These items inthe list are referred to as translation items.andP;  This list gives the desiredtarget pattern in terms of the yacc source production.andP;  The rule translationis analogous to a labeled translation in a GSDTS and corresponds to asynthesized attribute in an attribute grammar.andM;A traversal in NewYacc is the term for a dynamic path of control or &quot;walk&quot;through the constructed parse dag and corresponds to a single translation ofthe input.andP;  Starting at the root of the parse dag, the traversal begins basedon a user-supplied display mask.andP;  Each element in the initial ruletranslation that corresponds to this display mask is evaluated in order.andO;Leaf nodes in the dag are considered to be strings in the translation and aremerely output.andP;  Grammar symbols are considered to be functions and areevaluated recursively; that is, translations associated with theirproductions are applied.andP;  Part of our system's flexibility results fromhaving different display masks used as arguments to these recursive grammarsymbol calls.andM;For the infix to postfix example just shown, the simplest user main programlooks like:andM;main() { DAG *pt; pt = yyparse(); nytraverse (pt, printer, POSTFIX, NY OPEN);andM;}Here yyparse() is called just as in the original yacc system, except that itreturns a pointer to the constructed parse dag.andP;  This dag can now betraversed, with the POSTFIX translation being applied, by the call tonytraverse().andP;  The argument NY OPEN specifies that the subsequent traversalis open starting at the root of the parse dag.andP;  (The details of open versusselective traversals are described later.)andP;  The &quot;printer&quot; argument is merelya function that will be repeatedly called with strings of output symbolsduring the traversal.andP;  Rather than assume translations are to be output to afixed I/O port, NewYacc allows the user to specify his/her own I/O procedure.andM;Grammar symbols (e.g., #1) in a rule translation may specify new traversalmasks.andP;  If no alternate mask is given as the argument to a grammar symbol ina rule translation, then subsequent traversals proceed using the maskcurrently in effect.andP;  For example, suppose we wish to translate expressionsin the following manner: if the top-level operation is multiplication thentranslate to prefix; otherwise translate to postfix.andP;  The following NewYaccspecification performs the translation using the display mask SILLY:andM;expr: '('expr')' {$$ = $2;} [(POSTFIX,PREFIX,SILLY)#2] | expr '+' expr {$$ =$ + $3;} [(POSTFIX) #1 '' '' #3 ''+''] [(PREFIX) ''+'' #1 '' '' #3] [(SILLY)#1(POSTFIX) '' '' $3(POSTFIX) ''+''] | expr '*' expr {$$ = $1 * $3;}[(POSTFIX) #1 '' '' #3 ''*''] [(PREFIX) ''*'' #1 '' '' #3] [(SILLY) ''*''#1(PREFIX) '' '' #3(PREFIX)] | ...andP;  | term ;andM;The SILLY rule translation for the top-level product expression declares thatsubsequent traversals of the left and right parse dags should be performedwith the PREFIX mask (e.g., #1(PREFIX)).andP;  The SILLY rule translation for thisproduction also specifies that the expression itself be written in prefixform.andM;In this case, we include sample C source code for illustration that cannormally be associated with productions for execution during parsing.andP;  The Ccode in braces is executed while a sentence in the language is being accepted(i.e., when yyparse() is executed); the NewYacc rule translations, on theother hand, are applied during traversal of the parse dag (i.e., whennytraverse() is executed).andP;  Once the first traversal of a dag completes,others can be requested through additional calls to nytraverse().andM;Open TraversalandM;A traversal proceeds depth first in a parse dag starting from the root andproceeding downward according to the explicitly specified NewYacc ruletranslations for subsequent productions.andP;  Not all productions, however, needto have rule translations explicitly defined.andP;  A # character prefixed to thefront of a grammar symbol in a NewYacc rule translation or the use of the NYOPEN option in an invocation of nytraverse() at the root specifies that thesubsequent traversal should be open: if a production has an explicit ruletranslation for the descending display mask (e.g., POSTIFX) then use it;otherwise, traverse the terminals (i.e., output them) and non-terminals(i.e., sub-trees) in the same order they occur on the right-hand side of theproduction.andP;  This is called the default rule translation and can beexplicitly defined or implicitly inferred for each rule.andP;  For example, thedefault rule translation for the production &quot;expr: expr + expr&quot; is [#1 #2#3].andM;Figure 2 graphically illustrates an open traversal from a call tonytraverse() after the string &quot;4 + 5 * 9&quot; has been parsed accordin to theabove grammar.andP;  The shaded nodes are those encountered during a traversal.andO;The arrows show the incoming mask and traversal type of a translation.andO;Numbers on the nodes indicate the order they are traversed as dictated by theNewYacc rule translation for that node (shown in square brackets) chosenaccording to the incoming arrow's mask.andP;  Shaded leaf nodes denote outputtokens.andP;  Additional output is specified in the rule translations as stringsin quotations.andM;The answer &quot;49&quot; is output by the normal yacc parsing actions found in bracesassociated with most of the grammar rules.andP;  This is a result of callingyyparse().andP;  A subsequent call to nytraverse() with the POSTFIX mask on anopen traversal results in &quot;4 5 9 * +&quot; being output.andP;  This example was takendirectly from the desk calculator example in the yacc reference guide [6].andM;Selective TraversalandM;Prefixing a grammar symbol with the character andamp; in a NewYacc rule translationor using the NY SELECT option in an invocation of nytraverse() at the rootspecifies that the traversal should be selective: the default translation isa list of only the non-terminals on the right-hand side of a production.andP;  Ifno rule translation matches the descending mask during a selective traversalof a particular node in the dag, then only the right-hand side non-terminalsare traversed in order to continue the selective traversal down the parsedag.andM;Such a traversal selects only specific information from the parse structure.andO;Thus, terminal symbols on the right-hand side of a grammar rule are notechoed in a selective traversal does not have a matching rule translation.andM;A trivial example of a selective traversal is the extraction of all top-levelproducts from any input expression.andP;  Thus,andM;2 + 5 * 9 -- ( 5 * 2)andM;would be translated into,andM;5 * 9andM;The following fragment embedded in an otherwise straightforward expressiongrammar fulfills the intended function:andM;expr : '(1 expr ')' [ (PRODUCTS) ] | expr '+' expr | expr '+' expr [(PRODUCTS) #1() &quot;*&quot; +3() &quot;\n&quot;] | .andP;  .  .  | term ; term : DIGIT | term DIGITandM;;The sample string 2 + 5 * 9 -- (5 * 2) and its selective translation isgraphically illustrated in Figure 3.andP;  Assume the call from nytraverse ()specifies the PRODUCTS translation.andP;  The traversal does not extend to anysubtree whose root has the production rule &quot;expr : (expr)&quot; since the PRODUCTSrule for that production declares an empty translation.andP;  Further, since noPRODUCTS rule translations are associated with production at the leaves ofthe parse tree, the leaf nodes are not echoed to output as would be the casein an open traversal.andP;  This is shown in Figure 3 by unshaded leaf nodes.andM;ConditionalsandM;NewYacc also provides conditional tests in rule translations based on stringmatching between translation items.andP;  The following expression grammarfragment outputs only expressions that are symbolically sysmmetric aroundoperators (e.g., 2 * 2 + 2 * 2 would be accepted whereas 2 * 9 would berejecting):andM;expr : '(' expr ')' [ (SYMMETRY) #2 ] | expr '+' expr [ (SYMMETRY) IF (#1 ==#3) THEN #1 &quot;+&quot; #3 ENDIF ] | expr '*' expr [ (SYMMETRY) IF (#1 == #3) THEN #1&quot;*&quot; #3 ENDIF ] | .andP;  .  .  | term [ (SYMMETRY) #1 () ] ;andM;In this example, the equivalent of &quot;==&quot; is determined, based upon stringequivalence.andM;Variable ReferencingandM;One of the most important and simple features of NewYacc is the use ofreferences: symbols declared in rule translations that are accessible fromany subsequent rule translation in the parse dag.andP;  They correspondapproximately to inherited attributes in typical attribute grammars with animportant distinction: inherited attributes must be attached to any rule thatmay access it and all intervening non-terminals in any possible parse tree.andO;A reference is a variable whose scope is based on its position in the parsestructure, i.e., is dynamically scoped.andP;  The idea is related to non-localrules in incremental attribute grammar evaluators [5].andM;A reference can be assigned a sequence of translation items that areevaluated only when the reference is used.andP;  References are declared at thefront of rule translations after the display mask list and are prefixed withan ! character.andP;  A reference is used by prefixing an @ character to the name.andO;Figure 4 shows a grammar that uses two references called &quot;var&quot; and &quot;val&quot; torecord the first terminal string in an expression.andP;  It replaces it andalloccurrences of that terminal string in the expression with a variablename.andP;  Nested expressions in parenthesis are independent expression and aretreated similarly.andP;  This is a simplistic example intended to illustrate thereference feature.andP;  Thus, the string:andM;2 + (7 * 2) -- 2andM;becomes three statements, namely two assignments and an expression.andM;* a = 2 * b = 7 * a + (b * 2) -- aandM;The var and val references are scoped on the parse tree below the &quot;stat :expr&quot; rule and &quot;expr : (expr)&quot; where they are declared.andP;  In an attributegrammar scheme, these inherited attributes will be associated with anypossible subsequent left-hand side symbol.andP;  This is often cumbersome andillustrates the usefulness of this simpler method.andP;  Figure 5 shows the scopeand value of the var and val references in the constructed parse.andM;The example just given also illustrates the use of the last type oftranslation item: user-defined functions.andP;  The gensym () function is such atranslation item.andP;  User-defined functions may have other translation items asarguments, and these functions return strings that are incorporated into thetranslation or assigned to a reference.andM;APPLICATIONSandM;The examples given earlier are simple for purposes of illustration.andP;  One ofour goals, however, was to bring more powerful translation technology to bearon realistic software problems.andP;  The applications we describe in this sectionare representative of activities in large software development efforts; allare well served by having a simple, declarative notation for eitherextracting information from source programs or transforming that source fornew uses.andM;Note that in cases where a source is transformed, a very common operation isto install additional procedure calls that will assist in the collection ofrun-time information.andP;  In these cases, the inserted code must workcooperatively with other tools in the run-time environment, and, therefore,the support environment must provide for smooth interoperation between manytools [7-9].andP;  The environment we use for this capability is the PolylithSoftware Interconnection System.andP;  Polylith facilitates the construction ofdistributed applications spanning different host architectures,implementation language domains, and communication media.andP;  While it is notnecessary for many uses of NewYacc, Polylith is, nevertheless, an effectiveenvironment for exploting the full utility of our parse-tree annotationtechniques and is, likewise, a prime beneficiary of the NewYacc capability.andM;Code ProfilingandM;It is often valuable to augment source code with a tracing capability inorderto analyze its performance characteristics during execution.andP;  One suchcharacteristic is the number of times a particular piece of code (i.e., astatement) executes during an individual run or series of runs.andP;  Such&quot;profiling&quot; of code allows developers to identify potential bottlenecks intheir algorithms that may cause some performance degradation.andP;  For example,Figure 6 shows the profile of a trivial piece of source code.andM;Such profiling capabilities are often expensive to implement for singleprogramming languages.andP;  The cost of the tool does not justify the expense ofre-implementing many features found in the language compiler.andP;  Consequently,this capability is often included with the language compiler itself as anoption (as in the UNIX cc compiler with the -p option).andP;  While this usefultechnique unifies language changes and profiler capabilities, such aphilosophy has inherent limitations.andP;  It may cause enormous problems in themaintenance and understandability of the compiler code.andP;  Additional featurescannot endlessly be added to the compiler without some form of modularity.andM;Given a grammar for the C programming language with 174 grammar rules, wewere able to create a profiling tool with the addition of 56 NewYaccpretty-printing translations (which we reused from a C pretty printer alredywritten in NewYacc) and 20 profiling translations.andP;  (1)andM;There are two basic traversals used in code profiling, both of which areopen.andP;  This means that they echo the input program along with augmentations.andO;The first augmentation, by using the PROFILE traversal, is the addition ofprofiling function invocations along with each statement.andP;  Figure 7 displaysa fragment of the profiling translations for C statements.andP;  The source codein Figure 6 is parsed by the grammar containing this fragment and producesthe augmented code found in Figure 8.andP;  Only simple statements are profiled.andO;Compiling and executing the transformed program results in a profile.out filewhich contains the original program's execution profile.andP;  By parsing theoriginal program once again with the profile.out file available and using thePRINT traversal, one obtains the user-readable version of the program'sprofile as shown in Figure 6.andP;  The two translators can be constructed fromthe single grammar specification.andP;  The main program and UNIX shell script toexecute the entire package is shown in Figure 9.andM;Related to this profiling activity is the task of measuring statementcoverage: given a program and set of test data, how can we easily determinewhether all statements are executed by the data?andP;  (lternately, how can wedetermine whether all variables have been either accessed or set?)andP;  We haveemployed exactly the same approach as the above program profiler in order totranslate Ada source code into a program that, when executed, will generateinformation for a coverings analyzer.andP;  Such a tool has been prototyped foruse within the TAME environment [2].andM;Incremental ExecutionandM;The previous example used NewYacc to create an altered source program thatwould be compiled and run stand-alone.andP;  Greater functionality, however, canbe obtained by altering source codes so they will interoperate with othersupport tools in the execution environment.andP;  One such tool we have developedis Cinema, a tool for watching the execution of a program statement bystatement.andM;We annotated a C language grammar with traversal rules to translate a sourceprogram into one that contains various additional procedure calls; when thenew source is compiled nd linked, these calls would be bound to a programstub that would transmit information to a support tool--calledCinema--responsible for displaying that information in a useful way.andP;  Theprotocol between an application program and Cinema is very simple andconsists of a stream of integers, each representing a statement numbercurrently executing in our environment, the Cinema tool is made easilyavailable to the application via the Polylith Software Interconnectionsystem.andP;  Currently, Cinema runs in a separate window within the SuntoolsWindow Environment, where users may ask the projectionist to advance the&quot;frames&quot; (statements) at a particular rate or single step by setting theappropriate values in the Cinema window.andM;Figure 10 shows a sample C program along with its translation according toNewYacc rewrite rule.andP;  In general, only the subset of productions in thegrammar that are concerned with entire statements need have rule translationsassociated with them.andP;  compound and simple statements are augmented withMovie function calls.andP;  The remainder of the productions implicitly defer tothe default translation.andP;  A snapshot of a Cinema window with Ada source isshown in Figure 11.andM;The idea for a Cinema tool was originally inspired by Jack Dongarra, whoconstructed a monolithic parser in Fortran for Fortran in order to providelimited execution-time animation [3].andP;  Using NewYacc translations, it is easyto create such display tools for many different languages.andP;  To accommodate anew language, all we need is to annotate the grammar to generate Movie callsthat match the existing protocol.andP;  The window display component can be reusedby all tools.andM;In the same way, it is easy to construct general, language-independent toolsto assist in the analysis of data access behavior, much as has been done forFortran [3].andP;  Once a display tool has been implemented.andP;  NewYacctransformations makes it possible to automatically generate an instrumentedsource to drive the display tool.andM;Source-to-Source TranslationandM;A modern software development environment must deal with more than just filescontaining source programs--it must manage many diverse representations of aprogram that collectively characterize a software module.andP;  The PolylithSoftware Interconnection System (that we have used to join components asdescribed in previous sections) is one such system.andP;  It provides a moduleinterconnection language (MIL) for users to describe how components should beintegrated.andP;  Like many such systems, Polylith strongly separates theimplementation part of a program from the structural specification part thatrepresents it, and, as such, Polylith is itself a prime beneficiary ofNewYacc technology (suitable parse-tree annotations allow a consistentstructural representative to be extracted automatically from an existingsource program).andP;  Similarly, even without the MIL, this approach will providea way to automatically generate call-graph structures or code skeletons atlow cost.andM;In the Polylith MIL, an interface may correspond to either the use ordefinition of a procedure or datum.andP;  Special emphasis is placed on thecorrect portrayal of type information in this representation, and, therefore,the task of extracting structural information from a source program is acontext-sensitive task beyond the capabilities of just yacc.andP;  A body ofNewYacc rewrite rules can be associated with the source language grammar,however, thereby allowing structural representation that has not beennormalized to be quickly constructed.andP;  (We emphasize that the currentextraction process does not attempt to account for multiple definitions ofsome resource in a program unit.andP;  Subsequent simplifying operations will beapplied by our Polylith Binding System during an additional pass on theextracted information to resolve questions concerning multiple definitionsand use.)andP;  As an example, Figure 12 shows the minimum Polylith specificationthat would be extracted from the code in Figure 13.andP;  Values for attributessuch as PATTERN and BINARY are assigned by the Polylith Binding System laterin the analysis.andM;Another valuable source-to-source translation activity will assist users inprogram-verification tasks.andP;  We have had some success in using NewYaccannotations to transform C code into an analogous program having syntaxsuitable for input-to-computer algebra systems.andP;  Each rewrite rule attachedto a grammar production denotes the semantics of that production in terms ofthe algebra system.andP;  Using the transformed source program, developers canperform symbolic execution of their program to assist them in determining afunctional specification for existing code.andP;  Our current prototypes of thissystem are being evaluated in the TAME development environment [2].andM;DISCUSSIONandM;An essential role played by NewYacc is to allow inexpensive construction oftools that will translate language dependent information (e.g., source files)into common notations.andP;  (The interface-extraction task described earlier isjust such an example.)andP;  By decomposing traditionally monolithiclanguage-translation tasks into a set of language-processing tools in aheterogeneous environment, we achieve two interrelated goals: modularity andreuse.andP;  Each tool has a clear and independently-defined translation task, andtools that operate on common formats in the environment can be reused acrossseveral language and system domains.andM;One commonly used operation found in the actions of many yacc grammars iscode to allocate and manage storage for scanned tokens and other supportstructures.andP;  There is only one token buffer, bbtext, and this precludessimple comparisons and concatenations of token strings.andP;  Complex storagemanagement code clutters even the simplex translations.andP;  The use of functioncalls in many actions attempts to clean up this problem, but they hide andinappropriately distribute the intent of the translation.andP;  Compounding thiscomplexity is the need to adjoint other translation tasks to the samegrammar.andP;  NewYacc enables developers to retain the intent of grammar andeases the burden of translation extensions.andM;A serious problem with yacc and other parser generator systems is the lack ofinherited attributes.andP;  Their implementation in yacc would be restrictivewithout some reworking of the current model.andP;  NewYacc provides not only theability to attach references to specific rules but also eases the tediousmanagement of the flow of these &quot;attributes&quot; through subsequent grammar rulesby scoping them on the nodes in a parse below the node where a reference isdeclared.andP;  Such a scheme has also alleviated a chronic problem of yacc users:the use of global variables that simulate a dynamic scoping of variables inthe parse structure.andM;Other parser generator systems require explicit specification of ruleattributes and their flow because most are bottom-up parsers intended toeconomize on space by performing semantic actions while parsing.andP;  Ourexperience with NewYacc is that space is no longer such a problem, allowingus to keep the parse of large source files in memory.andP;  It is a much morestreamlined semantic-analysis tool than previously developed resources thathave bundled editing and synthesized attribute capabilities.andP;  Further, otherschemes for specifying semantic action often require redundant information(e.g., inherited attributes must be attached to all nodes on the dag betweendefinition and use).andP;  In contrast, our experience is that the flow ofattributes in many grammars can often be implicitly specified, and ourabstract notions of traversal types and tree-scoped variables allow us toavoid specifying this redundant information.andP;  As we have stated, traversalsand references are equivalent to synthesized and inherited attributes,respectively.andM;Even the use of references, however, in some sense violates our originalintent to keep the annotation scheme simple and decrease the use of non-localinformation in individual rule translations.andP;  Tasks that use references couldhave been rewritten using additional traversal masks, but we felt referencesprovide a convenient shorthand for many problems.andM;The idea of selective and open traversals, selecting information from aparse, or echoing out the original input with augmentations, respectively, isa useful abstraction for many application translations that use a mix of bothmethods.andP;  The ability to construct tools that quickly extract a subset ofinformation from source code or augment the code has been of great value inpromoting code reuse in our environment.andM;Finally, the value of simple annotations, as opposed to more complex schemessuch as compilers having a plethora of options, can only be fully realized inthe context of an environment, such as Polylith, which attempts to amortizethe use of language independent tools across many language domains.andP;  Grammarannotations represent a shorthand for common operations performed in manytranslation applications.andP;  Automatic storage management of token sequences,variable scoping on parse trees, and default rules for echoing the inputstring are three useful and powerful abstractions that simplify the task ofthe tool developer.andM;CONCLUSIONSandM;Our decision to devise a separate tool rather than pursue other optionsallowed us to meet additional, pragmatic constraints.andP;  For applications suchas Cinema, an alternative would have been to directly enhance individualcompilers to generate the structure and protocol streams.andP;  This option isextremely undesirable due to the associated portability and maintenanceproblems.andP;  In devising a separate tool, we chose to explore the use ofattribute grammars for producing the input needed by generic environmenttools.andP;  As is seen from our examples, many information extraction problemscan be addressed through the use of simple annotations.andM;There will still be important roles for normal yacc; in the case that contextsensitive information does not need to be extracted, then the run-time costof retaining the whole parse tree need not be paid.andP;  We have shown, however,that use of the parse-tree annotations can reduce the set-up costs previouslyassociated with many translation tasks.andP;  Our implementation of this approachpresents the look and feel of a full attribute grammar without sacrificingthe simplicity of using normal yacc declarations.andM;REFERENCESandM;[1] Aho, A., and Ullman, J. The Theory of Parsing, Translation, andCompilating.andP;  Vol II, Prentice Hall, Englewood Cliffs, N.J., 1973.andM;[2] Basili, V., and Rombach, H. D. The TAME project: Towardsimprovement-oriented software environments.andP;  IEEE TRans.andP;  Softw.andP;  Eng.andP;  14, 6(June 1988), 759-773.andM;[3] Brewer, O., Dongarra, J., and Sorensen, D. Tools to aid in the analysisof memory access pattern form FORTRAN programs.andP;  Parallel Computing 9,[1988], 25-35.andM;[4] Farrow, R. Generating a production compiler from an attribute grammar,IEEE Softw.andP;  1, 4 (Oct.andP;  1984), 77-93.andM;[5] Johnson, G., and Fischer, C. A. meta-language and system for nonlocalincremental attribute grammar evaluation in language-based editors.andP;  InProceedings of the 12th Annual ACM Symposium on Principles of ProgrammingLanguages (New Orleans, La., Jan 14-16).andP;  ACM, New York, 1985, pp.andP;  141-151.andM;[6] Johnson, S. Yacc: Yet another compiler-compiler.andP;  Bell Laboratories,1979.andM;[7] Purtilo, J. On specifying an environment.andP;  In Proceedings of the IEEE's9th International Computer Software and Applications Conference (NewportBeach, Calif., June 5-9).andP;  IEEE, New York, 1989, pp.andP;  456-463.andM;[8] Purtilo, J. A. software interconnection technology.andP;  Tech.andP;  Rep.andO;TR-2139.andP;  Dept.andP;  of Computer Science, Univ.andP;  of Maryland, 1988.andM;[9] Purtilo, J. Polylith: An environment to support management of toolinterfaces.andP;  In Proceedings of ACM SIGPLAN Symposium on Language issues inProgramming Environments (Seattle, Wash., June 25-28).andP;  ACM/SIGPLAN, NewYork, 1985, pp.andP;  12-18.andM;[10] Reps.andP;  T., and Teitelbaum, T.andP;  The synthesizer generator.andP;  InProceedings of the ACM SIGSOFT-SIGPLAN Software Engineering Symposium onPractical Software Development Environments (Pittsburgh, Pa., April 23-25).andO;ACM, New York, 1984 pp.andP;  42-48.andM;(1) Tools like grep could not be used to count the translations directly, sowe constructed a selective NewYacc translation on the NewYacc grammar itselfto extract all translations which could then be counted.andM;JAMES J. PURTILO is currently an assistant professor in the Computer ScienceDepartment at the University of Maryland, a holder of a joint appointment inthe UM Institute for Advanced Computer Studies, and a member of both the IEEEComputer Society and ACM.andP;  His current research interests are in the problemsof heterogeneity in distributed and parallel computing systems.andM;JOHN R. CALLAHAN is currently a doctoral candidate in the Computer ScienceDepartment at the University of Maryland.andP;  His current research interests arein the problems of programing heterogeneous distributed systems.andP;  Authors'Present Address: Computer Science Department, University of Maryland, CollegePark, MD 20742.andP;  purtilo@flubber.cs.umd.edu; callahan@brillig.umd.edu.andO;</TEXT></DOC>