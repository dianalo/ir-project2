<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO> ZF32-018-121 </DOCNO><DOCID>11 485 514</DOCID><JOURNAL>C Users Journal  Nov 1991 v9 n11 p42(14)* Full Text COPYRIGHT R andamp; D Publications Inc 1991.andM;</JOURNAL><TITLE>A multithreading library in C for subsumption architecture.andO;(includes related article on subsumption architecture research)(Technical)</TITLE><AUTHOR>Man, Richard F.andM;</AUTHOR><SUMMARY>The subsumption architecture is a control system for autonomousrobots that breaks down the control program into task-achievinglayers.andP;  Capabilities programmed into the robot are increased byadding more sophisticated levels of functions that inherit thecapabilities of the lower layers.andP;  This inheritance is effected bymodification of the lower levels.andP;  Subsumption architecturefeatures the ability to create concurrent asynchronous executingmodules with specific communication capabilities.andP;  A subsumptionarchitecture library for the C programming language is includedthat features a multithreading executive.andP;  The multithreadingexecutive enables the programmer to write concurrent executingmodules.andP;  A message manager included in the library launches thecommunication mechanisms.andM;</SUMMARY><DESCRIPT>Topic:     ProgrammingArtificial IntelligenceC Programming LanguageTutorialMultithreadingRobotsArchitecture.andO;Feature:   illustrationprogram.andM;</DESCRIPT><TEXT>' @  Subsumption architecture, created at the MIT Mobile Robot Lab byProfessor Rodney Brooks as a control system for autonomous robots, decomposesthe control program in terms of task-achieving layers.andP;  Starting from thelowest layer, the robot's capabilities are increased by additions of higherand higher layers of competence, with each higher level subsuming andincorporating capabilities of the lower layers by modifying lower layers'behavior.andP;  The resulting control system provides more robustness,buildability, testability, and adaptability than traditional systems.andM;A major characteristic of a subsumption architecture implementation is theability to write concurrent asynchronous executing modules with certaincommunication capabilities.andP;  Since autonomous robots have their own embeddedprocessors and C has many advantages in programming embedded systems, Idecided to augment C with a subsumption architecture library.andP;  In thislibrary, the multithreading executive provides the ability to writeconcurrent executing modules and the message manager implements thecommunication mechanisms.andM;This subsumption language contains features similar to MIT's first generationFSM-based subsumption language, plus some features from the BehaviorLanguage.andP;  I hope to add more Behavior Language features as time goes on.andO;Most of these functions are written in standard C, with some target hardwarespecific functions in assembly.andP;  All target-specific functions are isolatedinto their own modules and can be replaced easily when switchingenvironments.andM;Although the library w writing subsumption architecture-based robot controlsoftware, it may also be used to write simulation software that runs on PCsor workstations.andP;  To date, I have tested the library in PC DOS and Sun 3 UNIXenvironments, and on a Motorola MC68HCll EVB evaluation board with 16K ofRAM.andP;  (My own mobile robot project, which uses the HCll EVB as the maincontroller, is mentioned briefly at the end of this article.) Overview Of TheMultithreading ExecutiveandM;With the multithreading library, a single program may contain multipleexecuting threads, each being an execution instantiation of a function in theprogram.andP;  The executive's scheduler, operating independently of the host OSscheduler, controls which thread to run at a given time.andM;Figure 1 lists the executive functions included in the library; Figure 2, themessage manager functions.andP;  (Because the code has been commented and isprovided in the listings, I will not give a detailed explanation of each ofthe functions; instead, I will outline the way the system works.)andM;The function ExecInit() initializes the system.andP;  A program must call itbefore it calls any other functions in this library.andM;ExecCreateThread() creates the context for a thread but does not execute it.andO;A program calls this function with the address of a thread function, itsrequired stack size, and two pointer sized initial arguments.andO;ExecCreateThread() may be called anytime, including in another concurrentlyrunning thread as well as multiple times within the same thread function.andO;(Such thread functions should obey the usual rules of reentrancy, e.g., byusing automatic variables instead of global variables.) The first argument tothis function specifies the thread type: this will be used when more featuresare incorporated from the Behavior Language.andM;After a user program creates all the initial threads, it must call thefunction ExecStart() to start the scheduler.andP;  Once started, the schedulernever returns control to the original caller but will pass control torunnable threads in a round-robin manner.andM;This executive supports only the cooperative style of multitasking - that is,a thread only gives up control back to the executive when it explicitly callsa particular library function.andP;  Although in theory not as suitable aspreemptive multitasking for real time programming, the use of subsumptionarchitecture makes this mostly a non-issue.andP;  (Both of Brooks's subsumptionlanguages use cooperative multitasking as well.) A thread typically executessome initialization code and then calls the MsgGetMsg() function to get amessage.andP;  MsgGetMsg() immediately calls the thread-switching functionExecSwitch(), which gives execution control to the next runnable thread.andO;After receiving control, a thread should call MsgGetMsg() again within areasonable&quot; time to ensure that other threads have a chance to run.andP;  Thus thecall to MsgGetMsg()is usually done in a non-terminating while loop.andP;  If athread function ever returns, its resources are reclaimed and it will not beexecuted again.andM;As an example, consider the following program that creates two threads:andM;void thread(void)andM;MsgWatchTimer(O);andM;while (MsgGetMsgo)andM;printf(&quot;I am alive, threadandM;%d\n&quot;, ExecGetThreadID());andM;}int main()andM;{ExecInit();andM;ExecCreateThread(NORMAL_PROC,andM;thread, 10000.andP;  0, 0);andM;ExecCreateThread(NORMAL_PROC,andM;thread, 10000,  .andP;  0);andM;ExecStart();andM;When run, the program     prints the followingandM;Output:andM;I am alive,     thread 0andM;I am alive,     thread 1andM;I am alive,     thread 0andM;I am alive,     thread 1andM;I am alive,     thread 0andM;(etc...andP;  )andM;There are  three types of messages: timer, port, and semaphore.andP;  A threadnotifies the message manager of what types of messages it wants to receive byusing the MsgWatchTimer(), MsgWatchPort(), or MsgWatchSemaphore() functions.andO;All of these functions return a unique message identifier.andP;  When a messagearrives, the message manager places the receiving thread at the end of aqueue of runnable threads and stores the message identifier in the queueentry; it then calls the scheduler function ExecSwitch.andP;  Upon receivingcontrol, the scheduler takes the first thread off the runnable queue threadand gives control to it.andP;  From a thread's point of view, it calls theNsgGetMsg() function and the library function returns with a messageidentifier.andM;This event-driven style of cooperative multitasking is similar to those usedby other cooperative multitasking OSs such as MS Windows v3.0 and the AppleMacIntosh Multi-Finder.andP;  I have thus chosen the name MsgGetMsg() deliberatelyto be close to the names of the corresponding functions in these OSs.andM;The simplest message to watch for is the timer message.andP;  To do this, a threadcalls the function KsgWatchTimer() with the time delay factor.andP;  The threadwill then be runnable after the specified time has elapsed since it was lastrun.andP;  In this implementation, the unit for time delay factor is proportionalto the number of threads currently watching for timer messages.andP;  I may changethe time delay factor to a constant time unit later, to match thecorresponding concept in Brooks's languages.)andM;Threads communicate through a port&quot; message.andP;  A port variable can be any Cvariable, although it is best to use a local variable for re-entrancyreasons.andP;  To allow other threads to identify a port variable, a thread mustassociate a unique identifier with it.andP;  Port variables serve as theinput/output &quot;register&quot; interface of a thread, and their correspondingidentifiers serve as their name&quot; interface.andP;  An ASCII string serves as a goodunique identifier for a port variable (or a semaphore, see below).andP;  Forefficiency reasons, a program must convert the string to a unique index valueand use it in place of the ASCII string.andP;  (This library contains the functionStringToAtom() for this purpose.andP;  It returns the same unique index value fortwo ASCII strings if and only if they are identical.)andM;A program informs the message manager of the binding between a port variableand a port identifier by using the MsgWatchPort() or MsgOpenPort() function.andO;All other message manager functions only use port identifiers.andM;A port variable may be unidirectional or bidirectional.andP;  A thread sets a portvariable for reading by calling the function MsgWatchPort() with a portidentifier and the address of its corresponding port variable.andP;  When anotherthread indirectly writes to that port variable, the message manager notes thearrival of this message to this thread and takes the appropriate action.andM;A thread sets a port for writing by calling the function MsgConnectports()with an output port identifier and an input port identifier (the destinationport) in another thread.andP;  Multiple input port variables (up to asystem-defined limit) may be connected to a single output port.andP;  When usingMsgConnectPorts  , no actual output port variable is required.andO;Alternatively, a thread can set a port for writing by calling the functionMsgOpenPort() with a port identifier and the address of a port variable.andO;Here, it is assumed that other threads will connect their input portvariable(s) to this output port.andP;  A lower layer of competence uses theMsgOpenPort() function to provide feedback values for the higher layers.andM;A thread writes to a port by calling the function NsgWritePort() with theoutput port identifier and the value it is writing.andP;  This function updatesthe value of the output variable (if it was registered via MsgOpenPort () andfinds all threads with input port variables connected to this output port (byMsgConnectPorts()).andP;  It then updates these input port registers and placesthe threads on the runnable queue.andM;A thread calls MsgSuppressports() with an output port identifier and theidentifier of an output port  usually in another thread) to be suppressed.andO;The semantic of this function is that whenever the thread writes to theoutput port (the first argument to the MsgSuppressPorts() function) viaMsgWritePort(), all the input ports attached to the suppressed port (thesecond argument) will receive this value for a system-defined period.andP;  Anyother writes during this period is ignored and will not get passed to theattached ports.andM;A thread calls MsgInhibitPorts() with an output port identifier and theidentifier of an input port to be inhibited.andP;  Whenever the thread writes tothe output port with MsgWritePort(), the inhibited input port will receivethis value (for a system-defined period) instead of from the output port thatit may be connected to.andM;A thread also may read the current value of any output port variable bycalling MsgPeekPort() with the port identifier of an output port variable.andO;Note that the system does not care if you specify the same port identifier(i.e., same ASCII string) for two different port variables.andP;  The result isundefined.andP;  MsgConnectPorts() may also be called anywhere, including infunctions that are lexically far from the threads whose variables areinvolved in the call.andP;  However, since this practice obscures the interfacebetween the threads, it is not recommended.andP;  As a programming style, I useASCII strings in the form of either thread_function-namein.digit (e.g.,andO;alphaPos.in.2) ,  or threaccfunction-nome.out.digit, where &quot;in&quot; and out&quot;signify an input or output register respectively.andP;  A thread may wait for asemaphore by calling the function MsgWatchSemaphore() with a uniqueidentifier.andP;  The second argument to the function specifies whether the threadis watching for the clearing of or the setting of the semaphore.andP;  A semaphoreis set and cleared via the functions MsgSetSemaphore() MsgClearSemaphore()respectively.andP;  Implementation Of The Multithreading ExecutiveandM;There is almost enough machinery in standard C to write all the functions inthe multithreading executive.andP;  The standard library functions setimp() andlongimp(), which implement non-local gotos, are enough to implement thethread-switching function ExecSwitch().andP;  These functions work in thefollowing ways: when setimp() is called with a jump buffer, it returnsimmediately with the value 0.andP;  Later, if the function longjmp()is called withthat same jump buffer, then execution returns to where the setimp() iscalled; this time as if setimp() returns with the second argument toZongimp() as its value.andP;  If the second argument of longimp() is 0, thensetjmp() returns a value of 1.andM;The internal function ExecSwitch() first checks for possible stack overflow,then records the current thread's execution context via a call to setjmp().andO;It then calls another internal function, execRunNewThread(), which takes thefirst thread off the runnable queue and switches back to that thread via acall to longjmp().andP;  The execution continues in this new thread as if its callto setjmp() inside ExecSwitch() has just returned again with a messageidentifier.andP;  ExecSwitch() then returns to MsgGetMsg() which in turn returnsthe message identifier the thread that calls it.andM;One concern with these functions is that setjmp() and Iongjmp() do notaddress the issue of setting up the initial stack pointer for each thread.andO;In theory, longjmp() should not be called if the function that originallycalls setimp() has already exited since the stack context may no longer bevalid.andP;  Some C-and C++-based multithreading executives deliberately ignorethis constraint so that the stack space for all the threads is allocated onthe stack of the running program.andP;  This technique, however, makes threadstack allocation tricky and obscure.andP;  Under this scheme a program may beforced to create all the possible threads at once, because the alternative ofallowing a program to create a thread anytime is difficult to implement.andM;I chose a different approach to allocate thread stack space.andP;  TheExecCreateThread() function allocates stack space for a thread dynamicallyvia the standard C function calloc() and stores the address of the returnedvalue in the thread's context.andP;  When calling a thread function for the firsttime, the scheduler function ExecSwitch() changes the stack pointer so thatthe new thread will use the correct stack pointer.andP;  This is only done at theinitial call to a thread since normal thread-switching uses the functionssetjmp() and longimp()to save and restore execution context, including thestack pointer.andM;Since there is no portable way of changing stack pointers in C, it is doneusing a small assembly routine.andP;  I wrote a prototype C routine that doeseverything except modify the stack pointer, then compiled it to assembly.andP;  Ithen modified the assembly file to handle stack switching for a particularmachine environment.andP;  This compile/modify technique makes it relatively easyto port this part of the system to different enviroriments.andP;  I did encounterone problem with this approach.andP;  The library in the HCll cross compiler thatI am using assumes that if a stack address is lower in value than a heapaddress, then the heap must have overrun the stack.andP;  This would be true innormal cases since the heap is allocated upwards from the bottom of a freedata segment and the stack is allocated downward from the top of the samedata segment.andP;  It is not true here because the &quot;stack&quot; is really another heapitem, so I had to write a very simple-minded linear stack allocator tocircumvent this problem.andP;  About The Listings Listing 1 contains themultithreading executive.andP;  Listing 2 (sans the servo interface code) is thecontrol software for a simple six-legged walking robot.andP;  The Listing 2 codeis based on the description of a simple walking algorithm for Genghis in [4].andO;Notice that there is no routine that is consciously doing any walking - theclosest it comes is that the highest layer function, TripodGait(),alternately raises its legs in a tripod gait.andM;This code is intended to control the movement of a six-legged &quot;ladybug&quot; robot(for which the hardware is being built by Donald Doughty).andP;  The robot's brainis an MC68HCll EVB, chosen because it contains many features that are usefulfor embedded work, such as a serial and parallel interface, some AJDconverters, and several timers on one chip.andP;  The EVB emulates all thefeatures of the CPU while providing a ROM monitor, 16K of user RAM space andan RS-232 port.andP;  The monitor and the RS-232 port allow programs to bedeveloped on the host, typically on an IBM PC, and executed on the EVB.andP;  TheEVB interfaces 12 Futuba servos - two per leg - through a custom designedinterface board.andP;  One servo moves the leg back and forth and the other movesit up and down.andP;  (As of this writing, the hardware for the project, which ispart of my master's thesis, is not yet finished and the code is incomplete;if you are interested in the project, you may contact me at the address givenin my bio.)andO;</TEXT></DOC>