<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF109-683-361  </DOCNO><DOCID>09 683 361.andM;</DOCID><JOURNAL>Hewlett-Packard Journal  Dec 1990 v41 n6 p74(7)* Full Text COPYRIGHT Hewlett Packard 1990.andM;</JOURNAL><TITLE>An object-oriented message interface for testing the HP 3000 datacommunications and terminal controller. (technical)</TITLE><AUTHOR>Maioli, Frederic.andM;</AUTHOR><SUMMARY>The software for the Hewlett-Packard 2345A data communications andterminal controller (DTC) is based on a multiprocessor,multitasking operating system where parallel processors or tasksexchange messages to communicate.andP;  Testing is one of the importantsteps in developing a task.andP;  A message machine, a program thatsimulates the message environment of the task being tested, isbuilt.andP;  A new method is presented that uses object-orientedconcepts to write a message machine to test the HP 2345A DTC PADsupport software.andP;  A declarative, not procedural, program, it issmaller in code size, more reusable, and easy to adapt to newmessage structures.andP;  A performance decrease is overcome by runningtests on a more powerful hardware platform.andM;</SUMMARY><DESCRIPT>Company:   Hewlett-Packard Co. (Products).andO;Ticker:    HWP.andO;Product:   HP 3000 (Computer system) (Computer programs)HP 2345A Distributed Terminal Controller (Computer programs).andO;Topic:     Research and DevelopmentObject-Oriented ProgrammingTestingData CommunicationsControllers.andO;Feature:   illustrationchart.andO;Caption:   Testing a task. (chart)Messages exchanged between the two tasks server and device.andO;(chart)Byte-code syntax of the messages in Fig. 2. (chart)andM;</DESCRIPT><TEXT>[FIGURES HAVE BEEN OMITTED]andM;Creating a general-purpose message compiler/decompiler using symbolicexpressions, expert systems concepts, object classes, and inheritance reducessoftware testing overhead and improves test readability and portability.andM;THE HP 2345A DATA COMMUNICATIONS and terminal controller (DTC), whichoperates with the MPE XL 2.0 operating system, provides access to X.25networks, PAD (packet assembler/disassembler) support, asynchronous terminalsand printers connected locally or through modem links, back-to-backconnections, and other capabilities.andP;  All of these services can be shared bymultiple MPE XL systems connected through a local area network (LAN).andP;  Withthe back-to-back feature, a DTC can work without a host.andM;The HP 2345A DTC software is based on a multiprocessor, multitaskingoperating system.andP;  In this system, parallel processes or tasks communicateamong themselves by exchanging messages.andM;An important step in developing a task is testing it.andP;  This is done bybuilding a message machine, a program that simulates the message environmentof the task under test.andP;  During the development of the DTC network software,several message machines were written in the MPE XL operating system and onHP 9000 Series 200 Pascal workstations.andM;Reusing an existing message machine can seem very attractive to someonestarting a new project.andP;  However, even when this can be done effectively,each version will usually be maintained separately, and the benefits ofhaving some common code are gradually lost.andM;Looking for a better solution, we have used object-oriented concepts to writea message machine for testing the HP 2345A DTC PAD support software (seearticle, page 63).andP;  The program is declarative rather than procedural.andP;  Thismakes it smaller in code size, more reusable, and very easy to adapt to newmessage structures.andP;  The main drawback is a decrease in performance, whichcan be overcome by running the tests on a more powerful hardware platform.andO;Task interactionandM;As already mentioned, a task is a process inside the DTC.andP;  A byte-codemessage is a sequence of bytes that a task sends to another task.andP;  The syntaxof the different messages a task can send or receive constitutes its messageinterface.andM;Each task maintains its own behavior as it interacts with its environment bysending and receiving messages.andP;  Testing a task consists in checking itsbehavior by sending it a sequence of messages or a message script.andP;  Thetested task reacts to the message script by sending back a sequence ofmessages that constitutes a message trace.andM;A message script file is written in a message source language and isinterpreted by the message machine, which sends the corresponding byte-codemessages (see Fig.andP;  1).andP;  The advantage of having a message source languageand an interpreter is the readability of the message scripts.andP;  This alsomakes it possible to send a message from an interactive interface, run amessage script in step-by-step mode, or put the tested task in a determinedstate (to debug it, for example).andM;The message machine catches any message sent by the tested task in itsbyte-code format, translates it to source format, and logs it in the messagetrace file.andP;  Translating from source to byte code is called messagecompilation, and the reverse operation is called message decompilation.andM;The complete task test is a set of message scripts that test as much aspossible of the task's behavior.andM;In the process of maintaining the DTC software, new versions of a task may bereleased.andP;  Compatibility of the old and new versions is checked by runningthe same task test on both versions and comparing the respective messagetraces.andP;  This operation is called a regression test because the comparison isexpected to validate the new version's compatibility.andM;The usual way to run a regression test is to run a comparison program such asthe HP-UX diff utility, which searches for any differences between twomessage trace files.andM;An ExampleandM;To illustrate these concepts, let us consider a protocol for communicationbetween a task named device and a task named server.andP;  These tasks have beenchosen for purposes of this example, but one can imagine that the device taskmanages a set of RS-232 terminal links, while server handles a computersystem's 1/0.andM;Fig.andP;  2 shows an example of a message exchange between the two tasks serverand device.andP;  Five different messages can be exchanged.andP;  The open-sessionmessage signifies that a device has become active and requests that a sessionbe opened (logon).andP;  The close-session message is sent when a device logs off.andO;The write message sends data to a device.andP;  The read-line message occurs whena device enters a line of text.andP;  The read-break message signifies that abreak interrupt key signal has been received from a device.andM;The byte-code syntax of these messages is described in Fig.andP;  3.andP;  Theinformation inside a byte-code message is structured in fields.andP;  Themessage-code field is a 2-byte integer containing a constant related to thetype of message.andP;  The dest-task field is one byte long and is used by theoperating system to identify the task the message is going to.andP;  In thisexample the ASCII value is 25 for the server task and 32 for the device task.andM;The data field is a string of bytes representing the content of a write orread message.andP;  The data-length field is a 2-byte integer field representingthe length of the data string in bytes.andM;The break-code field is a 1-byte field that distinguishes the read-linemessage (value = 0) from the read-break message (value = 1).andP;  These messageshave the same message code.andP;  The dev_num field is a 2-byte integer thatidentifies the hardware device managed by the device task.andM;As mentioned above, our message machines define a source language associatedwith the byte_code message syntax.andP;  Examples of source messages are: !!!andO;BEGIN TABLEandM;open-session     desl_task: 25 dev_num; 30andM;read_line        dest_task: 25 dev_num: 30 data: &quot;listf, 2'andM;read_break       dest_task: 25 dev_num: 30andM;close_session    dest_task: 25 dev_num: 30 !!! END TABLEandM;In this example, each line represents a message to server, which isidentified by the dest_task value 25.andP;  The first symbol in a line identifiesthe message.andP;  It is followed by a sequence of identifier/value pairs.andP;  Theidentifier is a parameter name (terminated by :) corresponding to a field inthe byte_code syntax, and the value is the value of this parameter in themessage.andM;The byte_code fields corresponding to parameters in source messages arecalled parameter fields.andP;  Examples are dest-task, dev_num, and data.andP;  Not allthe fields of a byte_code message are parameters in the source syntax.andP;  Thereare also constant fields, or selector fields, whose value identifies a uniquemessage structure.andP;  Examples are message_code and break_code.andP;  Finally, thereare fields, such as data_length, whose values depend on the values of otherfields.andP;  These are called computed fields.andM;Notice that the list of source messages given above could be used as amessage script by a message machine and would correspond to a test of server.andO;This reproduction of the dialog of the example of Fig.andP;  2 would make themessage machine produce the message trace: !!! BEGIN TABLEandM;writedest_task: 32dev_num: 30data:'XYZMPEXLA.30.00.TUE,andM;MAY 29, 1990'andM;writedest_task;32dev_num:30data: ' :'  writedest_task:32dev_num:30data:'FILE1 FILE2 FIL'  writedest_task:32dev_num:30data:  :' !!! BEGIN TABLEandM;Conventional Compilation and DecompliationandM;When one wants to reuse a message machine and adapt it to new messageformats, most of the changes consist of rewriting the message compilation anddecompilation procedures.andM;There is a procedure compile-message, which takes as input a line of messagesource code and returns the byte-code format of this message: procedurecompile-message(line)andM;local variables: idf, resultandM;read an identifier idf in line;andM;if idf =  'open_session' {andM;let result be a new stringandM;write the integer 20 on 2 bytes in result;/* message_codeandM;compile_parameterin_type_size(line,'dest_task', result,andM;'integer',1);andM;compile_parameter_in_type_size(line,'dev_num',result,andM;integer',2);andM;return result; }andM;else if idf = 'close-session'andM;else if idf = 'write'andM;else error('bad message name')andM;end ifandM;return result end procedureandM;In this procedure, the message type is identified.andP;  Then the byte_codemessage is synthesized parameter by parameter in the following procedure:procedure compile_parameter_in_type_size(line,param_name,andM;result,type,size)andM;local variables: idfandM;read an identifier idf in line;andM;if idf and param_name are not the same then error (&quot;badandM;parameter name&quot;);andM;if type =  integer' thenandM;read the integer int in decimal format in line;andM;write the integer int in binary on size bytes in result;andM;else if type =  string' then ....andM;end if end procedureandM;Decompiling a message is slightly more difficult.andP;  First, one must match amessage structure to a byte_code format.andP;  This is done by a decision treethat tests values in fixed fields:andM;procedure decompile_message(byte_message)andM;local variables : message_code, break_codeandM;let message_code be the integer from byte 1 to byte 2 inandM;byte_message;andM;if message_code = 20andM;return decompile_open_session(byte_message);andM;else if message_code = 21andM;else if message_code = 23andM;let break_code be the integer at byte 6 in byte_message;andM;if break_code = 0 thenandM;return decompile_read_line(byte-message);andM;else if break_code = 1 thenandM;end ifandM;else error(&quot;bad message code&quot;);andM;end if end procedureandM;There is a procedure for each message structure, which is called when themessage structure has been determined.andP;  For example, the one corresponding tothe open-session message is:  procedure decompile_open_session(byte_message);andM;local variables: resultandM;let result be a new string;andM;write  request_session' in result;andM;decompile-dest_task_in(byte_message, result);andM;decompile_dev_num( ...andM;return result; end procedureandM;For each parameter, there is the reciprocal of the parameter compilationprocedure.andP;  One example is: proceduredecompile_desL_task_in(byte-message,result)andM;let dest_task be the integer at byte 3 in byte_message;andM;write  dest_task' and dest_task in result end procedureandM;Writing the message compilers and decompilers in algorithmic language issimple for a few messageb, but it is more difficult for 50 messages, atypical number for the message interface of a real DTC task.andP;  The messagecompilers and decompilers are programs that are very dependent on messagebyte_code and source syntax, so they contain much redundant information.andM;This approach has several drawbacks.andP;  First, the bytecode_to_message matcheris complex, difficult to validate, and difficult to maintain when new messagestructures are added.andP;  Second, some fields are common to several messages.andO;It would be possible to write some partial compilation and decompilationprocedures common to several messages, but modifying the syntax of onemessage could require modifications in other messages.andP;  Third, whenandM;changing or adding a field, there are interdependent modifications in thecompiler and in the decompiler.andP;  This creates the need for a compatibilitytest between compilation and decompilation procedures.andM;A further drawback of the conventional approach is that, for the same scriptand the same tested task, some parameters can have different values inmessage traces that do not constitute regression test violations.andP;  Forexample, there can be a message trace that contains some information aboutthe current date: write dest_task: 32 dev_num: 30 data:  XYZ MPE XL A.30.00.andO;TUE,andM;MAY 29, 1990'andM;This causes useless differences between message traces that increase thedifficulty of analyzing these files and of automating the tests.andM;A final drawback of the conventional approach is that no messagedocumentation is maintained as the message machine evolves.andP;  Thedocumentation used in reality is the source listing of the compilation anddecompilation procedures.andM;Using Symbolic Programming ConceptsandM;Object_oriented languages provide symbolic expression facilities.andP;  This gaveus the idea of representing the message source language using symbolicexpressions.andP;  This is the same as using lists in Lisp,' arrays in Smalltalk,or terms in Prolog.andM;The traditional source message: open_session dest_task: 25 dev_num: 30 isequivalent to the symbolic expression (using Lisp lists, for instance):andM;(open_session  dest_task 25)  dev_num 30))andM;More generally, any source message will have the syn -tax:+  andless;message nameandgt; andless;Parameter nameandgt; andless;parameter valueandgt;)')andM;There are significant advantages to the use of symbolic expressions.andP;  First,it is easy and improves readability to give name values instead of integervalues to some parameters.andP;  For example,  dest_task 'device') is better than dest_task 32).andM;Second, intelligent regression is possible.andP;  When comparing message tracefiles, the HP_UX diff utility provides a byte_to_byte comparison.andP;  It is abetter solution to compare two symbolic expressions by traversing theirstructures (like the equal function in Lisp').andP;  This is because:andM;* It is more efficient to compare symbols than the bytes of strings.andM;* One can customize the comparison algorithm by not comparing some parametersthat contain variable information, such as the current date.andM;* The formatting of regression violations is easily improved.andP;  The incorrectmessages are displayed rather than the incorrect lines.andM;* It is easier to recover automatically after a nonregression violation andcontinue the comparison, since the comparer synchronizes on messages ratherthan lines.andM;A third advantage of using symbolic expressions is automatic indentation.andO;Some environments provide indenting formatters for symbolic expressions (suchas Lisp pretty printing').andP;  Using it, large source messages with manyparameters are very readable:andM;(command-name (param1 val/1)andM;(param2 val2)andM;(param3 val3)andM;We used Smalltalk arrays and found it simple to implement such a printingformatter.andM;Specifying the Compiler and DecompilerandM;The most important drawback in adding or modifying a new message format inthe message compiler and decompiler is that the same information for messagetranslation is coded at least twice, once in the compiler and once in thedecompiler.andP;  This is a source of errors, code overhead, unreadability, andnonportability of the message machine.andP;  The question arises: Wouldn't it bepossible to define only once the necessary information for both compilationand decompilation? Many symbolic programs define a data formalism and aninterpreter over this formalism.andP;  Most of the behavior of these programs isembedded in specification data bases rather than procedures.andP;  This is thecase for most expert systems, which contain an interpreter (the inferenceengine) over a specification of the expertise (the rule base, which is a database).andP;  The question is then: Does there exist a formalism to specify themapping between the source format and the byte-code format of a message, withgeneral purpose compiling and decompiling procedures?andM;We have been able to answer this question in the affirmative.andP;  We haveobtained an efficient specification formalism, which now covers 95% of ourmessage compilation and decompilation.andP;  The remainder is implementedconventionally.andM;Our formalism makes the distinction between two kinds of fields in messages.andO;There are fields with a statically known position in the byte-code syntax,and fields with a statically unknown position.andP;  &quot;Statically&quot; means that thefield is always located at the same place in the byte code.andP;  This locationdoes not depend on the message content.andP;  For example, the dest_task field inall messages has a statically known position (at byte 3) in all byte-codemessages, but the data field does not have a statically known position, sincethe end position of the field is known only when the message to be compiledor decompiled is known.andM;To simplify, we will call fields with a statically known position positionedfields and fields with a statically unknown position unpositioned fields.andO;The specification formalism only covers positioned fields.andP;  Given a message'sspecification, we have written the general-purposeandM;compilation and decompilation procedure that interprets the specification.andM;The following symbolic expressions describe the specification of the messagesof the example above:andM;* Declaration of all the parameter fields of all the messages and their types(integer, string, or symbolic integer which translates a string to aninteger):andM;parameter_fieldsandM;(devnum integer)andM;(dest_task  SymbolicInteger  'device'32)andM;'server' 25)))andM;(data String)andM;* Declaration of constant and computed fields: (constan_fields message_codebreak_code) (computed_fields data_length)andM;* Declaration of the size (in bytes) of each field in theandM;byte-code messages (positioned fields only): (fields_sizeandM;(message_code 2)andM;dest_task 1)andM;dev_num 2)andM;(data_length 2)andM;(break_code 1))andM;Specification of all the messages.andP;  For each message, there is an expressionfor called a metamessage.andP;  A metamessage formalizes the notion of messagestructure.andP;  First, there is the corresponding message name, then threesubexpressions called metafields.andP;  The parameter_fields metafield containsall parameter field names.andP;  The con -stant_fields metafield maps values toconstant fields.andP;  The byteCode_order metafield defines how the fields areordered in byte code.andM;(message_specsandM;(open_sessionandM;parameter_fields dev_num dest_task)andM;(Gonstant_fields  message_code 20))andM;(byteCode_order message_code dest_task dev_num))andM;(close_session ...andM;(write ...andP;  )andM;(read_lineandM;(parameter_fields dev_num desl_task data)andM;constant_fields (message_Gode 23)andM;(break_code 0))andM;(byteCode_order message_code dest_taskandM;dev_num break_code))andM;(read_breakandM;(parameter_fields dev_num dest_task)andM;(constant_fields (message_code 23)andM;(break_code 0))andM;(byteCode_order message_code dest_taskandM;dev-num break_code data_length))andM;The message specification is now completed.andP;  Before using it to performcompilation and decompilation, there is an initialization step called themetacompilation phase where the specification is checked for correctness.andO;Examples of checked constraints are field name consistency and collisions,and field juxtaposition consistency in each message.andM;The metacompilation also generates intermediate results.andP;  A field_positionmetafield is added to each metamessage to complete bytecode_orderinformation.andP;  It relists the byte_code fields, adding to each of them thepair andless;first byte, last byteandgt;.andP;  This pair defines the position of the field inthe byte-code string:andM;(message-specsandM;...(read_breakandM;...(byteCode-Wsition  message-code 0 1)andM;(dest_task 2 2)andM;dev_num 3 4)andM;(break_code 5 5)))andM;A constant field always has the same position in all the messages thatcontain it.andP;  Otherwise, it would be impossible to map a byte-code onto amessage structure.andP;  The positions of all constant fields are kept in theconstant_field_position list: (constant_field_positionandM;(message_code 0 1)andM;(break_code 5 5))andM;The decoder tree is used by the decompiler to identify a message from a bytecode.andP;  In the example, it is: (decoder_treeandM;(message_codeandM;(20 request_session)andM;(21 close_session)andM;(22 write)andM;(23 (break_code  O read_line) (1 read_break))))andM;The syntax is:andM;andless;decoder_treeandgt;andM;andless;message nameandgt;;andM;andless;constantfield nameandgt;  andless;constantfieldvalueandgt;andless;decoder_treeandgt;)')andM;It is used in the following function, which is used by the decompiler:andM;function decode_bytes(t,str)andM;/* find the message structure name associated with the byte codeandM;str by performing the tests specified in the decoder tree */andM;local variables: x,y,val,cName,n,[v.sub.1] [V.sub.n],[t.sub.1]...[t.sub.n,|andM;if t is a name, return t;andM;t has the form (cname [v.sub.1.t.sub.1])...(V.sub.n.t.sub.n))andM;otherwise error(&quot;bad decoder tree&quot;);andM;let x and y be such that the constant field_position' list contains:andM;constant_field_position ...andP;  (cName x y) ...andP;  )andM;let val = the integer coded from byte x to byte y in strandM;let i , 1 andless;= i andless;= n such that [V.sub.i] = valandM;otherwise error(&quot;undecodable byte code&quot;);andM;return decode_bytes([t.sub.i],str); end functionandM;The decoder tree takes the place of the decision tree in the conventionaldecompilation procedure.andP;  It is automatically generated at themetacompilation step:andM;procedure generate-decoder-tree(ist)andM;/* return a decoder tree mapping one of the message names in the list 1stfrom a byte code string */andM;local variables: n,[V.sub.1]..[V.sub.n],i,[m.sub.i] c,S, [V.sub.k], sublist,subdecoder,result suppose 1st has the form ([m.sub.1]...[M.sub.n])andM;if n = 1 return [m.sub.1];andM;endifandM;/* find a constant field that discriminates messagesandM;find a constant field c such thatandM;for all i, 1 andless; = i andless; = n consider the metamessage:andM;([m.sub.i]...constant_fields...([c V.sub.i]) ...andM;and let S be the set of all viandM;and S contains at least two elementsandM;if not found error(&quot;impossible to build a decoder tree&quot;)andM;end findandM;let result = an empty listandM;/* recursively build the tree */andM;for all [V.sub.k] in SandM;sublist = the list of mi such that [V.sub.i] = [V.sub.k]andM;subdecoder = generate_decoder_tree(sublist)andM;put subdecoder to the end of resultandM;end forandM;add c to the beginning of resultandM;return result  end procedureandM;The general_purpose compiler looks as follows (for simplicity, type checkingand parameter value translation have not been indicated here):andM;function compile(1st)andM;/* translate the source message 1st in byte codeandM;local variables: m,n,[p.sub.i][P.sub.n],[V.sub.i][V.sub.n]m,[c.sub.1][c.sub.m], [W.sub.1]..[W.sub.m], p,[b.sub.1]..andO;[b.sub.p],[X.sub.1],[..X.sub.p],[Y.sub.p],[Y.sub p],i,j,resultandM;suppose 1st has the form: (m ([p.sub.1.V.sub.1)...([P.sub.n.V.sub.n))andM;find the metamessage of the form:andM;(m  parameter_fields [p.sub.1]...[P.sub.n])andM;(constant_fields ([c.sub.1.W.sub.1]) ...andP;  ([c.sub.m.W.sub.m))andM;(byteCode_position ([b.sub.1.X.sub.1.y.sub.1])...andM;([b.sub.p.andP;  x.sub.p.andP;  y.sub.p]))andM;otherwise error(&quot;syntax error&quot;)andM;/* initialize byte code */andM;let result be an empty stringandM;/* explained later */andM;call the procedure attached to m to compute computed field valuesandM;for 1 andless; = i andless; = pandM;if j exists such that [b.sub.i] = [c.sub.j] thenandM;/* code constant field */andM;code [w.sub.j] as integer from byte xi to byte [y.sub.i] in resultandM;else if j exists such that [b.sub.i] [P.sub.j]andM;/* code parameter fieldandM;code [v.sub.j] as integer from byte [x.sub.i] to byte [y.sub.i]andM;in resultandM;else if ...andP;  /* and so on for computed parametersandM;end ifandM;end forandM;/* explained laterandM;call the procedure attached to m to compile unpositioned parameters to resultend functionandM;The decompiler is as follows: function decompile(str)andM;/* translate the byte code string str in source messageandM;local variables: t,m,n,[p.sub.1]..[p.sub.n],p,[b.sub.1]..[b.sub.p][x.sub.1]..[x.sub.p],[y.sub.1]..[y.sub.p],result, i,j,valandM;let t = the decoder tree specification;andM;let m = decode_bytes(t,str);andM;find the message specification in message_specs:andM;(m (parameter_fields [p.sub.1]...andP;  [P.sub.n])andM;(byteCode_position  ([b.sub.1], [x.sub.1], [y.sub.1])...andO;([b.sub.p][x.sub.1][y.sub.p)) /* explained later */andM;call the procedure attached to m to decompile unpositionedandM;parameters and computed fields from strandM;let result be the list made up of the single element mandM;for 1 andless; = i andless; = nandM;if j exists such that [b.j] = [p.sub.i]andM;/* positioned parameter */andM;val = the integer coded from bytes [x.sub.j] to [y.sub.j] in strandM;elseandM;/* explained laterandM;else val = value computed by the procedure attached to mandM;endifandM;add  pi val) at the end of resultandM;end forandM;return result end functionandM;The different statements commented /* explained later refer to conventionalprocedures necessary to compile and decompile unpositioned fields and computevalues of computed fields.andP;  These procedures (not described here) representno more than 5% of the message machine implementation (in noncomment sourcecode lines of Smalltalk).andM;As a result of this design, to add, modify, or remove message structures itis only necessary to edit the message specification list, adapting a fewprocedures for unpositioned fields, and running the metacompilation step.andM;Using Objects and inheritanceandM;The symbolic message machine was implemented in Smalltalk/V on a personalcomputer and then ported to a C-coded Smalltalk implementation on the HP- UXoperating system to interface with the test environment of the DTC operatingsystem.andP;  A Smalltalk interpreter provides the interface to the DTC operatingsystem test environment on HP-UX.andP;  The message machine and all tests areimplemented in this interpreter.andP;  Its expression power and openness arepowerful advantages that help develop and run the tests more efficiently thanbefore.andM;A number of facilities allowed us to write an efficient and well-adaptedimplementation.andP;  One adaptation was the use of array objects to representsymbolic expressions.andP;  Another was the use of classes and inheritance toimplement objects representing metamessages, metafields, and positions.andP;  Inparticular, different metamessages contain much common information.andP;  Theimmediate solution consists of implementing partial message descriptions,relations between them, and metamessages to propagate metafields and fieldstructure information.andP;  Metamessages also refer to procedural informationthat is to be propagated along these relations.andP;  Therefore, it was helpful tomap classes and superclasses to metamessages and partial descriptions, andthe basic class inheritance mechanism to the propagation relation.andM;Thus, a class is created for each message and the metafield information isobtained from methods-that is, by inheritance.andP;  Procedures related tounpositioned fields are treated in the same way.andP;  For example, to obtainmetafield information on the write and open-session messages, one creates theclasses:andM;DtcMessageandM;WriteMessage, subclass of DtcMessageandM;OpenSessionMessage, subclass of DtcMessage.andM;DtcMessage provides information common to all messages.andP;  Specifying values ofthe parameters_field metaparameter consists of implementing the followingmethods: method parameter_fieldso on class of DtcMessageandM;return the Array  dest_task dev_num) end method method parameter_fields() onclass of WriteMessageandM;result : = result of sending parameter_fields to superclass of selfandM;return concatenation of result and the symbol data end method Otheradaptations were:andM;* Metafield information is cached in sets, dictionaries, and orderedcollections for better performance.andM;* The compile and decompile procedures are methods of the abstract messageclass DtcMessage.andM;* A new metafield, example, is used in a general-purpose test procedure tobuild an example source message.andP;  It is also used in an automaticdocumentation procedure.andM;ConclusionandM;The object-oriented message machine has been used in the HP 2345A DTC PADsupport project (see article, page 63).andP;  Validating a new version of the PADsupport software only requires starting an HP-UX shell; no further humanintervention is needed.andM;After having being successfully used by the PAD support project, the messagemachine proved its ability to adapt to a new project, where it is now used.andO;AcknowledgmentsandM;I wish to thank the people who helped develop these new techniques insoftware testing: Christian Billeau, Montserrat Mane, Jean Pierre Dacher,Marie-Therese Sarrasin, Sylvaine Roy, Jean-Pierre Allbgre, Bernard Wagner,Olivier Bordes, and Christian Gresset.andP;  Special thanks to Remy Poulailleaufor a lot of ideas and encouragement.andM;ReferencesandM;1.andP;  P.H.andP;  Winston, Lisp, Addison-Wesley, 1981.andM;2.andP;  A. Goldberg and D. Robson, Smalltalk 80: The Language and ItsImplementation, Addison-Wesley, 1983.andM;3.andP;  W.F.andP;  Clocksin and C.S.andP;  Mellish, Programming in Prolog, Springer-Veriag,1981.andM;@@@096833637 0HPJIZa088EOFTandM;[FIGURES HAVE BEEN OMITTED]andM;The dimensional changes in cold-drawn Cu 1.8wt% (11.4 at%) Be rods resultingfrom aging are investigated.andP;  The dimensional changes are nearly isotropicfor as-quenched specimens but are anisotropic for cold-drawn specimens.andP;  Thetheoretical dimensional changes predicted based on the degree of preferredorientation, the crystallographic data of Cu-Be, and the geometry of thespecimens agree with the experimental results.andM;COPPER BERYLLIUM (Cu-Be) ALLOY is traditionally used for spring connectors inthe electronic industry because it has high conductivity, is platable,andM;is low in cost, and has high strength with a relatively low modulus ofelasticity (good spring characteristic).andP;  The material is usually machinedwhen it is still soft after being solution-quenched and cold-worked.andO;Machined parts are then precipitation hardened (aged) at an elevatedtemperature.andP;  This nearly doubles the mechanical strength withoutsignificantly changing platability or conductivity.andM;For precision components with tolerances on the order of + or - 5 [micro-m](+or - 0.0002 in), the use of Cu-Be alloy is limited because of theinconsistent dimensional changes that accompany aging.andP;  The shrinkage ofCu-Be during aging has been investigated by several other researchers whoassumed isotropic shrinkage of this material.andP;  This paper investigates theanisotropic dimensional changes of Cu-Be during aging, and discusses theeffects of cold drawing, aging time, and aging temperature.andM;ExperimentsandM;Table I lists the properties of the tested material.andP;  The tested bars werecenterless ground with minimum material removal, then machined into cylinders25 mm (1.0 in) long.andP;  Next, the ends of these cylinders were ground parallelwithin 1.25 [micro-m] (50 ;[micro-m].andP;  The specimens were ultrasonicallycleaned, then aged at different temperatures from 200 degrees C to 480degrees C  390 degrees C to 900 degrees F) in a mixture of 95% and 5%[H.sub.2]  to minimize any measurement error caused by surface oxidation.andM;All samples were measured before and after each aging period.andP;  Themeasurements were performed in an environmentally controlled room in whichtemperature was held to 23 + or - 1 degrees C. Diameters were measured with ascanning He -Ne laser system with resolution of 0.2  Am (10 [micro-in] andaccuracy of + or - 0.8 [micro-in] + or - 30 [micro-in].andP;  The specimen lengthswere measured with an indicating system with a resolution of 0.2[micro-in](10 [micro-in]) and accuracy of + or - [micro-in] (+ or - 40[micro-in]).andM;An x-ray diffraction method was used to characterize the sample texture.andO;Inner and outer pieces of a bar wereandM;removed on a traveled wire electrical discharge machine' as shown in Fig.andO;la.andP;  The diffractometer was set up for [CuK.alpha] x-rays with a Ni filterand a 0.4 degrees beam split.andP;  The areas under the (200) and (111)diffraction peaks were measured with a planimeter and compared with data forcopper powder.andM;Table 1andM;Composition and Size of the Test PiecesandM;Material: Cu 1.8 wt% Be 0.23 Co 0.10 SiandM;Condition: Solutionized at 775 degrees C  1425 degrees F),andM;Water-Quenched !!! BEGIN TABLEandM;Cold-Drawn, % Diameter ChangeandM;0        10        20       30andM;Size (mm) 14.27      12.70    11.43    10.06andM;Size (in)   0.562    0.500     0.450    0.396 !!! END TABLEandM;ResultsandM;While the as-quenched specimens had the same random texture as the copperpowder, distinct evidence of a preferred orientation or nonuniform texturewas found in the cold-drawn specimens.andP;  As Fig.andP;  lb shows, the preferredorientation increases from the outside to the center of a drawn bar, andincreases with the percent of cold drawing.andM;The percentage changes in the lengths and diameters of the cylindricalsamples for different aging times at 315*C 600*F) are plotted in Fig.andP;  2.andO;The effects of aging time and temperature on the dimensional changes areshown in Figs.andP;  3 and 4, respectively.andP;  DiscussionandM;The decomposition of the supersaturated phase of Cu-Be by precipitation hasbeen found by other researchers to be: supersaturated [omega arrow  GP zonearrow [gamma&quot;] arrow [gamma'] arrow [gamma].andM;In a supersaturated phase of this alloy, there is a random distribution of Beatoms in a solid solution with Cu atoms.andP;  The GP (Guinier-Preston) zones arelocations where precipitates form.andM;The equilibrium y phase does not exist in the ranges of aging temperature andtime used in this experiment.andP;  The GP zone, [gamma&quot;], and [gamma'] phasesconsist of multilayered plates formed on  1001 planes.andP;  Shrinkage resultsfrom the phase transformation because the unit cell dimensions of the GPzone, [gamma&quot;], and [gamma'] phases are smaller than those of the [omega]phase, as summarized in Table 11.andM;where a, b, and c are the unit cell dimensions and FCC indicates aface-centered cubic lattice.andM;The coherency of the plate-type precipitates allows dimensional change in thedirection normal to the plate, but prohibits any shrinkage in the habit plane(the flat plane in which precipitation plates tend to form).andP;  If this werenot the case, voids would form at the perimeters of the precipitate plates.andM;Anisotropic dimensional change on a macroscopic scale is the combined effectof:andM;* Microscopic dimensional change caused by each precipitateandM;* Formation of the precipitates on habit planes and directional shrinkagerelative to these planesandM;* Preferred orientation of the habit planes induced by the cold drawingprocess.andP;  Consider a cylinder of diameter D and length L. Its volume V isgiven by:andM;V = [Pi.D.sup.2] / 4andM;L.andM;Upon aging, the volume change resulting from small changes in both diameterand length is:andM;dV/V = 2[sup.dD] over D + dL over L.andM;All of the GP zone, [gamma&quot;], and [gamma'] phases are present after aging at315'C  600*F) for a short time.-' It is assumed for simplicity that only they' phase is present after long aging time (10 hr).andP;  The theoretical volumechange dV/V after complete transformation of the et phase to the [gamma']phase in Cu 1.8 wt% Be was calculated be:andM;dV over V = 0.61%.andP;  (2)andM;This agrees with results from other researchers.andP;  By combining equations 1and 2, the plot of dD/D (%) versus dL/L (%) is found to be a straight line:andM;dD over D = 0.5[sup.dL] over L - 0.305%.andM;Equation 3 is plotted in Figs.andP;  3 and 4 together with the experimental data.andO;As shown in Fig.andP;  3, the measured shrinkage data of the as-quenched specimensafter long aging at 315 degrees C (600 degrees F) agrees with the isotropicshrinkage calculated from equation 1:andM;dL over L = dD over D = 1/3 dV over V [approx.=] -0.2%  (4)andM;Consider a cubic lattice whose [001] direction coincides with the bar axis(longitudinal axis of a cylindrical bar).andP;  There are only two planes, (001)and (002), perpendicular to the bar axis, but there are four planes-(100),(200), (010), and (020)-parallel to this direction.andP;  Assume that theprobabilities of forming plate-type precipitates on all {001} planes areequal.andP;  Since the aging-induced shrinkage is significant in the directionperpendicular to the habit plane as pointed out earlier, and since there aremore habit planes parallel to the bar axis, it can be seen that thetransverse direction has to shrink more than the axial direction when thematerial lattice structures align themselves after cold drawing so that the[001] fiber axis is parallel to the bar axis.andM;The experimental data can now be explained.andP;  First, since the precipitationprocess happens quickly at 315 degrees C (600 degrees F), dimensions of theaged samples change mostly during the first hour, then vary slowly as theaging time increases, as shown in Fig.andP;  2.andM;Second, the data points start slightly off the anisotropic shrinkage line inFig.andP;  3 at the early stage of precipitation, but approach this line as theaging time increases as indicated by the direction of the arrows.andP;  (Recallthat the theoretical line represents the near-equilibrium condition aftervery long aging time.) Experimental data also suggests that the axialdimensions of the textured samples expand to conserve their volumes atequilibrium as modeled by equations 2 and 3.andM;Third, for aging below 260 degrees C (500 degrees F), the dimensional changeof Cu-Be is more complicated.andP;  As seen in Fig.andP;  4, the as-quenched samplesalways shrink isotropically because of their random orientation.andP;  Thetextured samples change their dimensions anisotropically but the experimentaldata converges to the theoretical line represented by equation 3.andM;Conclusions and RecommendationsandM;The anisotropic dimensional change of cold-drawn, then aged Cu-Be rods wasinvestigated.andP;  This paper shows that:andM;* Cold drawing of Cu-Be forms a distinct [001] fiber texture.andM;* The anisotopic dimensional change during an aging process is significantlyinfluenced by the texture.andM;* The as-quenched samples shrink isotropically in the temperature range 2000degrees C to 480 degrees C (390 degrees F to 900 degrees F) because of theirnear-random texture.andP;  The textured specimens change their dimensionsanisotropically.andP;  The transverse dimension of cylindrical samples shrinks butthe axial dimension expands to conserve their volume after long aging attemperatures greater than 315 degrees C (600 degrees F).andM;* A more precise shrinkage model should consider the different phases in theaged samples, grain boundaries, and other volume defects that affect thesample dimensions.andM;* Dimenional changes are dominated by cold-work induced texture.andP;  Therefore,if the amount of cold work is controlled, then a fixed set of shrinkagefactors for a particular aging process can be used in practice to predictdimensional changes of machined parts.andM;AcknowledgmentsandM;The authors would like to express their appreciation to Brush Wellman Inc.,andO;Cleveland, Ohio, U.S.A.andP;  for providing the material, and to Hewlett-PackardCompany, Santa Rosa, California, U.S.A.andP;  for use of the metrology equipment.andM;ReferencesandM;1.andP;  M.I.andP;  Gitgarts and A.V.andP;  Tolstoy, &quot;Volume Changes in a Copper BerylliumAlloy,&quot; The Physics of Metals and Metallography, Vol.andP;  48, no.andP;  2, August1979, pp.andP;  197-199.andM;2.andP;  H. Kreye, &quot;Shrinkage and Warping During Age Hardening of CuBe Alloys,&quot;Metals, Vol.andP;  29,1975, pp.andP;  1118-1121.andM;3.andP;  Z.P.andP;  Pastukhova and N.V.andP;  Vasilev, &quot;Volume Changes, Warping, andResidual Stresses in Beryllium Bronze During Heat Treatment,&quot; Metal Scienceand Heat Treatment, Vol.andP;  12, September-October 1979.andM;4.andP;  V.A.andP;  Phillips and L.E.andP;  Tanner,  High-Resolution Electron MicroscopyObservation on GP Zones in an Aged Cu 1.97 wt% Crystal, &quot;Acta Metallurgica,Vol.andP;  211, no.andP;  4,April 1973, pp.andP;  441-448.andM;5.andP;  R.F.andP;  Rioja and D.E.andP;  Laughlin, &quot;The Sequence of Precipitation in Cu 2wt% Be Alloys,&quot; Acta Metallurgica, Vol.andP;  28, no.andP;  9, September 1980, pp.andO;1301-1313.andM;6.andP;  Y.M.andP;  Koo, Atomic Structure of Cu 10.9 at% Be Alloys in the Early Statesof Aging, PhD Thesis, Northwestern University, 1987.andM;7.andP;  N.P.andP;  Hung, The Anisotropic Dimensional Change Due to Aging in Cold DrawnCu 1.8 wt% Be, PhD Thesis, University of California at Berkeley, 1987.andO;</TEXT></DOC>