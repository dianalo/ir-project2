<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF109-409-207  </DOCNO><DOCID>09 409 207.andM;</DOCID><JOURNAL>Hewlett-Packard Journal  June 1990 v41 n3 p12(15)* Full Text COPYRIGHT Hewlett Packard 1990.andM;</JOURNAL><TITLE>The HP OSF/Motif Window Manager.andO;</TITLE><AUTHOR>Krizan, Brock C.; Taylor, Keith M.andM;</AUTHOR><SUMMARY>The OSF/Motif Window Manager is one of the X clients in version 11of the X Window System that determine the particulars of the userinterface; it implements an interface supporting user and clientmanipulation of windows and dictates user interface behaviorthrough its window management interface.andP;  Client windows placeddirectly in the background, or root, window of the screen are theprimary objects manipulated using the window manager; methods ofmoving and resizing the windows, directing all keyboard input to aspecific window and installing color maps for a window areprovided to users.andP;  The characteristics of the Window Manager,including its common appearance and behavior, three-dimensionalappearance and mouse and keyboard interfaces are described, andaspects of its operation and implementation, including widgets andwindows, configuration and event processing, are examined.andM;</SUMMARY><DESCRIPT>Topic:     Graphical User InterfaceWindowingSoftware DesignCustom SoftwareClient/Server ArchitectureScreen Generators-FormattersX Windows (Standard)Program Development ToolsProgram Development Techniques.andO;Feature:   illustrationchart.andO;Caption:   The X client-server model. (chart)A client window and the various window manager components. (chart)OSF/Motif Window Manager start-up process. (chart)andM;</DESCRIPT><TEXT>The HP OSF/Motif window manager, which is built on top of the X WindowSystem, is a window management interface that provides a 3D enhancedPresentation Manager appearance and behavior using HP OSF/Motif widgets.andM;THE X WINDOW SYSTEM, Version 11 (also known as X or X11) was developed as aplatform on which a variety of user interfaces can be implemented.andP;  Theparticulars of a user interface are determined by the X clients that run onthe system.andP;  X clients are programs that use X to display information andreceive input.andP;  The HP OSF/Motif Window Manager (mwm) is one such client.andM;Fig.andP;  1 shows the relationship between the X Window System and clients.andP;  TheOSF/Motif window manager mwm implements an interface that allows user andclient manipulation of windows.andP;  mwm dictates through its window managementinterface a particular user interface behavior.andP;  The principal objects thatare manipulated using the window manager are the client windows placeddirectly on the background, or root, window of the screen.andP;  Windows withinthese top-level client windows are managed by clients and are not directlymanipulated by the window manager.andP;  Users are provided with ways to move andresize windows, to direct all keyboard input to a particular window, and toinstall color maps-' for a window.andM;X, as it comes from the Massachusetts Institute of Technology (MIT), providesmechanisms for supporting clients that implement a variety of windowmanagement user interfaces.andP;  A sample window manager, mwm, is distributed byMIT.andP;  Several window managers have been implemented at companies anduniversities to meet the needs of a particular application environment, toemulate some non-X Window System user interface, to provide the latest newand improved window management interface, or to provide personalcustomizations of uwm.andP;  Window managers are one of the most common types of Xclients.andM;With so many window managers available, implementing another window managerwould seem to be a waste of time.andP;  However, the window manager is anessential and highly visible part of any window system user interface, andthe usability of a system can be significantly affected by the windowmanager.andP;  Prior to the availability of mwm's predecessor, the HP windowmanager, or hpwm, HP customers who had access to X used the sample windowmanager uwm or, less frequently, window managers available in the publicdomain.andP;  HP wanted to give users an interface that was visually refined,consistent, easy to learn, and based on industry standards.andM;Hpwm supports industry standards in appearance and behavior as well as Xstandards for client interoperability.andP;  The appearance and behavior of hpwmis based on Presentation Manager, which also defines the window managementappearance and behavior for HP's NewWave Office.andP;  Users already familiar withthe Presentation Manager standard from the personal computer environment nowfind their skills useful on an HP-UX workstation.andP;  The three-dimensionalvisuals of hpwm represent a refinement, not a change, from PresentationManager standard appearance.andM;In 1988, the Open Software Foundation (OSF) accepted HP's proposal that hpwmbe adopted as the basis for the OSF/Motif window manager.andP;  The commitment toPresentation Manager as an industry-standard user interface was key in OSF'sdecision.andP;  OSF/Motif encompasses several technologies built on top of the XWindow System, and the new OSF/Motif window manager is only one piece of theOSF/Motif environment.andM;Window Manager CharacteristicsandM;The basic set of functions that a window manager provides is relativelyconstant in any window system.andP;  On the other hand, the appearance andbehavior vary greatly from one window manager to another.andP;  Many of thecharacteristics of mwm were leveraged from hpwm.andP;  This allowed us to meet anaggressive schedule and still satisfy the functionality and quality goals formwm.andM;Common Appearance and BehaviorandM;Like hpwm, the appearance and behavior of mwm are heavily influenced byPresentation Manager.andP;  Indeed, the default behavior of mwm, as well as thatof the OSF/Motif widgets, is as close to Presentation Manager as ispractical.andP;  A key benefit of this is that users can easily move betweensystems running MS/DOS [Rights] or OS/2 and systems running the HP-UXoperating system and X Windows.andP;  Nevertheless, some differences were admittedinto the design of mwm to satisfy the variety of HP-UX users and to use thepower of engineering workstations.andP;  This has led to a window manager with ahigh degree of configurability and an enhanced appearance over PresentationManager.andM;Key behavioral aspects of Presentation Manager and the OSF/Motif environmentinclude the direct manipulation of objects and an object-action paradigm foruser interaction.andP;  Direct manipulation involves using the keyboard and/ ormouse to do window management functions directly, such as moving and resizinga window.andP;  A user does not enter a command such as move -w mywindow x = 10 y= 100, but rather drags the window using the mouse to the new position.andP;  Withthe object-action paradigm, the user selects an object and then performs someaction on the object.andP;  30 AppearanceandM;One deviation from strict adherence to the Presentation Manager standard isin the appearance of the user interface components.andP;  The three-dimensionalvisual style developed for earlier HP products was accepted by OSF as part ofthe OSF/Motif standard.andP;  3D components appear in both the window manager andthe OSF/Motif widgets.andP;  Use of 3D components strengthens the directmanipulation paradigrn by providing visual objects that react naturally touser actions (e.g., buttons appear to go in when pressed).andM;Mwm uses the OSF/Motif widgets to provide visual and operationalcompatibility with other clients that use the OSF/Motif widgets.andP;  All partsof mwm are displayed with the 3D visual style.andP;  This includes the windowmanager frame, icons, and menus.andP;  A key factor that influenced mwm's use ofthe 3D visual style was the prevalence of window manager components on thescreen.andP;  The challenge was to provide a 3D appearance but not to distractfrom or limit the client user interface.andP;  Mwm is designed to be frugal withits use of screen space, subtle in its use of 3D indications, and restrainedin its use of color.andP;  Fig.andP;  2 shows a client window and the various windowmanager components.andM;Configurable Appearance and BehaviorandM;Although mwm implements the Presentation Manager behavior with a 3D visualstyle, configurability was considered a desirable departure from a strictPresentation Manager model.andP;  In some cases configurability applies to aspectsof the user interface that are not constrained by the standard appearance andbehavior.andP;  The colors of components and the fonts that are used fall intothis area.andP;  Configurability can also alter the standard appearance andbehavior in fundamental ways.andP;  Since it is almost impossible to provide asingle, fixed user interface acceptable for all users, configurability ishighly desirable.andM;Configurability of mwm is provided in a way that does not burden users whoare satisfied with the window manager's standard appearance and behavior.andO;Mwm provides the standard appearance and behavior as a default and allows foruser customization.andP;  Configuration is only necessary if there are specializedrequirements.andP;  In addition, mwm provides a function that resets allcustomized mwm settings to default values to give the user a known startingplace from which to work.andM;It is anticipated that only a small group of system administrators will wantto customize mwm.andP;  To make their job easier, mwm uses the same resource namesfor specifying configuration values for colors and fonts as are used forOSF/Motif widgets.andP;  The result is that configuring mwm is similar toconfiguring any client built using OSF/Motif widgets.andM;ICCC ComplianceandM;Compliance with the standard Inter-Client Communication Conventions (ICCC)developed by the X Consortium is a requirement for any X client.andP;  Theseconventions are intended to facilitate interoperability of X clients.andO;Clients that follow the conventions can coexist on the same screen and notinterfere with each other's behavior.andP;  This applies particularly to thecommunication between clients and window managers.andP;  The ICCC is the basis forthe programmatic interface to X window managers  see the box on page 23).andM;Mwm implements the ICCC standard in a way that is compatible with thestandard OSF/Motif behavior.andP;  This allows a user to run a client even thoughit was developed without specific knowledge of mwm.andM;Mouse and Keyboard interfacesandM;Window managers are often implemented with a reliance on the mouse for userinteraction and the keyboard is ignored.andP;  The OSF/Motif behavior specifies afunctional equivalence between mouse and keyboard interaction.andM;Mwm is fully functional when it is run on systems that do not have a mouseinput device.andP;  Not only does the standard OSF/Motif behavior have keyboardsupport, but mwm supports features beyond the OSF/Motif standard.andP;  Forexample, keyboard and mouse interaction can be mixed together, even whiledoing a particular action such as moving a window.andM;OSF/Motif Window Manager OperationandM;Mwm has two basic phases of operation: start-up and event processing.andP;  Atstart-up, mwm asserts itself as the window manager for a particular screen,processes configuration information, and takes care of currently displayedclient windows (see Fig.andP;  3).andP;  Event processing is the steady-state phase ofoperation.andP;  Like most X clients, mwm is event driven-that is, it waits forsome type of X event, processes the event, and then waits again.andP;  In theevent-processing phase, all mwm actions are the direct result of some event.andM;Start-upandM;When mwm first starts up it must indicate to the X server that it wants to bethe window manager.andP;  The X server has no notion of a special window managerclient, but there are some X facilities that are necessary for windowmanagement that cannot be accessed by more than one X client.andP;  By assertingcontrol of these facilities, mwm effectively locks out other window managerclients (conversely, mwm is locked out if another window manager is alreadyrunning).andM;The primary facility over which mwm gains control is the facility forredirecting several types of X requests from other clients (see Fig.andP;  4).andO;Usually a client makes a request to the X server to do a function and thatfunction is done immediately by the server.andP;  With a redirected request, thefunction is not handled by the X server, but is passed to the redirectingclient (i.e., the window manager).andP;  The window manager decides how to handlethe redirected request and then makes the request, sometimes changing therequest to be compatible with its window management policies.andM;The types of X requests that are redirected by mwm include:andM;* Window configuration (moving and resizing)andM;* Window stacking (who's on top of whom)andM;* Window mapping (display of a window on the screen).andM;These requests are redirected only when they apply to top-level clientwindows, which are windows displayed directly on the background or rootwindow of the display.andP;  Using its ability to redirect X requests, mwm cancontrol when, where, and how client windows are displayed.andM;Once mwm has asserted itself as the window manager, it can then configureitself and prepare to do event processing.andP;  In general mwm has itsconfiguration specified through resource files like other X clients (see Fig.andO;5).andP;  These resource files contain user-specific configurations,client-specific configurations, and screen-specific configurations.andM;Resources that are specific to fonts, colors, and bit maps are defined andreferenced in general-purpose resource files.andP;  However, not all configurationresources can be conveniently specified in a general-purpose file.andP;  The mwmresource description file (usually called .mwmrc) contains descriptions ofresources that are difficult to specify in the general-purpose resourcefiles.andP;  Mwm menus, mouse semantics, and keyboard semantics are described inthe mwm resource description file and referenced in other resource files.andM;The last thing that mwm does during its start-up phase is adopt clientwindows that are currently being displayed.andP;  Mwm assumes control over theplacement of client windows on the screen.andP;  In the usual case where mwm isthe first client to be started there will be no clients to adopt.andM;ProcessingandM;After mwm completes start-up it goes into a loop waiting for and processingevents.andP;  Events are messages from the X server that are generated as theresult of some user or client action.andM;When a top-level client window is to be displayed on the screen, the windowmanager receives a map request event.andP;  In processing the request, the windowmanager retrieves client-specified and user-specified configurationinformation to place the client window on the screen.andP;  The client window isreparented to a window manager frame window.andP;  In effect, the client window isplaced inside a window manager frame window.andP;  This is the mechanism thatallows mwm to give all clients a common top-level window border.andP;  In theframe window, around the outside of the client window, are placed the windowmanager direct manipulation components shown in Fig.andP;  2.andP;  Once the clientwindow is dressed up in its window frame, it is placed on the screen.andM;User interaction with the window manager results in mouse (button and motion)events and keyboard (key) events.andP;  When a user interacts with a directmanipulation window manager component, a stream of events is generated.andP;  mwmassociates the events with a particular user interface component and invokesthe associated function.andP;  Immediate visual feedback of the user's interactionmaintains the appearance and behavior of the direct manipulation interface.andM;Users can configure window manager actions to be invoked by particular key orbutton events.andP;  This interface to the window manager is in addition to thestandard interface which is based on direct manipulation of window managercomponents.andP;  Mwm arranges with the X server to grab button and key eventsthat invoke window manager functions.andP;  This grab mechanism allows the windowmanager to get the events even while another X client window is receivingkeyboard input.andM;Termination of mwm is triggered when a window manager function invoked by auser or by an event indicates that the X server has been shut down.andP;  When mwmis terminated, the window frames that belong to mwm are destroyed.andP;  Normally,all the child windows of a window that is being destroyed are also destroyed.andO;However, since mwm reparents client windows to their window frames atstart-up, the desirable behavior is for the client windows to be reparentedback to the background (root) window so that the clients can continue to run.andO;To accomplish this, mwm uses the X11 save set mechanism to cause clientwindows to be reparented back to the root window when mwm terminates.andP;  Byplacing all client windows that have been reparented to window frames intoits save set, the windows are automatically reparented back to the rootwindow by the X server when mwm terminates.andM;RestartandM;The restart function is invoked when a user wants to reconfigure mwm.andO;Restart is necessary because some resources are only read by mwm in itsstart-up phase.andP;  Any aspect of the mwm configuration can be changed at anytime using the restart function.andP;  The window manager restart functioneffectively terminates the current instantiation of mwm and starts a new one.andO;This function is special in that it causes mwm to make a complete passthrough both of its operational phases.andP;  The event that invokes the restartfunction is processed in the steady-state event processing phase.andP;  Restartexecution begins with the termination of mwm and completes when mwm starts upagain.andM;OSF/Motif Window Manager ImplementationandM;Like the features and characteristics of mwm, most of the code and design formwm were leveraged from the HP window manager.andP;  The period when hpwm wasdesigned and implemented was one of rapid change for X and for HP's use of X.andO;This had to be taken into account in formulating an implementation strategyfor mwm.andP;  For example:andM;* Hpwm was implemented at the same time that there were new developments inuser interface technologies and components.andP;  However, to minimize risk,stable technologies were used in favor of the newer ones.andM;* The user interface components that hpwm used were often first-generationproducts.andP;  Therefore, visual and performance tuning of these components couldnot be relied upon.andM;* Prototype versions of hpwm were required to refine the 3D visual style, tosupport usability testing, and to support prototype application environments.andM;* Standards that hpwm used were under development in parallel with theimplementation of hpwm.andM;The implementation strategy used for hpwm involved substantial prototypingand design, followed by bottom-up reimplementation.andP;  Prototyping and designaccounted for more than half of the engineering and calendar time spent onimplementing hpwm.andP;  Development of a prototype delayed dependencies on userinterface components and facilities.andP;  The prototype was used to identifyvisual and performance problem areas requiring design refinements.andP;  Designdecisions were substantiated or changed based on experience with theprototype.andM;After the prototype and hpwm, mwm can be viewed as the third pass on thewindow manager.andP;  The experiences gained from the earlier efforts were usedduring the definition and implementation of mwm.andP;  Also, the use of the hpwmengineering team for the development of mwm allowed for rapid and effectiveprogress once the functionality was defined.andM;Widgets and WindowsandM;There are two principal levels in which a programmer can write a userinterface for an X client: the high level using a widget library like theOSF/Motif widgets and the low level using the X library.andP;  Widgets providehigh-level objects (like menus and buttons) that embody the semantics ofspecific user interactions, and the X library provides only basic windowfunctionality.andP;  Since the HP window manager user interface was implementedusing a mixture of widgets and the X library, mwm was implemented using asimilar mixture of libraries.andM;Mwm uses the OSF/Motif widgets to implement its menus.andP;  This providesappearance and behavior consistent with applications that also use theOSF/Motif widgets.andP;  It also leverages the engineering effort that went intothe design and development of the menu widgets.andM;Mwm does not use any widgets for the window frame components (title bar,resize handles, and border).andP;  To understand why, it is necessary to examinethe decision made for hpwm.andP;  First, at that time, the available widgets didnot offer enough control over the thickness of the 3D beveling (the topshadow and bottom shadow highlights) to give the desired 3D effect.andP;  Thewindow frame has oddly shaped pieces and complicated joints that requireexplicit drawing by the window manager.andP;  Also, the visual design requiressingle-pixel beveling between components of the window frame.andM;Second, although using multiple widgets as buttons for the frame decorationsimplified some aspects of event handling, it complicated changing the colorof the entire window frame.andP;  Some window managers change only the title barappearance to indicate the active window.andP;  However, this can be difficult orimpossible to spot depending on the size of the window and the degree towhich it is obscured.andP;  Mwm and hpwm change the color of the entire frame toindicate keyboard focus.andP;  Thus, the functional and performance needs of hpwmrequired a solution other than using the widgets available at the time.andM;It is important to note that with the latest version of OSF/Motif widgets,most of the objections that caused the initial decision not to use widgetsfor the window frame have gone away.andP;  For example, OSF/Motif provides widgetscalled &quot;windowless gadgets&quot; that provide better performance than the widgetswith windows that we used.andP;  However, there are still some mwm user interfacerequirements-, such as the resize cursors, that require either widgets withwindows or special processing.andM;An mwm window frame consists of ten windows for drawing, cursor presentation,and event handling (see Fig.andP;  6).andP;  The main frame window has the root windowas its immediate parent.andP;  It is an input/output window and is the window towhich frame drawing is done.andP;  Above the frame window are eight input-onlywindows for the resize handles.andP;  Each of these windows has its own cursor toindicate the type of resize that can be started in that area.andP;  The next layerup includes an input-only title window which is used to display a differentcursor for the title area and partially obscures the upper resize windows.andO;This layer also includes a base window on which the client window sits.andP;  Thebase window partially obscures the lower resize windows and is used fordrawing the client matte if one is specified.andP;  The client matte is a featureof mwm that allows the user to create an extra level of distinguishabilityfor a window by specifying a color for the area below the title bar windowshown in Fig.andP;  6.andP;  An example of this feature is illustrated by the striplabeled optional matte in Fig.andP;  2.andM;The primary reason there are so many windows is to get the desired cursorbehavior.andP;  As the pointer moves into each resize area, the cursor changes toindicate the type of resize that can be started in that area.andP;  This isaccomplished in mwm by creating input-only windows that overlay the graphicsin the frame window.andP;  Each window is created with a different cursorattribute.andP;  A benefit of this, from mwm's point of view, is that the X servertakes care of changing the cursor shape when the pointer enters or leavesthese windows.andP;  Careful overlapping of the title bar window and the basewindow clips the comer resize areas to their characteristic nonrectangularshapes.andM;ConfigurationandM;The mwm approach to configuration can be characterized in terms ofconsistency, flexibility, performance, and usability.andP;  These attributes wereachieved using the following techniques.andM;* The mwm configuration is based on the values of resources set in theresource files.andP;  mwm resource names are consistent with the standardOSF/Motif widget names.andP;  The names are defined such that a single entry in aresource file can be used to specify values for related resources.andP;  Forexample, the background color used for all window manager components can bespecified with one resource.andM;* Most configuration overhead occurs at start-up and is avoided during userinteraction, when quick feedback is required.andM;* All mwm resources have default values that are consistent with the standardPresentation Manager behavior and 3D appearance.andM;Three types of resources are processed by mwm: general behavior resources,component-specific appearance resources, and client-specific appearance andbehavior resources.andP;  Fig.andP;  7 shows a portion of a file with some sampleresource settings.andM;General-Behavior Resources.andP;  General-behavior resources are used to definewindow manager policies such as directing keyboard input to a particularclient window and specifying when to install a client window's color map.andO;Button and key associations* to window manager functions are also specified.andO;For example, pressing the left mouse button with the pointer over the rootwindow can be configured to post a menu.andP;  The general-behavior resources arecompletely processed when mwm is started.andM;Fig.andP;  8 shows a portion of the mwm resource file used to define the buttonand key associations declared in the sample .Xdefaults file shown in Fig.andP;  7.andO;The first part of the resource file, labeled menu workspace, defines theappearance and the functions associated with the menu shown in Fig.andP;  9.andP;  Forexample, for the menu item hpterm, the function f.exec is executed whenhpterm is selected, and the field &quot;hpterm = 80x42andamp;&quot; defines the BP-UX commandthat is executed by f.exec to start a new hpterm terminal emulator that is 80columns by 42 lines in size.andP;  The key and button bindings define the event(key or button selection), the context (where the event occurred), and theaction associated with key and button selections.andP;  From the key bindingdescription in Fig.andP;  8, the key sequence Alt ESC entered while in an icon orwindow context would cause the Window menu to be displayed.andM;Component-Specific Appearance Resources.andP;  Mwm high-level components includethe window frames, icons (small representations of client windows), andwindow manager menus.andP;  These components use the same set of appearanceconfiguration resources.andP;  The resources specify the colors and textures touse for 3D appearance and the font to use for displaying text.andP;  Defining the3D appearance of a component can involve specifying the texture and color forthe foreground, the background, the top shadow, and the bottom shadow of thecomponent.andP;  Default component-specific appearance resources can be used toavoid specifying any 'Also called key bindings.andP;  resources for a monochromesystem, and only the background color on a color system.andP;  On a color systemthe top shadow, bottom shadow, and foreground colors are generatedalgorithmically.andP;  The algorithm generates an effective 3D visual appearancebased on a background color.andP;  New colors are generated by shifting the RGBvalues of the background color.andP;  The values are shifted to make the topshadow color lighter, the bottom shadow darker, and the foreground color muchdarker than the background color.andM;The window frame and icon components have a set of appearance resources forboth active and inactive states.andP;  A component in the active state can receivekeyboard input, and a component in the inactive state cannot.andP;  In the case ofa window frame, the client window receives the keyboard input.andP;  For humanfactors and performance reasons there is a single 3D color scheme for activecomponents and a single color scheme for inactive components.andP;  Multiple,client-specific color schemes for active and inactive states led to problemswith identifying the client window that was supposed to receive keyboardinput.andP;  Also, interactive performance is maintained by allocating allcomponent colors and graphics contexts (graphics state information used in Xdrawing requests) at start-up time.andM;Client-Specific Appearance and Behavior Resources.andP;  Resources used by thewindow manager to customize components for particular client windows areclient-specific resources.andP;  The image in the icon representation of a clientwindow can be specified.andP;  Client-specific colors can also be specified tocolor the client icon image and the 3D matte that fits within the windowframe.andP;  Client-specific resources are retrieved based on the resource name orclass of a client window.andP;  The resulting X resources and window managercomponents are cached to avoid resource processing overhead when severalclients of a particular name or class are run.andP;  This enhances performancebecause client windows are placed on the display frequently during userinteraction.andP;  Event ProcessingandM;Mwm event processing is designed to handle different types of events andevent contexts.andP;  The events that are processed include button presses,pointer motion, window destruction, and many more.andP;  Event contexts define thelocations where the events occurred.andP;  These locations include the rootwindow, widgets, nonwidget window manager components, the window frame, anicon, and client windows.andP;  The window frame has subcontexts such as thesystem menu button, the resize border handle, the title, and the minimizebutton.andM;Table I lists some events that are processed, the contexts they occur in, andthe actions taken when the event occurs.andM;Events with a root window context generally involve newly displayed windows,destroyed client windows, or the invocation of a window manager function thatis not client-specific (e.g., repaint the screen).andP;  Events for mwm menus havea widget context.andP;  Events with a nonwidget context are generally on thewindow frame and are often related to user interaction with the directmanipulation components such as the resize handles.andP;  Events with a clientwindow context are typically notifications about the actual or desired stateof a client window.andM;The event-processing loop for mwm has the following flow of control.andM;*  Use the Xt Intrinsic function XtNextEvent to retrieve the next event sentby the X server.andM;* Identify the event context.andP;  Events are always reported relative to somewindow.andP;  The X context manager, which is accessible through X libraryfunctions, is used to associate mwm contexts and data with the windowidentifiers provided in events.andM;*  Dispatch nonwidget events to the appropriate event handler and dispatchwidget events using the Xt Intrinsic function XtDispatchEvent.andM;*  Go back to the start of the event loop to get the next event.andP;  Mouse EventProcessing.andP;  Much of the behavior of the window manager interface is based onhow mouse events are processed.andP;  Mwm divides mouse event processing into twocategories: mutable behavior event processing and immutable behavior eventprocessing.andM;Immutable behavior is built into mwm and is associated with the directmanipulation features (title bar, resize handles, etc.) of window frames andicons.andP;  Each direct manipulation feature has its behavior encapsulated in mwmevent processing.andP;  Button press-and-release events and mouse motion eventsthat occur with a context corresponding to a direct manipulation feature areprocessed by the event handler for that feature.andM;Mutable behavior event processing is based on user specification of mouseevent associations with window manager functions.andP;  For example, button threeof the mouse can be associated with the minimize function such that wheneverbutton three is pressed with the mouse pointer over any part of the clientwindow or window frame, the window will be minimized.andM;Mwm maintains a table that associates mouse events with Window managerfunctions, and it uses this table for deciding which window manager functionto invoke.andP;  Keyboard Input Focus Event Processing.andP;  The window with thekeyboard input focus is known as the active window.andP;  What this means is thatwhen a key is pressed, the input is applied to the window with the keyboardinput focus.andP;  Moving the keyboard input focus between windows is an importantwindow manager function.andM;Two behaviors are supported by mwm for setting the keyboard input focus:explicit selection and pointer-relative selection.' Explicit selection meansthat a specific window is designated to be the keyboard input focus window.andO;Explicit selection of the input focus is Presentation Manager behavior.andP;  Forpointer-relative selection, the window under the mouse pointer automaticallybecomes the keyboard input focus window.andP;  This behavior is favored by manytechnical users.andM;Very different event processing is needed to handle the two differentkeyboard input focus behaviors.andP;  Setting the keyboard input focus inpointer-relative mode is done using enter and leave window events.andP;  When thepointer enters a window frame, mwm receives an enter window event.andP;  mwmresponds by making a request to the X server to cause delivery of keyboardinput to the client window.andP;  As long as the pointer remains over the windowframe (or the client window), keyboard input will be delivered to the clientwindow.andP;  This maintains the illusion that the window frame is just anotherpart of the client window.andP;  When the pointer leaves the window frame, a leavewindow event is received.andP;  This is usually followed by an enter window eventas the pointer enters the root window or another window frame.andP;  Mwm respondsby resetting the keyboard input focus appropriately.andM;Event processing for explicit selection of the keyboard input focus primarilyinvolves button press and key press events as opposed to enter and leavewindow events.andP;  When a button press event is received by mwm and the contextis a client window that does not have the keyboard input focus, mwm calls theX server to cause the delivery of keyboard input to the client window.andM;mwm has to take care when it is processing button press events.andP;  Usuallybutton events go to the window that is under the mouse pointer at the timethe button is pressed or released.andP;  This means that if the pointer is over aclient window and the button is pressed, the client window would normally getthe button press event and mwm would not see an event.andP;  mwm handles this byestablishing a passive grab of the button event when it is generated in theclient window context.andP;  A passive grab of the button causes the event to bedelivered to mwm and not to the client window (see Fig.andP;  10a).andP;  mwm haseffectively stolen a button event that would normally belong to the clientwindow.andM;This is not very friendly because the stolen event is often a mouse button 1press event which, according to Presentation Manager, is also used to doselections of user interface components in the client window.andP;  mwm redeemsitself by making the button event available to the client.andP;  After mwm setsthe keyboard input focus, it replays the button press, causing the event tobe delivered to the client window (see Fig.andP;  lob).andP;  Mouse event processing bythe server is then allowed to continue, and mouse events that occur after thebutton press are delivered to the client window (if the client window isinterested in the events).andP;  While a client window has the keyboard inputfocus, mm turns off its passive grab request for a button press.andP;  InteractivePointer Tracking.andP;  A direct manipulation interface has to work hard toprovide good feedback to the user.andP;  An example of this occurs duringinteractive moving or sizing of windows in mwm.andP;  mwm draws a frame outlinethat tracks the new position or size of the window as the user moves themouse around.andP;  Making this operate smoothly and efficiently requires someinteresting event processing.andM;All X window managers provide a feedback mechanism like the one describedabove.andP;  Many do so by polling the position of the pointer (mouse cursor) anddrawing a new outline (erasing the old) when the position changes.andP;  This hasthe advantage of keeping the window manager and the server synchronized,providing smooth behavior.andP;  The disadvantage is that the polling continueswhen the pointer is not moving, using up network bandwidth if the windowmanager is running remotely.andM;The first implementation of hpwm, forerunner of mwm, departed from polling byrequesting the server to report pointer motion events only when the pointermoved.andP;  Thus the drawback of polling was avoided.andP;  However, when the pointermoves, a large number of events must be processed.andP;  This was not a problem onmedium-to-high-performance workstations that could keep up with the flood ofevents, but a problem did occur on low-performance machines, particularly Xterminals.andP;  The time to process each motion event was longer than the time togenerate a new one, causing the user to observe a window outline that wouldfall behind the motion of the pointer.andM;The solution to the problem, implemented in mwm (and a later hpwm), is torequest the X server to send pointer motion hints, which are a special typeof pointer motion event.andP;  In this mode of operation, the X server only sendspointer motion hints in conjunction with certain other events, such as windowexit and entry.andP;  The X server also sends a pointer motion hint when thepointer moves from the last position queried by mwm.andP;  Each time a pointermotion hint is received, mwm acknowledges it by querying the position of thepointer.andP;  It then moves the pointer outline based on the values returned bythe query.andP;  Tracking the pointer position with pointer motion hints is moreexpensive than polling when the pointer is moving, but it avoids the pollingburden when the pointer is not moving.andM;Adopting a Client WindowandM;Adopting a window refers to the process that mwm goes through when itinitially encounters a window that it does not yet manage.andP;  This happens withthe set of client windows that are on the display before mwm is started, aswell as with clients that are started after mwm is already running.andP;  For eachwindow that it adopts, mwm collects information from the client and theresource data base that affects the appearance of the window border, theplacement of the window on the screen, and the window's behavior in responseto user actions.andM;Communication between an X client and an X window manager occurs throughevents and properties (special information associated with a window).andP;  Amongthe events that are processed by mwm are those that begin or terminatemanagement of X clients.andP;  The properties allow the client to indicateplacement, decoration, and behavior information.andM;Mwm becomes aware of a new client when it receives the client's redirectedrequest to display (or map) its top-level window.andP;  Mwm responds to this eventby:andM;* Examining several client window propertiesandM;* Constructing a window frame and icon for the windowandM;* Reparenting the client window to the mwm window frameandM;* Placing the client window on the display.andM;Several properties are used in this client-window manager communication.andO;Some are listed in Table II.andM;The initial position and size of a window can be set either programmaticallyor interactively by the user.andP;  This information is passed to mwm in theWM_NORMAL_HINTS property of the client window.andP;  The value of this property iswhat determines how mwm places the window.andP;  Mwm will let the user place thewindow interactively if mwm's interactive placement is enabled and if theinitial position has been set programmatically.andP;  However, if the initialposition has been set by the user (e.g., via a command-line option),interactive placement will not be done even if it is enabled.andM;Mwm manages windows, not clients.andP;  If a client uses several top-levelwindows, mwm will treat them all equally even though they may have differentpurposes.andP;  However, a client may indicate a secondary top-level window, suchas a dialog box, by placing the WM_TRANSIENT_FOR property on it.andP;  Mwm willdecorate a window with this property differently, using a separate decorationresource for secondary windows.andP;  Mwm will not place a secondary windowinteractively.andM;In addition to reading properties when the window is adopted, Mwm trackschanges to some of the properties while the client is running.andP;  The clientmay change the name displayed in the title bar by changing the WM_NAMEproperty.andP;  Similarly, the client may change the name displayed in the icon bychanging the WM_ICON_NAME property.andP;  Window geometry (i.e., size, position,and resize increment) changes are also tracked in WM_NORMAL_HINTS to makesure that resize units are properly reported.andP;  For example, a terminalemulator may resize its window to display function keys, but the number oftext rows reported as the window size should not change.andM;Menu HandlingandM;Mwm supports both client-specific and general-application menus.andP;  Thecontents of client-specific window menus and general-application menus can bespecified by the user.andP;  The user can also specify the button or key eventthat causes a menu to be posted and the context for the event (e.g., post autility menu when mouse button 1 is pressed with the pointer in the titlearea of the window frame).andP;  Everything that can be done with menus using amouse can also be done using a keyboard.andM;Presentation Manager behavior includes a client-specific window menu that isposted using the window menu button on the window frame.andP;  The window menu islike a pull-down menu.andP;  It appears below the window menu button when thepointer is moved over the window menu button and the selection button (on themouse) is pressed.andP;  A selection is made by dragging the pointer to a menuitem and releasing the selection button.andP;  A client-specific window menu canalso be posted by a button or key event in the client icon context.andM;To the user it may seem that mwm supports a large number of menus.andP;  This isbecause each client window has a menu that is posted from the window menubutton, and each client icon has a menu that can be posted with a key press(typically Shift ESC).andP;  There are also menus that are commonly used to startclients and to perform various window management functions (e.g., change thestacking order of client windows).andP;  The heavy use of menus, combined with therelatively high performance cost of making menus, led to the design of a menucache for mwm.andP;  A menu cache is possible because many menus have the samemenu items.andP;  Also, the flexibility of the OSF/Motif menu widget allowed mwmto use a pop-up menu type for all the menus.andP;  Mwm uses the OSF/Motif pop-upmenu type to implement window menus and simulates pull-down menu behaviorwhen a menu is posted using the window menu button.andM;Mwm keeps a list of menu specifications.andP;  When mwm makes a menu it startswith a particular menu pane specification.andP;  The workspace menu entries givenin Fig.andP;  8 illustrate a menu specification.andP;  Other menus can be specified tocascade from the starting menu (see Fig.andP;  11).andP;  When a menu is made, anassociation is made between the menu and the initial menu specification.andO;Subsequent calls to make the same menu will return the menu that is alreadybuilt.andP;  The key to making this work is the capability of mwm to adjust thecharacteristics of the menu dynamically so that the menu is set up correctlyfor the context in which it is posted.andM;Mwm adjusts the following menu characteristics:andM;*  The active and inactive appearance and behavior of menu items are matchedto the context in which the menu is posted.andP;  Menu items that are notapplicable in a particular context are grayed out and are not selectable.andM;For exam le a menu item that minimizes a client window is grayed out if themenu is posted in the icon context.andM;A menu is placed in keyboard traversal mode to allow keyboard manipulation ofthe menu.andP;  However, if a menu is not posted using a key press, the menu isnot placed in traversal mode.andM;A menu is configured to have particular key and button events select a menuitem and unpost the menu.andM;A menu is posted at a particular screen position (e.g., below the window menubutton in a window frame).andP;  Mwm keeps track of the currently configuredcharacteristics of a menu and does the minimal amount of adjustment that isnecessary before posting the menu.andM;Component GraphicsandM;The window frame provided by mwm for decorating client windows consists of anumber of components representing different window management functions.andP;  Thefunctionality and layout of the components are the same as in PresentationManager.andP;  However, mwm enhances the appearance of the frame by adding the 3Dappearance.andM;It is important for mwm to be as fast as possible to implement a good directmanipulation interface.andP;  The two principal things that were done to speed upthe graphics rendering were to minimize the number of X protocol requests todraw the frame, and to do all the drawing to one window.andM;A fully configured mwm window frame consists of a border and a title bar.andO;The border is divided into eight resize handles.andP;  The title bar is dividedinto boxes (or gadgets) for the system menu, the title text, and the minimizeand maximize functions.andP;  The height of the title bar and the drawings insidethe gadgets are scaled to match the height of the font used for the text inthe title bar.andM;A frame with the 3D look may have as many as four colors displayed at once.andO;These are the background, the foreground (title text), and the top shadow andbottom shadow colors (see Fig.andP;  12).andP;  The background color makes up themajority of the color visible in a frame.andP;  Mwm sets the background color of aframe by setting the background attribute of the frame window.andP;  Thebackground of all the frame components is set in one X graphics call.andP;  Oncethis attribute is set, the X server takes care of painting the background ofthe window in response to exposure events.andM;Graphic contexts are used to store much of the information required by the Xgraphics routines.andP;  This includes items such as colors, line styles, and clipregions.andP;  Mwm creates several graphic contexts for use in drawing the frame.andO;These graphic contexts may differ in foreground color and fill tile.andP;  Theyare created when the window manager starts up and are used for all the windowframes.andP;  When mwm draws a differently colored part of the frame, it passes adifferent graphic context to the graphics drawing routine.andM;The title text is usually drawn in one XDrawString call using the graphiccontext containing the foreground color.andP;  If the text is too long for theavailable space, then the text is truncated by setting a clip rectangle intothe graphic context before calling XDrawString.andM;The remainder of the frame is made of the top and bottom shadow colors.andP;  Thisincludes the outer 3D shadowing, the separations between the resize handles,the edges of the title bar buttons, and the images inside the system minimizeand maximize buttons.andP;  This drawing is done with only two calls toXFillRectangles.andM;XFillRectangles takes, among its arguments, a list of rectangles and agraphics context.andP;  Mwm generates two lists of rectangles for top and bottomshadows when a frame is built.andP;  This occurs whenever a frame is needed for anew window, or when a window has been resized.andP;  To make this task simpler tocode, two helper routines were constructed to add data to an existing pair oflists.andP;  One routine adds the top and bottom shadows to construct rectangularfeatures.andP;  The other routine adds the top and bottom shadows to construct thecorner resize handles.andP;  The shadowing for the entire frame is constructed outof multiple calls to these two routines.andM;Mwm always redraws the entire frame in response to an exposure event.andP;  In thebest case, this takes three X graphics calls for drawing the text and the topand bottom shadows.andP;  If the text is clipped, then two more X calls arerequired for setting and clearing the clip rectangles.andP;  If the backgroundcolor of the frame changes, then two additional calls are needed to set theframe window background attribute and clear the window to the new background.andO;The common case of setting or clearing the focus indication on a window frametakes five X graphic calls.andM;The performance of this frame redrawing algorithm has been adequate.andP;  Apossible optimization would make the exposure event handling smarter by onlydrawing those areas that need to be drawn.andP;  This would require eithergenerating a new list of rectangles for the exposed region, or picking outthe affected rectangles from the list of rectangles for the whole frame.andO;Since X drawing calls map into X protocol requests (which can becomputationally expensive), the optimization would have to avoid generatingmore X protocol requests than the approach taken above.andM;Testing a Window ManagerandM;Mwm has a programmatic interface that is used by clients and an interactiveinterface for users.andP;  The testing of mwm needed to cover both of theseinterfaces.andP;  The approach to testing the programmatic interface involvedwriting a number of special-purpose clients that systematically generated allof the events that the mwm programmatic interface handles.andP;  These programswere run for each regression test as mwm progressed through its variousdevelopment releases.andM;The testing of the interactive mwm interface required a much differentapproach.andP;  The interactive nature of the interface precluded the use of testprograms.andP;  Testing could have been accomplished by developing test scriptsthat testers would follow for each regression cycle and each tested hardwareconfiguration.andP;  However, this is an extremely tedious and expensive approachto testing.andM;Fortunately the Xtm (X test monitor) testing tool was developed for testinginteractive X clients.andP;  Xtm is based on the record-replay software testingtechnique.andP;  In this technique human interactions with the system are recordedin a file and replayed later for regression testing.andP;  Xtm records all mouseand keyboard interactions and saves them in an interactive test script file.andO;The tester can at any time save snapshots of all or part of the screen.andP;  Forregression testing the Xtm interactive test scripts can be replayed.andP;  Xtmcompares the saved screen images with the replay screen images and flags anydifferences.andP;  A tester only has to spend time recording the interactive testscript and checking the results of the automated regression tests.andP;  Use ofXtm also allowed repeatable testing.andP;  A user could not be expected to move apointer in exactly the same way or remember what a screen looked like down toa single pixel each time a test script is followed.andM;Mwm testing also benefited from the wide distribution it received throughOSF.andP;  Mwm was made available to a sizable number of people at OSF membercompanies including HP.andP;  These users had a variety of software and hardwareenvironments as well as different patterns of use and expectations from auser interface.andP;  Their input provided a useful adjunct to the testing doneusing Xtm.andM;AcknowledgmentsandM;We would like to acknowledge all those that helped with the development ofmwm.andP;  First are the other members of the mwm (and hpwm) team: project managerKaren Helt, Fred Handloser, and Paul McClellan.andP;  Shizunori Kobara's help wasinstrumental in designing a good-looking window frame.andP;  Finally, we wouldlike to acknowledge the Open Software Foundation for its vision in promotingindustry standards and for picking hpwm as the basis for the OSF/ Motifwindow manager.andM;ReferencesandM;1.andP;  F. E. Hall and J. B. Byers,  X: A Window System Standard for DistributedComputing Environments,&quot;  Hewlett-Packard journal, Vol.andP;  39, no.andP;  5, October1988, pp.andP;  46-50.andM;2.andP;  Hewlett-Packard journal, Vol.andP;  40, no.andP;  6, December 1989, pp.andP;  B-46.andM;3.andP;  Ibid, pp.andP;  33-38.andM;4.andP;  C.D.andP;  Fuget and B.J.andP;  Scott, &quot;Tools for Automating Software Test PackageExecution,&quot; Hewlett-Packard journal, Vol.andP;  37, no.andP;  3.andM;5.andP;  K.A.andP;  Olsson and M. Bergman, &quot;A Virtual User Simulation Utility,&quot;Hewlett-Packard journal, Vol.andP;  39, no.andP;  2, April 1988, pp.andP;  48-53.andM;6.andP;  M.R.andP;  Tuttle and D. Low, &quot;Videoscope: A Nonintrusive Test Tool forPersonal Computers,&quot; Hewlett-Packard journal, Vol.andP;  40, no.andP;  3, June 1989,pp.andP;  58-64.andM;Table IIandM;Window Properties !!! BEGIN TABLEandM;Property             UseandM;_MOTIF_WM_HINTS      Frame decoration and functionandM;preferencesandM;_MOTIF_WM_MENU       Modify window menuandM;WM_CLASS             Client class for fetching resourcesandM;WM_HINTS             Icon imageandM;WM_ICON_NAME         Icon nameandM;WM_ICON_SIZE         Icon sizes preferred by windowandM;managerandM;WM_NAME              Client window nameandM;WM_NORMAL_HINTS      Window position and sizeandM;WM_PROTOCOLS         Client-windowmanagerandM;communicationandM;WM_STATE             Window manager state for clientandM;WM_TRANSIENT_FOR     Secondary window indicator !!! END TABLEandM;Interclient Communication ConventionsandM;The X Window System Version 11 (X) was designed to be a platform on whichwindowed application environments could be built.andP;  it provides a basic set ofmechanisms for building these environments and does not impose any particularuser interface behavior.andP;  With a minimal set of constraints on behavior anX-based application  X client) may be usable in isolation but unable tocoexist with other X clients.andP;  Coexistence entails civilized sharing oflimited resources (e.g., the physical color map) and the use of standardmechanisms for exchanging information (e.g., cutting and pasting text).andP;  Awindow manager can enforce coexistence of X clients in areas such as the useof screen space and keyboard input, but even a window manager does not haveabsolute power to maintain order.andP;  An unfriendly X client could grab the Xserver and prevent other X clients from getting input or doing output.andM;Inter-Client Communications Conventions ManualandM;Early in the development of X, representatives from the different companiesworking on or with X started meeting to address the problem of X clientcoexistence.andP;  This group has been officially sanctioned by the X Consortiumto develop interclient communication conventions.andP;  The conventions that havebeen developed are documented in the Inter-Client Communication ConventionsManual (ICCCM).andP;  ICCCM compliance has become a key design criterion for Xclients.andP;  The development of the ICCCM is ongoing and the general goals thatshape this development include:andM;*  Improving client coexistence in areas of potential contention.andM;*  Tracking the evolution of the X Window System and X clients and providingnew conventions that are generally applicable.andM;* Adding X Window System support for new conventions.andM;* Ensuring that all ICCCM changes are backwards compatible.andM;This means that all previously defined conventions are maintained,andM;and old conventions are changed only when theyandM;clearly cause incorrect behavior.andM;Client-To-Window-Manager CommunicationandM;Many conventions are documented in the ICCCM.andP;  However, the conventions thathave received the most attention by X client developers have been thosedealing with client-to-window-manager communication.andP;  A key goal of the mwmdesign was ICCCM compliance.andP;  X clients that are ICCCM compliant can coexistin a predictable manner with mwm and with each other.andP;  Window properties areone of the X mechanisms for client-to-window-manager communication.andP;  A windowproperty is a collection of information of a particular type that isassociated with a window.andP;  Clients associate, by convention, severalproperties with their windows to communicate with the window manager.andO;Noteworthy examples of properties that are used for client-to-window-managercommunication are WM_NORMAL_HINTS and WM_PROTOCOLS.andP;  The WM_NORMAL_HINTSproperty deals with window size and positioning, and WM_PROTOCOLS deals withpublic or private window manager communication protocols.andM;Client Window Size And PositionandM;The WM_ NORMAL_ HINTS property is used by a client to give a hint to thewindow manager on how the client window should be positioned on the screenand what its size should be.andP;  The window manager enforces how a client ispositioned and sized on the screen.andP;  Some window managers may enforce apolicy where all client windows are tiled on the screen (displayed withoutoverlapping), or where windows are not allowed to be displayed with part ofthe window off the edge of the screen.andP;  The WM-NORMAL_ HINTS propertyprovides the window manager with a starting point from which it then appliesthe screen layout policies.andP;  An ICCCM compliant window manager can ignoresome or all of the information contained in the WM_NORMAL_HINTs property.andP;  AnX client should be designed to be robust enough to work in environments wherethis is the case.andP;  This demand on X clients is based on an ICCCM principlethat the user is in control of the user interface, not the X clients.andM;The WM_NORMAL_HINTs property contains the following pieces of information:andM;* Minimum and maximum window sizes.andP;  These are reasonable minimum and maximumsizes for the window.andP;  Mwm uses the maximum size when a window is maximized.andM;* Base and increment window sizes.andP;  The overall window size is the base sizeplus some number of increments.andP;  mwm adjusts a window size to meet thisconstraint when the window is initially placed on the screen or followingresizing by the user.andP;  This is especially useful when the window isassociated with a terminal emulator X client.andP;  The base window size usuallyincludes the height of the softkeys.andP;  The increments are set to be equivalentto the height and width of one of the characters displayed in the terminalemulator window (terminal emulator X clients use fixed-size fonts in whichall characters are the same size).andM;* Minimum and maximum window aspect ratios.andP;  The aspect ratios indicateallowable values for the ratio of the window width to the window height.andP;  Forexample, an X client can indicate that it would always like to be displayedin a square window (the aspect ratio is 1:1).andM;* Anchor point for window placement.andP;  The anchor point for placing a windowallows an X client to specify how the window position should be interpreted.andO;This is useful in the case where a window manager adds a frame around the Xclient window and adjusts the position of the X client window on the screen.andO;The X client can specify an anchor point such that a corner or side of the Xclient window, including the window manager frame, is placed at a particularabsolute location on the screen.andP;  In general, mwm uses the WM_NORMAL_HINTSinformation with little or no change to place an X client window.andO;Adjustments are only made if the user requests some refinement of the mwmwindow placement policy (e.g., the user requests that windows beinteractively placed when they are first displayed).andP;  In placing an X clientwindow on the display, mwm first determines a desirable window size, which isusually the window size specified by the X client.andP;  Mwm then retrieves theWM_NORMAL_HINTS property.andM;The processing of the WM_NORMAL_HINTS property varies based on the version ofthe ICCCM that the associated client implements.andP;  Mwm uses the size of theproperty in figuring out which version of the ICCCM to use.andP;  This allows mwmto be backwards compatible in complying with the ICCCM.andP;  Client and WindowManager ProtocolsandM;The WM-PROTOCOLS property is used by an X client to indicate interest inpublic or private window-manager-to-client communication protocols.andP;  Ingeneral, these protocols are used to inform an X client of some windowmanager action that has occurred or is about to occur (e.g., the windowsystem is about to be terminated).andP;  Public protocols are registered by the XConsortium, specified in the ICCCM, and supported by most, if not all, ICCCMcompliant window managers.andP;  Private protocols are specific to a particularwindow manager.andP;  Private protocols that have high utility and widespreadacceptance by X client developers usually become public protocols.andM;The WM-PROTOCOLS property is formatted as a list of protocol identifiers.andO;Many window managers, including mwm, keep track of X client changes to theproperty.andP;  This allows an X client to participate only in those protocolsthat it requires at a particular time.andP;  The WM-PROTOCOLS list can accommodateany number and mix of public and private protocols.andM;The WM_DELETE_WINDOW protocol is a commonly used public protocol.andP;  Thisprotocol is used to inform X clients that a request has been made (probablyby the user) to get rid of an X client window.andP;  This protocol is used bywindow managers to implement a clear and consistent user interface forgetting rid of windows.andP;  Typically, deleting a window also includes deletingthe X client that is associated with the window.andP;  Mwm uses the WM_DELETE_WINDow protocol to close a window.andP;  The mwm close function can be accessedfrom the standard window menu that is posted by pressing the window menubutton in the client window frame.andP;  if the close function is invoked on aclient that does not participate in the WM_DELETE_WINDOW protocol, mwm usesthe X request XKillClient to get rid of the window and terminate the client.andO;in this case the client finds out that it has been terminated but cannotprevent or delay the termination.andP;  This is not appropriate for clients thatwould like to interact with the user on termination, or clients that havemultiple windows that can be independently terminated.andP;  If a client doesparticipate in the WM_DELETE_WINDOW protocol, mwm sends a termination requestmessage to the client indicating that the window is to be terminated.andP;  It isthen up to the client to determine how to deal with the window, because mwmtakes no further action.andP;  Well-behaved clients immediately remove the windowfrom the screen or prompt the user for confirmation.andO;</TEXT></DOC>