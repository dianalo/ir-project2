<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-551-586  </DOCNO><DOCID>08 551 586.andM;</DOCID><JOURNAL>Dr. Dobb's Journal  June 1990 v15 n6 p126(3)* Full Text COPYRIGHT Mandamp;T Publishing 1990.andM;</JOURNAL><TITLE>LZW revisited: speeding up an old data compression favorite.andO;(tutorial)</TITLE><AUTHOR>Regan, Shawn M.andM;</AUTHOR><SUMMARY>A data compression program presented in the Oct 1989 issue of DrDobb's Journal, LZW Data Compression, is modified to performfaster and provide effective compression of some types of largerfiles.andP;  The original code actually created larger files than theoriginal for certain types of files.andP;  The new compression routineinvolves adjusting code size at the same point where thecompression program's and expansion program's string table isfull, setting an arbitrary limit on code size, ensuring that thetable size is more than two times the maximum code size andmonitoring compression ratios.andP;  Source code for the newcompression program is available on disk, on CompuServe and on DrDobb's Journal's Listing Service.andM;</SUMMARY><DESCRIPT>Topic:     Data CompressionPerformance ImprovementApplications ProgrammingProgramming InstructionProgramsCodes.andO;Feature:   illustrationtableprogram.andO;Caption:   Typical compression levels using revised LZW. (table)Upgraded LZW data compression program. (program)andM;</DESCRIPT><TEXT>LZW RevisitedandM;When the October 1989 issue of Dr. Dobb's came out, I was delighted to seeMark Nelson's article on LZW data compression (&quot;LZW Data Compression&quot;).andP;  Markpresented a clear description with code of a basic LZW compression program.andO;As I used the program, however, I discovered that for some larger files, evenwhen using 14-bit codes, the compressed file would actually be larger thanthe original.andP;  Because Mark's intention was to enlighten and not tocomplicate the subject, his code omitted some optimizing additions to LZWcompression.andP;  Although, he did describe some optimization techniques --including the use of variable code size -- as well as clearing the stringtable after the compression ratio degrades.andM;The original program's lack of performance on larger files can be traced tothe fixed-length string table.andP;  When the table is full, new codes cannot beadded and must be sent out in character form with no compression done.andP;  Whenthis happens, you could actually be sending out an 8-bit character using a14-bit code; this explains how the file can get larger.andP;  If your incomingdata changes, even moderately, with the string table full, then thecompression ratio begins to degrade rapidly.andM;With this in mind, imagine compressing a small file with your code size setat 14 bits.andP;  If your string table needs less than 511 entries, you could haveused 9-bit codes saving 5 bits per output code.andP;  Of course you wouldn't wantto fix your code size at 9 bits because the compression on larger files wouldsuffer.andP;  What you would like is for the code size to start at 9 bits and ifthat table filled, the code size could increment to 10, thus providingoptimal performance on any size file.andM;My ImplementationandM;One of the more elegant features about LZW compression are that thecompression and expansion programs build the exact same string table for aparticular file.andP;  This means at the same point the compression program'sstring table is full so is the expansion program's.andP;  At this point you shouldtry to adjust your code size.andP;  As you can see in the compression section ofListing One (page 127), I wait until after I have sent out the current codebefore the code size is incremented because the current code belongs to theprevious code size.andP;  Notice in the compression section I increment when thecode size is greater than max_code, while in the expansion program Iincrement when the code size equals max_code.andP;  This is because the expansionsection is working a code behind using old_code instead of new_code.andP;  It isalso because of this that I must handle a special case when incrementing thecode size on an end-of-file condition.andM;Finally, you should also set some arbitrary limit on your code size.andP;  If youuse 14 bits, your codes stay well under the positive integer maximum of32767, which suits the program without any modification.andP;  Don't forget yourtable size needs to be a prime number somewhat larger than 2andless;MAX_CODE_SIZE.andO;To implement the table clearing, start by monitoring the number of bytes (notcodes) read in and then sent out.andP;  After a predetermined interval, computethe new compression ratio and check it against the previous one.andP;  If theratio has increased, you need to clear out the string table and start over.andO;You then need a device to send a signal from the compression program to theexpansion program to clear the string table.andP;  The easiest way to accomplishthis is by reserving the first of the 9-bit codes.andP;  In my example, I used 256as the CLEAR_TABLE code.andP;  I also used 257 as the TERMINATOR to signal theend-of-file condition.andP;  This means the first available code for compressionis now 258, which I've defined as FIRST_CODE.andM;When combining both methods, you should not experience any degradation incompression until the table is full.andP;  When the table is full, you will firstcheck to see if you can increase the code size.andP;  If you can't, then (and onlythen) will you start to monitor your compression ratio at your predefinedinterval and ultimately clear the string table.andP;  When this happens, you canreset your code size back to 9-bits because basically you're starting fromscratch.andP;  Although you still won't get performance as good as PKZIP (fromPKWARE, Glendale, Wisc.), you now have the source for a much improved versionof this basic LZW compression program.andP;  Table 1 lists some typicalcompression levels I've achieved with this program.andM;Your ImplementationandM;Even though the program works well as is, there are still some improvementsthat can be made.andP;  As Mark suggested, the input and output routines can bemodified for more speed.andP;  Also, a more sophisticated hashing routine mightspeed it up.andP;  For better compression, you might experiment with tableclearing.andP;  I found on .EXE files the compression ratio drops steadily after acode size increase, then bottoms out and then starts rising again.andP;  If yoususpend clearing until you are back to just below the starting ratio you canget a somewhat better compression.andP;  I also noticed that in smaller textfiles, I can at times get better compression by clearing the table instead ofincreasing the code size.andP;  Be careful, however, about basing any optimizationmethods on any preanalysis of the data.andP;  If, for example, you wish to use itwith stream I/O you will be working with buffers and not files where anypreanalysis might be difficult or useless.andM;Shawn is a programmer/analyst for MicroBilt Inc. of Atlanta, Georgia.andP;  Youcan reach him through Interlink; or write to him at 2127B Powers Ferry Rd.,andO;Marietta, GA 30067.andO;</TEXT></DOC>