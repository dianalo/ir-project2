<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-375-088  </DOCNO><DOCID>07 375 088.andM;</DOCID><JOURNAL>AI Expert  July 1989 v4 n7 p34(9)* Full Text COPYRIGHT Miller-Freeman 1989.andM;</JOURNAL><TITLE>Making PROLOG parallel. (technical)</TITLE><AUTHOR>Eadline, Douglas.andM;</AUTHOR><SUMMARY>The PROLOG language, because it is referentially transparent andnonprocedural, is well suited to parallel computing environments.andO;Process models are theoretical approaches for implementingparallel PROLOG which look at OR and AND parallel behavior.andP;  ORparallelism avoids the backtracking approach used in sequentialPROLOG for nondeterministic programs.andP;  AND parallelism, used indeterministic programs, obtains a single solution by verifyingmultiple queries independently.andP;  These methods usually incorporateguard clauses, which help control parallel execution but cannotprovide full OR parallelism.andP;  Process models that specify both ANDan OR parallelism without guard clauses wait until a binding forshared variables is produced before executing subgoals containingthese variables.andP;  Implementation models are discussed andcurrently available parallel PROLOG implementations are described.andM;</SUMMARY><DESCRIPT>Topic:     Artificial IntelligencePROLOGNonprocedural LanguagesParallelismSets.andO;Feature:   illustrationprogramchart.andO;Caption:   The 'classic' family tree example. (program)The OR parallel specification of ?-parent. (chart)The AND parallel specification of ?-grandparent. (chart)andM;</DESCRIPT><TEXT>Making PROLOG PARALLELandM;The combination of PROLOG and parallel computers is not coincidental.andO;Programming parallel computers requires a higher degree of control than thatfound on sequential machines.andP;  The programmer must be concerned withinterprocessor communication, synchronization, and work distribution, inaddition to shared variables.andP;  For example, a program running on processor Acannot modify variables in use on processor B.andP;  Because PROLOG is bothdeclarative (not dependent on procedural control) and referentiallytransparent (prohibiting different assignments of the same variable), itwould seem naturally suited for parallel environments.andP;  Furthermore, theoft-cited Japanese fifth-generation computer project is based largely onparallel computers and logic programming.andP;  However, several issues must beaddressed beofe PROLOG can be made parallel.andM;These issues concern what type of parallelism to exploit and how to implementthat parallelism physically.andP;  Because logic programs may employ two types ofparallel logic, OR and AND parallelism, different schemes have been developedto specify various levels of parallelism.andP;  The potential utility of any oneparallel PROLOG methodology will depend largely on the parallelism expressedby the programmer.andP;  Understanding parallel logic is therefore an especiallyimportant prerequisite to using parallel PROLOG.andM;Before parallel logic can be described, a subtle point must be considered.andO;Parallel execution does not imply a parallel algorithm.andP;  As with many other&quot;myths&quot; about PROLOG, writing programs in PROLOG does not magically describeyour program in parallel.andP;  Portions of your program may translate quite wellinto a parallel environment, while other protions, no matter how manyprocessors are at your disposal, will never be able to use more than oneprocessor.andP;  Possessing a parallel problem is as important as possessing aparallel computer.andM;THE PROCESS MODELandM;A process model for implementing parallel PROLOG is a theoretical appraochthat makes few specific hardware assumptions.andP;  The goals of a process modelare to identify and specify all the parallel processes within a given logicor PROLOG program, make sure the parallel execution is complete, and find allpossible solutions.andP;  In general, process models look for two types ofparallel behavior, OR and AND parallelism.andP;  The classic family tree programin Listing 1 illustrates both.andM;OR PARALLELISMandM;OR parallelism is often associated with non-deterministic logic programs(those with more than one solution).andP;  Consider the query?-parent(Kay,R), inwhich we want to find the children of kay.andP;  Because the parent relationoccurs twice in the database, sequential PROLOG will first try to solve thequery using the relation parent(x,y):-father(X,Y).andP;  and then backtrack tosolve parent(X,Y):-mother(X,Y).andP;  In both cases, X is bound to the constantkay and Y is bound to the variable R.andP;  In theory, answers can be producedfrom the unification of either father(kay,R) or mother(kay,R).andP;  Thesesearches are classified as OR parallel.andP;  Given two processors, the search forsolutions from either father(kay,Y) or mother(kay,Y) can proceedindependently and in parallel.andP;  Further OR parallelism can be found for eachinstance of father and mother in the database.andP;  For example, for eachoccurrence of the relation mother, a separate unification of mother(kay,R)can be initiated, which will result in two failures and four bindings:Bindings: Failures: Y = steve  Y = lauren Y = doug  Y = matthew Y = tim Y =kathyandM;Figure 1 illustrates the full OR parallel specification of ?-parent(kay,R).andO;The most important property of a full OR parallel PROLOG is that backtrackingis replaced with parallel execution of all OR branches.andM;AND PARALLELISMandM;AND parallelism is often associated with deterministic logic programs (thosewith only one solution) and can be illustrated by considering the query?-parent(dave,steve), parent(steve,lauren).andP;  The query is true ifparent(dave,steve) and parent(steve,lauren) are true.andP;  Given two rpocessors,the verification of both parent(dave,steve) and parent(steve,lauren) canproceed independently and in parallel.andP;  The effect of variables in ANDparallelism can be seen by examining ?-grandparent(kay,matthew).andP;  To verifythis query, PROLOG must solve the clause parent(kay,Z), parent(Z,matthew).andO;If each subgoal is solved independently, each will return a different set ofbindings for the variable Z.andP;  For example, parent(kay,Z) will produce: Z =steve Z = doug Z = tim Z = kathy and parent(Z,matthew) will produce: Z =steve Z = shirleyandM;Proof of the initial query will require an intersection of the two sets ofbindings, in this case Z = steve for both subgoals.andP;  If the binding sets donot intersect, a binding conflict occurs, even though both subgoals havesucceeded.andP;  Figure 2 illustrates the AND parallel specification for the query?-grandparent(kay,matthew).andM;Allowing each subgoal to execute in parallel does have some drawbacks.andO;Consider the query ?-grandparent(kay,R).andP;  A fully AND parallel evaluation ofthe query would solve parent(kay,Z) and parent(Z,R) separately.andP;  The bindingsgenerated by the subgoal parent(kay,Z) would be the same as before, while thesubgoal parent(Z,R) would produce 12 binding pairs: Z = dave, R = steve Z =dave, R = doug .andP;  .  .  Z = shirley, R = lauren Z = shirley, R = matthewandM;By working independently, the second subgoal has made 10 unnecessarybindings: all those where Z is not equal to steve, doug, tim, and kathy.andP;  Hadthe second subgoal known about the bindings the first subgoal was producingfor Z, the search space would have been limited by these u seful bindings.andO;In turn, the time required to solve the query would have been reduced.andO;Figure 3 illustrates the full AND parallel specification for the query?-grandparent(kay,R).andM;The unnecessary searching by separate subgoals can easily cause parallelexecution to take longer than sequential execution.andP;  Another difficultyintroduced by AND parallelism is the overhead needed to find the intersectionof binding sets returned by each subgoal.andP;  Indeed, a rule such asq(X,Y,S):-a(X,Y),b(X,T),c(Y,S),d(T,S,X).andP;  has variable dependencies thatrequire the intersection of bindings from all four subgoals to be determinedfor correct evaluation.andM;Process models, called full OR, full AND, or full AND-OR parallel indicatingthe amount of parallelism that will be extracted from a logic program, havebeen developed to handle AND parallelism.andP;  The full AND-OR process models arethe most complex but yield the most parallelism.andP;  Defining full parallelismis beyond the scope of this article but becomes important when assessingprocess models.andP;  (L.V.andP;  Kale has analyzed full parallelism in logicprograms.)andM;Along with full parallelism, the term &quot;complete&quot; is often used to describeparallel process models.andP;  In simple terms, completeness guarantees that allexisting solutions to a logic program will be found.andP;  Although this soundstrivial, the backtracking mechanism, and hence sequential PROLOG, can beproven incomplete.andP;  Briefly, if a logic program contains an &quot;infiniterelation&quot; (one that continually produces bindings), a process model may getstuck under some conditions and fail to identify other parallel branchesleading to solutions.andP;  The need for completeness in logic programs isdebatable.andP;  However, as schemes for parallel execution of logic programsemerge, a clear notion of completeness is important.andP;  Many strategies havebeen suggested for coping with the various difficulties introduced by ANDparallelism.andM;GUARD-ANNOTATION TECHNIQUESandM;These techniques usually place some type of guard test before each clause ofa relation.andP;  The purpose of a guard clause is to help control parallelexecution.andP;  One strategy requires that, for a given relation, the OR parallelunification of all clauses be attempted and the first of those clauses with asuccessful guard test be allowed to execute.andP;  Using the family tree programin Listing 1 as a simple example, the parent relation could include two guardtests called male(X) and female(X) based on additional information added tothe database: parent(X,Y):-male(X):father(X,Y).andO;parent(X,Y):-female(X):mother(X,Y)andM;The guard relations can be defined by the user but cannot bind any variables.andO;After unification, the query ?-parent(steve,Y) performs the guard testmale(steve) and female(steve) for both instances of the relation.andP;  If X werebound to a male or female term, the remainder of the appropriate clause wouldbe solved by producing a binding for Y.andP;  If X were not bound to male orfemale, neither clause would be solved.andP;  The inclusion of AND parallelism iscontrolled by the programmer.andP;  Within a clause, subgoals are separated byeither a parallel or sequential conjunction operator.andP;  Variables are oftenannotated as &quot;readers&quot; (input) or &quot;writers&quot; (output) to handle bindingconflicts.andP;  In addition, OR parallelism is often implemented as &quot;don't-carenondeterminism,&quot; which means the parallel search will stop after one solution(as opposed to all solutions) has been found.andM;The lack of full OR parallelism is often considered a disadvantage ofguard-annotation techniques.andP;  Furthermore, annotating variables, specifyingconjunction operators, and supplying guard clause expressions have created anew parallel logic language.andP;  Whether PROLOG will have to undergo this typeof metamorphosis to be an effective parallel language is debatable.andP;  Examplesof these methods include PARLOG, Concurrent PROLOG, and Delta-PROLOG.andM;AND-OR PROCESS MODELSandM;Several methods have been proposed that specify AND and OR paralliems inlogic programs without requiring guard clauses, conjunction operators, orvariable annotations.andP;  In general, these process models halt execution ofsubgoals containing shared variables until a binding for those variables isproduced.andP;  For example, the query ?-grandparent(dave,Y), after u nification,would start by solving the first subgoal parent (dave,Z).andP;  The secondsubgoal, parent(Z,Y), would not start until a binding for Z was produced bythe first subgoal.andP;  As more bindings were produced, the second subgoal wouldcontinue to accept bindings, starting a separate parallel process for eachbinding.andM;One complication of this approach occurs when bindings must be merged in aclause.andP;  For example the clause q(X,Y,S):-a(X,Y),b(X,T),c(Y,S),d(T,S) mayrequire bindings produced from two separate clauses, b(X,T) and c(Y,), to bemerged in clause d(T,S).andP;  Care must be taken to ensure that merged bindingshave been derived from the same origin.andP;  For instance, an X,Y binding pairproduced by a(X,Y) will produce a set of S and T bindings from b(X,T) andc(Y,S).andP;  Only combinations of S and T bindings originating from a unique X,Ybinding pair can be merged for input to the subgoal d(T,S).andP;  To keep track ofthe legal bindings, AND-OR process models often use some form ofsynchronization (orr &quot;sync&quot;) mechanism to solve the merge problem.andP;  Theadvantage of AND-OR process models is the creation of useful parallel ANDprocesses by passing of shared bindings.andP;  AND-OR process models usuallyimplement OR parallelism by initiating a parallel process for each instanceof a relation.andM;AND-OR parallelism results in increased overhead--synchronization, merging,and dataflow analyses required for the shared bindings in AND parallelclauses.andP;  In addition, passing shared bindings between AND parallel subgoalsrequires some type of global routing algorithm.andP;  All these overhead tasksrequire additional processor time that would not be a factor with sequentialbacktracking PROLOG.andP;  Indeed, small PROLOG programs may require more AND-ORoverhead time than processing time.andP;  Examples of these models include theAND-OR process model, the Sync model, and the Reduce-OR process model.andP;  Ofall the process models mentioned here, only the Reduce-OR model can beconsidered complete.andM;RESTRICTED MODELSandM;Restriction methods limit the amount of parallelism found in logic programs.andO;Although this idea may contradict a fully parallel PROLOG, practical hardwarereasons call for adopting restricted parallelism.andP;  Arguments have also beenmade against the need for full AND parallelism in logic programs.andP;  As aresult, the Restricted AND Parallel (RAP) model has been proposed as a modelfor AND parallelism.andP;  Restricted AND parallelism forces sequential executionof all subgoals in a clause that share variables.andP;  If the subgoals share novariables, theya re allowed to execute in parallel.andP;  As an example, considerthe rule in Listing 1, child(X,Y,Z):-father(Y,X),mother(Z,X).andP;  The query?-child(X,dave,kay) would be solved sequentially because the X variable isshared between the subgoals father(dave,X) and mother(kay,X).andP;  Conversely,the query ?-child(kathy,Y,Z), would be solved in parallel because novariables are shared between the subgoals father(Y,kathy) andmother(Z,kathy).andP;  Restricted AND parallelism employs backtracking andtherefore does not take advantage of OR parallelism in logic programs.andP;  Forexample, in the preceding rule, only one solution to relation father(Y,X)will be found at a time.andM;The Restricted OR-AND Parallel (ROAP) model is an extension of the RestrictedAND Parallel model that employs a form of OR parallelism.andP;  Consider, again,?-child(X,dave,kay).andP;  As with the RAP model, after unification, the subgoalfather(dave,X) is solved first, due to the shared X variable.andP;  Unlike the RAPmodel, however, ROAP will produce all the possible bindings for X and spawn aparallel task for each instance.andP;  For example, after unification, thepreceding query will return four bindings for father (dave,X): X = steve X =doug X = tim X = kathyandM;Then the second subgoal will use the returned bindings to spawn four tasksthat can be solved in parallel: mother(kay,steve) mother(kay,doug)mother(kay,tim) mother(kay,kathy)andM;Like the RAP model, the ROAP model also allows AND parallelism if novariables are shared between subgoals.andM;From a process-model perspective, restricting parallelism reduces theoverhead required to produce full AND parallelism.andP;  Restriction models reduceparallelism, but reduced parallelism may be an advantage when the processmodel is implemented on a real parallel computer.andM;THE IMPLEMENTATION MODELandM;The discussed process models assumed very little about parallel PROLOG'shardware environment.andP;  The bridge between a process model and a particularhardware environment is an implementation model.andP;  The implementation model isimportant because it must take the parallel tasks specified by the processmodel and produce efficient execution on real hardware.andM;As a working definition, an implementation model will be considered efficientif it can produce an independent, scalable, and load-balanced execution of alogic program.andP;  Independent execution mandates that the program not supplyspecific control to the parallel network.andP;  For example, the programmer shouldnot have to control interprocessor communication when writing a logicprogram.andP;  Scalable execution requires that a logic program run on manyprocessors without modification.andP;  The program's execution speed shouldincrease as the number of processors increases, with the maximum scalabilitydetermined y the programmer's algorithm.andP;  Scalability also ensures that aprogram will execute on just one processor.andP;  Finally, load-balanced executionrequires that all processors work to their maximum capacity.andP;  In particular,all processors should be equally and constantly busy with minimum timedevoted to the parallelization process.andM;The combination of process and implementation models presents an interestingquestion: why continue identifying and specifying more parallel processeswhen all available processors are busy?andP;  The problem with developing acombined process and implementation model is not finding parallelism butrather controlling the search.andP;  Indeed, ferreting out concurrent processeswhen all processors are busy can degrade system performance.andP;  Generatingparallel processes in logic programs can easily become exponential due tomany OR parallel solutions and recursive rules.andP;  Even simple PROLOG programscan saturate a network of 20 processors.andM;As an example, consider the quisort program in Listing 2.andP;  As demonstrated inFigure 4, each call to quisort generates two recursive calls to itself thatcan be performed in parallel.andP;  Thus, sorting the numbers (5,3,2,1,4,8,7,6,9)with quisort would generate almost 20 quisort tasks.andP;  Controlling, notidentifying parallelism is the most important property of any parallel PROLOGimplementation.andP;  In essence, a fully parallel PROLOG may be &quot;too parallel&quot;for all but the most massive (500 or more processors) parallel machines.andM;When creating an integrated process-implementation model, these factors mustbe considered.andP;  In particular, to assure scalability and load balancing, somemechanism must be present to turn the parallelization process on and off.andP;  Ofthe process-model methodologies presented, restriction models permit thegreatest control of the parallelization process.andP;  The restriction mechanismdecides whether to evaluate a clause as sequential or parallel, based on ananalysis of shared variables.andP;  The same mechanism can be employed to restrictparallelism based on analysis of available processors.andM;Allocating available processors can be accomplished with one of two methods.andO;The first method, global allocation, requires a constant account of busy andidle processors, and all requests for processors and communication betweenprocessors must pass through a central controller at some point.andP;  Thiscentralized control can potentially create a bottleneck and excessiveoverhead as the number of processors increases.andM;The second method, local allocation, is the opposite of global allocation.andO;Each processor is responsible for finding an idle processor that can accept aparallel task.andP;  Local allocation requires busy processors with parallel tasksto check the status of its nearest neighbors.andP;  If a neighbor is idle, a taskis given to it for processing.andP;  If the neighbor is busy, the processor triesanother neighbor or solves the task &quot;at home.&quot;andP;  Local allocation requiresminimal overhead and is independent of the number of processors.andP;  However,local allocation has one drawback.andP;  Situations may arise where parallelprocesses cannot find their way to idle processors.andP;  Extending the reach of aprocessor beyond its nearest neighbors is one solution, but it requires moreoverhead.andM;Local allocation works nicely with restriction methods.andP;  If a processorcannot find any idle neighbors, sequential execution begins and the searchfor parallel processes halts.andP;  Since the design of restriction models has abuilt-in sequential pathway, the transition from parallel to sequentialoperation or from sequential to parallel operation is a fast, low-overheadprocess.andM;The exact implementation of a given process model will undoubtedly be verymachine-specific.andP;  Each may have advantages or disadvantages for differenthardware approaches to parallel computing.andM;THE REAL THINGandM;The availability of parallel PROLOG obviously depends on the availability ofa parallel computer.andP;  Although not commonplace, parallel machines arebecoming more widespread and economical.andP;  In particular, networks built fromthe INMOS Transputer (Bristol, U.K.) can be inexpensively added to existingApple Macintosh II and IBM PC-compatible computers.andP;  The following is a briefdescription of some currently available parallel PROLOG implementations.andM;PARLOG, a guard-annotated PROLOG, is available from the Imperial CollegeComputing Department (London, U.K.).andP;  Current implementations exist for SunWorkstations, VAX computers, and the IBM PC.andP;  Although not parallel machines,these implementations adhere to the PARLOG model; programs written on thesemachines should transfer smoothly to parallel mach ines.andP;  An INMOS Transputerversion is also expected in the near future.andM;An OR-parallel PROLOG has been implemented on the Sequent Balance (Beaverton,Ore.) shared-memory parallel computer by Argonne National Labs.andP;  Initialresults indicate performance increases ranging from 15%-35%.andP;  QuintusComputer Systems (Mountain View, Calif.) has placed its sequential version ofPROLOG on the Sequent Symmetry series and is expected to introduce anOR-parallel version in the near future.andM;A variation of parallel PROLOG called Communicating Sequential PROLOG hasbeen introduced by Brainware (West Berlin, FRG) for the INMOS Transputer.andP;  Inthis implementation, several built-in predicates that support processcreation and communication have been added to a sequential version of PROLOG.andO;The addition of these &quot;control&quot; predicates, however, adds a proceduralcomponent to the language.andM;Parsytec (Aachen, FRG) has introduced a transputer version of the RestrictedAND Parallel model.andP;  The implementation was developed to run on itstransputer-based Megaframe computer.andP;  Test results indicate that with minormodifications of standard sequential source code, the quisort program inListing 2 ran 2.5 times faster on four transputers than it did on one.andM;An implementation of the Restricted OR-AND Parallel process model has beendeveloped for the INMOS Transputer by Paralogic (Bethlehem, Pa.).andP;  Initialtest results for both AND parallel (deterministic) and OR parallel(nondeterministic) programs are presented in Figure 5.andP;  One important featureof Paralogic Parallel PROLOG is that the test programs require nomodification of the programs require no modification of the Clocksin andMellish syntax over the range of processors.andP;  The tests were performed on anIBM PC clone and transputer boards from Computer Systems Architects (Provo,Utah).andP;  Initial versions of the language are expected to support up to eighttransputers in either IBM PC or Macintosh II environments.andM;The parallel PROLOG story is just beginning.andP;  Although PROLOG seems a naturalchoice for parallel processing, the implementation of OR and AND parallelismcan take many forms.andP;  Continued research and the application to real problemswill probably shape the future of parallel PROLOG.andP;  Whatever the outcome,parallel PROLOG will doubtless prove a powerful tool for the knowledgeengineer.andO;</TEXT></DOC>