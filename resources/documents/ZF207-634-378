<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-634-378  </DOCNO><DOCID>07 634 378.andM;</DOCID><JOURNAL>PC Magazine  Oct 17 1989 v8 n17 p285(8)* Full Text COPYRIGHT Ziff-Davis Publishing Co. 1989.andM;</JOURNAL><TITLE>OS/2 - a rich communications environment. (part 2) (Lab Notes)(technical)</TITLE><AUTHOR>Prosise, Jeff.andO;AttFile:   PCMAG\V08N17\OS2TERM.C;0 Program:  OS2TERM.C  C source code.andO;PCMAG\V08N17\OS2TERM.EXE;2 Program:  OS2TERM.EXE  Executable file.andM;</AUTHOR><SUMMARY>Unlike DOS, which makes communications program developmentdifficult, OS/2 offers a wide ranging, comfortable environment forcommunications programs.andP;  The OS/2 serial driver offers everythingcommunications programs require for high speed characterinput-output.andP;  OS2TERM.C is a user type-in program in C whichshows the differences between the DOS and OS/2 communicationsprogramming environments and offers a simple yet completelyfunctional terminal emulator.andP;  The program is used an a teachingexample to the calls and routines required in OS/2.andP;  Directions onthe program's use are supplied.andM;</SUMMARY><DESCRIPT>Topic:     OS-2Terminal EmulationProgramming InstructionType-In ProgramsC Programming Language.andO;Feature:   illustrationtableprogram.andO;Caption:   Configuring serial ports under OS/2. (table)Managing the OS/2 serial device driver. (table)OS2TERM.C listing. (program)andM;</DESCRIPT><TEXT>As you'll recall from our last issue, DOS makes life difficult forcommunications programmers.andP;  Because its primitive AUX serial device driveris not interrupt driven, high-speed DOS communications programs must supplytheir own code and logic to interface with the serial port.andP;  DOSTERM, thebare-bones terminal emulator presented in the previous issue, does littlemore than read, write, and display characters; yet even these simple tasksrequire some fairly advanced programming techniques.andM;By contrast, OS/2 presents a rich environment for communications programs.andO;The OS/2-supplied serial device driver provides all of the low-level servicesa commercial-quality communications program needs for high-speed characterinput and output.andP;  There are no interrupt service routines to worry about, noprogramming of the Universal Asynchronous Receiver/Transmitter (UART) or theinterrupt controller chips, and no extra effort necessary to implementsophisticated handshaking and flow-control schemes.andP;  The driver handles allof these functions internally, effectively insulating the application programfrom the chores of direct device management.andM;OS2TERM, the OS/2 equivalent of DOSTERM, highlights the differences betweenthe DOS and OS/2 communications programming environments.andP;  Both programs(which can be downloaded from PC MagNet) provide you with simple but fullyfunctional terminal emulators.andP;  Indeed, if you connect a DOS machine and anOS/2 machine with a null modem cable and run DOSTERM on one and OS2TERM onthe other, you'll fmd that the two PCs talk to each other-a seemingly trivialfeat until you realize that you have electronically bridged the gap betweentwo quite different operating systems.andM;THE OS/2 SERIAL DEVICE DRIVERandM;Before gening to OS2TERM, however, we should consider the OS/2 communicationsfacilities that it uses.andP;  The OS/2 serial device driver comprises two files,which are placed in the OS2 subdirectory of the hard disk drive duringinstallation.andP;  The first, COM01.SYS, provides serial-device support forAT-class machines.andP;  The second, COM02.andP;  SYS, is used with PS/2 machines.andM;Unlike AUX, which is loaded by default every time DOS is initialized, theOS/2 drivers must be loaded with a DEVICE command in the CONFIG.andP;  SYS file.andO;A single DEVICE statement, however, loads as many copies of the driver asthere are COM ports installed in the system.andP;  COMOI.andP;  SYS supports up to twoserial ports, which are assigned the logical names COM1 and COM2; COM02.SYSSuports up to three.andM;The COM0x.SYS device drivers are fully interrupt driven.andP;  Since normal OS/2application programs run at privilege level 3 in the 80286/80386protected-mode environment-and thus cannot service system interrupts theoperating system itself handles all interrupts generated by the UARThardware.andP;  All incoming characters go first into a 1,024-byte intemal buffer.andO;Outgoing characters are temporarily stored in a 128-byte internal bufferbefore being delivered to the UART's transmit hardware.andP;  The sizes of bothbuffers are fixed and cannot be altered by an application program.andM;Characters are passed between these buffers and a user's application space atthe program's request.andP;  Although functions are provided for determining thenumber of characters awaiting processing in the input and output queues, theOS12 Programmer's Reference warns that the mechanisms used for moving data inand out of them may change in subsequent releases.andP;  As a result, programsshould not be written to rely upon this information.andM;Hardware handshaking at the RS-232 control pins can either be performed bythe application program or can be delegated to the device driver.andP;  TheCOMOx.SYS drivers offer a variety of handshaking modes that are handledtransparently at the device driver level.andP;  This allows application programsto ignore control pin states and concem themselves with nothing more thanreading and writing bytes of data.andP;  In one mode, for example, known as RTStoggleon-transmit mode, the RTS (Request to Send) pin is automaticallyasserted when data is moved into the transmit buffer and held until thebuffer is emptied.andP;  We'll examine the entire array of handshaking options indetail later in this article.andM;If desired, COMOx.SYS will provide automatic transmit and receive flowcontrol using the XON/XOFF protocol.andP;  If receive flow control is enabled, thedevice driver transmits an XOFF character when the 1,024-byte serial inputqueue is almost full.andP;  XON is transmitted when enough characters have beenread to leave the queue about half empty.andP;  (To accommodate systems thatexpect XON to be the first character following XOFF, all other output isinhibited until after the XON character is sent.) With transmit flow controlactivated, the device driver responds to the receipt of an XOFF character bydisabling output until XON is received.andP;  Both the XON and XOFF charactercodes used by the drivers are user programmable.andP;  THE DOSDEVIOCTL FUNCTIONandM;The DosDevIOCtl function is used to query and configure device drivers underOS/2.andP;  Of the roughly 90 subfunctions provided for direct device support, 20apply to the serial device driver.andP;  This superset is divided into 10categories, one for each device that the DosDevloctl function supports.andP;  Thecategory code is passed along with the desired function code when DosDevIOCtlis invoked.andP;  Serial-device support functions belong to category I.andM;Figure 1 lists the DosDevIOCtl serial port services; for most, name denotesfunction.andP;  SETBAUDRATE, for example, permits an OS/2 application to set theserial device driver's data rate, while GETBAUDRATE retums the current datarate.andP;  You'll recall that, in the last issue, setting the data rate under DOSrequired a direct write to the UART registers or a call to the BIOS throughinterrupt 14h.andP;  Under OS/2, SETLINECTRL sets the driver's linecontrolcharacteristics: the number of data bits, the number of stop bits, and theparity setting.andP;  GETINQUECOUNT and GETOUTQUECOUNT return values to thecalling program that reflect the number of characters awaiting processing inthe device driver's internal receive and transmit queues.andM;By far the most complex of the DosDevIOCtl serial port functions areSETDCBINFO and GETDCBINFO.andP;  These functions allow programs to manipulatevalues in the device driver's DCB (Device Control Block).andP;  The DCB is theblock of information that determines the device driver's behavior.andO;Specifically, the components of the DCB structure define such criticalcommunications parameters as what binary values are used for the XON/XOFFcharacters, what the read and write timeout values will be, and whathandshaking strategies will be employed.andM;The DCB structure shown in Figure 2 has the following form: struct (andM;USHORT usWriteTimeout; USHORT usReadTimeout;andM;BYTE bFlaga1; BYTE bFlags2;andM;BYTE bFlags3; BYTE bErrorReplacementChar;andM;BYTE bBreakReplacementChar; BYTE bXONChar;andM;BYTE bXOFFChar; The SETDCBINFO and GETDCBINFO function codes and the addressof a DCB structure are passed as arguments to DosDeviOCtl.andM;The usWriteTimeout and usReadTimeout variables are 16-bit values that definetimeout values.andP;  These are expressed in hundredths of a second, where 0represents 0.01 seconds, 1 represents 0.02 seconds, and so on.andP;  The variablesbErrorReplacementChar and bBreakReplacementChar define the Error and BREAKreplacement characters.andP;  Similarly, bXONChar and bXOFFChar define the XON andXOFF characters used when XON/XOFF flow control is activated.andM;The bFlags variables are further subdivided into bit fields, as detailed inFigure 3.andP;  They control such additional devicerelated parameters ashandshaking modes, flow control, and read and wfite timeout processingstrategies.andM;Detailed consideration of the various DCB elements and of their effects onthe operation of the serial device driver is best handled in connection withspecific topics as they arise.andP;  We will also discuss a subset ofDosDevIOCtl's serial port functions, although the scope and complexity of theentire set preclude treating all of them here.andP;  For further reference, referto the &quot;I/O Control Functions&quot; section of die OS/2 SDK or Programmer'sToolkit OS12 Programmer's Reference manuals or to Ray Duncan's Advanced OS12Programming (Microsoft Press, 1989).andP;  REAOING AND WRITINGandM;The OS/2 kernel APT functions treat a setial port like a file.andP;  It is openedfor reading and writing with OS/2's standard DosOpen function and closed withDosClose.andP;  It is read and written with DosRead and DosWrite.andP;  And, like allother resources that OS/2 allocates on a per- process basis, a serial port isautomatically closed when DosExit is invoked to terminate a process.andM;Of the parameters passed to DosOpen, only szFileName, hf, and fOpenMode(these are the designations used in the Microsoft SDK Programmer's Referencemanual) have any meaning in terms of opening a serial port.andP;  Such variablesas usAction, ulFileSize, usAttribute, and fOpenFlags (which indicate whataction DosOpen took when it opened the file, the new file size, theattributes assigned to a newly created file, and the action to be taken ifdie file doesn't exist) are unknown to COMOx.sys.andM;The filename string, szFileName, is used to open a serial port.andP;  The stringmust be COM 1, COM2, or COM3 for the three serial ports, respectively.andP;  Thefile handle, hf, returned by DosOpen is used in all subsequent references tothe port.andP;  Like a file, a serial port may be opened with a combination ofread and write access rights and with a number of restrictions placed onother processes that attempt to utilize it.andM;A serial poll is normally opened with both read and write privileges for dieprocess that opened it.andP;  This is done by setting the least-significant twobits of the fOpenMode word to 0x0002.andP;  Bits 4, 5, and 6 are used to specifythe share mode: 0x0010 for deny-read-write, 0x0020 for deny-write, 0x0030 fordeny-read, and 0x0040 for deny-none.andM;A serial port opened in deny-read-write share mode cannot be opened byanother process running in OS/2; attempting to do so will return a sharingviolation error (error code 32) from DosOpen.andP;  A serial port opened indeny-none share mode, however, can be accessed by other programs.andP;  But thereis an inherent danger in doing this: a stream of data pouring in from aserial device will be split between programs running simultaneously-even ifthe data was intended for only one.andP;  Each process will see only thecharacters that were received during its time slice (or, more precisely, thecharacters that were transferred from the input queue to satisfy a DosReadrequest during its time slice).andM;Thus, to protect data steams from being corrupted by background processes,safety dictates opening a serial port in a multitasking environment indeny-readwrite mode.andP;  Should you have occasion to run two communicationsprograms at once, the most reliable way to multitask them is to assign eachone its own COM port.andM;Dufing noffnal processing, if a DosWrite request is made but a byte of datacan't be delivered to the transmit hardware within the time specified in theusWriteTimeout field of the DCB structure, DosWrite times out and retums.andO;The number of bytes transmitted before the request was completed can bedeten-nined from the bytes-written variable, whose address was passed toDosWrite.andP;  The timeout value can be changed with a call to DosDevIOCtl'sSETDCBINFO function.andM;The alternative to this form of write processing is what the OS/2documentation terms write infinite processing.andP;  In the write infinite mode,DosWrite won't reWm until the number of bytes specified are transmited.andO;Which write mode is in effect at any given time is determined by die state ofbit 0 in the bHags3 field of the DCB strucwre.andP;  When this bit is set, writeinfinite processing is used; when bit 0 is clear, the timeout value found inusWriteTimeout is applied.andM;OS/2 offers three different modes of read processing.andP;  Like the writeprocessing modes, these are controlled by the application program throughSETDCBINFO.andP;  Seaing bit 1 of bFlags3 in the DCB structure effects normal readtimeout processing, setting bit 2 invokes wait-for-something reads, andseaing both causes OS/2's serial device driver to employ a no-wait readstrategy.andM;The first, normal read timeout processing, is analogous to the normal writeprocessing mode for transmitting bytes of data.andP;  DosRead returns when thespecified number of bytes have been read from the input queue or when asingle byte hasn't been received for the duration of the timeout intervalspecified in usReadTimeout.andM;In the second, wait-for-something form of read processing, COMOx.SYS waits(up to the amount of time specified in the usReadTimeout field) for data toappear in the queue.andP;  It then returns immediately, regardless of how manybytes were requested.andP;  Thus, for example, if I byte of data is retumed when aDosRead call is made with wait-for-something read processing in effect, and 5more bytes are received in the meantime, the next call to DosRead will rewmall 5 bytes.andP;  If there had initially been no data in the input queue, DosReadwould have waited for the fff st byte to appear.andM;The difference between wait-for-something read processing and normal readtimeout is most easily understood by considering another example.andP;  If aDosRead call was executed with a request for 10 characters and only 5 byteswere received, with normal read processing in effect DosRead would not returnuntil the timeout counter expired after receipt of the fifth byte.andP;  Withwait-for-something reads, however, the same DosRead call would returnimmediately, even though the full 10 bytes hadn't been read.andM;With no-wait read processing in effect, DosRead does not wait for characterdata to appear in the input queue.andP;  Rather, it checks the queue forcharacters, processes what's there, and rewms immediately.andP;  If there isnothing in the queue, DosRead will indicate this fact by returning abytes-read value of 0.andP;  If there are characters in the queue, all of them (upto the maximum number specified when DosRead was invoked) are processed.andM;Which forms of read and wfite timeout processing are best to use depends uponyour application.andP;  At startup, the serial device driver defaults to noffnalreads and writes, with 60-second timeouts.andP;  Many communications programmers,however, choose wait-for-something reads, which are the most time-efficient.andO;No-wait reads impose a high amount of overhead on the application program-toomuch, in fact, for them to be employed in a time-critical thread.andM;When dealing with output, many communications programmers are inclined toemploy normal write timeout processing.andP;  The reason is that this modeprovides a failback when something that is extemal to the program-Ahe sefialdevice driver's receipt of an XOFF character, for example, or the failure ofthe receiving device to assert CTS (Clear to Send) when expecte-hastemporarily blocked further transmission.andM;The OS2TERM program that is furnished here provides an illustration of how anapplication program can make use of DosDev IOCtl's DCB funcations to set theoperating parameters that the device driver will utilize.andP;  The call toSETDCBINFO is preceded by a call to GETDCBINFO to fill in the DCB controlstructure (labeled DCBInfo in OS2TERM.C).andP;  The timeout and flags fields arethen modified to suit the needs of the program and SETDCBINFO is called.andO;OS2TERM uses waitfor-something reads and normal writes with 60-second timeoutperiods to pass data to and from the serial port.andP;  One minute is enough timeto keep timeout periods from interfering with the normal flow of executionbut it is short enough so that it still should prevent the program fromhanging in case disaster strikes.andP;  HANDSHAKINGandM;The OS/2 serial device driver can use a variety of protocols for automatichandshaking with devices on the other end of the line.andP;  By default, when aserial port is first opened, DTR (Data Terminal Ready) and RTS arepermanently asserted, and output handshaking is performed using CTS and DSR(Data Set Ready).andP;  Underthese conditions, any input received while DSR isinhibited is treated by the dfiver as extraneous and is ignored.andP;  Any and allof these parameters can be changed, however.andP;  It is up to the OS/2application program to know the characteristics of the serial hardware withwhich it is exchanging information and to set the handshaking modesaccordingly.andM;Output handshaking using CTS, DSR, and DCD (Data Carrier Detect) can beenabled by setting any combination of bits 3, 4, and 5 in the bFlags1 field.andO;With output handshaking enabled, data will not be transmitted from the128-byte output queue unless the corresponding pin is held high by thereceiving device.andP;  With bits 3 and 4 set, for example (the defaultconfiguration), OS/2 will not output characters unless the DCE (DataCommunications Equipment) has asserted both CTS and DSR.andP;  DCD handshaking isused only in special circumstances.andM;Bit 6 of the DCB structure's bHags1 field controls DSR input sensitivity.andO;With sensitivity enabled, the device driver discards any characters receivedwhile DSR is not asserted.andP;  Since this is the default operating mode, an OS/2communications program must either make sure that the transmitting deviceasserts DSR before it puts data on the line, or it must use SETDCBINFO todisable input sensitivity.andP;  OS2TERM takes the laner course, first callingGETDCBINFO to obtain default parameter values, then clearing bit 6 beforecalling SETDCBINFO.andP;  This process eliminates any dependence on DSR.andM;Bits 0 and 1 of bFlags I and bits 6 and 7 of bFlags2 are used to control thedevice driver's handling of die DTR and RTS control pins, respectively.andP;  Ineach case, clearing both bits disables the corresponding control signal;seaing the lower bit while leaving the higher one clear enables the signal;and clearing the lower bit and seaing the higher bit activates inputhandshaking for the corresponding pin.andP;  With the first two seaings, DTR andRTS are simply inhibited or asserted by the device driver.andP;  They remain sountil SETDCBINFO is called again to alter them or until the applicationprogram manually toggles them by using DosDevIOCtl's SETMODEMCTRL function.andO;In all cases, DTR and RTS can be set independently.andM;In DTR input handshaking mode, the device driver assumes control of DTR,toggling it on and off as needed to control the flow to the receive queue.andO;DTR is asserted when the queue is less than half full and is inhibited whenthe queue approaches capacity.andP;  This sewp achieves the same effect as anXON/XOFF protocol implemented in hardware rather than software.andP;  RTS inputhandshaking mode does the same for RTS-all pin voltages are handledautomatically by the device driver.andM;The final handshaking option is RTS toggle-on-transmit mode, which isactivated by seaing bits 6 and 7 in bFlags2.andP;  In this mode, the device driverasserts RTS when data in the output queue is awaiting transmission andinhibits it when the queue is emptied.andP;  This handshaking scheme isparticularly useful when the hardware on the receiving end will not transmitdata while but won't accept data unless it is.andP;  With toggle-on-transmit, RTSis asserted only when it needs to be-namely , when the device driver isrequesting permission to output a character through the UART.andM;An application program need not employ any of OS/2's automatic handshakingmodes, of course; it can perform its own handshaking instead.andP;  DTR and RTScan be manipulated manually with the SETMODEMCTRL function, and CTS, DSR, RI(Ring Indicator), and DCD are read by DosDevIOCtl's GETMODEMINPUT functin.andO;It is important to note, however, that if the application progRam gives upcontrol of DTR or RTS (by setting either to input handshaking mode or bytelling RTS to toggle-on-transmit mode), the corresponding pin cannot bechanged by SETMODEMCTRL.andP;  To make such a change, the program must firstcancel automatic handshaking.andP;  It can do this in one of two ways: either byclearing the lower two bits of bFlags 1 (to disable DTR) or the upper twobits of bHags2 (to disable RTS), or by setting the higher of the two bitswhile clearing the lower of the two.andP;  This will enable the corresponding pinand will free it from the device driver's control.andP;  OS2TERMandM;Figure 4 shows a conceptual model for a typical OS/2 communications program.andO;OS2TERM.C, shown in Figure 5, is the source listing for a protected-modeterminal-emulation program based on the model.andP;  C has quickly become thelanguage of choice for OS/2 developers.andP;  And the OS/2 API is speciallytailored to the C programming language by virtue of its stack-basedargument-passing protocol.andP;  If you have a copy of the Microsoft C Compiler,Version 5.1, and you have installed it with OS/2 support, you can compile andlink OS2TERM yourself with the following command line:andM;c1 -Lp -Zp -G2 os2term.candM;While OS2TERM is functionally identical to the DOSTERM emulator presented inthe previous issue, in terms of implementation they bear little resemblance.andO;In OS2TERM, all interaction between the program and the serial port hardwareis handled by the operating system.andP;  The interrupt service routines thatserve the UART are coded into the COMOx.SYS andamp;vice driver, and the driver inturn is accessed with standard OS/2 API calls.andP;  This single level ofindirection incurs a small performance penalty (the overhead involved inrouting everything through the operating system), but it pays great dividendsin simplification.andP;  The program's only job becomes that of sending andrereiving bytes; it neither knows nor cares how they're being sent andreceived.andM;OS2TERM begins by using OS/2's DosOpen function to open COM I for reading andwriting.andP;  To ensure that it has sole access rights to the port, the programopens COM I in deny-read-wfite mode.andP;  DosDevIOCtl's SETBAUDRATE andSETLINECTRL functions are, invoked to set the data rate to 9,600 bits persecond and the line control characteristics to 8 data bits, 1 stop bit, andno parity.andP;  One argument passed to SETLINECTRL is the address of a structurewhose fields define the desired line settings.andP;  This structure, calledLineCtrl, is declared, and its variable values predefined, in the global datasection of OS2TERM.andP;  C.andM;Once the data-rate and line-control settings are set, OS2TERM callsGETDCBINFO, passing the address of the DCBlnfo strucwre as an argument.andO;Using this address, GETDCBINFO fills in the fields of DCBlnfo with thecurrent parameter values.andP;  OS2TERM alters five fields: usWriteTimeout,usReadTimeout, bFlags1, bFlags2, and bFlags3.andP;  These changes effect 60-second timeouts, enable DTR and RTS, disable DSR input sensitivity, andinitialize the driver for noffnal write processing and wait-for-somethingreads.andP;  A call to SETDCBINFO formalizes the new DCB settings.andM;With the COMOx.SYS now properly initialized, OS2TERM creates a separatethread of execution whose sole purpose is to read and display incomingcharacters.andP;  The ability to compartmentalize functions in their own threadsand have the operating system manage the time slices allotted to them is oneof the great advantages OS/2 provides to communications programmers.andP;  Sincethe primary thread will be monitoring the keyboard at the same time the newthread monitors the serial poll, it doesn't matter that OS2TERM uses largetimeout values.andP;  That's because the keyboard thread will still get timeslices even while a DosRead executes, so that we can terminate the programwith a keystroke regardless of the status of the other thread.andM;After the new thread is dispatched, the primary thread falls into a simpleloop that reads the keyboud and outputs any characters it receives to thedisplay and to the serial port.andP;  When the Esc key is pressed, the threadexecutes a DosExit call to end the process.andM;Like DOSTERM, OS2TERM is completely independent of the RS-232 control pins.andO;This isn't quite typical of communications programs, but I had a reason formaking it so-it ensures that both programs will function properly no manerhow the null modem cable linking them is wired.andP;  As long as DOSTERM andOS2TERM are used with a cable whose TD (Transmit Data) and RD (Receive Data)pins are crossed, the programs should work flawlessly.andP;  MULTITHREADEDPROGRAMMINGandM;OS2TERM provides a simple application of multithreaded programmingtechniques, in which one thread is dispatched to handle incoming data whilethe other manages outgoing information.andP;  Multithreaded programming is apowerful technique that has implications far beyond its simple applicationhere.andM;To begin with, multiple threads eliminate the code serialization required ofsingle-tasking application programs.andP;  DOSTERM, for example, had toalternately poll the keyboard and the serial input queue (a queue it set upand maintained) for data.andP;  Characters had to be processed on a first-come,first-served basis.andP;  In OS/2, you simply assign each task its own thread ofexecution and let the operatng system take care of time multiplexing.andM;Actually, OS2TERM is simple enough that it doesn't absolutely have to use twodifferent threads, though this approach certainly makes the code cleaner.andO;Other applications, however, may not be as simple.andP;  Your communicationsprogram , for example, might support a large-packet file-transfer protocolwhose packet size exceeds 1,024 bytes.andP;  When the packet size is smaller thanthe buffer size, there is no danger of overrunning the receive queue; thetransmitting device won't send another packet until you've checked andacknowledged the last one.andP;  But with oversize packets comes the possibilitythat the buffer will overflow while your program checks the contents of thelast packet transmitted.andM;Multithreaded programming provides the solution: just create a thread whoseonly duty is to read characters from the serial port and rebuffer them inyour own internally maintained receive buffer.andP;  You can size this buffer tofit any specification, leaving the primary program thread free to attend toother duties while the background thread continues processing incoming data.andM;This solution, of course, is exactly analogous to the way DOSTERM manages itsown receive buffer-though under OS/2 such a measure is necessary only in themost extreme cases.andP;  Still, I am left with the hope that a future version ofOS/2 will make the sizes of the serial device driver's transmit-and-receivequeues an option configurable under program control.andM;In the meantime, however, OS/2 gives you another way to sidestep potentialbuffer-overflow problems.andP;  By seaing up a pipe with DosMakePipe, a programcan let OS/2 take care of the additional layer of buffering.andP;  You could havethe thread that reads the serial port simply stuff incoming characters intothe pipe with DosWrite and have the primary thread extract data from theother end with DosRead.andP;  With DosMakePipe, you can make the pipe any size youwant up to 64K.andP;  (At least one commercial OS/2 communications program I knowof uses this general idea to circumvent OS/2's limited queue size, althoughits authors chose to forego pipes per se and implemented their own queuinglogic in order to achieve the best performance possible.)andM;A third solution would be to jack up the priority of the thread that readscharacters from the device driver's receive buffer from regular totime-critical.andP;  I don't recommend this approach, however, as it has been myexperience that running time-cfiticas threads is asking for trouble.andP;  (Whileexperimenting with time-critical threads in OS 2TERM, I found that otherportions of the program were quite often starved for CPU time, resulting inpoor performance and even, in some cases, lockups.) So investigate otheralternatives first; if all else fails, tum to adjusting thread priorities.andO;But be prepared for a long beta-test cycle to ferret out sources of programfailures and anomalous program behavior.andM;THE OS/2 ALTERNATIVEandM;The raw number of options OS/2 provides with its serial device driver mayseem intimidating, but with that complexity comes power.andP;  Once you'vemastered DosDevIOCtl and its serial device functions, building acommunications program around COMOx.SYS becomes a simple task.andP;  The clincheris that, thanks to OS/2's willingness to do the dirty work, it doesn't take asingle extra line of code to endow OS2TERM with some really advancedcapabilities-flow control, handshaking, etc.andP;  Contrast that with the codethat makes up DOSTERM, and you'll begin to appreciate the power of OS/2.andO;</TEXT></DOC>