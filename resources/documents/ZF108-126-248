<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-126-248  </DOCNO><DOCID>08 126 248.andM;</DOCID><JOURNAL>Dr. Dobb's Journal  Dec 1989 v14 n12 p144(7)* Full Text COPYRIGHT Mandamp;T Publishing 1989.andM;</JOURNAL><TITLE>Text searching, C++ and OOPs, and ANSI strings. (object-orientedprogramming) (C programming)</TITLE><AUTHOR>Stevens, Al.andM;</AUTHOR><SUMMARY>TEXTSRCH, a C++ programming project, allows users to search largetextual data bases.andP;  Programmers can build the index by scanningtext and extracting words; for queries, programmers need Booleanoperators.andP;  The first set of functions in the project parse queryexpressions and prepare them for a retrieval pass at the database.andP;  TEXTSRCH expression analysis occurs through thelexical_scan function.andP;  Upon validation the program converts itinto tokens, an infix notation and a postfix notation.andO;Programmers can then enter a search expression.andP;  To learn moreabout C++ programming, Object-Oriented Program Design withExamples in C++, by Mark Mullins, is a useful and practical book.andO;Lastly, the ANSI standard C specification has introduced the'stringizing' concept of preprocessing wherein the # operatorturns a parameter into a string.andP;  Programmers can also use theoperator to create a TRACE macro.andM;</SUMMARY><DESCRIPT>Topic:     C Programming LanguageANSIObject-Oriented ProgrammingProgramming InstructionQuery LanguagesSearchingPreprocessorsSortingTokensData Base Languages.andM;</DESCRIPT><TEXT>Text Searching, C++ and OOPS, and ANSI StringsandM;This month we are going to start a new &quot;C Programming&quot; column project.andP;  Weare going to examine some of the problems associated with the maintenance oflarge text data bases.andP;  You might be familiar with the problem.andP;  You have alot of reference material and you do not always know how to find what you arelooking for.andP;  Sometimes the reference material is stored in text files.andP;  Ifyou keep a lot of word processing files at work, or if you download a lot ofsoftware with .DOC or READ.ME files, your material is stored somewhere inASCII text and would be ready to be read if only you could find it.andP;  Our newproject will address the problems associated with locating the text filesthat have the information we need.andM;Someday everyone will have Optical Character Recognition scanners, and wewill store all our books and magazines on disk.andP;  Maybe the magazines willbegin to sell their editorial content on diskettes or CD-ROM as well.andP;  Whenthat happens, then all our reference works will be ready for treatment by adocument processor similar to the one we will build here in this column.andM;There are a number of software packages that do what we will build here.andO;Most CD-ROM distributions of large text data bases include such a system.andP;  Wewill build our own.andP;  That way each of us can customize it to our specificrequirements.andP;  This software will be generic standard C.andP;  If you want tointegrate it into a particular user platform, it should port with littledifficulty.andP;  Our project will build a system that we will call TEXTSRCH.andM;There are a number of disciplines that we must address in the development ofsuch a project.andP;  First, we must ask, given a large text data base and someoneto search it, how does the search proceed?andP;  What are the search criteria andhow will we express them to the software?andP;  These are the first requirementsto consider, because they will determine what techniques we use to store andfind things.andP;  Next, once we identify files of text that match our searchcriteria, how must the system present them to us?andM;The TEXTSRCH Data BaseandM;A document retrieval system such as TEXTSRCH works best in an environmentwhere the data files are static.andP;  There is a lot of text and it does notchange much.andP;  Users control changes with addendum or replacement documents atscheduled intervals.andP;  Typical applications are engineering specifications,maintenance manuals, and reference libraries.andM;To build the data base, you collect the documents in a controlled location,perhaps its own subdirectory, and then you build an index.andP;  The indexsupports searches.andP;  Some systems require you to manually examine everydocument and mark all the phrases that will appear in the index.andP;  Other buildthe index by automatically scanning the text and extracting words.andP;  We willuse this second approach.andM;You want to use this kind of system on a static data base because theindexing operation can take a long time.andM;RetrievalsandM;With the data base in place and the index built, you are ready to performretrievals.andP;  Let's first discuss how such searched will proceed.andP;  Someonewill want to find all references to a word or phrase in the data base.andO;Perhaps you will want every reference to the phrase, &quot;object-orientedprogramming.&quot;andP;  You must tell the system what you want, and it msut tell youwhere you can find those references.andP;  But suppose you are interested onlyreferences to OOP that are specifically about Smalltalk.andP;  Then you might wantyour search to deliver only those files where both key phrases appear.andO;Another search might want to specifically exclude references to C++, and soyou must be able to tell the system about that requirement as well.andM;QueriesandM;You can see where we are heading.andP;  It is apparent at the outset that we needsome form of structure query language with Boolean operators.andP;  We need to beable to parse an expression such as this one:andM;&quot;object oriented&quot; and &quot;smalltalk&quot; but not &quot;C++&quot;andM;Our expressions will have operators with precedence, so we will need to useparentheses to override the default precedence assigned by the parser, makingan expression such as this one possible:andM;&quot;object oriented&quot; and (&quot;design&quot; or &quot;programming&quot;)andM;The TEXTSRCH Expression AnalyzerandM;All of what just preceded leads us to our first installment.andP;  The first setof functions that we will develop will parse such queary expressions andprepare them for a retrieval pass at the data base.andP;  Listing One, page 164,is textsrch.h.andP;  This listing is one that will grow over the months.andP;  As weadd features, we will add macros, prototypes, and such to textsrch.h.andP;  Thismonth it contains what we need for expression analysis.andM;Listing Two, page 164, is express.c, the code that parses our expressions.andO;It begins with a modified BNF that describes the query language.andP;  As you cansee, it isn't very complex.andP;  A program that wants to parse an expressioncalls the lexican scan function in this module.andP;  The function returns a NULLif it finds an error.andP;  If the expression is correct, the function returns apointer to the parsed expression, which is represented in the form of tokenssuitable for processing by an expression interpreter.andM;The lexican scan function calls the expression function to check theexression for syntax and to convert it into tokens.andP;  The syntax check uses arecursive descent parser.andP;  That is, if the expression function finds a leftparentheses in the stream, it calls itself to validate the expression that isin parentheses, and then, when it returns, it expects to find a rightparenthesis.andP;  If it finds the unary NOT operator, it calls itself to checkthe expression the follows the operator.andP;  If it finds a word or phrase -- aphrase in our context consists of a group of words surrounded by doublequotes -- it looks at the next element in the expression.andP;  If that element isthe binary AND or OR operator, the expression function calls itself to checkthe expression to the right of the operator.andM;While validating the expression, the program converts it into tokens.andP;  Eachlanguage element is a one-character token, and the tokens are written into anarray in the order in which they occur.andP;  When the token is a word or phrase,which is assigned the OPERAND token, an associated string contains the valueof the word or phrase.andM;After the expression is found to be correct and the tokens are built, thelexican scan function calls the postfix function.andP;  Its purpose is to convertthe token stream from infix notation to postfix notation.andP;  An expression ininfix notation uses defined operator precedence with parentheses to overridethe defaults.andP;  This is the notation we use when we compose the query.andP;  It isalso the notation used by the C language.andP;  The postfix notation (also calledReverse Polish Notation) eliminates the parentheses and represents precedenceby the proximity of tokens to one another.andP;  Users of SNOBOL, Forth, and TIscientific calculators will recognize the notation.andM;An infix expression places a binary operator between the operands as shownhere:andM;this and thatandM;The postfix version of this expression pushes the operands on a stackfollowed by the operator as shown here:andM;[is less than] and [is greater than]andM;thatandM;thisandM;(In these examples, I've used the angle brackets to set operators apart fromthe operands on the stack.)andM;A parenthesized infix expression such as this:andM;(this and that) or whatandM;is represented on the postfix stack this way:andM;[is less than] or [is greater than]andM;whatandM;[is less than] and [is greater than]andM;thatandM;thisandM;Evaluation of a postfix expression is a stack operation.andP;  The top element ispopped.andP;  If the element is an operand, we use the operand to derive the valueof the expression.andP;  If the element is a unary operator, the next element ispopped and evaluated, the unary operator is applied to it, and the result ispushed.andP;  If the element is a binary operator, the next two operators arepopped, the binary operator is applied to them, and the result is pushed.andO;Then the procedure repeats until the element popped is a single result.andP;  Eachpop is a recursive repeat of the entire procedure.andP;  In our case the pushedresults are true or false values within the data base document depending onthe search results.andP;  Each time we pop a word or phrase, we see if it is inthe data base and, if so, in which files.andP;  The result of that search ispurshed.andP;  We'll get further into the details of expression evaluation nextmonth.andM;Conversion from infix notation to postfix notation is a simple matter.andP;  Theprocedure is described in detail in Fundamentals of Data Structures, Horowitzand Sahni, 1976, Computer Science Press, on page 91-97.andP;  We implement thisprocedure in the functions postfix, isp, icp, and poststack.andM;Listing Three, page 167, is testexpr.c, a program to test our expressionanalyzer and display the results.andP;  It is a throwaway program not to be usedin the project beyond its purpose as a test and demonstration tool.andP;  You typeyour expression into the gets function.andP;  Use words and phrases withinterspersed operators.andP;  The valid operators are AND, OR, and NOT.andP;  Thepurpose of the query is to express a pattern of words and phrases that do ordo not appear in the text data base.andP;  The TEXTSRCH program will find filesthat match the query expression.andP;  Typical expressions are these:andM;(fortran or cobol) and not pascalandM;fortran or (cobol and not pascal)andM;The testexpr program will report a syntax error by displaying a pointersymbol below the expression element where it found the error.andP;  If theexpression is correct, the program will display the postfix stack in thisformat:andM;Enter the search expression:andM;fortran or (cobol and not pascal)andM;TokenandM;[is less than] or [is greater than]andM;[is less than] and [is greater than]andM;[is less than] not [is greater than]andM;pascalandM;cobolandM;fortranandM;Enter the search expression:andM;Press the Enter key with no expression to terminate the program.andP;  Next monthwe'll discuss how we will index the data base and how that index will deliverour query results.andM;Book Report: Object-Oriented ProgramandM;Design With Examples in C++andM;Are you looking for a stocking stuffer for yourself this season?andP;  There is anew book called Object-Oriented Program Design With Examples in C++, by MarkMullins.andP;  The book is more about object-oriented programming and design thanabout C++, but it uses C++ for examples and is an indispensable addition toyour library if you are trying to figure out OOP and C++.andM;Mullin takes a unique approach to these subjects.andP;  Instead of presenting justanother enhancement to the ATandamp;T C++ reference documents and Stroustrup'sbook, he teaches the basics of object-oriented design and uses C++ todemonstrate the lessons.andP;  Follow this book from beginning to end, and youwill have a manageable grasp on object-oriented design and programming by thetime you're done.andM;Mullin's book also teaches valuable lessons about the general approach aprogrammer uses in the design of software systems, object oriented or not,and he does it with a writing style that informs and often entertains thereader.andP;  Every now and then he slips in a dry joke that goes by almostunnoticed.andM;To show you how to design an object-oriented system, Mullin undertakes thedevelopment of an integrated information management system for a fictionalcompany.andP;  This is the first extensive treatment of OOP I've seen that usesreal, believable examples of things that a programmer might encounter in thereal world.andP;  Most writers build contrived analogies that attempt to relateabstract examples of toasters, fruit, or other silly non-automata to themysterious things that the object-oriented paradigm calls objects.andP;  Mullinuses infentory, sales and personnel database records to demonstrate thedevelopment of a class hierarchy to support his hypothetical design.andP;  Theseare things we can all associate with.andM;Perhaps you've never worked on an inventory system, but you can readily seewhat one might need to do.andP;  If there is a warehouse full of stuff and youneed to locate specific items, fill orders for items, and replace what yousell, then you need an inventory system.andP;  I've worked on several.andP;  Thesmallest was for a video tape store; the largest was for spare parts for theSpace Shuttle.andP;  Their respective functional requirements were similar.andP;  Theinventory management folks call it &quot;material requirements planning.&quot;andP;  GeorgeCarlin calls it &quot;keeping track of your stuff.&quot;andP;  Mullin takes this mundaneapplication, one that everyone will recognize, and designs an object-orientedsoftware system to support it.andM;Mullin traces the design in the manner in which it might actually occur.andP;  Thefalse starts, the refinement of requirements, the incremental development ofan object-oriented data model, he presents them all in the sequence in whichyou would encounter them during a real-design project.andP;  As he proceeds,Mullin tells you how you should be thinking about the objects and their placein the class hierarchy.andM;Mullin's design sometimes tends to build his data base by using views thatseem--at least to me--to be unnatural.andP;  Object-oriented design involvesbuilding base classes and derived classes in a class hierarchy.andP;  Becauseevery entity in his data base has a name and address, Mullin starts out witha new class named &quot;Entity&quot; that contains name and address members.andP;  The hederives everything else from that class.andP;  This is not the natural view ofthings.andP;  We are not necessary always subordinate to our common denominators.andO;Because we all have addresses does not mean that we are subordinate to thoseaddresses.andP;  I think we are seeing the tendency of the object-orientedparadigm to bend our perspective in inappropriate directions.andP;  The solutionto a problem should resemble the problem, and names and addresses arecomponents of their owners, not the other way around.andP;  I would have createdthe Entity class with its name and address members and then included aninstance of that class in each of the classes that require it.andP;  Thefunctional result would be the same but we would not be forced to perceiveour data base from an illogical perspective just to adhere to hierarchicaldogma.andP;  But then, I do not know enough about object-oriented design to writea book.andP;  Not yet, at least.andM;My only other criticism of this book is that Mullin and his editors do notseem to know that the word &quot;data&quot; is a plural noun.andP;  But then, many of mycolleagues here at DDJ don't know that either, and I forget sometimes, too.andO;That criticism aside, this is a very good book.andP;  OOP and C++ have beenbegging for literary treatments this good, and I'm happy to see it finallyhappenning.andM;The ANSI Corner: Preprocessing andandM;STringsandM;The ANSI standard C specification has introduced something the committeecalls &quot;stringizing,&quot; not a real word, an abomination actually, but a newconcept in preprocessing, nonetheless.andP;  (If Kandamp;R can give us &quot;initializer,&quot;also not a word, I guess X3J11 similarly presumed that they could extendEnglish while they extended C.)andM;The trouble with the ANSI document is that it often fails to provide anybasis for a particular extension to classic C.andP;  In too many cases thecommittee leaves it to us to figure out why they included a particularfeature.andP;  They will describe the feature and perhaps provide examples of howa conforming compiler must behave, but they do not adequately provide themotive behind it all.andP;  The rationale document that accompanies thespecification is supposed to fill these infromation gaps but too often itdoes not or tries and fails.andP;  Such is the case with the preprocessor's #operator on #define macro parameter substitutions, the so-called&quot;stringizing&quot; feature.andP;  They tried to explain it, but I do not understand theexplanation.andP;  If you do not already know how you might use the # feature, youmight not be able to guess its purpose from the description in thespecification even when you know what it does.andP;  What we can do is look atwhat it does and see if this solution solves some problem we might have.andP;  The# operator turns a parameter into a string.andP;  That's all it does.andP;  Here is anexample:andM;#define str(x) # x printf(str(HELLO));andM;This macro expands the hello parameter into a string so that the printf calllooks like this after the substitution:andM;printf(&quot;HELLO&quot;);andM;The preprocessor performs any other translations on the parameters before itbuilds the sting as shown here:andM;#define HELLO goodbye #define str(x) # x printf(str(HELLO));andM;This sequence converts to this:andM;printf(&quot;goodbye&quot;);andM;Why would you want to do any that?andP;  If you know you want HELLO to be &quot;HELLO&quot;or goodbye to be &quot;goodbye,&quot; why not just code it that way in the first place?andO;Let's try to dream up a circumstance where this feature might have some use.andO;One possibility that comes to mind is in the realm of debugging.andP;  You can usethe# operator to create a TRACE macro that traces selected expressions inyour program on the console.andP;  You can turn the TRACE on and off with a globalcompile-time variable.andP;  Here is the macro:andM;#ifdel DEBUGGING #define TRACE(x)(printf(&quot;\n&quot;#x),(x)) #else #defineTRACE(x)(x) #endifandM;Suppose your program has an expression that you want to trace on the console.andO;If this is the expression:andM;b = strlen (&quot;12345&quot;);andM;To trace this expression, you can recode it with the TRACE macro like this:andM;b = TRACE(strlen(&quot;12345&quot;));andM;Now whenever the expression is executed with the DEBUGGING global variabledefined, the expression's code is displayed on the console, as well as beingevaluated because the statement is preprocessed to this sequence:andM;b = (printf(&quot;\n&quot;&quot;strlen(\&quot;12345\&quot;)&quot;), (strlen(&quot;12345&quot;)));andM;Notice that the two components of the macro expansion, the printf and thestrlen calls the comma separated.andP;  This guarantees the the strlen, which isthe rightmost expression, returns the value required when the expression isevaluated.andP;  Notice also that the two are surrounded by parentheses.andP;  If theywere not, we would get the wrong value in the &quot;b&quot; integer because theassignment operator has a higher precedence than the comma operator.andM;Next month the ANSI Corner will explore the ## token pasting operator.andP;  Wewill, that is, if I can figure out a useful application for token pasting.andM;AvailabilityandM;All source code is available on a single disk and online.andP;  To order the disk,send $ 14.95 (Calif.andP;  residents add sales tax) to Dr. Dobb's Journal, 501Galveston Dr., Redwood City, CA 94063, or call 800-356-2002 (from insideCalif.) or 800-533-4372 (from outside Calif.).andP;  Please specify the issuenumber and format (MS-DOS, Macintosh, Kaypro).andP;  Source code is also availableonline through the DDJ Forum on CompuServe (type GO DDJ).andP;  The DDJ ListingService (603-882-1599) supports 300/1200/2400 baud, 8-data bits, no parity,1-stop bit.andP;  Press SPACEBAR when the system answers, type: listings(lowercase) at the log-in prompt.andO;</TEXT></DOC>