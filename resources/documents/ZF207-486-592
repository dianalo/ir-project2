<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-486-592  </DOCNO><DOCID>07 486 592.andM;</DOCID><JOURNAL>Computer Language  August 1989 v6 n8 p49(8)* Full Text COPYRIGHT Miller Freeman Publications 1989.andM;</JOURNAL><TITLE>An object-based development model; object-oriented methods canyield benefits in analysis and design as well a coding.andO;</TITLE><AUTHOR>Bulman, David M.andM;</AUTHOR><SUMMARY>An object-oriented applications development model consists ofthree distinct activities: requirements analysis, object-orienteddesign, and object-oriented programming.andP;  The initial step in theprocess requires modeling the problem domain and determining thenature of the data and operations objects can be used to structurethe model.andP;  The design step specifies and refines the nature ofthe objects to represent the problem model.andP;  Operations not neededin the particular model are added to each object to facilitate itsreusability in future applications.andP;  The object-orientedprogramming step involves arranging, interconnecting, andoptimizing the objects in the most effective structure for theapplications.andP;  Details of the methodology for developingobject-oriented applications are described.andM;</SUMMARY><DESCRIPT>Topic:     Object-Oriented ProgrammingTutorialMethodsModelingProgram Development TechniquesApplications ProgrammingSoftware DesignRequirements Analysis.andO;Feature:   illustrationchart.andO;Caption:   Cruise control context diagram. (chart)Set cruise control status. (chart)Control and compute speeds. (chart)andM;</DESCRIPT><TEXT>An Object-Based Development Model Object-oriented requirements analysis,design, and programming are distinct activities.andP;  Requirements analysis mustcome first if we are to understand the problem.andP;  Design, object-oriented ornot, can only be done after a problem is understood.andP;  Object-orientedprogramming addresses language, implementation, and programming environmentissues.andP;  Object-oriented programming can be done without object-orienteddesign or (if the programmer is foolish) in the absence of any design.andO;Object-oriented design is similarly independent; once we create anobject-oriented design, it can be programmed in an object-oriented languageor objects can be simulated in traditional languages.andM;To arrive at an object-oriented solution to a problem, we must decide whatthe objects should be.andP;  With very small problems, the selection of objectsmay be trivial; that is, we may be able to identify the objects byinspection.andP;  For large and complex problems, identification &quot;by inspection&quot;seldom works.andP;  It is true that some objects will correspond to recognizableuser entities in the problem domain.andP;  However, not all user entities areobvious nor can they be intuitively discovered.andP;  Also, user entities are notthe only sources of objects.andM;From the point of view of either object-oriented design or programming, anobject is some private data together with the operations on that data.andP;  Fordesign purposes, an object is characterized entirely by its operations.andP;  Forexample, it does not matter whether an invoice object has a local data item(instance variable, property, attribute) holding the invoice total or thetotal is calculated from the individual items in the invoice.andP;  The total neednot be a stored property of the object.andP;  We only need to know if anyoperation yields the invoice total when invoked.andP;  Hence, any methodology forobject-oriented design must concern itself intensely with the identificationand specification of the operations of objects.andM;Model-based developmentandM;The first step in solving a problem is making sure you understand what theproblem is.andP;  In other fields, engineers use models of their problems andsolutions to better understand them and to aid in communicating withcustomers.andP;  Many software engineers use models of their solutions, but fewexplicitly model the problem.andM;To develop an object-oriented solution, we first build a model in the problemdomain of what we understand the problem to be.andP;  This can be done byconstructing a model using object-oriented requirements analysis.andP;  Thestrategy and model described here provide the information needed to decide onthe objects and their operations.andM;Requirement analysisandM;The term &quot;object-oriented requirements analysis&quot; is somewhat redundant sinceit is hard to see how to do proper requirements analysis withoutconcentrating on the objects in the user's view of the problem.andP;  When I say Iwant to do object-oriented requirements analysis, I mean that I want toconcentrate on objects.andP;  I wish to implement a system whose solutionstructure in some way consists of or is organized around objects.andP;  Ratherthan use a whole new set of modelling tools and associated techniquesinvented solely to represent the problem from an object-oriented perspective,it is more rewarding to ask whether any current models are sufficientlyobject-oriented.andM;I investigated whether an extended form of structured analysis could providethe tools needed for requirements modelling.andP;  Earlier reaction to thisquestion by those familiar with traditional structured analysis was that itwouldn't work because &quot;structured analysis is a functional decomposition of asystem.&quot;andM;This view of structured analysis is much too narrow.andP;  It arises because astructured specification often appears to consist overwhelmingly of symbolsrepresenting processes (functions).andP;  It is easy to forget that theseprocesses appear on data-flow diagrams.andP;  The emphasis of a data-flow diagramis (and always was, as conceived by its originators) on the data.andM;The arrows on a data-flow diagram show the flow of data to and from: entitiesoutside the system, data stores about entities in the system, and symbolsrepresenting transforms of the data.andP;  That some workers think of data-flowdiagrams as a way to represent decomposition of functions should notinterfere with our correctly using them to represent the transformation andmovement of data about entities.andP;  Thus, I return to the intent of theoriginators by focusing on the data stores and real-world entities ratherthan the functions to be performed.andM;For real-time problems or those with a significant control component in theirresponses to events, D.J.andP;  Hatley and I.A.andP;  Pirbhai's Strategies forReal-Time System Specification (1987) brings a much-needed coherence tomodelling control via a control model and finite-state machines.andP;  Inparticular, I use their control specifications in the form ofstate-transition diagrams.andM;Another essential part of our model is the use of entity-relationshipdiagrams to model both the parts of a complex entity and the relationshipsbetween entities in the user's world and the solution.andP;  Entity-relationshipdiagrams provide an excellent tool for communication between the domain andcomputer specialists.andP;  By enabling us to simply and clearly depict theentities and their relationships, they help us locate object candidates.andM;Object-oriented designandM;An object-oriented design is one in which each of the major modulescorresponds to an entity either in the user's world or in an implementationof a solution to the user's problem.andP;  The next step in my strategy forobject-oriented design is to construct a partial list of candidate objects,so named because we recognize that some iteration will be required to arriveat their final definition.andM;We derive the majority of candidate objects directly from the model.andP;  Werefine the objects by adding objects and partitioning or combining existingobjects.andP;  We also refine the operations defined for each object.andP;  This stephelps create more reusable objects.andP;  A major goal is to locate opportunitiesfor defining higher-level operations for existing objects.andP;  The recognitionand implementation of higher-level operations causes the design of theremainder of the system to be simpler.andM;Sources of objectsandM;An automobile cruise-control system illustrates our approach.andP;  (Thisnow-classic example is so small that we could have arrived at most of theobjects by inspection.)andM;The first source of objects is the set of terminators in the context diagram(Figure 1).andP;  The name of each terminator should be included in the list ofcandidate objects.andP;  Terminators are likely to be considered entities by theuser, and we certainly need to perform operations on them.andP;  The candidateobjects we put in the list as a result of examining the context diagram arethe six terminators: wheel, engine, throttle, driver control wand, brakepedal, and accelerator pedal.andM;A rich source of objects in most problems is the collection of data stores inthe set of data-flow diagrams.andP;  We draw a fragment of data-flow diagram foreach stimulus to which the system must respond.andP;  Each fragment consists ofone process together with the stimulus (data or control) flow, thecorresponding response flow(s), and any data stores needed to produce theresponse.andM;From these data-flow diagrams we are able to add candidate objects named CCStatus and Current Speed.andP;  Two additional data-flow diagrams for the lowerlevel of Compute Speed and Control Speed will add two more candidate objects,Desired Speed and Wheel Pulse Count.andM;A few of the data flows may become candidate objects.andP;  Any stimulus (eithertime signals or the data flows from terminators) or response (data flow tothe terminators) whose data structure is sufficiently complex should beincluded as a candidate object.andP;  Stimulus and response data flows embody userentities that cross the boundary of the system (for example, a report ordeposit to an account).andP;  The reason they are likely candidates is that, incontrast to internal data flows, they frequently have a complex internal datastructure and their operations are directly determined by user policy.andP;  Suchobjects yield more interesting or higher-level operations than objects fromother data flows.andP;  None of the data flows in this particular example have anyinternal complexity, so none engender candidate objects.andM;Specifying an objectandM;Definition of an object starts with a suitable name.andP;  It is also useful toindicate whether the object was derived from a terminator, data store, ordata flow.andM;Remember that an object is characterized entirely by its operations.andP;  Inprogramming terminology, this means we have no interest in any possibleinstance variables at this stage, only in the set of messages or operationinvocations to which the object can respond.andP;  Thus, the interesting andvaluable part of an object is the specification of its operations.andP;  Thesespecifications include any restrictions on any required state of the objectat the time of invocation of each operation.andM;We name each operation.andP;  Most operations also have parameters.andP;  However,formal parameters names we might use later in the implementation are notuseful during the construction of the candidate list.andP;  If we are planning toimplement objects using a strongly typed language, some notation showing thetype of each parameter is necessary at this point in development.andP;  We choosea type name that is meaningful outside the object rather than one thatindicates its use inside the object.andP;  It is also useful at this stage ofdesign to show whether a parameter is an input, an output, or both.andM;Carving the operationsandM;The operations are derived by what I call carving from the low-levelprocesses (data transforms) connected to and from the candidate objects.andP;  Wediscover which operations are needed by examining the data-flow diagrams andthe process specifications.andP;  If we are defining a data-store object, we traceeach data flow connected to it to the lowest-level process, which is thesource or destination of the data flow (Figure 2).andP;  By examining thespecification of each such process, we can see which operations are needed onthis object.andM;In the simplest case, we might find only PUT and GET operations on the datastore.andP;  For the moment, then, these would be the only two operations wedefine for this object.andP;  The final result of some other approaches toobject-oriented design would include only such simple operations.andP;  Thismethodology includes guidelines for identifying higher-level operations.andM;This carving of the operations is important but easy.andP;  By examining thedata-flow diagrams in Figures 3 and 4, we can see that only processes 2.1,2.2, and 3.2 have any contact with the Current Speed data store, for example.andO;To decide what operations are actually needed for the Current Speed object,we look at the specifications of those three processes.andP;  For this smallexample, all we need to do is get the Current Speed and put a new value ofthe Current Speed.andP;  (Due to space considerations, the process specificationsare not shown here.)andM;We carve the operations for each of the candidate objects in turn.andP;  This isonly the first step in arriving at each object's operations.andM;Performing this step on our example, the objects and their operations so farare as shown in Listing 1.andP;  This is the minimal set of operations.andP;  We knowthey are needed because we find them in the process specifications.andP;  Theymight not include all the operations necessary when completing the detaileddesign; a significant number of operations are likely to be added to eachobject during the object-refinement step.andM;Refining objects and operationsandM;By examining any entity-relationship diagrams related to an object, alongwith its operations, I often find that the design would be improved bysplitting a candidate object into two or more objects.andP;  Splitting objects mayserve to simplify the interfaces to the operations of the objects, forexample.andP;  Without splitting, I might have needed an additional parameter thatspecified, in effect, which of the two split objects was to handle theoperation.andM;One of the principal indicators of a good design is narrow interfaces betweenmodules.andP;  There is often an important trade-off between the number ofoperations for each object and the number of parameters for each operation.andM;Objects usually have some relationship to other objects.andP;  For example, we mayhave Persons and Automobiles objects with a relationship between them.andP;  Anobject may be added to implement this relationship between Persons andAutomobiles.andP;  After adding a relationship object, each object is more likelyto be reusable than if the relationship were implemented in the two originalobjects because including the relationship as operations in an object makesit difficult to use the objects separately.andP;  Examination of theentity-relationship diagrams may reveal that two or more objects should becombined into one.andM;Due to space limitations, I have not shown the control specifications nor allthe control flows in the cruise-control example.andP;  One kind of object is bestillustrated by considering such control.andP;  This kind of object encapsulates afinite-state machine used to control the other objects in the system.andP;  Itcould be implemented as an executive module controlling other modules or as astate-control object.andP;  The operations for a state-control object take theform of asking for permission to perform a certain action.andM;Completing the setandM;In this step we add operations to each object that are not actually needed bythe requirements specification.andP;  Doing this makes the object more reusablefor future applications and enhances maintainability.andM;We may add operations so we have inverse or complementary pairs ofoperations.andP;  For example, if we originally needed an expand operation,perhaps we would add a shrink operation.andP;  Other pairs might bedestroy/restore, divide/combine, advance/retreat, and so on.andM;Suppose the requirements lead us to propose an object for a complex numberdata type.andP;  Our analysis might show us that, for the present application, weonly require operations for addition, subtraction, and multiplication.andO;Including an (at present unneeded) operation for division would certainlymake our object more reusable for other applications.andM;Higher-level operationsandM;I will use the cruise control problem for our first example of a higher-leveloperation; the operation we initially derived for the accelerator pedalobject was get( Accelerator Position ).andP;  However, in the processspecification this is compared to the previous value, which we had stored.andO;In other words, the only reason we wanted to get the Accelerator Position wasto see if it had changed from the previously stored value.andP;  The operation wereally needed was isChanged?.andP;  Implementing this higher-level operationsignificantly simplifies the process that uses the accelerator pedal object.andM;We can often identify a whole family of higher-level operations fordata-store objects.andP;  The specifications of the processes that access a givendata store may appear at first to have only get and put operations.andP;  A morethorough examination of the specification might show that most of theseoperations appear in loops.andP;  This tells us that we need higher-level iteratoroperations, which include the requisite setting of loop variables, checkingfor end-of-file conditions, and so on, in the iterator operation itself.andM;An even more thorough study of the specification could reveal that the wholepurpose of the loop and its embedded operations was to compute the average ofthe values in some field of a record.andP;  Thus, the operations we really wantedwere such things as Average, Sum, Total, Minimum, Maximum, and so on.andP;  A goodway to help us recognize higher-level operations on data stores is to writeparts of the process specifications in a higher-level language such as SQL.andM;By defining such higher-level operations on many of the objects, we move mostof the complexity of the problem into objects that are, by the same strategy,made more reusable.andP;  Often the number of lines of source code required formany application modules can be reduced by more than half as a result ofdefining such higher-level operations on objects.andM;Traditional structureandM;Although the most difficult part of object-oriented design is deciding whatthe objects ought to be, a significant set of design problems remains.andP;  Howdo we arrange these objects with the best kind of interconnection?andM;If each object arbitrarily accessed all other objects, we would not be ableto deal with the complexity involved.andP;  In other words, we still face thesystem architecture problem, even with the best choice of objects.andM;One possibility would be to use a traditional, hierarchical, module-callingstructure.andP;  If an organization already has a significant investment in theuse of such hierarchical designs, this may be the best choice.andP;  It issuitable only when the implementation language is not a pure object-orientedprogramming language such as Smalltalk since everything in Smalltalk is anobject.andP;  The situation is different, however, if the implementation languageis Ada (where objects have to be imitated).andM;Even some object-oriented languages such as C++ or Object Pascal havetraditional nonobject structures such as procedures and functions.andP;  Becausetheir underlying language is not based strictly on the object, using atraditional hierarchical structure may minimize risk as a softwareorganization makes the transition to a full object-oriented methodology.andM;Object-oriented structureandM;Once we have used an object-oriented design strategy to identify objects, itis natural to ask the following questions:andM;* Is the notion of object useful for organizing objects and other modulesinto higher units?andM;* Does our requirements model contain clues to this kind of conglomeration?andM;* Is there any advantage to such an organization?andM;Positive answers to these questions favor new ways to view systemarchitecture as a hierarchy of objects.andM;The use of high-level objects would yield the same advantages as low-levelobjects: encapsulation and isolation of related data and operations, enhancedmapping between the user's view of the system and implementation, potentialreusability of subsystems, and increased control of complexity.andM;How do we arrive at this hierarchy of objects?andP;  Some proposed approaches donot seem fruitful.andP;  People who have always been in favor of top-downeverything have, of course, declared that object-oriented design ought to bedone top-down and that we ought to use some sort of stepwise refinement ofbig objects into little ones.andP;  Alan Perlis once made a remark that expressesmy view: &quot;Everything should be designed top-down--except the first time.&quot;andP;  Ithink the process has become confused with the product; an analysis or designdocument that exhibits a hiearchical view of a system can be developed up,down, or sideways.andM;The premise that the top of the top-down hierarchy should be one object(consisting of a collection of high-level objects) can conflict with theprinciple that the shape of the system be closely related to the problem asthe user sees it.andP;  Although internal system objects will be created, anyhigh-level objects should be objects the user would naturally use to describethe problem.andP;  The user needs, and often demands, traceability from therequirement to the solution.andM;Are the proponents of stepwise refinement of objects saying we should createa single object for the whole system?andP;  Consider what this means in connectionwith a system that must respond to more than a thousand different events inthe real world.andP;  Each event requires the system to respond to one of athousand entirely different stimuli.andP;  Now remember that an object ischaracterized entirely by its operations.andP;  This implies that the top objectwill have a thousand different operations.andP;  Maybe the intent is to have sometop-level operations, each including a number of different operations,handled by the top object.andP;  This warps the basic definition of an object asused in object-oriented programming and design.andP;  This kind of top-downrefinement of objects does not seem to be a useful paradigm.andM;What we are looking for are subsystems that might be calledsuperobjects--objects that use (or contain) many objects.andP;  The designerlocates them by examining the larger abstractions in the user's world.andP;  Thelarger abstractions usually correspond to groups of entities (data stores andterminators) that interact strongly within the group.andM;Another way to find superobjects is to work with one of the higher-levelstate-transition diagrams in our requirements model.andP;  The states in such adiagram are likely to correspond to what the user thinks of as operatingmodes of the system.andP;  This strategy uses the following steps to build ahierarchy of objects and superobjects:andM;* Create a superobject to encapsulate the processes and objects dealing witheach state in the state-transition diagram.andM;* Define operations based on the inputs, events, and conditions the systemrecognizes in the state being considered.andM;* Encapsulate the state memory required in the superobject.andM;Such state or option superobjects are especially significant because theyoften correspond to coherent options important to the user.andM;Discussion of inheritance between object classes as a method for derivingobjects was omitted from this article.andP;  Although it is important inobject-oriented design, the derivation of our original objects is an earlieractivity and is more difficult.andP;  These objects comprise the roots of theinheritance hierarchies.andM;Our approach replaces object-oriented design methods that use intuition fordetermining the objects with a definite strategy for deciding on the bestobjects.andP;  In a large industrial project, we have to understand exactly whatthe problem is before trying to design a solution for it.andP;  Thus, thepreparation of a model ofthe problem is not extra work; it is part of astrategy for its solution.andP;  Given the information from such a model, a largenumber of quite acceptable objects emerge by applying our simple strategy.andO;Plenty of opportunity for creativity still exists in fine-tuning the objectsand their specifications.andM;If your organization has a large investment in another requirements analysismethod, you can still use this strategy as long as your analysis methodyields the information I have used to derive objects.andM;Because I completed the development of the methodology while teaching it inshort seminars over the last three years, I owe an obvious debt to many ofthe several hundred software engineers who persisted in asking difficultquestions.andM;ReferencesandM;Date, C.J.andP;  A Guide in the SQL Standard.andP;  Reading, Mass.: Addison-Wesley,1987.andM;DeMarco, T.andP;  Structured Analysis and System Specification.andP;  New York, N.Y.:andO;Yourdon Press, 1978.andM;Gomaa, H.andP;  &quot;A Software Design Method for Real-Time Systems,&quot; Communicationsof the ACM 27(9): 938-949, Sept. 1984.andM;Hatley, D.J., and I.A.andP;  Pirbhai.andP;  Strategies for Real-Time SystemSpecification.andP;  New York, N.Y.: Dorset House, 1987.andM;Jackson, M.andP;  System Development.andP;  Englewood Cliffs, N.J.: Prentice-HallInternational, 1983.andM;Jacobson, I.andP;  &quot;Object-Oriented Development in an Industrial Environment,&quot; inOOPSLA '87 Proceedings, pp.andP;  183-191.andM;McMenamin, S.M., and J.F.andP;  Palmer.andP;  Essential Systems Analysis.andP;  New York:N.Y.: Yourdon Press, 1984.andM;Ross, R.G.andP;  Entity Modeling: Techniques and Application.andP;  Boston, Mass.:andO;Database Research Group, 1987.andM;David M. Bulman is president of Pragmatics Inc., a consulting firm inWaikoloa, Hawaii, that offers seminars in object-oriented development.andP;  Hehas been programming, consulting, and teaching for more than 30 years.andO;</TEXT></DOC>