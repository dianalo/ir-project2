<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-315-372  </DOCNO><DOCID>08 315 372.andM;</DOCID><JOURNAL>Datamation  March 15 1990 v36 n6 p109(3)* Full Text COPYRIGHT Cahners Publishing Co. 1990.andM;</JOURNAL><TITLE>Training for a key transition. (converting to COBOL II) (includesrelated article on relating COBOL II to Systems ApplicationArchitecture) (Management - Education)</TITLE><AUTHOR>Bookman, Harvey.andM;</AUTHOR><SUMMARY>Conversion by any company from COBOL to IBM's new programminglanguage COBOL II involves more than simple installation.andP;  Reviewof and changes in programming standards and training proceduresare necessary to fully utilize COBOL II's features.andP;  Installing anew language involves several steps.andP;  First, the complexities ofCOBOL II must be understood and a decision made as to whether theadvantages are worth the effort.andP;  Second, programming standardsmust be revised for COBOL II programming but in light of thecompany's needs and structure.andP;  Third, training courses must berewritten to bridge the changeover and programmers must betrained.andP;  Fourth, decisions must be made regarding theimplementation of standards for only new programs or for both newprograms and converted ones.andP;  Additional decisions regarding theconcurrent use of two generations of COBOL are needed.andM;</SUMMARY><DESCRIPT>Product:   COBOL-2 (Compiler) (usage).andO;Topic:     Programming ManagementStandardsProgramming Languages.andO;Feature:   illustrationtable.andO;Caption:   Implementation tips. (table)andM;</DESCRIPT><TEXT>Training for a Key TransitionandM;Many companies have begun converting VS COBOL programs to COBOL II andwriting new programs in COBOL II.andP;  Introduced by IBM in 1984, COBOL II isslowly becoming the standard for COBOL programming.andP;  Companies are oftenunder the misconception that installation of COBOL II is complete when thecompiler has been placed on a system and then tuned.andP;  But installation isreally only complete after the training staff and the standards committeehave determined which of COBOL II's new features will be allowed and how theprogramming process will change as a result of the installation.andM;If VS COBOL programming standards are not updated, COBOL II programs will becoded in the same manner as VS COBOL programs and will not take advantage ofthe new software technology available.andP;  If no standard procedures areadopted, each department will be coding COBOL II programs in its own way.andM;Companies that merely update their VS COBOL training courses and standards byswitching to the new COBOL II syntax will be applying old technologystandards to a new language.andP;  That would be similar to the first automobileowners using horses to pull their Model T Fords.andP;  Almost every company has aset of programming standards that programmers and analysts are expected tofollow.andP;  These standards are usually developed by special teams and areinfrequently, if ever, updated.andP;  Even when a new language is installed,companies tend to rely on established standards and training procedures,which usually amounts merely to updating statements, a simple one-to-oneconversion from the old language to the new.andM;The Proper VerbandM;For instance, years ago the ALTER verb often was taught in COBOL classes.andO;When structured programming became popular, programmers in most companieswere told never to use the ALTER verb because it led to unstructured codethat was difficult for other programmers to follow.andP;  Training departments hadto review courses and either stop mentioning the ALTER verb or stronglysuggest it not be used.andM;When COBOL II was released, it became apparent that similar updates should bemade to companies' standard programming procedures.andP;  For example, it might bebetter to use an INITIALIZE statement rather than separate MOVE statements tomove initial values to fields.andP;  Additionally, the elimination of some verbsin COBOL II necessitates other changes.andP;  In COBOL II, the DISPLAY statementwould be used instead of the EXHIBIT statement, INSPECT instead of EXAMINE,comments instead of REMARKS.andM;But to take full advantage of the facilities of a new language, companiesshould establish new standards.andP;  The standards committee needs to look at thetrade-offs involved in the language's additional capabilities and decidewhich are appropriate.andP;  Training staffs should work in conjunction with astandards committee to update training material.andP;  The training staff shouldtailor in-house courses which are consistent with company guidelines andensure that courses purchased from outside vendors comply with the standards.andO;What many companies do not realize is that COBOL II allows for much more thanjust changing one VS COBOL verb to a different one in COBOL II.andP;  There are anumber of reasons why COBOL II standards are often incomplete andinsufficient:andM;* Standards are often arrived at through experience with a product, and mostcompanies don't have enough experience with COBOL II to understand whataspects of the language will best fit into their company's methodology.andM;* Coversion of VS COBOL programs to COBOL II is often given high priority andis therefore done before standards are established.andP;  Training classes for enmasse conversion do not reflect the need for new standards.andM;* When changes to standards are made to guide conversions, they are oftenconfined to what must be changed in VS COBOL programs for them to runsuccessfully in COBOL II.andP;  But these updates can be made by any basicconversion program and do not take program design into account.andM;* Even when comprehensive standards have been established, often COBOL IIcourses for VS COBOL programmers (bridge courses) do not sufficientlycommunicate those standards.andP;  These courses usually concentrate on explainingthe basic differences between VS COBOL and COBOL II and on how to convertprograms.andM;* It is sometimes harder to insert company standards into computer-basedtraining packages than into courses taught by instructors.andM;The important changes that must be made to COBOL II standards are those thatare not readily apparent.andP;  They must be taken into account during theanalysis and program design stages of a project.andM;When writing new programs, proper analysis and design will lead to programsthat take advantage of many of the new COBOL II features.andP;  Proper analysisand design will also reduce coding time and make programs much easier tofollow.andM;Confusing CodeandM;Take as an example the problem of 10 programs all writing to the same reportfile concurrently.andP;  In VS COBOL, the typical approach for a company would beto write a separate report writer program to open, write to and close thefile.andP;  A driver program would call the report writer to open the file, leteach program call the report writer to write each record and, when processingis complete, would call the report writer to close the file.andP;  This leads toinefficient as well as confusing code.andP;  There is more chance of a codingerror when using a CALL statement than when using a WRITE statement.andM;But COBOL II release 3 allows files and variables to be defined as&quot;external.&quot;andP;  A file can be opened in one program, written to by many separateprograms and then closed by any program.andP;  Even the switch indicating that thefile is opened or closed may be used in multiple programs without passing itin CALL statements.andP;  Using external files and switches when writing to areport file leads to systems that are more straightforward and easier todesign and maintain.andM;However, this design will not be achieved if conversion software is used onan existing system.andP;  For existing applications, an effort must be made tochange some code to use the new methodology allowed in COBOL II.andM;Trade-Offs of Complex FeaturesandM;When evaluation COBOL II, the standards committee needs to determine whetherthe language's more complex capabilities are going to be more trouble thanthey're worth.andP;  For example, COBOL II allows nested programs (multipleprograms within one another in the same source file) and global data itemsshared among nested programs.andP;  Nested program CALL statements process muchmore efficiently (with the efficiency of a PERFORM statement) than CALLstatements to nonnested programs.andP;  But they are also complex and difficult tounderstand.andM;Do their advantages outweigh the extra training required to understand them?andO;Should companies prohibit or restrict their use?andP;  It seems that whenefficiency is the major issue, nested programs may be useful.andP;  however, theirgeneral use may do more harm than good.andP;  A highly intelligent programmer mayuse a complex design that will be difficult for the average programmer tomaintain.andM;FILLER data items no longer need the word FILLER explicitly coded.andP;  Willexperienced programmers find this confusing?andP;  Will it detract from theclearness of code?andP;  Changes like this will not be effected during conversionsand are often overlooked.andM;The EVALUATE statement allows code to be written for what is called a &quot;case&quot;construct in structured programming, whereby a path is taken based on a setof conditions.andP;  An IF statement can always be coded instead of an EVALUATEstatement, and can always produce code that is at least as efficient.andP;  Adetermination must be made as to whether programmers will be required to useEVALUATE or IF statements.andM;To further confuse the issue, COBOL II has an END-IF statement to limit thescope of the IF statement, thus enhancing the IF statement.andP;  Its prudent usemay help eliminate the problem of forgetting to code a period at the end ofan IF statement.andM;More ChoicesandM;It is more difficult to choose between two commands that resolve the sameproblem in COBOL II than it was in VS COBOL.andP;  There are more commands andclauses, allowing many ways of coding to produce the same results in moreinstances than is possible in VS COBOL.andP;  Which of the many possible methodsshould a programmer choose?andM;COBOL II AllowsandM;For MUCH MORE THANandM;JUST CHANGING ONEandM;STATEMENT TO ANOTHER.andM;The new features in COBOL II that allow more flexibility must be carefullyanalyzed, and each company must decide whether the flexibility is an asset ornot.andM;Perhaps one of the reasons that languages such as PL/1 have never gainedconsiderable popularity is because so much flexibility can make maintenance anightmare.andP;  Programmers familiar with only a subset of PL/1 may often beconfounded by code they do not understand.andP;  The restrictions in VS COBOL madeit easier to establish standards and training courses.andM;COBOL II does allows specific statements to be restricted on a companywidebasis, but companies should use this facility only after carefulconsideration of its various implications.andP;  For example, the ALTER commandcan be eliminated, thereby eliminating a company's worries about theconfusing code it can produce without causing other problems.andM;However, you would not want people to subjectively eliminate the EVALUATE andINITIALIZE statements just because they feel the statements are tooinefficient.andP;  That would overlook the fact that these verbs contribute toeasier maintenance, which might easily outweigh any use of extra CPU cycles.andO;In addition, the verbs removed might be important in the design of aparticular system.andM;COBOL II AdvantagesandM;Not everything about COBOL II is more complex than VS COBOL.andP;  Take, forexample, the common problem of obtaining a last name from a field containinga first name followed by a last name, when another field contains thestarting position of the last name.andP;  COBOL II provides an extremely simpleanswer to the problem, coded in a single statement that is much easier for aprogrammer to understand than the way it is done in VS COBOL.andP;  It relies onthe new feature of &quot;reference modification&quot; (a fancy name for the ability tocreate a substring from part of a data item) introduced in release 3 of COBOLII.andM;Training departments must carefully analyze the advantages of referencemodification, since a cursory understanding may lead to its restriction in acompany.andP;  When used only to eliminate the need for coding subfields, thestatement may end up making a program harder to maintain.andM;Even the options available for compilation can lead to problems for thestandards committee.andP;  For instance, the SSRANGE option has long been awaitedby COBOL programmers.andP;  It instructs the compiler to generate code to ensurethat subscripts, indexes, OCCURS DEPENDING ON values and referencemodification values are within the ranges allowed in the program.andP;  Invaliddata in these items cause abnormal program terminations that are oftendifficult to debug.andM;While solving one problem, the new option creates another.andP;  It is soinefficient that it can make a program run much longer, in rare cases even50% longer.andP;  This has led some companies to prohibit its use.andP;  Trade-offs ofprogrammer productivity for substantial increases in CPU time are not alwayseasy to make.andP;  They may depend on a number of factors such as the amount onunder-utilized CPU capacity and the technical ability of the programmingstaff.andM;New Features, More QuestionsandM;COBOL II offers other new features leading to questions such as:andM;* Should seven-dimensional tables available in COBOL II be used?andP;  The limitis three in VS COBOL.andM;* Should a table be initialized with a VALUE clause or through the INITIALIZEstatement?andP;  Neither of these features was allowed in VS COBOL.andM;* Should programmers be allowed to use upper and lower case code in theirprograms according to their own subjective style?andM;Training departments establishing standards must carefully assess whether thenew standards take advantage of the new environment available in COBOL II.andO;Simply ensuring that standards will work is not enough.andM;Standards must be critically reviewed if new features are to be used to theirfull advantage.andP;  Otherwise, there will be more to teach and more variables toconfuse programmers.andP;  You might even end up decreasing rather than increasingprogrammers productivity.andM;Company should decide whether they are going to enforce COBOL II standardsfor all programs or have two sets of standards, one for converted programsand one for new programs.andP;  If maintenance tasks are to become standardizedunder the new COBOL, it makes sense to follow the same standards for bothconverted programs and new programs.andM;However, companies often do not have the extra resources available to insertstandards into converted programs, and management is often reluctant to makemore changes than are absolutely necessary.andP;  Experience shows that a changeto only a few lines of code can cause major problems.andM;Because the majority of programmers work on maintenance rather thandevelopment, knowledge of VS COBOL code may still be required for many yearsin companies that plan to use a dual COBOL environment.andM;Harvey Bookman is president of New York City-based Bookman Consulting Inc., asoftware development company specializing in programmer proficiency testing.andO;He is the author of COBOL II (McGraw Hill, April 1990).andO;</TEXT></DOC>