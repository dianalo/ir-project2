<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-819-872  </DOCNO><DOCID>07 819 872.andM;</DOCID><JOURNAL>EXE  Oct 1989 v4 n5 p22(4)* Full Text COPYRIGHT Process Communications Ltd. 1989.andM;</JOURNAL><TITLE>OOP Pascal: the inside story. (Software Review) (includes relatedarticle on Macintosh memory management) (evaluation)</TITLE><AUTHOR>Smith, Paul G.andM;</AUTHOR><SUMMARY>Macintosh programmers have the advantage over PC programmers whenit comes to the mechanisms behind object-oriented Pascal.andP;  Theworkings of QuickPascal, Turbo Pascal 5.5 and Apple Object Pascalare described and compared.andP;  QuickPascal uses three areas ofmemory: a data segment with global (static) variables, a stacksegment with compiler and local variables, and the heap (a regionmemory for non-relocatable variable length data structures).andO;QuickPascal is touted as the standard Object Pascal, however, itdoes a substandard job of implementing the language.andP;  Turbo Pascal5.5 implements static objects, constant objects, static methods,constructors and destructors.andP;  There is orthogonality betweenrecords and objects, but method table references cannot beinitialized automatically.andP;  Apple's Object Pascal makes the PCofferings seem primitive and unsophisticated by comparison.andP;  TheApple product has no need of a distinction between static andvirtual methods because the Linker automatically constructs avirtual method call.andP;  Objects are always instantiated inrelocatable heap blocks.andM;</SUMMARY><DESCRIPT>Product:   Turbo Pascal (Program development software)Object Pascal (Program development software)QuickPascal (Compiler).andO;Topic:     ComparisonCompilersEvaluationObject-Oriented Languages.andO;Feature:   illustrationtablechart.andO;Caption:   How objects are accessed in QuickPascal. (table)The Macintosh memory map. (chart)Macintosh heap management. (chart)andM;</DESCRIPT><TEXT>OOP Pascal: The inside story In September's edition of .EXE Magazine, Ioutlined the history and examined the PC implementations of object-orientedPascal.andP;  This month, I will describe the mechanisms behind 'objects' asimplemented in QuickPascal, Turbo Pascal and the original Apple ObjectPascal, showing why PC programmers are getting half measure compared to theirMaccousins.andM;QuickPascal V1.0andM;QuickPascal (QP) uses three areas of memory for program data.andP;  Global(static) variables are allocated in a data segment.andP;  The compiler reservesmemory for parameters and local variables in the stack segment.andP;  The thirdarea -- the heap -- is a region of memory in which non-relocatablevariable-length data structures are allocated.andP;  QP supplies no mechanism formanaging relocatable memory blocks (described later in this article).andO;Objects are always allocate in non-relocatable memory blocks.andM;Object variables (which are pointers to objects, not the objects' data) areallocated in either the data or the stack segment, depending on whether theyare global or local variables.andP;  Object instances (the data the variablespoint to) are all placed on the heap.andP;  Each object instance has sufficientmemory to hold all its data fields of the object plus a pointer to its methodtable.andP;  Microsoft's QuickPascal uses 'flat' virtual method tables: ie onetable for each object type, containing an entry for each method.andP;  QP methodtables also contain a field defining the size of object instances for theirclass.andM;This structure of object, with the memory block containing a pointer to theclass method table followed by the data fields, makes it very easy for thecompiler to generate code to call methods and access fields -- see Figure 1.andO;The overhead for method calls is fixed.andP;  If parameters are to be passed, theadditional overhead is the same as that of an ordinary procedure or function.andO;The disadvantages of this approach will become clear when we consider themore sophisticated design of Apple's Pascal.andM;I wrote in my last article that 'QuickPascal follows the Apple languagedefinition quite closely'.andP;  To expand a little: QP syntax varies in oneirritating detail.andP;  QP insists that every reference to object fields within amethod be prefixed with self.andP;  to indicate that the field belongs to theobject.andP;  Object Pascal allows fields to be accessed by their names alone.andP;  Asmall point, perhaps, but one that would compel you to perform a lot oftiresome editing if porting code from the Mac to PC.andM;QP purports to be 'standard' Object Pascal.andP;  In fact, it does a poor job ofimplementing the language.andP;  The error in the self syntax, pointed out above,makes me doubt that QP's authors have read the Apple language definition.andO;But QP's biggest faults are represented by a list of conspicuous absences.andO;Lacking overlay management, smart program linkage and method tableoptimisations, QP is quite unsuitable for the development of non-trivialprograms: it is a toy compiler.andM;Turbo PascalandM;Turbo Pascal V5.5's object-oriented extensions are, as I wrote before, quitedifferent to Apple's Object Pascal and Microsoft's QP.andP;  Significantly, TP5.5implements static objects, constant objects, static methods, constructors anddesctructors.andM;The implementation of global variables, local variables, and dynamic objectsis similar to that of QP.andP;  The language syntax differs, however, todistinguish between static and dynamic objects.andP;  Dynamic object variablesmust be explicitly defined as pointer variables.andP;  Static and constant objectsare allocated like normal variables and constants.andP;  Dynamic objects areallocated in a heap, in which a non-relocatable memory block is set aside foreach instance of an object.andM;TP5.5 objects with virtual methods contain a reference (pointer) to themethod table--objects without virtual methods do not, which, as we will see,causes problems.andP;  This pointer is placed within the object using thefollowing rule: before the first data field of the first type in the objecthierarchy that has virtual methods.andM;Method tables are made up of one field containing the object's size, a secondfield containing the complement of the first (used for method call validationduring debugging), followed by a list of double word pointers to the methods'program code.andP;  Figure 2 shows examples of TP5.5 method call code.andP;  Calls toboth static and virtual methods have fixed overheads -- in fact, staticmethods are treated like ordinary procedure/function calls.andM;Borland has implemented a semi-smart linker.andP;  If an object type is neverinstantiated (used), all methods for that object are stripped from the finalprogram file; otherwise all the methods for that object are included.andO;Compare this to Apple's linker, which strips the code of individual methodsaccording to whether they have been invoked within the link job and onlycreates method tables for polymorphic (overridden) methods.andM;I have already complained that static methods are only necessary becauseBorland's linker is too dumb to recognise monomorphic methods (ie methodsthat are never overridden) and treat them accordingly.andP;  Borland gives twojustifications for static methods: they permit name overloading and they letthe programmer control the size of virtual method tables and optimise theircode.andP;  (Borland's position, as quoted in this article, is based on interviewsthat I conducted with Borland's Gary Whizin, Development Manager for TurboPascal, and Anders Hejlsberg, Chief Architect of the language.)andM;Name overloading is borrowed from C++.andP;  Overriding static methods are allowedto take different parameters and return different function results.andP;  This issomething about which I feel distinctly uncomfortable, because I like todesign polymorphic methods that have the same effect whatever object theybelong to.andP;  Take the classical example of a hierarchy of derived classes: thegraphical objects.andP;  Suppose that two different objects, derived from the sameancestor, each have a method called Draw.andP;  One object is (say) a rectangle,the other a circle.andP;  Then the rectangle object method would be called withRectInst.Draw (x, y, width, height), while the circle object might requireCircInst.Draw (x, y, radius).andP;  This violates my program design principles.andO;Borland claims that name overloading is analogous to the effect of Pascal'sscoping rules: local procedures declared within separate outer procedures canhave the same names but different parameters.andM;Borland's claim that static methods allow the programmer to optimise hisprograms, by forcing the compiler to generate direct calls and hence takemethods out of their objects' method tables, is correct.andP;  US-based TurboPowerSoftware, which is developing a class library for TP5.5, found that, becauseof the size of flat virtual method tables, it ran out of space unless it mademany of its objects' methods static.andP;  By implementing static methods, Borlandhas been pragmatic -- at a cost to the user.andP;  The problem could have beenavoided by writing a smarter linker.andM;Not constructiveandM;There is also the question of Borland's implementation of constructors anddestructors.andP;  C++ calls them automatically when creating and destroyingobjects, thus making it easier to use static objects.andP;  Borland never callsthem automatically.andP;  If you do not call an object's constructor then itsmethod table reference is never initialised.andP;  If you do not call an objecthsdestructor when you dispose of it, the Dispose function does not know howmuch memory to release.andM;Borland says that, since most object classes need an initialisation method toset up object fields, there is no harm in inventing a special kind ofinitialisation method.andP;  When called to set up an objecths fields, TP5.5'sconstructors also initialise private stuff needed by the run-time system.andO;This is wrong: a Pascal programmer should not have to enforce things thatbelong in the run-time system.andP;  The compiler should generate the requiredcode.andM;Borland's other point is that, since TP5.5 allows variable-length dynamicarrays of static objects, it is not possible to initialise automatically allthe potential array members' method table pointers.andP;  (Pascal does not supportdynamic arrays directly.andP;  However, consider the type definition BIGARRAY =ARRAY [0..5000] OF BIGTYPE.andP;  If you define a variable that points toBIGARRAY, you can allocate a dynamic block that is shorter than the arraytype.andP;  As long as you do not go off the end of the block, you can safelyaccess elements with the construct BIGARRAYPTR.andP;  [and] [elemNum]).andM;Why does TP5.5 allow dynamic arrays of static objects?andP;  It encourages badprogramming practices and it creates nasty implementation problems.andP;  Theanswer is that Borland trapped itself with the flexibility of TP5.5's syntax.andO;The Borland designers were constrained by a hierarchy of design decisions.andO;It seemed desirable to preserve orthogonality between records and objects,but, having done this, they discovered that they could not inilialise methodtable references automatically.andM;I have one final gripe with TP5.5 Standard Object Pascal provides a standardfunction Member.andP;  This compares two object instances and returns TRUE if oneis a member or descendant of the class of the other.andP;  TP5.5's nearestequivalent is a function called Type0F.andP;  This returns a pointer to anobject's method table and can be used to determine whether two objects are ofthe same class.andP;  However, if the object does not have a method table (ie hasno virtual methods), it does not work -- it actually causes an error!andP;  Thismakes Type0f nearly useless.andP;  Why should a programmer need to know, if hisprogram uses objects written by someone else on a project, whether thoseobjects have virtual methods?andM;Clearly Member is a more generally useful function.andP;  Even so, Type0f could beextended to work for all kinds of object.andP;  The compiler knows whether anobject has a method table, because otherwise it could not generate the codeto extract the reference to it from the object.andP;  Where there is no methodtable, the compiler could generate code to return a unique value for eachclass type.andP;  If it used illegal addresses, such as odd values, for thispurpose, then they would never clash with the address of a real method table.andM;Apple's Object PascalandM;On the Macintosh, objects are always instantiated in relocatable heap blocks.andO;The compiler automatically calls the Memory Manager to create and dispose ofthem and generates the appropriate code to reference their fields andmethods.andP;  Every object variable is a handle variable: a pointer to a pointerto a relocatable memory block.andP;  An object variable is, therefore, a referenceto the object and not the object itself.andP;  Assigning an objectanyThing:=different Thing; does not copy any object data; it merely copies areference to the object.andP;  The referenced memory block contains a two-byteobject class identifier, followed by all the fields declared for the objecttype and its ancestors.andM;A new call, specifying an object variable, creates a relocatable memory blockfor the object instance in the heap and leaves the address of its masterpointer in that object variable.andP;  This memory block is released when aDispose call is made, specifying the handle of the object to be freed.andM;All Apple Object Pascal method calls result in a table look-up, to determinethe address of the code being called.andP;  This is quite different from anordinary procedure or function call.andP;  Each method call is translated as acall to a special routine associated with that method.andP;  This routine in turncontains a call to the method dispatcher, followed by a table ofimplementations for that method.andP;  The method dispatcher determines which ofthese implementation methods is appropriate to the object whose methods wasbeing called.andP;  It performs a linear search of the method table, looking for amethod with a matching class identifier.andP;  See Figure 5.andM;Methods tables are usually stored in a segment of their own, which means thatthey must be called via the jump table.andP;  The jump from the method table tothe implementation code also goes through the jump table.andP;  As a result, themethod table is shorter, as it contains a list of offsets into the jumptable, instead of a list of segment numbers and offsets.andP;  Also, the methoddispatcher does not need to know how to load segments.andP;  Each method tablealso contains an entry that stores a copy of the entry for the last-calledmethod: this means that if the same class method is called successively, thesecond and subsequent calls are faster.andM;The linker optimises monomorphic method calls, making them into normalprocedure or function calls.andP;  Any object methods that are not overridden aretreated like ordinary procedure or function calls.andP;  The Linker can tell, fromwhether a given object type is instantiated, whether it should include itsmethods in the linked program file.andP;  The distinction between monomorphic andpolymorphic methods is made at link time -- the compiler knows nothing of theprocess.andM;The upshot of this is that Apple's Object Pascal has no need of a distinctionbetween static and virtual methods.andP;  If a method is polymorphic, the Linkerautomatically constructs a virtual method call.andP;  If a method is monomorphic,the Linker treats it as an ordinary procedure or function, so there is nooverhead on the method call.andP;  If a method is never used it will not be linkedinto the program.andP;  All this takes place with no interference from theprogrammer.andM;But which PC Pascal?andM;Apple's Object Pascal shows just how primitive and unsophisticated the PCofferings are.andP;  However, I recognise that it would be unrealistic andunhelpful to expect all .EXE readers to abandon their PC development in orderto take advantage of the Mac's superior programming facilities.andP;  It is, then,once more a case of pitting QuickPascal against Turbo Pascal.andM;Readers of my previous article will have spotted that I am guilty of a U-turnin my evaluation of QP.andP;  I still do prefer Microsoft's language design toBorland's.andP;  A more thorough probing of the compiler's limitations, however,has produced deep reservations about the suitability of QP for professionalprogramming.andP;  Users will find it difficult, if not impossible, to build largeprograms with it.andM;I cannot praise Turbo Pascal V5.5's language design or implementation.andP;  I donot believe that Borland has got its language design right.andP;  However, if youwant a PC object-oriented Pascal for professional programming, TP5.5 iscurrently (I say, reluctantly) the only choice.andM;Paul G Smith is a specialist in object-oriented programming techniques,graphics, and communications.andP;  He was co-founder of Macintosh and PC softwarehouse Baccbus andamp; Smith Limited.andP;  Thanks to Larry Rosenstein, of Apple's SystemSoftware group, for supplying details of the Object Pascal method callingmechanism.andO;</TEXT></DOC>