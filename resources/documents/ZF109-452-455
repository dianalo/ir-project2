<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF109-452-455  </DOCNO><DOCID>09 452 455.andM;</DOCID><JOURNAL>Communications of the ACM  Sept 1990 v33 n9 p40(21)* Full Text COPYRIGHT Association for Computing Machinery 1990.andM;</JOURNAL><TITLE>Understanding object-oriented: a unifying paradigm.andO;</TITLE><AUTHOR>Korson, Tim; McGregor, John D.andM;</AUTHOR><SUMMARY>Traditional software development does not support iteration, reuseor a unifying model to integrate phases of the program life cycle,but the object- oriented paradigm addresses all these issues.andO;Boundaries between phases are blurred in the object-orientedsoftware life cycle because objects are the items of interest inall phases.andP;  Both the analysis and design phases identify objectsand the relationships between objects, providing a continuity thatcreates a seamless interface between phases.andP;  The object-orienteddevelopment process is iterative, replacing the 'waterfall' modelof software development with a 'fountain' model.andP;  Individualsoftware components are designed to represent concepts that willeventually be executable forms; the Abstract Data Type (ADT) isthe way the object-based paradigm captures the conceptualinformation.andM;</SUMMARY><DESCRIPT>Topic:     Object-Oriented ProgrammingProgram Development TechniquesSoftware DesignAbstract Data TypesNew Technique.andO;Feature:   illustrationchartprogram.andO;Caption:   Group of related classes referred to as a subsystem or classcluster. (chart)A menu example. (program)An example inheritance graph. (chart)andM;</DESCRIPT><NOTE>Only Text is presented here; see printed issues for graphics.andO;</NOTE><TEXT>UNDERSTANDING OBJECT-ORIENTED: A UNIFYING PARADIGM The need to develop andmaintain large complex software system in a competitive and dynamicenvironment has driven interest in new approaches to software design anddevelopment.andP;  The problems with the classical waterfall model have beencataloged in almost every software engineering text [19,23].andP;  In response,alternative models such as the spiral [2], and fountain [9] have beenproposed.andM;Problems with traditional development using the classical life cycle includeno iteration, no emphasis on reuse, and no unifying model to integrate thephases.andP;  The difference in point of view between following data flows instructured analysis and building hierarchies of tasks in structured designhas alway been a major problem [4].andP;  Each system is built from scratch andmaintenance costs account for a notoriously large share of total systemcosts.andM;The object-oriented paradigm addresses each of these issues.andM;A look at the object-oriented software life cycle, as described by Meyer [5],Coad and Yourdon [4], and Henderson-Sellers and Edwards [9], identifies thethree traditional activities of analysis, design, and implementation.andO;However, each of the referenced descriptions eliminates the distinctboundaries between the phases.andM;The primary reason for this blurring of boundaries is that the items ofinterest in each phase are the same: objects.andP;  Objects and the relationshipsbetween objects are identified in both the analysis and design phases.andO;Objects and relationships identified and documented in the analysis phaseserve not only as input to the design phase, but as an initial layer in thedesign.andP;  This continuity provides for a much more seamless interface betweenthe phases.andP;  Analysts, designers and programmers are working with a commonset of items upon which to build.andM;A second reason for the blurring of these boundaries is that theobject-oriented development process is iterative.andP;  Henderson-Sellers andEdwards further refine this idea by replacing the waterfall model of softwaredevelopment with a fountain model.andP;  Department reaches a high level only tofall back to a previous level to begin the climb once again.andM;As an example of the blurring of the traditional boundaries of the life cyclephases, Coad and Yourdon recommend that classification relationships betweenobjects be captured and documented during the object-oriented analysis (OOA)phase.andP;  This classification will be directly reflected in the classinheritance structure developed in the design and in the code.andP;  Thisclassificationis in no way required in order to document the systemrequirements.andP;  In other words, Coad and Yourdon are recommending atraditional design activity in the analysis phase.andM;The blurring of the traditional design and implementation phases has beenfueled by the development of encapsulation and abstraction mechanisms inobject-oriented and object-based languages.andP;  For example, Meyer claims [14]that Eiffel is both a design and an implementation language.andP;  He goes on tosay that software design is sometimes mistakenly viewed as an activitytotally scluded from actual implementation.andP;  From his point of view, much isto be gained from an approach that integrates both activities within the sameconceptual framework.andM;The object-oriented design paradigm is the next logical step in a progressionthat has led from a purely procedural approach to an object-based approachand now to the object-oriented approach.andP;  The progression has resulted from agradual shift in point of view in the development process.andP;  The proceduraldesign paradigm utilizes functional decomposition to specify the tasks to becompleted in order to solve a problem.andP;  The object-based approach, typifiedby the techniques of Yourdon, Jackson and Booch, gives more attention to dataspecifications than the procedural approach but still utilizes functionaldecomposition to develop the architecture of a system.andP;  The object-orientedapproach goes beyond the object-based technique in the emphasis given to databy utilizing the relationships between objects as a fundamental part of thesystem architecture.andM;The goal in designing individual software components is to represent aconcept in what will eventually be an executable form.andP;  The Abstract DataType (ADT) is the object-based paradigm's technique for capturing thisconceptual information.andP;  The class is the object-oriented paradigm'sconceptual modeling tool.andP;  The design pieces resulting from theobject-oriented design technique represent a tighter coupling of data andfunctionality than traditional ADTs.andP;  These artifacts of the design processused in conjunction with a modeling-based decomposition approach yield aparadigm, a technique, which is very natural and flexible.andP;  It is natural inthe sense that the design pieces are closely identified with the real-worldconcepts which they model.andP;  It is flexible in the sense of quickly adaptingto changes in the problem specifications.andM;Object-oriented remains a term which is interpreted differently by differentpeople.andP;  Before presenting an overview of a set of techniques for the designprocess, we will give our perspective so the reader may judge the techniquesin terms of those definitions.andP;  Briefly, we adapt Wegner's [27] definitionfor object-oriented langauges to object-oriented design.andP;  The pieces of thedesign are objects which are grouped into classes for specification purposes.andO;In addition to traditional dependencies between data elements, an inheritancerelation between classes is used to express specializations andgeneralizations of the concepts represented by the classes.andM;As natural and flexible as the object-oriented technique is, it is stillpossible to produce a bad design when using it.andP;  We will consider a number ofgeneral design criteria and willd iscuss how the object-oriented approachassists the designer in meeting these criteria.andP;  We will refer to a number ofdesign guidelines developed specifically for the object-oriented designparadigm and will discuss how these properties reinforce theconcepts of gooddesign.andM;The paradigm sprang from language, has matured into design, and has recentlymoved into analysis.andP;  The blurring of boundaries between these phases has ledus to include topics in this article that are outside the realm of design,but which we consider important to understanding the design process.andP;  Sincethe paradigm sprang from language, we define the concepts basic toobject-oriented programming in the following section.andM;Basic Concepts ofandM;Object-OrientedandM;ProgrammingandM;Five general concepts will be discussed in ths section: objects, clases,inheritance, polymorphism, and dynamic binding.andP;  The first three conceptsappear in high-level design and analysis.andP;  The last two are added duringlow-level design and implementation.andM;Although these concepts are basic to object-oriented programming, the variousobject-oriented communities often associate different specifics with eachconcept.andP;  In this section we focus on the basics of the concepts.andP;  Latersections elaborate on the possible variations.andM;Of the five concepts, only one (inheritance) is a unique contribution of theparadigm.andM;It is the blending of inheritance with the other four concepts in specificways that characterizes object-oriented programming.andP;  The paradigm is newenough, however, that there is not universal agreement on how to characterizeit.andP;  Other definitions can be found in [5, 28].andM;In the following discussion we introduce and illustrate each of the fiveconcepts using Eiffel syntax and semantics.andM;Figure 1 shows a group of related classes referred to as a subsystem or aclass cluster [14].andP;  This cluster implements all of the types necessary forimplementing a simple hierarchical menu system.andM;objectsandM;Objects are the basic run-time entities in an object-oriented system.andO;Objects take up space in memory and have an associated address like a recordin Pascal or a structure in C.andM;The arrangement of bits in an object's allocated memory space determines thatobject's state at any given moment.andP;  Associated with every object is a set ofprocedures and functions that define the meaningful operations on thatobject.andP;  Thus, an object encapsulates both state and behavior.andM;From a design perspecitve, objects model the entities in the applicationdomain.andM;ClassesandM;A class defines a set of possible objects.andP;  From the point of view of astrongly typed language, a class is a construct for implementing auser-defined type.andP;  For example, in Figure 2 the variables main_menu andsub_menu are both type MENU.andP;  Execution of the statement Main_menu.createdynamically allocates space for the object &quot;Main_menu.&quot;andP;  Subsequent executionof the statement sub_menu.create dynamically creates a second instance of theMENU class.andM;Ideally, a class is an implementation of an ADT.andP;  This means that theimplementation details of the class are private to the class.andP;  The publicinterface of such a class is composed of two kinds of class methods.andP;  Thefirst kind consists of accessor functions that return meaningful abstractionsabout an instance's state.andP;  The other kinds of methods are transformationprocedures used to move an instance from one valid state to another.andM;Information-hiding guidelines dictate that all data within a class beprivate.andP;  This is to guarantee that the itnerface of the class is in fact anabstraction.andM;Other languages provide a similar construct for creating an ADT.andP;  Ada, forexample, has the package.andP;  A package differs from a class in that a packageencapsulates the type but is not the type itself.andP;  This is an importantdifference.andP;  It results in a weaker connection between state and behavior aswell as the syntactic burden of an additional parameter to most of thepackage's procedures.andM;Some systems, such as Smalltalk, have run-time class-objects (meta-classobjects).andP;  By this we mean that for each class in the system there is acorresponding object that stores information about the class as a whole andimplements the class-level operations.andP;  Such objects are useful for storingdynamic information about the type, such as the number of current instancesof the type, and provide an elegant way to implement operations such as classconstructors and destructors, or maintain global information specific to theclass.andM;InheritanceandM;Inheritance is a relation between classes that allows for the definition andimplementation of one class to be based on that of other existing classes.andO;Instance-based inheritance has also been studied and implemented [21], but wewill limit this discussion to traditional class-based inheritance.andM;Inheritance is the most promising concept we have to help us realize the goalof constructing software systems from reusable parts, rather than hand codingevery system from scratch.andP;  Procedural abstraction has worked well for someselect domains, such as mathematical libraries, but the unit of abstractionis too small, the procedural focus not general enough, and the parametermechanism too rigid.andM;Another construct that has been touted as holding a key to reusability is theconcept of parametrized types or generics as applied to procedures, and Adapackages.andP;  The ability to create libraries of generic procedures and packagesis a very useful one that has not been exploited nearly enough and will proveto be a central concept in the future of software development.andP;  It, however,is only applicable to strongly typed systems and is not as general a conceptas inheritance.andM;Inheritance not only supports reuse across systems, but it directlyfacilitates extensibility within a given system.andP;  This theme will beelaborated upon throughout the article.andP;  We will show that inheritanceminimizes the amount of new code needed when adding additional features, andthat inheritance coupled with polymorphinesm and dynamic binding minimizesthe amount of existing code that must be changed when extending a system.andM;To understand exactly what inheritance is and how it provides the claimedbenefits we introduce some basic terminology, elaborate on the inheritancerelation, and then illustrate it with a simple example.andM;When class Y inherits from class X (see Figure 3), we will refer to class Yas a derived class and class X as a base class.andP;  In this case, class Y hastwo parts, a derived part and an incremental part.andP;  The derived part is thepart inherited from X.andP;  The incremental part is the new code, writtenspecifically for Y.andM;The mapping from the members of X to the derived members of Y is defined bythe rules of the language in conjunction with code written by the programmerin class Y.andP;  The mapping may be a simple identity in which the derived partof Y is exactly the same as the members of X.andP;  This inheritance mapping mayhowever, be much richer than a simple identity.andM;In general, a feature of X may be renamed, reimplemented, duplicated, voided,have its visibility changed, or underto almost any other kind oftransformation as it is mapped from X to Y.andP;  As with any language feature,inheritance can be misused.andP;  What constitutes the proper use of inheritanceis a widely debated topic.andP;  We favor a very disciplined use of inheritance.andM;Each object-oriented language has its own set of allowable inheritancemappings.andP;  At the language level, keywords are provided to indicate the kindof mapping desired.andP;  Certain kinds of mappings require additionalinformation.andP;  For example, if a given member of X is to be reimplemented asit is mapped to Y, the code for reimplementation must be given.andM;The inheritance relation is often called the &quot;is,a&quot; relation.andP;  This isbecause when a class Y inherits from class X, class Y now has, byinheritance, all the features of X.andP;  Thus Y is an X.andP;  Y is undoubted morethan an X, but in addition to whatever else it may be it is also an X.andM;Because of this, the inheritance relation is often used to reflectabstraction and structure present in an application domain.andP;  A commonly usedexample domain is from graphics.andP;  A rectangle is a special kind of polygon(see Figure 4).andP;  This relationship is easily captured by the inheritancerelation.andP;  When rectangle inherits from polygon, rectangle gets all thefeatures of a polygon.andP;  In addition, a polygon is a closed figure and sorectangle also inherits all the features of a closed figure.andM;Yourdon advised capturing this classification structure explicitly during theanalysis phase.andP;  If a software system is developed using object-orientedanalysis, object-oriented design, and implemented in an object-orientedprogramming language, then objects and classifications identified duringanalysis are preserved and enriched during design, and are directlyimplemented in code.andP;  We believe this ability to capture and encapsulateabstraction directly in code represents a major breakthrough in softwaretechnology.andM;At the highest level, all figures in a graphics system have a pixel width andcoloer and the property of being able to be scaled, rotated or drawn.andP;  Theseproperties are defined in the root class &quot;Figure.&quot;andP;  Closed figures have, inaddition, a perimeter and an area.andP;  Polygon adds the attribute&quot;number_of_sides.&quot;andP;  Thus, a rectangle has, by inheritance, a pixel width,scaling procedure, calculate_area function, etc.andP;  Some of these features canbe inherited as is, others should be modified as they are inherited.andP;  Theset_pixel_width as defined in the figure class may be appropriate forrectangles &quot;as is&quot; but the calculate_area procedure should be redefined togive a more efficient implementation.andM;In an object-oriented graphics system, inheritance minimizes the incrementaleffort of adding a new graphics primitive.andP;  In the same manner, theobject-oriented approach with inheritance facilitates rapid prototyping.andM;The real appeal and power of the inheritance mechanism is that it allows theprogrammer to reuse a class that is almost, but not exactly, what he wants,and to tailor the class in a way that does not introduce unwanted sideeffects into the rest of the class.andP;  Furthermore, the object paradigm focuseson identifying and encapsulating commonality in higher level abstractions.andO;If these higher level classes are accumulated in a software repository inwould eventually be quite likely that for almost any desired class, ageneralization of that class would already exist in the software repository.andM;PolymorphismandM;There are many kinds of polymorphism [3], but in general polymorphism meansthe ability to take more than one form.andP;  In an object-oriented language, apolymorphic reference is one that can, over time, refer to instances of morethan one class.andP;  Because of this ability to refer to more than one class ofobject, a polymorphic reference has both a dynamic and a static typeassociated with it.andM;The dynamic type of a polymorphic reference may change from instant toinstant during the program execution.andP;  In strongly typed object-orientedenvironments, the run-time system keeps all polymorphic referencesautomatically tagged with their dynamic type.andM;The static type is determined from the declaration of the entity in theprogram text.andP;  It is known at compile time and determines the set of validtypes that the object can accept at runtime.andP;  This determination is made froman analysis of the inheritance graphs in the system.andM;The &quot;is a&quot; nature of inheritance is tightly coupled with the idea ofpolymorphism in a strong typed object-oriented language.andP;  The idea is that ifY inherits from X, Y is an X, and therefore anywhere that an instance of X isexpected, an instance of Y is allowed.andM;Figure 5 provides an outline for discussion.andP;  After execution of statement 1,the static type of x is X and the dynamic type of x is X.andP;  After statement 4,the static type of x is still X but its dynamic type is now Y.andM;A more realistic example will help to clarify the use and importance of thisconcept.andP;  In a graphics system we may want the ability to perform some action(such as scale or rotate) on all currently displayed figures.andP;  It wouldfacilitate this operation if a list of all displayed figures were available.andM;Referring to the inheritance diagram of Figure 4, one can see that thevariable &quot;current_figures: ARRAY [Figure]&quot; provides just what is needed.andO;Since Figure is an ancestor of Circle, the Eiffel type system knows thatCircle is a Figure and allows the assignment: current-figures.put(C1:1);{where C1 is an object of type Circle).andP;  After this assignment the statictype of current figures .item [1] would still be figure, but its dynamic typewould be &quot;circle.&quot; Likewise, the elements 2...n of the array could beSquares, Lines, or any other graphics primitive.andM;Dynamic BindingandM;The binding referred to in this section is the binding of a procedure call tothe code to be executed in response to the call.andP;  Dynamic binding means thecode associated with a given procedure call is not known until the moment ofthe call at runtime.andM;In the object-oriented world, dynamic binding is associated with polymorphismand inheritance in that a procedure call associated with a polymorphicreference may depend on the dynamic type of that reference.andM;Suppose x is a polymorhic reference whose static type is X, but whose dynamictype may be X or Y.andP;  Suppose further that the procedure &quot;do_it&quot; is anoperation defined in X but redefined in Y as a part of the inheritancemapping.andP;  The call x.do_it now depends on the dynamic type of x.andP;  If itsdynamic type is X, as in statement 3 of Figure 5, the call will be bound tothe code defined in class X.andP;  If its dynamic type is Y, as in statement 5 ofFigure 5, the call will be bound to the code as redefined in class Y.andM;The graphics example, continued below, will illustrate the usefulness of thisconcept.andP;  In the next section we elaborate onthe benefits of this conceptrelative to extensibility.andM;Suppose the class &quot;Figure&quot; in Figure 4 contains the procedure &quot;draw&quot; (withperhaps a null implementation).andP;  By inheritance, every graphics primitive inFigure 4 will have a procedure draw.andP;  The draw algorithm is, however, uniqueto each graphical shape, and so the draw procedure will be redefined in eachclass that defines a graphic primitive.andM;Returning to the polymorphic array of the previous section, one can now seethe usefulness of polymorphism combined with dynamic binding.andP;  To redraw theentire graphics window the following code would suffice: For i: = 1 toNumber_of_ Shapes do current_figures.item(i).draw;andM;At each pass through the loop, the code matching the dynamic type ofcurrent_figure.item(i) will be called.andP;  Note that if additional kinds ofshapes are added to the system, this code segment remains unchanged.andO;Contrast the resulting simplicity and extensibility as compared with atraditional case statement design.andM;Basic Design ConceptsandM;This section presents the fundamentals of the object-oriented design phase ofthe object-oriented software life cycle.andP;  For a reference pointobject-oriented design is compared to the procedural design paradigm(top-down functional decomposition).andP;  The designs produced using theobject-oriented paradigm are measured against a set of qualities ofwell-designed software.andM;A Different Point of ViewandM;Most computer professionals know the syntax of several programming languages.andO;Most know several diagramming techniques for representing design details.andO;Yet most know only one approach to system design.andP;  It is perhaps harder tolearn a new system development technique than it is to learn a new language.andO;This is because learning a language involves memorizing a few keywords andtheir valid arrangements while learning a new system development techniquerequires a fundamental change in our way of thinking.andM;A design paradigm is characterized by its view of the decomposition process.andO;The procedural paradigm takes a task-oriented point of view, which begins itssupport for the design process when a solution to the target problem isproposed.andP;  The proposed solution is decomposed by breaking it into a sequenceof tasks.andP;  These tasks form the basic building blocks for a proceduralapplication.andP;  Information developed as part of the analysis process serves asinput into the design phase but it is in a different terminology andrepresents a different perspective from the design phase.andP;  For this reason,the traditional view of an application life cycle includes what may be anunnecessary boundary between analysis and design.andP;  This boundary results froma shift from the problem domain in analysis to the solution domain in design.andM;The object-oriented design paradigm takes a modeling point of view.andP;  Theanalysis and design phases of the traditional life cycle, while remainingdistinctly separate activities in the object-oriented life cycle, worktogether closely to develop a model of the problem domain.andP;  The model isconstructed by viewing the problem domain as a set of interacting entities.andO;The software-based models of entities and the relationships between them areassembled to form the basic architecture of the application.andP;  The informationdeveloped in the analysis phase becomes an integral part of the design ratherthan simply providing input into the phase.andP;  This smooth transition isfacilitated by the homogeneity of the &quot;pieces&quot; being used by each process.andO;As discussed in Coad and Yourdon [4] this homogeneity is in stark contrast tothe difference in point of view between Structured Analysis and StructuredDesign.andM;The pieces produced by the procedural design paradigm are procedures thatperform tasks.andP;  These pieces are artifacts of the design process and relateto the proposed solution.andP;  The pieces produced by the object-orientedparadigm are entity descriptions, classes.andP;  Many of these descriptions can berelated back directly to the original problem.andP;  Although many of the classesdo not represent physical objects, they are conceptual entities which can bestated in the terminology of the problem domain.andM;An Example for ComparisonandM;Consider an example that will illustrate the different points of view of theprocedural and object-oriented paradigms.andP;  Figure 6 presents an abbreviatedstatement of requirements for a software system which would control thetraffic lights at the intersection of two streets.andP;  The application wouldhave software interfaces to the hardware pieces like the car sensors and thetraffic lights.andM;The procedural paradigm approaches the development of the trafficintersection control system by considering the sequence of tasks that must beperformed.andP;  A functional decomposition of the proposed solution provides aset of tasks such as those in Figure 7.andP;  This hierarchy chart illustrates theprocess of step-wise refinement.andP;  Each layer in the hierarchy represents theidentification of more detailed functionality.andP;  The tasks are sequenced byreading from left to right across the chart.andM;The object-oriented paradigm approaches systems development by identifyingthe entities that are present in the problem.andP;  The physical entities involvedin this problem include the sensors, traffic lights, and the controller.andP;  Theparadigm is not limited to physical entities.andP;  For this problem, onenon-physical entity that can be identified is a &quot;lane&quot; entity.andP;  This entityassociates a sensor with a particular traffic light.andP;  The lane entity bridgesbetween the problem domain and the solution domain.andP;  It is named anddiscussed in the terminology of the problem, but may arise either throughviewing the problem or the implementation of the controller which must haveinformation about which light is associated with which sensor.andM;Abstractions of the entires will become the classes that form the foundationof the system.andP;  The specifications for these classes will supplement theinformation from the traditional requirements document.andP;  The object-orientedrequirements document uses objects and classification to blend traditionalanalysis information about the required systems functionality withdescriptions of the objects it manipulates.andP;  The systems specifications areuseful to both the designers and users.andM;To the latter because the descriptions are not pieces of a solution butpieces of the problem.andM;To the former because the design will retain and build directly upon theobjects identified during analysis, and this facilities communication betweenusers and designers since users are better able to relate to the problem thanto the computer-based solution to that problem.andM;The entities identified above and several others are illustrated in Figure 8.andO;This figure uses an entity-relationship diagram to present the entitiesd andthe relationships between them.andP;  The diagram is the representation of asemantic data model of the problem.andP;  A semantic data model is so namedbecause it allows representation of a broader range of information than otherdata models suchas the relational model.andP;  Peckham and Maryanski [8] provide asurvey of several semantic data models.andP;  Other techniques have been proposedfor capturing this information (e.g., Wirfs-Brock [28]).andM;A comparison of the information in Figures 7 and 8 illustrates the differencein points of view of the two paradigms.andP;  Neither technique concentrates onone type of abstraction to the exclusion of all others.andP;  The proceduralparadigm, while giving priority to procedural abstraction, must consider thestructures necessary for data representation at some level in the designprocess.andP;  Likewise, the object-oriented paradigm may use functionaldecomposition in designing the operators needed to manipulate an object.andM;The object model supports the complete software development life cycle.andO;Beginning in the requirements phase, objects are identified.andP;  By developingspecifications of the entities found in the problem domain a clear andwell-organized statement of the problem is actually built into theapplication.andP;  These objects form a high-level layer of definitions that arewritten in the terminology of the problem domain.andP;  During the refinement ofthe definitions and the implementation of the application entities, otherentities, or classes, are identified.andP;  Figure 9 illustrates the layers ofobject specifications that result from this process.andM;The object-oriented analysis and the object-oriented design phases work moreclosely together because of the commonality of the object model.andP;  In onephase the analyst identifies problem domain objects while in the next phase,the designer specifies additional objects necessary for a specificcomputer-based solution.andP;  The design proces is repeated for theseimplementation-level objects.andP;  The position of object-oriented design in thesoftware development process is further detailed in the paper byHenderson-Sellers [9] appearing in this special issue.andM;entitiesandM;Object-oriented design is first concerned with entities--things.andP;  Thesethings may be tangible objects such as traffic lights, chairs, or airplanes.andO;The entities may be abstract concepts such as roles, interactions, orincidents.andP;  For example, an airplane and a pilot are tangible objects butthese two entities may be bound together by the incident of a flight.andP;  Theflight is also an entity which has a state that describes the particularairplane and the particular pilot as well as passengers, cargo, etc.andM;RelationshipsandM;The relationships between entities are the incaractionsthat occur betweenobjects in the problem space.andP;  A pilot flies an airplane.andP;  Flies is onerelationship between pilot and plane.andP;  This relationship is anapplication-level relationship and is expressed in the terminology of theproblem.andP;  Two entities may have more than one relationship between them.andP;  Thepilot is_in_command_of the airplane.andP;  An entity may have relationships withseveral other entities.andP;  The pilot is_employed_by the airplane.andM;An important design relationship in the object-oriented paradigm is theinheritance relation.andP;  In order to describe a class of pilots, the designermight wish to begin with the description of class person.andP;  Using theinheritance mechanism, all the behavior and attributes of a person would beadded to the pilot class definition.andP;  Linking two classes via the inheritancerelationship means that future improvements to the person class will becomeimprovements to the pilot class automatically.andM;A second design relationship in the object-oriented paradigm is the componentrelation.andP;  The description of person probably includes a name attribute.andO;This attribute can be provided by declaring an instance of the string classin the definition of person.andP;  This instance of string is a component of theperson class definition.andM;The distinction between these two relationships is an important one.andO;Inheritance represents a specialization of the existing definition.andP;  That is,a pilot is a special kind of person, one who flies planes, but is still aperson.andP;  A component is used to provide a service in the implementation of aclass.andP;  A person is not a special kind of string.andP;  The instance of string isused to represent an attribute of person, not to define what a person is.andO;The characteristics of a person become part of the characteristics of a pilotwhen added by inheritance, while the characteristics of a string are hiddenin the implementation of a person.andM;Complete Data ModelandM;Object-oriented design has two separate components which must be blended inthe development of an application: class design and application design.andO;Class design is &quot;wrapped inside&quot; of application design.andP;  The design of anapplication includes the identification of the kinds of entities in theproblem domain plus those specific to implementing the solution such as menusystems or pointing devices.andP;  Each kind of entity leads to a classdescription which should be a complete model of one concept.andP;  Once thesedescriptions have been developed, the application can be designed.andP;  Theapplication is developed by connecting instances of the classes--modeling thereal world so that they interact with each other resulting in a problemsolution.andM;The class descriptions include three parts: definitions of attributes,description of the class interface, and the set of valid transitions betweenthe possible states for an instance of the class.andP;  Consider the design of astack class.andP;  Figure 10 shows the three parts of the class design.andP;  Part (a)of the figure shows that the data attributes for the stack class include adata store for the items contained in the stack and some means of locatingthe top, or visible, item in the stack.andP;  Part (b) gives the public interfaceof the class.andP;  Part (c) uses a state diagram to illustrate the sequence ofvalid states for the class.andP;  This diagram not only provides information aboutthe states of the class, it provides constraints on the sequence of use ofthe operators from the class interface.andM;The pattern of interaction between instances of the classes provides thestructure of the application.andP;  These interactions are models of therelationships between the classes.andP;  These relationships are modeled in one ofseveral ways but they all involve messages.andP;  A message is a communicationbetween two objects.andP;  The messaging may be either synchronous or asynchronousdepending upon the execution model chosen.andP;  An object may send a message toany other object whose identity is available.andP;  The message can correspond toany operator in the public interface of the receiving object.andP;  The receivingobject may be an object at the same design level or it may be one that isdeclared as part of the implementation of the sending object.andM;Semantic data modeling provides support for developing a complete data modelof an application which incorporates both high-level applicationrelationships and low-level class definition relationships.andP;  Figure 11provides an entity-relationship diagram that illustrates the pieces of thepilot/plane application used above.andP;  All the entities and the relationshipsbetween them can be captured in this one model.andM;Thus, the development of an object-oriented application is a blend of classdescription and application configuration.andP;  Much of the process is guided bythe real-world problem domain rather than our view of the problem solution.andO;This results in an application design that, at a high level, contains a modelof the problem domain.andP;  The application design process begins at a top leveland proceeds through class identification to a low level and then movesupward as low-level classes are designed based on lower-level definitions.andM;Support for Good DesignandM;Modularity.andP;  The object-oriented paradigm provides natural support fordecomposing a system into modules.andP;  In this paradigm classes are the modules.andO;This means that not only does the design process support modularity, but theimplementation process supports it as well through the class definition.andO;Figure 12 illustrates a class definition for the pilot class.andM;Classes as module represent a fine-grained approach to system composition.andO;Others have proposed a more coarse-grained approach.andP;  Meyer [15] defines acluster as a set of classes that are conceptually related.andP;  This cluster ofclasses is a natural grouping to consider because an application, whichincludes a class representation of a concept, will usually need to includeinstances of a set of classes in order to fully implement the concept.andO;Wirfs-Brock [29] defines a subsystem grouping and the work of Johnson,reported in the Wirfs-Brock article describes frameworks as other approachesto grouping classes.andP;  These groupings collect classes which as a group forman abstraction.andP;  For example, the concept of a linked list might berepresented by three classes: a class that is the list itself; a class thatdescribes the links; and a class that defines iterators for the list.andO;Individually the classes are not very useful but together they provide thedesigner with a commonly used abstraction.andM;Information Hiding.andP;  The class construct supports information hiding throughthe separation of the class interface and the class implementation.andP;  Theseparation allows the class interface (i.e., specification) to be mapped toseveral different implementations.andP;  It also allows much maintenance activityto be hidden from users of the class.andM;This separation is in parallel to the design activity of separating thebehavior of an object from the attributes of the object.andP;  The operators inthe public interface represent the possible behaviors of the object.andP;  One ofthe responsibilities of these operators is to provide for the controlledaccess to the attributes of the object.andP;  The representation of theseattributes and the corresponding implementation of the operators should behidden from users of the class.andM;Figure 12 illustrates a usual division between public interface and privateimplementation.andP;  The interface operator tell_age hides the fact that theoperator uses the person's date_of_birth and the system date as the basis foranswering the request.andP;  In this case, the object's attribute age has beenmapped to a representation using date_of_birth and associated operators tocalculate current age.andM;Weak Coupling.andP;  Classes are designed as collections of data and the set ofallowable operations on that data.andP;  Therefore, the interface operators of aclass are inward-looking in the sense that they are intended to access ormodify the internal data of the class.andP;  This leads to fewer connectionsbetween classes.andM;Interactions between classes come from two sources.andP;  The componentrelationship discussed previously results in a coupling between the twoclasses.andP;  If an instance of class A is declared within the implementation ofclass B, then instances of class B contain an instance of class A in theirimplementation.andP;  Operators of class B send messages to (invoke the interfaceoperators of) the instance of class A.andP;  In Figure 12, the name attribute isan instance of the string class.andP;  Person's print_name operator would carryout its task by sending a message to the name instance to print.andM;Interface functions of a class may take as parameters instances of anotherclass.andP;  This coupling assumes the instance parameter will either provideinformation for the operation of that function or the instance will bemodified by having one of its interface functions invoked.andM;Strong Cohesion.andP;  A class is a naturally cohesive module because it is amodel of some entity.andP;  Object-oriented style guidelines require that for afunction to be a member of a class it must either access or modify datadefined within the class.andM;The inheritance mechanism could be viewed as weakening the cohesion of themodule.andP;  The data and functions inherited from another class form a naturalgroup separate from those data values and functions defined within the newclass.andP;  However, the ultimate test of cohesion is met by the fact that allthese pieces are brought together to represent one concept.andM;Abstraction.andP;  Liskov and Guttag [12] present two methods of abstraction:abstraction by specification and abstraction by parameterization.andO;Object-oriented languages support both of these methods to varying degrees.andM;Abstraction by specification abstracts the specification of an entity fromits implementation.andP;  This type of abstraction is supported by virtually everyobject-oriented language.andP;  The public interface of a class constitutes thespecification of that class.andP;  The interface specifies the legitimateoperators of the data contained in instances of the class.andP;  In mostobject-oriented languages, the implementation of these operators and theexact representation of the class's data elements are hidden from access ifnot from the view of those outside the class definition.andM;Abstraction by parameterization abstracts the type of data to be manipulatedfrom the specification of how it is to be manipulated.andP;  This type ofabstraction is supported by most object-oriented languages at the operatorlevel but by only a few languages at the class level.andP;  Eiffel, for example,allows a class definition to be parameterized.andP;  Consider the definition of astack class.andP;  The class can be totally specified without regard to the typeof the items to be &quot;stacked.&quot;andP;  The type of the items can be identified atcompile time through the use of a parameter.andP;  Figure 13 shows a parameterizedclass definition in Eiffel syntax.andP;  This type of abstraction is only ofinterest in a typed-language environment.andM;Extensibility.andP;  The object-oriented paradigm produces designs that are easilyextended.andP;  The inheritance mechanism supports extending designs in two ways.andO;First, the inheritance relation facilitates the reuse of existing definitionsto ease the development of new definitions.andP;  As the inheritance structurebecomes progressively deeper, the amount of specification and implementationinherited by a new class definition grows.andP;  This usually means that as theinheritance structure grows, the amount of effort to develop a new classdecreases.andM;Second, the polymorphic property of the typing system in object-orientedlanguages also supports extensible designs.andP;  Figure 14 shows a simpleinheritance hierarchy.andP;  Consider the operator x, shown in Figure 15, thattakes an instance of class A as a parameter.andP;  The polymorphic behavior ofobject-oriented typing systems allows the substitution of instances ofclasses B, C, D, E, or F as the actual argument to operator x.andM;This polymorphic property supports the extension of existing systems in thefollowing way.andP;  Assume further analysis reveals another specialization, G,would provide the new feature needed by the current application.andP;  Instancesof this new class can be used as actual arguments to operator x even thoughthe class G had not been thought of before the x operator was designed.andP;  Thusa new feature is added with little or no modification to the remainder of theapplication.andM;Integrable.andP;  The object-oriented design process produces designs whichfacilitate the integration of individual pieces into complete designs.andP;  Thenarrow clearly defined interface of a class supports integration with othersoftware components.andP;  The set of allowable operations and their requiredparameters are easy to identify.andP;  The narrow interface corresponds naturallyto the observable behaviors of the real-world entity modeled by the class.andO;The interfacing of two classes then is a model of the natural interactions ofthe two entities.andM;Objects are also very integrable at the implementation level.andP;  Theencapsulation provided by a class hides the implementation details from theremainder of the system.andP;  The hiding of data declarations, function-namingconventions, and complex control flows prevents interactions.andP;  Thus,integration of prewritten components is much less likely to requiremodification of existing code in either component.andM;Support for ReuseandM;The object-oriented paradigm combines design techniques and language featuresto provide strong support for reuse of software modules.andP;  The reuse comes ina variety of forms.andP;  Some of the reuse in the object-oriented paradigm ismuch the same as that in the procedural paradigm but the object-orientedparadigm adds an additional type of reuse.andM;Every time an instance of a class is created, reuse occurs.andP;  This is similarto the declaration of a variable of a specific type.andP;  The major difference isthat the resulting class instance is a much more complex structure than asimple variable.andP;  An instance of a class provides a combination of datastructures and operators on those data structures.andP;  Declaring the instance ofthe string class to represent the name attribute in the pilot class is anexample of this type of reuse.andP;  Using an instance of the string classprovides operators for copying, concatenating, and, perhaps, even editing thestring value.andM;Inheritance provides two levels of support for reuse.andP;  As part of thehigh-level design phase, inheritance serves as a means of modelinggeneralization/specialization relationships.andP;  These relationships appear inthe form of classifications.andP;  A chair may be viewed as a special type offurniture as well as a general description of the more specific categories ofrocking chairs, straight chairs, and reclining chairs.andP;  This high-level useof inheritance encourages the development of meaningful abstractions which,in turn, encourages reuse.andM;Often in actual design the presence of mid-level abstractions such as tableand chair will be recognized and considered separately.andP;  The availability ofan inheritance relation enables the designer to &quot;push higher&quot; and to identifycommonality among abstractions and to produce higher-level abstractions,(e.g., furniture), from this commonality.andP;  By identifying this commonalityand removing it to a higher abstraction, it becomes available to be reusedlater in the current design or in future designs.andP;  Filing cabinets andbookcases may be identified later.andP;  Much of their description (attributessuch as height, weight, color, etc.), may already be available from thefurniture abstraction.andP;  The benefits of this reuse prompt the designer tosearh for higher and higher levels of abstraction.andM;In the low-level design phase, inheritance supports the reuse of an existingclass as the basis for the definition of a new class.andP;  An existing piece ofcode can be copied to a new file and modified to fit its new purpose.andP;  This&quot;editor inheritance&quot; does not establish any connection between the old pieceof code and the new code.andP;  If a bug is discovered in the old code andrepaired, knowledge of this change may or may not reach the personresponsible for the new code.andP;  Inheritance provides an important improvementin this process.andM;Inheritance establishes a dependency between the existing class and the newclass.andP;  This technique is nonintrusive in that the existing code is notmodified.andP;  The new code in the subclass can not cause the existing code to&quot;break.&quot;andP;  The inherited code is included in the new definition automaticallyas the new class definition is compiled.andP;  Any modifications to the originalclass, bug fixes or feature additions, are incorporated into the newer classat the next compilation.andP;  This technique allows a class to serve as the basisfor many new definitions without propagating the errors of the originaldefinitions throughout the system.andM;Much research focuses on support for reuse.andP;  Several of the research effortspresented in Wirfs-Brock [29] include consideration of reuse.andP;  Reenskaug'swork with Role Models and Johnson's work with Frameworks address the need forconceptual groupings of classes.andP;  As libraries of classes grow very large,locating the classes that are needed to represent a given concept becomes adifficult task.andP;  These conceptual models associate classes forming largermore readily recognized groupings.andP;  Lieberherr's work on the Law of Demeterapproaches reuse from the point of view of the interactions between classes.andO;The Law addresses the allowable dependencies between classes.andP;  For example,it explicitly eliminates the direct access by one object of another object'simplementation.andP;  This reduces the number of dependencies between classes,increasing the design's flexibility.andM;Software BaseandM;The set of classes together with the application and implementationrelationships between them form a reusable resource for the designer whichhas been referred to as a software base.andP;  This software base further promotesreuse by overcoming one of the real-world obstacles to reuse: finding theappropriate class.andM;Large companies have communications problems.andP;  How, in a company of 5,000designers, can information about existing resources be shared?andP;  The followingsection on development environments discusses tools that facilitate thelocation and use of specific classes.andP;  The article by Gibbs et al [6] in thisissue discusses the problem of class management.andM;Design GuidelinesandM;In any object-oriented application, instances of classes make up the majorityof the system and, if a pure object-oriented approach is used, all of thesystem consists of instances of classes.andP;  Therefore the design of theindividual classes has a major impact on the overall quality of theapplication.andP;  In this section a set of guidelines is presented for the designof classes.andP;  The intent is to illustrate the factors which should beconsidered when designing a class without discussing each guideline indetail.andP;  Figure 16 presents the list of guidelines which are brieflydiscussed below.andM;The first four guidelines address the proper form and use of the classinterface.andP;  The information hiding required by the first guideline reinforcesthe development of representation-independent designs.andP;  This encapsulation isfurther specified in the second guideline which prohibits accessing classinstances used as part of the representation of this class.andP;  These guidelinesenforce the idea that a class is characterized by its set of operations andnot by its representation.andP;  The third guideline defines the public interfaceas containing the complete set of public operations on the representation ofthe class.andP;  &quot;Helper&quot; functions are deferred to the protected area in a classdefinition.andP;  The fourth guideline requires that to belong to the class, eachoperator must represent a behavior of the concept being modeled by the class.andO;Together these four guidelines give the designer directions for developingand separating the class interface and the class representation.andM;The second four guidelines consider the relationship of this class to otherclasses.andP;  Guideline number five constrains the designer to link a class witha few other classes as possible.andP;  If a class being designed will need many ofthe services of another class, perhaps that functionality should be part ofthe representation of the new class.andP;  The sixth guideline is intended toreduce, and perhaps eliminate, global information.andP;  Any information needed byone class should be explicitly passed to it in a parameter from anotherclass.andP;  Guideline number seven prohibits the use of inheritance to developthe representation of a new class rather than its interface.andP;  The preferredmethod for utilizing an instance of a clas as part of the representation ofanother class is to declare an instance of the supporting class in therepresentation of the newly designed class.andP;  Finally, the last guidelineencourages the designer to develop inheritance structures of classes whichare specializations of an abstraction.andP;  These abstractions lead to morereusable subclasses and to clear-cut differences between the subclasses.andO;Articles by Johnson and Foot [10] and Lieberherr and Holland [11] expand oneach of these guidelines.andM;Software DesignandM;and DevelopmentandM;EnvironmentsandM;The object-oriented design process produces a large number of softwarecomponents that are interconnected by a network of relationships.andP;  Use of theobject-oriented paradigm relies much more heavily on the use of supportingtools and environments compared to procedural design techniques.andP;  Thissection presents information about some existing support systems andconsiders how these systems may look in the future.andP;  Many of the features ofsupport systems discussed here are not limited to the object-oriented domain,but characteristics of object-oriented design make particularly good use ofthe support provided by such an environment.andM;Conceptual ToolsandM;We have already described a number of conceptual tools for object-orienteddesign.andP;  We will summarize them briefly and include others that have not beenexplicitly discussed previously in this article.andM;Generalization/Specialization.andP;  These closely related concepts provide muchof the power of the object-oriented paradigm.andP;  Specialization guides thedesigner in the reuse of an existing abstraction by defining a new class thatis more specific than the existing class.andP;  The specification of the new classincludes the specification of the existing class as a proper subset.andO;Generalization supports the exploitation of commonalities between classes.andO;When two or more classes are representing overlapping sets of attributes, thecommon attributes may be factored out of both classes and used to create anew class.andP;  The new class then becomes the superclass for those previouslyoverlapping classes.andP;  The inheritance mechanism of an object-orientedlanguage implements both of these tools.andM;Specialization does not require any modification of existing definitions.andO;The new definition simply includes a reference to the existing one.andO;Generalization usually does require modification of existing definitions.andO;The definitions and declarations that are common among the classes areremoved to a new higher-level definition.andP;  The inheritance mechanism thenmakes these pieces in the new high-level definition available to thedefinitions at the lower levels.andM;Components.andP;  One class may be used as part of the representation of anotherclass.andP;  This type of reuse of design simply looks for a class that alreadyrepresents some subset of the attributes of the new class.andP;  An instance ofthis class can then be used to provide that representation.andP;  Instances ofseveral classes may provide much of the representation of a new class, makingits realization a relatively quick process.andM;Contracts.andP;  This is a device defined in Wirfs-Brock [29] and Meyer [14] todescribe the division of responsibility between two classes that interact.andO;The contract specifies what capabilities one class will provide and what theother class can expect to receive when requesting one of the capabilities.andO;The client/server model is a type of contract that has been used to groupcapabilities even in the procedural paradigm.andM;Clusters/Subsystems/Frameworks.andP;  Each of these concepts is a technique forrecognizing sets of classes that are conceptually related.andP;  It is oftenlogical to divide the representation of a concept among several classes.andO;Some of these subconcepts may be of use in the development of other concepts.andO;In the above example of the linked list, by separating the list iterator intoa separate class, we are able to have multiple iterators on the same list atthe same time.andM;No syntactic unit exists that indicates this relationship.andP;  This is the mostimportant place to apply a tool for support.andP;  The designer should be able todesignate clusters in the software base.andP;  If a user calls up the linked listclass, the environment should be able to inform the user that these otherclass are probably of interest as well.andM;These conceptual tools are very useful in the design process.andP;  They provideguidelines for the design and direction for the designer.andP;  Most existingdevelopment environments require that the designer be responsible forrespecting the guidelines presented by these conceptual tools.andP;  A set ofsoftware tools that supports the use of these conceptual tools is needed.andO;The work of Lieberherr reported in Wirfs-Brock [29] is one effort to developtools that include a policy for design.andM;Levels of AccessandM;The reuse of software components is a strong feature of the object-orientedparadigm.andP;  This reuse will only take place if there are good tools whichadapt to the various ways that classes are used.andP;  These tools will providethe designer with access to the class definitions, implementations, andstructures of the software base.andP;  For our purposes, three levels of access toa class definition can be identified:andM;Access for generating instances.andP;  Users often reuse an existing class bycreating instances of the class for an application they are designing.andO;Accessing a class for this purpose requires that the designer have access tothe public interface of the class.andP;  However, it should be the completeinterface.andP;  That is, the attributes that are inherited from superclasses upthe inheritance structure should be presented as part of the completeinterface.andP;  A design environment should be capable of combining informationfrom multiple class specifications to present to the class user.andM;Access for creating new subclasses.andP;  Users accessing a class in order to useit as the basis for a new class definition may need more information thanthose users simply creating instances from the definition.andP;  In particular,some languages give operators written in the subclass access to some or allof the data or protected operators declared in the superclasses.andM;The person creating the subclass may need to see the data declarations aswell as the interface for the class(es) being accessed.andP;  Some of this &quot;data&quot;are actually instances of other classes declared as part of therepresentation of the current class.andP;  This implies that the user may needaccess to definitions for these classes to fully understand how a classfunctions.andM;Access for maintaining the class.andP;  Users accessing a class, in order torepair or extend it, need the maximum amount of information.andP;  Information isneeded on all of the following: the interface, the representation, and theimplementation.andP;  The environment should allow for wide-ranging browsing thatlets the user select an operator to be edited, a data declaration to beexamined, or a relationship to be followed.andP;  The environment should provideintegrated editing and as much static checking as possible.andM;Existing ToolsandM;Tools for design.andP;  A number of design tools are available which facilitatesome part of the object-oriented design process.andP;  These tools can be dividedinto two categories: those that provide high-level design tools and thosethat assist with low-level design.andP;  No commercial tool that we are aware ofsupports both the development of a high-level design and takes that design tothe lower levels of development.andP;  The work of Reenskaug reported in theresearch survey of this special issue [29] is an attempt to develop amethodology for the complete life cycle.andM;Tools such as Excelerator from Index Technology support the development ofEntity-Relationship Diagrams.andP;  The Entity-Relationship Model is one of thesemantic data models mentioned previously.andP;  An E-R Diagram provides a veryflexible framework in that it can capture any relationship that existsbetween classes.andP;  Excelerator provides an integrated data dictionary whichallows much information about the classes and the relationships to be stored,managed, and manipulated.andP;  A number of other existing computer-assistedsoftware engineering (CASE) tools support the development of the E-Rdiagrams.andM;Most of these tools do not &quot;understand&quot; the object-oriented paradigm.andP;  Thatis, they do not treat the application-specific relationships such asis_employed_by, any differently than the paradigm-specific relationships suchas inheritance.andP;  It is the designer's responsibility to differentiate betweenthe relations.andP;  While a tool dedicated to the paradigm can provide moreintelligent support and &quot;critique&quot; the design as it progresses, a moregeneral tool can support multiparadigm integration of systems.andM;Interactive Development Environments, Inc. has developed and markets aproduct which supports a variant of the object-oriented paradigm.andP;  Theirdesign technique, reported in [26], is termed Object-Oriented StructuredDesign (OOSD).andP;  OOSD incorporates the features of object-oriented design withthe functional approach of Structured Design.andP;  It is beyond the scope of thisarticle to present a detailed critique of this methodology but the automateddesign tool, Software Through Pictures, developed to support their work isone example of a useful design tool.andM;Software Through Pictures provides a range of CASE tools.andP;  A series ofeditors provides the designer with the popular graphical notations: E-Rdiagrams, Data Flow diagrams, and a data structures editor which supportsJackson hierarchical data structures.andP;  The environment also supportsautomatic documentation and data dictionary facilities.andP;  All facilities areintegrated and information entered in one tool is accessible in others.andM;The designs developed in Software Through Pictures can be &quot;brought to life&quot;using the automatic code generation facilities.andP;  Unfortunately, the productdoes not support generation in any object-oriented language.andP;  It does providecode generation in Ada, C, and Pascal.andP;  The code is not managed ormanipulated by the environment.andP;  Because the system does not providelow-level design support, the designer has very little control over the codethat is generated.andM;Tools for implementation.andP;  A number of languages are accompanied by toolkitswhich support the low-level design and implementation process.andP;  Smalltalkprovides an integrated environment which combines a class browser, editor,and compiler.andP;  The class browser treats each class discretely and does notpresent the complete interface of a class.andP;  The browser does provide astructured list which shows the class inheritance structure.andP;  Whilenavigating the class inheritance structure, a class may be selected, viewed,and modified in the integrated editor.andP;  When the designer completes theediting process, a pop-up menu in the editor window allows the new code to beimmediately checked compiled, and linked into the system.andP;  Development of asimilar system for C++ (minus the compiler), has been reported in [20].andM;Tools of the FutureandM;The two design environments described above are passive graphics editors inthe sense that they record what the designer enters and display theinformation when needed.andP;  The language toolkit discussed in the same sectionis more active but does not include capabilities for high-level designfunctions.andP;  The useful tools of the future will integrate high- and low-leveldesign processes.andP;  The tools will provide intelligent support for the designparadigms being used and will be an active &quot;assistant&quot; to the designer.andM;At a high level, in the object-oriented paradigm, this means support forrecognizing and recording the relationships that exist between entities inthe problem space.andP;  These relationships represent the interactions betweencomplex entities and as a result are infinite in variety.andP;  This requires theflexible approach of the entity-relationship semantic data model that allowsuser-defined relations rather than a limited number of &quot;standard&quot; relations.andO;The result at this level is a complex structure of dependencies.andP;  Manyenvironments allow the designer to draw this class/application structure inthe form of E-R diagrams or some other notation and retain only theattributes of the picture rather than the interconnections.andP;  This isinsufficient.andP;  The tool should provide a representation for this structurewhich can be the basis for active manipulation.andP;  Baldassari et al.andP;  [1]present a CASE tool which uses a variant of Petri nets to provide thiscapability.andP;  PROTOB is directed at distributed systems but provides a hint ofwhat a general-purpose tool should include.andM;The concept of a software base [24, 25] of reusable components will requirethe support of a comprehensive set of tools.andP;  These tools should provide theuser with a software base navigator that can follow any of the relation linksdeveloped between classes.andP;  Such a tool must be very general because therelationships present in an object-oriented design span fromapplication-oriented relationships to standard relationships such asinheritance.andM;The toolkit should include low-level tools which operate on both the classesand the relationships between them.andP;  This includes the &quot;hierarchy flatteners&quot;described above as well as in-line editors and syntax checkers.andP;  All of thesetools should be incorporated into the overall environment.andM;The existing tools for object-oriented design are inadequate.andP;  A number ofsimple tools assist in recording design decisions but these tools do notfacilitate the design decisions themselves.andP;  Although the object-orientedparadigm simplifies the solution of complex problems, a comprehensive set oftools will greatly assist the designer.andM;Implementing an Object-Oriented DesignandM;The software community has long realized that iteration is inherent in thesoftware life cycle.andP;  Since the software development team will be constantlymoving back and forth across the different phases, the joints between what wehave traditionally called analysis, design and implementation should beseamless.andM;Therefore it is important to have object-oriented languages and developmentenvironments that directly support the object-oriented design paradigm andthat make a smooth transition between design and implementation.andM;The object-oriented design paradigm exists independently from any specificimplementation environment, and yet there are implementation issues thataffect the design as well as the development process.andP;  This section exploressome of these implementation issues.andP;  In addition, the sidebars by Jordan andKilian provide case studies on the implementation decisions taken by twomajor object-oriented languages: C++ and Trellis.andM;As a parenthetical remark we note that in some environments one may wish todo an object-oriented design, but implement in a non-object-orientedlanguage.andP;  High-level design should be language independent but it is notparadigm independent.andP;  A truly object-oriented design can be directlyimplemented only in an object-oriented language.andP;  What can be done in thissituation is to transform the object-oriented design into an object-baseddesign (remove inheritance) and then implement in a traditional language.andP;  Weview this transformation as part of the design process, but others view it asan implementation technique.andM;Newer languages like Ada or Modula 2 have language constructs that directlysupport the encapsulation of an ADT.andP;  In other languages like C or COBOL theimplementation of an object-based design requires programmer adherence to aset of coding standards that are unenforceable by the compiler.andM;Specific IssuesandM;As stated in the introduction to this section of this article, there are manyfacets to the object world.andP;  Some techniques and concepts such as delegationare often considered under the object-oriented umbrella, but this sectionconsiders only the variations within traditional class-based inheritancesystems.andM;Typing.andP;  Programming languages are commonly classified according to theextent of type checking provided at compile time.andP;  Object-oriented languagesvary widely on this axis.andP;  On the one extreme Smalltalk is essentially atypeless language, whereas Eiffel is a very strongly typed language.andM;In object-oriented languages, type checking is applied at the level of anobject.andP;  Objects not only have data, but associated operations.andP;  Typechecking in the object world must therefore be associated not only with theinterpretation of data, but with determining which operations may be appliedto an object.andM;In a strongly typed object-oriented system, the only messages that areallowed to be passed to an object are those that can, from a syntacticanalysis of the source code, be guaranteed to be resolvable at runtime.andM;This is not true of Smalltalk.andP;  The absence of a type system means that anymessage may be attempted with any object.andP;  If, at runtime, a message isapplied to an object that does not know how to respond, then a runtime erroroccurs.andM;The weakly typed, interpreted environments exemplified by the Common LispObject System (CLOS) and Smalltalk have traditionally been associated withrapid prototyping [17] whereas the strongly typed, compiled languages such asEiffel and C++ are usually chosen for production environments.andM;Dynamic binding.andP;  In the previous section, the relationship between alanguage's typing system and dynamic binding were considered.andP;  Some typedlanguages, however, impose further constraints.andP;  C++ requires that a functionbe declared as &quot;virtual&quot; in order for it to be a candidate for dynamicbinding.andP;  This limitation may have some efficiency benefits, but makes forless-modifiable software components by restricting which operations on a typecan be modified in a sub-type.andP;  Polymorphism.andP;  Even in a strongly typedobject-oriented language, the typing system is more flexible than in alanguage like Ada or Pascal.andP;  As explained in section 2, entitled &quot;BasicConcepts of Object-Oriented Programming,&quot; the user-defined inheritancehierarchy can be taken by the compiler to define a sub-typing hierarchy.andM;Suppose that class Y inherits from class X. if the language treats Y as asub-type of X, then compiler will allow an instance of Y wherever an instanceof X is expected.andP;  This allows for an entry in the polymorphic array ofmenu_items in Figure 2 to refer to any of the specialized menu items(including a menu).andM;Not all languages treat every user-defined inheritance relation as defining asub-type.andP;  This imposes constraints on the use of polymorphism.andP;  Thesevariations and their impact on polymorphism are further explored in the nextsub-section.andM;Inheritance.andP;  Issues here include single versus multiple inheritance, singleversus multiple inheritance graph(s), information hiding in inheritance, andsub-typing versus implementation.andM;Multiple Inheritance: Many object-oriented languages allow for a class tohave more than one direct parent.andP;  This facility is especially useful when aclass belongs to more than one classification scheme.andP;  Suppose that a systemwas being developed for the National Wildlife Federation, and a &quot;Leopard&quot;class was being defined.andP;  The designers may already have class definitionsfor &quot;cat&quot; and &quot;endangered.&quot;andP;  Since a leopard is both a cat and an endangeredspecies, it would be natural to inherit from both classes.andP;  Eiffel has alwayshad multiple inheritance, but only the most recent versions of C++ have addedthis ability.andP;  Some languages such as Turbo Pascal V5.5 still only allow forsingle inheritance.andM;Number of Inheritance Graphs: Some languages define a single root class fromwhich all other classes automatically inherit.andP;  This language-defined rootclass thus bind all user-defined classes together into a single inheritancegraph structure and is used to provide a set of services common to allclasses in the system.andP;  One such service, provided in Eiffel's root classadds the ability for each object to make a deep (recursive) clone of itself.andM;In a strongly typed language, the dynamic type of an object reference isconstrained by the programmer-defined class inheritance hierarchies in thatsystem.andP;  In a language where every class automatically inherits from a singleroot class there is no constraint on the dynamic type of a reference whosestatic type is the root class.andM;The presence of an automatic parent to every class provides a simple, elegantsolution to some otherwise messy problems.andP;  It allows a language to remainsmall and conceptually clean, yet all the same time extensible.andP;  Smalltalkhas a single root class, C++ does not.andM;Information Hiding in Inheritance.andP;  Inheritance is a form of coupling betweenclasses.andP;  Normally modules in a software system should be loosely coupled.andO;Should inheritance be an exception to this rule?andP;  Should inheritancerepresent tight coupling, or loose coupling?andP;  Is information hidingincompatible with inheritance?andM;In Eiffel, inheritance represents tight coupling with no information hiding.andO;Other languages, such as C++, allow for information hiding withininheritance, and for variable levels of coupling between a base and derivedclass.andP;  This issue has been widely discussed in the literature [14, 22].andM;Sub-Typing versus Implementation.andP;  Inheritance can be used for eithersub-typing or implementation.andP;  All of the examples used thus far havedemonstrated the use of inheritance for sub-typing: A leopard is a sub-typeof a cat.andP;  A toggle_item is a sub-type of a menu_item.andP;  Inheritance forsub-typing corresponds to the &quot;is a&quot; nature of inheritance described earlier.andM;Figure 17 shows inheritance for implementation.andP;  A stack is not an array, butan array can be used for the implementation of a stack.andP;  Some authors [8, 13]discourage the use of this type of inheritance because it introduces compleximplementation dependencies into the software system.andP;  Furthermore, thispractice, in the presence of polymorphism and dynamic binding, leads to adesign in which information hiding can be violated.andM;Notice, in Figure 17, that by the use of polymorphism the stack protocol canbe subverted.andP;  C++ avoids this kind of problem by allowing a base class to bedeclared as &quot;private&quot; in the inheritance clause.andP;  This signifies to thecompiler that inheritance for implementation is intended.andP;  The compiler thendisallows any corresponding backward polymorphic assignments.andM;Figure 13 shows an alternate implementation of an array-based stack.andP;  In C++in-line functions can be used to avoid the extra procedure calls and thusachieve the same efficiency that was sought by inheritance in Figure 17.andM;Objects.andP;  Object-oriented languages differ in the kind of run-time objectsthat they manipulate, and in how these objects are created and destroyed.andM;Objects as Instances of Classes: Class instances are the basic objects in anobject-oriented system.andP;  All object-oriented languages allow for dynamicobject creation.andP;  Dynamically created objects are referenced through apointer (either explicitly or implicitly) and have the associated problems ofaliasing, etc.andP;  This means that object-oriented systems must deal with theissue of the management of objects in memory.andM;Some languages allow objects to be created statically or dynamically.andP;  InC++, this results in having a separate syntax for pointers to objects.andO;Although statically created objects may save one level of indirection, manysystems, such as MODSIM II, do not even allow for them, and in most of thosethat do they cannot be associated with polymorphism and dynamic binding.andM;For dynamically created objects, the language system automatically handlesallocation and deallocation of memory for the object.andP;  Initialization of theobject's data, and memory management within an object are treated differentlyfrom one system to another.andM;C++ has class constructors which deal with an object's data initializationand initial dynamic allocation of any memory within an object.andP;  Classconstructors are implicitly called whenever a class variable declaration isencountered.andP;  When an object passes out of scope or is explicitly deleted,the class destructor is automatically called and must deallocate anydynamically allocated memory internal to the object.andP;  Eiffel has no classdestructors, because it has automatic garbage collection.andP;  Eiffelconstructors must be explicitly called to create and initialize an object.andM;Other &quot;Objects&quot;: In addition to class instances, an object-oriented languagemay allow other types of run-time entities.andP;  In the second section of thisarticle we introduced the idea of a class-object.andP;  This object is not a classinstance, but more like an accessible class descriptor.andP;  Another way oflooking at it is that each class has a corresponding meta-class thatdescribes the class.andP;  A class-object is an instance of this meta-class.andP;  Usesfor such a class-object were given in that section.andM;In Smalltalk all run-time entities are objects.andP;  Even integers are instancesof the integer class.andP;  Other languages allow some primitives such as aninteger to be implemented in the traditional way.andP;  This saves memory spaceand execution overhead as every integer does not have to have a pointer toits class descriptor, etc.andP;  Other systems treat integers conceptually asobjects, but handle them differently at the compiler level for efficiencyreasons.andM;EncapsulationandM;Most object-oriented languages provide direct support for some form ofinformation hiding within a class.andP;  Figure 13 shows the use of the exportclause to support information hiding.andP;  In Eiffel, every feature of a class isautomatically private, and thus unavailable outside of the class, unless itis specifically included in the class' export clause.andP;  C++ addressesinformation hiding with the language constructs of private, public,protected, and friend.andM;Full support for encapsulation requires that the programmer have completecontrol over what features of a class are a part of the public interface.andP;  Insome versions of Smalltalk, encapsulation is limited in that all methods areautomatically public and all data private.andM;Encapsulation is such an important part of the object-oriented paradigm that,according to some definitions, a language is not object-oriented unless itprovides for encapsulation.andM;Persistence: Some object-oriented languages, such as C++ and Turbo PascalV5.5, have no direct way to store an object.andP;  Users of these languages musteither manage their own object i/o (a nontrivial task) or puchase acommercial object-oriented database system.andM;In Smalltalk and CLOS the entire current execution state can be saved todisk.andP;  Yet, individual objects cannot be saved to an external file throughthe facilities of the basic language.andM;Other languages provide object i/o to disk in the same way that Pascal andCOBOL provide record i/o.andP;  An environment can add this functionality withoutaltering the language definition or adding keywords by adding an objectstorage management class to the class library.andP;  An object needing persistencewould then inherit from the &quot;storable&quot; class.andP;  This is the approach taken byEiffel.andM;The OOPS class library [7] uses a single root class to provide basicpersistence capabilities and guarantee uniform i/o semantics.andM;Keyed access to persistent object may also be provided in a language.andM;Pure versus hybrid.andP;  Trellis, Eiffel and Small talk are pure object-orientedlanguages.andP;  They are pure in that they not only support the paradigm, theyenforce it.andM;One way in which some languages enforce the use of the object-orientedparadigm is by requiring that all functions, procedures and variables bedeclared internal to some class.andP;  In such a system there are no globalvariables, and no free-standing functions or procedures.andP;  All state isencapsulated in an object, and all code is executed relative to some specificobject.andP;  The main program becomes the constructor in the class that defines aspecific application.andM;C++, Object-Pascal, CLOS are hybrid languages.andP;  They are object-orientedextensions to base languages that were designed to support a differentparadigm.andP;  As such, C++ is a multi-paradigm language whereas Smalltalk is asingle paradigm language.andM;&quot;Purists&quot; claim tha the hybrid languages are a detriment to the paradigm inthat groups using a hybrid language may claim to be doing object-orientedprogramming when, in fact, they may be doing 90 percent of their design inthe paradigm of the base language.andP;  When the benefits of the object-orientedparadigm are not realized on such projects, managers will becomedisillusioned with the &quot;object-oriented&quot; approach.andM;Proponents of hybrid languages see them as a natural migration path into theparadigm.andP;  Programmers skilled in the base language can immediately use theobject-oriented version and gradually learn the new features and paradigm.andO;Proponents also claim that no all problems are best solved by a single tool,thus the availability of multiple paradigms is desirable.andM;History LessonsandM;There is much that has been learned about software development that isorthogonal to the object-oriented paradigm but that nevertheless ought to beincluded in any modern programming language and environment.andM;All object-oriented languages provide classes and objects, but some of themdo not provide any construct for information hiding within an object.andP;  TurboPascal 5.5 is particularly bad in this aspect.andM;Eiffel provides a generic facility.andP;  This is such an important construct forsupporting reuse that every strongly typed language ought to support it.andO;Unfortunately, few do.andP;  Some of the compilers are very fast, others are veryslow.andP;  Some, like Smalltalk have large libraries and are integrated into asophisticated development and testing environment.andP;  Others provide only abare-bones compiler.andM;The field is so new, however, that it should not be judged too  harshly.andO;Commercially, C++ is only 3 years old, Smalltalk-80 and Objective C only 6years old.andP;  Admittedly, Simula has existed for more than 20 years, but mostlyin a research setting.andM;ConclusionandM;The purpose of this article has been to introduce terminology, concepts, andbasic techniques surrounding the object-oriented paradigm.andP;  The emphasis ondata in system design has increased greatly over the past several years andhas led to a number of data-driven techniques.andP;  By considering a definitionthat includes objects, classes, and class inheritance, we have tried to focuson a set of concepts that we view as a paradigm separate from theobject-based paradigm being supported by the Ada and Modula-2 communities.andM;The design philosophy of the object-oriented paradigm takes a modeling pointof view.andP;  This allows the designer to work with one approach which begins inthe problem domain and transitions naturally into the solution domain.andP;  Bybuilding a model of the problem into the application system, the resultingdesign is more responsive to changes in knowledge about the problemsituation.andP;  The modularity of these design and information-hidingcapabilities of most object-oriented languages contribute to the technique'sresponsiveness to modifications.andM;A number of languages support the object-oriented paradigm, and thevariability in language features affects the design process.andP;  Although mostobject-oriented languages now support multiple inheritance, the inheritancemechanism varies greatly from one language to another.andP;  A number of languagesare available in a variety of development environments which facilitate thesystems development process.andP;  We have detailed a number of languagedifferences, but we believe that ultimately it is the richness of thisdevelopment environment and supporting software base that will have thelargest impact on productivity.andM;The articles in the remainder of this special issue will provide a detailedview of many topics that we have merely introduced.andP;  The Proceedings of ACM'sConference on Object-Oriented Systems, Languages, and Applications (OOPSLA)is a rich source of material as well.andM;ReferencesandM;[1] Baldassari, M., Bruno, G., Russi, V. and Zompi, R. PROTOB, a hierarchicalobject-oriented CASE tool for distributed systems.andP;  In ESEC '89, 2d EuropeanSoftware Engineering Conference Lecture Notes in Computer Science no.andP;  387,Springer-Verlag, 1989.andM;[2] Boehm, B. A spiral model of software development and enhancement.andO;Computer, (May 1988), 61-72.andM;[3] Cardelli, L. and Wegner, P. On understanding types, data abstraction, andpolymorphism.andP;  Comput.andP;  Surv.andP;  17, 4 ACM, N.Y.andP;  471-522.andM;[4] Coad, P. and Yourdon, E.andP;  Object-oriented Analysis.andP;  Yourdon Press, 1990.andM;[5] Cox, B.andP;  Object-oriented Programming: An Evolutionary Approach.andO;Addison-Wesley, New York, 1986.andM;[6] Gibbs, S., Tsichritzis, D., Casais, E., Nierstrasz, O., Pintado, X.andO;Class management for software communities.andP;  Commun.andP;  ACM 33, 9 (Sept.andP;  1990).andM;[7] Gorlen, K.andP;  An object-oriented class library for C++ programs.andP;  Softw.andO;Exp.andP;  and Prac.andP;  17, 12, 899-922.andM;[8] Halbert, Using types and inheritance in object-oriented programming.andO;JEEE Softw.andP;  (Sept.andP;  1987), 71-79.andM;[9] Henderson-Sellers, B. and Edwards, J.M.andP;  The object-oriented systems lifecycle.andP;  Commun.andP;  ACM 33, 9 (Sept.andP;  1990).andM;[10] Johnson, R.E.andP;  and Foot, B. Designing reusable classes.andP;  J.andO;Object-oriented Program.andP;  (June-July 1988), 22-35.andM;[11] Lieberherr, J.J.andP;  and Holland, I.M.andP;  Assuring good style forobject-oriented programming.andP;  IEEE Softw.andP;  (Sept.andP;  1989), 38-48.andM;[12] Liskov, B., and Guttag, J.andP;  Abstraction and Specification in ProgramDevelopment.andP;  MIT Press, 1986.andM;[13] McGregor, J.D.andP;  Object-oriented Software Design and Development.andP;  VanNostraad Reinhold.andP;  To be published.andM;[14] Meyer, B.andP;  Object-Oriented Software Constraction.andP;  Prentice-Hall, 1988.andM;[15] Meyer, B.andP;  The new culture of software development: Reflections on thepractice of object-oriented design.andP;  In Proceedings of the FirstInternational Conference on the Technology of Object Oriented Languages andSystems (1989), pp.andP;  13-23.andM;[16] Meyer, B.andP;  Lessons from the design of the Eiffel libraries.andP;  Commum.andO;ACM (Sept.andP;  1990).andM;[17] Mullin, Object-oriented Program Design with Examples in C++.andP;  AddisonWesley, 1989.andM;[18] Peckham, J. and Maryanski, F.andP;  Semantic data models.andP;  ACM Comput.andP;  Surv.andO;v. 20, n. 3, 1988, 153-189.andM;[19] Pressman, R.S.andP;  Software Engineering.andP;  McGraw-Hill, 1987.andM;[20] Raghavan, R., Ramakrishnan, N., and Strater, S. A C++ class browser.andP;  InProceedings of the C++ Workshop, USENIX Association (1987), pp.andP;  274-281.andM;[21] Sciore, E.andP;  Object specialization.andP;  ACM Trans.andP;  Inf.andP;  Syst., 7, 2 (April1989), 103-122.andM;[22] Snyder, A.andP;  Encapsulation and inheritance in object-oriented programminglanguages.andP;  In Proceedings of OOPSLA (1986), pp.andP;  38-45.andM;[23] Sommerville, I.andP;  Software Engineering.andP;  Addison-Wesley, 1989.andM;[24] Tsichritzis, D., Ed.andP;   Active Object Environments.andP;  CentreandM;Universitaire D'Informatique, Geneve Switzerland, 1987.andM;[25] Tsichritzis, D., Ed.andP;  Object Oriented Development.andP;  Centre UniversitaireD'Informatique, Geneve Switzerland, 1989.andM;[26] Wasserman, A.I., Pircher, P.A., Muller, R.J.andP;  Concepts ofobject-oriented structured design.andP;  In Proceedings of TOOLS '89 (1989), pp.andO;269-280.andM;[27] Wegner, P.andP;  Dimensions of object-based language design.andP;  In Proceedingsof the Conference on Object-Oriented Systems, Languages, and Applications(1987).andM;[28] Wirfs-Brock, R., Wilkerson, B., and Wiener, L. Designing Object-OrientedSoftware.andP;  Prentice-Hall, 1990.andM;[29] Wirfs-Brock, R. and Jonnson, R. Surveying current research inobject-oriented design.andP;  Commun.andP;  ACM 33, 9 (Sept.andP;  1990).andM;TIM KORSON is an assistant professor of computer science at ClemsonUniversity in Clemson, South Carolina.andP;  He has worked at the SoftwareEngineering Institute as a Visiting Scientist and serves as a consultant toATandamp;T.andP;  His current research interests include developing metrics andaccounting systems for the management of information assets with emphasis onmanaging a corporate transition to object-oriented technology.andM;JOHN D. McGREGOR is an associate professor of computer science at ClemsonUniversity.andP;  He has worked at Lawrence Livermore National Laboratory and is aconsultant for ATandamp;T Bell Laboratories.andP;  He is an ACM Lecturer and recentlyhas been program chair of ACM's Computer Science Conference and general chairof the National Educational Computing Conference.andO;</TEXT></DOC>