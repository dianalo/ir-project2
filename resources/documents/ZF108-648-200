<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-648-200  </DOCNO><DOCID>08 648 200.andM;</DOCID><JOURNAL>Computer Language  July 1990 v7 n7 p34(11)* Full Text COPYRIGHT Miller Freeman Publications 1990.andM;</JOURNAL><TITLE>Controlling colors the Xlib way. (the X library C programmer'slibrary for the X Window System)</TITLE><AUTHOR>Johnson, Eric F.; Reichard, Kevin.andM;</AUTHOR><SUMMARY>The X Window System includes several programming libraries, mostof which are built as toolkits atop the lowest programming layer,the X library, or Xlib.andP;  Xlib is a C programmer's library into thelower levels of the network-based X protocol, which is apredefined way for applications to communicate with the X serverapplication program.andP;  X server controls the hardware, and programsask it to draw things using the X communications protocol.andP;  UsingXlib function calls for the user interface code maintainsportability, and standardization of the X library and the Xtoolkits that reside above it allows the same source code to becompiled and run on many machines.andP;  Drawing in X, X's colormodels, the simple color model, setting up a connection,visualizing visuals, drawing in a color, creating a window and agraphics context, mapping onto the display, event loops, changingcolors, redrawing a window, cleaning up and closing the connectionare described.andM;</SUMMARY><DESCRIPT>Topic:     X Windows (Standard)Program LibrariesProgram Development ToolsProgramming InstructionTutorialComputer GraphicsProtocolC Programming LanguageColor.andO;Feature:   illustrationprogram.andO;Caption:   17 short utility programs are listed from the X library. (program)andM;</DESCRIPT><TEXT>The X Window System provides a vendor-independent graphics library you canuse to write colorful windowed applications.andP;  That's the theory, anyway; thereality is that creating these colorful windowed applications can be verydifficult.andM;The X Window System is the only widely available, portable windowing system.andO;It comes with a number of programming libraries, most built as toolkits ontop of the lowest programming layer, the X library.andM;Often called Xlib, the X library is a C programmer's library into the lowerlevels of the network-based X protocol.andP;  This protocol is a predefined wayfor applications to talk to an application program called the X server.andP;  TheX server controls the keyboard, monitor, and mouse and performs the actualdrawing tasks: in other words, it owns the hardware.andP;  Your programs ask the Xserver - using the X communications protocol - to draw things.andP;  The X servercan also (if asked) let you know when the user has pressed a key on thekeyboard, moved the mouse, or generally tried to interact with your program.andM;DOS programmers who like directly munging the hardware are going to hatethis, but this level of indirection has two key benefits: applicationportability and network transparency.andP;  Portability is maintained by usingXlib function calls for the user interface code.andP;  The same source code can becompiled and run on many machines (including Sun SPARCstations,Hewlett-Packard 9000s, and IBM RS/6000s) since the X library (and the Xtoolkits that reside above Xlib) are standardized.andP;  (They are standardized toa degree, which seems to mean &quot;standardized until the next release.&quot; Eachrelease from the Massachusetts Institute of Technology introduces new quirksand incompatibilities.)andM;Since many programs can talk to an X server, you can have a spreadsheet inone window, a word processor in another, and a game in a third.andP;  Since X isnetwork-transparent, it doesn't matter which machine runs an applicationprogram-you can run the game on your boss's machine to eat any extra CPUcycles that might be lying around.andM;To make its application portable, X's designers abstracted keyboards, mice,graphic displays, and colors (among other things) so programmers can use theabstractions and be free of hardware worries.andP;  This works well in theory (andgenerally in real life, too), but some abstractions are a wee bitcomplex-particularly color.andM;DRAWING IN XandM;Xlib function calls allow you to draw into windows and off-screen areascalled pixmaps.andP;  A window is an area on the screen to which you can draw andfrom which your application can read input events (like keys being pressed).andO;Most X applications create at least one main window and perhaps a number ofsubwindows.andP;  (If you've heard of windows on systems like Presentation Manageror the Macintosh, you're already familiar with the way X treats windows.)andM;When you draw into a window, you need a graphics context.andP;  This contextstores the current drawing color and font, line width, and a number of otherparameters, all having to do with drawing.andP;  You need to create a window todraw in and a graphics context to draw with.andM;X'S COLOR MODELSandM;X goes wild with color.andP;  Six types of color visuals and numerous ways towrite color applications are available.andP;  X has colormaps, standard colormaps,and visual types.andP;  There are probably a zillion ways to use color in Xapplications.andM;The first thing to remember about color is that not everyone has it.andP;  Manyworkstations are sold as monochrome systems, primarily due to the cost of19-inch color monitors and video boards to drive these expensive monitors.andO;If they need color, your applications must be able to detect systems thatsupport color and those that don't.andP;  Your application needs to detect whethersystems that support color also support a writable colormap (one yourapplication can change).andM;If you really require color, you don't have much choice about what to do if auser isn't running a color system.andP;  Most applications, though, do just finewithout color-they just won't look pretty.andM;THE SIMPLE COLOR MODELandM;The simple color model provides relatively easy color for the masses.andP;  Ifyour application just wants to draw a line in red, you really don't have toworry about the complexities of the X color model unless you're veryparticular about the shade you want'andM;The X Window System comes with a database of English color names, such asred, misty rose, and lime green (our favorite).andP;  You can use these names andhave Xlib look up the proper red/green blue (RGB) values for each named color(that way, users can customize the color database for variances on theirsystems).andP;  Once you have a colormap, you can set &quot;red&quot; as shown in Listing 1(if a display and screen number have already been set up).andM;The code in Listing 1 will try to allocate a read-only color cell in yourcolormap.andP;  Don't worry about the details right now.andP;  Using these color namesand read-only color cells can help make your programs good citizens in the Xworld because other applications share the cells in the colormap.andP;  Sincecolor is expensive, many systems provide a small number of colors (such as 16on a VGA system or the more common 256 on most color workstations).andP;  Eachcolor cell your application uses may be a precious resource.andP;  But sometimesyou absolutely must use color cells and be able to change (read or write)those cells.andM;We've put together a program that displays constantly changing RGB colors.andO;This program is based on the idea that working source-code examples makelearning a lot easier, especially for complex subject matter.andM;This program should give you a brief introduction to Xlib programming andshow you how to munge color values.andP;  The text explains various portions ofthe source code; the listings provide the code a bit at a time.andP;  You candownload the complete code from COMPUTER LANGUAGE's CompuServe forum or BBSnetwork.andM;SETTING UP A CONNECTIONandM;The first thing you need to do to start an X application is set up aconnection to a display  X server).andP;  The Display structure is defined inandless;X11/Xlib.handgt; (almost every X program needs this include file).andP;  Use the Xlibfunction XOpenDisplay() to set up the connection:andM;#include  X11/Xlib.h)andM;Display *display;andM;char *display_name;andM;display_name = NULL;andM;display = XOpandM;if ( display == (DisandM;{/*  Handle errors here */andM;}XOpenDisplay() takes a name of the connecting display.andP;  When we pass NULL,we're really telling XOpenDisplay() to use the name stored in the DISPLAYenvironment variable.andP;  You'll have to set up DISPLAY to name the properdisplay-X server-when you test this program.andP;  X has a standard for passingthe display name on the command line (-display displayname), but we'll usethe default case here and pass NULL.andM;VISUALIZING VIZUALSandM;X divides the world of color systems into six visual classes that describevarious ways workstation hardware is set up.andP;  Some workstations allow formultiple colors in a color look-up table.andP;  Some provide three (red, green,and blue) such tables (&quot;decomposed&quot; color look-up tables).andP;  Others provideonly black and white.andP;  Some workstations allow the graphics hardware to betreated in a number of ways (using overlay planes, for example), usuallyletting software control color planes and whatnot.andM;All these ways of treating hardware are grouped into general categoriescalled visuals.andP;  Each has a full-blown structure that describes itsabstraction of color hardware.andP;  Any screen - usually a physical CRT monitor -can support a number of visuals (a number of ways of looking at the colorhardware).andP;  Each visual has one of the following general classes:andM;* PseudoColor systems allow for read/write colormaps and have a color look-uptable.andM;* StaticColor is a PseudoColor system with a read-only colormap.andM;* Directcolor systems provide red, green, and blue color look-up tables(decomposed tables) and a read/write colormap.andM;* TrueColor systems are the same as DirectColor, only TrueColor has aread-only colormap.andM;* GrayScale allows for variations in gray (or some other primary color) andis essentially a PseudoColor visual where the red, green, and blue elementsshould be set the same all the time.andM;* StaticGray is a GrayScale visual where you cannot change the color map; thegray scales are fixed.andP;  X's designers refer to monochrome systems astwo-color StaticGray systems.)andM;Who really cares about all these classes? You - if you want to write portableX applications.andP;  In our program, we only deal with PseudoColor visuals forsimplicity's sake, because the colormaps are writable and we don't have tomess with the three (RGB) color lookup tables.andP;  The real problem is finding aPseudoColor visual to use - and that's what your applications will have todo.andP;  This task is the same as finding any other type of visual.andM;Many (if not most) color X systems provide a PseudoColor visual as thedefault.andP;  PseudoColor makes the most sense and breaks the least code since alot of X code assumes a PseudoColor default visual.andP;  (Sun Microsystemsdecided against this for its X11/NeWS product.andP;  Sun is correct in that nostandard exists for what the default visual should be, but it sure made lifemore difficult for a lot of beginning X programmers.)andM;The function SetUpVisual() searches the possible visuals on a display andscreen to find the first PseudoColor one.andP;  There may be many PseudoColors andother visuals.andP;  Visuals describe the ways the hardware can be viewed.andM;SetUpVisual() takes a display pointer (from above) and a screen number  Xdisplays can support multiple physical screens) and returns a visual pointerand depth.andP;  Both values are needed to create a window later.andM;SetUpVisual() uses the Xlib function XGetVisualInfo(), which returns a listof visuals that match a given template.andP;  Here we're only using the screennumber (the default screen) and the class of PseudoColor-we're saying we'lltake anything as long as it's a PseudoColor visual and the visual is on thegiven screen (the CRT).andM;We can fill in any elements in a large structure (XVisualInfo in this case),but we have to tell the Xlib routine which elements we filled in.andP;  We do thisusing bitmasks.andP;  By using the class and screen fields of the template, wepass the VisualClassMask VisualScreenMask to XGetVisualInfo().andP;  To create awindow and a graphics context, we fill in part of a structure and then use amask to tell Xlib which parts are filled.andP;  X uses this technique often.)andM;XVisualInfo looks like Listing 2.andP;  Both XVisualInfo and the mask values aredefined in the include file andless;X11/Xutil.handgt;.andP;  XGetVisualInfo() returns the listof visuals that match the template.andP;  Since we just want one, we take thefirst (Listing 3).andP;  After calling XGetVisualInfo(), we free the visual listreturned by the function using the Xlib routine XFree().andM;MAPS, CELLS, AND PIXELSandM;To draw in a color, we need a color cell (or pixel value).andP;  This pixel valueis used with the graphics context to draw.andP;  (Pixel is a terrible name forthis since most people except IBMers - associate 'pixel' with a dot on thescreen; here it refers to a location in a color look-up table.) To create ourown color cell in the visual we found, we need to create a colormap using ourvisual.andM;SetUpColormap() creates a colormap using our new visual and then finds valuesfor &quot;black&quot; and &quot;white.&quot; We're never sure what these color names will map to,but we always hope the colors look something like real black and white.andM;SetUpColormap() takes a display pointer, screen number, and visual andreturns a new colormap with black and white colors.andP;  RootWindow() is a macrothat returns the screen's root (or base) window.andP;  This is the highest-levelwindow and is considered the screen background.andP;  The window parameter isassociated in the colormap with the same screen as the window - hence thepurpose of the default window on the screen (Listing 4).andM;Instead of AllocNone, we could pass the constant AllocAll to allocate all thecolor cells in the colormap.andP;  By allocating as few color cells as possible,we try to minimize the &quot;Technicolor&quot; effects of using our colormap.andP;  Sincemany workstations can only have one active hardware colormap at a time, whenan X window manager switches into (and out of) our colormap, the rest of thescreen may go Technicolor.andM;After we get a colormap, we can use XAllocNamedColor()  to allocate a colorcell (this will be a read-only color cell, so it won't be easy to changelater) with a color value matching a particular name.andP;  The name  white' islooked up in the system's color database.andM;The XColor structure looks like Listing 5.andP;  The pixel field is the locationin the colormap.andP;  The red, green, and blue values are the numericdescriptions of the color (Listing 6).andM;Next, we need to allocate a read-write color cell in our new colormap(Listing 7).andP;  Now that we have a color cell, we can change the color itholds.andP;  Finally, we set up some arbitrary RGB color values.andP;  Many 256-colorsystems use just the top byte of the 16-bit RGB values, so we shift up.andP;  Weencourage you to try out a number of different numbers for the RGB values andexperiment at will:andM;/* Set up some &quot;random&quot; RGB color*/andM;/* values*/andM;the_color.red = ( 1andless;andless; 8 );andM;the_color.green = (104 andless;andless; 8 );andM;the_color.blue = (200 andless;andless; 8 );andM;X uses bitmap fonts to draw text.andP;  Before we can use a font, you need to loadit.andP;  Here, we use XLoad-QueryFont() (one of a number of font-loadingfunctions) to load in a font named  'fixed'.andP;  The 'fixed' font should beavailable on most systems.andP;  If not, we use the xlsfonts program to get a listof available fonts and choose our favorite name:andM;font = XLoadQueryFont( display, &quot;fixed&quot;andM;if ( font == (XFontStruct * ) NULL )andM;{/* We've got a problem...andP;  */andM;}Creating windows is probably one of the most difficult tasks in X. Once wehave a visual, a depth (the number of color planes supported by the visual),and colors for black and white (which we use as border and backgroundcolors-not necessarily black and white), we can create a window.andP;  There areeasier ways to create a window, but this way we can make sure we can accesscolor from the window.andM;In the main function from the source code:andM;/* Create a window and set ICCCM values.andP;  */andM;SetUpWindow( display, visual, depth,andM;colormap, black, white, andamp;windowandM;ICCCM refers to the Inter-Client Communications Conventions Manual, adocument that describes how X applications should act.andP;  For simplicity, we'renot setting all the ICCCM values we should, but enough so most windowmanagers won't give you griefandM;The function SetUpWindow() creates a window for us.andP;  First we determine thesize and location of the window.andP;  Normally in X you can pass a command-lineparameter called the geometry specification:andM;-geometry width X height + x + yandM;to set the location and size (where width, height, x, andy are numbers and nospaces follow the width).andP;  Most X programs will accept this method forlocating the application's window.andM;Next, we fill in part of an XSetWindowAttributes structure.andP;  As withXGetVisualInfo(), we fill in part of the structure and then provide a bitmaskthat tells the Xlib routine which part we filled in.andP;  The fullXSetwindowAttributes structure looks like Listing 8.andP;  For most of the fields,we use the defaults shown in Listing 9.andM;The event-mask field states that we are interested in ButtonPress (generatedwhen the user clicks the mouse in the window) and Expose events (generatedwhen part of the window needs to be redrawn).andM;We finally get to create the window, using XCreateWindow() (Listing 10).andP;  Wethen store some ICCCM-related values for the window manager.andP;  These aren'treally related to using color in X but are needed to make the window managerhappy.andM;Note that we're using functions for rel.andP;  4 of the X Window System.andP;  If youhaven't upgraded yet, skip XAllocWMHints() and XAllocsize-Hints().andP;  Instead,declare the variables as structures rather than pointers to structures (anddon't free the memory when you're done).andP;  The XWMHints structure didn't havethe base-width and base-height fields in rel.andP;  3; use width and height fieldsinstead and PSize instead of PBaseSize for the flags.andP;  We wholeheartedlyencourage you to upgrade to rel.andP;  4, the most professional X release thusfar.andM;CREATING A GRAPHICS CONTEXTandM;X uses a graphics context to describe scribe how objects should be drawn.andO;The GC contains the drawing color (and background color for text), the linewidth, the font to draw text in, what sort of pattern should be used (calledtiling and stippling in X terminology), and so on.andP;  Here, we're mainlyconcerned about the pen color and text font.andM;Each GC is associated with a window.andP;  You may create multiple GCs for awindow, but remember that each takes up server memory (since X terminals weredesigned for low cost, they don't have a lot of extra memory).andM;The Xlib function XCreateGC() creates a GC associated with a window.andP;  You maypass a structure full of initial values and a mask telling the Xlib whichfields of the structure you filled in.andP;  Since we're using so few, we'll takethe easy route and create the GC with no special initial values other thanthe system-provided defaults (Listing 11).andM;XSetForeground() sets a GC to draw in the given foreground color.andO;XSetBackground() sets the background color for text.andP;  The following code setsthe foreground (drawing color) to black and the background (for text) towhite:andM;unsigned long black, white;andM;XSetForeground( display, gc, blackandM;XSetBackground( display, gc, whiteandM;XSetFont() sets a GC to use a font for drawing text and takes a font IDnumber.andP;  This ID number is stored in the fid field of the XFontStructstructure.andP;  Of course, you have to load to font first:andM;Font font_id;andM;XFontStruct *font;andM;font_id = font-) fid;andM;XSetFont( display, gc, font_id );andM;MAPPING ONTO THE DISPLAYandM;When you're working with windows in X, creating the window is only the firststep.andP;  X will create a window for you, but it won't put the window on thescreen until you map it.andP;  XMapWindow() and XMapRaised() both handle thistask.andP;  XMapRaised() maps the window and makes sure it starts out on top,while XMapWindow() just maps the window to the screen  but nine times out of10 both act the same):andM;Display *display;andM;Window window;andM;XMapRaised( display, window );andM;XFlush( display );andM;XFlush() sends the X protocol requests out (over the network, usually) to theX server.andP;  Xlib normally batches these requests and sends a clump to the Xserver to improve network performance.andM;EVENT LOOPandM;Events in X are asynchronous messages from the X server.andP;  Events aregenerated when the user presses a key on the keyboard (and releases a key),the mouse is moved, and windows need to be redrawn, and at other times.andM;Normally, when you create a window you tell the X server which of the manypossible types of events your application is interested in.andP;  Then, when suchan event is generated, the X server will send it to your application.andP;  Sinceevents are tied to windows, the X server is really sending the event to theapplication that owns (has registered an interest in events on) a window.andP;  Xapplications are said to be event-driven; they have a central loop that waitsfor events to come in and then processes them (Listing 12).andM;The function CheckForEvents() checks to see if an X event is pending.andO;XPending() returns the number of events waiting in the event queue.andP;  If noevents are waiting, XPending() flushes the output buffer like XFlush().andP;  Youcan use XPending() when you don't want your applications to block awaitinginput from the X server.andP;  X provides both blocking and nonblocking eventfunctions.)andM;XNextEvent() blocks awaiting the next event from the given X display.andP;  Whenwe combine XNextEvent() - a blocking function -with XPending(), we have avery simple nonblocking section of code.andP;  It is simpler than X's nonblockingevent functions.andM;XNextEvent() returns the event into an XEvent structure.andP;  This structure isreally a union of many different event structures, one for each major type ofevent.andP;  All the structures have a type field in common, so you can switch offthe type field.andP;  Here we're looking for ButtonPress  signaling that the userhas pressed a mouse button) and Expose events.andP;  Remember that unless you askfor events of a certain type (via XSelectInput or XCreateWindow), you won'tget events of that type - except, of course, for certain types of events thatyou get no matter what (Listing 13).andM;We call sleep() here just to delay changing the color.andP;  This gives you achance to see the dazzling color on the screen and appreciate its sublimebeauty.andP;  In other words, there's no particular reason for sleep() other thanto wait between color changes.andM;CHANGING COLORSandM;The function ChangeColor() munges the color cell we've set up, the_color.andP;  Itdoes this by incrementing (setting back to zero after reaching an arbitrarymax value) each of the red, green, and blue fields.andP;  It then callsXStoreColor(), which requires you to have set up a color cell (the pixelfield of the XColor structure) before trying to change the contents of thatcell.andM;The flags field of the XColor structure tells XStoreColor() which values tochange: red, green, and blue (that is, all of them).andP;  In our program,XStoreColor() is the key changing the color we display (Listing 14).andP;  Afterwe change the color, we redraw the window us the new color.andM;REDRAWING A WINDOWandM;Unlike some windowing systems, such as Amiga's, X doesn't maintain thecontents of obscured windows.andP;  When one window overlays another, the obscuredpixels are usually lost.andP;  (You can ask X to save these pixels, but X neverguarantees it.) All your X applications should look for Expose events andredraw your windows accordingly.andM;The X server will send an Expose event for every rectangle exposed (wasobscured and now is not) that you need to redraw.andP;  X also guarantees thatExpose events will arrive in sequence.andP;  If you wait until the count field iszero, you know your application has received the last Expose event in thesequence.andM;This sequence is important because for some applications it's easier toredraw the entire window than to clip the given rectangle and redraw eachsection as it is exposed.andP;  We redraw the entire window since we have a verysimple program.andP;  We don't want to redraw the window many times in a row, sowe wait until the count field is zero.andM;In X, it is normal to create a window, map it to the screen, and wait untilthe Expose event arrives before drawing into the window.andP;  Because X isnetwork-oriented and an X window manager may take its own sweet time mappingyour window, the mapping function XMapRaised() may take a long time.andP;  Younormally wait for an Expose event before drawing into a new window.andM;The code in Listing 15 is from the function CheckForEvents().andP;  The Redraw()function redraws the whole window.andP;  We call this function when X sends anExpose event and when we change the current color and want to see theresults.andP;  We start by drawing in a rectangle in the current color (Listing16).andP;  Then we draw in the current RGB values as text in black (the window hasa white background) as shown in Listing 17.andM;CLEANINGandM;Well-behaved X applications clean up any resources (especially large memoryeaters) before exiting the program.andP;  This makes things easier for the Xserver.andP;  Some of these functions free, some unload, and some (our favorites)destroy.andP;  From a programmer's perspective, they all do the same thing.andO;XCloseDisplay() should also free up all your program's X resources (as willsimply quitting your program), but it's nicer for the X server to do itformally:andM;Display *display;andM;Window window;andM;GC gc;andM;XFontStruct *font;andM;XDestroyWindow( display, window );andM;XFreeGC( display, gc );andM;XFreeFont( display, font );andM;CLOSING THE CONNECTIONandM;XCloseDisplay() shuts down a connection to an X server.andP;  After you've calledXCloseDisplay(), don't make any more X calls for that display connectionsince you've just wiped it out.andP;  In other words, don't draw to windows onthat display, don't check for keyboard events, and don't even think aboutgrabbing more color cells.andP;  You can still make calls using other displayconnections yes, you can open as many display connections as you want-or atleast as many as your operating system will allow you):andM;Display *display;andM;XCloseDisplay( display );andM;Creating a window, drawing into it, and munging colors - what more could youwant? If your version of X is installed properly, you should be able tocompile the program with a UNIX command like cc-o  colorfun colorfun.c -|X11.andM;We've used only the low-level Xlib (-|X11) library.andP;  We did not use the Xttoolkit library nor any Motif or Open Look libraries.andP;  The colorfun programdoesn't need any command-line parameters, but the DISPLAY environmentvariable should be set up correctly.andM;To quit the program, simply click the mouse (any button will do) in theprogram's window.andM;We think you'll have a lot of fun programming X applications and hope thisprogram helps introduce the X library.andP;  This article can't do more than giveyou a taste of X programming-we've written two books on the subject and stillhaven't covered everything.andP;  The books listed in the sidebar can satisfybigger appetites.andM;Eric E Johnson and Kevin Reichard wrote X Window Applications Programming andAdvanced X Window Applications Programming Portland, Ore.: MIS: Press, 1989).andO;In real life, Johnson is a systems designer for Boulware Technologies Inc andReichard is editor of Computer User, a Minneapolis-St.andP;  Paul month#newspaper.andP;  Both detest the term &quot;GUI.&quot;andM;MORE INFORMATION ON X PROGRAMMINGandM;* X Window System: C Library and Protocol Reference by Robert W Scheifler,James Gettys, and Ron Newman (Bedford, Mass.: Digital Press, 1988) is thebible of Xlib programming.andP;  It contains the official definition of the Xprotocol (the communications formats that sit under the Xlib) and the Xlibfunctions and macros.andP;  The book is currently being updated to rel.andP;  4, so anew version will be out soon.andM;* X Window Applications Programming by Eric F. johnson and Kevin Reichard(Portland, Ore.: MIS: Press, 1989) is an introduction to Xlib programming inC, with scads of source-code examples.andP;  Advanced X Window ApplicationsProgram ming, the newest book, covers more advanced topics in X applicationdevelopment.andM;* Introduction to the X Window System by Oliver Jones (Englewood Cliffs, NJ.:andO;Prentice Hall, 1989) is another excellent introduction to Xlib programming.andM;* O'Reilly andamp; Assoc.andP;  (Sebastopol, Calif.) publishes a large set of X manuals(vols.andP;  1-7; vol.andP;  6 is mysteriously missing) covering Xlib programming(vols.andP;  1-2), using X (vol.andP;  3), X toolkit programming (vols.andP;  4-5; toolkitssit on top of the Xlib), and XView programming (vol.andP;  7; XView is a toolkitthat was designed to make SunView applications easier to port to X, and thereare many more SunView applications than X applications, at least right now).andM;(Listings omited)</TEXT></DOC>