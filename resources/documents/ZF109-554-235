<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF109-554-235  </DOCNO><DOCID>09 554 235.andM;</DOCID><JOURNAL>Digital Review  Oct 29 1990 v7 n42 p19(2)* Full Text COPYRIGHT Cahners-Ziff Publishing Associates LP 1990.andM;</JOURNAL><TITLE>Software overhead that defies gravity. (memory requirements ofDECwindows) (column)</TITLE><AUTHOR>Hancock, Bill.andM;</AUTHOR><SUMMARY>The rising popularity of virtual computer systems, and the focuson getting software programs to market as quickly as possible, hasled to a proliferation of inefficiently-coded programs thatrequire an unnecessarily large amount of memory.andP;  One solution tothis problem is to sponsor industry-wide code-efficiencystandards.andP;  The need for conscientious programmers working towrite code that is efficient as possible cannot be overemphasized.andO;Many companies tend to make up for slow, unwieldy code by buyingmore powerful hardware, but this practice fails to ensure thatcode is as elegant and clean as it might be.andP;  The focus onportability and a preponderance of 'quick-and-dirty' code has alsoled to deterioration of the quality of programming.andM;</SUMMARY><DESCRIPT>Topic:     StandardizationMemory ManagementGraphics SystemsGraphics SoftwareProgram Development TechniquesCritiqueProgramming ManagementSoftware Design.andM;</DESCRIPT><TEXT>Software overhead that defies gravityandM;I have DECwindows running on various machines.andP;  It works pretty well, but theoverhead defies gravity,  In fact, in a brief test of required memory, aDECterm session needed almost 10 times more memory than an equivalent SETHOST session with DECnet.andP;  To create the DECterm session on a VAXstation3100, it took about 15 seconds to get it all arranged.andP;  On a VAXstation II,it was closer to a minute and a half, and the response was always sluggish.andM;I shouldn't be surprised, I guess.andP;  I have written DECwindows and X windowscode for some time and should be familiar with the overhead involved.andM;For instance, the code required to resize a window properly and space all thesubwindows, text, graphics and other displayable items proportionally after auser has dragged one corner of the window to a new location on the screen ison the order of 10 to 15 pages of C language (using Xlib and not the widgetsfor total control).andM;This further substantiates the general theory that the simpler it is to dosomething on a computer, the more code and overhead are required to make that&quot;something&quot; work properly.andM;Overhead comes from many places, some easily identifiable, some not.andP;  Certainsystem implementations of the VAX architecture, for instancE, do notimplement the entire VAX instruction set in hardware.andP;  In some cases, morethan 15 percent of the total instruction set in a VAX is implemented viasoftware microcode.andP;  In this manner, instructions are the same no matter whathardware-implementation restrictions might have existed when the system wasengineered.andM;The up side is that all code everywhere works.andP;  The downside is that emulatedinstructions can cause serious overhead if used a lot in an applicationprogram.andP;  For example, if the cyclic redundancy check (CRC) instruction is inhardware on one system and emulated on another system, it is quite possiblethe emulated system will be slower to compute CRCs, even if the CPU has ahigher MIPS rating than the non-emulated system.andP;  The effect of thisparticular instruction would be devastating because CRC's are usedextensively in VMS--and all networking products--to ensure that everythinggets to where it is supposed to go without loss of data.andM;This kind of overhead, which is unavoidable on some system types and maycause serious throughput problems, can be rectified only by purchasing a VAXmodel that supports hardware CRCs.andM;Sometimes overhead is just plain inefficient code.andP;  In the dark ages ofcomputing, we were required to keep code very tight because of systemrestrictions that allowed only program sizes defined by the hardware oroperating system architecture.andM;For instance, because of memory management restrictions, PDP-11s would permitprograms to be only 64KB in size while executing in memory.andP;  If a programwere privileged, the amount of memory available to map the total programcould be as little as 8KB or 4KB.andM;To create larger programs, programmers became very efficient and used atechnique called overlays (still seen in PDP and microcomputer code) to foolthe system so that programs could be physically larger than the amount ofallowable memory.andP;  By shifting pieces of code in and out of memory, a programusing the overlays technique could be much larger than the allowed memoryarea for the code.andP;  Using overlays required a programmer to be moreknowledgeable about the architecture and design of the system for which hewas writing.andM;With virtual systems, programs can be very large.andP;  Many times, the result isvery inefficient code, depending on the system manager's ability to tune thevirtual operating system to allow the program to execute when it is muchlarger than the available physical memory.andP;  Why custom-fit an array when theprogrammer can create a huge one very easily and use it without fearing thatthe program will fall on its face?andP;  The inefficiencies of such programmingtactics are obvious, but they are becoming the norm.andM;Recently I was messing with a code generator and was appalled at theinefficiency of the code generated.andP;  A call to the product maker turned up ageneral attitude of, &quot;Why are you all bent out of shape?andP;  It's for a virtualsystem.&quot;andP;  Just because a machine is virtual does not mean that its codeshould be large and sloppy.andM;An additional impetus not to worry about code efficiency is the availabilityto cheap hardware.andP;  Let's face it, it's much easier and less expensive todemand faster hardware than to try to optimize code for peak performance.andM;When I complained about DECwindows' performance to a fellow computing type,his response was, &quot;Buy a bigger box.&quot;andP;  I've heard that a lot lately.andP;  Butjust because bigger boxes are available doesn't reduce the responsibility ofthe programmer to produce efficient code.andM;Another reason for software inefficiency is that most software vendorsprovide every possible feature in the same program for all environments.andO;Again, it used to be that we would get programs intended for, and custom-fitto, specific items or environments.andP;  Now a vendor delivers aone-program-does-it-all solution (which it might)--but it does not do any onefunction in a particularly efficient manner.andM;Then there is the eternal cry of portability.andP;  With the cost of softwareskyrocketting, the need to be able to move code from one platform to thenext, more powerful and less-expensive hardware platform is essential in mostbusinesses.andM;The word portable, when used in the same sentence as the word software,conjures up thoughts of inefficiency.andP;  Sure, some software vendors attempt tomake their code efficient in all environments, but they quickly find that theeffort outweighs the cost involved and start writing everything as portableas possible--and efficiency goes into the gutter.andM;There are times that sites simply do not care about efficiency andperformance.andP;  One of my clients has a four-node, 8800-based VAXcluster thatis used to produce an astronomical amount of stickers for junk mailings.andP;  Getthis: There is not one line of traditional program code in the entire system.andO;Everything, and I do mean everything, is written in DCL.andP;  Honestly, some ofthe command procedures are more than 1,500 blocks in size!andM;Why?andP;  Simple.andP;  The client knows DCL, can find expertise easily, can makemodifications for custom mailings and can create serious applications in avery short time.andP;  I have harped about performance for year to this client,but any time things get a little slow, the client simply buys another 8800.andO;It's cheaper to add hardware than recode everything, and it's also mucheasier to endure a conversion between VMS upgrades with DCL than withexecutable images.andM;There are companies that worry about how to tune their systems or how tocompress their disk resources for optimal I/O and then turn loose a trashyprogram that uses antiquated scratch files or sorting algorithms.andP;  One sitethat I know of has every system-tuning aid available, and not one soul knowshow to use the tools nor interpret the information that the tols are tryingto convey.andM;Many other sites are in the same boat: They have the need and the technology,but no understanding.andP;  Some sites hire the understanding, in the form ofconsultants, but very few consultants know how to exploit this understandingin the fullest sense of the word.andM;Quick-and-dirty code and command files are often to blame for overhead aswell.andP;  Just think back to how many times the quick-and-dirty program orprocedure has become the application.andP;  More often than not, the applicationbecomes &quot;patch city&quot; and ends up looking extremely unlike the program thatwas originally created to solve a problem.andM;There is nothing wrong with quick-and-dirty code as long as it is temporaryor rarely used.andP;  The trouble is, it usually becomes the mainstay forcorporate usage (payroll, budgeting, etc.), and that's when the inefficiencycomes through.andM;Unfortunately, inefficient code is here to stay--for now, anyway.andP;  Also,unfortunately, maintainable coding techniques, such as modular programming,do not lend themselves well to performance on virtual systems; calling a newroutine causes context switching, so lots of modules cause lots of overhead.andM;Moreover, no one has come up with something better that permit modularity andmaintainability as well as performance.andM;Some of the better-known theories of software engineering and codingpractices were developed before the onslaught of virtual systems and extendedmemory code segments, so such methods include little consideration ofefficiency.andM;Maybe what we need are code-efficiency standards, similar to our networking,language, graphical user interface and other interface standards.andP;  Of course,that tends to make sense, so the chances of its gaining a ground swell ofmomentum are comparable to the eradication, in our time, of mouthwash bottlesarriving in the mail.andM;What we could really use are conscientious programmers who work at craftingefficient code.andP;  Although conscientious programmers are not a dying breed byany means, we have to stress the need for more of them.andM;Some coding environments--real-time domains, for example--requireperformance-oriented code.andP;  There needs to be more emphasis during theproduct development process on performance-oriented products and more timeallocated for programmers to work on the performance aspects of their craft.andM;With tight schedules and &quot;get-it-out-the-door&quot; management, writing efficientcode has taken a back seat to the completion of code.andP;  We need beter toolsets and code generators as well as programmer education about efficient codetechniques.andM;That way, we might get longer life out of existing systems and satisfy moreusers with fewer systems.andM;Getting more for less.andP;  Now there's an idea.andM;Bill Hancock is a principal at Network-1, a New York-based companyspecializing in network security and counsulting.andP;  He is also a member of theDECUS board of directors.andO;</TEXT></DOC>