<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-234-928  </DOCNO><DOCID>08 234 928.andM;</DOCID><JOURNAL>PC Week  March 12 1990 v7 n10 p89(4)* Full Text COPYRIGHT Ziff-Davis Publishing Co. 1990.andM;</JOURNAL><TITLE>C++ power demands new environments. (Software Review) (Zortech C++compiler) (evaluation)</TITLE><AUTHOR>Coffee, Peter.andM;</AUTHOR><SUMMARY>Zortech Inc's Zortech C++ is the only product available thatprovides a full development environment for the object-orientedC++ language.andP;  C++ is not directly supported by most majorsoftware vendors because debuggers for C++ are not yet assophisticated as those for ANSI C. The goal of C++ is to simplifythe construction of graphical user interfaces by replacing crypticlow-level code with object-oriented extensions.andP;  Characterconstants in C++ are a single-byte data type.andP;  Zortech C++ 2.0does not reject old-form C function declarations but may do so infuture editions.andP;  Stepstone Corp's Objective-C is a strongalternative to C++ that lacks the complete C++ feature set but ismore compatible with standard C. Other vendors emphasize CASEsupport and top-down design approaches.andM;</SUMMARY><DESCRIPT>Company:   Zortech Inc. (products).andO;Product:   Zortech C++ (Compiler).andO;Topic:     Computer-aided software engineeringProgram Development ToolsCompilersEvaluation.andO;Feature:   illustrationchart.andO;Caption:   Buyers cite source-level debugging, quality of code libraries asvital. (chart)andM;</DESCRIPT><TEXT>By Peter CoffeeandM;As corporate computing enters the 1990s, software developers face a dauntingcombination of growing complexity and rising user expectations.andP;  Manydevelopers believe that object-oriented techniques are a promising approachto these problems.andM;A relatively new programming language called C++ combines the benefits ofobjects with the technical and practical advantages of C, and it is gainingground among developers looking for the tools to tackle new tasks.andP;  C++ alsocompetes with other object-oriented dialects of C, and this article willreview the differences among these various solutions.andM;Despite developers' growing interest in C++, it has yet to be directlysupported by such major vendors of programming tools as Borland InternationalInc. and Microsoft Corp. -- though both are said to be working on C++products.andP;  The hopeful vendor must recognize, however, that it takes morethan just a compiler to realize the full benefits of object-orientedtechniques.andM;&quot;A fundamental trade-off is in the debugging arena,&quot; said Jerry Katzke, vicepresident for Software Development at Index Technology Corp. in Cambridge,Mass.andP;  &quot;The debuggers and environments for C++ are not yet where they are forC, and for the design methodologies that's even more true.&quot;andM;In fact, PC Week could identify only one PC-based C++ product as providing afull C++ development environment, including a source-level debugger (the No.andO;1 priority of PC Week readers in a survey conducted for this article).andP;  Thatproduct is Zortech C++, from Zortech Inc. of Arlington, Mass.andM;But even Zortech has a long way to go before it reaches the level ofworkstation-class products such as ObjectWorks for C++, from ParcPlaceSystems of Mountain View, Calif.andP;  (ObjectWorks for C++ is currently availableonly for Sun Microsystems Inc. workstations.)andM;These more advanced C++ environments -- still to come for the PC -- give thedeveloper far more power to use libraries of reusable software objects.andP;  Thequality and ease of access to such libraries were priorities No.andP;  2 and No.andO;3, respectively, among surveyed readers with interest in C++ (see table atright).andM;Developers facing the challenges of Presentation Manager can look forward togetting their hands on CASE:PM for CommonView, expected in early May.andP;  Thisproduct will combine the CASE:PM development environment, from CaseWorks Inc.andO;of Atlanta, with Glockenspiel's CommonView -- a library of C++ classes formultiwindow user interfaces available from ImageSoft Inc. of Port Washington,N.Y.andM;With few PC-based products currently available, but many having been recentlyannounced or expected in the near future, a comparative review would be oflittle use and would soon be obsolete.andP;  Instead, PC Week takes thisopportunity to examine C++, as a technology, in the overall context of objecttechniques: a controversial mix of substantial long-range benefits andsignificant short-run costs of adoption.andM;The C programming language has been highly successful as a tool for buildinghigh-performance applications on a wide range of computers.andM;As a language, it is relatively small, and a C compiler is often the firstdevelopment tool to become available for a new machine.andP;  C provides goodfacilities for efficient manipulation of data structures, and its use offunction libraries has made it a foundation of development in many differentproblem domains.andM;On the downside, however, C has done nothing to aid developers in facing thethree key components of today's growing complexity in software: thecomplexity of data, the complexity of the modern user interface, and thecomplexity of multiple and/or distributed platforms.andM;In the area of data, for example, C is famous for giving developers enoughrope to hang themselves.andP;  A C function that has been told to print an integerwill produce meaningless results if the argument actually supplied is afloating-point number.andP;  C does little to help the developer stay on top ofmodern applications involving a growing variety of highly structured datatypes.andM;As a relatively low-level language, C also does little to aid the developerin managing the common, but intricate, elements of the graphical userinterface.andP;  Rather, the C developer faces constant demands for hands-onmanagement of memory and other housekeeping functions that distract from theproblem at hand.andM;Many C conventions are also tied closely to hardware -- for example, thenotion of the &quot;natural size&quot; of an integer (which depends on the underlyingarchitecture).andP;  Moving a densely coded system in C from one platform toanother often reveals many hidden dependencies of this kind.andM;For the harried C developer, C++ represents a sort of urban renewal forsoftware.andP;  It seeks to build a clean, well-lighted city of long-lived,reusable software objects on the existing foundation of available programmerskills.andM;Eventually, its goal is to replace the ghetto of cryptic, hard-to-maintaincode that currently makes it so difficult to build large or complicatedsystems.andM;To be sure, object techniques are supported by many other languages as well,from Smalltalk to Actor to Turbo Pascal.andP;  Even the COBOL standard may soon beextended with object-oriented features.andM;Unlike most other object languages, however, C++ was designed in thetradition of C: Specifically, it minimizes the cost in machine resources oflanguage features that are not actually used in the particular program athand.andP;  The massive run-time environments of many other object languages(which are often interpreted, rather than compiled) are far less credible forcost-effective delivery of applications.andM;There are, however, several significant differences between C++ and C.andO;Proponents of the language have billed C++ as a simple extension of C, addingonly object facilities, in the same way that objects were recently added toBorland's Turbo Pascal.andP;  Proponents often assert that one can move into C++incrementally because a C++ compiler will pass ordinary, &quot;vanilla&quot; C codestraight through.andP;  This is not entirely accurate.andM;For example, character constants (data values corresponding to a singleletter or other symbol) in C++ are a distinct, single-byte data type, asopposed to the C convention in which characters are treated as alternativenames for integer numbers (and represented as &quot;naturally sized&quot; integerdata).andP;  The C++ approach should not cause problems unless a poorly writtenprogram has used numbers (rather than the preferred 'X' format) to representcharacter constants in source code.andM;Other differences arise in the notation used for definitions of functions.andO;In ANSI C, a function that is declared with an empty argument list (forexample, &quot;functionname( )&quot;) takes an unspecified number of arguments withunspecified types.andP;  In C++, however, this notation indicates a function thattakes no arguments.andP;  Such code can be rewritten, using the notation&quot;functionname(void),&quot; to make it portable between C and C++.andM;Updating Old C CodeandM;A C++ compiler may also reject old-form function declarations, in which thefunction name and argument list are followed by the types and names of thearguments.andP;  Old C code may have to be updated with ANSI-style functionprototypes (recommended, but not required for ANSI C) before it can be usedunder C++.andM;Some of these difficulties can be overcome by a considerate implementation ofthe language.andP;  Zortech C++ version 2, for example, continues to support theold format for argument types as a way to ease the transition, but Zortechofficials warn that this support may not continue in future versions.andM;Differences such as these have sparked debates among those serious about C.andO;&quot;The only reason we are talking about using C++ or Objective-C is because ofa desire to be 'upwardly compatible' with existing C code,&quot; said onedeveloper in a discussion on ARPAnet.andP;  &quot;Note, however, that C++ is not'upwardly compatible' with C. Rather, C++ is a different language.andP;  Just tryincluding andless;sunview.handgt; [a header file for the windowing system on Sunworkstations], and you will see what I mean.andP;  Or any large C language program-- it won't compile with a C++ compiler.&quot;andM;Others, however, take a less restrictive view of what it means to say thatC++ is a natural growth path from C. &quot;C++ is programmer-compatible with C,&quot;said another developer during the same network discussion.andP;  &quot;You can take alarge project with a bunch of C programmers and have them writingworking-equivalent C++ programs in a day or less.andP;  You can convert yoursystem from C to C++ a module at a time.andP;  You can write large systems thatwill compile in both C++ and ANSI C without change and do the same thing.andM;&quot;A good C++ programmer,&quot; he said, &quot;can convert about 1,000 lines of old C perhour to C++.andP;  Converting ANSI C should be faster.&quot;andM;A third developer offered a specific example.andP;  &quot;I recently converted a screeneditor that I maintain to be compilable under both C++ and C. It was [about]25,000 lines of C code -- not very well-designed, but highly portable.andP;  Ittook about two days.&quot; He added, &quot;Debugging time for the C++ version [aftermaking it compile] was zero.andP;  It worked right off the bat.&quot;andM;Once over the hump of conversion, developers will find that C++ provides anumber of features in addition to objects.andP;  One is the ability to passparameters by reference.andP;  In C, the novice is often initiated into the use ofpointers to deal with the fact that C can only pass the value of a parameter,not the parameter itself as a data object to be modified.andM;If a function in C is supposed to produce a side effect (that is, to change adata value that persists after returning from the function), then theargument to the function must be a pointer to that value; the function mustthen, in turn, use that pointer to find the data to be modified.andM;This gets further confused by the exceptional treatment of arrays: An arrayis passed as the value of its starting address, in effect passing it byreference.andP;  The topic of value vs.andP;  reference is a common cause of earlydifficulties for the C novice.andM;In C++, by contrast, the new &quot;reference&quot; operator provides a notation that issymmetric between the calling and called functions.andP;  This makes programs morereadable, and reduces the chance of errors by generating the referenceautomatically.andM;Other benefits of C++ include explicit support for declaring in-linefunctions, and streamlined procedures for allocation and recovery of storage.andM;In summary, C++ begins with the semantics and notation of C, then addsstronger support for tracking of data types across functions.andP;  With thissupport, C++ lets the developer take advantage of these type-checkingfacilities to manage special-purpose, abstract data types defined by theprogrammer -- that is, classes of objects.andM;Such a data type -- an on-screen window, for example -- can be treated as anobject that responds to messages.andP;  A new class of objects can use &quot;multipleinheritance&quot; to borrow the properties and behaviors of one or morepre-existing groups of objects.andM;There's more to object-oriented C than C++.andP;  Developers should also considerother solutions that add the power of objects to the experience base of C.andM;The strongest alternative to C++ is Objective-C, from Stepstone Corp. ofSandy Hook, Conn.andP;  This dialect is the foundation of the NextStepsoftware-development system: the powerful, object-oriented tool set includedwith all NeXT Inc. workstations, and also licensed by IBM for the AIXNextStep Environment/6000 on the new IBM RISC System/6000 Powerstations.andM;Stepstone has addressed the demands of object-oriented development with aninterpreter/debugger and extensive class libraries, and supplies versions forplatforms from the AT-class PC up through the NeXT and other high-endworkstations.andM;Developers comparing C++ to Objective-C have found that Objective-Crepresents a smaller change in the foundation language, C, though some feelthat this appearance is deceiving.andM;&quot;Objective-C is 'simple,' &quot; noted one developer, &quot;because it lacks thecomplete feature set that C++ is striving for, which is needed to solve allcommon programming problems.andP;  But if you're writing serious code you stillhave to address these needs.andP;  In Objective-C you have to do this by writinghack C code or assembly code based on an understanding of Objective-C'sunderlying implementation in the C language.&quot;andM;Satisfaction Hinges on UseandM;This developer acknowledged, however, that satisfaction with a tool has a lotto do with how it is being used.andP;  &quot;Some people who seem to be pretty happyworking with Objective-C,&quot; he observed, &quot;are those people who are using it toencapsulate window graphics routines written in C or assembly.andP;  In thesecases, most of the processing time is spent in the low-level graphicsroutines so that the Objective-C overhead is less of a problem.&quot;andM;C++, by contrast, has emphasized the goal of minimum overhead to preserve theefficiency that has long been a hallmark of C. This comes, however, at theexpense of what many find to be a more awkward syntax and a greater overallfeeling of complexity in the language.andM;Until recently, there was a major non-technical difference between C++ andObjective-C: C++ was being implemented by many different vendors, withcompetition accelerating its development, while Objective-C was a proprietaryproduct of Stepstone.andP;  (It remains to be seen whether C++ competition willproduce effective standards or merely awkward confusion.)andM;More recently, however, Objective-C has been second-sourced by both NeXT andIBM; NeXT now ships its own version of the language, while IBM has elected tocontinue working with Stepstone.andP;  The IBM package includes Stepstone'sfoundation library of 20 base classes (supporting advanced data structuresand input/output functions) along with the Objective-C compiler for extensionof NextStep's classes.andM;As mentioned above, a prerequisite to the effective use of objects is theability to track relationships between classes.andP;  Existing code cannot verywell be reused if one cannot find out that a suitable &quot;ancestor&quot; isavailable.andP;  In Objective-C, this need is met by a sophisticated &quot;classbrowser&quot;; a similar tool is available from CNS Inc. of Eden Prairie, Minn.,andO;for use with its proprietary dialect Ctalk (see &quot;Tools Offer Shortcut toWindows Applications Development,&quot; PC Week, Sept.andP;  11, 1989, Page 47).andM;Ctalk's browser is much like that of the popular Smalltalk/V environment fromDigitalk Inc. of Los Angeles.andP;  The Ctalk browser makes it easy to track thesingle inheritance relationships supported by the language.andM;The CNS Ctalk/Views class library is well-suited to programming for MicrosoftWindows, competing for this role with ImageSoft's CommonView library.andM;CNS recently announced plans to produce these class libraries in versions foruse with other languages, including both C++ and Objective-C.andM;Ctalk requires the Microsoft C compiler and Microsoft Windows SoftwareDevelopment Kit; Zortech also provides directions for the use of its C++compiler, in lieu of Microsoft C, for Windows development.andM;The C++ tools currently available for the PC do not address the fullpotential of object techniques.andP;  Zortech, ImageSoft and other C++ vendorswill need to offer (among other utilities) browsers supporting multipleinheritance before programmers will be able to make full use of the classlibraries that they create.andM;CASE TechniquesandM;A central theme of this article has been the need to use objects in general,and C++ in particular, as part of an overall development strategy -- anelusive goal, even for well-established languages.andP;  Indeed, the challenges ofeffectively using C++ are much like those facing the developers ofcomputer-aided software engineering (CASE) tools in general.andM;One such vendor, Index Technology Corp., has chosen C++ as the implementationlanguage for its next-generation tools.andP;  The Index approach is yet more proofthat C++ as a language alone is not a complete solution: Index has alsolicensed object-oriented database technology from Ontologic Inc. ofBillerica, Mass., in pursuit of its development goals.andM;The Ontologic approach is &quot;far superior for CASE than relational databases,&quot;said Jerry Katzke, vice president of software development at Index, &quot;becausein CASE you essentially have many objects that are closely intertwined witheach other.andP;  You want to be able to pick up an object and get all the objectsassociated with it, where with relational databases it's most efficient todeal with multiple instances of similar objects.&quot;andM;This brings up the broader question of the appropriate design approach tomake the best use of object techniques in future applications.andP;  Most existingtools focus on &quot;top-down&quot; design.andM;Top-down design begins by defining what a system is supposed to do -- forexample, &quot;produce and send customer invoices&quot; -- and then refining thatstatement into more specific subsidiary functions.andP;  This not only encouragesa concentration on the purpose of the system, with an emphasis on achievingdesign goals, but it also creates problems in the three areas of challengefor 1990s applications: the complexity of data, the sophistication of theuser interface and the variety of back-end hardware platforms.andM;Varied sources and uses of data make it hard to characterize modernapplications as having a clearly defined top-level function.andP;  Imagine atop-down definition of a modern word processor, withwhat-you-see-is-what-you-get (WYSIWYG) editing, mail merge and integratedelectronic mail.andP;  Where is the top of such a system?andP;  By contrast, objectscould be thought of as supporting a &quot;cluster-out&quot; approach.andP;  One identifiesclusters of desired behaviors and develops classes of object to support them.andM;Another problem of traditional top-down design has been frequent inability toreuse the resulting code.andP;  When each fragment is a result of step-by-stepdecomposition of a particular problem, the odds are low that any of thelow-level results will be useful for any other problem that may arise.andM;By contrast, the cluster-out approach of objects encourages the design andconstruction of complete definitions for the common components ofapplications.andP;  Such components might include menus, windows, relationaldatabases or file system interfaces.andM;A third problem with top-down design has been its lack of abstraction.andO;Top-down design breaks up the functions of the system in a clean,understandable way, but the dirt builds up at the bottom level -- that is, itbecomes easy to view the bottom-level functions as primitives that may aswell be written to work directly with the hardware.andM;Good design argues against this, but top-down development as a method doesnothing to discourage it.andM;By contrast, the object-oriented approach of sending messages (rather thanmanipulating resources directly) encourages abstraction away from the detailsof the platform.andM;Management InvolvementandM;Conversion to object techniques is not just a technology change, but amanagement change as well.andP;  Management will have to support the idea ofspending extra time and money up front to build libraries oriented towardtheir particular tasks.andP;  The quality and productivity of object techniquesdon't come free; they come as dividends from this investment.andM;Even the best C++ environment has no intrinsic power to turn the journeyman Cprogrammer into a far-seeing architect of robust, reusable classes.andP;  &quot;C++ isgoing to require a higher skill level among its practitioners,&quot; said onedeveloper, adding, &quot;I have no problem with that.andP;  I think the time for'amateur' code pounders is rapidly passing.&quot;andM;Object techniques in general, and C++ in particular, will not make difficulttasks trivial -- but they will, with proper planning and support, make thempractical at a competitive cost.andO;</TEXT></DOC>