<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-285-282  </DOCNO><DOCID>07 285 282.andM;</DOCID><JOURNAL>Computer Language  Jan 1989 v6 n1 p34(10)* Full Text COPYRIGHT Miller-Freeman 1989.andM;</JOURNAL><TITLE>Designing with objects. (object-oriented programming )</TITLE><AUTHOR>Bailey, Stephen C.andM;</AUTHOR><SUMMARY>The introduction of structured analysis, design and programminghave changed programming dramatically since 1979.andO;Block-structured languages have evolved and developed as a result.andO;Reusable code and top-down design make pathological connectionsand spaghetti code a thing of the past.andP;  The latest fad word insoftware is 'object-oriented.' C++, Smalltalk, and frame-basedexpert systems have all been added to the object-oriented arsenal.andO;The term object-oriented means different things to differentpeople, but it is basically a an attitude toward programming,equivalent to structured programming.andP;  To appreciate theobject-oriented approach, the programmer must learn the value ofthe creation and use of abstract data types.andP;  The object-orientedapproach is applicable to every manipulation of every type of datastructure.andP;  One aspect of object-oriented programming discussed isthe concept of data abstraction.andM;</SUMMARY><DESCRIPT>Topic:     Object-Oriented LanguagesProgram Development TechniquesProgramming InstructionType-In ProgramsAbstract Data Types.andO;Feature:   illustrationchartprogram.andO;Caption:   Analysis diagram and object hierarchy chart. (chart)Object-oriented program listings. (program)andM;</DESCRIPT><TEXT>Designing with Objects Programming has changed dramatically.andP;  During the last10 years, we have been introduced to the concepts of structured analysis,design, and programming.andP;  We have witnessed the development and evolution ofblock-structured languages.andP;  And we have enjoyed the fruits of the structuredrevolution.andP;  Use of and focus on structure have helped to eliminate much ofthe spaghetti code of the past.andP;  Programmers everywhere have begun toconceive of reusable code, eliminate pathological connections, and takeadvantage of top-down design.andM;The newest buzzword in software today is &quot;object-oriented.&quot; Object-orientedweapons that have recently been added to the programmer's arsenal includeC++, Smalltalk, and frame-based expert system.andP;  We are continually exposed toobject-oriented this and object-oriented that, and it is often very difficultto understand exactly what &quot;object-oriented&quot; means in any given context.andM;To make matters worse (or perhaps this is the root of the problem), the term&quot;object-oriented&quot; means something different to everyone who uses it.andP;  To aSmalltalk programmer, &quot;object-oriented&quot; has something to do with classes andmessage-passing.andP;  To a frame-based expert system developer, it meansinheritance of methods and data values.andP;  To a C++ designer, it includesoperator overloading and information hiding.andP;  To an Ada programmer, it has todo with packages.andM;This article treats object-oriented programming not as a rigorous,well-defined technology but as an attitude.andP;  In this way, it is similar tostructured programming.andP;  Programs are structured because they have a certainlook and feel, not because they follow a well-defined set of rules.andP;  Thebenefits of structured design, analysis, and programming have been achievedbecause developers have adopted a new attitude with regard to their work.andM;The purpose of this article is to expose the benefits of an object-orientedapproach and show how these benefits can be achieved.andP;  It will introduce youto a new attitude about programming and system design.andP;  You do not need tolearn a new language or development environment to achieve these benefits.andO;What you must learn is the value of the creation and use of abstract datatypes.andP;  This article focuses on only one aspect of object-orientedprogramming: the concept of data abstraction.andM;The benefits to using an object-oriented approach to systems development arenumerous.andP;  You can expect cost savings during the development and maintenanceprocesses and, perhaps best of all, you can expect the number of bugs thatmake their way into finished products to be dramatically reduced.andM;Design principlesandM;Top-down development has the following basic structure.andP;  Analysis is done todetermine the processes and data flows involved in a system.andP;  Certainprocesses are specified for automation.andP;  The processes are decomposed intosmaller and smaller subprocesses by designers until single-function modulesare created.andP;  These are coded and unit-tested and then integrated andsystem-tested.andP;  The executables of the system are all completed, and thecomplete system is assembled and given an acceptance test.andP;  The method isintrisically process-oriented.andM;Programmers focus on processes because that is their job--to make thecomputer perform some procedure accurately and repeatedly.andP;  Analysts focus onprocesses primarily because most analysts are or used to be programmers.andM;Like structured development, object-oriented development follows the classicwaterfall model: analyze, design, implement units, implement programs,implement systems, validate and verify, and maintain.andP;  But the key secretbehind object-oriented procedures is that immediately after the analysis iscomplete, object-oriented designers focus on the data, not the processes.andM;Object-oriented development is data-driven.andP;  If you take all of the data in asystem and normalize it, each fully third normal form structure is anexcellent first approximation of each of the objects that need to bemanipulated.andP;  Every third normal form structure stands alone as an entity.andO;Each has its own set of processes and procedures that manipulate it.andP;  Theseprocesses can be defined independently of all other objects.andM;Clearly, many of these third normal form objects need to work together toperform some larger function.andP;  For example, price and part data can becombined with quantity data to form an invoice.andP;  The invoice is an object aswell, with methods and procedures of its own.andM;The interface between the invoice object and the part and price objects canbe clearly defined.andP;  If any invoice process needs to know data about a part(for example, the cost to manufacture it in quantities of 100), it should notembed within itself information about how to obtain that data.andP;  It shouldsimply ask the part object for it.andP;  There should be a specific part-objectprocess for calculating this information, and any invoice process that neededthe data would call this one routine.andP;  This is the concept of informationhiding.andP;  It is the basis of modularity.andM;But an object-oriented approach is not limited to database applications.andP;  Anormalized data structure is simply one type of data structure, and datastructures in general are the foundation of all programming efforts.andP;  Evenprograms with no file accesses at all have some internal data structures,whether they are arrays, structures, or static global variables.andO;Object-oriented methods are applicable to every manipulation of every type ofdata structure.andM;Development exampleandM;I have chosen as my example the development of a computer program thatperforms all the basic mechanics of a game of seven-card stud.andP;  It doeseverything but bet intelligently (that enhancement is left to the reader).andM;I will skip the analysis phase and move directly to the design phase, partlybecause analysis can remain relatively unchanged under an object-orienteddevelopment cycle.andP;  (Although analysis can remain relatively unchanged, thereare a large number of reasons why it should not.andP;  I do not go into thesereasons here because my goal is to show how the basic concepts of anobject-oriented approach can be implemented with minimal disruption.andP;  Forinformation on one of the best object-oriented analysis methods, see Mellorand Schlaer, 1988.)andM;To a large degree, analysis is not really necessary here because therequirements are clearly understood.andP;  You buy into a game with an ante, youreceive one or more cards, you bet to buy additional cards, and the winnertakes the pot.andP;  When you're broke, you go home.andP;  If, however, you are apurist or you really need to start with the analysis, you will find a diagramin Figure 1.andM;Object-oriented methods have their first real impact in the general designphase.andP;  Designers are supposed to develop structure charts before anyprogramming takes place.andP;  The structure chart is used to show eachfunction-subfunction relationship within a program and specify the workperformed by each routin at each level.andP;  The chart clarifies the design andaids the partitioning of the job among numerous programmers.andP;  (Unfortunately,in too many cases, the structure chart is made after the coding phase iscomplete, usually at the insistence of someone who feels that some type ofdocumentation is necessary.)andM;Under an object-oriented approach, designers should still develop structurecharts, but not the type of charts you're used to.andP;  The subroutine andcontrol hierarchy chart should be replaced by an object hierarchy chart.andO;This type of chart does not represent the subroutine organization of aprogram; it represents the data organization of it.andM;Figure 2 shows an object-oriented structure chart for the example program.andP;  Agame of seven-card stud is conceptually composed of players with poker handsand chips, a pot, a deck of cards, and some way of displaying the progress ofthe game to the user.andP;  (This is, after all, a computer program playing poker,not Saturday night at a friend's house.andP;  Smoke and beer have not beenincluded.)andP;  The hierarchy shows that a deck and a poker hand are bothcomposed of cards, and a pot contains chips.andM;The final task of the general design phase is to select an implementationlanguage.andP;  I have chosen C because I like it, it is popular, and it has twofeatures I need: function pointers and structures.andP;  I will use C in a mannerthat may seem foreign to you.andP;  I hope you will see it as an elegant exampleof how far you can push the object-oriented approach using conventionallanguages.andM;Detailed 'designandM;With object-oriented development, the purpose of the general design phase isto describe the class hierarchy of the system; that is, describe all of theobjects to be manipulated and indicate which objects are subordinate to whichothers.andP;  During the detailed design phase, the purpose is to specify all ofthe methods that act upon these objects.andP;  A method is nothing more than afunction or subroutine call; I use the terms &quot;function&quot; and &quot;method&quot;interchangeably.andM;I prefer to start my specification at the bottom of the chart.andP;  This way, Ican assemble and test my system one component at a time.andP;  Let's pick anobject off the bottom of the structure chart to use as an example: cards.andO;What is the data structure of a card?andP;  The implementation of the card classis as follows.andP;  (Since I am going to use function pointers, I might as welluse enums as well.andP;  My apologies to those of you with C compilers that do notsupport enums or do not allow duplication of names in different contexts.andP;  Iuse Microsoft C.) struct card [ enum rank rank; enum suit suit; ];andM;A card has two basic data components: rank and suit.andP;  What methods areappropriate for a card (keeping in mind that we are focused just on the cardand not the deck)?andP;  Obviously we need to be able to determine the rank of acard as well as the suit.andP;  You may think we need a method to compare twocards (I know I did).andP;  If you think about it, though, you will realize thatthe ranks of a card have no real value except in the context of the gamebeing played.andP;  An ace is just an ace.andP;  It is the high card in some contextsand the low card in others.andP;  In fact, in the card game of euchre, a jack canbe promoted to the highest card of all.andM;Consider the difference between a deck of cards and a single card.andP;  Poker,pinochle, and euchre decks are three different types of decks.andP;  The onlything they have in common is that they are all composed of cards.andP;  Cards arepieces of paper (or here, electronic structures) with ranks and suits.andP;  Youmust be able to determine the rank and suit to play a game.andM;What is not obvious is that since different decks are composed of differentcards, the ranks and suits involved in any game cannot be known in advance.andO;Therefore, we need a method to initialize the face value of a specific cardso a deck can be created.andP;  Since we will have to display the cards on thescreen, we also need routines to translate the rank and suit values intostrings or pictures that can be displayed.andP;  I chose to use strings to makelife easier.andM;Every object requires four additional, generic functions.andP;  In the C++language, these are known as contstructors and destructors.andP;  In normallanguage they are known as initialization and clean-up routines.andP;  The fourfunctions are class constructor, object (or instance) constructor, object (orinstance) destructor, and class destructor.andP;  A class constructor contains allof the initialization logic that must be performed once before any objectsare created.andP;  For example, the class constructor for the deck classinitializes the random number generator (since dealing cards is a deckmethod).andM;An object constructor contains all of the initialization logic that must beperformed once before any object can be used.andP;  For example, the objectconstructor for a deck object must initialize that deck.andP;  This function willbe called once for every deck that a game requires.andP;  It is passed the type ofdeck to create (with or without jokers, for instance), and it fills aninternal array with cards of the appropriate type.andP;  This needs to be doneonly once per deck.andM;I have not included any destructors in my example.andP;  I did not need them (andfrankly, I didn't realize their value until this article was nearlycomplete).andP;  Good programming style would require all objects and all classesto be destroyed before the program terminates.andP;  The absence of valuable orimportant logic in a destructor should never be taken for granted.andP;  Thatwould violate the principle of information hiding.andM;Destructors would be necessary, for example, if the constructor actuallyallocated space for the object or allocated space for arrays held in theobject structure.andP;  It would be the job of the destructor to free that memoryand mark the object structure as invalid so it could not be reused.andP;  A classdestructor could be used to update and close a file opened by the classconstructor.andM;C++ provides automatic access to these functions.andP;  In standard C and otherlanguages, you have to call them yourself.andM;Object-oriented programmingandM;Once the design phase is complete, the fun part--coding--begins.andP;  Likeobject-oriented design, object-oriented programming is more an attitude thana set of rules.andP;  It is an effort to implement a class while preserving thedesign concepts of modularity, data encapsulation, and information hiding.andM;No designer can consider every design issue in advance.andP;  Programmers have tomake a considerable number of implementation decisions.andP;  The guidelines forthese decisions are to retain modularity, data encapsulation, and informationhiding.andP;  These three concepts create the real benefits of the object-orientedrevolution and are as important during programming as they are during design.andM;One of the primary tenets of both structured and object-oriented methods ismodularity.andP;  Under an object-oriented approach, &quot;module&quot; is synonymous with&quot;class.&quot;andP;  Each class is treated as a unit.andP;  It is defined, designed, built,and tested as an independent unit.andP;  The only reason to consider another unitwhile designing and building a class is to ensure that all of the requiredinterfaces have been offered.andM;Depending on the language used, modules can be implemented in a number ofways.andP;  I have chosen to implement every class as a single file with one ormore associated headers.andP;  If you need to work on a class method, you alwaysknow where to look.andP;  I have used eight-character names for the class so thefile name is the same as the class name.andP;  I have used long, descriptive namesfor all of the methods.andM;Data encapsulation is primarily handled during the design phase.andP;  However, itcan become an issue during programming.andP;  Frequently, what initially appearsto be one object is found to be composed of subobjects.andP;  The programmer anddesigner must always get together to determine the appropriate encapsulationand interfaces for all of the objects to be created.andM;Ihave chosen to define one data structure for each class.andP;  I find that whenall the data does not fit nicely into one structure, two or more classes areprobably required.andP;  This simplistic approach may not work in every instance.andO;Notice, though, that a third normal form data table can always be easilyrepresented by a single matching data structure.andP;  Object-oriented methods canbe easily extended to database applications simply by mapping all data tablesto leaf nodes in the class hierarchy.andM;The most difficult programming issue to enforce is information hiding.andP;  Theidea is to hide from other portions of a program or system the implementationof those decisions that are most likely to change.andP;  Nothing changes moreoften during maintenance and enhancement than data structures and theiraccess, storage, and modification procedures.andM;Information hiding means the logic of all data structure access, storage, andmodification routines should be hidden from routines not specificallyinvolved with the structures.andP;  Since the logic of any process depends on thestructure being manipulated, the structure of the object itself should alsoremain hidden.andP;  The object and its methods should be what is commonly calleda black box.andM;Implementation detailsandM;Listings 1 and 2 contain two of the header files that implement the card datastructure.andP;  I have chosen to separate constants (placed in .h files) fromclass definitions (placed in .s files) and global data (placed in .g files).andO;There is no other reason for keeping these files separate.andM;I have chosen for my implementation a style patterned after BjarneStroustrup's implementation of classes in C++.andP;  I use this style to emphasizethe black-box aspect of objects.andP;  Refer to Listing 2 and the header filecard.s.andP;  This header file contains every aspect of the definition of the cardclass.andM;Examine this header from the bottom up.andP;  At the bottom is the actualdefinition of the structure that implements the class object.andP;  This structurehas two primary components: a data portion (at the top) and a pointer to amethods structure (at the bottom).andP;  I could have placed a pointer to each ofthe methods inside the structure.andP;  However, if implemented as far pointer,this mechanism would have added 20 bytes to a four-byte structure.andP;  Thisproblem compounds as the number of methods increases.andP;  Instead, I havedefined a methods structure that supplements the class structure.andM;The methods structure is defined immediately above the class structure.andP;  Itcontains a pointer to each of the defined methods along with a functionprototype of each.andP;  This enables the compiler to type-check each use of thefunction.andM;Immediately above the definition of the methods object is a definition offunction prototype for the class and instance constructors (also present toenable type checking by the compiler).andP;  If destructors were defined, functionprototypes for them would be placed here as well.andM;Finally, at the top of the header are type definitions for the class and themethods structures.andP;  A separate type definition is made for the methodsstructure to minimize the overhead associated with making a function call.andM;Listing 3 shows the implementation of the deck class and object constructors.andO;The class constructor is used to initialize a static global methods structure(not shown) with pointers to all of the class methods.andP;  The object instanceconstructor is used to initialize the methods structure pointer in everyobject created.andM;These procedures allow every method to validate all objects it is passed.andP;  Ifthe class constructor has not been called, none of the methods can beaccessed.andP;  If the object constructor has not been called, the methods pointerwill not be correct.andM;Notice that the deck class constructor performs a necessaryfunction-initialization of the random number generator.andP;  It also invokes thecard class constructor since this class is required by one or more of thedeck methods.andM;Ihave written all my constructors so they can be called repeatedly without anerror.andP;  In this way, each class constructor can ensure that every subclass itneeds has been created.andP;  Notice also the object instance constructor.andO;Whenever a deck object is created, a deck array must be initialized.andM;Listing 4 contains the definitions of all of the card class methods alongwith C code for one of them.andP;  The code for the remaining routines isavailable from the COMPUTER LANGUAGE Bulletin Board service and CompuServeforum.andP;  You will notice that all of the functions that implement classmethods are static.andP;  They cannot be called from outside this file.andP;  The onlyglobal entry points in this module are the class and instance constructors(the destructors would also be global if they were present).andP;  Notice thatpassed card objects can easily be validated by method routines.andM;On the surface, this seems like an awful lot of work just to write afunction.andP;  I use this style because it creates an explicit connection betweenthe data of the object and its functions.andP;  The style does generate, as aby-product, a header file that documents the essentials of the class and itsmethods.andP;  It is useful documentation and much more than I used to seeingduring maintenance operations.andM;Using a defined classandM;The code fragment in Listing 5 is from the Playing Cards function called bythe deck object constructor.andP;  It is not a deck method.andP;  It is a function thatsupports the object constructor by creating a playing card deck.andP;  The codefragement in Listing 5 shows how a card class method is put to use.andP;  Noticethat a doubly indirect structure reference is made to obtain a pointer to thecard class method SetCard.andP;  The methods pointer from the initialized objectis located and the pointer to the function that establishes the face value ofa card is obtained.andP;  This pointer is dereferenced to make the function call.andM;This is certainly a lot of overhead to go through to make one call.andP;  Toimprove efficiency, I have placed the function pointer into a local variablethat I use instead.andP;  It is important to keep in mind that the card structuremethods pointer will not have the proper address in it until after the cardclass constructor has done its work.andP;  Notice also that every object must beconstructed before it can be initialized.andM;It may occur to you that the initialization could be easily done withinnested loops, the outer loop running from (int) Clubs to (int) Spades and theinner loop running from (int) Two to (int) Ace.andP;  This would certainly cut outa lot of repetitive code and would work equally well.andM;Unfortunately, it would violate the definition of information hiding.andP;  Thevalues and orders of the rank and suit enums are the property of the cardclass, not the deck class.andP;  If a new game that used some new card ranks wereto be added, the card class would have to be updated to allow these cards tobe created.andP;  If a new card were to be inserted between 10 and jack, thisroutine would begin to create invalid decks the first time it was recompiled.andO;That could be months or years after the new card was added.andP;  The bug would behard to locate because no one would think to look here for code that requiresan understanding of the card class internals.andM;To truly remove the enum values from any consideration, a third data fieldmay need to be added to the card class data structure: relative value.andO;Relative value would be defined when the rank and suit of the card weredefined and would be used to rank cards with respect to one another in thedeck.andM;Object-oriented developmentandM;The methods shown here do not require any programmer or analyst to learn anew language.andP;  They do not even require the learning of a new concept.andP;  Thebasic concepts are all inherent parts of structured methods.andP;  All you need tolearn is to apply them first to data and then to processes.andM;Object-oriented development does not generate a fundamentally differentcomputer program.andP;  It merely generates the same functionality in a differentway.andM;Building black boxes is the essence of an object-oriented developmentapproach.andP;  By focusing on the data in a system, you can readily determineappropriate encapsulations.andP;  This is substantially more difficult when youhave a primary focus on procedures.andP;  By encapsulating stand-alone objects,you can hide the implementation decisions behind standard interfaces.andP;  Eachblack box you create can then be kept in one single or a few related modulesand used to assemble any number of systems.andM;Object-oriented methods are truly an evolution of structured methods.andP;  Whatis new with is the idea of focusing on the data.andP;  Once you have defined yourobjects, all functions (or methods) would be created with standard structuredtechniques (such as sequential decomposition).andM;Object-oriented methods are here to stay.andP;  Their primary benefits arise fromthe use of modularity, data encapsulation, and information hiding.andP;  You donot have to buy and learn a new language to obtain these benefits.andP;  You dohave to make a fundamental change in the way you look at the developmentprocess.andP;  You must begin to implement the concept of object-orienteddevelopment by understanding and using these data abstraction techniques.andP;  Ifyou put your attention on the data before you consider the processes, youwill wind up with much better algorithms that can be developed.andO;</TEXT></DOC>