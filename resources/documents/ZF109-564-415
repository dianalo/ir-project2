<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF109-564-415  </DOCNO><DOCID>09 564 415.andM;</DOCID><JOURNAL>Communications of the ACM  Oct 1990 v33 n10 p63(12)* Full Text COPYRIGHT Association for Computing Machinery 1990.andM;</JOURNAL><TITLE>NEST: a network simulation and prototyping testbed. (DiscreteEvent Simulation) (technical)</TITLE><AUTHOR>Dupuy, Alexander; Schwartz, Jed; Yemini, Yechiam; Bacon, David.andM;</AUTHOR><SUMMARY>Agraphical language environment called Network Simulation Testbed(NEST) and its use in simulating and modeling distributed computernetworks are analyzed.andP;  NEST helps distributed system designerssimulate and create network operations in a UNIX environment,using an environment-based approach rather than the more typicallanguage- or model-based methods.andP;  Various load configurations andfailure responses in on-line transaction processing can bemanipulated with simulated prototypes.andP;  NEST includes standardmonitor tools to develop the network simulation and link it tocommunication and node functions written in the C programminglanguage by the designer.andP;  The programming or the graphics toolsmanipulation can be used to alter the simulation to examine andtest different conditions.andP;  NEST acts not only as a simulator forarbitrary network architectures but also as a prototyping tool foractual system development.andM;</SUMMARY><DESCRIPT>Topic:     Distributed ProcessingSimulation of Computer SystemsOperating EnvironmentsGraphics LanguagesNetwork Models.andO;Feature:   illustrationchart.andO;Caption:   Overall architecture of NEST. (chart)The generic monitor. (chart)A custom monitor. (chart)andM;</DESCRIPT><NOTE>Only Text is presented here; see printed issues for graphics.andO;</NOTE><TEXT>NEST: A NETWORK SIMULATION AND PROTOTYPING TESTBEDandM;The Network Simulation Testbed (NEST) is a graphical environment forsimulation and rapid-prototyping of distributed networked systems andprotocols.andP;  Designers of distributed networked systems require the ability tostudy the systems operations under a variety of simulated network scenarios.andO;For example, designers of a routing protocol need to study the steady-stateperformance features of the mechanism as well as its dynamic response tofailure of links or switching nodes.andP;  Similarly, designers of a distributedtransaction processing system need to study the performance of the systemunder a variety of load models as well as its reponse to failure conditions.andO;NEST provides a complete environment for modeling, execution and monitoringof distributed systems of arbitrary complexity.andM;NEST is embedded within a standard UNIX[TM] environment.andP;  A user develops asimulation model of a communication network using a set of graphical toolsprovided by the NEST generic monitor tools.andP;  Node functions (e.g., routingprotocol) as well as communication link behaviors (e.g., packet loss or delayfeatures) are typically coded by the user in C; in theory, any high-levelblock-structured language could be supported for this function.andP;  Theseprocedures provided by the user are linked with the simulated network modeland executed efficiently by the NEST simulation server.andP;  The user canreconfigure the simulation scenario either through graphical interaction orunder program control.andP;  The results of an execution can be graphicallymonitored through custom monitors, developed using NEST graphical tools.andM;NEST may thus be used to conduct simulation studies of arbitrary distributednetworked systems.andP;  However, unlike pure simulation tools, NEST may also beused as an environment for rapid prototyping of distributed systems andprotocols.andP;  The actual code of the systems developed in this manner can beused at any development stage as the node functions for a simulation.andP;  Thebehavior of the system may be examined under a variety of simulatedscenarios.andP;  For example, in the development of a routing protocol for amobile packet radio network, it is possible to examine the speed with whichthe routing protocol responds to changes in the topology, the probability andexpected duration of a routing loop.andP;  The actual code of the routing protocolmay be embedded as node functions within NEST.andP;  The only modifications of thecode will involve use of NEST calls upon the simulated network to send,receive or broadcast a message.andP;  Thus NEST is particularly useful as a toolto study the performance behavior of real (or realisticly modeled)distributed systems in response to simulated complex dynamical networkbehaviors.andP;  Such dynamic response is typically beyond the scope of analyticaltechniques restricted to model steady-state equilibrium behaviors.andM;Traditional approaches to simulation are either language-based ormodel-based.andP;  Language-based approaches (e.g., Simula, Simscript) provideusers with specialized programming language constructs to support modelingand simulation.andP;  The key advantage of these approaches is their generality ofapplications.andP;  These approaches, however, are fundamentally limited as toolsto study complex distributed systems: First, they separate the tasks ofmodeling and simulation from those of design and development.andP;  A designer ofa network protocol is required to develop the code in one environment usingone language (e.g., C), while simultaneously developing a consistentsimulation model (e.g., in Simscript).andP;  The distinctions between thesimulation model and the actual system may be significant enough to reducethe effectiveness of simulation.andP;  This is particularly true for complexsystems involving a long design cycle and significant changes.andP;  Second, theseapproaches require the modeler to efficiently manage the complexity ofscheduling distributed system models (under arbitrary network scenarios).andM;Model-based approaches (e.g., queuing-network simulators such as IBM's RESQ[12]) provide users with extensive collections of tools supporting aparticular simulation-modeling technique.andP;  The key advantage of model-basedapproaches is the efficiency with which they may handle large-scalesimulations by utilizing model-specific techniques (e.g., fast algorithms tosolve complex queuing network models).andP;  Their key disadvantage is a narrowerscope of applications and questions that they may answer.andP;  For example, it isnot possible within a pure queuing-network model to model and analyze complextransient behaviors (e.g., formation of routing loops in a mobile packetradio network).andP;  The model-based approach, like the language-basedapproaches, suffers from having simulation/testing separated fromdesign/development.andP;  It has the additional important disadvantage ofrequiring users to develop indepth understanding of the modeling techniques.andO;Designers of distributed database transaction systems are often unfamiliarwith queuing models.andM;NEST pursues a different approach to simulation studies: extending anetworked operating system environment to support simulation modeling andefficient execution.andP;  This environment-based approach to simulation sharesthe generality of its modeling power with language-based approaches.andP;  NESTmay be used to model arbitrary distributed interacting systems.andP;  NEST alsoshares with the language-based approach an internal execution architecturethat accomplishes very efficient scheduling of a large number of processes.andO;However, unlike language-based approaches, the user does not need to beconcerned with management of complex simulation scheduling problems.andO;Furthermore, NEST does not require the user to master or use a separatesimulation language facility; the processes of design, development andsimulation are fully integrated.andP;  The user can study the behavior of theactual system being developed (at any level of detail) under arbitrarysimulated scenarios.andP;  The routing protocol designer, for example, can attachthe routing protocol designed (actual code with minor adjustments) to a NESTsimulation and study the system behavior.andP;  As the system changes through thedesign process, new simulation studies may be conducted by attaching the newcode to the same simulation models.andP;  NEST can thus be used as an integralpart of the design process along with other tools (e.g., for debugging).andM;In similarity to model-based approaches, NEST is specifically targeted towarda limited scope of applications: distributed networked systems.andP;  NESTsupports a built-in customizable communication network model.andP;  However, thisscope has been sufficiently broad to support studies ranging from low-levelcommunication protocols to complex distributed transaction processingsystems, avionic systems and even manufacturing processes.andM;The environment-based approach to simulation offers a few importantattractions to users:andM;1.andP;  Simulation is integrated with the range of tools supported by theenvironment.andM;* The user can utilize graphics, statistical packages, debuggers and otherstandard tools of choice in the simulation study.andM;* Simulation can become an integral part of a standard development process.andM;2.andP;  Users need not develop extensive new skills or knowledge to pursuesimulation studies.andM;3.andP;  Standard features of the environment can be used to enhance the range ofapplicability.andM;* NEST simulation is configured as a network server with monitors as clients.andO;The client/server model permits multiple remote accesses to a shared testbed.andO;This can be very important in supporting a large-scale multisite project.andM;In this article we describe the architecture of NEST, illustrate its use, anddescribe some aspects of NEST implementation.andP;  We will also feature itsdesign and provide examples of NEST applications.andM;Architecture of NESTandM;The overall architecture of NEST is depicted in Figure 1.andP;  NEST consists of asimulation server and client monitors.andP;  The simulation server is responsiblefor the execution of simulation runs.andP;  The generic client monitors are usedto (re)configure a simulation model and control its execution.andP;  The customclient monitors are used to observe simulation behavior and display theresults.andP;  Clients can (and typically will) reside on separate machines fromthe server.andP;  This allows dedication of a computing server to execute acycle-consuming simulation while delegating presentation and controlfunctions to remote workstations.andM;The client-server communications require relatively low communicationsbandwidth.andP;  This permits the server to support remote clients over awide-area network, allowing researchers to use a remote supercomputer toexecute a complex simulation study.andP;  Similarly, it may be useful to retain ashared simulation testbed for integration of systems developed by a multisiteproject.andP;  For example, in the design of a complex communication network,different sites may be responsible for different protocols and subsystems.andP;  Ashared testbed can be useful for integration of these subsystems as well astesting of individual subsystems in relation to each other under standardizedscenarios.andP;  In all these cases the simulation server can be located on aremote system and accessed by multiple remote clients at the different sites.andM;User interaction with NEST is depicted via the shaded arrows in Figure 1.andO;Users provide node and link functions which are linked with the simulationserver to form a simulation testbed.andP;  These functions are coded in C andinclude calls upon the NEST library.andP;  Node functions are used to modeldistributed communicating processes running at network nodes (e.g.,andO;protocols, database transactions, manufacturing cells).andP;  NEST executes thenode processes and their communications calls using NEST-provided primitivesfor sending, broadcasting or receiving packets.andM;A simulated link has an associated stack of link functions.andP;  The motion of apacket over the link is simulated by passing it through the link functions,which act as a stack of filters.andP;  Link functions are used to model thebehavior of communication links (e.g., packet loss, link jamming, support ofa standard protocol stack).andP;  Link functions are also used to monitor andcollect performance statistics of link traffic (e.g., number of controlpackets, link delay).andM;The simulation server integrates the node and link functions to form a singlesimulation process.andP;  The simulation server schedules the execution of thenode and link processes to meet the specifications of delay and timing set bythe users.andP;  The user can control the timing of events and the delaysassociated with communications through a collection of NEST-supported timingcontrol functions.andP;  These functions simulate standard UNIX timing control(e.g., sleep() function) and support full user control over simulation time.andM;The generation of a simulation testbed is thus an extension of the standardNEST environment.andP;  The NEST simulation server may be viewed as a schedulingkernel that maintains certain parameterized simulation-schedulingcapabilities.andP;  These capabilities are handled via calls upon thecommunication primitives, which define elementary models of &quot;node&quot; and &quot;link&quot;object behaviors.andP;  The user extends these &quot;node&quot; and &quot;link&quot; objects throughthe node and link functions.andP;  Increasingly complex simulation models may beobtained through incremental extensions.andM;NEST User InterfacesandM;NEST users control and manage a simulation through graphical monitoringtools.andP;  NEST provides two kinds of monitors: generic monitors and custommonitors.andP;  The generic monitor provides a complete environment to create,edit and configure simulation scenarios.andP;  A typical generic monitor screen isdepicted in Figure 2.andP;  The user creates and modifies a network descriptionusing a mouse to draw it; clicking the mouse generates nodes; dragging themouse between nodes creates links.andP;  Numbers are used to identify nodes, andto indicate weights for each edge.andP;  Node and link pop-up menus offer a rangeof editing features to configure the respective simulated objects.andP;  Thepop-up menus in the figure are being used to change the function assigned toa node; the &quot;show node data&quot; item can be used to update the node propertieswindow.andP;  Simulation parameters may be set via respective panels at the top.andO;Once the user has defined a simulation scenario, it is sent to the simulationserver where it is loaded and executed.andM;One of NEST's key features is the ability to reconfigure a scenario duringthe simulation run.andP;  This is particularly important for studies of complexdynamic system behaviors: how does the system respond to a node/link crash?andO;How will it handle addition of new nodes or links?andP;  What transient behaviorsoccur as a result of such critical changes?andP;  How long will certain transientslast?andP;  How probable are they?andP;  These types of questions are typicallydifficult to answer through analytical studies or model-based simulation andrequire significant experimentation.andP;  This sort of experimentation withvarying scenarios is possible with NEST.andP;  Users may delete or add nodes andlinks or change their features while the simulation is running.andP;  The impactof these changes on the system behavior may be instantly observed andinterpreted.andP;  Such dynamic reconfiguration can, for example, be invaluable instudying the behavior or routing protocols, especially transient behaviorslike the formation of routing loops.andM;NEST's custom monitors offer tools to display the results of a simulation.andP;  Auser may view the status and data associated with different nodes orperformance statistics of interest.andP;  The custom monitors may be used toanimate the dynamics of the simulation behavior and represent the evolutionof local partial views of the system state.andP;  This is particularly useful inthe study of complex dynamical behaviors of distributed systems.andP;  An exampleof such a custom monitor is given in the following section, &quot;An Example of aNEST Application.&quot;andM;Simulation Server:andM;An Efficient LightweightandM;ProcessandM;NEST supports an efficient lightweight process model to facilitate simulationof complex distributed systems.andP;  A process typically models the behavior of anode.andP;  A process is provided with an appropriate context includingconfigurational information (e.g., respective node and incident links);simulation-scheduling information (e.g., pending messages); and executioninformation (e.g., pointer to its run-time stack).andP;  NEST simulation servermanages the appropriate scheduling of process execution and the contextswitching.andP;  Multiple threads of execution are supported from within a singleUNIX process.andP;  The overhead associated with context-switching is thussignificantly reduced.andP;  Therefore, NEST can support large simulations (scoresto hundreds of nodes) in a workstation environment and hundreds to thousandsof nodes within a more powerful server environment.andM;Scheduling of simulation events is made complex by the mixture of real andsimulated events.andP;  It is necessary for NEST to manage simulated time that ispartially controlled by real events.andP;  Events divide into simulated events andreal-time events.andP;  Communication events such as attempts by processes toreceive a message require synchronization of the process simulation clockwith a global simulation clock.andP;  This is accomplished via suspension of theprocess until all messages that should have been delivered by its simulationtime are available.andP;  Similarly, attempts by processes to control their timing(e.g., a request to be suspended for certain simulation time) requiresynchronization of the local simulation clock with a global simulation clock.andM;Of a more complex nature is the synchronization of the simulation clock toaccount for internal or external real-time events.andP;  A user may wish to studythe execution of a real code (for node processes) and use the actualexecution time of a particular segment of a process to evaluate therespective simulated time.andP;  NEST must synchronize the execution of such codesegments with the simulation clock.andP;  Furthermore, the users too can be asource of real-time events that are mapped to simulated time.andP;  For example, auser can interact with the simulation directly (e.g., changing the networkconfiguration during a run).andP;  A change by the user redirects the evolution ofthe simulation.andP;  It is necessary to assure that user real-time interaction isproperly managed in simulation time.andP;  This implies that a user event can takeplace only after all simulated processes have been synchronized to anappropriate simulation time.andP;  Otherwise it would be possible for someprocesses to continue and execute in the past relative to the changesintroduced by the user.andM;These complex mappings of real time into simulated time are managed by NESTthrough a simple adjustable scheduling policy.andP;  NEST passes through all itsprocesses using a round-robin scheduling.andP;  During each pass all processes areprovided with a quantum of simulation time to be executed.andP;  Processes thatare suspended (e.g., for reception of messages that have not yet beendelivered or through direct requests) only require a simple advance of their(simulation) clocks and potential reactivation if the respective time isarrived at.andP;  Changes of configuration through user interaction or programcontrol can be executed only between passes.andM;The user can adjust the temporal duration of a NEST pass.andP;  In the limit whenthe pass duration is very long, the simulation schedule is entirelycontrolled by simulated events (e.g., communications), as real-timeinteractions are not permitted.andP;  Processes will be permitted to execute untilthey reach a synchronizing event when they are suspended.andP;  The simulationclock will be advanced at the maximum rate possible since it is not necessaryto anticipate external interactions and advance the clock in locked step.andP;  Ifa significant level of external control is desired, a shorter duration forthe pass can be selected, leading to finer locked-step execution of thesimulation processes.andM;An Example ofandM;a NEST ApplicationandM;As an example of how a NEST application might be developed and used, let usexamine how to build a simulation of the Routing Information Protocol (RIP)using NEST.andP;  RIP is a simple routing protocol developed at Xerox PARC for theXNS protocols, and adapted by U.C.-Berkeley researchers for IP routing [9].andO;It is currently used by many UNIX implementations as a simple routingprotocol for IP networks.andP;  We select this example since it requiresconversion of an existing body of code to execute under NEST.andP;  This presentsinteresting challenges compared to the simpler task of converting aNEST-designed system to run in a networked UNIX environment; it provides aninteresting way to explore the differences between the two kinds of codes.andM;The source for the UNIX RIP routing daemon contains much system-dependentcode for maintaining the UNIX kernel routing tables, in addition to its own.andO;The first step in converting the program to a NEST simulation is to eliminatethis unnecessary code.andP;  Additional code for tracing the incoming and outgoingpackets can also be eliminated, as NEST will provide these functions.andM;There are two kinds of changes which must be made to the code to enable it torun under NEST: The first are changes which use the NEST facilities forcommunication and network configuration.andP;  These changes are simple and resultin a significant reduction of the program complexity.andP;  The routing daemonnormally sends and receives messages using the sendto() and recvfrom() systemcalls.andP;  These are similar to the NEST communications primitives sendm() andrecvm(), which allow messages to be sent between nodes in the simulation.andO;Since the protocol messages are already serialized byte strings, it is easyto encode them as pointers to the strings, plus a length count.andP;  The routingdaemon also expends significant effort to extract the network configurationfrom the UNIX kernel.andP;  NEST provides a convenient function, getneighbors(),which returns a list of the node ID numbers of all directly connected nodes.andO;A global configuration table can store the address information which wouldnormally be distributed among the kernels of the various machines in thenetwork.andP;  Finally, since the daemon uses system calls to get the current timefor expiring routes and other time-out conditions, it must be changed to usethe NEST runtime() function instead of the corresponding system calls.andM;The second type of changes are to program mechanisms such as global datastructures which are required to run several instances of the RIP daemon codein a single UNIX process.andP;  These changes can be more difficult, since thereare a number of functions the code performs that would not work if one triedto run several copies of it in a single UNIX process, with a single addressspace.andM;First, there are a number of global or static variables, ranging from theroute table maintained internally by the daemon, to buffers for theconstruction and interpretation of protocol messages.andP;  Since these cannot beshared by all the nodes in a simulation, they are turned into arrays ofvariables, indexed by node ID numbers, and appropriate preprocessor macrosare defined so that the existing code need not be changed.andP;  The daemon alsouses UNIX timers to interrupt the program periodically so that it will sendout routing updates to its neighbors.andP;  Since these timers cannot be easilyshared by several instances of the routing code, the top-level control loopmust be altered slightly to check whether it is time to send out routingupdates.andM;Once these changes have been made, the RIP simulation will run under NEST,and the user can add additional features to support a custom monitor.andP;  Onepossibility is to take some of the display routines from the generic monitorand incorporate them into a monitor function in the simulation.andP;  Thisfunction can trace through the routing tables of the nodes in a network todisplay the path which a packet would take when traveling from one machine toanother.andP;  With such a display, it is possible to directly see the routingloops that are caused by failures of gateways in the network, and see howlong it takes for new, correct routes to be established.andP;  An example of sucha custom monitor is illustrated in Figure 3.andM;The user can now examine how RIP reacts dynamically to failures in thenetwork.andP;  For example, Figure 4(a) illustrates a network scenario and theroute established by RIP from a client node (indicated by a square) to aserver node (indicated by a triangle).andP;  Upon failure conditions establishedby the user, a new topology is established as in 4(b).andP;  RIP will reactdynamically to the failure conditions and its attempt to establish a newroutine from the client to the server; it will create loops as in Figure4(c), or partial routes as in Figure 4(d) before it discovers a new route, asshown in Figure 3.andM;Implementation of NESTandM;The implementation of NEST can be broken down into several areas: facilitiesfor network configuration and communication mechanisms for the correctexecution of simulation code, and support for communication with generic andcustom monitors.andM;The network model provided by NEST is a connectivity graph; a link isassociated with each pair of nodes that are able to communicate directly.andO;This simple configuration structure is stored internally as a table.andO;However, users can manipulate the configuration, either within the program,or using the generic client monitor, as a separate list of nodes and links.andM;All simulated communications between nodes are modeled as messages.andP;  Thesemessages can be sent at any time, and are queued at the receiving node in theorder in which they would have arrived in the simulated network.andP;  NEST uses ashared memory model to simulate message passing.andP;  Messages consist of twodata items: a key and a memory pointer.andP;  The key provides a unique messageidentifier while the memory pointer indicates the contents of the message.andO;This structure supports significant flexibility as nodes can communicate datastructures of arbitrary complexity to each other.andP;  Low-level communicationscan be modeled by sending pointers to the serialized data that would be sentin a real network.andP;  NEST, however, does not support simulation ofshared-memory communication models since such simulations require that allaccesses to message memory be captured and synchronized by the simulationserver.andM;Communication with the generic monitor is provided by an internal monitorfunction which is run at regular intervals of the simulation.andP;  Specialroutines are provided to allow the simulation to continue executing whilewaiting for I/O operations to complete.andP;  By using the functions nbread() andnbwrite(), which are nonblocking versions of the standard read() and write()system calls, the user can communicate with custom monitors as well.andM;The most interesting aspect of the NEST implementation is the mechanism forthe accurate execution of simulation code.andP;  Each node has a thread ofcontrol, or lightweight process, associated with it.andP;  Links do not have aseparate thread of control, but can provide functions which are called when amessage is sent from one node to another.andP;  The lightweight process model usedin NEST is similar to other UNIX lightweight process implementations (e.g.,andO;Sun's LWP library [13]).andP;  Each node has its own stack for local variables andshares global variables and dynamically allocated memory with the other nodesin the simulation.andP;  Control can pass from one node to another eithervoluntarily, or because the time-slice allocated for a node has been used up.andO;A round-robin scheduler arranges for each node to receive equal amounts ofrunning time.andM;The NEST scheduler is distinguished in one important way from typical processschedulers: it schedules nodes in simulated time.andP;  Therefore, it must ensurethat when a node tries to receive a message from another node, it gets thefirst message that arrives in simulation time.andP;  The difficulties in ensuringthis are depicted in Figure 5.andP;  The scheduler runs node A first, and it sendsa message to node B.andP;  When node B runs, it attempts to receive a message(indicated by the circle).andP;  At this point, the message from A has beendelivered, and would normally be available to node B.andP;  But in simulationtime, there may be a message from node C which would arrive before themessage from node A.andP;  As a result, the simulation scheduler cannot give B anymessage until it knows that no earlier message (in simulation time) canpossibly be sent.andM;In order to establish correct ordering of events within the simulation, theNEST scheduler maintains several lists of nodes, based on their status, theavailability of messages and the progress of the simulation of other nodes.andO;The simulation is divided into synchronization passes, whose length can bespecified by the user, and even modified dynamically.andP;  At the beginning ofsuch a pass, most nodes will be on the run list, since they can be run, andare not waiting to receive a message.andP;  As the scheduler scans the nodes inthis run list, one of two things will happen; either the node's time-slicewill expire, or it will attempt to receive a message.andP;  If the time-slice runsout, the node is moved to the run list for the next pass.andP;  If an attempt toreceive occurs, the node is placed on a wait list.andP;  The wait list isstructured so the node which has the earliest available message is always atthe head, and is updated whenever a message is sent to a node on the waitlist.andP;  Once all the nodes on the run list have been run by the scheduler, ittakes nodes off the wait list in turn.andP;  Eventually, the node at the head ofthe wait list will not be able to continue execution until some time afterthe beginning of the next pass; at this point, the simulation pass is over,and after the internal monitor function is run, a new pass is begun, and thecycle continues.andM;This method ensures that events within the simulation occur in the order inwhich they would occur in the simulated environment.andP;  However, since the usercan interact with the simulation, and even change the configuration, whilethe simulation is running, an additional constraint must be added to preserveconsistency when real-time events interact with the simulation.andP;  Otherwise,the relative ordering of real-time events and simulation events would appeardifferent to different nodes.andM;Therefore, the restriction is made that all real-time events which modify thenetwork must take place between simulation passes.andP;  Between passes, all nodesare at the same point in simulation time; thus any changes will appear tohappen at the same time to all the nodes in the simulation.andP;  For this reason,the internal monitor function which communicates with the generic monitor isrun between each simulation pass.andM;Additional Features ofandM;NESTandM;The key goals of NEST implementation are efficiency, portability andextensibility.andP;  Efficiency of simulation is of great importance in the studyof large-scale complex distributed systems.andP;  Certain phenomena occurring insuch systems cannot be extrapolated from the study of small-scale simplifiedversions.andP;  However, a simulation study of complex large-scale systems mayrequire significant computing resources and consume too much time.andP;  NESTaccomplishes significant efficiency through the use of a single-processmulti-threaded execution model and through the use of an optimized scheduler.andO;The single-process execution model involves a minimal amount ofcontext-switching overhead, significantly less than the overheads associatedwith multi-tasking implementation.andP;  Sharing memory among the differentprocess threads permits the simulation to accomplish significant efficiency(e.g., passing pointers instead of full messages).andP;  Finally, the user mayfine-tune the scheduler's granularity, thus adjusting execution runs tomaximize efficiency or real-time reconfiguration and experimentation.andO;Typically, a user will set the initial granularity of the round-robin passesto facilitate a high degree of interaction and change.andP;  Once the scenario ofinterest has been defined, the user can reset the pass duration to allow forefficient uninterrupted execution of the simulation.andM;NEST has proved very efficient in studies of both large-scale and complexdistributed systems.andP;  Exact comparative benchmarks of simulation tools areyet to be developed.andP;  NEST has been used in simulation studies (utilizing aSun-3 server) involving networks of hundreds of nodes executing a standardrouting protocol model [14].andP;  Similarly, NEST was applied in the developmentof a complex distributed transaction-processing model where node functionsinvolved over 20,000 lines of codes [7].andP;  In all cases the response time wasvery fast.andM;Portability has been accomplished by minimizing and localizing dependenciesof NEST on specific hardware or even UNIX variant characteristics.andP;  A typicalport of the simulation server can be accomplished in a few days.andP;  The clientsoftware depended initially on the Sun window system.andP;  A recent porting tothe X-window environment can be expected to ease the portability of the userinterfaces.andP;  NEST has been ported into a large number of workstationenvironments and exported to over 150 user sites worldwide.andM;Extensibility and customization by users are key elements of NEST's design.andO;From a user's perspective NEST is perceived as an extension of the standardUNIX environment.andP;  NEST simulation server and clients are simply UNIXlibraries of functions.andP;  The user can modify any of these functions oraugment them with his or her own custom functions.andP;  A user simulationconsists of an extension of the NEST libraries with user-provided node andlink functions.andP;  This process of extension permits the user to adapt NEST anddevelop it into a custom environment for specific simulation studies ofinterest.andP;  Researchers at Northrop Corporation [11], for example, pursuedthis approach to develop a simulation testbed for protocol research.andO;Similarly, researchers at Xerox PARC and UC Berkeley [10] extended NEST intoa complete environment to study and test TCP/IP internetwork designs (e.g.,andO;gateway routing techniques).andP;  In both cases NEST was equipped with nodefunctions modeling in detail the respective protocol environments.andM;Incremental expandability is a key element in long-term development ofsimulation studies.andP;  Typical simulation studies are designed as throwawaysoftware and the enormous investment in their development is lost when theobject of the study is completed.andP;  NEST simulations can be construed toretain a significant part of the investment through incremental expansion.andO;Thus, a TCP/IP internet testbed may be used to support a significant numberof relevant studies sharing the same testbed software.andP;  Users can share andport the respective libraries among different sites leading to importantsavings and cross-fertilization.andM;Finally, customization and expandability are also supported in the design ofthe NEST client monitor tools.andP;  All menus provide handles for simpleadaptations and expansions to support user-defined options.andP;  This completesthe range of flexibilities offered to users in developing testbed simulationstudies.andM;Sample Applications ofandM;NESTandM;IPLS--A DistributedandM;Incremental Position LocationandM;SystemandM;NEST was initially developed as a tood to experiment with the design of adistributed position location system [5].andP;  Consider a network ofpacket-switched mobile radio units.andP;  Two radios within range of each othercan measure the propagation delay between them and extract an estimation oftheir mutual distance from each other.andP;  Given these distributed observationsof distances, it is required to compute the location coordinates of the radiounits.andP;  IPLS involves a few distributed algorithms that aim to address therange of problems arising from mobility, partial distributed measurements andpossible errors.andP;  The dynamics of topology changes due to mobility may besimulated through an internal monitor function that causes network nodes tofollow some randomized model of motion.andP;  Link functions may be used tosimulate broadcast communication links.andP;  Node functions can include protocolsfor range measurements and use the network topology as a model to defineobservation errors.andP;  Similarly, node functions can be used to execute IPLScode to compute the location coordinates of the nodes.andP;  NEST became a keytool in the development and study of these algorithms under varied dynamicscenarios.andM;Topology Recognition,andM;ARPAnet and Internet RoutingandM;Broadcasting connectivity tables is an important technique for accomplishingtopology recognition by nodes of a dynamic network.andP;  Topology recognitionprotocols are used within a number of communication networks (e.g., DECNet).andO;It is difficult to establish the dynamic behavior of such algorithms inresponse to significant topology changes.andP;  Examples of such behavior includefast propagation of &quot;good news&quot; (e.g., new links) versus slow propagation of&quot;bad news&quot; (loss of a node), instabilities and looping [3].andP;  The theoreticalunderstanding of the dynamical response of distributed algorithms is in itsembryonic stages.andP;  Simulation studies provide the only practical tool at thistime for developing better understanding of these dynamics.andP;  Traditionalqueuing-network simulators typically address equilibrium behaviors.andP;  NESTbecame an important tool in the study of dynamic response behaviors.andP;  A fewstudies of topology recognition algorithms were conducted.andP;  Similarly, theresponse of standard routing algorithms to node and link failures was studiesextensively [14].andM;Dynamic Load-Balancing,andM;Distributed TransactionandM;ProcessingandM;Other work [7,8] has used NEST to develop simulations of complex distributedsystems.andP;  Microeconomic models of supply and demand, with bidding andauctions, were used to develop a dynamic load-balancing system.andP;  Processesare given a certain amount of &quot;money&quot; which they use to bid forcommunications and CPU resources.andP;  This bidding behavior was implemented onthe nodes in a NEST simulation and analyzed to find the relative performanceof various bidding strategies and auction methods, and to compare them withtraditional load-balancing methods.andP;  A more complex simulation used themicroeconomic models to manage a distributed transaction-processing systemwith replicated data.andP;  This simulation had upwards of 20,000 lines of C coderunning onn each node, showing the ability of NEST to model complexbehaviors.andM;Distributed MultiprocessorandM;Operating SystemsandM;NEST has also been used to simulate the behavior of an experimentalmultiprocessor operating system [1].andP;  In this study, operating system codewas run using NEST to see how various performance measures would be affectedby adding additional processors.andP;  The results generated with NEST were laterverified on real hardware and found to differ by only a few percent.andM;REAL--Transport ProtocolandM;SimulationandM;NEST has been used as the basis of REAL, a system for simulating the behaviorof TCP/IP networks [10].andP;  It provides standard models of interactive andbatch traffic sources (TELNET and FTP), using three models of TCP protocolimplementation.andP;  Three IP gateway implementations were modeled and simulationresults were used to validate analysis of a &quot;Fair Queuing&quot; gatewayimplementation [4].andP;  Currently, the REAL system is being extended to providea distributed simulation platform combining many NEST simulationscommunicating over a local area network.andM;ConclusionsandM;The study of NEST and its applications established a few important results:andM;Environment-based simulation tools can offer significant attractions overlanguage- or model-based approaches.andP;  The users do not require sophisticatedexpertise in the use of complex modeling tools or specialized languages.andO;While NEST was developed to support C, the extension to support otherstandard languages (e.g., Pascal, Fortran) is straightforward.andP;  Thesimulation tools can be entirely integrated and unified with theuser-standard development environment.andP;  Simulation can be conducted as anintegral part of the design and implementation cycle.andP;  The actual code of thesystem developed (or a modification of it) may be used to model its behavior.andO;The environment can support simple modeling of arbitrary simulation scenariosand execute the actual system within the resulting simulation testbed.andM;It is often important to study, through simulation, the dynamic response ofthe system to changes.andP;  These changes may be introduced through user orprogram control.andP;  NEST usefully separates scenario modeling and controlfunctions from the simulation code.andP;  The scenario may then be passed to thesimulation as a parameter, allowing the simulation to adapt to new scenariosand respond to the respective changes.andM;Separation of scenario display and control from the simulation execution interms of simulation server and monitoring clients can offer additionalattractions.andP;  The simulation may be executed over a remote computationalserver, permitting optimum utilization of the server cycles and fasterresponse.andP;  The client monitors may provide effective remote (re)configurationand scenario controls.andP;  This permits users to access substantially morecomputing capabilities over a network than may be available to them locally,and conduct extensive simulation studies.andP;  Additionally, as is often thecase, the development of a complex distributed system may involve work atmultiple sites.andP;  A common simulation testbed can support sharing of softwareand efforts as well as improved studies of the interactions between thedifferent subsystems.andP;  Furthermore, it can significantly improve integrationof the results, as it enforces certain standards over independent developmentefforts.andM;Finally, extensibility, customizability and portability enable users toextend and adapt NEST to become a total design environment for their systems.andO;The word-of-mouth ad hoc distribution of NEST to over 150 sites and itssuccessful application to scores of various projects provide a measure ofsuccess in accomplishing the results reported in this article.andP;  The authorswould be pleased to share NEST software and experiences with other interestedsites and users.andM;([TM]) UNIX is a registered trademark of ATandamp;T Bell Laboratories.andM;ReferencesandM;[1] Barak, A. International Computer Science Institute, Berkeley, privatecommunication, 1989.andM;[2] Bacon, D., Dupuy, A., Schwartz, J., Yemini, Y. Nest: A network simulationand prototyping tool.andP;  Winter USENIX Technical Conference, February 1988.andM;[3] Bertsekas, D. Data Networks.andP;  Prentice-Hall, Englewood Cliffs, N.J.andO;1987.andM;[4] Demers, A., Keshav, S., Shenker, S. Analysis and simulation of a fairqueuing algorithm.andP;  In Proceedings of the ACM SIGCOMM Symposium onCommunications Architectures and Protocols, (September 1989).andM;[5] Dupuy, A., Bacon, D. A Distributed Position Location System.andP;  ColumbiaUniversity, 1987.andM;[6] Dupuy, A., Schwartz, J. Nest User Interface Manual and Nest User's Guide,Columbia University, March 1988.andM;[7] Ferguson, D., Nikolau, C., Yemini, Y. Microeconomic algorithms fordynamic load balancing in distributed computer systems.andP;  Res.andP;  Rep., IBM T.J.andO;Watson Research Center, Yorktown Heights, NY, October 1989.andM;[8] Ferguson, D., Nikolau, C., Yemini, Y. Microeconomic algorithms for flowcontrol in virtual circuit networks.andP;  Res.andP;  Rep., IBM T.J.andP;  Watson ResearchCenter, Yorkstown Heights, NY, January 1990.andM;[9] Hedrick, C. L. Routing Information Protocol.andP;  Network working group RFC1058, SRI International, June 1988.andM;[10] Keshav, S. REAL: A network simulator.andP;  Tech.andP;  Rep.andP;  UCB/CSD 88/472,University of California at Berkeley, December 1988.andM;[11] Rose, M.andP;  The Nest simulation facility at NRTC.andP;  Tech.andP;  Rep., NorthropResearch and Technology Center, 1987.andM;[12] Sauer, C. H., McNair, E. A., Kurose, J. F.andP;  The Research QueuingPackage: Past, present and future.andP;  In Proceedings of the National ComputerConference, Arlington, VA, 1982.andM;[13] Sun Microsystems, Inc. SunOS 4.0 system services overview, 1988.andM;[14] Swinyer, B. Comparison of routing algorithms.andP;  Project Rep., ColumbiaUniversity, 1988.andM;ALEXANDER DUPUY is currently a senior software engineer at the ColumbiaUniversity Computer Science Department.andP;  His current research interests arein network management and object-oriented databases.andP;  Author's PresentAddress: Columbia University Computer Science Department, New York, NY 10027.andM;JED SCHWARTZ is currenty a software engineer at Sigma Imaging Systems.andP;  Hiscurrent research interests are in PC-based imaging systems.andP;  Author'sPresident Address: Sigma Imaging Systems, 622 Third Avenue, New York, NY10017.andM;YECHIAM YEMINI is an associate professor at the Columbia University ComputerScience Department.andP;  His current research interests include networkmanagement, high-speed networking, protocol design, performance analysis, andneural networks.andP;  Author's Present Address: Columbia University ComputerScience Department, New York, NY 10027.andM;DAVID BACON is a researcher at IBM T.J.andP;  Watson Research Center.andP;  His currentresearch interests are in programming language design and the application ofoptimistic techniques to distributed systems.andP;  Author's Present Address: IBMT.J.andP;  Watson Research Center, 30 Sawmill Road, Hawthorne, NY 10532.andO;</TEXT></DOC>