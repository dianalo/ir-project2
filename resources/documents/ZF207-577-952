<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-577-952  </DOCNO><DOCID>07 577 952.andM;</DOCID><JOURNAL>Hewlett-Packard Journal  August 1989 v40 n4 p38(5)* Full Text COPYRIGHT Hewlett Packard 1989.andM;</JOURNAL><TITLE>An extensible agent task language. (creating scripts in theHewlett-Packard NewWave environment)</TITLE><AUTHOR>Packard, Barbara B.; Whelan, Charles H.andM;</AUTHOR><SUMMARY>The agent task language (ATL) of Hewlett-Packard's NewWavewindow-oriented operating environment enables the creation ofscripts for the automation of tasks.andP;  Such scripts create, modify,manipulate, and eliminate objects that consist of tasks and theirrelated data files.andP;  The several features that support theprogramming of scripts include an interpretive engine that is partof the agent task, a task language compiler that is used to createa binary object file that includes a header record and binaryP-code records, a library of components common to allapplications, source templates for common semantic routines, arun-time environment, a system of multiple parsers, and tasklanguage recorders.andP;  Details of ATL's architecture are described.andM;</SUMMARY><DESCRIPT>Company:   Hewlett-Packard Co. (products).andO;Ticker:    HWP.andO;Product:   NewWave (Graphical user interface) (product specifications).andO;Topic:     System DesignOperating EnvironmentsSpecificationsProgramming LanguagesUtilizationProgramming.andO;Feature:   illustrationchart.andO;Caption:   Binary P-code record format. (chart)Paser data flow. (chart)LIST external command format. (chart)andM;</DESCRIPT><TEXT>An Extensible Agent Task LanguageandM;THE AGENT TASK LANGUAGE of the HP NewWave environment is a set of proceduralcommands that provide users access to the task automation functions of theNewWave environment.andP;  Scripts can be written to create, delete, modify, andotherwise manipulate NewWave objects.andP;  The scripts are processed by aninterpretive engine, which is part of the agent object.andP;  More information onthe interaction of the agent, the task language, and the application can befound in the article on page 32.andM;In the NewWave environment, each task is a separate object with associateddata files.andP;  Tasks function across and within object classes and aresupported by all NewWave applications.andP;  Upon opening a task, the user seesthe contents of the file containing the task language commands, available forediting and compilation.andP;  when the user drags a task to the agent icon, theassociated binary P-code file is executed.andP;  Task language commands have averb/object syntax:andM;andless;command keywordandgt; {parameter}...andM;The parameter of a command may be either a keyword or a literal.andP;  Commandsare line-oriented, but a continuation character is available to extend acommand across the line boundary.andP;  A primary concern in the languagedefinition was the mapping of the interactive user interface to the tasklanguage commands.andP;  To make the scripts as readable as possible, we wanted tohave the command keywords reflect user actions.andP;  For example, if an action isaccomplished interactively by clicking on a menu item such as CUT, thecorresponding task language command will contain that menu item as itscommand keyword verb.andP;  The parameter type is command dependent, but numeric,string, and keyword command parameters can be used.andM;User RequirementsandM;Agent tasks will be created and executed by users whose expertise varieswidely.andP;  The casual NewWave user will record a few actions within an objectand save them as a task, which is executed to repeat the actions.andP;  The poweruser will construct complicated automated tasks, frequently for other users,that execute for a considerable time without user intervention.andM;The novice, using the task language as a macro recorder, quite possibly maynever look at the task language form of the task.andP;  This user will requireease of use and high performance.andP;  The power user will demand a language withat least the power of command languages in existing applications such asExcel or DBase III Plus.andP;  [R]andM;Our chosen model for the task language is the power user.andP;  The language isappropriate for constructing large automated tasks involving severalapplications.andP;  We have provided a conversational window facility, designed bythe task writer and controlled by the task language script, which enables thetask to receive user input and display information.andP;  Other features includevariables, functions, task procedures, control statements such asconditionals and loops, and numeric, string, and logical expressions.andP;  Acommand parameter defined as a literal may also be an expression of the sametype.andM;We expect that in time many casual users will move toward the power usermodel.andP;  The language should be designed to facilitate this.andP;  Toward this end,the agent task recorder facility has a built-in watch feature.andP;  The user cansee the task language command that was recorded as a result of an action.andO;Recorded tasks do not contain the advanced programming features listed above,but the relationship of the user's interactive actions to the task languagecommands will be apparent from the syntax of the command.andP;  In particular, thesyntax of task language command is meaningful enough to serve as a learningaid to users who wish to explore the more advanced features of NewWave agenttasks.andP;  This is another reason for the close mapping of the command keywordsto the interactive user actions.andM;System RequirementsandM;The system requirements for automating a task that spans applications have asomewhat different perspective.andP;  A task language statement is either acontrol statement (examples include variable assignment, procedure call,loops) or an action command (such as CLOSE, CUT, PASTE) to a particularobject.andP;  Control statements are independent of the current active object andcan be executed by the agent interpretive engine, but action commands aresent to an object of a particular application class and executed by it.andO;Commands are not identical across applications; many are class-specific.andP;  Forexample, most applications support some form of SELECT.andP;  But the object ofthe selection, which translates to the parameter of the task languagecommand, will vary widely depending on the object class.andP;  In a document onewould SELECT a range of text, in a spreadsheet a cell or range of cells.andO;However, in the NewWave Office window the selection is an icon, that is,another object with a class and title.andP;  The NewWave open architecturespecification mandates the dynamic installation and removal of applicationclasses and leads to a different configuration on each system.andP;  Task languagecommands for a NewWave application written by an independent software vendormust also be supported.andM;It is impossible for the agent engine to keep track of the command set andsyntax supported by each application currently active on the system.andP;  Theagent engine should not interpret the contents of a command it sends to anapplication in playback.andP;  It is equally impractical to have each applicationclass parse its commands at execution time, returning similar syntax errormessages, or handling variables or expressions as parameters.andM;The solution is a task language parser module and recorder template for eachapplication class.andP;  The parser converts ASCII task language commands to theexternal command form recognized by the application.andP;  The recorder templateconverts the external command to ASCII task language commands during the taskrecording.andP;  These are installed into the task automation process when theapplication is installed into the NewWave environment.andP;  As applications areadded to and removed from the system, the set of task language commandsaccepted by the compiler and creaed by the recorder is customizedaccordingly.andM;Application Developer AssistanceandM;Because developers of NewWave applications need to provide parser andrecorder modules for task automation, we supply tools and guidelines to maketheir job as simple as possible.andP;  We separate out the components that arecommon to all applications and provide code for these in libraries, and weprovide source templates for typical semantic routines.andP;  Since we wish tohave the task language commands appear as one programming language to theuser, we provide guidelines for commands and examples of appropriate syntaxthat are the same or similar across applications.andM;The Task Language CompilerandM;Our first design decision was to compile task language scripts to a binaryP-code format for execution rather than interpreting the ASCII commands atrun time.andP;  There were several reasons for this:andM;* The binary format is more compact, particularly for long tasks.andM;* A standardized binary format is more suitable for execution by applicationsin the MS Windows environment.andM;* Syntax and other obvious errors can be flagged and fixed at compile time.andM;* Nonsequential instructions such as loops and procedure calls can be handledefficiently.andM;* Functions, variables, and expressions can be preprocessed and handled in astandard manner.andM;As a result, the task language compiler is a two-pass compiler.andP;  The firstpass follows the general compiler model of scanner, parser, and semantics.andO;It receives as input the ASCII task language script, parses it, and generatesbinary P-code records which are written to a temporary file.andP;  The second passfixes instructions that reference addresses that were unknown when the P-codewas initially generated.andM;Object File FormatandM;Successful compilation of a task creates a binary object file.andP;  An objectfile consists of two main parts: a fixed-length header record and the binaryP-code records which will be executed by the agent interpretive engine.andM;The header record contains the version ID of the compiler as well asinformation such as the number of variables, conversational windows, andpages of code in the task.andM;The code section of the object file consists of the variable-length, binaryP-code records which are executed at run time by the agent engine.andP;  ManyP-code instructions are similar to high-level assembly language.andP;  Pointers tolocations in the code are maintained as addresses.andP;  Addresses consist of apage number and an offset into that page, thus identifying the start of aninstruction.andP;  Page size is fixed.andP;  P-code instructions do not cross pageboundaries; however, a continuation P-code is available.andM;The P-Code RecordandM;The agent interpretive engine performs a task by fetching and executing theP-code instructions.andP;  The generic record format is shown in Fig.andP;  1.andP;  Thelength field contains the number of bytes in the record, including the lengthword.andP;  A record with no parameters will have a length of 4.andP;  The P-code ID isthe numeric opcode of the instruction.andP;  The parameters are any parameters theinstruction requires.andP;  The type and length are instruction dependent.andO;Parameters of type string are null-terminated, which is indicated by thestring \0.andM;The Command P-CodeandM;As mentioned earlier, most P-code instructions result in an action commandsent to a particular application object.andP;  Fig.andP;  2 illustrates the P-codeformat for a command.andP;  The parameters of the P-code, except for the integerclass ID word, make up the external command form, which is sent to theapplication.andP;  The Class ID parameter is an integer indicating the class ofobject that recognizes this command.andP;  It is a task dependent.andP;  The commandlength is an integer containing the total length of the length word, thecommand ID word, and the parameters.andP;  The command ID is set by theapplication.andP;  The parameters are of variable length and type, and are commanddependent.andM;At run time, the agent engine strips the first three words and sends theremainder, the external command, to the application.andP;  The agent enginerequires the length word; the remainder of the structure is designed by theapplication.andP;  However, applications are strongly urged to use the formatillustrated.andM;Run-Time EnvironmentandM;The agent interpretive engine is implemented as a simple stack machine.andO;Variable assignments, function and procedure calls, and expressionevaluations are all stack operations.andP;  When a task starts up, the agentinitializes its data structures using information in the task header record.andO;It then makes an MS Windows intrinsic call to receive an MS Windows TIMERmessage at regular intervals.andP;  Each TIMER triggers a P-code fetch andexecution.andP;  The agent relinquishes control between instructions, thusallowing tasks to conform to the same execution guidelines as other NewWaveobjects.andP;  P-codes are fetched from the current page, which is retained inmemory.andP;  Pages are procured as needed.andP;  If the P-code is a command, the agentchecks the class ID to determine if the instruction class matches the classof the object that currently has the focus.andP;  If so, it posts anAPI_PLAYBACK_MSG to the object with the command as a parameter.andP;  No moreP-code instructions are executed until the agent receives an AP_RETURN_MSG.andM;The Task Language ParsersandM;To facilitate the modularization and customization of the task language, wedesigned a system of multiple parsers.andP;  The main compiler contains twoparsers: the top level or class independent paser, and the expression parser,which handles functions and expressions of numeric, string, and logical type.andO;Each application also has a parser module, which parses its class dependenttask language commands.andP;  This module also includes semantic routines whichconvert the parsed command to the external command form.andP;  The parser modulesare in the form of MX Windows dynamic libraries and are accessed from theclass independent parser through the MS Windows LoadLibrary intrinsic.andP;  Theapplication's installation file identifies the library file, the applicationclass name, and the names of its parse routines by adding them to its OMFproperty list as a property PROP_AGENTTASKINFO.andP;  The task language compilerenumerates all applications with this property.andP;  It is then aware of allavailable classes of task language commands.andP;  Again, this can be differentfor each system configuration.andP;  However, the compiler loads only thelibraries of the classes requested by the task script.andM;Paser ComponentsandM;The following sections describe briefly the various components of theparsers.andP;  Fig.andP;  3 shows a data flow diagram of their interaction.andM;Parser Routines.andP;  The current parser modules have been created using the yaccparser generator.andP;  yacc was developed at ATandamp;T Bell Laboratories.andP;  There isnothing to preclude a developer's substituting a customized parse routine fora yacc-generated one.andM;Keyword File.andP;  The recommended class dependent parser model stores itscommand keywords in a file which is read into a table during theinitialization process.andP;  The token number of each keyword depends on itsposition in the file.andP;  This permits a certain amount of command localizationwithout reconstructing the parser.andM;Scanner Routine.andP;  The scanner was developed in-house at HP and provides theonly access to the task language source file.andP;  All paser modules must call itfor token input.andP;  The scanner returns token types and indexes to appropriatetables where the values are stored.andP;  If a parser module uses a differenttoken representation, it can modify its scanner to retrieve the value at thispoint and continue processing.andM;Expression Parser.andP;  The expression parser is available to the classindependent and class dependent parsers.andP;  It is activated by a semantic callduring the parsing of a command.andP;  It processes tokens until it finds one thatis not part of the expression.andP;  The associated semantic routines generateP-codes to evaluate the expression and place the result on the enginerun-time stack.andP;  The expression parser then sets the state of the scanner sothat the next token request (by a command parser) will return a token typeexpression, which will satisfy the conditions of the parse.andP;  There is norequirement that class dependent parsers use the expression parser.andM;Semantic Routines.andP;  Since the structure of the external command form is knownonly to the relevant application, the semantic routines must be theresponsibility of the application developer.andP;  However, we have provided alibrary of routines to perform functions such as initialization, buffermanagement, and cleanup.andP;  Also, there are routines that handle the semanticprocessing of expressions when they occur as command parameters.andP;  Use of thislibrary will greatly simplify the implementation of the semantics.andP;  Theoutput of the semantic routines is returned to the compiler in a buffer andthen written to the object file.andM;The FOCUS CommandandM;The compiler directs the source processing to the appropriate parser throughthe FOCUS command.andP;  This command needs additional discussion since it resultsin both compile-time and run-time actions.andP;  The syntax isandM;FOCUS [[ON] [OFF] andless;classnameandgt; &quot;andless;title stringandgt;&quot;]andM;where classname is the name of the class of object (for example, DOCUMENT orFOLDER) as recognized by the task language parsers, and title string is thetitle of the specific object referenced.andP;  At installation time this classnameis added to the OMF PROP_AGENTTASKINFO property of the class.andP;  When a task iscompiled, the compiler adds the classnames to its list of keywords recognizedby the scanner, and through the scanner by the class dependent parsers aswell.andM;When a task is executed, the majority of the commands will result in theagent's sending a message to the object that currently has the focus.andP;  Theparameters of this message make up a command that will direct the object tochange its state.andP;  At run time, the FOCUS command tells the agent whichobject is the target of subsequent command messages.andP;  At compile time it hasanother role.andP;  It controls selection of the class parser that will parseclass dependent commands and generate the external command.andP;  Commands arecompiled sequentially in the order received.andP;  However, the order in whichcommands are executed at run time will seldom, if ever, be completelysequential.andP;  The inclusion of conditional execution (IF, WHILE), jumps(GOTO), procedure execution (DO), or user variables in a task virtuallyguarantees that there is no way to make a determination at compile time whichobject will have the focus at run time.andP;  The FOCUS command sets acompile-time focus.andP;  In effect, it determines which class dependent parserwill parse the commands following it.andP;  The commandandM;FOCUS DOCUMENT &quot;Orders Report&quot;andM;will cause all class dependent commands to be parsed by the document parseruntil another FOCUS command is encountered.andP;  If the OFF parameter is used,only class independent commands will be accepted by the parsers until anotherFOCUS statement is encountered.andP;  The main effect of this command is to reducecompilation time, since a syntax error returned by a class dependent parserwill cause the command to be reprocessed by the class independent parser.andM;The Task Language RecordersandM;Task recording provides the ability to monitor run-time events and recomposethem to produce a reusable task in the ASCII task language format.andP;  The focalpoint of the recording process is the class independent recorder.andP;  Thismodule is as MS Windows dynamic library which is loaded only during arecording session.andP;  It receives all external commands from the agent whilerecording is active.andM;The recorder first determines if the received command is specific to a class.andO;If it is not, the command is immediately converted to its ASCII task languageform.andP;  If the command is class-specific, the library will either providedefault dependent recording or will pass the external command to a separateclass dependent recorder module.andP;  In either case, the complete task languagetext is used to build a source file of ASCII task commands.andM;Default Dependent RecordingandM;The majority of class-specific external commands are handled wholly withinthe class independent recorder.andP;  This module uses ASCII recorder templatefiles to provide the necessary information to do default dependent recording.andO;These files provide formatting information so that a multiplicity of externalcommands can be recomposed into task language without the need of invokingclass-specific executable code.andM;Recorder template formatting strings are patterned after the C programminglanguage's print control strings.andP;  They describe how a given externalcommand's parameters are to be interpreted and formatted into compilable tasklanguage text.andP;  They can include information on the order of parameters inthe external command, the size of each parameter, the data type of theparameter, and how the parameter is to be formatted in the task languageline.andP;  Templates also support arrays of parameters, enumerated parameters,optional parameters, and optional fields in the task language form.andP;  Commentfields, ignored by the recorder but useful for documentation, may be includedas well.andM;Template file information for a particular class is read into memory when aFOCUS command for that class is first received during a recording session.andO;As external commands are passed to the record at run time, they are thenformatted into task language.andM;The example below illustrates a template and a command definition from theNewWave Office recorder template file.andM;Template Formatting String: &quot;%v %1d COPIES TO DEVICE %2s&quot; ; 13th template.andM;Command Definition: 103 13 &quot;LIST&quot;andM;The command definition specifies that when external command 103 is received(and NewWave Office has the focus) the 13th template in the file is to beused with the verb LIST.andP;  The template definition specifies that the firstparameter in the external command is a decimal integer and the secondparameter is a string.andM;The external command form of the example is shown in Fig.andP;  4.andP;  From theexternal command shown, default dependent recording will produceandM;LIST 2 COPIES TO DEVICE &quot;LaserJet&quot;andM;Class Dependent RecordersandM;If there are cases that cannot be handled by template files, an applicationcan provide its own class dependent recorder.andP;  The class independent recorderwill pass the external commands that it cannot handle by default recording tothe class dependent recorder for the class that currently has the focus.andM;ExtensibilityandM;All recorders including the class independent recorder are written as MSWindows dynamic libraries that are loaded only when needed with the MSWindows intrinsic LoadLibrary.andP;  All recorders must also support a commonprogrammatic interface, so that the interactions between the classindependent recorder and any class dependent recorder are identical.andM;The developer of a new application can implement recording by producing theASCII recorder template file and, if necessary, by developing theapplication's own separately linked dynamic library.andP;  The file names aredeclared in the PROP_AGENTTASK_INFO property in the application'sinstallation file.andP;  Recording is activated when the running application getsthe focus during a recording session.andM;AcknowledgmentsandM;The agent task language project is indebted to many individuals.andP;  However,some should be specially acknowledged.andP;  Glenn Stearns was the creator of theagent project and has been the driving force behind it ever since.andP;  Hisenthusiasm, persistence, and constant flow of ideas clearly &quot;made it happen.&quot;andO;Tom Watson designed and implemented the prototype for the class independentparser and wrote the initial definition of the task language commands.andP;  Manyof his ideas found their way into the final product.andP;  Tony Day was a majorcontributor to the definition of the command set of the NewWave Office classdependent parser.andP;  The success of this first parser helped establishviability.andP;  Many thanks to the agent team and the task language reviewcommittee for the hours spent reviewing task language specifications, and toproject manager Ian Fuller and section manager Larry Lorren for theircontinual support of this and other NewWave projects.andO;</TEXT></DOC>