<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-396-930  </DOCNO><DOCID>07 396 930.andM;</DOCID><JOURNAL>Data Based Advisor  July 1989 v7 n7 p22(5)* Full Text COPYRIGHT Data Based Solutions 1989.andM;</JOURNAL><TITLE>Golden rules--part 2. (R:Base lab: includes related article on theMod 11 check digit algorithm)</TITLE><AUTHOR>Litwin, Paul.andM;</AUTHOR><SUMMARY>The rules for R:Base allow the user to restrict the range of dataentered into columns.andP;  Rules greatly increase the validity of datain the database, when used correctly.andP;  This column discusses twotypes of rules and how to modify them without having to redefine.andO;Computation and use of check digits is discussed extensively inboth the column and the related article.andP;  Rules can also beinvoked to insure that a mandatory column is never left blank, aswell as when certain columns can be left blank.andP;  Modification anddefinition of rules is also discussed.andM;</SUMMARY><DESCRIPT>Product:   R:base (Data base management system) (product specifications).andO;Topic:     Relational Data BasesRule-Based SystemsAlgorithms.andM;</DESCRIPT><TEXT>Golden Rules--Part 2andM;R:BASE's rules allow you to restrict the range of data entered into your datacolumns.andP;  When used properly, rules greatly increase the validity of the datayour database contains.andP;  In last month's column, I outlined the two basictypes of rules (value checking and table checking) and presented several&quot;golden&quot; examples.andP;  In this issue we'll look at a couple more examples anddiscuss how to modify rules without having to redefine them.andP;  These examplesare from the fictitious database I introduced last month.andP;  This database,called CLINIC, might be used in a doctor's office or clinic to track patientvisits to the clinic.andM;Checking your digits with a check digitandM;If one or more of the columns in your database contains identification numberdata, you can decrease the chances of a bad I.D.andP;  number getting into yourdatabase by using a check digit.andP;  A check digit is a single numeric digittacked onto the end of the I.D.andP;  number that helps detect errors in recordingor inputting the I.D.andP;  Let's first discuss how to test for a valid checkdigit.andP;  For a more complete discussion of check digits and the mod 11 checkdigit algorithm in particular, see the accompanying article.andM;We'll create a check digit for the Idnum columns in the PATIENT and VISITtables of the CLINIC database.andP;  Before we do, we need to decide on themaximum value of the Idnum column.andP;  Let's say that it will never be greaterthan 99,999 or more than five digits long.andP;  We need to know this before wewrite our check digit algorithm because the algorithm will parse the I.D.andO;number and is dependent on its length.andP;  Next, we need to create an integercolumn, Check, that holds the user-entered check digits.andP;  We also need todefine several computed columns.andP;  For a five-digit I.D.andP;  number, we'll needto create seven computed columns.andP;  We need to do this for each table thatuses the Idnum column.andP;  Since we've defined the PATIENT table, we'll use theEXPAND command to add the new columns.andP;  First, we'll create the column,Check, the user will enter the check digit into: Randgt; EXPAND patient WITH checkINTEGERandM;Next, we create columns I1 through I5 for each digit of the I.D.andP;  By definingthese columns as integer type and using the R:BASE Mod function, we can parseeach digit Idnum into the columns: Randgt; EXPAND patient WITH i1 = MOD(idnum,10)INTEGER Randgt; EXPAND patient WITH i2 = MOD(idnum,100)/10 INTEGER Randgt; EXPANDpatient WITH i3 = MOD(idnum,1000)/100 INTEGER Randgt; EXPAND patient WITH i4 =MOD(indum,10000)/1000 INTEGER Randgt; EXPAND patient WITH i5 = idnum/10000 INTEGERandM;Now, we sum up the product of each digit multiplied by its constant, i.e.andO;multiply the ith digit by (i+1).andP;  Check0 is then equal to 11- (this sum mod11).andP;  Randgt; EXPAND patient WITH + check0 = 11-mod(i1*2 + i2*3 + i3*4 + i4*5 +i5*6),11) INTEGERandM;The last step in calculating the check digit is to test to see if Check0 isgreater than nine.andP;  If so, set the check digit, column Check1, equal to 0.andO;Otherwise, the check digit is equal to the value of Check0.andP;  Randgt; EXPANDpatient WITH check1 = ifgt(check0,9,0check0) INTEGERandM;We can use the same EXPAND commands, substituting &quot;visit&quot; for &quot;patient&quot; toadd the same columns to the VISIT table.andP;  If you haven't created your tablesyet, Define mode is more appropriate.andP;  Either way, once your columns aredefined in both the PATIENT and VISIT tables, you're ready to define yourrules: Dandgt; &quot;Bad ID number / check digit!&quot; check IN patient EQA check1 + INpatient Dandgt; &quot;Bad ID number / check digit!&quot; check IN visit EQA check1 IN visitandM;Next, we set up a data entry form for each of these tables using FormsExpress, putting the Check column to the right of the Idnum column.andP;  Then,each time Idnum and Check are input and the record is added to the database,the computed columns are calculated and the rule checked.andP;  The I1 through I5,Check0 and Check1 columns are then computed from the Idnum entry.andP;  Check1then contains the correct check digit and is compared by the rule to theuser-entered Check column.andP;  If the Check and Check1 columns don't match, theerror message is displayed (see Fig.andP;  1).andM;&quot;Okay,&quot; you might say, &quot;you've shown me how to check for a valid check digit,but how do I get the right check digit in the first place?&quot;andP;  You need to makesome provision for computing the check digit prior to or at the time the I.D.andO;numbers are assigned.andP;  This can be done in a couple of ways.andP;  One would be towrite an R:BASE program (or for that matter a program in any language such asBASIC or Pascal) that uses the Mod 11 check digit algorithm to print a seriesof sequentially assigned I.D.andP;  numbers and their respective check digits.andO;Then, when you assign I.D.andP;  numbers, you could go to this printout and crossoff each number as it's used.andP;  This technique is especially useful if youron-line time is limited and more than one person assigns I.D.andP;  numbers.andM;Another way to assign I.D.andP;  numbers and check digits is to have R:BASE keeptrack of the last assigned I.D.andP;  number in a lookup table.andP;  When a new I.D.andO;number is created, the check-digit is computed.andP;  Thus, R:BASE could be usedto generate the check-digit when the I.D.andP;  number is assigned (e.g., everytime a new PATIENT record was added) and to verify the check digit every timethe I.D.andP;  number is referenced (e.g., when a new VISIT record is added).andP;  Wecould implement this system by creating an additional lookup table calledNEXTID.andP;  NEXTID would contain most of the same columns as those defined abovewith just one row.andP;  Define NEXTID with the integer column Idnum and thecomputed columns I1 through I5, Check0 and Check1, as before.andP;  R:BASE makesthis easy, since once a column is defined for one table, it never needs to bedefined again.andP;  We simply use the TABLES command within the Define mode tocreate the NEXTID table without redefining the columns: Randgt; DEFINE Dandgt; TABLESDandgt; nextid WITH idnum i1 i2 i3 i4 i5 check0 check1 Dandgt; ENDandM;Next, we need to create one row in the NEXTID table with Idnum equal to thelast assigned I.D.andP;  number plus 1.andP;  For example, let's say that the lastassigned I.D.andP;  number is 534.andP;  We then use the LOAD command to enter thesingle row: Randgt; LOAD nextid USING idnum Landgt; 535 Landgt; ENDandM;Then we use the following command file called NEXTID.CMD to assign I.D.andO;numbers to new patients: *( NEXTID.CMD ) LABEL STARTCMD SET VAR vidnumINTEGER SET VAR vnext INTEGER SET VAR vcheck0 INTEGER SET VAR vcheck1 INTEGER*( Look up the value of the last I.D.andP;  in the NEXTID table.andP;  ) SET VAR vidnumTO idnum IN NEXTID WHERE COUNT EQ 1 SET VAR vcheck0 TO check0 IN NEXTID WHERECOUNT EQ 1 SET VAR vcheck1 TO check1 IN NEXTID WHERE COUNT EQ 1 *( Incrementthe I.D.andP;  # by 1 and put the value into Vnext.andP;  ) SET VAR vnext TO (.vidnum +1) *( Now, before we forget, increment Idnum in the NEXTID table ) *( by 1.andO;) CHANGE idnum to .vnext IN NEXTID WHERE COUNT EQ 1 *( The mod 11 check digitalgorithm specifies that we do not use ) *( any I.D.andP;  number when Vcheck0 =11.andP;  So we must skip to the ) *( beginning of the command file when Vcheck0 =11.andP;  ) IF vcheck0 EQ 11 THEN GOTO STARTCMD ENDIF *( Otherwise, create aPATIENT record with the new I.D.andP;  and check ) *( digit using the LOADcommand.andP;  ) *( Before we load data into the PATIENT table, we need to set )*( Rules Checking Off, because there may be some rules that ) *( forbid oneor more columns from being NULL.andP;  ) SET RULES OFF LOAD patient USING idnumcheck .vidnum .vcheck1 END SET RULES ON *( And edit the newly created recordin the PATIENT table.andP;  ) EDIT USING patient WHERE idnum EQ .vidnumandM;Although implementing a check digit system is a bit involved, the reductionof errors can be significant.andP;  If you normally access your tables by a uniquekeyed I.D.andP;  column, a check digit system might be essential.andP;  One comment isin order here.andP;  These routines assume that the check digit will be enteredinto a column separate from the I.D.andP;  number column.andP;  You could implement asystem with the check digit as the last digit of the I.D.andP;  number column.andO;For our example, Idnum would then become six digits wide instead of five, andthe parsing routines would have to be modified.andM;Mandatory and optional dataandM;Rules can also be used to ensure that a mandatory column is never left blank.andO;For example, if you wanted to be certain that the Sex column in the PATIENTtable was always filled in, you could define the following rule: Dandgt; RULES Dandgt;&quot;Sex can't be left blank&quot; sex IN patient EXISTSandM;The flip side of thsi concept is to use rules to specify when a column can beleft blank using the FAILS condition.andP;  This is necessary when you want todefine a rule that limits the data that can be entered and you want to allowthe column to be blank.andP;  For example, last month we specified that allentries into the Diag1, Diag2, and Diag3 columns of the VISIT table must alsobe present in the DIAGNOS lookup table.andP;  But, visits to our clinic might befor a patient with only one diagnosis code.andP;  The previously defined ruleswon't allow the Diag2 and Diag3 columns to be blank.andP;  We should have definedthe following two rules instead: Dandgt; RULES Dandgt; &quot;Diagnosis codenot found&quot; diag2IN visit EQA diag IN diagnos + OR diag2 IN visit FAILS Dandgt; &quot;Diagnosis code notfound&quot; diag3 IN visit EQA diag IN + diagnos OR diag3 IN visit FAILSandM;Keeping tabs on your rulesandM;Like reports and forms, R:BASE stores user-defined rules in a table calledRULES (what else?).andP;  There are several R:BASE commands that help you managerules.andP;  An important one is the SET RULES command.andP;  If you SET RULES OFF,R:BASE will ignore rules during data entry and modification.andP;   On the otherhand, if you SET RULES ON, whenever you enter or modify data using theCHANGE, EDIT, INSERT, LOAD, or UPDATE commands, the rules are checked.andP;  UseLIST RULES (or SHOW RULES) to view the status of Rules (ON or OFF) and todisplay the rules you've defined.andM;To delete a rule, use the REMOVE RULES command or Definition Express.andP;  UseREMOVE RULES # to delete a rule permanently.andP;  (&quot;#&quot; is the number of the ruledisplayed by LIST RULES).andM;The best way to modify rules in R:BASE is to use the Definition Expressmodule.andP;  You can also edit the RULES tables directly using a command likeEDIT ALL FROM RULES.andP;  I find this particularly difficult, because the rulesare stored in the RULES table in a less than obvious manner.andP;  Anotherstrategy might be to use the REMOVE RULE command to delete a rule andre-enter it from scratch using the RULES command in Define mode.andP;  I prefer touse Definition Express.andM;I won't go into all the details of using Definition Express, but here are afew hints.andP;  From the Rules Menu, choose &quot;(2) Change an existing rule&quot; to editrules.andP;  After picking the rule you want to edit (by specifying the table itapplies to and its error message), you'll be presented with the rules editingscreen.andP;  It's separated into two sections: the message and the conditions.andO;You can move between these sections by using the PgUp and PgDn keys.andP;  Thenormal R:BASE editing keys (e.g., Ins, Del, etc.) can be used to edit theerror message in the message section.andM;In the conditions section, you have a dditional function keys at yourdisposal.andP;  Use the Enter key to edit the line the cursor is on or to add anew condition.andP;  If you want to change a previously defined condition, pressEnter when the cursor is on the condition; R:BASE will walk you through theparts of the condition (see Fig.andP;  2):andM;1.andP;  The column to which the rule appliesandM;2.andP;  The table to which the rule appliesandM;3.andP;  The operator (e.g., EQ, NE, LE, EQA, NEA, LEA, etc.)andM;4.andP;  For value-checking rules, the comparison value.andP;  For table-checkingrules, the table and column of the comparison column.andM;To keep the old setting, just type Enter without moving the cursor; to modifya setting (e.g., to change the operator from GT to GE), move the cursor tothe replacement choice and then press Enter.andP;  To add a new condition, movethe cursor to a blank line and press Enter.andP;  Definition Express will thenprompt you for each part of the new condition.andP;  To remove a condition, usethe F2 key.andP;  When you're done editing a rule, press Esc to exit.andM;Rule limitationsandM;There are a few quirks and limitations to R:BASE rules that you should beaware of.andP;  As I've mentioned, each rule can only have up to 10 comparisonconditions; error messages are limited to 40 characters; and the first wordof the error message must not be an R:BASE keyword.andP;  I can live with the10-comparison restriction, since lookup tables are supported.andP;  And the othertwo restrictions are just inconvenient.andP;  Much more restrictive is the factthat rules don't allow parentheses.andP;  This can be a problem when you need tocombine several conditions with both AND and OR operators, and it makesspecifying certain rules almost impossible.andM;Another restriction is that R:BASE limits you to 20 rules per table.andP;  R:BASElets you define an unlimited number of rules, but any rules over the20-rule-per-table limit are ignored.andP;  R:BASE doesn't even warn you that yourrules are being ignored--you have to keep track of how many rules you'vedefined for each table.andM;There's one poorly documented quirk of the rules system which makes usingrules that apply to multiple tables a little dangerous.andP;  If you define a rulethat doesn't reference a specific table and later add a new table with acolumn that falls under the scope of this rule, you must re-enter the RULEScommand before the rule applies to the new table.andP;  For example, say that youenter a rule to specify that the last name in all tables must never be blank,like this: Dandgt; RULES Dandgt; &quot;The last name is mandatory&quot; lasname EXISTSandM;Then you add a new table to the database that includes the Lasname column.andO;This rule won't apply to the new table until you delete and re-enter therule.andM;Despite these limitations, rules are a flexible and powerful part of R:BASEfor DOS, a part that's often under-used.andP;  Perhaps this is because, to creategood database rules, you must have an intimate knowledge of the data, notjust the database.andP;  This often requires you, the R:BASE programmer, to talkwith the users about the nature of the data, so you can accurately guess howthe data will look before it's entered.andP;  This is difficult.andP;  You may have toenter a few test records before finalizing your rules.andP;  This way, you canstop and look at your data after an initial run-in period and fine-tune thelimits placed on your columns.andP;  The run-in period will usually suggest newrules that you may have never thought of.andM;Sometimes, defining rules involves minor annoyances, such as mistakenlycreating a rule that's too restrictive and that rejects most of your records.andO;Yes, defining rules can be a hassle; but don't let that keep you from usingthis important R:BASE facility.andP;  A little time spent here will increase thequality of your data.andP;  You know that old saying, &quot;Garbage  in--garbage out.&quot;andO;Think of rules as a way to keep your garbage bills down.andM;Paul Litwin has been an R:BASE user since version 1.0 of R:BASE 4000, back in1983.andP;  He has an MS degree in biostatistics and works as data manager for amedical research project at the University of Washington in Seattle.andP;  Paulcan be reached by writing to &quot;Data Based Advisor.&quot;andO;</TEXT></DOC>