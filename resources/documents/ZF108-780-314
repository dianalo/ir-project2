<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-780-314  </DOCNO><DOCID>08 780 314.andM;</DOCID><JOURNAL>Hewlett-Packard Journal  April 1990 v41 n2 p44(7)* Full Text COPYRIGHT Hewlett Packard 1990.andM;</JOURNAL><TITLE>Firmware development for a modular liquid chromatography system.andO;(HP 1050 Series Liquid Chromatography System) (technical)</TITLE><AUTHOR>Buttner, Christian; Fritze, Fromut; Ple, Gerhard.andM;</AUTHOR><SUMMARY>The modules that make up the HP 1050 Series Liquid ChromatographySystem fall into three categories: solvent delivery system,automatic liquid sampler, and detector.andP;  The modules are combinedto form a complete, working analysis system.andP;  The firmware, thatis the combined functionality of a complete liquid chromatographysystem, physically resides in specific modules.andP;  The objectivesfor firmware development were to reuse as much code as possible,easily maintainable code, and identical processor and userinterface hardware for all modules.andP;  Information within tablesmodifies task behavior.andP;  Using mostly hash tables or indexes toaddress entries provides good performance.andP;  A proprietaryoperating system manages the independent tasks and theirinteractions.andP;  Sixty percent of the code is common to all threemodules; 15 percent is used to generate the tables; the remaining25 percent is module-specific.andP;  The firmware is written mostly inPascal with Assembly used only when absolutely necessary.andM;</SUMMARY><DESCRIPT>Company:   Hewlett-Packard Co. (products).andO;Ticker:    HWP.andO;Product:   HP 1050 Series Liquid Chromatography System (Test equipment,electronic) (design and construction).andO;Topic:     FirmwareSoftware EngineeringPASCALChemistry.andO;Feature:   illustrationchart.andO;Caption:   Block diagram of the generic HP 1050 Series module electronics.andO;(chart)Common memory map for the HP 1050 Series processor. (chart)Workstation and emulator network for the HP 1050 Series firmware.andO;(chart)andM;</DESCRIPT><TEXT>[Figures have been omitted]andM;EACH HP 1050 SERIES MODULE is a stand-alone unit, performing one specifictask required in a liquid chromatography system.andP;  There are three types ofmodules: solvent delivery system, automatic liquid sampler, and detector.andO;Combined, the modules form a complete, working analysis system.andP;  Therefore,the scope of the firmware implementation is the combined functionality of acomplete LC system, but the firmware physically resides in specific modules.andM;Based on our experience with earlier products and the large number of newfunctions, which had to be implemented by up to ten engineers working inparallel within a time frame of two years, we took the trouble to establish arobust firmware development process with some significant new approaches.andO;Some key objectives were to reuse as much code as possible, to aim for easilymaintainable code, and to insist on identical processor and user interfacehardware for all modules.andP;  Code Reuse.andP;  One of the most important goals wascode reuse.andP;  We adapted design concepts from a previous product andemphasized strongly common solutions for all devices.andP;  For common functions,we aimed to reuse code unmodified from device to device.andP;  Even functions thatonly have common concepts got identical code and are tailored to thedevice-specific needs by tables.andP;  Easy Maintainability.andP;  Both to removedefects and to enhance the product's functions, postrelease work may benecessary on the code.andP;  In addition, the control firmware for futureinstruments may be derived from an existing version.andP;  This motivationaffected the structuring of the firmware and led to the decision to writecode in Pascal, limiting the amount of assembly language code to the absoluteminimum.andP;  Identical Hardware.andP;  A prerequisite to making and handling a largeamount of common code is the use of identical keyboards, displays, andmicroprocessor architecture in all modules.andP;  Fig.andP;  1 shows the genericelectronic hardware block diagram.andP;  The processor board, which is common toall modules, occupies one slot of the cardcage.andP;  It is based on a Motorola68008 microprocessor, has 64K bytes of RAM with 32K battery powered, and canhandle up to 512K bytes of ROM.andP;  To keep the processor board absolutelydevice independent, the ROM is physically located on a device-specific boardin another slot.andP;  Integrated on the processor board is the remote interfacecircuitry.andP;  The remote interface provides common communication lines betweenthe HP 1050 modules.andP;  Additional electronics monitor a safety sensor todetect solvent leaks.andM;Fixed address ranges are allocated to the different printed circuit boardslots.andP;  They range in size from 128K or 64K for option slots to 16K fordevice-specific slots.andP;  The internal bus system is designed to acceptadditional processor cards in all option slots.andP;  The bus system includes allthe necessary signals for data, addresses, interrupts, resets, monitoring,and control.andP;  Development EnvironmentandM;The firmware can be classified as either hardware independent or tightlycoupled to the hardware.andP;  For software development we had a number of UNIXworkstations and terminals, while we used emulators for integration and testson the target hardware.andP;  In addition, we used a central UNIX machine for filearchiving.andP;  All UNIX machines were linked by local area networks, while theemulators were linked via a high-speed link.andP;  Fig.andP;  3 shows the developmentsystem architecture.andM;Because only a limited number of prototypes and emulators were available, wemade every effort to do as much development work on the UNIX workstations aspossible.andP;  The Pascal compiler for the UNIX workstations and the crosscompiler for our target processor had some incompatibilities-for example,different import/export declarations-so to achieve compatibility we built asoftware preprocessor that handled the differences automatically.andP;  This gaveus the confidence that a procedure developed on the UNIX workstations couldbe painlessly transferred to the target hardware without error-prone manualintervention.andP;  Since we didn't want to expend too much effort in building asimulation of the target hardware, software verification on the UNIXworkstations was restricted to the lesshardware-dependent parts.andM;Beyond the common UNIX directory structure, each developer had the sameuser's directory structure to contain sources, documents, and tools.andP;  Thesource directories were set up to contain either common code used by allmodules or module-specific sources.andP;  Fig.andP;  4 shows the directory structure.andM;To support the Pascal preprocessor we added include and object directories inparallel with each source directory.andP;  The include directories containedconstants, types, functions, and procedure declarations exported by a givensource file.andP;  These were automatically generated by the preprocessor andhelped to adjust for the different compilers' import/export concepts.andP;  Theobject directories contained either purely UNIX or target-processorrelocatable code and made the distinction between the two more obvious.andM;The preprocessor concept and its import/export requirements had the advantagethat we could trace all imports of a given file.andP;  Doing this recursivelystarting with the main program finds all needed sources.andP;  Thus, we couldeasily compile the complete system by just referring to the main program.andO;Alternatively we could automatically check for changed sources and update theaffected and dependent files.andP;  In the same way we were able to link allnecessary object files into an executable file, without the burden ofmaintaining and updating make files.andP;  Again, we just referred to the mainprogram when calling the link utility, and it collected all requiredrelocatables automatically.andP;  To add a new source file, we only had to add anew include statement to the calling source file and the tools took care ofthe compilation and linking.andM;Because we traditionally use a proprietary multitasking operating systemwithin our firmware, we faced the difficulty of simulating that operatingsystem on top of the UNIX operating system.andP;  This allowed us to use the UNIXworkstations to verify entire tasks including their communications.andP;  SincePascal doesn't support switching the stack pointer and the program counter(necessary to swap tasks), we used assembly language for our target machines.andO;Unfortunately, no assembler was available for our HP 9000 Series 500 machine,so we had to look for another solution.andP;  Thus we used one fork-createdprocess per task on the UNIX workstations.andP;  Control between the processes wastransferred by UNIX signals while shared memory emulated the targetprocessors' common RAM.andP;  Although this isn't as speedy as an assemblylanguage solution for switching contexts, it worked fine for our simulationpurposes.andM;Revision Control SystemandM;The UNIX revision control system (RCS) was quite heavily used and veryvaluable, since we had different teams for the various modules workingsimultaneously.andP;  For all functionality we added scripts to access the RCSfrom any UNIX machine within the network.andP;  We also added procedures to checkout all files for a given source directory at once.andP;  This gave us the abilityto maintain software packages as a single source directory (e.g., operatingsystem, dialog, parser, etc.).andP;  From time to time, for example when newfunctionality was added, we had new incompatible versions of a given package.andO;To handle this we simply incremented the major number of that package'sinternal release and came up with rules like: &quot;For parser version 4.X youneed operating system version 5.X.&quot; A major benefit of the revision controlsystem is its ability to update a string containing condensed statusinformation for a file version.andP;  We put this string into the object code andthe final executable code by placing it into a string constant within eachfile (e.g., c_rcsid = &quot;$Header: env,v 1.1 89/06/27 10:58:30 ffritze Exp $&quot;).andO;Thus we had the ability to backtrace the files associated with a givenrelease by simply scanning the executable code or EPROM for that stringconstant.andM;Design OverviewandM;In the beginning of the design process we identified all common functionblocks and tried to structure these so that we could easily tailor them toeach specific instrument's needs.andM;Functions were segmented to minimize the interfaces between them.andP;  Weassigned related functions to tasks handling a given set of data (e.g.,andO;parameter handler) or resources (e.g., remote control task).andP;  By assigningpriorities for the tasks we made the real-time behavior of the module moreresponsive to hardware and user interaction.andM;To allow reuse of the common generic tasks and utilities, we had to find away to adapt their behavior to each instrument's individual needs.andP;  To ensurea stable and maintainable platform, we voted against individual modificationsof common code.andP;  Instead, we designed the tasks so that their behavior couldbe modified by supplying appropriate information within tables.andP;  Goodperformance is achieved by using mostly hash tables or indexes to addressentries rather than interpreting through a whole table.andP;  The instruments'behavior was completed by adding specific tasks (e.g., execution tasks) andinterrupt routines (e.g., hardware scanner).andP;  Task Structure and interactionandM;The system consists of several independent tasks, as shown in Fig.andP;  5.andP;  Thesetasks and their interactions are managed by a proprietary operating system.andM;To explain the interaction of the different tasks, let us assume that a userhas just pressed a key.andP;  This is sensed by an interrupt routine serving askeyboard scanner, which sends a key mail message to the dialog task.andO;Depending on the contents of its tables, the dialog task changes its state,executes some macros, and builds up a new display by sending mail to thedisplay task.andP;  The display task thus reflects the entry of the key to theuser.andP;  In parallel, the update task is informed of a new state and stops itsperiodic update of the display.andP;  Once the user has completed the instructionit is not only echoed by the display, but also sent to the parser.andP;  Dependingon the contents of its tables, the parser task checks for valid range andbuilds an internal instruction.andP;  This is mailed to the parameter handler, acentral task dealing with all instrument parameters.andP;  The parameter handlerchecks the instruction for correctness with respect to other dependencies.andO;To find incompatible settings before execution of a measurement, theinstruction is sent to a verify task.andP;  Once this check is passed, thesetpoint is stored within the parameter handler.andP;  An acknowledgment is sentto the parser and forwarded to the dialog task, the display, and the user.andO;If the new setpoint belongs to the currently active parameters (called theactive method) it is also transmitted to the execution task.andP;  Otherwise, themethod handler gathers the settings for later execution.andM;Simultaneously, depending on the dialog state, the update task may query theparser for actual readings.andP;  These requests are forwarded directly to theresponsible execution task.andP;  The answer is translated backwards by the parserand mailed to the update task, which displays it via the display task.andO;Independently, the hardware is monitored by periodic routines such as theremote control scanner and the leak scanner.andP;  Any errors or triggers (e.g.,andO;sample injection) are sent to the event handler task, which performs systemstate transitions (e.g., waiting into run) according to its state table.andO;Triggers may also be logged into the logbook task, while state transitionsmay be reflected, for example, by LED changes or remote control linesettings.andP;  The logbook task maintains a logbook file, which can be accessedby a user to get information on the history of the system.andM;Task ConfigurationandM;To provide a useful building block for several chromatographic modules, wehad to consider the system integration process.andP;  It was obvious that oursoftware development process had to support parallel work on several specificand common tasks.andP;  All intertask communication is accomplished by sending andreceiving mail.andP;  To decouple system integration from the progress of anindividual task or of other modules, we took a new approach to taskconfiguration.andP;  In contrast to the more traditional close ties betweencorresponding tasks (i.e., by static tables), we deliberately tried todecouple the individual tasks as much as possible.andP;  Thus we came up with anautomatic mail configuration process.andM;At start-up, each task registers with the operating system to reserve therequired resources (e.g., RAM, stack) and get the needed priority.andP;  In thisprocess, each task declares its needs with respect to mail.andP;  A task maycontain several mail producers and consumers.andP;  These are announced to theoperating system.andP;  As the mail manager is informed about the type of mail tobe received or sent it performs two main services: it generates mail routesleading from each producer to all mail consumers interested in the same sortof message, and it assigns an appropriate number of buffers to each producer.andO;This guarantees availability of the requested resources to each producerbetter than a common pool of buffers, which could be easily emptied by asingle producer.andM;After initialization the multitasking starts and the tasks compete for CPUtime.andP;  Our multitasking is not time-sliced, so a task continues to operateuntil a higher-priority task is scheduled or it suspends itself waiting formail.andP;  A more important task is only scheduled once it receives mail, eitherfrom an interrupt-based scanner or from the currently executing task.andP;  Theexecuting task thus gets interrupted and suspended while the higher-prioritytask is awakened with mail received.andP;  Thus we use a mail-driven multitaskingsystem.andM;Mail ManagementandM;The smart mail management system handles all kind of situations: producerswithout consumers, consumers without any producers, several producers for agiven type of mail, multiple consumers for some mail, consumers of severaldifferent types of mail, and producers of multiple mail types (see Fig.andP;  6).andO;This built-in flexibility allows easy addition and integration of a new taskwithout modifying tables.andP;  If a consumer never receives mail, it is notbothered and never awakened.andP;  In contrast, a producer's mail that has noconsumer is simply short-circuited back to the producer.andM;This flexibility made it possible to have early working prototypes by, forexample, defining returned mail to be an acknowledgment although no one hadever received that mail.andP;  It also allowed easy adding of functionality.andP;  Forexample, assume we want to trace what keys are pressed.andP;  We simply write atask that registers for key mail as a consumer.andP;  It will automaticallyreceive all key mail, and its only responsibility is to forward the mailafter tracing.andP;  One can look at tasks simply as objects to be added to asystem, while the system resolves all connectivity and resource issues.andM;Table-Driven ApplicationsandM;As already explained, the objective of writing reusable code led to afirmware system composed largely of generic parts that are tailored tospecific uses with the help of tables.andM;Several ways of building ROM tables were considered:andM;* Pseudoinstructions.andP;  The tables are built by defining constantsandM;with the help of the compiler or by defining theandM;memory contents with the help of assembler pseudo instructions such as;andM;DS.B  VALUEandM;DS.W  #PROCESS_XYandM;* Cross generation.andP;  The tables are generated on a remote computer with thehelp of tools on that computer (UNIX shell scripts, lex/yacc etc.).andM;* Generate tables with the help of Pascal.andP;  The tables are generated by aPascal program that runs on the target processor.andP;  The program initializes amemory area for its own variables, which will later be used as the table.andM;In the past, we have used the first method, pseudo instructions, forpresetting memory locations (small tables, structured constants).andP;  The pseudoinstruction technique has the advantage that the assembler/linker places thedefined bytes and words in the ROM area automatically, whereas with the othertwo alternatives this must be managed separately after the tables are built.andO;The problem with this approach is that there is no automatic link between theassembler statements and the data structure of the final table.andP;  There is noautomatic way of detecting errors in those tables once they are written.andO;Typically the errors show up later at run time.andP;  With this experience in mindwe rejected this alternative.andM;The second alternative, cross generation, has the potential of a powerfulcomputer with all of its tools, but still has the disadvantage of not havinga link between the data structure of the cross-generated table and the datastructure of the programs that later interpret that table.andM;The third alternative has all the disadvantages of a  typical) targetenvironment, including reduced memory space, no or poor operating system, andno tools.andP;  On the other hand, there are some important advantages.andP;  First,the procedures building the table use the same data structure (Pascal typedeclaration) as the interpreting procedures.andP;  Second, the table generationprocess can use the features of the Pascal programming environment, includingthe compiler (type checks).andP;  Because of these advantages, this alternativewas chosen.andM;Table GenerationandM;Every generic Pascal procedure that has to be customized by a predefinedtable has to provide a set of Pascal procedures that can be used to build upthe table.andP;  When generating the tables, the parameters passed to theseprocedures and the sequence of the procedure calls determine the contents ofthe table.andP;  This process of table generation has to be done once beforecalling the generic procedure, for example during the start-up phase in theemulator.andM;Typically the code for table generation is much bigger than the amount ofmemory used for the final table.andP;  Therefore, the table generation code isexcluded from the final instrument firmware.andP;  This is achieved by burning thetables into ROM after a &quot;protostart&quot; program execution in which only thetable generation code is executed (see Fig.andP;  7).andP;  This burning into ROM isdone together with the step of burning the whole firmware.andM;The following is an example of table generation from the parser tablegeneration process:andM;PROCEDURE set_cmd_table; BEGINandM;node('LIST', list_token,  lev_1, lev1 7,  syn_colon  );andM;leaf('SlG1',tok_wll,  lev_1, mc_para_instr, syn_signal );andM;leaf('RTIO', tok_rthres,  lev-1, mc_pra_instr, syn_ratio  );andM;leaf('PKWD', tok_pkwidth,  lev-1, mc_para_instr, syn_Width  );andM;leaf('OFC1', tok_fcode1,  lev-1, mc_para_instr, syn_fcode  );andM;leaf('AZEl', tok_azero1,  lev-1, mc_para_instr, syn_daczero);andM;leaf('ATCA', tok_autor_al,  lev-1, mc_para_instr, syn_on_off);andM;leaf('PLSP', tok_plotp,  lev-1, mc_para_:instr, syn_plotp );andM;leaf('FMXP', tok_maxp,  lev-1, mc_para_instr, syn_maxp  );andM;leaf('SCNP', tok_scanp,  lev-1, mc_para_instr, syn_scanp  );END{seL_cmd_table};andM;Node and leaf are Pascal procedures that are called to build up the parsertables.andP;  The parameters passed to these procedures are instruction keywords,syntax descriptors and internal tokens for them, and the mail routes to theexecution tasks.andP;  ResultsandM;Fig.andP;  8 shows the amount of code written for the HP 1050 modules in thousandsof noncomment source statements (KNCSS).andP;  More than half of the code (60%) iscommon to all three modules.andP;  This common code is tailored to the specialneeds of the modules by tables which are generated by about 15% of the code.andO;The rest of the code (25%) is module-specific.andM;Almost all of the firmware is written in Pascal.andP;  Assembly language is onlyused where necessary, for example in the operating system for stack pointermanipulations and interrupt handling or for performance reasons like the RAMtest during the start-up phase and data acquisition in the detector.andP;  Strictuse of the revision control system (RCS) helped us manage the potentialproblems of incompatible versions of up to 20 tasks.andP;  Automatic taskconfiguration and the automatic include and compile-if-necessary mechanismshelped the firmware engineers change or add tasks without knowing about thecomplete system in detail.andP;  The high level of common code gave us:andM;* Three times as much test time on the common firmware parts as oninstrument-specific parts.andP;  Therefore, the common firmware parts turned outto be very robust.andM;* Common understanding and knowledge of the firmware in each instrument onthe part of all firmware engineers working on that project.andP;  This put us in aposition to balance manpower among the teams working on a specificinstrument.andM;* Early prototypes for both hardware and user interface tests as a result ofconcentration of effort on the common firmware parts at the very beginning.andM;* The basis for future enhancements that are common to all instruments (e.g.,andO;communication interfaces).andM;* The basis for new instruments to be developed.andM;In the future, the extensive use of tables will allow us to enhance thefunctionality of the instruments incrementally, or to modify, for example,the user interface without altering the common firmware parts.andP;  Ourexperience has shown that modifying the tables is almost always bug-free thefirst time.andP;  Also, improvements of the common firmware parts in terms ofperformance or functionality always count three times.andM;AcknowledgmentsandM;The success of this exacting firmware project is the result of good teamworkby the programmers and the support of the hardware engineers.andP;  The authorswant to thank in particular Herbert Anderer, Fritz Bek, Volker Brombacher,Guenter Hoeschele, Michael Leiber, Klaus Weber, and Klaus Witt for theirvaluable contributions in programming and in team discussions.andP;  Also, manythanks to Claus Lueth, who had to deal with many proposals and complaintswhile designing and implementing the common processing hardware.andO;</TEXT></DOC>