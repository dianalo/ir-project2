<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-182-696  </DOCNO><DOCID>08 182 696.andM;</DOCID><JOURNAL>Data Based Advisor  Jan 1990 v8 n1 pS8(6)* Full Text COPYRIGHT Data Based Solutions 1990.andM;</JOURNAL><TITLE>Introduction to a new decade: banking on database managementsystems. (overview of database technology) (technical)</TITLE><AUTHOR>Kalman, David M.andM;</AUTHOR><SUMMARY>There are many parallels between using a database managementsystem (DBMS) and using a bank.andP;  The heart of a DBMS is theengine, which reads, writes and organizes data.andP;  The engine inmultiuser databases also handles security and concurrency control.andO;Engines are chiefly accessible through command languages or menus.andO;Programs such as dBASE in which the engine and the user interfacehave been sandwiched together work fine for single users, but poseproblems in multiuser systems.andP;  The solution is to run the engine,also known as the database server, on a file server and the userinterface on individual microcomputers.andP;  Client/server systemsprovide access to data on remote servers without the necessity ofchanging applications.andP;  Many DBMS, such as dBASE and R:BASE, offerhigh-level procedural, or English-like step-by-step, programminglanguages.andM;</SUMMARY><DESCRIPT>Topic:     TrendsData Base Management SystemsTechnologyNetwork ArchitectureSoftware DesignApplicationsUser InterfaceData Base LanguagesProgram Development Techniques.andM;</DESCRIPT><TEXT>Introduction To A New DecadeandM;Using a database management system in the '90s is a lot like going to thebank.andP;  Banks offer services, such as tellers, ATMs, drive-up windows, andtouch-tone phone services that provide access to the vault.andP;  Databasemanagement systems offer services, such as programming languages and end-userapplications, that give access to the database.andM;In a bank, you show the teller your identification.andP;  You make deposits andwithdrawals.andP;  If your balance falls below zero, the teller won't let you casha check.andP;  In a database system, you enter a password.andP;  You can &quot;deposit&quot; and&quot;withdraw,&quot; but instead of money, you deal with data.andP;  If the number ofwidgets in the database falls below five, the database application shouldn'tlet you sell 10.andM;With both banks and databases, users must use the accepted service, or&quot;interface.&quot;andP;  You couldn't (legally) run into a bank and grab a bag of cashfrom the vault.andP;  Nor would you dump a database file into a word processor towrite a report (you'd see a lot of file header garbage, delimiters, and othermessy characters).andM;Legal bank interfaces include tellers, night deposit boxes, and ATMs.andO;Database management systems of this new decade have multiple interfaces,allowing access to the database in a variety of ways.andP;  A programmer might usea language such as C, Pascal, dBASE, or SQL.andP;  A user might use a SQL or dBASEfront end, a spreadsheet application, or even a computer-aided design (CAD)program.andP;  These interface tools represent entry points into the database,that invaluable corporate asset.andM;The engineandM;At the center of the database management system lies the &quot;engine&quot; that reads,writes, and organizes data.andP;  In multiuser databases, the engine also handlessecurity (passwords, for example) and concurrency control (giving users themost current view of the data without trashing it).andM;The engines in PC database products have been accessible mainly through&quot;built-in&quot; menus or command languages such as Paradox's PAL and R:BASE.andP;  Inaddition, the database engine and user-interface layers have been sandwichedtogether in one program.andP;  For example, dBASE III PLUS consists of a userinterface and a file manager in one package.andM;On single-user systems the sandwich approach works just fine; however, onnetworks it can bog down.andP;  On a network, the data handling functions operateat the workstation, but the data resides on a file server.andP;  When a userrequests a specific piece or set of data, the database system drags all thedata from the file server to the workstation, where it decides what to keepand what to discard.andP;  Because the intelligence is in the workstation, largeamounts of data move across the network.andP;  With many users requesting data,network response slows significantly.andP;  Then add to this the fact that eachworkstation controls security and concurrency.andP;  In this scenario, datasharing consists mainly of collision management--sharing data by bumping intoother users as efficiently as possible.andM;The solution to these problems is to separate the database engine from itsuser-interface components, running the engine or &quot;database server&quot; on anetwork file server, and running the user interface on the workstation.andP;  Thisis the client/server architecture (CSA).andP;  The Ashton-Tate/Microsoft SQLServer, Gupta Technologies' SQLBase server, ORACLE Server, XDB Server, andNovell's NetWare SQL are all client/server database managers.andM;In a client/server system, the database server and the workstationapplications (a.k.a.andP;  front ends, user interfaces, surfaces, or clients)operate independently.andP;  In simple terms, when the workstation issues a query,the database server sends back only the requested data.andP;  This design providesmore reliable concurrency control, improved security, and increasedperformance.andP;  Considering these attributes, LAN-based client/server systemsprovide a real alternative to minicomputer and mainframe database systems,with a tremendous savings.andM;The benefits of separationandM;In the 1990s, as local area networks (LANs) proliferate and connect withlarger computers, applications of many kinds will have access to distributeddata (on a combination of LANs, minicomputers, and mainframes).andP;  Theapplications may vary, but how they access the data will be standard.andO;Client/server systems offer a model by which users can access data on&quot;foreign&quot; servers without having to change applications.andM;Client/server architecture also provides a better way for applications toshare data, even on stand-alone systems.andP;  A single database engine can serveword processors, spreadsheets, and traditional database applications.andP;  Ingraphical interface systems, such as Microsoft Windows, Presentation Manager,and the Apple Macintosh, diverse applications appear on the desktop as one.andM;Application-independent database engines make it possible for applications toshare data seamlessly.andM;The new database architecture also provides multiple access methods,including direct access to the engine's low-level functions via functioncalls, or &quot;hooks&quot; (also called APIs, for application programming interface).andO;Experienced programmers can write custom systems in languages such as C orPascal.andP;  This provides maximum performance and flexibility, and makes itpossible to integrate database management systems with external devices suchas robots, sensors, and modems.andM;To take full advantage of relational database engines, programmers can embedSQL statements in low-level languages for data definition, control, andmanipulation.andP;  Among its many attributes, SQL provides a standard that makesit possible for diverse applications to share data intelligently.andM;Application tools: high-levelandM;procedural languagesandM;Programming in C or COBOL has its advantages; however, it's time-consumingand requires years of training to do well.andP;  To make programming morepalatable and productive, many database managers offer high-level procedurallanguages such as dBASE, PAL, and R:BASE.andP;  High-level means English-like (ormore French-like if you speak French).andP;  Procedural essentially means&quot;step-by-step.&quot;andP;  In a procedural language, the programmer specifies dataentry screens, program flow, reports, and queries, and manipulation of dataone record at a time.andP;  These languages differ from general-purpose languagesin that they include file handling commands and functions specific to adatabase engine.andM;The benefits of procedural languages include flexibility andcomprehensiveness.andP;  They allow programmers, ranging from novice to expert, tocontrol every aspect of an application with program statements.andP;  By theircomprehensiveness, these languages often provide several ways to accomplishthe same goals, giving beginners an opportunity to get the job done whilelearning to program.andM;Procedural languages provide line-by-line control of the user interface.andO;Boxes, colors, windows, input fields, and on-screen reports can bemanipulated individually.andP;  A wide range of functions provide numeric, string,and date manipulation.andP;  Experienced programmers can use procedural languagesto create amazing screen effects or complex reports.andM;The major disadvantage of high-level procedural languages is productivity fornon-programmers, or lack thereof.andP;  For the non-programmer, learning and usinga procedural language can consume more time than is ultimately saved.andO;Learning and using the many commands and functions is half the battle.andO;Non-programmers may find the concepts of program control and input/outputequally intimidating.andM;For the programmer, high-level procedural languages are more productive thanC, COBOL, or Pascal; however, low-level languages such as C run faster andprovide better control of the computer hardware.andP;  Also, learning a newlanguage still takes considerable time.andP;  Except for dBASE, high-levellanguages are considered &quot;non-standard,&quot; and a knowledge of relativelyobscure languages may not apply to the next job or project.andM;Non-procedural languagesandM;High-level languages can also be non-procedural.andP;  These are often called&quot;Fourth Generation Languages&quot; or &quot;4GLs&quot;.andP;  Products noted for their 4GLsinclude Progress, Informix, NPL/R, and generally all SQL databases (since SQLis a specialized 4GL).andP;  4GLs take a non-procedural approach, treating datanot so much as strings or numbers, but as entities, sets, or objects.andO;Non-procedural commands manipulate data without the programmer specifyingeach detail (such as SKIP or GOTO RECNO()).andP;  By moving the developer fromstring-handling to entity- or set-handling, the development process betterreflects real-world relationships.andM;4GLs are often associated with data dictionaries--tables containing dataabout the database.andP;  Any data entered into a table is validated according tothe rules in the dictionary.andP;  By giving the database some facts about itself,such as relationships between tables and values, screen display formats,calculations, and security controls, the 4GL can contain fewer, yet moreexpressive, commands.andP;  (In distributed systems, the data dictionary may alsoindicate the location of data on other computers).andP;  Comprehensive datadictionaries are sometimes called repositories.andM;The data dictionary may define a column, or field, as the sum of four otherfields.andP;  Or it may describe a display attribute, such as a color.andP;  In moreevolved 4GLs, the data dictionary may also contain business rules.andP;  Forexample, a rule may prevent you from deleting a DEPT without first deletingthe EMPLOYEEs in the DEPT.andP;  Generally, the more information in the datadictionary, the less code complexity in the 4GL application, and the moreproductive the development cycle.andP;  The data dictionary also enhances dataintegrity, both within and across applications, because all input isvalidated centrally.andM;Despite their advantages, 4GLs share some of the disadvantages of procedurallanguages.andP;  Because they're so closely tied to proprietary data dictionaries,4GLs (other than SQL) are non-standard.andP;  4GL syntax is specific to eachvendor's database management system.andP;  And despite the non-procedural handlingof data, 4GLs often rely upon procedural statements for report writing andforms design.andP;  Even with report writing programs and screen painters, 4GLsstill require significant training for non-programmers.andM;Object-oriented programming languages extend the 4GL concept.andP;  These havemany of the characteristics of 4GLs, except they extend the entity metaphorto include procedural programming constructs.andP;  Commonly used procedures, suchas forms, reports, and queries, are saved in libraries or in a datadictionary.andP;  Each procedure becomes a self-contained, modular &quot;object&quot; thatcontains information about itself.andP;  Because the object is self-contained, itcan respond to other object, or to the user, via messages it receives.andO;Because objects are generally always &quot;ready&quot; and waiting for input,object-oriented programming systems are often called &quot;event-driven&quot; systems(where a message from another object, the system, or the user is consideredan event).andP;  For programmers, new objects become part of the language.andO;Objects can be modified, copied, and re-used.andP;  As a programmer develops moreobjects, speed of development increases.andM;dBASE programmers may already recognize object-oriented characteristics inWallsoft's UI2.andP;  UI2 templates are objects (written in a template language)that convert to dBASE code.andP;  Like 4GLs, object-oriented languages can reducethe complexity of the application code.andP;  They also allow a programmer tomodel business problems in the programming language.andP;  An invoice object, forexample, could be copied, modified, or re-used.andM;The varied approach to database managers, from low-level to object-orientedprogramming, provides a solid foundation for productive applicationsdevelopment.andP;  But as we enter the 1990s, we'll find that the problem withprogramming is that you still have to learn to write code.andP;  If the goal ofapplication development is to reduce development time, maintenance cost, andtraining cost, it's clear that there's room for even more layers on the&quot;database pyramid&quot;--layers that eliminate programming.andM;Most of us are familiar with code and application generators.andP;  These programsinterpret a user's input (through menus, pictures, or dialog responses) andproduce the specified program code.andP;  The code may range from low-levellanguage output (e.g., C, COBOL, and Pascal), to procedural language output(e.g., dBASE IV AppGen, Genifer, and R:BASE Express) to 4GL output (Informixand SQL Forms).andP;  Some generators specialize in specific pieces of anapplication, such as Russ Freeland's SCRIMAGE screen designer.andP;  Others, suchas R:BASE Express, produce full, working applications.andM;The good news is that generators spare developers from having to rewritetedious, repetitive procedures.andP;  They also allow developers to createapplication prototypes quickly.andP;  In experienced hands, a code generator cancut development time substantially.andP;  Generators also extend the capabilitiesof novice programmers.andP;  Writing a complex report is best handled by a capablereport generator, especially in a crunch.andP;  At the same time, code generatorsprovide many code examples from which to learn.andM;A problem with generators is that they accept input and generate code--aone-way process.andP;  If you modify the code of a generated system, and thenregenerate it, you wipe out the modifications.andP;  This wouldn't be a problem ifyou never had to modify the generated code.andP;  However, reality is different.andO;Generated systems, invariably, require changes.andM;For non-programmers, code and applications generators pose a differentproblem.andP;  Although they may eliminate the need to write code, even the bestgenerators still require an understanding of how an application works.andP;  Thisunderstanding includes the concepts of program flow, input/output, anddatabase design.andP;  Of course, these concepts can be (and perhaps should be)learned.andP;  However, code generators are often sold with a &quot;no programming, nospecial training&quot; promise.andP;  As always, anything that seems too good to betrue, probably is.andM;At the top layer of the database of the 1990s, we find application generatorsthat donht necessarily produce code.andP;  In these systems, the designenvironment and the application are inseparable.andP;  The design environment mayconsist of Macintosh icons moved around the screen as in Odesta's DoubleHelix, or Entity-Relationship diagrams tied to a 4GL as in Zanthe's Zim.andP;  Outof the dBASE world comes Symmetry Software's Symmetry IV or Quiktek'sSchooner, a data driven application designer based on the Clipper engine.andO;The application you create is itself data that you never see.andP;  With thesesystems the specification and design process produces a working application.andO;The design, generation, testing, and maintenance phases are integrated into acommon developer interface.andM;This development approach is the basis of Computer Aided Software Engineering(CASE) tools.andP;  CASE is based on the notion that you can analyze, design,generate, test, and maintain an application by translating a designspecification directly into a working application.andP;  Programming is replacedby drawing flow charts, manipulating icons, embedding procedures, anddepicting relationships graphically.andM;Where CASE differs from similar generators is in its emphasis on designmethodologies, such as Chen's Entity Relationship Analysis (ERA) and Orr'sData Structured Systems Development (DSSD).andP;  A carry-over from CASE's rootsin the large systems world, this emphasis promotes group development.andO;Programmers and systems analysts can join development projects without aknowledge of the source code, only of the methodology.andP;  The emphasis onmethodology depends on a high level of training in systems analysis anddesign.andP;  So, in its most parochial implementations, CASE doesn't respond tothe needs of PC developers and users.andP;  PC users are generally untrained indesign methods, plus they tend to work alone, or in groups by dividing tasks.andM;In its most innovative forms, PC CASE tools have already begun to break thedependence on systems analysis expertise by building that expertise into thesystem.andP;  For example, Syscorp International's MicroSTEP lets the user designa system intuitively, by moving icons (building blocks) on the screen.andP;  Theresult is a rigorous system, written in C, that can access dBASE DBF files,and which is maintained entirely through the design environment.andP;  AfterMicroSTEP generates an executable program, it even erases the C source code(you can preserve it if you so choose).andP;  In the 1990s, we can expect PC CASEtools to provide even more design guidance.andP;  Using expert systems techniques,these tools will replace the application generators used on PCs today.andM;Database architectureandM;The client/server architecture and the layers of database tools reflect thegeneral nature of database management in the 1990s.andP;  Separating the databaseengine from the front end lets many front ends access common back ends, amodel that translates well to single-user, multiuser, and distributedsystems.andM;On single-user systems, this design allows true integration at the databaselevel, just as systems such as Smart, Enable, Open Access II, Symphony, andFramework first allowed integration at the user-interface level.andP;  Forexample, you could have a set of OS/2 Extended Edition-compatible or EmeraldBay-compatible applications that look nothing alike, yet use the same data.andO;As another example, C applications, WordTech's ORACLE dBXL, and Lotus 1-2-3could access ORACLE data.andM;On multiuser and distributed systems, you have these same benefits--and more.andO;With a database server, workstations can share data simultaneously.andP;  dBASEIV, Microsoft Excel, and Paradox could share data on an Ashton-Tate/MicrosoftSQL Server.andP;  Paradox, Microsoft Excel, and Revelation might share data onGupta's SQLBase server.andP;  C and Vulcan programs could share Emerald Bay data.andO;In distributed systems, PC applications can access data residing on acombination of microcomputers, minicomputers, or mainframes.andP;  What makes&quot;distributed&quot; data different from &quot;multiuser&quot; is the ability to treat remotetables in different locations as if they're part of one database.andP;  Productsin this category, or moving toward it, include SQLBase, Paradox, andMicrorim's soon-to-appear DBMS, Atlas.andP;  In all these cases, SQL makes thedistribution of data possible.andM;One step beyondandM;The separation of tasks, as in the client/server model, is the precursor topowerful multi-tasking, multi-processor systems.andP;  We now have databaseservers as back ends to client applications on LANs (multiple processesconnected by a wire).andP;  We'll soon have multi-tasking database engines andapplications running in parallel on the same processor.andP;  Eventually, we'llsee the physical separation of tasks, running on multiple processors, withinthe same desktop computer (such is the promise of IBM's Micro ChannelArchitecture).andP;  The multi-layered database of the 1990s will make theseadvances possible.andM;SummaryandM;The direction of database management is toward intelligent connectivity.andO;Developers and users can have access to distributed data without compromisingthe power of their desktop computers.andP;  The division of user interface anddatabase tasks gives PC/workstation users access to valuable data, withouttaking away the control that makes desktop computers popular and productivetools.andM;The client/server architecture promotes a diversity of applications, offeringadvantages for users, and opportunities for creative developers.andP;  With robustengines, developers who produce front ends can concentrate on making themmore productive for users.andM;The PC database products of the 1980s were powerful, complex tools usefulprimarily to developers or to those willing to become developers.andP;  Even withcode generators and menu systems, developing applications required anunderstanding of data structures and program logic that most users couldn'tacquire productively.andP;  In the 1990s, the demand for applications will grow.andO;In turn, more users will need to develop and maintain their own applications.andO;In a bank we have a variety of ways to make a withdrawal.andP;  The layeredapproach to database management tools, ranging from low-level languages toCASE systems, provides both developers and end-users the keys to the databasevault.andM;David M. Kalman is the Editor-in-Chief of Data Based Advisor magazine andauthor of The dBASE Language Handbook.andO;</TEXT></DOC>