<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF109-452-459  </DOCNO><DOCID>09 452 459.andM;</DOCID><JOURNAL>Communications of the ACM  Sept 1990 v33 n9 p61(4)* Full Text COPYRIGHT Association for Computing Machinery 1990.andM;</JOURNAL><TITLE>Implementation benefits of C++ language mechanisms.andO;</TITLE><AUTHOR>Jordan, David.andM;</AUTHOR><SUMMARY>C++ is an extension of the C programming language developed byBjarne Stroustrup at ATandamp;T Bell Laboratories in the early 1980sthat provides data abstraction and object-oriented programmingfacilities.andP;  It provides a natural syntactic extension to C thatincorporates the class constructs from Simula.andP;  C++ was designedto be compatible and comparable with C in syntax, performance andportability; it provides more static type checking than otherobject-oriented languages and uses user-defined types (classes)and built-in types as part of a single unified type system obeyingidentical scope, allocation and naming rules.andP;  C++ supports easyprogrammer and software migration from C-based applications to thenew object-oriented programming facilities.andP;  Key features of C++2.0, which is the ANSI and ISO standard, are described.andM;</SUMMARY><DESCRIPT>Topic:     C Programming LanguageObject-Oriented ProgrammingEnhancementsProgramming LanguagesStandards.andM;</DESCRIPT><NOTE>Only Text is presented here; see printed issues for graphics.andO;</NOTE><TEXT>Implementation Benefits of C++ Language Mechanisms C++ was designed by BjarneStroustrup at ATandamp;T Bell Laboratories in the early 1980s as an extension tothe C language, providing data abstraction and object-oriented programmingfacilities.andP;  C++ provides a natural syntactic extension to C, incorporatingthe class construct from Simula.andP;  A design principle was to remain compatibleand comparable with C in terms of syntax, performance and portability.andO;Another goal was to define an object-oriented language that significantlyincreased the amount of static type checking provided, with user-definedtypes (classes) and built-in types being part of a single unified type systemobeying identical scope, allocation and naming rules.andP;  These aims have beenachieved, providing some underlying reasons why C++ has become so prevalentin the industry.andP;  The approach has allowed a straightforward evolution fromexisting C-based applications to the new facilities offered C++, providing aneasy transition for both software systems and programmers.andP;  The facilitiesdescribed are based on Release 2.0 of the language, the version on which theANSI and ISO standardization of C++ is being based.andM;ParadigmsandM;C++ supports the object paradigm but does not enforce it; it is amulti-paradigm language.andP;  Programmers who have primarily used proceduralparadigm decomposition techniques can migrate to the language at acomfortable pace and still achieve many benefits of the language.andP;  Many canuse predefined object-oriented C++ libraries, incurring only a minimallearning curve.andP;  Because of the syntactical similarity to C, this is naturaland does not result in software appearing as a mixed collection ofprogramming styles.andP;  Thus C++ has become a major vehicle for the migrationfrom traditional &quot;produre-oriented&quot; programming and design techniques to dataabstraction and object-oriented programming.andM;C++ As A Better CandM;As an extension to C, C++ supports the basic data types in C; not all datatypes are of an &quot;boject type.&quot;andP;  C++ is often initially used &quot;as a better C,&quot;taking advantage of the strong type checking facilities (some of which werelater incorporated into the ANSIC C standard).andM;The name and argument types of a function are included in its signature,allowing function name overloading.andP;  This allows mnemonic name to be reusedin all appropriate contexts, reducing namespace clutter and the need todevise unique and often cryptic names.andP;  The likelihood of name collisions isreduced when separately designed software is integrated into an application.andO;A function prototype specification must precede the use of a function so thecompiler can do argument type checking.andM;C++ also allows programmers to define functions as inline, allowing the codeof the function to be expanded where it is called, eliminating procedure calloverhead.andP;  Inline functions provide the benefits of macros in C, but gofurther by providing argument type checking.andP;  Sometimes inline functions canresult in both a reduction of code size and an increase in execution speed.andO;But inlining is not a panacea and can be overused, sometimes resulting insignificant code expansion.andM;The reference type in C++ provides call by value syntax, but with theefficiency and operational characteristics of passing an argument by address.andO;A reference must be initialized when declared and cannot be changed,providing some protection against improper uses of pointers.andP;  A reference isan Ivalue, allowing functions that return a reference to be used on theleft-hand side of an assignment.andM;The const specifier in C++ allows data/objects to be defined a read-only.andO;This allows programmers to provide constants of any data type and ensure thatparameters passed to a function by address or reference are not changed bythe called function.andM;Defining New TypesandM;The class construct in C++ allows programmers to define new data typescompletely, so that they operate as if they were directly supported in thelanguage.andP;  Objects are instances of these classes; members of a class can befunctions or data.andP;  One can fully specify the functionality of the typemechanisms in the language, allowing new types to have all the expressivecapabilities possessed by the built-in types borrowed from C.andP;  This includesspecifying operators to handle assignment, initialization and typeconversions, for example.andM;Nearly all the built-in operators of C can be associated with functions whoseoperands include user-defined types; artihmetic, comparison, logical,dereferencing and subscripting operators, for example.andP;  As a synthacticalconvenience, operator symbols like +, andless;, andamp;, ==, -andgt;, and * are treated asfunctions whose names happen to be the standard operators found in manyprogramming languages.andP;  Operator overloading should be used where thesemnatics normally attributed to the operator apply intuitively for the typesof the operands.andP;  C has predefined semantics for use of operators withpointer operands.andP;  References can be used with operator overloading to passthe addresses of objects to the function implementing an operator, which isoften more efficient than passing objects by value.andM;Object InstantiationandM;Constructors are functions that can be defined for a class to ensure properinitialization of an object when it is instantiated.andP;  A constructor calledthe copy constructor is used to make a copy of an object.andP;  This constructoris used when an object is passed by value as a function argument or returnvalue.andP;  Some object-oriented languages do not pass objects by value, butalways use a reference.andP;  Specifying function arguments as references orpointers in C++ is recommended to reduce the often unnecessary overhead ofinstantiating a new object.andP;  Constructors are also used in type conversions.andO;A destructor is a function that can be defined to provide necessary cleanupwhen an object is deleted.andM;Objects in C++ can be instantiated either implictly or explicitly.andP;  C++, likeC, is a block-structured language and objects local to a block are implictlyinstantiated/deleted when a program enters/exists a block.andP;  The extent of anobject is either static, automatic or dynamic.andP;  Static objects have theirconstructors called automatically when a process starts and the destructorsare then implicitly called when the process terminates; these objects residein the data segment of a program.andP;  Automatic objects reside on the stack andare the local variables within a function.andP;  As with static objects, theconstructors and destructors are called implicitly for automatic objects onentry and exit from a function (or a block within a function).andM;Dynamic objects are explicitly instantiated by invoking the new operator andare destroyed by invoking the delete operator.andP;  As a default, the standardmemory allocation and deallocation facilities of the operating systemenvironment are used.andP;  Programmers can also provide their own memoryallocation primitives by overriding operator new and delete; this can be usedto place objects in shared memory, for example.andP;  It also provides a means oftransparently taking control of the allocation of objects of a known size andusing techniques far more efficient than possible with the system's standardmemory allocation facilities that must handle objects of any size.andM;C++ does not provide implicit dynamic allocation of objects, nor is theremandated support for garbage collection to free memory for objects no longeraccessible.andP;  Many of the languages that use garbage collection by defaultincur performance penalties.andP;  If garbage collection mechanisms are needed,they can still be developed and used on a per-class basis and kepttransparent to users of the class.andM;InheritanceandM;C++ supports both single and multiple inheritance.andP;  All classes do not haveto be derived from a single root class; there can be as many independentclass lattices as required.andP;  C++ supports class inheritance; it does notsupport object-level inherritance.andM;Multiple inheritance can result in a base class occurring more than once in aderivation.andP;  A single occurrence of a base class can be obtained by declaringit as virtual.andP;  Multiple inheritance can also result in a member functionwith a given signature being inherited from more than one base class.andP;  Theseclashes are detected at compile time and the ambiguity can be resolved byredefining the member function in the derived class.andM;PolymorphismandM;Polymorphism is a key benefit offered by object-oriented languages.andP;  Itprovides software a generic interface defined by a base class so objects canbe manipulated uniformly though they may be instances of either the baseclass or any derived class.andP;  Dynamic binding is a mechanism used to supportthis.andP;  New derived classes can be defined and easily incorporated into asystem; objects of those classes are transparently manipulated by softwareinterfacing at the generic base class level.andP;  Virtual functions provide thiscapability in C++.andP;  The function actually called depends on the class of theobject used when invoking the virtual function.andM;While some object-oriented languages are implemented such that all functionsare virtual, in C-+ the programmer can make the choice.andP;  If the designer of aclass does not want to permit a function to be redefined in a derived class,the function can be specified without the virtual keyword.andM;One can define a abstract base class in C++ by defining a set of virtualfunctions as having null values; the antithesis of an abstract class is aconcrete class in which all functions have been specified.andP;  Abstract classescan exist at multiple levels in a class hierarchy.andP;  The compiler only allowsinstantiations of concrete classes.andP;  Abstract classes provide a uniform andtransparent interface to a set of semantically related derived classes,ensuring the derived classes provide a base set of functionality.andM;Member Access ControlandM;C++ provides several levels of access control to the members of a class; thisincludes both functions and data.andP;  Members can be private, such that they areonly accessible by functions that are members of the class.andP;  Members of aclass can be declared as public, allowing all functions access to themembers.andP;  Members can be specified as being protected, only allowing accessby member functions of the class and any derived classes.andP;  This is useful forproviding access to members needed by derived classes, but preventing accessby other functions.andP;  The accessibility of base classes can be specified aseither public or private.andM;A class can also specify friend functions that are allowed access to privateand protected members.andP;  It is also possible to specify that all the memberfunctions of another class are friends by declaring the class as a friend.andO;This is useful when several classes are tightly related, each providing thedefinition of a component used in the facility being designed; the nodes of alinked-list class, for example.andM;Control of member accessibility can also be used to prevent use of some ofthe operators that provide the type mechanics in the language.andP;  For example,the copy constructor and the assignment operator could be restricted to asubset of functions by declaring them as private or protected.andP;  Definingoperator new as a private member of a class could be used to restrict thedynamic allocation of objects of the class to those functions that are eitherfriends or members.andM;Other Class FacilitiesandM;It has been mentioned that C++ supports constant data; this applies also toclass instances.andP;  Class member functions that do not change the value of theobject can be specified as const.andP;  These are the only member functions thatthe compiler will permit to be invoked with constant objects of the class.andO;The compiler also ensures that those functions do not change the value of theobject.andP;  This is useful information for users of a class, clearly indicatingthose member functions that can or cannot change the value of an object.andP;  Theconst specifier should be used for both data and functions wherever possible;otherwise it precludes users from having constant data.andM;A class can have members that are specific to the class by declaring them asstatic.andP;  Static data members have class scope and only one occurrence isshared by all instances of the class.andP;  While C++ does not provide meta-classfacilities, static data members can be used to provide some of theinformation commonly associated with a meta-class or class object.andP;  One canalso define static member functions that can be invoked with or without aninstance of the class.andM;Development EnvironmentandM;The C++ compilation environment results in C++ source being compiled into theobject code of a particular machine.andP;  The current language implementationdistributed by ATandamp;T is a translator; the C++ source is translated into C andthen compiled by a C compiler.andP;  The translator, in a sense, treats C as auniversal assembly language, which is in many ways true.andP;  C runs on virtuallyevery machine in the industry and this translation approach has allowed C++to be quickly bootstrapped onto many machine architectures.andP;  Another benefitof this approach is the ease of using C cross-compilers to build software fortarget machines architecturally different from the development machine.andO;There is an industry trend toward RISC processors to increase performance andsince most RISC processors have instruction sets specifically designed toefficiently execute C, the C++ translator is able to cost-effectively takeadvantage of this industry trend with minimal development cost.andM;C++ is link-compatible with C and any other language with which C code can belinked: Fortran, for example.andP;  A linkage specification mechanism has beendefined so that C++ implementations can provide link compatibility with otherlanguages.andP;  This permits C++ software to be readily incorporated intoexisting software environments without requiring rewriting millions of linesof tested, working software.andP;  Even if a software development organizationwants to rewrite its software to take advantage of the advanced features,this linking capability allows an incremental migration path.andP;  This allowsreuse not only of new code designed specifically using the object-orientedfacilities provided by C++, but also reuse of the massive amount of usefulcode available in C, Fortran, etc.andM;Class implementations are usually placed in libraries.andP;  A program using aclass will only link in those object files that are explicitly specified orare implicitly linked because they are needed by an object file that isincluded in the program.andP;  This would include all the object files containingthe virtual function definitions for those classes used by an application(this is a result of the technique commonly used for implementing the virtualfunction mechanism).andP;  Operating system environments supporting dynamicallylinked libraries would only link in object files when they are needed.andO;Functions can be separated into as many object files as necessary to minimizethe inclusion of unneeded functions.andP;  These aspects of the compilationenvironment permit C++ programs to fit easily into small machinearchitectures.andM;Initially there were no debuggers that provided C++-level debugging;programmers used C-level debuggers.andP;  With Release 2.0 of the translator,routines are provided that understand the name encoding algorithms used bythe translator.andP;  These routines are being incorporated into existing Cdebuggers, permitting the debugger to provide a more complete C++ debuggingenvironment.andP;  There also exists a utility that can be run against a programto rebuild its symbol table, replacing the encoded C names with their C++representation.andP;  C++ compilers directly provide C++-specific symbol tablerepresentations.andM;C++ can be obtained from multiple sources and several companies are marketingboth C++ translators and compilers.andP;  Some of the compiler implementationsinclude syntax-directed editors, incremental compilation and integrateddebugging facilities.andP;  Interpreters for C++ are also being developed, thoughnone are commercially available yet.andM;Performance AdvantagesandM;C++ allows generation of very efficient code when invoking member functions.andO;Non-virtual function calls are completely resolved at compilation.andP;  Invokingthem at runtime is just as efficient as a function call in C, with none ofthe lookup overhead characteristic of many object-oriented languages.andM;C++ implementations also have very efficient mechanisms for calling virtualfunctions.andP;  Each object of a class with virtual functions has a pointer to ajump vector that exists for each class.andP;  The jump vector contains theaddresses of all the virtual functions.andP;  Each virtual function is assigned anentry in the jump vector during compilation.andP;  When a virtual function iscalled, the jump vector pointer in the object is used with the virtualfunction's index in the jump vector to determine the appropriate function tocall.andM;Some object-oriented languages delay the computations needed to determine theproper function to call until runtime.andP;  While this approach does provide ahigher degree of flexibility, it results in slower execution and delays thedetection of many errors until runtime (the lack of a function beingspecified, for example).andP;  C++ does not have this characteristic and thusprovides excellent performance and a guarantee of the construction ofcomplete programs.andM;The class definition includes the data members used in the implementation ofthe class.andP;  One side effect is that during development of a class, changes toits declaration require recompilation of all files using the class.andP;  Butbecause the memory layout of an object is known at compile time, significantoptimizations can be made.andP;  The compiler can make effective use of the stackfor automatic variables and accessible data members can be directly addressedwithout incurring any overhead.andP;  Class implementors can provide inline memberfunctions that insulate the class user from the internal representation andstill provide direct memory access to the data without incurring any functioncall overhead.andP;  The C++ language has been defined so that software can bewritten to run very efficiently.andP;  Programmers do not have to leave thecontext of the language to obtain needed efficiencies.andM;Features Not Part Of The LanguageandM;C++ does not have a large virtual machine environments directly providingfeatures like garbage collection and graphics capabilities by default.andP;  Theseare not required in all application environments and can be providedeffectively through libraries.andP;  Their absence in the language allows C++ tobe used in a wider set of system environments than some object-orientedlanguages.andP;  Companies are producing development environments around C++ thatdo not intrude into the language itself, but do provide many of theinteractive development facilities characteristic of languages with built-inenvironments.andM;C++ does not have a built-in meta-class facility.andP;  In addition, no generallyavailable C++ environment yet supports the run-time creation and integrationof new types into running processes, though this is possible and has beendone.andP;  A new class can be derived from a given base class and beincrementally compiled and linked into a running process.andP;  Softwareinterfacing at the base class level can then manipulate instances of the newderived class via virtual functions.andM;Another feature some object-oriented languages/environments provide ispersistence, allowing objects to be placed on secondary storage so they canexist across processes.andP;  Some languages also support mechanisms to handleconcurrency, sometimes used with persistence.andP;  C++ does not directly supportpersistence or concurrency.andP;  Several companies have developed C++object-oriented databases that provide these capabilities.andP;  Persistence is anexample of a language feature that may be more appropriately provided bylibraries.andP;  By not incorporating the feature as a built-in languagemechanism, applications not requiring the feature are not constrained by itspresence.andM;Parameterized types and exception handling are currently not defined in thelanguage and thus are not yet available in commercial C++ implementations.andO;Techniques exist within the current language definition to approximate thesefeatures, but the techniques have drawbacks.andP;  Parameterized types andexception handling are likely to be added to C++ in the future.andM;SummaryandM;The C++ language provides the key capabilities and benefits offered byobject-oriented programming, without including features that would constrainits use to a limited set of application domains and environments.andP;  Themechanisms are defined to allow very efficient implementations and an easymigration path for the large amount of existing C software and programmers.andO;Features that would result in performance penalties have not been included inthe language.andP;  Instead, the language provides base functionality permittingdevelopers to provide needed mechanisms efficiently.andP;  This provides anexample of the efficiency and versatility offered by the language.andM;David Jordan is a Distinguished Member of Technical Staff at ATandamp;T BellLaboratories.andP;  He has been a lead developer on several large projectsbuilding systems in C++ since 1985.andP;  He has given courses and presentationson C++, object-oriented design and the project management and methodologyimplications of using object technology.andP;  He is currently evaluatingobject-oriented database technology.andO;</TEXT></DOC>