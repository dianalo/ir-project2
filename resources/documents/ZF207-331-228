<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-331-228  </DOCNO><DOCID>07 331 228.andM;</DOCID><JOURNAL>Communications of the ACM  June 1989 v32 n6 p740(10)* Full Text COPYRIGHT Assn. for Computing Machinery, Inc. 1989.andM;</JOURNAL><TITLE>Literate programming. (includes related article on thecharacteristics of literate programming) (technical)</TITLE><AUTHOR>Lindsay, Donald C.andM;</AUTHOR><SUMMARY>The construction of a 'literate program' requires that the programbe written in a lucid manner, designed to be read and understoodby users.andP;  Existing programs can be rewritten to providecommentary with little or no degradation to the performance of thecode and greatly increased maintainability.andP;  The writing of aliterate program does not require advanced technology.andP;  A programwhich has been adjusted to meet literate program standards issupplied with all of its annotations intact.andP;  An explanation ofthe algorithms and data structures are presented within theprogram itself.andP;  The program's implementation is discussed indetail.andM;</SUMMARY><DESCRIPT>Topic:     ProgrammingSoftware DesignFormatProgram Development Techniques.andO;Feature:   illustrationprogram.andO;Caption:   Text file difference utility. (program)andM;</DESCRIPT><NOTE>Only Text is presented here; see printed issues for graphics.andO;</NOTE><TEXT>literate programmingandM;1.andP;  INTRODUCTION This column describes a program which reads two text filesand prints out a description of the differences.andP;  The program presented hereis a simplified version of a preexisting program, which has been shortenedfor publication by removing all code which supported options, or whichimproved the program's speed or its memory needs.andM;The program is written in the C language, and is internally documented in theconcise and precise manner which is appropriate to real programs.andP;  Althoughsome writers find this form too terse and stylized for the purposes ofpresentation, I believe they do a disservice.andP;  A textbook, and a usefulprogram, simply have different purposes.andP;  For example, a program which is&quot;explained&quot; at considerable length, may in fact be poorly documented--fromthe viewpoint of a person wishing to know some quite reasonable postconditionof a certain procedure.andP;  This column should not be taken as a &quot;literateprogram,&quot; in Knuth's restricted sense.andP;  This is a column about the program,but the program itself is suitable for posting (without explanation) onUsenet.andP;  If space allowed, the program would have been presented in itsentirely (rather than as fragments), along with a machine-generated index.andM;The lack of innovation in this column should not be taken as an argumentagainst progress.andP;  Instead, it is hoped to be a demonstration of the mannerin which a traditional program can be kept both precise and manageable.andP;  Itshould be noted that the reduced program is about 700 lines long, of whichabout 300 are comments and spaces.andP;  Although the program was adjusted forpublication, it was no fluffed; this is indeed a real program, written forreal use, in accordance with standards based on maintenance experience.andM;The specification was the first part of the program to be written.andP;  This waskept up to date as the program evolved, and is as illustrated in Figure 1.andO;Figure 1 contains the program's identification, a standard copyright notice,and a functional specification.andP;  In most cases, the front of a real programcontains other material.andP;  For example, well-maintained programs contain ahistory log, showing the dates of revisions, the names of the partiesinvolved, and short explanations of the revisions.andP;  This is usually doneaccording to some standard format (e.g., labelled columns, or an indentationstyle) and the major asset of any such format is the imposed uniformity.andP;  Avirtue of keeping the log prominent is the increased likelihood thatmaintainers will add to it.andP;   (Beginning programmers often avoid makingentries, giving excuses such as the triviality of their change.)andP;  Thisprogram's log has been omitted to save space.andM;The format of the printout is different from that used by the filcom and diffprograms which have been used for many years.andP;  The intention was to keep thecommand lines straightforward and readable, at the expense of other goals(such as acceptability  to a specific editor).andP;  The text lines were printedas-is, since the display of a prefixed line may change tab interpretations,causing items originally separated by whitespace to become merged together.andO;There is also the possibility that prefixing may make some text lines toolong for the user's display medium.andP;  This format does have the disadvantagethat the commands can become buried in the output text.andM;2.andP;  ALGORITHM AND DATA STRUCTURESandM;The actual program contains an explanation of the algorithm which it uses.andO;However, its explanation is mostly a reference to the article &quot;A Techniquefor Isolating Differences Between Files,&quot; by Paul Heckel, published inCommunications of the ACM, 21, 4 (Apr.andP;  1978), p. 264.andP;  This method is basedon the idea that some lines will be found only once in the oldfile, and onlyonce in the newfile.andP;  A file-to-file map of line m atches is kept, and theseunique lines are found and marked as matched.andP;  Next, lines which are adjacentto matched lines are checked.andP;  It may be that these lines would have matched,but were disqualified because they were non-unique, that is, were found morethan once in either of the files.andP;  The algorithm takes the adjacency as astrong enough reason to match such lines.andP;  The map that results will showeach file to consist of blocks of matched lines and blocks of unmatchedlines.andP;  The printout algorithm (which was not included in Heckel's article)uses the map to print the unmatched and moved lines.andM;From this sketch, we see a need for two basic data structures.andP;  First, theremust be a structure which holds the lines of text, so that uniqueness can bedetermined, and so that the lines may later be retrieved for printing.andO;Secondary, there must be a map which relates the two files.andM;This program implements the first data structure by having a symbol tablepackage, which hides the details of its data structures from its user.andP;  thepackage is largely conventional, and returns &quot;handles&quot; so that the programgets a unique name for each unique line.andM;The program implements the map with global data declarations as illustratedin Figure 2.andM;3.andP;  THE MAIN PROGRAMandM;Given the function specifications shown in Figure 3, and the functionsignatures shown in Figure 4, then the code of the main procedure (lessargument checking) can be as shown in Figure 5.andP;  This code was notconstructured in any particular order, and was edited into six differentplaces in the program.andP;  However, the pieces were constructed to be proofreadas a whole.andP;  Only as a whole can it be determined if a piece of code meetsits functional specifications, given that the things which it directlytouches meet their functional specifications.andM;It is important to note the word &quot;directly.&quot;andP;  There is nothing so frustratingas discovering that the proofreading of one procedure requires reading theimplementation of others.andP;  This leads recursively to including a practicallyunbounded amount of information into the &quot;proof&quot; of any single property.andO;Although tools can assist in searches, they may not be useful in findingill-worded or poorly placed documentation, and they cannot find documentationthat was never written.andM;Some readers may think that &quot;proofs&quot; about programs are quite theoretical andacademic.andP;  Actually, proofs are a major tool of every efficient maintainer,who does not have time to understand everything about a program, but must besure that he understand certain things very well.andP;  This leads to the attitudethat documentation exists so that informal proofs are easy, and are likely tobe correct.andM;This style of thinking can be learned quite naturally.andP;  When maintaining aprogram, ask yourself what proofs you have constructed.andP;  If the documentationassisted these, then it is worth studying.andP;  If the documentation wasinadequate to the task, then study the inadequacy, and try to alleviate it.andO;With this attitude, a maintainer may develop good style; without it, it isall too likely that he will learn the style that makes programs needmaintenance.andM;4.andP;  READING THE FILESandM;Due to limited space, the bodies of openfile and input-scan will not be shownin this column.andP;  The inputscan routine is not as trivial as openfile, but isbasically just a loop, storing characters into a line buffer.andP;  It must copewith end-of-file, and with overlarge lines, but it mostly exists to call theroutine storeline--see Figure 6.andP;  This function body has unknown semanticsuntil we specify addsymbol, so we must next deal with the symbol table.andM;5.andP;  THE SYMBOL TABLEandM;The symbol table package presents a procedural interface, defined solely bythe entry points.andP;  They are as presented in Figure 7.andP;  Given this code, thebody of storeline now has well-defined semantics and can be checked againstits specification.andM;We will not show the internals of the symbol table package.andP;  The program usesa binary tree, which is searched by iterative descent.andP;  (This point will bediscussed further in Section 8, entitled &quot;Features and Performance.&quot;)  Theonly unconventional aspect is some counting, which makes it possible forsymbolisunique to compute its result.andM;One part of any design is the choosing of names.andP;  The reader will havenoticed that the names above, such as symbolisunique, are each a series ofsimple words, concatenated together.andP;  This is the simplest possible method ofconstructing long, meaningful names, and it is adequate for this smallprogram.andP;  The drawback in large programs is that the reader will eventuallyencounter a name which seems to defy analysis, or which he parses into thewrong phrase.andP;  The common solutions would be to change symbolisunique tosymbol_is_unique or else to SymbolIsUnique.andM;The underscore method is sometimes disliked on aesthetic grounds, and wasquite unreadable on many early display and hardcopy devices.andP;  It makes nameslonger, which caused problems in the days when compilers economized space bydealing with truncated identifiers.andP;  Also, names which become visible todebuggers, to linkers, and to other tools, often fall afoul of character setor length restrictions.andP;  (These problems are usually noticed when portingsoftware.)andM;The capitalization method is sometimes disliked as being error-prone to type,or as being difficult to communicate verbally to coworkers.andP;  (These problemsare most relevant when the language used is case sensitive, as the C languageis.)andP;  There are also typographic issues, such as the lack of vertical spacebetween upper case letters, and the ambiguity of some font families.andP;  (Forexample, if the upper case letter I (eye) resembles the lower case letter l(ell), then the name SymbolIsUnique becomes quite confusing.)andP;  Capitalizationmay also cause problems during porting, typically with debuggers, linkers,and the like.andM;In a large program, abbreviations eventually become necessary, although onlya few abbreviations (such as len) will be universally understood.andP;  Ingeneral, they are not as well understood as the inventor supposes, and whencarried to extremes, as in SDlocDCl, they are clearly inferior.andP;  It is commonto abbreviate pointer to ptr, and to distinguish variables containingaddresses by names such as symbolptr.andP;  In this small program, I have used thesimpler convention of prefixing with the letter p, as in psymbol.andM;Some readers will have noticed that function show-symbol is poorly designed.andO;It is less general than it might be, because it locates a string, but alsoprints it (and also knows where to print it).andP;  There are two reasons forchoosing this merged functionality.andP;  The first is that separating out theprinting would require another function, having only a trivial (single-line)body.andP;  In a small program such as this one, one extra function represents acost (in size) that partly balances against the poorer modularity.andP;  Thesecond and larger reason is that the symbol table package may wish to keepthe lines in a compressed format, or may store long lines as severalfragments.andP;  In this case, the interface chosen would have some extraconvenience, since the function need not recreate the original string.andM;6.andP;  CONSTRUCTING THE FILE MAPPINGandM;In Section 3, we defined the transform routine.andP;  Basically, it takes themaxline variables and the symbol arrays, and fills out the map defined inSection 2.andP;  The function body is shown in Figure 8.andP;  The scan routines werecreated to keep the transform routine readable.andP;  They do this partly bysimple smallness.andP;  The differences and similarities of the scan loops becomemore apparent, and the independence of the scratch variables is madeexplicit.andP;  Also, the specifications of the routines document the evolvingstate of the mapping data, whereas comments within a single large routinetend to be constructed with less care.andP;  It may not always be clear just whatbody of code a comment applies to, a difficulty which routine specificationscannot have.andM;It should be noted that this program was coded with tab settings at everyfifth column.andP;  It is well known that an indentation of two columns isn'tenough, and that eight is too much.andP;  This rule follows from practicalexperience with large routines.andP;  As routines become larger, they need deeperindentation in order to keep groupings visually distinct.andP;  On the other hand,deep indentation becomes more likely to run things up against the rightmargin.andP;  This difficulty with size gives us one more reason for keepingroutines small, regardless of language.andM;Another aspect of smallness is economy in the use of lines.andP;  There is apractical advantage to fitting an entire routine onto a screen, or onto apage.andP;  This program has followed the convention that an opening brace (&quot;curlybracket&quot;) is only on a line by itself when starting a function body.andO;However, blank lines have been used to set off groupings, and multi-statementlines have been avoided.andM;The routines themselves are shown in Figure 9.andM;7.andP;  PRINTOUTandM;The printing phase essentially scans through the map, printing (or not) thelines that it finds through the map's symbol table handles.andP;  This was donewith a single loop, which may advance a newline variable, or may advance anoldline variable, or may advance both.andP;  (The advances are always by one, orelse by the size of a block.) There are two major problems.andP;  The first issimply that there are a large number of cases--for example, if a block hasbeen moved, then a scan may encounter it twice, once where it came from, andonce where it went to.andP;  The second problem is that the code would have anunreadable control structure if it were written as a single function.andM;I have chosen to write printout as a main function and nine subsidiaryfunctions.andP;  They are held together by four global variables, rather than byparameter lists and by result values.andP;  This is usually an inferior method,since the use of global variables means that the functions have side effectsthat in general are hard to document (or are poorly documented).andP;  In thisspecific case, however, the subsidiary functions are in fact just fragmentsof the whole, and the C language makes it burdensome to pass the globalvariables both in and out of the functions.andP;  I apologize for seeming tosupport a practice which I counsel against.andM;The variables global to the ten printout functions are shown in Figure 10,and the functions are shown in Figure 11.andP;  The reader may have noticed thatthe show-same function contains an error check.andP;  It is considered goodpractice to leave such checks in the final program, unless there are reasonsto remove them.andM;8.andP;  FEATURES AND PERFORMANCEandM;Since the program contains loops that span the inputs, but does not containany nested loops, we would expect that execution time would be linear in thesize of input.andP;  In big-oh notation, we would say that we expect execution tobe O(N), where N is the number of input lines.andP;  This analysis assumes thatrelatively little is printed out, since that is the usual case.andP;  Thisanalysis also ignores the presence of the binary tree used by the symboltable package.andP;  Since the size of this tree is O(U), where U is the number ofunique lines, we can expect the tree construction phase to have an executiontime of O(N log.sub.2.(U)).andM;This program uses a fixed amount of space for the map.andP;  The original, morecomplicated version used O(N) space, with some loss in both simplicity andspeed.andP;  (The symbol arrays were implemented as arrays of pointers to arrays,with dynamic allocation of the subarrays as needed during the input phase.andO;The other arrays and the blocklen array need not be allocated until after theinput phase, at which time the desired size is known exactly.)andP;  (The originalprogram is also capable of keeping references into the input files, ratherthan keeping the actual lines themselves.andP;  This greatly shrinks the symboltable, but will give incorrect results should a hash collision occur.)andM;To measure this specific program's performance, I constructed several large(andgt;10,000-line) input files, and for each, I constructed a version of it whichdiffered slightly.andP;  I compiled the program, with optimization requested, andtimed it on these input files, using the time command of a Sun-3/160workstation.andP;  The program took approximately 25 percent to 50 percent longerthan the standard diff utility of this machine.andP;  The grof profiling toolrevealed that the transform step was taking 2.6 percent of the executiontime, and the printout step was taking less than 0.1 percent of the time.andO;This indicates that the code for these steps is in no need of performancetuning, and no effort should be wasted on attempts to improve their speed.andO;Of course, this conclusion depends on several &quot;reasonable&quot; assumptions.andP;  (Forexample, the speed of the input phase is affected by average line length,whereas the speed of the transform step is not.)andM;The symbol table package (not presented in this column) is clearlyinefficient, with addsymbol consuming 60 percent of the execution time.andP;  Thisis due to its simplistic algorithm, which does a full string comparison atevery step of a tree descent.andP;  There are several ways to reduce this cost.andO;As noted in a previous section, the strings can be shortened by a compressionmethod.andP;  Comparison can be avoided when strings are of unequal length.andP;  Thetree depth can be minimized by a balancing method.andP;  A hashing technique maybe used instead of a tree.andP;  Or, the hash of each line may be carried aroundwith the line, so that the bulk of the comparisons can be done on the hashvalues.andP;  This last technique was coded into a version of the program, and theexecution time became comparable to that of the diff utility.andM;The quality of the algorithm's decisions was discussed in the article byHeckel.andP;  To summarize, the output is usually of a quality comparable to thatof other algorithms.andP;  Sometimes the output is &quot;more right,&quot; particularlybecause it is capable of noticing a block move as such, rather than noticingit as a block deletion and as a (separate) block insertion.andP;  There are inputswhich will cause the algorithm to make poor decisions: this can also be saidof the other major algorithms.andP;  The failures are often a consequence of thefact that files may contain many identical lines, particularly if they areprogram source.andP;  Each algorithms must resolve this ambiguity, and there mayin fact be no resolution which is &quot;right.&quot;andP;  In general, however, thisalgorithm does produce the &quot;right&quot; result.andM;Historically, file difference programs have been subject to enhancement.andP;  Onmain category of changes has been in the area of input filtering.andP;  This isusually optional low-level processing, such as case reduction, various formsof whitespace reduction, comment stripping, and the like.andP;  Another categoryis optional changes in printout format, to show the context of a change, orto be more suitable for some other tool, such as an editor or a revisioncontrol system.andP;  A more open-ended category is changes made to fit theprogram into some system context.andP;  This may involve adding knowledge of somestructured environment (such as hierarchical directories), or may involveadaptation to ideas such as &quot;uninteresting changes,&quot; such as the timestampsfound in regression-test logs.andP;  The program presented here has been designedand coded in a manner which should make it suitable for maintenance, andtherefore a reasonable platform for enhancements.andO;</TEXT></DOC>