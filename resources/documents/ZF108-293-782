<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-293-782  </DOCNO><DOCID>08 293 782.andM;</DOCID><JOURNAL>Data Based Advisor  April 1990 v8 n4 p74(9)* Full Text COPYRIGHT Data Based Solutions 1990.andM;</JOURNAL><TITLE>Front-end friendly. (developing interfaces for database servers)(includes related article on server vernacular) (DB Connections)(technical)</TITLE><AUTHOR>Buzzard, James.andM;</AUTHOR><SUMMARY>Applications programmers require a good data base server for adata base management system with a good interface so that the userdoes not need to deal directly with the structured query language(SQL).andP;  This Application Programming Interface (API) provides thelink between the host language the user inputs and the data baseserver.andP;  There are basically four types of API: a function callinterface, a precompiler API, a native SQL dialect supported bythe host language, and a command mapping interface.andP;  The mostappropriate API depends on what is being developed and thelanguage in which the application is being developed.andP;  Animportant question when choosing an API is how many kinds ofinterfaces it supports so that the programmer has the option ofusing a different development language in the future.andM;</SUMMARY><DESCRIPT>Topic:     Applications ProgrammingInterfaceData Base Management SystemsStructured Query LanguageData Base Servers.andO;Feature:   illustrationchart.andO;Caption:   Where database server APIs reside in the client/serverenvironment. (chart)How the function-call API operates. (chart)How the precompiler API works. (chart)andM;</DESCRIPT><TEXT>FRONT-END FRIENDLYandM;Lately there's been a lot of talk and press coverage about client-servercomputing.andP;  Database servers are now the prime example of &quot;distributedprocessing.&quot;andP;  In a marketing frenzy not seen since artificial intelligence(remember how it was going to save the world?) and object-orientedprogramming arrived, vendors are busy proclaiming and comparing theirproducts' features and benefits.andM;But let's back up a bit.andP;  Database server software is pretty useless withoutsome way to access it from your client workstations (usually a PC on a localarea network or LAN).andP;  You can't write good applications without having agood interface to the server.andM;In this series we'll look at developing interfaces for database servers andapproaches to interfacing PC databases and development tools to SQL-baseddatabase servers.andP;  As examples of PC front ends, we'll start with dBASElanguage products (which doesn't mean that that's all there is).andP;  We'll coverhow dBASE commands are converted or mapped to SQL and the changes you mighthave to make in your dBASE applications--if you intend to move them to adatabase server.andP;  We'll also look at some performance issues specific todBASE applications acting as clients.andP;  Finally, we'll look at theinteroperability of dBASE applications and other front ends--in other words,the ability to have users interact with the server using Lotus 1-2-3 orAdvanced Revelation and share data being simultaneously manipulated andupdated by dBASE applications.andM;Connecting to Database ServersandM;In case some of the terms used in the article are unfamiliar to you, pleasesee the definitions in the accompanying jargon list, &quot;Server Vernacular.&quot;andP;  Itmay seem at times as though I use an unfamiliar word when a familiar onewould do just fine.andP;  PC database terminology (especially in the dBASEcommunity) and the terms used in the SQL and relational database arenasdiffer on what to call just about everything.andP;  You'll have to get used tocalling a data file a table (or a relation), a record a row (or a tuple), anda field a column (or an attribute).andP;  When you do, you'll find that people onboth sides of the fence have the same problems and concerns.andM;Finally, if all of this stuff about database servers causes you to ask theperennial question &quot;Why bother?&quot;, I offer this simple answer--maybe you don'tneed to.andP;  For a lot of PC data processing needs, database servers are grossoverkill.andP;  They have some attractive features (like transaction managementand recovery, centrally enforced security, and data integrity), but thesefeatures may not be attractive enough to justify their substantial hardware,software, and learning curve costs.andP;  Obviously, simple mailing list programsand personal phonebook databases don't need to be implemented using a$2,500-plus database server.andP;  Weigh the benefits and try to ignore the vendorrhetoric.andM;Please note that references to &quot;dBASE&quot; or &quot;dBASE systems&quot; in this articledon't refer solely to Ashton-Tate's dBASE, but to dBASE-compatible languageproducts and database management systems (DBMSs).andM;ApplicationandM;programmingandM;interfacesandM;The interface used to access system software (like database servers) isusually called an Application Programming Interface (API).andP;  The API providesa clearly defined interface between programs written in programming languages(referred to as a host language), like C or dBASE, and another softwaresystem, like the operating system or database server.andM;APIs isolate application programs from the internal workings of the databaseserver.andP;  As an applications developer you don't need to worry about whathappens inside the server when you request data.andP;  You simply pass yourrequest to the API (even this can be transparent in some command mappingAPIs) and the API returns the value you requested.andP;  The details of physicalfile layouts, communication protocols, and connectivity between yourworkstation and the server computer are all handled by the API and the serversoftware.andM;Actually, describing it as &quot;isolating&quot; the application programmer from thedatabase server is too simple.andP;  The performance of some database servers isinfluenced by the syntax of the SQL statements sent to the server.andP;  You mayneed to know how the server processes the syntax of your query if yourapplication has performance problems.andM;Database server APIs come in various forms.andP;  Some are useful and productive,some aren't.andP;  In software engineering there are often trade-offs involved inselecting a particular API and the resulting degree of control, ease ofdevelopment, and performance.andM;Most database servers include some kind of API for C language development.andO;The third party also provides APIs or front ends.andP;  They take existingproducts (such as Ashton-Tate's dBASE IV or Lotus 1-2-3) and modify them towork with particular database servers.andP;  Some newer products, such asSQL*Forms from Oracle, are specifically designed as database serverapplication development tools.andM;You can implement a database server API in one of four distinct ways: as afunction call library, as a precompiler API, by command mapping from the hostlanguage to SQL, or by supporting a native SQL dialect.andP;  Most databaseservers support a combination of these APIs--either included with thedatabase server or as products from a third-party software vendor.andM;To help clarify these different options, let's take a brief look at each typeof API.andM;Function-call interfaceandM;A function-call interface is implemented as a set of function calls in thehost programming language (or in a language linked with host languageprograms).andP;  You embed these functions directly into the application's sourcecode in place of the host language's data manipulation commands.andM;Although properly designed function-call interfaces can be very effective,they also require more development effort than the other APIs.andP;  Also, sincethe names and formats of even simple function calls (e.g., to send a SQLstatement to the database server) differ from one vendor to another, programsthat use a function-call API are generally difficult to port between databasesystems.andM;One way to try to avoid this lack of portability is to define a genericfunction-call interface.andP;  The application code would then refer only to yourfunction names.andP;  Your functions would contain the call to the appropriatefunction for the database server you choose.andP;  Unfortunately, this approachmeans you have to anticipate and pass all of the parameters required by anypotential server API to your generic functions.andP;  You also incur additionalruntime overhead from the nested function calls unless the language orcompiler you're using automatically substitutes the contents of the genericfunction wherever it's called in your code.andM;You might consider function-call APIs the lowest common denominator ofdatabase server APIs--they're generally provided on all database servers(IBM's OS/2 Extended Edition Database Manager is a notable exception).andO;Microsoft's SQL Server uses DB-LIBRARY, a function-call API, to allow Cprograms to communicate with the server from DOS or OS/2 workstations.andM;Precompiler interfaceandM;A precompiler API uses a piece of software called a precompiler to convertthe host language source code containing embedded SQL statements into a formthat can be compiled.andP;  The SQL statements are embedded directly into the hostlanguage program, usually preceded by keywords, like EXEC SQL, that theprecompiler recognizes.andP;  The precompiler substitutes a number of functioncalls for the original SQL statements.andP;  A library module (similar to themodule supplied with a function-call API) is then linked with the precompiledsource code file after it's compiled.andM;The embedded SQL statements used with precompiler APIs generally fall intoone of two categories: dynamic or static.andP;  Dynamic SQL statements arestatements whose content isn't known until the program actually runs (similarto using dBASE macros that include commands).andP;  Static SQL statements arethose whose complete content, except the values of host language variables,is known when the application is developed.andP;  Dynamic SQL is typically used inreport writers or ad hoc query tools.andP;  Static SQL predominates inapplications with standard, repetitive operations, like accounting software.andM;This distinction is important because some precompilers (like the oneincluded with IBM's Database Manager) optimize queries of static SQLstatements while precompiling.andP;  Optimizing queries is usually done by thedatabase server.andP;  The server converts the SQL commands into an efficient (onehopes the most efficient) series of steps (called an access plan) that itthen executes.andP;  Optimizing SQL statements while precompiling eliminates someruntime overhead.andP;  It makes precompiling slower, and the resulting accessplans may become less than optimal when the contents or structure of thedatabase changes.andP;  Dynamic SQL statements are always optimized when they'reexecuted rather than when they're precompiled.andM;Precompiler interfaces have one unique difficulty that results fromsubstituting function calls for embedded SQL statements in the application'ssource code.andP;  Some debugging tools allow you to view the source code of anapplication as it executes.andP;  Since the source code written by the programmerdiffers from the preprocessed and compiled source code, debugging can be moredifficult when using a precompiler API.andP;  To help with this, most precompilersleave the original SQL statements as comments in the source code files theyproduce.andM;Both the Oracle Server and IBM's Database Manager use precompilers to allow Clanguage programmers to use embedded SQL statements.andM;Native SQL interfaceandM;Some development environments or host languages support a native SQL dialectto access and manipulate data.andP;  In most cases these environments provideaccess directly to a SQL-based database server by simply sending the SQLstatements to the server.andM;Supporting native SQL within the host language has a number of advantages.andO;Development and debugging is faster and easier since you don't have theadditional precompiling step and don't need special function calls to accessdata.andP;  Applications developed using native SQL are more likely to match theset-oriented approach to data access and manipulation provided by SQLdatabase servers.andP;  Also, the overhead associated with mapping host languagecommands to SQL is reduced.andM;However, because the SQL standard is implemented and extended in differentways by different vendors, you still may need to do some mapping between thenative SQL dialect of the host language and the SQL dialect supported by theserver.andP;  Converting SQL dialects this way is a simple form of the commandmapping interface I describe later.andM;For example, dBASE IV includes a SQL dialect that's comparable to the dialectused by IBM's DB2 mainframe database system.andP;  When connected to SQL Server(which uses it's own proprietary SQL dialect), some dBASE IV SQL commands andfunctions need to be converted by mapping software.andP;  Also, since SQL Serverdoesn't support a number of SQL commands in the current dBASE SQL dialect(such as SQL cursors, the UNION set operator, the WITH GRANT OPTION clause ofthe GRANT command, and more), those commands will need to be emulated withmapping layer software or not allowed in dBASE IV SQL statements sent to SQLServer.andM;Native SQL interfaces can be either modal or nonmodal.andP;  Modal interfacesrequire you to switch between the host language and SQL modes using a specialcommand (e.g., the SET SQL ON/OFF command in dBASE IV).andP;  Nonmodal interfacesdon't require you to switch between modes.andP;  They allow you to freely intermixSQL commands with procedural host language commands.andP;  Nonmodal interfacesimpose fewer restrictions on using native SQL in your applications, whichmakes them preferable.andM;Oracle Quicksilver and Oracle dBXL (versions of the WordTech dBASE compilerand interpreter that work with Oracle's database server) have a nonmodalnative SQL API (as well as the ability to map dBASE commands to SQL).andP;  ThedBASE IV 1.1 Server Edition will probably use a modal form of native SQL toconnect to SQL Server--when it's released.andM;Command mapping interfaceandM;One of the ideas behind the current generation of database servers is toprovide transparent access to the database from standard desktopapplications.andP;  For example, users should be able to pull information into aLotus 1-2-3 or Excel spreadsheet or a dBASE report using only the data accessand query commands present in these environments.andM;Although SQL serves as the data access language for most database servers,users (or application programmers) shouldn't have to use SQL to communicatewith the database server.andP;  Instead, a layer of software between the desktopapplication and the server can convert (or map) host language commands toequivalent SQL statements.andP;  The server receives SQL statements and themapping layer converts the results returned by the server into a form theapplication recognizes.andM;In some cases host language commands can be almost directly mapped to theirSQL equivalents.andP;  For example, a dBASE REPLACE ALL command is nearlyidentical in form and function to a SQL UPDATE statement.andP;  In other casesthere are substantial differences in how the data is retrieved andmanipulated.andP;  An example of this is the record pointer navigation commandsavailable in dBASE (such as GOTO and SKIP).andP;  It takes a lot of mappingsupport to convert these to the set-oriented paradigm used by SQL (and truerelational databases).andP;  SQL databases locate records (rows, in SQL parlance)by unique key values, not by their position in the data file or table.andM;Oracle Quicksilver and Oracle dBXL map dBASE language commands to equivalentSQL commands.andP;  The dBASE IV 1.1 Server Edition should also provide this kindof mapping when it's used with SQL Server.andP;  (Though it's likely to besubstantially different from the approach used in the Oracle products.andP;  SeeSQL Server Environment's November/December issue or the February 1990Database Programming and Design.)andM;Just where is this mapping layer?andM;The location of the mapping software layer can be crucial to the performanceof the client-server combination.andP;  Some approaches (like the one used byOracle dBXL) do all the required mapping on the client workstations.andP;  Others(like the one expected in the dBASE IV Server Edition) place a good deal ofthe mapping overhead on the database server by using programmable features(triggers and stored procedures) built into the server.andM;Only time will tell which of these mapping approaches works best in the realworld.andP;  However the server-based approach used by dBASE IV is much morelikely to suffer performance degradation as users are added (the server's CPUis a finite resource that gets divided among the increasing number of users).andO;The client-based approach used by Oracle Quicksilver and Oracle dBXL relieson the user's CPU; its performance is less likely to suffer.andM;How do you choose?andM;After looking at these different approaches to database server APIs, thequestion that naturally springs to mind is &quot;Which one is best?&quot;andP;  The answer,of course, depends on what programming language you're writing in and whatyou're trying to do.andP;  Some combinations of task, language, and type of APIend up as mismatches.andM;For example, if you're planning to let users do ad hoc queries from Paradoxor dBASE, a precompiler interface to the database server would be less thanideal.andP;  These client tools (Paradox or dBASE in this example) already have aquery language, so a command mapping interface between the native querylanguage and the SQL dialect that communicates with the server would be best.andO;On the other hand, if you're developing the client application in C, whichlacks a native query language, having a command mapping interface wouldn't bepractical or possible.andP;  A function call or precompiler interface would bebest.andM;The best way to judge a server's API is not by what kind of interface itprovides, but by how many kinds of interfaces.andP;  Just because your primarydevelopment environment might be dBASE or C (or some other language) today,that doesn't mean you won't want to access the data on the server using C++or Clarion or PC/FOCUS a year from now.andM;In coming months we'll look at the specific functions and features an APIshould provide and some of the problems in connecting high-levelnonprocedural data access languages like SQL with more traditional proceduralprogramming languages, like dBASE.andM;James Buzzard owns a database and application design consulting firm,Hammerhead Systems.andP;  His industry experience includes four years as V.P.andP;  ofEngineering at SBT Corp. and a background in finance and accounting.andP;  You cancontact him at (415) 861-2170.andO;</TEXT></DOC>