<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-893-486  </DOCNO><DOCID>07 893 486.andM;</DOCID><JOURNAL>AI Expert  Nov 1989 v4 n11 p17(4)* Full Text COPYRIGHT Miller Freeman Publications 1989.andM;</JOURNAL><TITLE>Executable specifications. (Expert's Toolbox ) (column)</TITLE><AUTHOR>Knaus, Rodger.andM;</AUTHOR><SUMMARY>On a project of any size a programmer needs to writespecifications to help guide the implementation, but there isalways the uncertainty that the system does not meet the specs, orthat the specs are incorrect.andP;  Testing the specifications to seethat they do what they are suppose to do is one way to resolvethis problem.andP;  In addition, testing will help find potential bugs,and will guide others in determining whether the system will meetdesired goals.andP;  However, one drawback to testing specifications isthat the programming may not become part of the final system,adding to the cost of the total program.andP;  But by developing arapid prototype or model, a programmer can derive an overall viewof what the system will look like.andP;  A specification interpreterwritten in PROLOG is included.andM;</SUMMARY><DESCRIPT>Topic:     Computer SystemsSpecificationsTestingPrototypePROLOGArtificial IntelligenceSoftware DesignTutorialProgramming Instruction.andO;Feature:   illustrationprogram.andO;Caption:   Executing specifications. (program)Fixed interpreters. (program)Loop execution. (program)andM;</DESCRIPT><TEXT>Executable SpecificationsandM;One of the big problems in software development is the system specificationsCatch-22: on a project of any size you must write specs to guide theimplementation.andP;  In theory, the implementation follows the specs and theresulting system does what you want.andP;  However, in practice, you are never100% sure that a system meets its specs, or if the specs themselves arecorrect.andP;  This uncertainty occurs because a true implementation has correctspecs when it does what the user wants--something you can't test since thesystem hasn't been implemented yet.andM;Specification testing is one way out of this dilemma.andP;  Put the specificationsin an executable form (for example, a rapid prototype) and run them to see ifthey do what you want them to do.andP;  Executable specs have several advantages:andM;* You can spot bugs in the specs early on, when the cost of fixing them isrelatively small.andM;* Users can see if the system meets their goals before implementation starts.andM;* A new development or maintenance programmer can use the executable specs tolearn about the system.andP;  Running a model system gives you an overview that ishard to get by reading a bunch of dataflow diagrams.andM;However, executable specs also have drawbacks:andM;* The programming needed to make specs executable may not become part of thefinal system.andP;  This specification programming (for example, to develop arapid prototype) is an extra up-front cost, which may or may not be recoveredby having fewer errors in the final system.andM;* The programming language gobbledygook needed to make the specs executablealso clutters them up.andP;  Instead of reading English or looking at diagrams,you may have to read code.andP;  It may be hard to separate the particulars usedto execute the specs from the more abstract properties desired in the finalsystem.andM;To provide the advantages of executable specs while minimizing thedrawbacks--which cannot be entirely eliminated--I have written aspecification interpreter (SI) in PROLOG.andP;  This approach's advantages includethe fact that PROLOG code is semilogical.andP;  In addition to implementingexecutable specs, the code describes logical properties of the system.andO;Programming details are less visible in PROLOG code, because PROLOGautomatically handles many control and data-structure details.andM;The specification interpreter also executes system components described inEnglish by analyzing the description and using the information to construct asimulation.andP;  This analysis lets the SI execute specs before the more exactand detailed PROLOG has been written or when the user just wants a high-levelview of the system.andM;The SI works on partially complete (in fact, very incomplete) specs, bygenerating and calling simulation code for the missing parts of the system.andO;We exploit PROLOG's tools for code generation to help the analyst check outpartially complete specs.andM;SOME EXAMPLESandM;Before we bog ourselves down in implementation details, let's examine theexamples in Listing 1.andP;  Each process in the target system is defined by astub, and optionally by PROLOG code.andP;  The stub contains some minimalinformation about the process: its purpose, an English phrase describing whatthe process does, and its call, a term showing how the process is called.andM;When we execute a specification, the process requested directly by the userand each subprocess called during the resulting computation is executed usingeither PROLOG or stub definitions.andP;  Processes defined in PROLOG are generallyexecuted in PROLOG; those defined by stubs are executed using stubs.andP;  (Theuser may use stubs instead of PROLOG to obtain a detail-free view of anexecuting system.andP;  See the complete SI program on the AI EXPERT and InstantRecall Bulletin Boards--(301) 983-8439 for Instant Recall.)andM;Specification 1 is a very minimal specification for checking housing surveydata.andP;  The specification interpreter recognizes that the process is definedas a stub only, and that this stub describes an action rather than a branch,loop, or other specialized process.andP;  Therefore, the SI turns the purpose ofthe process over to an action simulator, which does all that can be done withvery little information: tell the user that the process would be performed atthis point when the system runs.andM;Now suppose the systems analyst works another minute or two on the housingspecs, producing the more elaborate Specification 2.andP;  Here the top-levelprocess is defined by PROLOG as well as a stub.andP;  Using information in thesubprocess stubs, this PROLOG translates into &quot;If the data is collected for arecord, put it in the sample.andP;  Otherwise, write an error message.&quot;andP;  Even ifyou don't write PROLOG, you can read the specification with a few minutes'practice; it's an uncluttered notation for expressing relations among thesubprocesses, and it executes in a PROLOG interpreter.andM;We'll execute Specification 2 not in an ordinary PROLOG interpreter but anenhanced one: the specification interpreter, which looks for stubs as well ascode.andP;  The result is the second execution trace shown in Listing 1.andP;  Thistrace's increased detail reflects the increased detail of the second spec.andO;Notice also that the SI recognizes data_collected_q as a branch andinterprets its stub accordingly.andM;The third example shows a process defined only by a stub.andP;  However, thepurpose of this process describes a loop, and the specification interpreterexecutes a loop, simulating the process inside the loop.andM;EXTENDED INTERPRETERandM;Listing 2 shows the top level of the specification interpreter.andP;  Thetop-level predicate do_goal is essentially just a simplified PROLOGinterpreter in PROLOG.andP;  In fact, if you left out the first two rules ofdo_goal, you would have a very nofrills PROLOG interpreter--one with no cutsor ors in the rules.andP;  (You can add these features with some additional rulesfor do_body.)andM;As an extended PROLOG interpreter, do_goal has to recurse and backtrack.andO;do_goal recurses because do_goal calls do_body and do_body calls do_goal.andO;do_goal backtracks because the PROLOG rules that define it and its helperpredicates backtrack.andM;The first rule of do_goal transforms it from &quot;PROLOG in PROLOG&quot; into aspecification interpreter.andP;  This interpreter says that if a stub matches aPROLOG goal, and is appropriate to use, the stub should be interpreted(because no PROLOG rule matches the goal).andM;The top level of the stub interpreter is shown in Listing 3.andP;  The stubinterpreter looks at the purpose of the stub, an English sentence fragment,and decides what kind of process is described, for example, branch, loop,action, and so on.andP;  The stub interpreter then calls a specialized helperprocedure to interpret the process.andM;Listing 4 shows how loops are executed based on stub information.andP;  Thispredicate (PROLOG procedure) extracts the information it needs, such as theaction inside the loop, from the English-language purpose in the stub.andP;  Thenit uses this information to synthesize the PROLOG code needed to simulate theloop described in the stub.andP;  For the stub from Specification 3 in Listing 1,Listing 5 shows the generated loop code.andM;If you need to generate code at run time, Listing 4 shows how to do it inPROLOG.andP;  The general plan is:andM;* Get rid of any old code that might confuse the system, using the built-inpredicate abolish.andM;* Use patterns to construct the new code.andM;* Assert the code into the PROLOG database.andM;* Call the top level goal of the new code.andM;Some details must be observed when generating code: you can put variables inyour patterns.andP;  If the variables stand for program segments, you can definethe value of those segment variables before or after their owner patterns--aslong as the segments are defined before you put the rules containing them inthe PROLOG database.andP;  If you define patterns as I did, with terms of the formandless;variableandgt; = andless;patternandgt;, it's a good idea to put parentheses around thepattern to make sure the = is performed after all operators in the pattern.andM;If you define the rules of a predicate in their intended order--the sensiblething to do--put them in the database with the queuing predicate assertzrather than the stacking predicate asserta or its synonym assert.andP;  (SomePROLOGs make assert a synonym of asserta or assertz.)andM;LANGUAGE PROCESSINGandM;Many of the stub interpreter's helper predicates use information from theEnglish purpose in the stub.andP;  Listing 6 shows the predicates that extractthis information.andP;  I used really hokey predicates to find the verb and objectof the stub purpose because the user is required to write processdescriptions as the predicate (in the grammatical sense) of a single Englishsentence.andP;  This requirement still affords the analyst a lot of descriptivefreedom but limits linguistic processing needed for the spec interpreter.andP;  Itis important to limit linguistic requirements so development effort can bedirected to the more crucial area of simulating additional process classes(menus and file I/O) and data descriptions to the SI.andM;With the analyst restricted to sentence predicates, let's examine thequestions we have to answer from the purpose of a stub:andM;* Does the stub describe a branch?andP;  A loop?andP;  Some other special kind ofprocess?andP;  To find out, look up the verb in a list process-classifying words.andO;Because we have limited the literary creativity of the specification writer,the verb is the first word in the purpose.andM;* Is the action performed on a single item or a loop?andP;  To find out, see ifthe head of the main noun phrase of the verb object is plural.andP;  This is thefirst noun phrase after the verb.andM;* The specification interpreter must also transform the purpose into anaction-completed message to inform the user when a process in a loop has beenperformed (Listing 7).andP;  Again, from a linguistic standpoint, the code is veryincomplete; it overgeneralizes regular verbs in forming the past tenses ofverbs.andP;  The result is somewhat crude, but understandable and easilyimplemented.andM;The singular rule is the most obviously incomplete, and for a good reason.andO;While the rule fails to find the singular of mass nouns like sand, thisfailure is really a conservatism built into the system.andP;  If a processed itemis identified as plural, it is processed in a loop.andP;  By recognizing onlyunmistakable plurals (it messes up words like pants--fix it if it matters),the system simulates a loop only when there is strong evidence for one.andM;AI DEMO FOR ANALYSTSandM;This specification interpreter illustrates the potential for AI to help inthe software production process.andP;  It also illustrates how current AItools--in this case PROLOG--make symbolic programming easy.andP;  The wholeprogram took less than two days, although I did start with some code fromInstant Recall's PROLOG Tools.andM;The specification interpreter also illustrates a particular design philosophythat I call the Schultheisz approach, in honor of our firm's businessmanager: wait and see if you really need something before investing in it.andO;It would be easy to improve the SI's natural-language processing, but is thatthe most important improvement to make?andP;  Instead of making every part of thesystem smart, build a minimal system and let the domain specialists tell youwhat should be improved.andP;  Their judgment is almost certainly better than anAI expert without domain expertise.andP;  By starting with a minimal expert systemand letting the domain expert guide development, effort goes where it mostimproves the system.andM;Rodger Knaus is a principal of Instant Recall, a Bethesda, Md., firmspecializing in PROLOG software development, training, and programming tools.andO;</TEXT></DOC>