<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-693-586  </DOCNO><DOCID>08 693 586.andM;</DOCID><JOURNAL>IBM Systems Journal  June 1990 v29 n2 p228(8)* Full Text COPYRIGHT International Business Machines Corp. 1990.andM;</JOURNAL><TITLE>Data modeling for software development.andO;</TITLE><AUTHOR>Matthews, R.W.; McGee, W.C.andM;</AUTHOR><SUMMARY>One of the motivations for the use of a facility such as theRepository Manager in an information processing system is tocentralize the information needed for the development of software.andO;What this information is and how it is interrelated is defined inthe underlying data model.andP;  This paper discusses the kinds ofinformation required for software development and offers somesuggestions on how the data model should be organized andimplemented.andP;  (Reprinted by permission of the publisher.)andM;</SUMMARY><DESCRIPT>Company:   International Business Machines Corp. (products).andO;Product:   Repository Manager (CASE software) (usage).andO;Topic:     Software EngineeringData ManagementModels.andO;Feature:   illustrationcharttable.andO;Caption:   Sample entity types and interrelationships. (chart)Data generated in the software development cycle. (table)Entering object types in the framework. (chart)andM;</DESCRIPT><TEXT>Data modeling for software development One of the motivations for the use ofa facility such as the Repository Manager[TM] in an information processingsystems is to centralize the information needed for the development ofsoftware.andP;  What this information is and how it is interrelated is defined inthe underlying data model.andP;  This paper discusses the kinds of informationrequired for software development and offers some suggestions on how the datamodel should be organized and implemented.andM;A facility such as the Repository Manager [TM] [1] allows an installation tocreate an organized, shared collection of information about an enterprise'sinformation systems.andP;  One of the motivations for such a facility is tocentralize the information needed for the development of the enterprise'ssoftware.andP;  This information is generated by a variety of tools.andP;  At the sametime, it is accessed by a variety of tools, not only while the software isbeing developed but also throughout its life as it undergoes correction,change, and maintenance.andM;The information generated in the development of software can be thought of asa software development database, the clients of which are the varioussoftware development tools.andP;  The problem of designing such a collection ofinformation is not unlike that of designing any database.andP;  In particular,provision will be made for sharing information among tools, so that datastored by one tool are accessible on an equal basis to any other tool.andO;Equally important, when information is elicited from the user, it must bedone only once.andM;In order for tools to share data, the data must have an agreed-to format ormodel.andP;  We refer to this model as a data model.andP;  This model allows the toolset to evolve over time without the constant renegotiation of intertoolinterfaces.andP;  The model should also be reasonably stable, so that existingtools are not adversely affected by model extensions.andP;  Additions to the modelwill be frequent but generally not disruptive.andP;  Changes should be infrequent,and deletions should hardly ever occur.andM;In this paper we present a technique for the design of a data model suitablefor software development.andP;  We begin by briefly reviewing the types ofinformation generated by software development activity, and then consider themanner in which the data can be organized.andP;  We conclude by suggesting somecriteria by which the success of a data model can be measured.andM;Data requirements for software developmentandM;Before a data model suitable for software development can be designed, it isnecessary to understand the information that is generated by softwaredevelopment activity.andP;  This can be approached by first identifying the majorstages in the software development cycle and then considering the dataproduced at each stage.andM;According to Reference 2, the software development cycle has the followingmajor stages:andM;* RequirementsandM;* Analysis and designandM;* ProduceandM;* Build and testandM;* Production and maintenanceandM;Table 1 indicates the major kinds of data produced in the various stages ofthe software development cycle.andP;  For example, in the analysis and designstage, software specifications are written to state the purpose of thesoftware, the functions that it is to perform, the external interfaces to thesoftware, and the environment(s) in which it is to operate.andP;  Thesespecifications are usually written in natural language and are then used todesign the various components of the software: databases, panels, reports,programs, and so forth.andP;  Designs may be expressed again in natural language,or they may be given in a formal language that can be processed by a designtool to yield data required at the next stage of the development cycle.andM;As can be seen from the table, the data generated in software developmenthave a range of formats and sizes.andP;  Specifications tend to be unstructuredcollections of text, whereas source programs have more restricted formats.andO;Data definitions tend to be compact, whereas programs and listings tend to bebulky.andM;An important characteristic of these data is that they tend to be highlyinterrelated.andP;  That is, data produced in one stage are (or may be expected tobe) related to other data in that stage or different stages.andP;  For example,source modules are related to the program specification that they implementandgt;object modules are related to the source modules from which they are producedby a compiler, and so forth.andP;  When these relationships are properly recorded,the impact of changes in one aspect of the software on other aspects (e.g.,andO;the effect of a change to a record format on programs that use the record)can be readily determined.andM;In addition to data on the software itself, it is useful to maintain dataabout the hardware/software environment in which the software was developedand in which it will execute.andP;  When this is done, the impact of changes inthe environment on the software (e.g., the substitution of one terminal typefor another) can be readily determined.andM;Representation of software development dataandM;The first step in the development of a data model for software development isto identify and formally define the types of data involved.andP;  For thispurpose, it is useful to use the concepts of entity and relationship.andP;  Anentity is any identifiable thing or event that can be characterized in termsof a set of attributes and their associated values.andP;  For example, a sourcemodule is an entity with such attributes as programming language, statementcount, or reentrant.andP;  A relationship is an association of two or moreentities which may have attributes of its own.andP;  For example, the associationof an object module and the source module from which it was compiled is arelationship whose attributes include date of compilation.andM;Entities fall into types, which are based primarily on the particularattributes that they possess.andP;  For example, source modules tend to have thesame or similar attributes, and therefore they can be considered entities ofa single type.andP;  Relationships can be similarly typed, based on theirattributes and on the types of the entities that they associate.andM;A collection of entity types and relationship types constitutes anentity-relationship data model.andP;  The model is used by various softwaredevelopment tools in creating and maintaining entity and relationshipinstances, which represent software development information.andP;  The model canbe extended over time by adding types to support new kinds of softwareinformation.andM;The second step in developing a data model for software development consistsof determining how entities and relationships of each type will beimplemented.andP;  It is in this step that the spectrum of data formscharacteristic of software development can be best accommodated.andP;  Inparticular, entities that are compact and must be accessed from many otherentities can be implemented in an entity-relationship (ER) facility, such asthat provided by the IBM Repository Manager/MVS [TM] (RM).andM;Entities that are bulky and can be organized into records that are accessedsequentially can be represented as flat files, and surrogates for suchentities can be stored in an ER facility to document their existence andtheir relationships with other entities.andM;Model organizationandM;When facing the task of identifying the various types of entities to becontrolled and maintained, it quickly becomes apparent that an approach mustbe found that segments or divides the set of entity types into understandableand manageable units.andP;  Each of these units can then be analyzed forcompleteness and its role within the overall data model.andP;  Each unit can alsobe evaluated for any dependencies or associations with entity types in otherunits.andM;Entity-type categories.andP;  One such approach involves segmenting the set ofentity types into distinct categories, according to their relationships withother entity types and to the overall model.andP;  By this approach, we groupthose entity types that deal with software development from a conceptualstandpoint.andP;  These might include the following entity types: businessprocess, business goal, business entity, and business attribute.andP;  Togetherthey serve to define the requirements for business applications.andM;Another group might be composed of entity types to be used to describe asoftware program or system from a logic or design point of view.andP;  Such entitytypes as data views and data elements describe the data design forapplications and databases that meet the requirements identified in theconceptual model.andM;A third grouping in this example represents the physical implementation ofthe software program.andP;  Here, the entity types deal with the descriptions ofvarious implementations of the logical application description.andP;  The datastructures described in the logical definition are, in this case, representedas table definitions or segment defitions.andP;  The data view may be representedby a panel defition or a report format definition entity.andM;There are other entity types, however, that apply to more than one of thesecategories.andP;  Organization unit and location are examples of this type ofentity, which we call universal entity types.andP;  Table 2 lists the three entitytype categories just discussed and includes some examples of entity types andentity instances that fit within each category.andM;Example of relationships.andP;  The glue that joins these categories of entitytypes into a single view of data is supplied by relationship types (e.g.,andO;use, produce), which identify interdependencies and associations betweenindividual entity types regardless of their category.andP;  Using the levels amdentity types depicted in Table 2, relationship types can be identifiedbetween entity types within a signle category as well as between entity typesin different categories.andP;  For example, a PAYROLL process uses informationabout an EMPLOYEE (e.g., rate, hours worked, etc.) as input toEXECUTE__PAYROLL to reduce (MONTH__END) a paycheck.andP;  This is an instance of arelationship that associates a process with the data it either produces oruses.andM;Figure 1 illustrates some sample rerlationship types that associate entitytypes within a single category (business entity to business process) andacross category boundaries (data view to table definition).andM;Conceptually, there is no implication that the payroll process is acomputer-based application.andP;  The payroll process could be performed by monkslaboring in silence and seclusion, using quills and ink under candlelight.andO;At this conceptual level, the entities often referred to tangible things,events, and ideas.andM;At the logical level, those conceptual definitions are dealt with in dataprocessing terms.andP;  Again, however, the definitions have no specificimplementation characteristics.andP;  Here we see that a user view (e.g., CHECK)produces information described in a data view (e.g., EMPLOYEE__PAY__VOUCHER)andgt;the data view comprises many data elements (e.g., ACCOUNT__NUMBER).andM;The physical implementation of the payroll program unit is documented at thephysical level.andP;  Here is recorded the fact that the payroll program readsrecords from the employee table and prints an employee pay voucher.andM;Other relationships that can be defined here show that the payroll program isa single and unique implementation of the payroll function unit.andP;  The payrollfunction unit is in turn a logic design for all or part of the payrollprocess, as defined at the conceptual level.andP;  Similar relationships tie theemployee information to a data design and an implementation of that design.andM;Different types of descriptionsandM;A second method of sectioning the entity types uses the type of descriptiveinformation they contain relative to the software product being developed.andO;Reference 3 suggests that the minimal set of description types address thewhat, how, where, when, why, and who aspects of the product.andM;The application of the entity-type categories and description-type approachessimultaneously allow the partitioning of the entity types into very conciseunits.andP;  The grid or template into which these units fit is then very much inline with the framework described by Zachman in Reference 3.andP;  Figure 2 showsthis correlation.andP;  The scope and detailed description perspectives thatappear in the Zachman framework are shown here, but they are not applicableto the previous section on model organization.andP;  By building on the exampleshown in Table 2 and placing the entity types in appropriate cells in thegrid, the resulting model (without relationships) is shown in Figure 3.andM;Use of modeled dataandM;We have discussed various aspects of modeling data for software development.andO;In this section, we consider briefly the uses which can be made of the data.andO;Some of the functions we describe, such as program analysis, are nowexperimentally state-of-the-art, but their development should be stimulatedby the use of a common data model.andM;Traditionally, the process of developing software begins with requirements,continues with analysis and design, produce, build and test, and ends withproduction and on-going maintenance.andP;  Following that scheme and applying itto the model organization grid previously illustrated, it is apparent thatthere is a kind of flow through the model.andP;  During the requirements phase,those entity types identified in the conceptual level of abstraction arepopulated and manipulated.andP;  In the early stages of the design phase, thosesame entity types supply the basic information to shape the design.andP;  Thelogical entity types are populated with information from the conceptualentities.andP;  Depending on the robustness of the logical entity types and theinformation they contain, some or all of the information needed for codingcan be found in those entities.andP;  A tool that can obtain the designinformation from the logical entities can in turn populate the physicalentities and perhaps generate the bulk of the code needed for the softwareprogram.andP;  Under these conditions, the user is required to enter informationjust once.andP;  Translation and transformation of information from one level tothe next is the job of software tools.andM;Also note that there is no requirement that the user begin with enteringrequirements information at the conceptual level.andP;  The user may start at thelogical or physical levels.andP;  The level of detail is, of course, different ateach level, but there is no requirement that the definitions be completed atone level before moving on to the next.andP;  The model structure fully supportsan iterative style of modeling.andP;  Therefore, facts or concepts identified atone level can be iteratively applied to other levels.andM;We have been discussing here what is often referred to as a top-downapproach, that is, populating the repository model from the conceptual leveldownward.andP;  Another method for populating the repository model is thebottom-up method, which uses, for example, the analysis of existing programsto discover their structure, data usage, logic design, and operationalcharacteristics.andP;  This method normally begins with populating the physicalentities, and from them (with additional input) populates the logical andthen the conceptual objects.andP;  Figure 4 shows how these two methods vary.andM;Concluding remarksandM;The success of a data model for software development can be measured in termsof the following affirmative criteria:andM;* The model is easy to understand and use.andM;* A prospective software development tool developer can easily find theentity types and relationship types required.andM;* The entity and relationship types have been implemented appropriately.andM;* The model meets the performance objectives of the development tool.andM;* The model is robust.andM;* The model can be extended by the tool developer in a nondisruptive way.andM;AcknowledgmentandM;We wish to acknowledge the benefits we have received from the pioneering workof John Zachman in information systems architecture.andM;Repository Manager, Repository Manager/MVS, and AD/Cycle are trademarks ofInternational Business Machines Corporation.andM;Cited referencesandM;[1.] J. M. Sagawa, &quot;Repository Manager Technology,&quot; IBM Systems Journal 29,No.andP;  2, 209-227 (1990, this issue).andM;[2.] V. J. Mercurio, B. F. Meyers, A. M. Nisbet, and G. Radin, &quot;AD/CycleStrategy and Architecture,&quot; IBM Systems Journal 29, No.andP;  2, 170-188 (1990,this issue).andM;[3.] J. A. Zachman, &quot;A Framework for Information Systems Architecture,&quot; IBMSystems Journal 26, No.andP;  3, 276-292 (1987).andM;Robert W. Matthews  IBM Programming Systems, Santa Teresa Laboratory, P.O.andO;Box 49023, San Jose, California 95161-9023.andP;  Mr. Matthews is currently anadvisory programmer in repository product development at the IBM Santa TeresaLaboratory.andP;  He joined IBM in 1974 as a junior programmer in the IBMdevelopment laboratory, Kingston, New York, where he specialized insupporting the software development and library processes for the KingstonProgramming Center.andP;  In 1976, he assumed similar responsibilities at theSanta Teresa Laboratory.andP;  Since 1986, he has worked on different aspects ofthe use of a repository in software development.andP;  Mr. Matthews holds a degreein mathematics from New Mexico Institute of Mining and Technology.andM;William C. McGee  IBM Programming Systems, Santa Teresa Laboratory, P.O. Box49023, San Jose, California 95161-9023.andP;  Mr. McGee is currently a seniorprogrammer in repository product development at the IBM Santa TeresaLaboratory.andP;  He joined IBM in 1964 as a staff member of the Palo AltoScientific Center, where he specialized in physics applications, computergraphics, and database systems.andP;  In 1969, he received an OutstandingContribution Award for work on Data Base/Data Communication (DB/DC)requirements and strategy.andP;  In 1970 he joined the DB/DC development group inPalo Alto, where he was a manager of the DB/DC architecture department.andO;Other assignments in DB/DC development have included performance evaluation,distributed data requirements and planning, and data dictionary planning anddevelopment.andP;  From 1951 to 1959, Mr. McGee was with the General ElectricHanford Atomic Products Operation in Richland, Washington, as manager of thenumerical analysis unit and as a reactor data specialist.andP;  From 1959 to 1964,he was head of systems programming and research at Ramo WooldridgeCorporation in Canoga Park, California.andP;  Mr. McGee received the A.B.andP;  degreein physics from the University of California at Berkeley in 1949, and theM.A.andP;  degree in physics from Columbia University, in 1951.andP;  He is a member ofthe Association for Computing Machinery.andO;</TEXT></DOC>