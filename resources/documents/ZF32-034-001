<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO> ZF32-034-001 </DOCNO><DOCID>11 295 225</DOCID><JOURNAL>PC Magazine  Oct 15 1991 v10 n17 p97(2)* Full Text COPYRIGHT Ziff-Davis Publishing Co. 1991.andM;</JOURNAL><TITLE>2001: software for a new epoch. (Jim Seymour) (future of softwarefor microcomputers) (column)</TITLE><AUTHOR>Seymour, Jim.andM;</AUTHOR><SUMMARY>By the time the twentieth anniversary of the IBM PC rolls aroundin fall 2001, applications software will be very unlike that usedin 1981 or 1991.andP;  Applications in 2001 will be fast, mode-less,smart and memory-hungry.andP;  Early DOS-based applications werenotoriously 'modey.' For example, users of the firstword-processing program for the PC, EasyWriter, had to enter textin one mode and then edit the same text in another mode.andO;Mode-based operation still exists, albeit in more subtle forms.andO;Microsoft Windows, Ami Pro and Excel 3.0 promise the first, feeblesteps toward intra- and cross-application mode-lessness.andP;  By 2001,the average microcomputer will have 100Mbytes of RAM, allowing forincredibly fast program execution and very smart programs.andM;</SUMMARY><DESCRIPT>Topic:     Future of ComputingPerformance ImprovementSoftware DesignRandom access memoryMS-DOS.andM;</DESCRIPT><TEXT>2001: Software for a New EpochandM;A lot of us who have been around this business since before IBM ever thoughtof producing a &quot;personal&quot; computer, find ourselves in a particularlyruminative mood these days.andP;  This fall marks the tenth anniversary of IBM'sfirst PC.andP;  No doubt you'll be seeing a lot of misty-eyed &quot;how it was in theold days&quot; columns over the next few months.andM;I'll leave that revisionism to the historians.andP;  This issue and next, I'd likeinstead to look ahead ten years, to the kind of software we'll be using onthe twentieth anniversary of the first IBM PC and what we'll be doing withthose PCs.andM;There is an inevitability to the development of PC hardware.andP;  We know aboutthe plans from Intel and others for new chips.andP;  We know about flat-paneldisplays.andP;  And we know about voice- and handwriting-recognition and othertechnologies likely to be in place ten years hence.andP;  What we do with all thathardware is the more interesting, less certain question and that means thesoftware that runs on them.andM;By the time the twentieth anniversary of the introduction of the PC rollsaround, applications software won't look much like what we saw in 1981, norin 1991 for that matter.andM;Why? It'll be modeless.andP;  And fast.andP;  And smart.andP;  And damned big.andM;Of all those &quot;new looks,&quot; none will be so important as getting away from themode-based operation of present-day applications.andM;What? No modes? Isn't that a war we won almost ten years ago, not so longafter the PC was rolled out?andM;Early applications for what was known then as PC-DOS were infuriatingly&quot;modey.&quot; The first word processor for the PC, for example an abominationmisnamed Easy-Writer, long since forgotten by most of those poor souls whotried it was strictly mode-driven.andP;  You entered text in one mode; then youflipped to the program's other face to edit that text.andP;  Want to enter moretext? Fine.andP;  Flip back to the program's text-entry mode.andM;Today that sounds crazy, and it is.andP;  Entering text and editing text in a wordprocessor ought to be a single, seamless function.andM;More modes? PC word processors (and many of their predecessors on otherplatforms) had separate text-editing and text-formatting modes.andP;  You typed inyour material in the former, then flipped or even reloaded the program to getto its text-formatting mode.andM;That kind of arbitrary division between input and output or between entry andediting, reflected an older and far clumsier approach to computers, a relicof the days when computer software was used only by the programmers who'dwritten it.andM;When we got rid of the EasyWriters of the world, we thought we'd shed theburden of mode orientation in PC applications.andP;  But we were foolingourselves.andP;  Lotus 1-2-3, for example, couldn't print graphs from within theprogram, but only after you exited it and loaded its PRINTGRAPH utility(read: mode).andP;  Harvard Graphics users couldn't create a graph then annotateit in one screen; they had to get the bars, lines, and pie wedges rightfirst, then flip to a special annotation feature (read: mode).andP;  And on andon.andM;We've accepted a more subtle but no less foolish and obnoxious level ofmode-based operation in programs that even today are big sellers and widelyadopted standards.andP;  By 2001, not only will individual programs be free ofthis maddening mode orientation: The entire suite of programs we use willbegin to appear and work largely as one entity.andM;We see the faintest glimmers of that now.andP;  Ami Pro and Excel 3.0, forexample, let you use drawing tools directly, to annotate, decorate, ordesecrate your work within those programs themselves.andP;  And Windows, for allits warts, is a first feeble step toward cross-application modelessness.andO;Today we still have to switch from one program to another within Windows soit's not there yet.andP;  But future versions of Windows (under whatever name)will increasingly swallow up and integrate individual applications as weinstall them.andP;  They will appear to us as parts of a seamless whole.andM;BIGGER, FASTER, AND SMARTERandM;Beyond modelessness, raw speed may be the next most-important change in PCapplications.andP;  With RAM cheap and plentiful, our PCs will have 100MB or moreRAM.andP;  So no matter how big programs grow (keep reading), we'll be able toload all of our basic applications into RAM at once.andP;  And very large RAMcaches will swallow up the data we're working with.andP;  The result? Very fastprogram execution.andM;Living within the constraints of limited and (until recently) segmentedmemory has forced programmers into performance-hobbling tricks to conservememory.andP;  Without those constraints, and on the flat memory-model-based RISCchips we'll be using in 2001, apps will run far faster than anything we seetoday.andM;Limited memory has also kept programmers from producing truly smartapplications.andP;  Even the best of today's applications are still pretty dumb.andO;We've worked through the era of WYSIWYG software; now we're moving into theDWIM-programs epoch: the Do What I Mean apps.andP;  And software smart enough tozig when we want to zig even though we tell it to zag gobbles memory.andM;Which leads to the last of my four characteristics of PC applications adecade hence: truly massive programs.andP;  If you think software that demands512K is big, wait till you start putting apps on your gigabyte-sized harddisk that need three or four megabytes of RAM or five or ten to run.andM;Next time, I'll look at how truly smart, integrated software will work for usa decade hence, finally delivering on that &quot;working smarter&quot; promise so oftenheard today.andO;</TEXT></DOC>