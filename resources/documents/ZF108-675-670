<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-675-670  </DOCNO><DOCID>08 675 670.andM;</DOCID><JOURNAL>EXE  July 1990 v5 n2 p27(5)* Full Text COPYRIGHT Process Communications Ltd. (England) 1990.andM;</JOURNAL><TITLE>Program structures of the fourth kind. (The Fourth Kind)</TITLE><AUTHOR>Pickard, Richard.andM;</AUTHOR><SUMMARY>The article discusses the on-going search among computerscientists and programmers for an approach to structuredprogramming that avoids the use of the GO-TO statement.andP;  Theoriginal high-level or third-generation programming languages suchas FORTRAN and COBOL have little in the way of structuredprogramming tools.andP;  The development of nested IF statements andloops helps somewhat but the handling of hardware and softwareinterrupts by programs instead of assembler routines remains weak.andO;Languages developed in the 1970s provide some more structuredapproaches and some alternatives to the GO-TO statement such asBREAK and EXIT.andP;  An additional solution to the problem of locationin a program is presented.andM;</SUMMARY><DESCRIPT>Topic:     Structured ProgrammingThird GenerationProgramming LanguagesBranching.andO;Feature:   illustrationprogramchart.andO;Caption:   A POSIT block in outline. (program)The sample problem as a flow chart. (chart)The problem solved with GO TOs. (program)andM;</DESCRIPT><TEXT>During the 1950s and 1960s, the  bad old days', a succession of proceduralprogramming languages was developed, each at a 'higher level' than itspredecessor.andP;  For most of this period, the bulk of the design effort wasaimed at making it easier and faster to write programs.andP;  There was little toimprove the quality of code: the new high-level programs didn't work in justthe same way that the old assembler and machine-code programs didn't work.andO;Because the compiler writers 'thinking remained heavily oriented towards themachine and its features, high-level languages commonly offered only alimited range of data types and simplistic control structures.andP;  From themachine's perspective, data processing' was mainly about 'processing''Processing' meant doing calculations, moves and tests., and looping,branching and calling subroutines.andP;  Data' was in the province of theapplication -- nothing to do with the tool being used -- and compilers didlittle or nothing to check the legitimacy of what operations on data werebeing attempted.andP;  Certainly, the languages of that era provided a variety ofdata types for the convenience of the programmer, but these types werepredefined -- even in COBOL -- and only rarely were there any strong rulesabout the ways in which they could be combined.andM;However, it is structure issues that concern us here.andP;  The main point aboutstructure -- as it was first offered in high-level languages -- was that itwas barely recognised to exist.andP;  The original IF statement in FORTRAN wasmerely a three-way conditional branch; COBOL did a little better with the'conditional sentence'; not until ALGOL did we have a clear and usable way ofnesting IFs.andP;  The situation was a lot better with loops; these, bydefinition, have a clear scope.andP;  (The scope is specially clear if, as inCOBOL, the loop body is out of line and referred to by its label.) All earlylanguages provided procedure calls and returns -- most of them allowed areturn to the calling procedure from any point in the body of the calledprocedure.andM;Going, going, goneandM;The weakest area was probably that of interrupt and error handling.andP;  It washard to find a high-level language providing direct control over hardwareinterrupts and software events with equal power.andP;  The handling of hardwarewas (and is) not an integral part of most so-called system programminglanguages -- it was provided by libraries of assembler routines.andP;  Languagesupport for the handling of unpredictable software events was similarlymissing.andM;Computer scientists had long explored styles of programming includingfunctional (eg LISP), assertional (eg ancient RPG and modem PROLOG), amassive variety of procedural and special purpose languages and, morerecently, neural and vegetable approaches.andP;  But in the mid 1960s attentionwas focused on procedural languages (quite properly so, because mostprogrammers were using them).andP;  In this period -- and ever since -- theacademics have searched for purer structures; their constant bugbear has beenthe GO TO.andP;  in 1966, Bohm and Jacopini introduced an algebra for programmingbased on the idea of nested blocks of code, in which each block had one entrypoint and one exit.andP;  It used only the structures Sequence, IF and WHILE.andO;These authors admitted that not all programs could be expressed in theiralgebra.andP;  In 1968, Edsgar Dijkstra's famous letter 'GO TO StatementConsidered Harmful' stirred up much ardour in the hearts of purists and soonit was proved, by others that 'every flowchart program can be written withoutGO TO statements by using WHILE statements'.andM;High-flown academic debate was all very well, but it took a second school ofthought in favour of leap-free code to popularise the notion  on the ground'.andO;There was a growing band of program provers (such as Floyd in the early'70s), who had a need to limit the damage to their methods that a wayward GOTO could inflict.andP;  It was clear that well--structured programs were mucheasier to understand.andP;  The GO TO--less view was promoted and taken up by themakers of increasingly large and complex software systems.andM;In general, languages continued to provide a GO TO, but there began to appearsome varieties which left it out.andP;  In these languages, other techniques wereintroduced to replace it.andP;  The most common, in one form or another, was'BREAK' or 'EXIT'.andP;  BREAK caused a transfer of control from within one blockto the beginning of the next block at the same level; mostly it was used toprovide a premature escape from a loop.andP;  One variation which I have seen hada BREAK with an optional number - to specify how many levels of block fromwhich to escape.andM;Pascal is the most famous language to be designed specifically for structuredprogramming; curiously, it retains the Go TO and fails to provide a BREAK ora RETURN -- each block of code is entered at its beginnings and exited at itsend.andP;  As Kernighan pointed out (and anyone who's tried it knows) thiscombination makes for some tricky coding, especially in loops.andM;The ProblemandM;Now it's time to ask  what is the real problem?'.andP;  We must certainly agreethat the writing of easily understood programs in self-contained sections isdesirable.andP;  it promotes easier debugging and bug pre-empting walk-throughs.andO;it may lead to easier proofs of correctness.andP;  These factors taken togetherraise quality and simplify the task of managing software production andpredicting costs.andM;The problem is that, when we write real programs, it is nearly always thecase that we have to cater for errors and exceptions whose occurrence, bydefinition, must radically change the course of a program.andP;  Consider thesimple problem of reading lines of text until end of file.andP;  In old-fashionedprogramming, the end-of-file case would have been handled by a (smelly buteffective) GO TO.andP;  Some of the 'commercial' programming languages offeredescape techniques.andP;  PI/1 (circa 1965) provided the ON statement to specifyaction to be taken if certain software or hardware conditions arose; theseconditions included both arithmetic and programmer-defined exceptions.andP;  COBOLprovides the DECLARATIVES sections to trap file-- and record-handlingexceptions and errors.andP;  Some of the newer versions of C (circa 10 years on)and Ada (20 years) have also implemented similar handlers.andM;But the notion that a block of code could have a natural escape route was notgeneral.andP;  The exception-handlers of PI/1 and COBOL were always written before(ie textually above) the points in the program where their conditions couldarise; to implement a change of course in the main body of the program, thesehandlers had to end with a GO TO, or set a variable  flag) to be tested bythe main body when it was resumed.andP;  There still wasn't a way to express aprogramming idea such as Read the next text-line, but if at end of file, geton with the closing sequence (and then the rest of the program) except toexpress it with an explicit or implicit GO TO.andP;  (I mention the implicit Go TObecause of the example provided by the FORTRAN READ statement's optionalclause:END=label.)Notice that COBOL's AT END clause doesn't get us out of anyholes either.andM;Escapes are what GO TOs are properly used for.andP;  They lead to a programsection which deals with some situation which is:andM;*  Radically different from what the program is doing at the point from whichthe escape is made.andM;*  Common to different points in the program (but not necessarily).andP;  'Now',you may say, 'this is an obvious case for invoking a procedure.' Not so.andP;  Youonly shift the problem to what to do when the procedure returns, just likethe ON in PL/1 or the DECLARATIVE in COBOL.andP;  This is definitely a job for GOTO.andM;An area of program construction which has worried me for a long time (as aresult of avoiding GO TOs) is the Why am I here, and where do I go next?andO;problem.andP;  On exit from a loop (never mind how), such as that contained in atable lookup, do we have a valid result? When a READ fails, and the cause hasto be unravelled, what has to happen for the different cases of 'No recordfound', 'File not opened', 'Abort',  Retry' and  Fail'?andM;One technique for handling this problem is to invent an auxiliary variableflag), whose value is set inside the block doing the work, which is tested onexit from the block.andP;  IF or CASE constructs can be used for the test, and theflag has no other use in the program other than this steering function.andO;Sometimes we cheat, and use the result obtained by the inner block in twoways.andP;  For example, in the case of a table lookup, the result can be given an'impossible' value to indicate the failure of the search.andP;  Note that thisproblem and its solution are the same if the attempted work is done byin-line code or by a separate procedure.andM;When procedures are indeed written separately, they can be constructed asfunctions, and substituted in the places where an auxiliary variable mighthave been used.andP;  This saves the program itself having to declare thevariable, but it will probably still exist, hidden inside the function'sdefinition.andM;The SolutionandM;I would like to reduce programs to their essentials.andP;  If a section of codecan have different successor sections, depending on the conditionsencountered during the execution of that section, then -- right at the pointwhere the condition is identified -- I would like to arrange to execute therelevant successor.andP;  if a variable must be created just to convey thesignificance of some earlier result, and will only be used once, to determinethe next action then I don't want it.andP;  Having to test a flag means that youmissed the chance to act when the event occurred.andM;We are looking for a control structure which satisfies the followingrequirements:andM;*  To escape from the current block to some later block.andM;*  To escape up through any number of levels.andM;*  To arrive at the destination with some idea of why the escape was made.andM;*  To retain a block structure in which uncontrolled branches cannot be made(accidentally or deliberately).andM;The solution -- which is not wholly my own, and has its roots in academicwork done in 1970 -- is to use a new kind of block and a restricted form ofGo TO.andP;  This new block -- the fourth kind -- is called a POSIT('let it besupposed').andP;  As you can see from Figure 1 [omitted], it has a main body andany number of conditional parts.andP;  The POSIT and the conditional parts are allgiven names.andP;  Normal program flow is from the beginning to the end of themain body and then to the next block at the same level, ie after the lastconditional part.andP;  Abnormal flow is initially from the beginning of the mainbody and -- at some point where an exception is detected -- to just one ofthe conditional parts and then on to the next block.andP;  The way of makingescape is with a P ROVE statement, which nominates the POSIT, or with a DENYstatement, which nominates the POSIT plus a conditional part.andP;  PROVE makes acomplete escape, directly to the next block, DENY makes the escape via thenamed conditional part.andM;The scope of the names in a POSIT is statically limited to its body; escapesto irrelevant, external conditional actions are, therefore, impossible.andP;  Thenames of POSITs or their conditional parts may be passed as actual parametersto procedures so that they may PROVE or DENY on behalf of their callers.andO;(The formal parameter would be of type POSIT or DENIAL.)andM;Does it work?andM;Figures 2-4 [omitted] show a simple program.andP;  As a flowchart, the problem iseasily understood; it's to about listing Products, from a file, and theirSuppliers.andP;  Suppliers are few enough that they can be looked up in a table.andO;The programmed versions are done in Figure 3 with GO TOs and in Figure 4 withPOSITs to show how easy they are to use (if you relax and concentrate).andM;Let's check how well some of the problems and requirements have beenanswered:andM;*  POSIT allows escapes from the current block to some later block, upthrough any number of levels.andM;*  The place to which escape is made -- the destination - is chosen accordingto the cause.andM;*  Branches cannot be made, except to points in, or at the ends of,surrounding blocks.andM;*  There is no need for flags.andM;*  Called procedures can cause an escape; thus hardware-related interrupthandlers can act to change the course of a program.andM;It looks good so far, the pragmatic requirements of real code have beensatisfied, and the dangers of GO TOs avoided.andP;  Maybe, when they threw out theGO TO, they were a little too quick to throw out the label.andM;Two more areas to check are recursion and multi-tasking.andP;  Recursion is notreally a problem, because the executions of the called procedures (self orother) are synchronous.andP;  But suppose that the main body of a POSIT hasinitiated some asynchronous tasks and -- while doing some work of its own --PROVEs or DENYs itself.andP;  What should happen to the still-working tasks? Myanswer is that the operating system should terminate them, preferably by aDENY of their outermost POSIT, and-they are forgotten about (but I'm preparedto discuss it).andM;Does any language which you know allow this kind of control? The only thingnear it which I have seen is the Action Diagram, in Knowledge Ware's AnalystWorkbench.andP;  This is a picture-and-text editor for the specification ofstructured procedures.andP;  It allows the drawing of Sequence, IF and WHILEblocks and it allows the drawing of an EXIT from any block to any outerlevel.andP;  Because the mouse is used to point to the outer level, no labels areinvolved (in a text-only language such a handle cannot be avoided).andO;KnowledgeWare's EXIT is equivalent to the PROVE of the POSIT.andM;I would like the question of how to replace the GO TO reopened.andP;  Thegenerality of the loop structure has been successfully implemented in thePLANC language (The Third Side, .EXE November '89) and should be copied byothers.andP;  In the same way, we need a generalised block-and-escape structure,such as I have described here.andM;Dr Richard H Pickard has been a full-time data processing practitioner andwriter on the subject since 1964.andP;  He is equally interested in theapplication of DP techniques to business problems as in the techniquesthemselves.andP;  He is now a senior computing specialist for Whitbread.andP;  Richardmay be contacted on 0525-61836.andO;</TEXT></DOC>