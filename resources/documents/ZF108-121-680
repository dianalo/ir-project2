<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-121-680  </DOCNO><DOCID>08 121 680.andM;</DOCID><JOURNAL>Dr. Dobb's Journal  Dec 1989 v14 n12 p80(5)* Full Text COPYRIGHT Mandamp;T Publishing 1989.andM;</JOURNAL><TITLE>Are the emperor's new clothes object oriented? Some down-to-earthquestions about programming's latest high-flying fad.andO;</TITLE><AUTHOR>Guthery, Scott.andM;</AUTHOR><SUMMARY>Object-oriented programming (OOP) challenges traditionalprogramming procedures.andP;  OOP programmers historically acceptclaims without asking for proof.andP;  They have also ignored warningsto find out what a term means before using it.andP;  A debatable OOPfeature is that it offers reusable code.andP;  The unit of reuse is inthe hierarchy and hierarchies are nonmodular.andP;  This could requirereusing much more code than necessary.andP;  Additionally, it isdifficult to integrate code fragments.andP;  Fine tuning anobject-oriented program requires reorganizing the hierarchy,causing the semantics of the hierarchy to become a combination ofdescriptive reality and procedural code interpretation.andP;  OOPproblems include its failure when implemented on hardware, lack ofcoexistence and the persistent state of data.andM;</SUMMARY><DESCRIPT>Topic:     Object-Oriented ProgrammingProgrammingHierarchical OrganizationData AnalysisResearch Design.andM;</DESCRIPT><TEXT>Are the Emperor's New Clothes Object Oriented?andM;Alarge number of sweeping claims, particularly with respect to programmerproductivity and code reuse, are being made for object-oriented programming(OOP), many of them by firms that are in the business of making and sellingobject-oriented programming tools.andP;  Before we bet a real programming projecton this freshy sewn technology, we'd like to ask some questions aboutobject-oriented programming just to make sure the emperor's new clothes arereally as fine as these tailors claim.andM;Where's the Evidence?andM;In scientific and engineering disciplines -- besides computer science andprogramming -- we accumulate experience, gather evidence, and conductexperiments, which we then generalize to make claims.andP;  If one doubts theclaims one is invited to reanalyze the data and replicate the experiments.andO;For some strange reason, programmers have a history of accepting claimsblindly without asking for proof.andP;  Hope springs eternal, I guess, and direneed grasps any straw.andP;  To my knowledge there has been absolutely no evidencegathered or experiments performed to validate the claims made forobject-oriented programming, particularly for object-oriented programming inthe large.andM;The biggest OOP projects undertaken to date seem to be the OOP developmentsystems, and the news from this front is not all good [Harrison, 1989].andP;  ButOOP isn't supposed to be an end in itself.andP;  Esperanto was wonderful forwriting books about Esperanto but not much else.andP;  If you want to write an OOPsystem, then OOP is probably just the thing.andP;  But if you want to write, say,an accounting system or a reservation system using OOP you're going where noman or woman has gone before.andP;  In fact, you'll be performing on yurself thevery experiments that the OOP peddlers should have performed to substantiatetheir claims.andP;  Would you accept this situation if OOP were, for example, anew surgical procedure?andM;What is an Object?andM;The atomic element of object-oriented programming is, not surprisingly, theobject.andP;  But what is an object?andP;  The 51 papers in the IEEE &quot;Tutorial onobject-oriented Computing&quot; by Gerald Peterson [Peterson, 1987] contain manydefinitions and descriptions of an object.andP;  These definitions come in twobasic flavors.andP;  One flavor talks about modeling reality and the other talksabout encapsulated collections of programming tricks.andM;Stripped of its fancy jargon, an object is a lexically-scoped subroutine withmultiple entry points and persistent state.andP;  Object-oriented programming hasbeen around since subroutines were invented in the 1940s.andP;  Objects were fullysupported in the early programming languages AED-0, Alol, and Fortran II.andO;OOP was, however, regarded as bad programming style by Fortran aficionados.andO;As Admiral Grace Hopper has so often observed, we don't actually do anythingnew in computing we just rename the old stuff.andP;  Admiral Hopper (at the timeLt.andP;  Hopper) was doing object-oriented programming on the Harvard Mark I in1944 and probably didn't even know it.andM;Unfortunately, we have completely ignored Rentsch's 1982 plea [Rentsch,1982]: &quot;Let us hope that we have learned our lesson from structuredprogramming and find out what the term means before we start using it.&quot;andP;  C++was first described in April, 1980 [Stroustrup, 1980].andP;  Over nine years lateran incompatible Version 2.0 has just been released.andP;  The definition of C++still isn't complete.andP;  Can anything that's this hard to define be good forwriting understandable and maintaiable programs?andP;  And if you think it's hardto pin down the definition of an object, just try drawing a bead on thedefinition of the inheritance links that connect objects.andM;What's the Cost of OOP Code Reuse?andM;One of the primary claims of object-oriented programming is that itfacilitates the reuse of code.andP;  Does it?andP;  And if so, at what cost?andM;The unit of reuse in object-oriented programming is the hierarchy.andP;  It is thehierarchy and not the object that is the indivisible whole.andP;  Unlike asubroutine library where you can just take what you need and no more, inobject-oriented programming you get the whole gorilla even if you just wantedthe banana.andM;The problem is that hierarchies are nonmodular.andP;  You can't just clip theobjects you want to reuse out of the hierarchy because you don't know (infact, aren't supposed to know) how the objects are entangled in thehierarchy.andP;  So, the cost of OOP-style code reuse seems to be that you must(re)use a lot more code than yu want or need.andP;  Your system will be bigger,run slower, and cost more to maintain than with subroutine-style reuse.andO;Though there may be situations in which the convenience of the programmer socompletely outweighs the interests of the users and the interests of themaintainers, I've never seen one.andM;How to Combine Object Hierarchies?andM;If object hierarchies need to be small to control the cost of their reusethen you must be able to get many of them to work together when you buildyour program.andP;  You may, for instance, want to use a polynomial approximationhierarchy, a linked list hierarchy, a communication hierarchy, an indexedrecord hierarchy, a pop-up menu hierarchy, and a ray-tracing hierarchy all atonce.andM;But how do you combine object hierarchies?andP;  Can objects in a C++ mathematicshierarchy send arguments to objects in an Objective-C ray-tracing hierarchy?andO;Sadly, no.andP;  What's worse is that you can't even send arguments from one C++hierarchy to another.andP;  There are neither in theory nor in practice any OOPhierarchy combiners.andM;It is left as an exercise for the OOP programmer to &quot;impedance match&quot; notonly between OOP technologies but between OOP hierarchies within atechnology.andP;  This means doing exactly what you were told you wouldn't have todo; open up the objects and program with respect to representation of thestate inside.andP;  The object-oriented programmer must map from one internalrepresentation to another.andP;  There is, after all, no reason to suspect thatone hierarchy's internal representation of a compound object such as a matrixor a picture is anything like another's.andP;  This clearly defeats one of themain advertised benefits of object-oriented programming: Namely, hiddeninternal representation.andP;  What you may have saved by not having to write codefor objects in the same hierarchy, you now must spend as you write code tomap between objects in different hierarchies.andM;One of the few things that we have learned (again and again) over the last 40years of programming is that the hard part isn't getting code fragments towork.andP;  The hard part is getting them to work together.andP;  The name of the game,particularly when it comes to code reuse, is integration at scale.andO;Object-oriented programming makes building code fragments easier, but itmakes integration much more difficult.andP;  Making the easy parts easier but thehard parts harder is not progress by my lights.andM;How to Tune an Object-OrientedandM;Program?andM;Has any program you've ever written been too fast or even fast enough?andP;  Whatdo you do if your object-oriented program isn't fast enough?andP;  How do youperformance tune an object-oriented program?andP;  Indeed, how do you even answerthe question, &quot;Where is the program spending its time?&quot;andM;It's just possible you'll find yourself spending lots of time in one or twoof your own methods and can work on making those methods faster using classictechniques.andP;  But it's much more likely that you'll find you're spending moretime than you care to running around the hierarchy.andM;There is only one thing you can do: Rearchitect and reorganize the hierarchyitself to make it more efficient and to take into account the way you want touse it.andP;  The semantics of the hierarchy thus become a twisted combination ofthe descriptive reality that the objects came from and the profile of the useyour procedural code makes of them.andP;  This is not an attractive prospect.andM;The problem here, of course, is that while the semantics of classicprogramming languages match the semantics of the underlying hardware, thesemantics of object-oriented languages do not.andP;  When using classic languageslike C or Fortran, if you couldn't bind the problem to the hardware tightlyenough to get the performance you needed, you could make this binding tighteryet by resorting to assembly language or even microcode.andP;  You can't do thiswith an object-oriented program because you can't get at the virtual machinethat implements the semantics of these languages.andP;  They're all hidden awayfrom you in the vendor's compiler and runtime library.andM;Once again, the programmer is being invited to pass the cost of expedienceonto the user of the system.andP;  The additional cost of supporting a runtime OOPvirtual machine can vary from as little as 50 percent [Thomas, 1989] to asmuch as 500 percent of the cost of a non-OOP version of the system.andP;  Thiswholesale sacrificing of runtime efficiency to programmer's convenience, thisemphasis on the ease with which code is generated to the exclusion of thequality, usability, and maintainability of that code, is not found in anyproduction programming environment with which I am familiar.andM;Finally, before we leave the topic of hardware, let's not forget the Intel432.andP;  The 432 was OOP in silicon and it failed because it was just too slow.andO;If we couldn't make OOP efficient when we implemented it in hardware why dowe think we can make it efficient when we emulate it in software?andM;How to Manage the OOP DevelopmentandM;Team?andM;Real programs are built by large programming teams, not by individuals orsmall, closeloy knit cliques.andP;  Because we certainly don't want to imaginethat every programmer on a project builds his or her own private objecthierarchy, we are faced with the prospect of many programmers working on thesame tree.andP;  Given something as flexible as an object to work with, it isalmost certain that each programmer working on the tree will want toimplement a different vision of the reality that the tree is attempting tocapture.andM;One possibility is to appoint an object &quot;czar,&quot; the direct analogy of adatabase administrator.andP;  Databases need to be stable, so appointing anadministrator to watch over the database schema and carefully coordinatechanges to it makes good software engineering sense.andP;  Object hierarchies, onthe other hand, are deliberately not stable; the hierarchy is the programafter all and it's the program that we're developing.andP;  Imagine having to askthe permission of the subroutine czar every time you wanted to write asubroutine.andM;What really happens?andP;  What I've seen in the three large (7000+ objects) OOPprojects is that because everyone is trying to get his or her job done with aminimal number of dependencies on everyone else, subtrees and subrealitiesspring up all over the place and new objects and new methods sprout likeweeds.andP;  There was an object in one of these systems which when printed wenton for 80 pages.andP;  One also finds lots of little private languages forcommunicating between these subrealities.andM;Of course, good communication between the team members can attenuate thegrowth of some of this gratuitous complexity.andP;  But, in projects on tightschedules with programmers removed from one another in time, space, andorganization, predicating success on good communication adds more risk to analready risky undertaking.andM;Another distressing property of these multi-programmer hierarchies is thatthey're difficult to debug.andP;  If there is one overarching flaw in OOPM it'sdebugging.andP;  As was noted recently in the OOP newsgroup on USENET, &quot;it hasbeen discovered that C++ provides a remarkable facility for concealing thetrivial details of a program -- such as where the bugs are.&quot;andM;While we're passing through this analogy with database management systems,recall that one of the raison d'etre for DBMSs was the separation of data andprogram.andP;  Now, along comes OOP and we're told that mixing data and program isthe right thing to do after all.andP;  Were we wrong then or are we wrong now?andM;Do object-Oriented Programs Coexist?andM;We have gotten used to mixing languages in our programs.andP;  This isindustrial-strength code reuse in action; if you can't access it at will, youcan't reuse it.andP;  You don't have to rewrite a Fortran subroutine into C to useit in a C program, you just call it.andP;  Common or at least coercible callingconventions and a uniform linking model have made this possible.andP;  One of themany reasons that Lisp has failed as a programming language is that Lisp is alanguage loner.andM;How about object-oriented languages?andP;  Can you mix Objective-C, Eiffel, CLOS,Actor, Owl, and C++ objects in a tree?andP;  Not on your tintype.andP;  Objecthierarchies are isolated bunker realities just like the language technologiesthat implement them.andM;We have learned that there is no all-singing, all-dancing anything incomputing.andP;  No one language, no one communication protocol, no one operatingsystem, no one graphics package -- no one anything is always right all thetime everywhere.andP;  We have learned again and again that closed systems arelosers.andP;  Successful systems have one thing in common -- they can coexistpeacefully and gracefully with other systems.andP;  Object-oriented programmingdoes not currently have this property, either in concept or in practice.andP;  Ifby &quot;reuse&quot; OOP advocates really mean &quot;reuse when the whole world is just likeme&quot; then this is not reuse in any practical or useful sense.andM;What are the Consequences ofandM;Persistent State?andM;Persistent state means that data obtained from an object cannot be usedindependently of that object.andP;  It means that the very act of obtaining avalue invalidates all other previously obtained values.andP;  Programmatically,this means that every time you want to use a value you have to retrieve itfrom the hierarchy.andP;  It is a programming error to make a local copy of avalue.andP;  Hierarchy chasing and the inheritance machinery are not only in theinner loop of every orthodox object-oriented program, they are part andparcel of every use of every value in the program.andM;But, persistent state isn't only a performance issue.andP;  It is much moreimportantly a data consistency issue.andP;  The only correct way to get two ormore consistent values from an object heirarchy is to get them together inone package in one response to one query.andP;  This is the only way you can beassured that they are consistent each with the other.andP;  Not only have I notseen any discussion of this property of OOP, I have seen exampleobject-oriented programs that don't understand the consequences of persistentstate and simply assume consistency between values obtained serially.andO;Without explicit assurances from the designers of the hierarchy in use, thisis an error.andM;There was a very good reason why persistent state was regarded as bad Fortranprogramming style -- it's semantic mine field.andP;  Why do we have to completelyrediscover the principles of good programming with each new programminglanguage and paradigm we invent?andP;  In all but very restricted and tightlycontrolled situations experience has shown that persistent state should beavoided.andP;  For those who haven't taken a stroll in this mine field,object-oriented programming offers the opportunity to avoid reusing other'sexperience and learn for themselves.andP;  As with modularity and the separationof programs and data, OOP seems content to simply ignore what we have learnedin 40 years of programming.andM;Can You Get the Development SystemandM;Out of the Production System?andM;A common failing of many programming aids such as OOP is that you can't getrid of them when you're done with them.andP;  They're like training wheels on abicycle except you can't take them off when you've learned to ride.andO;Programming languages such as Lisp and methodologies such as OOP areparticularly painful because they are based on a virtual machine that sitsbetween you and the real machine.andP;  The virtual machine is a nice warm-fuzzyto have during development but we simply can't afford to have it in ourproduction systems.andM;Structured programming was such a success because you got all the benefits ofenhanced software productivity without any runtime penalty.andP;  We don't knowyet what the minimal runtime cost of OOP is but our inability to measure itand hence engineer it should certainly give us pause.andP;  I'm uncomfortableworking with a programming paradigm whose runtime cost I can't even estimate,let alone eliminate.andM;ConclusionandM;Object-oriented programming runs counter to much prevailing programmingpractice and experience: In allocating and controlling software costs, inmodularity, in persistent state, in reuse, in interoperability, and in theseparation of data and program.andP;  Running counter to prevailing wisdom doesnot, of course, automatically make an innovation suspect but neither does itautomatically recommend it.andP;  To date, in my opinion, advocates ofobject-oriented programming have not provided us with either the qualitativearguments or the quantitative evidence we need to discard the lessonspainfully learned during the first 40 years of programming.andM;BibliographyandM;Harrison, William H., John J. Shilling, and Peter F. Sweeney, &quot;Good News, BadNews: Experience Building a Software Development Environment Using theObject-Oriented Paradigm,&quot; IBM Technical Report RC 14493, March 3, 1989.andM;Petersen, Gerald E., &quot;Tutorial: Object-Oriented Computing,&quot; Computer SocietyPress of the IEEE, Order Number 821 and 822, 1987.andM;Rentsch, Tim, &quot;Object-Oriented Programming,&quot; SIGPLAN Notices, Volume 17,Number 9, (September 1982) pp.andP;  51-57.andM;Stroustrup, Bjarne, &quot;Classes: An Abstract Data Type Facility for the CLanguage,&quot; Bell Laboratories Computing Science Technical Report No.andP;  84,April 3, 1980.andM;Thomas, Dave, &quot;The Time/Space Requirements of Object-Oriented Programs,&quot;Journal of Object Oriented Programming, March/april 1989, pp.andP;  71-73.andM;Scott is a scientific advisor at Schlumberger's Austin System Center inAustin, Texas, where he was the chief software architect of Schlumberger'snew family of wellsite data acquisition systems.andP;  He has a Ph.D.andP;  inprobability and statistics from Michigan State University and he has beenprogramming since 1957.andP;  He can be reached through Internet: @gutheryasc.slb.com.andO;</TEXT></DOC>