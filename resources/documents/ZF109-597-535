<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF109-597-535  </DOCNO><DOCID>09 597 535.andM;</DOCID><JOURNAL>Communications of the ACM  Nov 1990 v33 n11 p75(12)* Full Text COPYRIGHT Association for Computing Machinery 1990.andM;</JOURNAL><TITLE>Transaction processing monitors.andO;</TITLE><AUTHOR>Bernstein, Philip A.andM;</AUTHOR><SUMMARY>Modern transaction processing (TP) systems consist of integratedbasic software, including a high-performance data base managementsystem, communication system and TP monitor.andP;  The TP monitorshould provide an interprocess communication concept that hidesnetworking details, should manage processes and should allowsystem managers to easily and efficiently control large networksof terminals and processors.andP;  The TP monitor ties independentcomponents together and provides a single, integrated interface tothose components.andP;  The TP monitor's main function is to coordinatetransaction requests between terminals and application programsthat process the requests.andP;  The TP monitor accomplishes this byimposing a certain structure on the software components of a TPsystem and offering support functions for each component'sactivities.andP;  Other aspects of TP monitors are discussed in detail.andM;</SUMMARY><DESCRIPT>Topic:     On-line transaction processingSoftware DesignData Base DesignData base management systems.andO;Feature:   illustrationdiagramprogram.andO;Caption:   A model for TP monitors. (diagram)A forms manager's compilation process. (diagram)A program implementing MM, RC and AS functions for a terminal.andO;(program)andM;</DESCRIPT><NOTE>Only Text is presented here; see printed issues for graphics.andO;</NOTE><TEXT>Transaction Processing MONITORSandM;Atransaction processing (TP) application is a program that performs anadministrative function by accessing a shared database on behalf of anon-line user N TP system is an integrated set of products that supports PPapplications.andP;  These products includes both hardware such as processorsmemories, disks and communications controllers and software, such asoperating systems (OS), database management systems (DBMS) computer networks,and TP monitors.andP;  Much of the integration of these products is provided by TPmonitors which coordinance the flow of transaction request between terminalsthat issue request and TP applications that can process them.andM;Today, TP represents over 25 percent of the computer systems market and isone of the latest growing segments of the computer business.andP;  TP applicationsappear in most sectors of large enterprises such as airline reservation,electronic banking, securities trading, inventory and production control,communications switching videotex, sales management, militar command andcontrol and government services.andM;TransactionsandM;A transaction is a unit of work that executes exactly once and producepermanent results.andP;  That is, transactions should beandM;* serializable--the system should appear to process transactions serially;andM;* all-or-nothing--each transaction should either execute in its entirety orhave no effect; andandM;* persistent--the effects of a transaction should be resistant to failures.andM;A &quot;user-oriented request&quot; may require executing several transactions.andP;  Forexample, to process an order, a user may enter the order, request a shipment,and issue a bill, each of which may execute as a transaction.andP;  To simplifythe discussion, this article assumes that a user-oriented request executes asone transaction.andM;To ensure serializability, all-or-nothing, and persistence, the systemrequires application programmers to delimit the boundary of each transaction,(e.g., by bracketing the corresponding application program with theStart-transaction and End-transaction operations).andP;  The programmer can causethe system to obliterate an active transaction by issuing theAbort-transaction operation.andP;  At execution time, each transaction eithercommits (it executes in its entirely and its results persist) or aborts (itseffects are undone).andM;Most of the system's support for serializability, all-or-nothing, andpersistence is within DBMSs.andP;  Each DBMS uses concurrency control (usuallylocking) to make its execution serializable.andP;  It uses recovery mechanisms(usually logging) to make transactions all-or-nothing and persistent, byundoing the effects of transactions that do not finish, and by writing all ofa transaction's updates to the log before the transaction commits.andM;If multiple DBMSs are accessed by a single transaction, then additional DBMScoordination is needed, often with TP monitor or OS support, via thetwo-phase commit protocol: To ensure all-or-nothingness despite failures, thefirst phase of two-phase commit requires every DBMS accessed by a transactionto put that transaction's updates on stable storage (e.g., disk).andP;  After allDBMSs acknowledge phase one, each DBMS is told to commit the transaction.andM;Concurrency control, recovery, and two-phase commit mechanisms arewell-documented in the literature, and are not discussed further in thisarticle (see [4]).andM;A typical TP application contains relatively few transaction types--sometimesless than ten, usually less than a few hundred.andP;  The resources required by atransaction can cover a broad range.andP;  Typically, it uses up to 30 diskaccesses, up to a few million machine language instructions, and up to a fewdozen network messages.andP;  Today's largest TP systems have about 100,000terminals and 1000 disks, and can sustain several thousand transactions persecond at peak load.andP;  Many TP systems, large and small, are distributed,consisting of multiple nodes that can process transactions.andM;The TP Computing StyleandM;Most of the attention on TP technology in the technical literature hasfocused on database aspects of TP.andP;  Although database are quite important toTP, the database view of TP is incomplete, because performance andease-of-use are also much affected by the OS and its integration withcommunications.andM;Unless a computing platform is specifically designed for TP (and few of themare), there are likely to be many inefficiencies and inconveniences inimplementing TP applications.andP;  The reason is that TP is a style of computingdifferent from other standard computing models: batch processing,time-sharing, and real-time.andP;  Most importantly, TP systems support thetransaction abstraction, which is absent from the other three models.andP;  Thetransaction is the basic unit of computation, different from the &quot;process&quot; or&quot;task&quot; abstraction supported by the underlying OS.andP;  TP differs in other waystoo.andM;In classical batch processing, a batch of sorted transaction requests ismerged with an input master file to produce a new master file.andP;  TP differsfrom classical batch processing in its need to support a large number ofterminals and active users, associative and random access to files, andfine-grain failure handling.andM;In classical time-sharing, a user logs in from a terminal and executes asequence of requests that is unpredictable from the system's viewpoint.andP;  TPdiffers from time sharing in the regularity of its application load, theintensity of database management and communications over computation, and itsrequirement for very high availability.andM;In real-time systems, fast response time is the main goal.andP;  Due to itson-line response time requirements, TP is essentially a database-intensivereal-time system that supports the transaction abstraction.andM;TP MonitorsandM;Through the early 1970s, building a TP system was a roll-your-own activity.andO;Computer vendors supplied hardware, an OS, and sometimes a DBMS, althoughoften the latter could not meet the response time requirements of TP.andP;  Thevendor's system was usually designed for batch, time sharing, or real-time.andO;The customer had to modify it into a platform suitable for TP.andM;Today's customers expect far more.andP;  The vendor must supply a full complementof integrated basic software, including a high-performance DBMS,communications system, and TP monitor.andP;  Application builders expect the TPmonitor to offer a seamless integration of the basic software.andP;  The TPmonitor should manage processes, should provide an interprocess communicationabstraction that hides networking details, and should help system managersefficiently and easily control large networks of processors and terminals.andO;In this sense, a TP monitor is a combination of &quot;glue&quot; and &quot;veneer&quot;--gluethat ties together independent components and a veneer that provides asingle, integrated interface to those components.andM;There are several ways to structure a TP monitor to provide these functions[2].andP;  In the following section, a model for these structures is presented.andO;All TP monitors of which the author is aware conform to this model.andP;  Thefunctions of each component are discussed in the section entitled &quot;TP MonitorFunctions.&quot;andP;  A major aspect of TP monitor functionality is the way it mapsthe model's components into OS structures.andP;  This is described in the sectionentitled &quot;Process Management.&quot;andP;  Queuing functions that provide fault-tolerantmessage passing are described in the &quot;Queuing&quot; section, followed by adiscussion of system management and application recovery in the sectionentitled &quot;System Management and Recovery.&quot;andP;  The article concludes by showinghow distributed computing features of new OSs are subsuming traditional TPmonitor functions, and how TP monitors are likely to evolve as a result.andM;Throughout the article, it is explained why vendors choose one structure overanother, using popular commercial products as examples, such as Digital'sACMS [9] and DECintact [8], IBM's CICS [11, 16, 24] and  IMS/DC [15], andTandem's Pathway [21] TP monitors.andP;  This is not an exhaustive list; mostcommercial computer manufacturers offer a TP monitor product.andM;TP Monitor ArchitectureandM;The main function of a TP monitor is to coordinate the flow of transactionrequests between terminals or other devices and application programs that canprocess these requests.andP;  To accomplish this, the TP monitor imposes a certainstructure on the software components of a TP system and offers functions tosupport the activities of each component.andP;  In this section, TP monitorstructure is described.andP;  Later sections examine the support functions moredeeply.andM;The vast majority of TP applications are structured to perform the followingsteps for each terminal:andM;(1) Interact with the erminal user to collect the transaction's input,usually through forms and menus.andM;(2) Translate the transaction input into a standard-format request message.andM;(3) Start the transation.andM;(4) Examine the request's header to determine its type.andM;(5) Execute the request type's application program, which may in turn invokeDBMSs and other application programs.andM;(6) Commit the transaction after the application has finished.andM;(7) Send the transaction's output to the terminal.andM;All TP applications can be structured to follow this control flow.andP;  A TPmonitor divides an application into components that perform the above steps(see Figure 1):andM;* Message Manager (MM)--performs steps (1), (2), and (7).andM;* Request Control (RC)--performs steps (3), (4), and (6).andM;* Application Server (AS)--performs step (5), in collaboration with DBMSs.andM;A particular system typically has many instances of MMs, RCs, ASs, and DBMSs.andO;These instances follow a communication paradigm imposed by the TP monior: MMscommunicate with RCs, which communicate with ASs, which communicate with ASs,which communicate with DBMSs and with each other.andP;  This communicationparadigm is consistent with the flow of events in the seven-step procedure ofthe previous paragraph.andP;  By decomposing the application in this manner, theTP monitor can simplify application programming by mapping these componentsinto OS processes and by providing communications support between components.andO;It also provides system management operations to monitor and controlperformance, faults, and security.andM;Despite the importance of these system management operations, this articlecontains relatively little about system management, in the section entitled&quot;System Management and Recovery.&quot;andP;  Instead, this article will focus on thecomponents that directly affect the execution of each transaction--messagemanagement, request control, and application servers.andM;TP Monitor FunctionsandM;Message ManagerandM;A Message Manager (MM) must interact with a variety of terminal types tocollect input and display output.andP;  It performs four main functions: itformats requests, manages forms, validates input, displays output, andperforms user-oriented security checking.andP;  Each function is described in thefollowing paragraphs.andM;Since terminal technology changes frequently, today's TP systems have a mixof terminal types, such as character-at-a-time terminals, screen-at-a-time(i.e., block mode) terminals, and personal computers.andP;  There are manyindustry-specific variations of these devices, such as bar-code readers,automatic teller machines, and point-of-sale terminals.andP;  For the purposes ofthis article, &quot;terminal&quot; is used to describe all these devices.andM;To isolate Request Control (RC) from the diverse interfaces provided by thesedevices, an MM translates each input that asks to run a transaction into astandard-format request message or, simply, a request.andP;  RC can count onreceiving its input in standard format.andP;  This makes RC programs independentof terminal types: such terminal independence provided by MMs is akin to thedata independence provided by DBMSs, which insulate applications from thevariety of physical database formats through a standard database format.andM;The format of requests is defined by the TP monitor.andP;  It includes a standardheader, which is the same for all applications that use the TP monitor, and arequest body, which is defined by the application.andP;  The header may includethe terminal's address, the name of the user at that terminal, and the nameof the request type.andP;  This header format varies from one TP monitor to thenext.andP;  The request body includes the parameters to the transaction.andM;The forms manager is the component of an MM that is responsible fortranslating between terminal-specific format and standard request format.andO;Each form consists of a set of fields, each field ha a set ofcharacteristics, such as a label, a data type, and a representation on thephysical screen or window.andP;  The forms manager provides an editor for theapplication programmer to define and modify forms.andP;  The forms manager alsoprovides a complier, which translates a form definition into a transaltiontable and a record definition (see Figure 2).andP;  The translation table is thecompiled version of the form that is used by the forms manager's run-timesystem to translate between terminal-specific format and standard requestformat.andP;  The record definition is a high-level language declaration for theform's standard request format, suitable for including in an applicationprogram that uses the form.andM;Often the execution of a request produces output.andP;  The output may bedesplayed by the forms manager, or may be interpreted as a special devicecommand, for example, ask a teller machine to dispense cash.andM;AN MM is also responsible for validating input.andP;  It can check that each inputis of the proper type (e.g., no alphabetic characters in a numeric field) andthat it is in the allowable range of values (e.g., by a table lookup).andP;  Whileperforming data validation, an MM ordinarily may not read shared databasesthat are updated by transactions.andP;  This allows it to efficiently executeclose to the terminal and far from the shared database.andP;  However, it may usea local snapshot copy of such databases.andM;In an MM, the application programmer writes forms definitions and datavalidation routines.andP;  The TP monitor does the rest: it compiles formsdefinitions and does run-time translation of each form into a request.andM;In addition to request preprocessing, an MM usually performs some securityfunctions.andP;  It autheticates each user, by checking a password, and puts theuser's identifier in each request the user submits.andP;  It may also performaccess control, by only displaying menu entries that correspon to requesttypes that the user is authorized to access from the terminal he or she isusing.andP;  (Certain requests can only be issued from terminals in a guardedarea, such as a money transfer room.)andP;  Since the OS does not know aboutrequest types, and DBMSs typically do not know the terminal from whichrequests originate, this function must be performed in the TP monitor.andM;Request controlandM;Each request constructed by an MM is passed to an RC for processing.andP;  The RCis responsible for sending the request to an application server (AS) that canprocess the request.andP;  The application programmer only has to provide a tablethat relates each request type to the identifier of the AS that can processthat request type.andP;  The RC does the rest.andM;The RC looks in the request's header for the symbolic request type, and mapsit into the identifier of the appropriate AS.andP;  The RC then calls the AS thathas that identifier, passing parameters that it extracted from the request.andO;Usually, the RC is responsible for bracketing the translation, by callingStart-Transaction before invoking any AS, and calling End-Transaction orAbort-Transaction when the transaction is completed.andM;RC-to-AS Mapping.andP;  The mapping from symbolic request type to AS identifiershould be dynamic.andP;  This is helpful for fault tolerance, since it allows thesystem to quickly remap a request type to a different AS identifier if theoriginal AS fails.andP;  IT also allows the system manager to redistribute requesttypes to different ASs, e.g., for performance reasons.andM;A table that is local to the RC provides an easy way to implement thisdynamic mapping.andP;  If there is more than one copy of the RC, then each copymay have a different copy of this table, leading to a problem: If differentRCs control different request types, then a request might arrive at an RCthat cannot handle that request's type.andP;  There are two standard solutions:andM;* Every MM knows which RCs can handle each request type.andP;  Each MM is designedto send each request, R, to an RC that can handle R's request type.andM;* Every RC knows which RCs ccan handle each request type.andP;  An MM sends R toany RC, and that RC forward it, if necessary, to another RC that handles R'srequest type.andM;Some systems support a global name service [12].andP;  This service maps namesinto attribute-value pairs, and is accessible from any node.andP;  One can use aglobal name service to map request types into RC identifiers.andP;  Since the nameservice is globally accessible, either MMs or RCs can take responsibility forforwarding each request to the proper RC.andM;RC-to-AS Binding.andP;  To call an AS, an RC must use the AS's identifier to bindto that AS.andP;  The nature of this binding is determined by the OS andcommunications architecture.andP;  For example, if an RC and AS are bound in thesame address space, then an AS identifier could be an external reference thatis resolved by the linker.andP;  Alternatively, if an RC and AS execute indifferent address spaces that are bound through a communications session,then the AS identifier could be a network address that is used to create asession binding.andM;A global name service may be used to store the mapping from request typesinto AS identifiers.andP;  Since the mapping is globally accessible, ASs canaccess it directly, without using RCs as intermediaries.andP;  In this case, theTP monitor need not distinguish RCs from ASs.andP;  That is, the notion of RCdisappears.andM;However, even if the TP monitor does not distinguish RCs from ASs,applications usually retain the distinction.andP;  That is, some ASs map requesttypes into AS identifiers (i.e., they perform the RC function), and othersexecute a request type's application program.andP;  This structure tends tominimize the number of bindings, which is important for performance in adistributed system.andP;  Typically, each MM binds to one--or at most a few--ASsthat perform the RC function.andP;  And each AS that does not perform RC functionsonly binds to those that do.andP;  In the absence of this structure, all MMs wouldhave to bind to all ASs, and/or all ASs would have to bind to each other.andP;  Tominimize rebinding cost, these bindings are usually long-lived.andM;After an AS completes a call, it may return a result to the RC.andP;  The RCtypically returns this result to the appropriate MM.andP;  Therefore, the RC mustbe able to map each request back to the MM that sent it.andP;  For this reason,each request's header usually contains the identifier of the request'soriginating MM.andM;Application ServersandM;Each AS consists of one or more application program, which typically access ashared database.andP;  In addition to linking ASs with RCs, the TP monitor usuallyprovides ASs with access to the terminal that supplied each request.andP;  It mayalso compensate for certain OS limitations, in the areas of processmanagement and communication, which are discussed in the next section.andM;Process ManagementandM;One function of a TP monitor is to define a process management strategy forcreating and managing processes for MMs, RCs, and ASs.andP;  By a process, we meanthe OS abstraction consisting of an address space, processor state, and setof resources (e.g., a task in IBM MVS, or process in UNIX or VAX/VMS OSs).andO;There are several popular process management strategies, which depend onandM;(1) whether MMs, RCs, and ASs execute together in a single address space orseparately in different address spaces [i.e., client-server], andandM;(2) whether a process has one or morethan one thread of control (i.e.,andO;single-threaded vs.andP;  multi-threaded).andM;We treat each strategy in turn.andM;Single Address SpaceandM;Single-Threading.andP;  A simple process management strategy is to create oneprocess for each terminal.andP;  Each process executes and image (i.e., loadmodule) consisting of its MM, RCs, and ASs linked together.andP;  Thus, a standardintraprocess procedure call can be used by its MM to call an RC, and by an RCto call an AS.andP;  That is, the process executes a sequential program of theform shown in Figure 3.andP;  This processper-terminal structure is commonly usedin time-sharing systems, where each terminal is assigned a unique processwhen a user logs into that terminal.andP;  It is used in small TP systems too.andO;Unfortunately, it does not scale well; when a system has a large number ofterminals, it is inefficient to have a process for each terminal.andP;  Theinefficiency arises from OS overhead: lengthy searches of the OS's table ofprocess descriptors; too much processor context switching between processes(i.e., swapping the contents of registers, address translation tables, andprocessor cache memory); too much fixed memory per process; and the potentialfor too much paging I/O if processes are not fixed in memory.andP;  The problemmay be compounded in a distributed system, since a terminal may require aprocess on each system on which it executes transactions.andM;Another problem with the process-per-terminal approach is the inconveniencein controlling load.andP;  To reduce load, the TP monitor can deactivate terminalsby stopping the processes connected to those terminals.andP;  However, it cannoteasily lower the priority of specific request types, since the set of allprocesses would need to cooperate to achieve this effect.andM;Multithreading.andP;  One can avoid the overhead of the process-per-terminalapproach by having a single process manage all terminals that are connectedto a node.andP;  Conceptually, each terminal has a private thread of control, butshares its address space with all other threads in that process.andP;  Theseprivate threads can be implemented by the application.andP;  More often, they areimplemented by the TP monitor or OS.andP;  Each thread in a process must have aprivate data area for local variables.andP;  If implemented by the OS, this dataarea normally consists of a private stack and register save area; ifimplemented by the TP monitor, it consists of a local process memory region,indexed by thread.andP;  Thus, the system switches its attention between terminalsby switching threads.andP;  By contrast, in the process-per-terminal model, thesystem switches between terminals by switching processes.andP;  Switching threadsis more efficient than switchig processes, because switching threads does notinvolve replacing address translation tables or processor cache memory.andM;The term service call is used to denote a call to an OS service, includingcommunications and database functions implemented in the OS.andP;  Two aspects ofservice calls require special treatment when implementing threads: contextswitching and synchrony.andM;First, if a service call cannot complete its work immediately, it will changethe processor context, so that another program can execute until the servicecall completes.andP;  For example, it may change the program counter, a registerpointing to a stack, or a pointer to an address translation table.andP;  In thiscase, the processor context of the calling program must be restored on thereturn from the call.andM;Due to the possibility of context switching, each service call must identifythe thread that issued the call, so the call can return to the proper thread.andO;If threads are implemented by the OS, then the OS can implicitly attach athread identifier.andP;  If threads are implemented by the TP monitor, the OSregards the service call as a call from a process, not from a thread.andP;  So thethread identifier must be an explicit parameter to the service call.andP;  Whenthe OS returns to the process after a call, the TP monitor code in theprocess passes the return to the proper thread.andM;Second, a service call may be synchronous, meaning that the caller stopsexecuting until the callee finishes and returns to the caller.andP;  A synchronousservice call may become blocked, because it is dealing with an external agentthat will not immediately perform the operation (for example, a call to aDBMS, which can block while waiting for a disk I/O, or a call to receive amessage, which can block until the message arrives).andP;  A synchronous call by athread may cause the thread's whole process (including other threads) toblock, even though only one thread is waiting for the result of the call.andO;There are two solutions to this problem:andM;(1) Implement every service with an asynchronous interface, so the caller isnot blocked.andP;  The caller receives the return as a message or softwareinterrupt (e.g., a signal in UNIX OSs, or asynchronous system trap in the VMSOS).andM;(2) Implement multithreaded processes in the OS.andP;  The OS knows the identityof the thread that makes each synchronous call, so it can block that threadwithout blocking other threads in the same process.andM;In the above [2] is a more general solution than [1], because it solves theproblem for all services.andP;  InandM;(1), a special asynchronous interface for each service type is required.andM;On shared-memory multiprocessors, OS-based multithreading has anotheradvantage: different threads of a process can execute concurrently ondifferent processors.andP;  If multithreading is implemented by the TP monitor,one must create multiple (perhaps multithreaded) processes to get thisphysical concurrency.andM;Multithreaded processes have two main disadvantages: First, they have weakerprotection than single-threaded processes, in that all threads can access theprocesses' memory.andP;  This problem can be mitigated by using a stack-basedmachine architecture (where each thread has a private stack for local data)and by using a strongly typed programming language (to ensure that programsdo not make stray memory references).andP;  Second, the system now has two levelsof scheduling--processes and threads within processes.andP;  This makes itdifficult to adjust scheduling parameters to obtain the desired relativepriority of threads in different processes.andM;On balance, the benefits of threads outweigh the disadvantages in mostsystems.andP;  Nearly all TP monitors that use a single address space also usemultithreading (e.g., IBM's CICS and Digital's DECintact TP monitors).andM;Inter-Process CommunicationandM;For efficiency reasons, TP systems are often configured as distributedsystems.andP;  For example, a TP system may have a large,geographically-distributed terminal network.andP;  Since there is generally morecommunication between a terminal and its MM than between an MM and RCs, it isefficient to put each MM in a computer near the terminals it serves; if the&quot;terminal&quot; is a workstation, it probably has its own MM.andP;  However, since RCsand ASs are shared across the entire network, these functions may be remotefrom the MMs.andM;A TP system may also be distributed for manageability reasons.andP;  For example,a TP system may include several subsystems, each dedicated to request typesthat are relevant to one division of an enterprise.andP;  A large bnak may haveseparate TP systems to process checking accounts, credit cards, loans, andtrust accounts.andP;  In such a system, a request that originates in one divisionmay require running ASs in another division.andP;  For example, a request to pay acredit card bill from a checking account may require running an AS on thecredit card division's system and an AS on the retail banking division'ssystem.andM;These examples--and distributed computing environments in general--pose aproblem of interprocess communication: How does a program in one addressspace (i.e., process) call aprogram in another address space (i.e., process)?andM;Message Passing.andP;  One popular approach is connection-oriented messagepassing.andP;  A process establishes a connection (i.e., a session or virtualcircuit) with another process, after which the processes can exchangemessages.andM;Thsi approach is used in IBM's CICS TP monitor, using SNA LU6.2 $(10$).andP;  Aprocess establishes a half-duplex connection, called a conversation, with aprocess on another system.andP;  Each process can send and receive messages overthe conversation.andP;  To control the half-duplex connection, when a process isfinished sending, it explicitly tells the other process that the latter maynow send.andM;Conversations are intended to be long-lived, spanning many transactions.andO;Consider a set of processes where there is a path of conversations connectingevery pair of processes in the set.andP;  All processes in the set are impolicitlyexecutingt within the same transaction.andP;  Each process independently tellswhen it is finished with its part of the transaction; at this point, theprocess is blocked.andP;  When all of the processes say that they are done withthe transaction, the transaction commits.andP;  Then all of the processesconcurrently begin executing the next transaction.andP;  Thhis programming modelis sometimes called chained transactions, because each process beginsexecuting a new transaction when the previous transaction commits.andM;The main benefit of this approach is that it imposes little structure onmessage exchanges.andP;  For example, programs can communicate using arequest-reply paradigm, or they can pass long data streams.andP;  The LU6.2version of this approach has another benefit; it exploits the half-duplexcommunication style to minimize the number of messages required to controlthis distributed execution.andM;Using connection-oriented message passing, programs in different processescommunicate using a different mechanism (message passing) than within asingle process (local procedure calls).andP;  There are two main problems withthis approach.andP;  First, it complicates the application-programming interface,since the application programmers uses different syntax and semantics forcalling local procedures and remote processes.andP;  Second, it makes applicationprograms dependent on the assignment of functions to nodes of the distributedsystem.andP;  For example, if an RC was programmed to call an AS in the sameaddress space, and the AS is moved to a different node, then the RC must be modified to call the remote AS.andM;Remote Procedure Call.andP;  The disparity between intraprocess and interprocesscommunication can be hidden by making interprocess message passing look likeprocedure calls to the application programmer.andP;  This avoids modifyingprograms whenever a process is moved from one machine to another.andP;  It alsoavoids certain common programming errors.andP;  For example, suppose a clientsends a message to a server, but the client forgets to wait for the reply.andO;Replies accumulate until an overflow condition arises.andP;  Or, suppose a clientgives up waiting for a reply from a server, deciding that the server must bedead.andP;  If the server is merely very slow and ultimately does reply, theclient may no longer be able to cope with that reply and may malfunction[13].andM;Remote procedure call (RPC) is a mechanism, implemented by the OS or TPmonitor, that makes message passing look like procedure calls [7].andP;  In anRPC, a client process issues what looks like a local (synchronous) procedurecall to a server process.andP;  The RPC mechanism translates this synchronous callinto an asynchronous message from the client to the server, and then waitsfor the reply.andP;  The client cannot forget to wait for the reply, because theRPC mechanism is guaranteed to do so.andP;  The client's RPC mechanism can give upwaiting and return with an error message to the client.andP;  In this case, itwill throw away any replies that arrive late.andM;When an RPC message arrives at a server, the server allocates a thread forthis call, either by creating a new thread or by reusing an idle one.andP;  Or, ifno threads are available (e.g., the server is single-threaded and isexecuting another call), the message waits.andP;  After the server executes thecall, a return message is sent to the client and the thread either becomesidle or is destroyed.andM;Some RPC designs hide some differences between the programming languages ofthe client and server.andP;  The client and server each have a stub program forthe server.andP;  The client's stub translates the parameters into a standard,machine-independent format.andP;  The server's stub translates the parameters fromthe standard format into the server's language-specific format.andM;The request-reply nature of RPC communication can be inconvenient if a serverhas a lot of data to send back to its client.andP;  It could send it back in onebig package, but this prevents the client from working on the result clientfrom whole result is available.andP;  It could require the client to ask for thedata a chunk-at-a-time, but this requires a roundtrip pair of request-replymessages from client to server for each chunk.andP;  Or, a special mechanism canbe designed to stream data back to the client a chunk-at-a-time, without anacknowledgement message for each chunk [14].andM;Client-Server in TP MonitorsandM;An RPC system manages the problem of locating and invoking remote servers.andO;To fully exploit this capability, one should separate different functionsinto different processes.andP;  In a TP monitor, this suggests thatandM;* MMs, RCs, and ASs execute in different processes;andM;* Each MM process (a client) calls RC processes (acting as servers); andandM;* Each RC or AS process (acting as a client) calls AS processes (acting asservers).andM;Some processes act as both client and server--an RC process is a client withrespect to AS processes, and a server with respect to MM processes.andM;The client-server model is used in Digital's ACMS and Tandem's Pathway TPmonitors.andP;  In the ACMS monitor, MMs, RCs, and ASs execute in separateprocesses.andP;  In the Pathway monitor, there are two types of processes:requesters, which execute MM and RC functions, and servers, which are ASs.andO;Both systems support RPC for interprocess communication.andM;Performance.andP;  The main benefits of the client-server model are ease ofreconfiguration and ease of programming.andP;  The main disadvantage of theclient-server model is the expense of message-based communication.andP;  In thesingle-address-space model, MMs, RCs, and ASs call one another using a localprocedure call--typically costing under 50 instructions.andP;  In theclient-server model, these calls are implemented by messages--typicallycosting 1000 to 10,000 instructions.andP;  Recent research has shown that thisperformance penalty can be greatly reduced [6, 18].andP;  Another overhead in theclient-server model is its generous use of processes, which leads to morecontext-switching overhead than a single-address-space model.andP;  This overheadcan be minimized using multithreading.andM;Multithreading.andP;  To limit the number of processes, MMs, RCs, and/or ASs maybe multithreaded.andP;  Multithreading may be implemented by the TP monitor or theOS.andP;  If the TP monitor implements multithreading, then the issue ofsynchronous service calls must be handled.andP;  In the single-address-spacemodel, this problem is usually solved by intercepting synchronous servicecalls in the TP monitor.andP;  In the client-server model, the problem is oftensolved by restricting the use of multithreading and synchronous calls, asfollows.andM;First, the TP monitor implements multithreading for MM and RC processes, butdoes not allow MM and RC processes to call DBMSs.andP;  Thus, the TP monitor doesnot need to intercept DBMS calls in MMs and RCs.andP;  But it still has tointercept receive-message calls by MMs and RCs, to make them asynchronous.andM;Second, TP monitor requires AS processes to be single-threaded.andP;  Thus, an ASprocess canmake a synchronous service call that blocks.andP;  The process is putto sleep, but since there are no other threads in the process, this isacceptable.andP;  This avoids having to implement either an asynchronous interfaceto all service calls or multithreading in the OS.andM;If an AS can only be single-threaded, then it may become a bottleneck.andP;  Theobvious solution is to have many processes running the same AS program.andP;  Butnow there is a communications problem.andP;  When an RC wants to call an AS, towhich AS process should it direct the call?andP;  What if it sends the call to anAS that is busy with another request?andP;  Since the AS is single-threaded, therequest will wait until the callee finishes and asks for another inputmessage.andP;  This is undesirable if other AS processes are idle at that time.andM;To avoid this problem, some TP monitors support an abstraction called ASclasses.andP;  An AS class is a set of AS processes that execute the same ASprogram.andP;  A process can send a message to an AS class, instead of directingit to a particular AS process.andM;The input message queue for an AS class is shared by all AS processes.andP;  If aprocess sends a message to an AS class, that message will be processedimmediately if any AS process is idle.andP;  AS classes are supported by Digital'sACMS and Tandem's Pathway TP monitors.andM;The issues of synchronous service calls and AS classes arise becausemultithreading is implemented by the TP monitor, not the OS.andP;  If the OSimplements multithreaded processes, then the problems disappear.andP;  When athread makes such a synchronous call, the calling thread can block, withoutaffecting other threads in the process.andP;  In addition, there is no need for ASclasses.andP;  Since a thread can send a message to a process, not just to anotherthread, and since all threads in the process can share the same input messagequeue, an AS process functions just like an AS class.andP;  However, amultithreaded AS process does have weaker protection between threads than ASclasses, where the AS processes have independent address spaces.andM;A system management benefit of the client-server model arises from the use ofAS classes or multi-threaded ASs: A system manager can easily control therelative speeds of different request types.andP;  When AS classes are used, thespeed of that AS is controlled by the number of processes in the AS class.andO;Allocating more processes in an AS class increases the fraction of theprocessor that is dedicated to that class' AS type.andP;  Multithreaded ASprocesses achieve the same effect, whether threads are implemented by the Osor TP monitor.andM;QueuingandM;Another communication problem arises from the fact that clients and serverscan fail independently.andP;  If possible, the failure of a server should notprevent its clients from making progress.andP;  TP monitors help clients cope withserver failures by providing queued communications.andM;It is sometimes impossible to run a transaction as soon as a user enters arequest.andP;  For example, consider a distributed TP system in which an MM sendsmessages to a remote RC.andP;  If the RC's process is unavailable, due to afailure or overload, then the MM cannot forward the requests that itreceives.andP;  The MM can either block until the RC is again available, or it cansave the requests and forward them when the RC is available.andM;In many applications, it is unnecessary to run a transaction as soon as auser enters a request.andP;  For example, a request by a clerk to ship an ordercan be buffered for several hours, with negligible loss of service to thecustomer.andP;  As long as the request is not lost, and the transaction eventuallyruns, the customer is satisfied.andM;In some applications, it is convenient and cost effective to buffer requestsfor long periods, and then process the requests as a batch.andP;  For example,retail system can gather information about sales from electronic cashregisters during the day, and then run a batch that updates its inventorytotals overnight.andP;  Batch processing can often be made more efficient thanon-line TP, and is therefore preferable when fast response time isunimportant.andM;In each of these cases, the request produced by an MM may be held for awhilebefore it is sent to the appropriate RC.andP;  Since these cases arise frequentlyin TP, most TP monitors offer special facilities to manage queues ofrequests.andP;  Each queue has a name and is accessible to MMs and RCs.andP;  MMsenqueue requests.andP;  RCs dequeue requests and process transactions on theirbehalf.andM;Although a user may not need fast response time, he or she may want thesystem to guarantee that a request will not be lost (e.g., the shippingexample above).andP;  For this reason, it is important that there be an option tostore requests in stable storage, such as disk, before acknowledging receiptof the request to the user.andP;  In this case, the MM's processing of a requestis essentially a transaction, which must be committed before acknowledgingthat it is done.andM;Additional reliability is attained if each transaction that executes arequest dequeues the request within its transaction.andP;  If the transactionaborts, the dequeue operation is undone.andP;  Thus, the request is automaticallyrestarted by the next RC that dequeues the request.andP;  If the queue is in mainmemory only, then this approach guards against losing the request due to atransaction abort.andP;  If the queue is stable, it also guards the requestagainst losing the contents of main memory (e.g., if the OS crashes).andP;  Thisstyle of operation is typical in the IMS/DC and DECintact RP monitors.andP;  (2)andM;A similar effect for guarding against system failures can be obtained if theTP monitor logs all messages from an MM to an RC (an option in CICS).andP;  In astable database, the application squirrels away a description of eachtransaction it executes.andP;  If the system fails and subsequently recovers, theapplication's recovery procedures can compare the message logs to informationabout committed transactions that it saved before the failure, so it knowswhich requests were submitted before the failure but did not execute.andM;A transaction can enqueue output that is destined for a user.andP;  But to guardagainst losing the output in the event of failure, the MM transaction thatdequeues the output must not commit until it is sure that the user actuallysaw it.andP;  Again, a message log can substitute for a queue.andM;Some requests require the execution of more than one transaction.andP;  To avoidlosing information if the system fails after some but not all of a request'stransactions have executed, each transaction can pass its resuts to the nexttransaction via a queue.andP;  Technical details of this approach appear in [5].andM;Queuing systems usually incorporate scheduling features.andP;  For example, eachrequest may be assigned a priority by the MM that enqueues it.andP;  An RC canthen dequeue requests based on that priority, or perhaps based on otherfields in the request.andP;  An application can explicitly scan the contents ofrequest queues, to find especially important requests that should beexpedited.andP;  Or the TP monitor may offer a scheduler that sits between a queueand RCs and explicitly assigns requests to RCs based on the schedulingcriteria.andM;Given that requests are buffered in queues, the length of queues is a naturalmeasure of system backlog, which can be made available to the system manager.andM;The main disadvantage of request queues is performance.andP;  It generally is moreexpensive for an MM to enqueue a request and subsequently for an RC todequeue it, than simply to send the request directly from MM to RC.andM;Most TP monitors offer queuing services.andP;  In some TP monitors it is anoptional feature, as in IBM's CICS and Digital's ACMS TP monitors.andP;  In otherTP monitors, it is the main communication technique, as in IBM's IMS/DC andDigital's DECintact TP monitors.andM;System ManagementandM;and RecoveryandM;System managers require on-line tools to monitor and control all aspects of arunning TP system, including performance, failures and security.andP;  These toolsgather data and adjust parameters in many component subsystems.andP;  For ease ofuse, the monitor and control functions of subsystems should bewell-integrated into a seamless interface.andP;  This is especially important fora large distributed system, in which complexity and distributed control makeit quite difficult to manage.andP;  Personal computers have compounded thisproblem enormously, since each desktop machine is now an independent node,with a user who wants to treat it as an appliance.andP;  System managers also needoff-line tools to test early versions of applications, and to analyze dataproduced by monitoring tools (e.g., for capacity planning and to analyzefailures and security breaches).andM;A TP monitor provides system management operations to manage the set of MM,RC, and AS processes.andP;  To do this, the TP monitor maintains a description ofthe configuration of processes in the system.andP;  This description includes theterminals and forms attached to each MM, the security characteristics ofusers, the set of request types routed by each RC, the set of programsmanaged by each AS, etc.andP;  In a distributed system, it also includes the namesof the nodes on which each process executes.andP;  A system manager can create anddestroy processes, move them between nodes, and alter the set of forms andprograms used by each process.andM;The RP monitor can measure the performance of the running system, and offerthis information to the system manager in application-orientedterms--transaction rates, response times, etc.andP;  The system manager can usethis information to adjust the configuration, to improve response time andthroughput.andM;The TP monitor's system management knowledge of the MM-RC-AS configuration isuseful for managing failures.andP;  If a node fails, the TP monitor can re-createthat node's MMs on another node that has access to the same set of terminals(e.g., one that is connected to the same local area network), and can createsessions between those terminals and the new MMs.andP;  It can also re-create thefailed node's RCs and ASs on another node that can load the appropriateprograms and has spare capacity to run the processes.andP;  Using itsconfiguration description, the TP monitor can perform these actions withouthuman intervention--either by using pre-defined backup configurations or byredesigning a feasible configuration at recovery time.andM;The transaction abstraction and queued requests help make recoverytransparent.andP;  When a process fails, transactions that were executing in thatprocess abort.andP;  After the TP monitor recovers the failed process (possibly onanother node), requests that correspond to the aborted transactionsautomatically restart, as described in the section entitled &quot;Queuing.&quot;andP;  Ifthis recovery is fast enough, the terminal user sees this failure merely asslow response time.andP;  Moreover, this recovery is accomplished almost entirelyby the RP monitor and transaction mechanisms, with little or no applicationprogramming.andM;The TP monitor can also perform system management functions related toaccounting, security, and capacity planning.andM;Future of TP MonitorsandM;In this article, it was shown that TP monitors have evolved to solvedistributed computing problems that are not solved by the underlying OS,DBMS, and netwrok.andP;  In particular, they support multithreaded processes,message routing, queuing, and system management and recovery.andP;  Sometimes,they support the transaction abstraction (e.g., the CICS monitor supportstwo-phase commit).andM;Many TP Monitor functions are starting to be found in OSs and DBMSs, via nameservers and data dictionaries, remote procedure call systems, and OS- orDBMS-supported transactions (i.e., two-phase commit).andP;  As such OS and DBMSfacilities become popular, the need for these TP monitor functions maydiminish.andP;  In response to this trend, we can expect TP monitor vendors tooffer higher functionality versions of these facilities, to maintain demand.andM;On epositive effect of putting TP monitor facilities into the OS is that allprogrammers will be able to program using transactions--not just thoseworking in an environment controlled by a TP monitor.andP;  Just as today'sprogrammer assumes that the computing environment includes processes, memorymanagement, and files, tomorrow's programmer will assume it includestransaction management and queue management.andP;  This will simplify thedevelopment of many reliable, distributed applications--not just those thatfit the traditional TP mold.andM;The need for TP monitors is likely to increase in the area of systemmanagement.andP;  With the proliferation of powerful workstations and servers, thecomplexity of the computing environment is quickly outstripping the abilityof system managers to control it.andP;  Since TP monitors are already providingmany of these management functions today, they are well positioned to fillthis rapidly increasing requirement.andM;(1) For the purposes of this article, &quot;database management system&quot; is used inits broadest sense, covering any manager of shared data, including block-andrecord-oriented file systems.andM;(2) Notice that this approach usually, requires two-phase commit, since thetransaction accesses two DBMSs--the queue manager and ordinary DBMSs.andO;Two-phase commit is avoidable if the queue manager and DBMSs share a commonrecovery log.andM;ReferencesandM;[1] Acker, R.D., and P.H.andP;  Seaman.andP;  Modeling distributed processing acrossmultiple CICS/VS sites.andP;  IBM Syst.andP;  J. 21, 4 (1982), 471-489.andM;[2] Anderson, K.J.andP;  Bucket brigade computing.andP;  UNIX Rev 8, 3 (Aug.andP;  1985),58-64.andM;[3] Anon.andP;  et al.andP;  A measure of transaction processing power.andP;  Datamation 31,7 (Apr.andP;  1985), 113-118.andM;[4] Bernstein, P.A., Hadzilacos, V., and Goodman, N. Concurrency Control andRecovery in Database Systems.andP;  Addison-Wesley, Reading, Mass., 1987.andM;[5] Bernstein, P.A., Hsu, M., and Mann, B. Implementing recoverable requestsusing queues.andP;  In Proceedings of the 199- ACM SIGMOD Conference on Managementof Data (May 1990), pp.andP;  112-122.andM;[6] Bershad, B., Anderson, T., Lazowska, E., and Levy, H. Light-weight remoteprocedure call.andP;  In Proceedings of the Twelfth ACM Sympossium on OSPrinciples.andP;  (December, 1989), pp.andP;  102-113.andM;[7] Birrell, A.D., and Nelson, B.J.andP;  Implementing remote procedure calls.andO;ACM Trans.andP;  Comput.andP;  Sys 2, 1 (Feb.andP;  1984), 39-59.andM;[8] Digital Equipment Corp. DECIntact Transaction Processing Ssytem:application Programming Guide.andP;  Order number AA-KZ03B-TE, Maynard, Mass.,andO;1989.andM;[9] Digital Equipment Corp. VAX ACMS Guide to Transaction ProcessingProgramming.andP;  Order number AA-N691E-TE, Maynard, Mass., 1989.andM;[10] Dequesne, W. LU6.2 as a network standard for transaction processing.andP;  InHigh Performance Transaction Systems, D. Gawlick, M. Haynie, A. Reuter Eds.,andO;Springer-Verlag, New York, 1989, 20-37.andM;[11] International Business Machines.andP;  CICS/OS/VS IntercomminicationsFacilities Guide, Form SC33-0230, White Plains, New York, 1986.andM;[12] Lampson, B. Designing a global name service.andP;  In Proceedings of theFifth ACM Symposium on Principles of Distributed Computing.andP;  (Aug., 1986),ACM, NY, pp.andP;  1-10.andM;[13] Liskov, B.H., and Herlihy, M.P.andP;  Issues in process and communicationstructure for distributed programs.andP;  In Proceedings of the Third Symposium onReliability in Distributed Software and Database Systems (October, 1983) IEEEComputer Society Press.andP;  pp.andP;  123-132.andM;[14] Liskov, B., and Shrira, L. Promises: Linguistic support for efficientasynchronous procedure calls in distributed systems.andP;  ACM SIGPLAN '88Conference on Programming Language Design and Implementation (June, 1988).andM;[15] McGee, W.C.andP;  The information management system IMS/VS, Part V:Transaction processing facilities, IBM Syst.andP;  J. 16, 2 (1977), 148-168.andM;[16] Pacifico, A. CICS/VS Command Level with ANS Cobol Examples.andP;  VanNostrand Reinhold Co., New York, 1982.andM;[17] Serlin, O. Fault-tolerant systems in commercial applications.andP;  IEEEComput.andP;  15, 8 (Aug.andP;  1984), 19-30.andM;[18] Schroeder, M. and Burrows, M.andP;  Performance Performance of Firefly RPC.andO;In Proceedings of the Twelfth ACM Symposium on OS Principles, (December,1989), pp.andP;  83-90.andM;[19] Seiwiorek, D.P.andP;  Architecture of fault-rolerant computers.andP;  IEEE Comput.andO;15, 8 (Aug.andP;  1984), 9-18.andM;[20] Siwiec, J.E.andP;  A High-Performance DB/DC System.andP;  IBM Syst.andP;  J. 16, 2(1977), 169-195.andM;[21] Tandem Computers Inc.andP;  An Introduction to Pathway, Part: T82339, 1985,Cupertino, CA.andM;[22] Wallance, J.J., and Barner, W.W.andP;  Designing for Ultrahigh Availability:The Unix RTR operating system.andP;  IEEE Comput.andP;  15, 8 (Aug.andP;  1984), 31-39.andM;[23] Wipfler, A.J.andP;  CICS Applications Development and Programming.andO;Macmillan, New York, 1987.andM;[24] Wipfler, A.J.andP;  Distributed Processing in the CICS Environment.andO;McGraw-Hill, New York, 1989.andM;PHILIP A. BERNSTEIN is a member of the technical staff at Digital EquipmentCorporation's Cambridge Research Laboratory, and is an architect of Digital'stransaction processing prodcuts.andP;  Author's Present Address: Digital EquipmentCorporation, Once Kendall Square--Building 700, Cambridge, MA 02139.andO;Internet: pbernstein@crl.dec.com.andO;</TEXT></DOC>