<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-537-106  </DOCNO><DOCID>07 537 106.andM;</DOCID><JOURNAL>AI Expert  August 1989 v4 n8 p15(5)* Full Text COPYRIGHT Miller Freeman Publications 1989.andM;</JOURNAL><TITLE>The power of LISP for C programmers. (AI Apprentice) (technical)</TITLE><AUTHOR>Rothrock, Michael E.andM;</AUTHOR><SUMMARY>LISP stands for list processing.andP;  LISP has powers that make it agreat language for certain types of problem-solving.andP;  Basiclist-processing methods used in the C language are discussed.andO;These can be adapted to other high-level programming languages aswell as assembly language.andP;  A top-down approach is applied to areal-world programming problem.andP;  It uses corresponding LISPfunctions to allow those familiar with LISP to see theimplications for C.andM;</SUMMARY><DESCRIPT>Topic:     C Programming LanguageLISPList Processing LanguagesTutorialAssembly Language.andO;Feature:   illustrationprogramchart.andO;Caption:   Linked-list structure. (program)approach to linked lists. (chart)Efficient sort program. (program)andM;</DESCRIPT><TEXT>The Power of LISP for C ProgrammersandM;What's all this list processing stuff about anyway?andP;  Even if you're aprogrammer with no LISP experience, you probably know that LISP stands forlist processing.andP;  You probably use linked-list structures in your code fromtime to time and wonder what LISP can do that you can't.andP;  Like otherlanguages, LISP has unique properties that make it a powerful language forsolving certain types of problems.andP;  Unique language properties are oftenquite handy and an enterprising programmer will incorporate those propertiesinto another language.andM;The two best-known LISP properties are symbolic processing and listprocessing.andP;  Both concepts can be developed in other languages with a set ofgeneric functions or procedures that operate on appropriate data structuresand by developing a proper mental attitude concerning the abstraction.andM;In this column we'll address generic list-processing procedures in C.andP;  Thesame concepts can be adapted for other high-level languages and assemblylanguage.andM;Most C programmers have used linked-list structures such as the one inListing 1.andP;  In this case, the first item in the structure is a link pointerto the next structure, and the rest of the structure is a place to storedata.andP;  This, of course, is a simple example.andP;  Real-world programmingrequirements usually result in more complex data structures for keeping trackof things like airline reservations, satellite ephemeries, journal entries,and so on.andP;  Lists are usually built from these structures (Figure 1).andP;  Listmaintenance procedures can be developed to add, delete, and sort list items,among other things.andP;  Essentially, by doing so we are processing a list.andP;  Thedifference is that these list procedures usually have a special purpose--forexample, we might write a procedure to add a new record to the head of thelist with code as shown in Listing 2.andP;  Unfortunately, such a procedure canonly be used to maintain lists composed of RECORD data structures.andP;  However,if we could develop a method of adding a record to a list regardless of therecord's structure, we could use this method for every list in our program.andO;LISP performs just this method; the notion of a list is embedded in thelanguage, as are generic procedures for list processing.andP;  Let's do the samefor C.andM;The trick is removing the links from the records.andP;  We need to define a datastructure to construct lists separate from the one that defines list items(Figure 2).andP;  A CONS is a data structure that can construct lists.andP;  Itconsists of two cells, called the car cell and the cdr (pronounced&quot;could-er&quot;) cell.andP;  A CONS is a simple structure, but don't let its simplicityfool you.andP;  A CONS is to symbolic processing what a binary digit is tonumerical processing.andP;  By combining CONS we can form lists, binary trees,hierarchies, and an infinite number of other useful data structures.andM;LIST PROCESSINGandM;Let's take a top-down approach.andP;  We'll start with a real-world programmingproblem and define the type and requirements of the list procedures we'llneed.andP;  We'll use the corresponding LISP functions so those of you who areLISPers will see the C implementations.andM;Listing 3 contains the entire source code for a sort program.andP;  The programreads lines of text from the standard input, sorts them, and writes them tothe standard output.andP;  It can be used on UNIX or MS-DOS systems as a filterprogram; in conjunction with other programs, pipes, and redirection, theprogram can perform more complex processing.andP;  Three special purposeprocedures exist in addition to main: getaline, output-list, andstring-compare.andP;  The other procedures perform general-purpose list processingand can be used for many programming problems.andP;  Once a library of suchprocedures has been built, a new application can be developed with minimaleffort.andM;The main procedure begins with a simple loop that reads each line of text andputs the text on a list called mylist, which is declared as a LIST type.andO;Think of a list as a new data abstraction available to you as a C programmer.andO;A list is a data entity to which you can add and recover items regardless oftype and do all kinds of things that seem reasonable to do with lists.andP;  Ourprogram includes a sampling of list-processing procedures needed to satisfyour program's requirements.andP;  In addition, you can write your own proceduresto do list processing.andP;  Your procedures should be generic and independent ofthe type of the items in the list.andP;  In fact, we can even make up a list thatcontains items of varying types.andP;  For example, we might store employeerecords, bowling-league scores, and parts lists in the same list.andP;  Yes, wecan even store lists in lists.andM;The program has a simple approach.andP;  We get text lines one at a time from thestandard input and push them onto a list.andP;  When we reach the end of file, thelist is sorted and output on the standard output.andP;  We can see from the codein main that a list can have properties similar to a stack, since we arepushing the lines of text onto mylist.andP;  But what are we pushing and wheredoes it go?andP;  Well, lp is the variable we are using and it is a POINTER.andO;Therefore, we must be pushing a POINTER onto the list.andM;getaline is a simple procedure that uses the library procedure fgets to reada string from the designated input stream (stdin in our case).andP;  The string isstored in a local buffer called line.andP;  fgets terminates when LINESIZE-1characters have been read or if a newline character is encountered, whichevercomes first.andP;  fgets will return a null if an end of file or an input erroroccurs.andM;Under normal circumstances, a null-terminated string will be stored in lineand getaline will then use the library routine strdup to duplicate the stringand return a POINTER to the duplicate.andP;  strdup uses the memory-allocationroutine malloc to get space to store the duplicate.andP;  If the system is out ofmemory, strdup will return null and getaline will exit with a returnparameter indicating the error.andP;  getaline returns a pointer to a string thathas been stored in memory allocated with malloc.andP;  When no more data isavailable, getaline will return null unless an error occurs, in which case itwill exit with an error indication.andP;  getaline's logic for handling abnormalconditions is adequate; however, production code might include somediagnostic messages to the standard error stream.andM;Let's return to the question of what gets stored on a list.andP;  We see from itsuse that the push procedure pushes a POINTER onto a list.andP;  In the example, lppoints to a type char.andP;  It should be obvious by now that the pointer does nothave to point to a char; it can point to any type of C item.andP;  push and otherlist procedures in our program work with lists similar to Figure 2.andP;  Withthis approach, we can build lists independent of items stored in the lists.andO;The list is made up of CONS linked together by their cdr cells.andP;  The car cellin the CONS points to the item stored in the list.andP;  To simplify the code, weuse typedefs to define the necessary data structures.andP;  Take a look at thedefinition of a CONS and a LIST.andM;LIST PROCEDURESandM;Listing 3 shows the push procedure we use to add an item to the head of alist.andP;  The item to be added is defined as a generic POINTER that points tovoid.andP;  push uses cons to allocate a new CONS and set its car and cdr cells.andO;push also updates the LIST variable so that it now points to the correct CONSat the head of the list.andP;  The LIST variable is passed to push by reference--aPOINTER to the LIST variable is passed so push can update it.andP;  Finally, pushreturns a POINTER to the head of the list as a convenience to the caller.andM;cons returns a POINTER to a CONS, but where did it get the CONS?andP;  In a LISPimplementation, CONS are managed as an allocated-memory resource.andP;  Atinitialization, they are collected together and put on a list called the freelist.andP;  Since LISP uses CONS liberally, they must be managed efficiently.andP;  Inaddition, CONS are frequently used to make temporary copies of lists that mayor may not be used.andP;  As a result, a method or recovering unused CONS andstoring them on the free list becomes necessary.andP;  We'll use malloc for thenecessary memory to hold a CONS.andP;  We'll let the system clean up after us byrestoring all dynamically allocated memory after exiting.andM;cons uses malloc and checks to see whether it granted our request.andP;  Sincethere is always a chance malloc cannot allocate memory, we must account forthis possibility.andP;  Again, production code should have better diagnostics forsuch error conditions.andM;pop is the opposite of push: it removes an item from a list.andP;  pop removes thefirst CONS from the list, retrieving its car cell and then releasing theCONS.andP;  pop, like push, must be passed a POINTER to a list rather than theLIST variable itself.andP;  That's because pop needs to modify the LIST variableto point to the second item in the list.andP;  pop uses procedure cpop to retrievethe first CONS and modify the LIST variable.andP;  cpop is very useful for walkingthrough a list without releasing the CONS structures that make up the list.andO;We use cpop in several places in our program.andM;outputlist is a procedure that iteratively removes each item from the listand sends it to the output stream (stdout in our case).andP;  However, outputlistmakes a copy of the LIST variable and leaves the original list intact.andO;outputlist is not a general list procedure, as it makes assumptions abouteach item in the list (it assumes each item is a string).andP;  Generic functionsin LISP will send the printed representation of an rgument to the outputstream regardless of the argument type.andM;These functions depend on a more elaborate strategy for data structure thanwe'll be using here.andP;  We'll have to accept the fact that our output functiononly works for lists of strings.andP;  outputlist uses the library procedurefputs, which outputs a string.andP;  outputlist takes a LIST as its firstargument.andP;  We supply this argument by using the sort procedure, which returnsa LIST.andP;  Syntactically, the fact that sort returns a POINTER to the sortedlist is convenient for calling outputlist.andM;LISP functions always return something.andP;  We follow this convention here evenin our outputlist procedure, allowing us to use constructs such as:andM;outputlist (sort(outputlist(item,andamp;1st), compare))))andM;Here the innermost procedure, push, returns a list used by the nextprocedure, outputlist, which in turn returns a list used by sort, whichreturns a list used by the outermost outputlist.andP;  Now one can see why LISPstands for &quot;Lots of Insidious Sets of Parentheses.&quot;andM;SORT TECHNIQUEandM;sort (Listing 3) is an example of a common LISP technique.andP;  Self-calling LISPfunctions are frequently encountered.andP;  This technique, called recursion, isavailable to programmers in most modern languages but is more common in LISP.andO;Many programming problems lend themselves to recursive solutions,particularly list processing.andP;  Recursion can be a very powerful technique,but it must be used cautiously since each recursive call uses stack space andpoorly contructed procedures can run through the stack.andP;  sort, however, is arecursive program that works very well.andM;sort checks to see if the list is empty or contains only one item.andP;  If so,its work is very easy.andP;  A list that is empty or contains only one item isalready sorted, so sort just returns the list itself.andP;  Otherwise, sort splitsthe list, sorts each half, and merges the results.andP;  It sorts each half withsort, a procedure that we know will sort a list.andP;  Fortunately, the problem,which the recursive call to sort must handle, has been reduced by half.andO;Eventually, the list will be either reduced to one, or empty, in which casethe first statement in sort will cause the recursion to terminate.andP;  Since theproblem is divided by half each time, the recursive depth is equal to thebase-2 logarithm of the size of the list.andP;  A list of 65536 items onlyrecurses to a depth of 16!andM;sort has a second parameter that is a procedure: the string-compare that waspassed by main.andP;  sort is designed to sort lists consisting of different typesof items.andP;  To determine the sorting order, one must be able to determine theordering sequence for the items.andP;  For strings, string-compare(a,b) returns avalue greater than zero if a comes before b in the collating order.andP;  To sorta list of items that are not strings, the user only needs to supply anappropriate compare procedure.andM;sort uses split to break the list into two halves.andP;  split walks two POINTERsthrough the list.andP;  The first POINTER is the variable 1st that was passed tosplit as a POINTER to the list head.andP;  Since C passes arguments by value, weare really working with a copy of the LIST variable and can use it as we wishwithout destroying the variable in the calling procedure.andP;  The secondPOINTER, tail, is stepped through the list twice as fast as the first.andP;  Whentail reaches the end of the list, the first pointer, 1st, will point to themidpoint of the list.andP;  The list is pruned at this point and a POINTER to thesecond half of the list is returned.andM;MERGE PROCEDUREandM;merge's strategy is to build a temporary list in reverse-sorted order bypushing CONS onto the list that are selectively popped off the appropriateinput list.andP;  The appropriate input list is chosen based on the comparefunction passed as a parameter to merge.andP;  When either of the input lists isexhausted, merge transfers the remaining items from the other list until it'sempty.andP;  Finally, merge returns the reverse of the temporary list.andP;  mergemanipulates CONS and thus uses cpop and cpush.andP;  This process is moreefficient than using pop and push since these procedures use free and mallocto release and allocate a CONS on each call.andM;reverse, a procedure that reverses a list, uses cpop and cpush to change theorder of the CONS in a list.andP;  Like merge, reverse pops from one list andpushes to another, yielding a list whose order is reversed from the original.andM;The sort program is written in ANSI-compatible C so it should be adaptable toany system.andP;  I have compiled it using Microsoft C 5.1 and a compact memorymodel, allowing access to all available memory under MS-DOS.andP;  Text files ofover 250K can be sorted using the program (the sort program provided withMS-DOS is limited to files of 64K or less).andP;  On an 8MHz 8086 system, sortinga file of 239K bytes took 40 seconds.andP;  On an 18 MHz 80386, the same sort tookless than five seconds.andP;  In general, the sort program is several times fasterthan the one provided with MS-DOS.andM;These procedures can be improved in many ways.andP;  For example, many text filescontain blank lines.andP;  Each time one of these lines l is read, space isallocated to hold the '\n' (newline) character as well as the terminating'\0' (null).andP;  This problem results in numerous cases of duplicate stringsthat contain identical data.andP;  The storage space for a string exceeds thatneeded for just the characters in a string since each memory fragmentrequired by the memory allocation scheme has overhead.andP;  If we could removethese duplicates, we could save data.andP;  For our purposes, the list, whichconsists of CONS with pointers to the strings, is not affected if the carcell of several CONS pont to the same string.andP;  We might employ a method ofsearching our list of existing strings to see if we have one that matches thenew one before allocating the memory for it.andP;  Another method is to recodesome of the simple procedures as macros.andP;  For example,l push on most systemsis faster and takes less space as a macro.andM;The sort program gives an indication of the power of list processing fornonLISP programmers.andP;  The small set of procedures shown here provides apowerful toolbox for solvingl the very large class of problems that lendsitself to list processing.andP;  Of course, many additions can be made to thistoolbox.andP;  Try it.andP;  Or better yet, if you don't already speak LISP, learnit--you'll be glad you did.andM;Michael E. Rothrock is the president of MERTEK Inc., a software consultingand sub-contracting firm in Deltona, Fla.andP;  He has over 20 years of experiencein the computer industry and has taught courses on LISP and C.andO;</TEXT></DOC>