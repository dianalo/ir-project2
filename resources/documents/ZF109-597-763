<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF109-597-763  </DOCNO><DOCID>09 597 763.andM;</DOCID><JOURNAL>Communications of the ACM  Nov 1990 v33 n11 p99(11)* Full Text COPYRIGHT Association for Computing Machinery 1990.andM;</JOURNAL><TITLE>An object-oriented relational database. (Computing Practices)</TITLE><AUTHOR>Premeriani, William J.; Blaha, Michael R.; Rumbaugh, James E.;andO;Varwig, Thomas A.andM;</AUTHOR><SUMMARY>Object-oriented (OO) design offers a uniform pattern for bothprogram code design and database design.andP;  Relational databasesthat can match real-world applications can be produced by OO datamodels.andP;  These data models also avoid normalization problems thatcan occur with relational database design.andP;  OO programminglanguages (OOPL) improve modularity, code reuse and codemaintenance.andP;  A technique for constructing an object-orienteddatabase management system (OO-DBMS) is to buffer the databasewith an object-oriented layer that retains relevant data inmemory.andP;  This layer has update and locking protocols built in.andO;Users can have quick access to data while storing it in a databasebetween executions.andP;  The database is hidden from applications bythe OO layer and applications are unaware that they are receivingdatabase services.andP;  The technique is described in detail.andM;</SUMMARY><DESCRIPT>Topic:     Relational data basesObject-oriented data basesObject-Oriented ProgrammingResearch and DevelopmentData Base DesignNew Technique.andO;Feature:   illustrationdiagram.andO;Caption:   OO-DBMS compile-time architecture. (diagram)OO-DBMS run-time architecture. (diagram)Buffering algorithm states. (diagram)andM;</DESCRIPT><NOTE>Only Text is presented here; see printed issues for graphics.andO;</NOTE><TEXT>An Object-Oriented Relational DatabaseandM;Many people recognize the short-comings of current database managementsystems (DBMS) [2, 9, 10] and conventional programming language [4, 8].andP;  DBMSand programming languages each provide a distinct viewpoint on data andapplications.andP;  The two viewpoints are not well integrated, although each hasits own strengths and weaknesses.andM;Relational DBMSs (RDBMSs) have a firm theoretical base and satisfy manyapplications.andP;  RDBMSs, however, lack important features needed for advancedapplications, such as abstract data types, complex integrity constraints, andversioning.andP;  Programming languages, such as Pascal and C++, provide abstractdata types, structured control constructs, and the ability to write complexalgorithms, but lack data persistence across executions and concurrent accessto data.andM;Objected-oriented (OO) design provides a uniform paradigm for both databasedesign and program code design.andP;  OO data models produce relational databasesthat match real-world applications and avoid the normalization problems oftenassociated with relational database design [3].andP;  OO programming languages(OOLPs) improve code reuse, code maintenance, and modularity [8].andM;We describe a technique for constructing an object-oriented DBMS (OO-DBMS)from existing technology and a small amount of human-written code.andP;  Theexisting technology is an RDBMS, an OOPL, and an object-oriented modelingtechnique.andP;  The basic idea is to buffer the database with an object-orientedlayer that keeps relevant data in memory.andP;  Locking and update protocols arebuilt into this layer.andP;  One achieves quick access to data, while storing itin a database between executions.andP;  The OO layer hides the database fromapplications; applications are unaware that they are receiving DBMS services.andO;The programmer sees an object-oriented language with certain predefinedoperations that allows objects to be retrieved from and stored in a databasebetween program executions.andM;The contribution of this article is the realization that a checkout mechanismcan be used to combine a RDBMS and OOPL into a robust and efficient OO-DBMS.andO;Our OO-DBMS is not a complete system.andP;  It lacks commonly expected featuressuch as extensible data types, management of behavior as well as data, andinheritance.andP;  Nevertheless, our approach to an OO-DBMS can satisfy manyapplications.andM;Related WorkandM;Two different areas of research relate to this article: OO-DBMS and databasecheckout/checkin.andM;OO-DBMSandM;The term &quot;OO-DBMS&quot; is not well defined; it means different things todifferent people.andP;  We will define OO-DBMS as the intersection of database andOOPL technology.andP;  The ambiguity in the term OO-DBMS is largely a result ofwhether one emphasizes the database or OOPL side.andM;OO-DBMSs are just starting to emerge in the commercial and research worlds.andO;The technology is immature, however, and suffers from lack of standards, poorperformance, and unresolved design issues, much the same as RDBMSs did adecade ago.andM;One of the most important features of an OO-DBMS is the implicit assumptionsthat (1) the system is oriented toward operations on individual objects and(2) the programmer can expect these to perform well.andP;  This is notable mainlybecause RDBMSs typically perform badly for single-object operations andnavigation between objects [6].andP;  There are two basic approaches to OO-DBMS:extending a relational DBMS and extending an OO programming language.andM;One can implement an OO-DBMS by extending an RDBMS.andP;  One extends therelational model with new data types, operators, and access methods.andP;  Anexplicit goal is to minimize changes to the relational model.andP;  This approachdefinitely adds to the functionality provided by an RDBMS.andP;  This type ofOO-DBMS integrates well with existing relational databases and provides forsmooth flow of data between engineering and business applications.andP;  Potentialdisadvantages are performance and robustness limitations.andP;  Even an augmentedRDBMS may not be capable of efficient operations on individual objects.andO;POSTGRES [23] and EXODUS [5] illustrate this approach.andM;Another approach to an OO-DBMS is extending an OOPL.andP;  Database functionality(persistence, authorization, concurrency) is provided as needed forindividual objects.andP;  An extended OOPL efficiently navigates individualobjects and has no inherent limits on functionality.andP;  An extended OOPL,however, must demonstrate reliable management of large quantities of data.andO;One must also develop a theoretical base as Codd provided for RDBMSs.andO;GemStone [17], Vbase [1], and ORION [14] adopt this approach.andM;At this point in time, it is not clear which approach is best.andP;  The choicewould seem to depend on the application.andP;  The OO-DBMS described in thisarticle adopts the viewpoint of extending an OOPL.andM;Our approach combines the maturity and robustness of the RDBMS with theperformance of the OO language in an open architecture that makes itconvenient to interface with other languages.andP;  Also, you can have both an OOand a relational interface to the same database.andP;  This allows you to write OOprograms that access data that already exists in an RDBMS as well as continueto use conventional RDBMSs access to the same data.andM;Database CheckoutandM;The notion of database checkout has been discussed [11, 15].andP;  A portion ofthe database is locked for exclusive use and copied into RAM.andP;  All subsequentread and write traffic is then executed against the RAM copy.andP;  Once work isfinished, the data is checked back into the database and made available forgeneral use.andP;  The checkout/checkin mechanism provides fast interactive accessand eliminates most locking overhead.andP;  We will refer to thischeckout/checking mechanism as database shadowing.andM;An ordinary database transaction locks its data for a few seconds.andP;  Incontrast, a checkout scheme may lock data for hours, days, and even weeks.andO;Thus the checkout mechanism provides support for long transactions.andP;  Longtransactions are often needed in a design environment.andM;Software SubsystemsandM;Our OO-DBMS is constructed from an object-oriented data modeling protocol, anRDBMS, and an OOPL.andP;  The exact subsystems chosen are not important for thesuccess of the shadowing technique, which we use to interface the programminglanguage to the database.andM;Object-Oriented ModelingandM;We have been using the Object Modeling Technique (OMT) [3, 16] for our work.andO;Any type of OO data model would suffice for our shadowing technique, but ourdiscussions will focus on the OMT for the sake of clarity.andP;  The OMT specifieslogical data structure, i.e., the classes of objects in the database andtheir relationships to one another.andP;  OMT diagrams are straightforward to mapinto RDBMS data definition (DDL) commands and OO code declarations.andP;  Figure 1shows a sample OMT diagram.andP;  Some aspects of OMT diagrams are discussed next.andM;A class describes a set of object instances with similar structure andbehavior.andP;  Each class has a name, a set of attributes (also called instancevariables, fields, or properties) that hold state values of the object, and aset of operations that an object is subject to.andP;  Object classes are denotedby boxes.andP;  The name of the class, its attributes, and its methods are drawnin the box.andP;  The listing of attributes and methods may be suppressed, as inFigure 1, depending on the level of detail desired.andM;A relationship connects two (or more) classes.andP;  An object class may inheritsome of its structure and behavior from a superclass; the subclass is arefinement of the superclass.andP;  This relationship among classes is calledgeneralization.andP;  Generalization (inheritance) is indicated by lines and atriangle fanning-out from the superclass to the subclasses.andM;An association relationship connects two or more object instances and isindicated by ordinary lines.andP;  Special symbols at the ends of an associationline indicate the multiplicity of the association (how many objects arerelated to a given object).andP;  A solid circle indicates zero or more; a hollowcircle means zero or one; a straight line without a terminator denotesexactly one.andM;Relational DBMS (RDBMS)andM;The RDBMS must provide that persistence, concurrency control, transactions,and a programming language interface.andP;  A query language or query-by-formscapability is unimportant for many engineering analysis problems becauseaccess to complex, structured data is controlled by the OO-DBMS front end.andO;The OO-DBMS described here hides the details of the RDBMS and removes some ofthe arbitrary restrictions.andP;  The RDBMS may be regarded as a lower-levelresource invisible to the end user.andM;Object-Oriented ProgrammingandM;Language (OOPL)andM;The object-oriented programming language must provide objects of differentclasses and the ability to send messages to objects to invoke aclass-dependent method.andP;  Inheritance of methods is not required by thealgorithm presented here, although any reasonable OO language will have it.andO;Each class describes a set of objects with identical structure.andP;  A class mapsinto an RDBMS table; each object instance maps into one row of a table.andP;  AnID generated by the OO-DBMS serves as the primary key of each object.andP;  Somerelationships map into RDBMS tables.andP;  The other relationship are stored inobject tables as buried pointers.andM;OO-DBMS SystemandM;ArchitectureandM;The programmer views the OO-DBMS as an object-oriented language withpersistence.andP;  The language includes specific operations about instances ofclasses and relationships.andP;  The OO-DBMS has both compile-time and run-timecomponents.andM;OO-DBMS Compile-timeandM;ArchitectureandM;Figure 2 summarizes OO-DBMS complie-time architecture.andP;  OMT diagrams andsupplemental files are provided as input.andP;  The supplemental files containminor details that OMT diagrams lack, such as attribute data types andpermissibility of nulls.andP;  This input is operated on by a conversion process.andO;The conversion output is a run-time programming interface (OO languagesubroutines and DDL commands to generate RDBMS tables.andM;Initially the conversion process was partially automated.andP;  We used AWK (1) tocreate the programming interface from a few hand-coded templates and manuallyprepared tables that described object classes and relationships.andP;  Then wegenerated RDBMS tables.andP;  We created one table for each object class.andP;  Forrelationships we had the choice of creating explicit tables or embeddingobject IDs as foreign keys.andP;  We indicated our decision on a case-by-casebasis by the presence or absence of a relationship name on the OMT diagrams.andO;Some decision factors were performance, prolieration of tables, and thelikelihood of future changes.andP;  Reference [3] contains more details on themapping process.andM;Later, we drew OMT diagrams with a general purpose graphics editor.andP;  Thegraphics editor produces graphics output in an ASCII markup language forwhich we have a BNF description.andP;  We used LEX and YACC (2) to compile the BNFdefinitions.andP;  Then we wrote software to recognize connectivity on OMTdiagrams and generate programming interface subroutines and DDL statements.andM;Our long-term solution to this issue is an OMT diagram editor.andP;  A customeditor provides active support for the semantics of OMT diagrams.andP;  The OMTeditor checks for duplicate names and simplifies the drawing of OMT diagrams.andM;OO-DBMS Run-timeandM;ArchitectureandM;Figure 3 summarizes OO-DBMS run-time architecture.andP;  There are two modes ofoperation: buffered and concurrent.andP;  To access buffered objects, theprogrammer first loads one or more sections into memory in a checkoutprotocol.andP;  Concurrent objects are accessed without using the protocol.andP;  Ineither case, the programmer deals with objects and relationships by callingthe appropriate interface functions.andP;  The mechanics of database interactionare hidden.andP;  In many cases, the operations are recorded directly into memory,and updating of the database is deferred.andP;  We define database shadowing asthis mode of transparent, buffered database access through operations onobjects and relationships.andM;The OO-DBMS programming interface is supported by internal shadowing routines(see section on OO-DBMS Programming Interface, later).andP;  These routines accessbuffered objects through an OO language.andP;  The shadowing routines access therelational database through the RDBMS programming interface (usually cursorson tables).andM;Key Design CriteriaandM;Performance was our most important design criterion for the OO-DBMS.andP;  Theshadowing mechanism improves interactive performance by using the OO languageto search memory and by deferring database writes.andP;  Most read operations canbe performed without accessing the database.andP;  The OO-DBMS eliminatesredundant database writes.andP;  For example, an object that is inserted and thendeleted requires no database activity.andP;  The shadowing mechanisms interceptsintermediate activity and only applies the net result to the database.andP;  Theinitial delay upon loading sections into memory was tolerable for ourpurposes.andM;Considerable elision is expected under normal application usage.andP;  In atypical session, a user will concentrate on a few areas of a design makingrepeated revisions of the same object before committing the results to thedatabase.andM;Another design goal was to increase programmer productivity.andP;  The OO-DBMSeases the burden of using a database.andP;  To a large extent the programmer canthink in terms of the OO language and forget about database interfacedetails.andP;  OO languages also provide robust libraries of tested code andfacilitate code reuse.andM;The OO-DBMS reduces programming errors since the programmer does not ecomeconfused by the mismatch between programming languages and data-baselanguages.andP;  Instead of using linked lists, trees, and hash tables, oneoperates on objects and relationships.andP;  Objects and relationships provide asimple, uniform programming paradigm.andM;Extensibility was another design criteria.andP;  Additional functions were addedas the need arose, and future additions are expected.andP;  For example, we planto incorporate propagation of operations among objects [20].andM;Key Design DecisionsandM;Concurrent versus bufferedandM;accessandM;The OO-DBMS supports two types of database access-concurrent and buffered.andO;Concurrent data has global scope and is visible to all users.andP;  Concurrentdata is accessed directly from the database and locked for the shortestpossible amount of time.andP;  System data for section (discussed later) is anexample of concurrent data.andP;  In contrast, buffered data is private to asingle user and is locked by a user for the duration of an interactivesession.andP;  Buffered data is loaded into memory, operated upon, and then savedback to the database.andP;  Buffering reduces database traffic and improvesapplication performance.andM;Each database table is either concurrent or buffered.andP;  Both categories lookalike to the programmer; both categories support the same operations and havethe same syntax.andP;  The OO-DBMS keeps track of which objects are buffered andwhich are concurrent.andP;  The only difference between the two categories is thetime at which changes are committed to the database and the degree ofconcurrency.andP;  Updates on concurrent tables are immediately applied to thedatabase.andP;  Updates on buffered tables are accumulated in memory for laterwriting upon an explicit save command or at the end of a session.andP;  Inpractice, only a few tables contain data that must be share among concurrentusers and must be assigned to the concurrent category.andP;  The other tables canbe buffered.andM;SectionsandM;A section is a subset of the database that can be independently manipulated.andO;Each instance of an object or relationship belongs to a single section.andP;  Eachsection contains zero or more data items from each buffered database table.andO;In other words, sections partition the data instances and cut across all thebuffered classes and relationships in the data model.andM;An application must lock a section before accessing its data.andP;  This is calledchecking out a section.andP;  An application may check out one or more sections.andO;Other users cannot read or write to checked-out sections.andP;  The notion of asection only applies to buffered data.andP;  Concurrent data cannot be checked outand can always be accessed by any application.andM;Database versusandM;nondatabase definitionsandM;There are two kinds of class and relationsh ip definitions in the OO-DBMS:database or nondatabase.andP;  Database classes and relationships are handled bothby the OO language and the RDBMS and may be saved in the database.andO;Nondatabase definitions are handled only by the OO language and may not besaved.andP;  Both kinds are useful.andP;  There is no point in creating database tablesfor nondatabase objects.andP;  Modifying nondatabase definitions only requiresrecompilation of the application, while the database must be rebuilt if anydatabase definitions are changed.andP;  Programmers use database definitionssparingly while nondatabase definitions are used freely.andM;PersistenceandM;Object instances are either persistent or transient.andP;  Persistent objectsremain in the database beyond the life of a program execution.andP;  Transientobjects are newly created objects stored only in memory and disappear when anapplication program terminates.andP;  Database objects may be transient orpersistent and may be converted from transient to persistent.andP;  Nondatabaseobjects are transient only.andM;Transient objects may temporarily violate database integrity rules.andP;  Forexample, the copy operation may create a transient object with a primary keythat matches the key of a persistent object.andP;  This may also occur when thetransient copy is going to be further updated before ultimate databaseinsertion.andP;  A transient object that satisfies database integrity may beconverted to a persistent object with an INSERT command (see section onOperations on Objects).andM;IDs for object referencesandM;An ID [13] is an arbitrary handle for referring to an object.andP;  Every objecthas a unique ID.andP;  IDs are automatically generated by the OO-DBMS and are notsubject to user update.andP;  ID allocation involves concurrency issues in amultiuser environment.andM;Because of their stability, IDs are particularly useful for objectreferences.andP;  Contrast this with the RDBMS scenario where the value of aprimary key changes and all foreign keys that refer to it must be updated.andO;All object database tables have an ID as the primary key.andP;  All relationshipdatabase tables use one or more IDs from participating objects as the primarykey.andM;All IDs are 32 bits long because the system is being run on a 32-bit machine.andO;Section IDs use only 16 bits and pad the remainder.andP;  Object IDs have 16 bitsto identify the section and another 16 bits to resolve identity within asection.andP;  One benefit of this ID allocation scheme is that once a section islocked, object IDs can be assigned within that section without conmsultingthe database.andP;  Another benefit is that if database storage of records withintables by IDs can be ordered, objects and relationships for a given sectionwill cluster within the tables.andP;  This improves the efficiency of sectionloading and section saving.andM;OO-DBMS ProgrammingandM;InterfaceandM;The OO-DBMS provides operations on objects, relationships, and sections.andP;  Theprogrammer executes an operation by invoking the function for the operationon the appropriate class.andP;  The function in turn calls internal routines forperforming buffered insert, delete, update, load, or save database operations(see section on the Internal Buffering Mechanism).andM;The following functions cover insertion, deletion, updating, and retrieval ofobjects and relationships from memory and the database.andP;  The functionsprovide the same functionality that would ordinarily be provided by a cursorinterface to a database.andP;  These functions have been sufficient for ourapplications.andM;Operations on ObjectsandM;The OO-DBMS includes functions to perform the following operations for eachobject class.andM;NEW (classname)andM;Creates and returns a new empty transient object of the given class.andP;  Issuesa create request to the buffering system.andP;  After an object is created, datamay be entered with a PUT operation.andP;  An object is transient until an INSERTis performed.andM;PUT (attributename, object, value)andM;Fills in an attribute by overwriting previous contents.andP;  Issues an updaterequest to the buffering system.andM;GET (attributename, object)andM;Returns an attribute value from an object.andP;  No action is required by thebuffering system.andM;RETRIEVE (classname, keyname, value 1, .andP;  .  .)andM;Returns a set of persistent objects whose keys match the sequence of values.andO;Transient objects are ignored.andP;  A key is a predefined list of attribute namesused to select objects.andP;  Any number of keys may be defined per object class.andO;RETRIEVE-ALL (classname)andM;Retrieves all persistent objects in a class.andP;  All concurrent objects arefound; buffered objects are found only for sections that have been loaded.andM;INSERT (object)andM;Converts a transient object into a persistent one.andP;  Issues an insert requestto the buffering system.andP;  An error is raised if the object violates databaseintegrity.andM;DELETE (object)andM;Destroys an object.andP;  Issues a delete request to the buffering system.andP;  Anerror is raised if the object belongs to any relationship.andM;COPY (object)andM;Returns a transient copy of the object, including its data.andP;  Issues a createrequest to the buffering system.andP;  COPY is equivalent to NEW followed by manyGETs and PUTs.andM;Operations on RelationshipsandM;The OO-DBMS includes functions to perform the following operations for eachrelationship with an explicit table.andM;INSERT (relationshipname, obj 1, obj2)andM;Adds a pair of persistent objects to a relationship.andP;  Issues an insertrequest to the buffering system.andM;DELETE (relationshipname, obj 1, obj2)andM;Deletes an object pair from a relationship.andP;  Issues a delete request a deleterequest to the buffering system.andM;DELETE-1 (relationshipname, obj1)andM;Deletes all object pairs from a relationship where obj1 is the first objectin the pair.andP;  Issues a delete request to the buffering system for each pair.andM;DELETE-2 (relationshipname, obj2)andM;Deletes all object pairs from a relationship where obj2 is the second objectin the pair.andP;  Issues a delete request to the buffering system for each pair.andM;RETRIEVE-1 (relationshipname, obj1)andM;Searches relationship to find object pairs in which obj1 is the first object.andO;Returns a set of objects.andM;RETRIEVE-2 (relationshipname, obj2)andM;Searches relationship to find object pairs in which obj2 is the secondobject.andP;  Returns a set of objects.andM;TEST (relationshipname, obj1), obj2)andM;Tests whether an object pair is a member of the relationship.andP;  Returns aboolean value.andM;Operations on SectionsandM;The OO-DBMS includes functions for controlling the buffering of sections.andM;SECTION-LOAD (section)andM;Locks a given database section and loads it into memory.andP;  An error occurs ifthe section is already loaded by another process.andP;  Reloading a sectionalready in memory aborts previous changes for the section.andM;SECTION-SAVE (section)andM;Commits changes for a given section to the database.andP;  Save requests areissued to the buffering system for objects and relationships requiringinsertion, deletion, or updating.andM;Internal BufferingandM;MechanismandM;The programmer accesses data by first locking and loading one or moresections into memory.andP;  As the data is loaded, the OO-DBMS builds datastructures used to search memory for objects and relationships.andP;  Subsequentoperations are performed in memory.andP;  Ultimately, changes made to a sectionare discarded or saved to the database.andM;Each buffered object has a state.andP;  When a section is loaded, all of itsobjects are in the PERSISTENT state.andP;  Each time an internal operation isperformed on an object, its state is checked to determine what action to takeand what the new state should be.andP;  Figure 4 shows a state transition diagram.andO;States are shown as uppercase names; actions are the lowercase names next toarcs.andM;Buffering StatesandM;TRANSIENTandM;Refers to transient objects.andP;  A newly created or copied object has thisstate.andP;  An insert operation changes the state to INSERT.andP;  Objects in thisstate are ignored during a save operation.andP;  Update operations on objects inthis state leave the state unchanged.andP;  Objects deleted from this state arediscarded.andM;PERSISTENTandM;Refers to unmodified persistent objects.andP;  Objects loaded from the databaseare put in this state.andP;  An update operation from this state sets the state toUPDATE.andP;  A delete operation sets the state to DELETE.andP;  Objects in this stateare ignored during a save operation because they are already up-to-date inthe database.andP;  An insert from this state is an error.andM;DELETEandM;Refers to persistent objects that must be deleted from the database.andP;  A saveoperation deletes objects in this state from the database and discards thein-memory copy.andP;  Any other operations are errors.andM;INSERTandM;Refers to persistent object that have been created during the current sessionbut not yet written to the database.andP;  A save inserts objects that are in thisstate into the database and sets their state to PERSISTENT.andP;  Updates toobjects in this state do not change their state.andP;  Delete simply discards theobject.andP;  An insert from this state is an error.andM;UPDATEandM;Refers to persistent objects that have been modified since being loaded intomemory.andP;  A save operation updates these objects in the database and setstheir state to PERSISTENT.andP;  Updates to objects in this state do not changetheir state.andP;  Delete sets the state to DELETE.andP;  An insert from this state isan error.andM;Internal Buffering OperationsandM;The database buffering system is driven by internal load, save, insert,delete, create, and update operations.andP;  These internal operations and thestate informatin recorded with each buffered object are used to bufferdatabase writes.andP;  Each internal operation on an object may change the stateof the object.andP;  Each operation is immediately applied to memory, and flagsare set on the object so that the changes can eventualy be written to thedatabase.andM;load (section)andM;Loads a section of the database.andP;  Searches all database tables for rowsbelonging to the section and creates objects in memory containing the data.andM;save (section)andM;Brings the database up-to-date with a section in memory.andP;  Updates thedatabase with information from objects in the insert, update, or deletestate.andP;  Objects in the persistent or transient state are ignored.andP;  Objects inthe delete state are discarded and their IDs recovered for reuse.andM;insert (object)andM;Makes an object persistent.andP;  This operation is applied to objects in thetransient state.andP;  Performs bookkeeping chores such as ID generation.andM;delete (object)andM;If the object is in the insert state, it is discarded.andP;  If the object ispersistent, it is placed in the delete state for eventual removal from thedatabase.andP;  create (class)andM;Create a new object of the given class and places the object in the transientstate.andP;  update (object)andM;Updates object attributes and places the object in the update state foreventual writing to the database.andM;Correctness of theandM;Buffering AlgorithmandM;We now show that applying database updates via our buffering scheme yieldsthe same results as immediate database update.andP;  Our demonstration onlyapplies to persistent objects and relationships, since transient and localdata are not written to the database.andP;  We begin by defining consistencyconditions.andM;Condition 1:andM;Each database record corresponds to an object or relationship record inmemory.andP;  Each record in memory has a state that correctly describes thedifference between what is in the database and what should be in thedatabase.andP;  Condition 2:andM;Each database record is uniquely identified by a primary key.andP;  With oneexception, no two persistent records in memory may have the same primary key.andO;The one exception is that a record that has been deleted and then insertedmay appear twice, once in the insert state and once in the delete state.andM;AssumptionsandM;We make the following assumptions.andM;(1) Sections are locked for a single user.andM;(2) If there are two records with the same primary key, it is an indicationthat there was a deferred deletion followed by a deferred insertion and notvice versa.andP;  (A deferred insertion followed by a deferred deletion cancelsout, leaving no trace in the buffering system.)andM;(3) Deletions must be processed before insertions, in case there is aduplicate record with the same primaru key.andP;  For example, primary keys forrelationships are formed from the primary keys of the objects being related.andO;If a member of a relationship is deleted and then inserted, there will be tworecords in in memory with the same primary key.andM;(4) Insertions must check persistent records for uniqueness of the primarykey.andM;(5) Modification of the primary key is not allowed for persistent records.andO;This is not a problem, since all primary keys are IDs.andM;Assertion 1andM;Under consistency condditions, a save operation correctly updates thedatabase.andM;All objects and relationship database tables use IDs as the primary keys.andO;IDs are assigned by the OODBMS and are never changed.andP;  The primary key for arecord provides a one-to-one mapping between memory and the database.andM;The state of each memory record indicates what actions must be performed tosynchronize the database.andP;  Records in the PERSISTENT state require no actionbecause they are already up-to-date.andP;  Records in the UPDATE state have theirnon-primary key attributes updated in the database.andP;  Records in the INSERTstate are added.andP;  Records in the DELETE state are removed.andM;Assertion 2andM;Consistency conditions hold immediately after a load operation.andM;Data is copied from the database into memory, so the two copies are the same.andO;Each memory record has the same unique primary key that it had in thedatabase.andP;  Each record is in the PERSISTENT state, indicating that it agreeswith the database.andM;Assertion 3andM;Each internal buffering operation preserves consistency.andM;In this section phrases such as &quot;deferred insert&quot; are used to refer to aninternal buffering operation.andP;  This will distinguish an internal bufferingoperation from the eventual database action.andM;A deferred insert is only allowed on records in the TRANSIENT state.andP;  Part ofthe deferred insertion process is a check for uniqueness of the primary key.andO;Since the object must belong to a section and since the section ID is part ofthe key, this check can be made without consulting the database.andP;  Records inthe INSERT, PERSISTENT,  and UPDATE states are checked, and duplication oftheir primary keys is blocked.andP;  On the other hand, since records in theDELETE state are invisible to the programmer, their primary keys may bereused.andM;A deferred delete is allowed for records in the PERSISTENT, UPDATE, or INSERTstates.andP;  Records in the INSERT state are not written in the database and canbe simply discarded.andP;  Records in the PERSISTENT or UPDATE state havecorresponding information in the database and are placed in the DELETE statefor later removal.andM;A deferred update is allowed for records in all states except the DELETEstate.andP;  With the exception of the TRANSIENT state, modification of theprimary key is not allowed.andP;  Modification of the primary key of a record inthe TRANSIENT state is allowed because such records are temporary.andM;InductionandM;By induction, since each individual buffering operation preservesconsistency, a series of buffering operations also preserves consistency.andM;Bidirectional LinkageandM;The OO-DBMS must quickly map from the database primary key to the OO languagepointer and vice versa.andP;  Some possible implementation techniques are:andM;(1) pair of tables + hashingandM;(2) pair of trees.andM;We used the container class relationship of our OO language, which wasimplemented with a pair of tables plus hashing.andP;  Hashing algorithms and tablelookup are provided by OO language libraries.andM;Integrity CheckingandM;The OO-DBMS incorporates rudimentary integrity checking.andP;  The OO-DBMSenforces the uniqueness of primary keys and candidate keys and nonnullspecifications.andP;  We also provide some support for enumeration types and rangechecking.andP;  Since the OO-DBMS is essentially a layer that wraps around anRDBMS, we could include more thorough integrity support in the future.andM;Application ofandM;the OO-DBMSandM;Choice of SoftwareandM;SubsystemsandM;Our implementation of the OO-DBMS was built on top of DSM, MIMER, and theObject Modeling Technique.andP;  The OO-DBMS could be ported to another RDBMS byrewriting the database interface.andP;  The OO-DBMS could be ported to another OOlanguage by emulating the DSM relation feature [19].andM;We chose the MIMER[R] DBMS for reasons unrelated to its technical merits.andO;MIMER is more or less a conventional SQL-like relational DBMS [7, 18].andP;  Aswith its competitors, MIMER implements certain aspects of the relationalmodel well, yet contains arbitrary implementation restrictions on others.andO;For example, a secondary index is restricted to a single attribute; it cannotbe composite.andM;We chose the Data Structure Manager (DSM) [19, 22] as our OO language becauseof its technical features and in-house availability.andP;  DSM is afull-functionality OO language developed at GE.andP;  DSM runs on top of the Clanguage.andP;  The most noteworthy DSM feature is its support for relationshipsamong objects.andP;  One can navigate DSM objects in a manner similar tonavigating RDBMS tables.andP;  DSM can automatically enforce certain constraints,such as existence dependencies between objects.andP;  DSM has a rich library ofpredefined classes.andM;Application ExperienceandM;We have used the OO-DBMS described in this article to support an editor forelectric circuit design.andP;  The circuit editor stores its data in a databasefor access by other programs such as mathematical simulators.andP;  Theobject-oriented layer allows the circuit editor to receive database servicessuch as data persistence and concurrent access, yet it still responds in realtime.andP;  Our electric circuit application supports interactive graphicalediting and requires a fast response to keep pace with the user.andM;We designed the OO-DBMS sporadically over the course of a year.andP;  Once we hadcompleted the design, it took three months to implement the OO-DBMS.andP;  Theextensive DSM library was largely responsible for the short implementationtime.andM;The full electric circuit application had fourteen full pages of OMTdiagrams.andP;  There were 82 object classes and 45 relationships, yielding 108database tables.andP;  Programmers wrote several thousand lines of code forprogramming interface function templates.andM;The performance of the resulting OO-DBMS was sufficient to support aninteractive electrical circuit editor running on a MicroVAX[R] computer.andP;  TheOO-DBMS keeps pace with interactive mouse movement.andP;  An RDBMS by itselfcannot support real-time performance because of I/O delay andcommand-processing overhead.andP;  It takes the OO-DBMS one second to perform amixed sequence of several thousand object and relationship operations inmemory, running on a MicroVAX II[R].andP;  The same sequence of operations wouldtake more than a minute if they were applied directly to the database.andM;This methodology is currently being used for another interactive graphicalapplication.andP;  Most of the effort required to adapt it to this new applicationis the preparation of a new data model.andM;ConclusionsandM;We have described an approach to implementing an object-oriented DBMS(OO-DBMS).andP;  One can take an existing relational DBMS (RDBMS) and hide itbeneath an object-oriented programming language.andP;  The buffering algorithmyields fast interactive performance while storing objects in a database.andP;  Ourwork demonstrates that it is possible to build an object-oriented DBMS on topof a relational DBMS and still get good performance.andM;This approach combines the best features of both RDBMS and OO programminglanguages.andP;  RDBMSs have a sound theoretical base and work well for businessapplications.andP;  Commercial products have robust concurrency, journaling, androllback facilities.andP;  At the same time we obtain the benefits of usingobjects to abstract an application.andP;  The programming language allows complexalgorithms to be written that would be hard to express in an RDBMS, withoutfrequent access of the RDBMS within the algorithm.andP;  This approach minimizesthe amount of new code that must be written, since it uses existing softwaresubsystems.andP;  An OO design methodology is the &quot;glue&quot; that binds together theRDBMS and OO language.andP;  Our &quot;OO-DBMS&quot; lacks the functionality of a fullsystem.andP;  Nevertheless, our approach to an OO-DBMS is quite effective for manyapplications.andM;In our applications, we have found that OO programming improves programmerproductivity, relative to conventional procedural languages like Pascal andC.andP;  Our approach to an OO-DBMS enables one to reap these productivity gainswhile using an RDBMS.andM;(1) AWK is a Unix tool.andM;(2) LEX and YACC are Unix tools.andM;ReferencesandM;[1.] Andrews, T., and Harris, C.andP;  Combining language and database advances inan object-oriented development environment.andP;  In Proceedings of OOPSLA '87Conference.andP;  (Oct.andP;  4-8, Orlando, Fl.) ACM/SIGPLAN, New York, 1988, pp.andO;142-152.andM;[2.] Atkinson, M.P., and Buneman, O.P.andP;  Types and persistence in databaseprogramming languages.andP;  ACM Comput.andP;  Surv.andP;  19, 2 (June 1987), 105-190.andM;[3.] Blaha, M.R., Premerlani, W.J., and Rumbaugh, J.E.andP;  Relational databasedesign using an object-oriented methodology.andP;  Commum.andP;  ACM 31, 4 (Apr.andO;1988), 414-427.andM;[4.] Booch, G.andP;  Object-oriented development.andP;  IEEE Trans.andP;  Softw.andP;  Eng.andO;SE-12, 2 (Feb.andP;  1986), 211-221.andM;[5.] Carey, M., et al.andP;  The architecture of the EXODUS extensible DBMS.andP;  InProceedings of the 1986 International Workshop on Object-Oriented DatabaseSystems (Sept.andP;  23-26, Pacific Grove, Calif.).andP;  ACM/SIGMOD, New York, 1986,pp.andP;  52-65.andM;[6.] Cattell, R.G.G., and Rogers, T.R.andP;  Combining object-oriented andrelational models of data.andP;  In Proceedings of the 1986 International Workshopon Object-Oriented Database Systems (Sept.andP;  23-26, Pacific Grove, Calif).andO;ACM/SIGMOD, New York, 1986, pp.andP;  212-213.andM;[7.] Codd, E.E.andP;  A relational model of data for large shared data banks.andO;Commun.andP;  ACM 13, 6 (June 1970), 377-387.andM;[8.] Cox, B. J.andP;  Object-Oriented Programming: An Evolutionary Approach.andO;Addison-Wesley, Reading, Mass., 1986.andM;[9.' Daval, U., et al.andP;  PROBE--A research project in knowledge-orienteddatabase systems: Preliminary analysis.andP;  Tech.andP;  Rep.andP;  CCA-85-03, ComputerCorporation of America, Cambridge, Ma., 1985.andM;[10.] Gadient, A.J.andP;  Functional requirements for an electronic designautomation environment integration framework.andP;  In Compint 85: FirstInternational Conference on Computer Aided Technologies (Sept.andP;  10-12,Montreal, Canada).andP;  IEEE-CS, Washington, D.C., 1985, pp.andP;  348-354.andM;[11.] Haskin, R.L., and Lorie, R.A.andP;  On extending the functions of arelational database system.andP;  In Proceedings of SIGMOD '82 InternationalConference on Management of Data (June 2-4, Orlando, Fla.).andP;  ACM/SIGMOD, NewYork, 1982, pp.andP;  207-212.andM;[12.] Kernighan, B.W., and Pike, R.andP;  The UNIX Programming Environment.andO;Prentice-Hall.andP;  Englewood Cliffs, N.J., 1984.andM;[13.] Khoshafian, S. N., and Copeland, G. P.andP;  Object identity.andP;  InProceedings of OOPSLA '86 Conference (Sept.andP;  29-Oct.andP;  2.andP;  Portland, Or.).andO;ACM/SIGPLAN, New York, 1986, pp.andP;  406-416.andM;[14.] Kim, W. et al.andP;  Integrating an object-oriented programming system witha database system.andP;  In Proceedings of OOPSLA '88 Conference (Sept.andP;  25-30,San Diego, Calif.).andP;  ACM/SIGPLAN, New York, 1988, pp.andP;  142-152.andM;[15.] Klahold, P., et al.andP;  A transaction model supporting complexapplications.andP;  In Proceedings of SIGMOD '85 International Conference onManagement of Data (May 28-31, Austin, Tex.).andP;  ACM/SIGPLAN, New York, 1985,pp.andP;  388-401.andM;[16.] Loomis, M.E.S., Shah, A.V.S., and Rumbaugh, J.E.andP;  An object modelingtechnique for conceptual design.andP;  In Proceedings of the European Conferenceon Object-Oriented Programming (June 15-17, Paris, France).andP;  Lecture Notes inComputer Science, 276.andP;  Springer-Verlag.andP;  New York, 1987.andP;  pp.andP;  192-202.andM;[17.] Maier, D., Stein, J., Otis, A., and Purdy, A.andP;  Development of anobject-oriented DBMS.andP;  In Proceedings of OOPSLA '86 Conference (Sept.andO;29-Oct.andP;  2.andP;  Portland, Oreg.).andP;  ACM/SIGPLAN.andP;  New Newk, 1986.andP;  pp.andP;  472-482.andM;[18.] MIMER Information Systems AB, Uppsala, Sweden.andM;[19.] Rumbaugh, J.E.andP;  Relations as semantic constructs in an ogject-orientedlanguage.andP;  In Proceedings of OOPSLA '87 Conference (Oct.andP;  4-8, Orlando,Fla.).andP;  ACM/SIGPLAN, New York, 1987, pp.andP;  466-481.andM;[20.] Rumbaugh, J.E.andP;  Controlling propagation of operations using attributeson relations.andP;  In Proceedings of OOPSLA '88 Conference (Sept.andP;  25-30, SanDiego, Calif.).andP;  ACM/SIGPLAN, New York, 1988, pp.andP;  285-296.andM;[21.andP;  Rumbaugh J. et al.andP;  Object-Oriented Modeling and Design.andO;Prentice-Hall, Englewood Cliffs.andP;  N.J., 1991.andM;[22.] Shah, A. et al.andP;  DSM: An object-relationship modeling language.andP;  InProceedings of OOPSLA '89 Conference (Oct.andP;  1-6, New Orleans, La.).andO;ACM/SIGPLAN, New York, 1989, pp.andP;  191-202.andM;[23.] Stonebraker, M., and Rowe, L.andP;  The design of POSTGRES.andP;  In Proceedingsof SIGMOD '86 International Conference on Management of Data (May 28-30,Washington, D.C.).andP;  ACM/SIGMOD, New York, pp.andP;  340-355.andM;CR Categories and Subject Descriptors: D.2.2 [Software Engineering]: Toolsand Techniques; D.2.10 [Software Engineering]: Design--methodologies; H.2.1[Database Management]: Logical Design; H.2.4 [Database Management]: SystemsandM;General Terms: Design, PerformanceandM;Additional Key Words and Phrases: Database checkout, database performance,database shadowing, engineering database application, entity-relationshipmodeling, long transaction, object-oriented database, relational databaseandM;MICHAEL R. BLAHA is a computer scientist at GE's Corporate Research andDevelopment Center in Schenectady, New York.andP;  His research interests includeengineering database management and complex data modeling.andP;  Email:blaha[a]crd.ge.comandM;WILLIAM J. PREMERLANI is a computer scientist at GE's Corporate Research andDevelopment Center.andP;  His research interests include object-orientedmethodologies and applications of databases to engineering applications.andO;Email: premerlani[a]crd.ge.comandM;JAMES E. RUMBAUGH is a computer scientist at GE's Corporate Research andDevelopment Center and is working on object-oriented methodologies forsoftware design and their implementation as practical systems forapplications.andP;  Email: rumbaugh[a]crd.ge.comandM;THOMAS A. VARWIG is a senior software design engineer at Cadence in SanDiego.andP;  his research interests include tools for printed circuit board designincluding automatic placement and routing.andP;  Email: varwig[a]autosys.com</TEXT></DOC>