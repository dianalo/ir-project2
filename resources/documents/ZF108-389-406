<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-389-406  </DOCNO><DOCID>08 389 406.andM;</DOCID><JOURNAL>Data Based Advisor  May 1990 v8 n5 p104(7)* Full Text COPYRIGHT Data Based Solutions 1990.andM;</JOURNAL><TITLE>The perfect API. (evaluating application programming interfaces)(DB Connections)</TITLE><AUTHOR>Buzzard, James.andM;</AUTHOR><SUMMARY>Selection of applications programming interface (API) software fordata base servers depends on several program specifications.andP;  Twomajor criteria are consistency and orthogonality, which translateinto four 'rules.' If a command permits an operation, a parallelcommand should exist for the inverse operation.andP;  Exceptions orinconsistencies in command use should be only those required bylogic.andP;  The API-server interaction method should be consistentthroughout.andP;  Data items should be functionally the same whetherused to interface with the server or with the client application.andO;Implementation of these rules involves consistent host-language tostructured query language conversion, support for detection andcorrection of syntactical and other errors, methods for handlingnull values, facilities to convert data types and translate amonghuman languages and support for distributed computing.andM;</SUMMARY><DESCRIPT>Topic:     Data Base ServersApplications ProgrammingInterfaceSpecificationsCriteriaSoftware Selection.andO;Feature:   illustrationphotograph.andM;</DESCRIPT><TEXT>THE PERFECT APIandM;Last month I looked at four general types of application programminginterfaces (APIs) to database servers.andP;  These include: function-call,precompiler, native SQL, and command-mapping interfaces.andP;  This month I'll gointo more detail about what features and services database server APIs shouldprovide, regardless of their type.andP;  I'll look at issues like the consistencyof the API, dealing with null values, and error handling and recovery.andM;A few simple rulesandM;As with many things in life (and programming), consistency is a necessaryingredient for database server APIs.andP;  Another concept that impacts thequality of database server APIs is &quot;orthogonality.&quot;andP;  C.J.andP;  Date definesorthogonality in computer languages this way:andM;&quot;A language is said to be orthogonal if independent concepts are keptseparate and are not mixed together in confusing ways.&quot;andM;For a database server API to be consistent and orthogonal, it should provideequivalent types of commands for equivalent operations.andP;  In evaluatingdatabase server APIs, I'll follow these rules:andM;Rule 1: If the API provides a command for a particular operation, it shouldalso provide a command for the opposite or complementary operation.andP;  The twocommands should be syntactically equivalent.andP;  For example, if a specificcommand is provided to connect to a database server, there should be asimilar command to disconnect from the server.andM;Rule 2: Special cases or exceptions in how and when commands can be usedshould be limited to those that are logically required.andP;  For example, if theAPI supports embedded SQL statements, any legal (for the database serveryou're using) SQL statement should be allowed in these embedded statements.andO;The API shouldn't restrict you to a subset of the SQL commands.andM;Rule 3: If the API provides programmers with a particular method ofinteracting with the server (for example, by function calls, command mapping,or embedded SQL), programmers should be able to use that one method for allinteraction with the server.andM;Rule 4: Data items manipulated solely by the client application (usually inhost-language variables) and data items used in interactions with thedatabase server should be functionally identical.andP;  You shouldn't have to usespecial data types for items in embedded SQL statements.andM;A few broken rulesandM;These rules probably seem simple and straightforward, but they're violated bymost commercial database server products in some way.andP;  For example, the SQLdialect supported by Microsoft SQL Server includes the CREATE DATABASE andDROP DATABASE commands for (you guessed it) creating and deleting databases.andO;To get a list of the existing databases, however, you execute a specialprocedure stored on the server called &quot;sp_helpdb&quot; rather than the more commonSHOW DATABASES command.andP;  This somewhat violates Rule 1.andM;The precompiler supplied with IBM OS/2 Extended Edition Database Manager isan example of API inconsistency.andP;  It requires you to use a C function call toconnect to the server and then use embedded SQL statements to access data onthe server--a violation of Rule 3.andM;Some people (including C.J.andP;  Date) have correctly argued that even SQL, asdefined by the ANSI standard and implemented by database vendors, lacksconsistency in certain areas.andP;  Even so, the server's API shouldn't addanother layer of inconsistency and confusion.andM;Consistency andandM;command-mapping APIsandM;Command-mapping APIs convert standard host-language commands into SQLcommands before sending them to the database server.andP;  They can presentseveral unique consistency problems.andM;In some cases there isn't a SQL command (or series of commands) that'sequivalent to the host-language command.andP;  For example, the dBASE GOTO command(which positions the pointer on a specific record) doesn't have an equivalentin SQL and must somehow be emulated (more on this next month).andM;Also, most PC-based application development tools, including those based ondatabase systems such as dBASE and Paradox's PAL, lack equivalents to many ofthe database administration commands used by database servers.andM;For example, Oracle Server allows you to allocate blocks of disk space,called &quot;tablespaces,&quot; for holding your database files.andP;  Since Wordtech'sQuicksilver doesn't require or support preallocation of disk space, you canonly generate these commands from your dBASE-language application by directlyissuing the necessary SQL commands (in effect, by switching from acommand-mapping API to a native SQL API, violating Rule 3).andM;Failures and errorsandM;In a client application attached to a database server, a command sent to theserver for processing can fail for a number of reasons.andP;  These reasons can bebroken down into several discrete groups:andM;* Misspelled SQL commands or key words embedded in the application's sourcecode by the programmer.andP;  This results in an error message from the server orprecompiler (if the error is detected during precompilation).andM;* Misspelled or invalid references to database tables or columns in the SQLstatements embedded in the application's source code by the programmer.andP;  Thisalso results in an error message from the server or precompiler (if the erroris detected during precompilation).andM;* Misspelled SQL commands or invalid references in commands entered by theuser (such as during ad hoc queries).andP;  This results in an error message fromthe server.andM;* Attempts by users to access or update data they don't have privileges to.andO;This results in a security violation message from the server.andM;* Rejected SQL commands that violate a data-integrity constraint enforced bythe server.andP;  For example, the SQL command might try to insert a record with aduplicate value for a column that requires unique values (like a customernumber column).andP;  This kind of failure will only occur on database serversthat support some form of server-based data-integrity constraints, such asMicrosoft SQL Server.andM;* User transactions rejected by the database server to resolve a deadlockwith another user.andP;  This usually results in the entire transaction beingrolled back and a message returned to the client application requesting thatthe client resubmit the transaction.andM;* Complete failure of the server computer or the communications link betweenthe workstation and the server.andP;  This results in a break in the workstation'sconnection to the server.andP;  The API should detect the failure and notify theclient application.andM;* Partial failures of the server computer or communications link, such as adisk failure.andP;  This results in lost data or garbled transmissions.andP;  The APIshould detect the failure and notify the client application.andM;Dealing with failureandM;Since we live in a less-than-perfect world, we need to adopt some strategy toavoid failures--when we can--and gracefully recover from them when we can't.andM;We can trap the first two types of failures by using a precompiler thatchecks the syntax and semantics of the client application's source code.andO;Because they occur only as the application executes, the other types offailures must be trapped by the client application or the database server APIcode.andM;Checking syntaxandM;Syntactical error checking involves checking the syntax, or composition, ofstatements and commands used in the application's source code.andP;  All compilersand interpreters perform some level of syntactical checking for host-languagestatements, either when the program is compiled or when it's executed.andM;The additional syntactical checking performed by the database server APIrefers to the SQL statements or server-specific commands embedded in theclient application.andP;  The host-language compiler or interpreter usually can'tunderstand or verify the correctness of embedded SQL statements.andM;Checking semanticsandM;Semantic checking involves validating references to database objects (tables,columns, and other elements in the database) and host-language memoryvariables in embedded SQL statements in the client application.andP;  It's usuallyprovided only by APIs that use a precompiler.andP;  Other types of APIs onlyevaluate SQL statements when they're executed.andP;  While the semantics of aparticular SQL statement is checked by the database server at this point, afailure here results in some type of program failure (i.e.andP;  run-time errorsrather than errors trapped during debugging).andM;It requires that the database contain all of the database objects referred toin the application source code.andP;  The precompiler or some other utilityprogram connects to the database server and issues queries to the datadictionary or system tables to verify that the database objects referenced inembedded SQL statements exist.andP;  It isn't practical if the application buildstemporary tables on the fly or builds all of its tables when installed.andM;It should be optional--programmers should be able to turn it off.andP;  Thisallows quicker program precompilation, particularly important when smallchanges are made and tested during debugging.andP;  Unfortunately, this isn'talways the case.andP;  For example, IBM OS/2 Extended Edition Database Managerversion 1.1 always checks your semantics--you can't disable it.andM;Trapping errorsandM;Error handling mechanisms can generally be divided into two groups: thosethat are event-driven and automatically activate when an error occurs andthose that require a specific manual check for an error after each operation.andM;Event-driven error handlers (such as dBASE's &quot;ON ERROR&quot; and &quot;ON READERROR&quot;facilities) are easier to implement and more reliable than manual errorchecking.andP;  Programmers need only activate the error handler when they startthe program.andP;  When the event handler is activated, programmers specify thename of the procedure or function they've written.andP;  When an error occurs, thefunction or procedure is automatically called.andP;  More sophisticated APIs letyou redefine the error-handling procedure or function on the fly, allowingyou to specify local error handlers.andM;Manual error-checking mechanisms require programmers to add checks for errorsor failures after every interaction with the server (such as after everyembedded SQL statement or function call to the API library).andP;  This form oferror checking increases development time and program complexity.andP;  It's alsolikely to result in less reliable programs since you might omit a particularerror check from the source code.andP;  There are also times you can't trapcertain types of errors--like time-outs due to communications or serverfailures--with manual error checks.andM;Mapping server errors toandM;host-language errorsandM;For command-mapping APIs, error handling usually involves mapping databaseserver errors to equivalent or similar error conditions defined in the hostlanguage.andP;  For example, dBASE IV has a native error handling system and apredefined set of error conditions.andP;  The error-handling system in thedatabase server API must map or convert error messages returned by the serverto host-language error conditions that the client application can detect andresolve.andM;In some cases the database server error conditions have direct host-languageerror condition equivalents.andP;  For example, trying to access a database servertable that doesn't exist results in a server error that can be directlymapped to the host-language error condition that results from trying to opena nonexistent data file.andM;In other cases, the database server might return errors that can't bedirectly mapped to an existing host-language error condition.andP;  For example,with database servers that support centrally enforced data integrityconstraints, you might try to update a column in a server table with anillegal value.andP;  The database server will reject the update and return amessage to the client application.andP;  However, the client application's hostlanguage may not include constraint enforcement facilities and thereforewon't have the corresponding error conditions.andP;  The command-mapping API willhave to supply additional host-language error conditions to matchserver-specific errors.andP;  The client application will also have to be modifiedto detect the additional error conditions.andM;Handling null valuesandM;Null values in database systems represent missing, unknown, or inapplicabledata.andP;  Null values are not the same as a blank or zero value.andP;  Nullsrepresent data that isn't known when the record is added to the database.andM;For example, if we're adding a record for a vendor, we might not know whatcredit limit the vendor will grant our company.andP;  In a database system thatsupports null values, we can accurately represent this unknown by putting anull in the credit limit column.andP;  However, in database systems that don'tsupport nulls (dBASE is a good example) we can only store a zero or someother numeric value in this column.andP;  It's clearly inaccurate to use a zero,since this would indicate that the vendor has given us no credit at all.andM;Null value support is especially important to statistical calculations onnumeric data.andP;  For example, an average value for a column is usuallycalculated by summing the values of all of the records and dividing by thenumber of records.andP;  If your system can't distinguish between zero and anunknown or missing value, your average will be skewed.andP;  The records withunknown values should be excluded because the value is missing.andM;In SQL database systems, columns are given null values whenever a row (orrecord) is added without a value being specified for the column.andP;  In somecases, especially for key or unique columns, null values aren't allowed (byusing the NOT NULL modifier on the column's definition in the SQL CREATETABLE command).andM;Three-valued logicandM;Normal programming languages (and normal programmers) work with what's calledtwo-valued logic.andP;  Every expression evaluates to true or false.andP;  If I comparetwo values, X and Y, the result will be either true or false.andM;However, database systems that support nulls must also support an extensionto normal, everyday logic called three-valued logic.andP;  In three-valued logic,every expression evaluates to one of three values: true, false, or unknown.andM;In general, any expression that involves a null value must result in anunknown result (you can't solve the problem if you don't have all of theinformation).andP;  Some examples of comparisons that include null values are:andM;If X = 10, Y = 20, and Z is null:andM;X = X  is true X = Y  is false X = Z  is unknown Z = Z  is unknownandM;Actually, there's a serious debate about whether three-valued logic isinadequate and more types of unknowns need to be recognized.andP;  While this isprobably true, it's a somewhat abstract concern to application programmersstruggling to keep track of just one type of unknown.andM;Supporting null values inandM;host-language programsandM;If the host programming language or application development system doesn'tsupport nulls directly (few do), then the API must use one of the followingmethods.andM;Indicator variablesandM;A second variable is passed to the client application from the server foreach variable used to retrieve data.andP;  The second variable (the indicatorvariable) contains a value (usually either -1 or 0) that indicates whetherthe value returned by the server (in the first variable of the pair) shouldbe considered a null.andP;  Indicator variables are used by Oracle Server and IBMOS/2 EE Database Manager.andM;Using indicator variables requires programmers to check the indicator beforemanipulating the query results (which is a lot of extra work).andM;Substitution valuesandM;Substitution values are special values used for each type of data (numeric,character, etc.) to represent null values.andP;  The database server API convertsthe null values returned by the server to the appropriate substitutionvalues.andP;  Substitution values are used by Microsoft SQL Server's API,DB-LIBRARY.andM;Using substitution values requires programmers to come up with values thatcan't possibly be mistaken for actual data.andP;  For example, an empty string forcharacter data or zero for numeric data may not qualify as suitablesubstitution values in situations where empty strings and zero values arevalid data.andM;Updates with null valuesandM;The API should also provide some way to insert null values into the database.andO;If the contents of a column of a SQL UPDATE or INSERT statement (used tochange values in existing rows or add new rows) need to be explicitly set tonull, the API must have some way to indicate this.andM;In APIs that use indicator variables, null values are usually inserted bysetting the indicator variable in the SQL statement for that particularcolumn to the value that indicates a null.andP;  In APIs that use substitutionvalues, the substitution value that corresponds to a null may (or may not,depending on the system) designate the null value in an update operation.andM;Data type conversionsandM;In most client applications, the program requests information from the user,stores the information in program variables, and then uses the variables aspart of a SQL statement sent to the database server.andM;To ease the task of writing and debugging client applications, programmersshould be able to define the variables used in embedded SQL statements asregular host-language variables.andP;  Having to use special data types ordeclarations for variables used in embedded SQL statements increases programcomplexity and reduces program portability between database systems (as wellas violating Rule 4).andP;  Ideally, converting between server data types andhost-language data types should be supported transparently by the API.andM;Most precompiler APIs require you to bracket the standard host-languagedeclarations, initializations, or variables used in embedded SQL statementswith special indicators.andP;  These indicators help the precompiler find the hostvariables in your source code, so they can be used semantically to check theembedded SQL statements.andM;Support for national languagesandM;and collating sequencesandM;If you develop applications used in non-English speaking countries, you mayfind that translating your application requires more than just changing theon-screen text.andM;Different countries (or locales, in more technical terms) may requiredifferent collating or character sorting sequences.andP;  You may also have tosupport multiple bytes per character (to accommodate accented alphabets orpictographic languages, for example).andP;  There may also be differences inday-of-week and week-numbering schemes (for example, Monday as the first dayof the week in some countries and as the second day in others).andP;  Generally,the database server engine must support these differences, not just the API.andM;Distributed database functionalityandM;If you plan to provide simultaneous access to more than one server in yourapplication, the distributed database support included in the database serverand its API can be crucial.andP;  Current database systems (even on very largesystems, like mainframes) still support only rudimentary distribution of datato multiple servers.andM;While even a partial discussion of distributed databases is beyond the scopeof this article, there are several points to keep in mind when evaluatingdatabase server APIs.andP;  For example, distributed database support can bebroken into two general categories: managing the database and manipulatingthe data in the database.andP;  Since this article focuses on the concerns ofapplication developers, we'll ignore managing distributed databases andconcentrate on manipulating the data.andM;Manipulating distributed data must be transparent to users and applicationprogrammers.andP;  The SQL statements or host-language commands used to access thedistributed database should be no different than the commands used with asingle local server.andP;  Beware of vendors' claims of distributed data supportthat require you to open a separate connection to each server within yourapplication program.andP;  The database server should independently manage queriesand updates involving multiple sites.andP;  Without this capability, the clientapplication will have to be altered each time the data is moved orredistributed.andP;  Data distribution should be managed by the databaseadministrator, not the application programmer.andM;Manipulating distributed data can be broken down into two more categories:distributed queries (where the data is only read from the databases) anddistributed updates (where data is updated on multiple servers).andM;Distributed queriesandM;Implementing distributed queries is generally less difficult for databasevendors than distributed updates.andP;  Even so, some parts of the database system(such as the concurrency manager and query optimizer) must be aware that aparticular query involves data from multiple sites.andP;  The database server mustbe able to transparently resolve the references to remote data without usersor the application programmer needing to know the actual location of thedata.andM;Distributed updatesandM;In addition to the facilities required for distributed queries, support fordistributed updates requires that the database system have the ability torecover to a logically consistent state after the failure of only part of thesites involved in the distributed update.andP;  In other words, if a clientrequests that several servers perform part of an update, the system as awhole needs to either complete the entire update or, if one of the serversfails, roll back (or undo) any parts that were done before the failure.andM;This multi-site fault tolerance is usually implemented using a techniquecalled two-phase commit.andP;  In simple terms, two-phase commit involves atwo-step process.andP;  All the servers involved in a distributed update ortransaction first notify each other (or a controlling server) that they'reready to commit (or make permanent) the update (the first phase).andP;  Then theyactually proceed to commit the update and notify each other that they havesuccessfully completed the commit operation (the second phase).andP;  If anyserver fails during the transaction, all of the other servers are signaled toroll back their portion of the update.andM;The database engine on the server computer, not the API, should supportdistributed updates and two-phase commit.andP;  Some products (such as MicrosoftSQL Server) support two-phase commit in the API.andP;  This requires specialapplication code for distributed updates and reduces the portability of theclient application.andM;SummaryandM;I hope you know the issues to raise in evaluating a particular databaseserver front-end tool or API.andP;  Few commercial products currently provide allof the features and functionality I've discussed, so your selection processwill involve some compromises to find the best fit for your application.andM;Next month I'll look at how a specific application development environment,the dBASE language, can be used to connect to SQL-based database servers.andM;If you want to know more about this topic, read:andM;C.J.andP;  Date, &quot;Defining Data Types in a Database Language,&quot; &quot;What's Wrong withSQL?,&quot; and &quot;NOT Is not 'Not',&quot; Relational Database Writings 1985-1989,Addison Wesley, 1990.andM;J.andP;  Celko, &quot;DBA Shoptalk,&quot; Database Design and Programming, September 1989,Miller Freeman Publications.andM;James Buzzard owns a database and application design consulting firm,Hammerhead Systems.andP;  His industry experience includes four years as V.P.andP;  ofEngineering at SBT Corp. and a background in finance and accounting.andP;  You cancontact him via MCI mail username JBUZZ</TEXT></DOC>