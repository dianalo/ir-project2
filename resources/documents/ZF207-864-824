<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-864-824  </DOCNO><DOCID>07 864 824.andM;</DOCID><JOURNAL>Communications of the ACM  Nov 1989 v32 n11 p1340(12)* Full Text COPYRIGHT Assn. for Computing Machinery, Inc. 1989.andM;</JOURNAL><TITLE>An experimental analysis of the performance of fourth generationtools on PCs. (technical)</TITLE><AUTHOR>Matos, Victor M.; Jalics, Paul J.andM;</AUTHOR><SUMMARY>The performance of several fourth generation programming language(4GL) tools is analyzed and compared with equivalent programswritten in COBOL, a third-generation language.andP;  The tested 4GLtools are Oracle, Informix-4GL, Condor, Rbase, dBase, Paradox andPC-Focus.andP;  A set of performance benchmarks consisting of thirteendifferent functions is obtained.andP;  It seems clear that 4GL systemsare much better than the previous generation.andP;  4GL code is easierto produce, debug and maintain than the equivalent COBOL programs.andO;Microcomputer-based 4GL systems offer an efficient yet simple toolfor small database applications.andP;  Contrary to wide belief, thesimplicity of 4GL systems may not automatically make theminefficient in terms of execution time.andM;</SUMMARY><DESCRIPT>Product:   Condor 3 (Computer program) (testing)PC-Focus (Data base management system) (testing)dBASE (Data base management system) (testing)Oracle (Data base management system) (testing)Informix-4GL (Data base management system) (testing)Paradox (Data base management system) (testing)R:base (Data base management system) (testing).andO;Topic:     Fourth-Generation LanguagesPerformance MeasurementTechnologyCOBOLBenchmarks.andO;Feature:   illustrationtablegraph.andO;Caption:   Inventory database tables. (table)Size of sample database tables. (table)COBOL vs. fastest database system: relational operators. (graph)andM;</DESCRIPT><NOTE>Only Text is presented here; see printed issues for graphics.andO;</NOTE><TEXT>An Experimental Analysis Of The Performance Of Fourth Generation Tools On PCsThe majority of current PC-based database management systems (DBMS) arepackaged as Fourth Generation Language (4GL) systems.andP;  Ideally, 4GL systemsprovide facilities to allow non-technical users to easily describe, retrieve,maintain, and display data.andP;  Typically, 4GL systems offer friendly interfacesfrom which a user can either make selections from a menu, directly typecommands to be interpreted by the 4GL system, or embed commands in ahigh-level language.andM;Programs written in a Third Generation Language (3GL), such as COBOL, PL/I,and Pascal are substantially more complex than equivalent programs writtenwith a 4GL tool, in particular those related to the querying and maintenanceof databases.andP;  Data display is surprisingly complex and limited in most ofthe current PC 4GLs, and the degree of difficulty they offer is comparable tothe use of 3GL Report-Writers [18].andM;Most of the current PC-DBMSs offer some relational capabilities and supportnon-procedural languages that emphasize the simplification of the process ofuser-machine communication.andP;  A major source of influence for the actual 4GLsystems are Query By Example (QBE) [25] and Structured Query Language (SQL)[4, 7] query languages.andP;  These two high-level languages are based on therelational model of data [8, 7].andP;  In general, they can be used on-line toformulate interactive queries, or they can be embedded into programs thatmake calls to the resident DBMS system.andM;Since the early arrival of 4GL systems, it has been noted that thesimplification of the process of program writing produces inefficient codewith high levels of input/output overhead.andP;  This overhead occurs because 4GLtools take care of the low-level file operations, and the user has little (ornothing) to say about the physical organization of data and applicable accesstechniques.andM;The 4GL tools have become important elements for problem solving on both PCsand mainframes, and use of these tools has contributed significantly tosoftware productivity.andP;  Several mainframe and mini-based 4GL systems (FOCUS,INGRES, INFORMIX) have been adapted to the PC environment.andP;  Others are nativeto PCs (dBASE, RBASE, CONDOR, PARADOX), and several are now migrating tolarger configurations.andP;  The cycle ofdesign-prototype-debug-implement-maintain has been reduced and simplifiedwith the use of 4GL tools, compared to conventional development based on 3GLlanguages.andP;  Even though the benefits of a 4GL are many, there is majorconcern with the efficiency of the final products they generate.andP;  The pointis, how much execution performance is sacrificed when a 4GL system is usedinstead of a 3GL?andM;The purpose of this article is to measure and evaluate (experimentally) thedifferences in execution time between retrieval/maintenance programs writtenwith a 3GL (cobol [20]) tool against that of equivalent programs written with4GL systems, specifically, ORACLE [19], INFORMIX-4GL [14], CONDOR [10],PARADOX [1], dBASE [12], RBASE [16], and PC-FOCUS[13].andP;  The COBOL compiler[20] is a relatively high performance implementation [15] and includes itsown ISAM file system.andM;We want to emphasize that our goal is to explore the relative performancecharacteristics of the various systems on a set of simple but commonly useddata processing tasks.andP;  We are attempting to probe the performance of 4GLtools realizing that the systems tested represent an instant in a changingscenario in which new and improved versions of these products areperiodically released.andP;  Our goal is not to generate absolute performancefigures for the given hardware or software; it is to explore the generalperformance characteristics of a group of 4GL software and to provide someinsights into an area where little information exists.andM;EXPERIMENTAL SETUPandM;An inventory database containing information about SUPPLIERs and PARTs, andcurrent STOCK is used to study 4GL performance.andP;  The database schema is shownin Table I.andP;  Records in the database are randomly generated.andP;  The size of thedatabase is changed from a few records to several thousand entries.andP;  Table IIindicates the sizes of samples used.andM;Larger file sizes of 10,000 and 20,000 &quot;Part&quot; records were also tried but arenot included here since some of the 4GLs did not complete some of the queriesin the maximum alloted time of one day.andP;  A set of programs was written toquery and update the inventory database.andP;  As indicated in Table III, the testprograms are grouped in four categories: (a) relational queries, (b)file-oriented operations, (c) record retrieval operations, and (d) datamaintenance.andM;The hardware consists of an IBM PS/2 16 megahertz, one wait-state, model 80computer, running under a DOS 3.30 operating system with two megabytes ofmain memory and a seventy megabyte hard disk with an average seek time of 29milliseconds.andP;  An indicator of system speed is that the Norton ComputingIndex for the cpu is 17.6 when compared to an IBM PC/XT, a Disk Index of 3.2,when compared to the XT hard disk, and an overall performance index of 12.8over the XT.andP;  There was no disk caching in effect, and the memory beyond 640kilobytes was not in use because none of the 4GL systems was capable of usingthis extended memory.andM;Each query was written as a stand-alone batch file, and timestamps wererecorded before and after query execution.andP;  Each result expresses the elapsedtime it takes to answer the query and write the results to a disk file.andP;  Codewas written by the same users after having a similar training period witheach one of the systems.andM;Relational QueriesandM;All the selected 4GL systems support the concept of tables (with possiblyduplicate rows), and all are (at least) minimally relational [9, 11].andP;  Thisimplies that they implement some forms of the operators (a) Projection, (b)Selection, and (c) Join.andP;  To enforce a higher relational environment, weadded Union and Difference to the list of basic operators and also requirethat relations be treated as a collection of unique rows without duplicaterecords in the same table.andM;The operators tested in our experiment are the minimal set of building blocksrequired to construct relational queries.andP;  The selection of this group ofoperators is driven by the concept of relational completeness originallyintroduced by [9], which states that any language able to simulate the fiveprevious operators has the same expressive power of relational algebra (wehave replaced cartesian-product by more general join operators).andM;The PROJECTION operator is used to extract unique values from column(s) of atable.andP;  SELECTION picks out all those records satisfying a given condition.andO;These two operators are primitively supported by all systems studied here.andO;In all the 4GL system used the syntactical constructs are very simple tohandle.andP;  For instance, query Q2 (see Table III) can be expressed in SQL querylanguage (ORACLE,INFORMIX) as: SELECT Part# FROM PART WHERE PartWeight [isless than] 700 The same query expressed in dBASE III is: USE PART LIST Part#FOR PartWeight [is less than] 700andM;In the relational database model, the semantics of the projection operatorrequired that a relation be reduced to a vertical subrelation and that anyduplicates introduced as a side effect be eliminated.andP;  Not all 4GLs studiedoffer versions of the &quot;REMOVE DUPLICATES RECORDS&quot; command.andP;  For those notsupporting detection/removal of duplicate rows (dBASE, COBOL, CONDOR) weapplied the following elimination mechanism: (a) Sort the resulting table.andO;(b) Sequentially visit each record: if a record is equal to the previous onethen mark it for elimination.andP;  (c) Copy to a new resulting file those recordsNOT marked for elimination.andM;Better techniques for duplicate removal have been reported [5], but the oneselected here is probably the simplest.andP;  Notice that most operating systemsand database systems already provide an external sort facility.andP;  An importantaspect of the projection operator is its high cost (directly related to thesorting of the file).andP;  Most DBMS query evaluations that involve projection donot always eliminate duplicate records immediately.andP;  In general they are keptand carried along in subsequent operations.andP;  It is only after the finaloperation in a query evaluation that duplicates are removed.andP;  This mechanismis simple to support but has the drawback that immediate operations may havea higher cost because of the inclusion of unnecessary repetitions of the samerecords.andP;  We have chosen to associate the projection operator with theimmediate removal of duplicates.andM;UNION and DIFFERENCE are operations not directly supported by the surveyedsystems.andP;  UNION refers to the concatenation of two tables having the samedefinition.andP;  The result contains unique tuples (records) from one or theother (or both) tables.andP;  The following SQL fragment to implement union ofSupplier table to itself (query Q3) is used in our evaluations.andM;INSERT INTO temporal (Sup#, Supstatus, Supcity, Supname)andM;SELECT * FROM Suppliers; INSERT INTO temporal (Sup#, Supstatus, Supcity,Supname)andM;SELECT * FROM Supplier; INSERT INTO result (Sup#, Supstatus, Supcity,Supname)andM;SELECT DISTINCT * FROM temporal;andM;In other systems, UNION is implemented using APPEND table to table, which iswidely supported, and then eliminate duplicates (using the removal mechanism)just described).andM;DIFFERENCE is the operation in which two tables with similar structures arecompared.andP;  Those tuples present in just the first table, but not the secondone, are brought out to the output.andP;  For the SQL-based systems (ORACLE,INFORMIX) we use the following fragment to implement the difference operatorthat subtracts Part tuples from an identical copy of Part file (query Q4)andM;INSERT INTO temporal (Part#, PartWEight, PartColor, PartDesc)andM;SELECT  * FROM Part; SELECT  * FROM Part WHERE  Part# NOT IN (SELECT Part#FROM temporal);andM;JOIN is a merging operator that can horizontally concatenate tuples from twoor more tables that match a given joining condition.andP;  Query Q5 (Table III)combines tuples from STOCK table with those from PART table having the samePart#.andP;  The SQL syntax for query Q5 is SELECT Part.*, Stock.* FROM  Part,Stock WHERE Part.Part# = Stock.Part#andM;The term Part.* (Stock.*) indicates that all attributes from the Part (Stock)table are considered in the output.andP;  The JOIN operator is supported by allsystems, although some 4GLs only implement limited versions of equi-joins(i.e., the matching condition MUST be equality).andM;File OperationsandM;Sorting a file and creating an index are two common file operations.andP;  In apure relational system, where records are retrieved by key rather thanrelative positions, sorting becomes less important.andP;  Nonetheless, it isuseful in producing output files to be exported to other systems or as partof the preprocessing of data to be fed to report writers.andP;  With the oneexception of ORACLE, all systems studied here allow sorts on combinations ofascending/descending groups of attributes.andM;Index creation is typically preliminary to fast searching operations.andP;  Indexcreation/maintenance is a critical factor in relational systems.andP;  In general,record selection is driven by retrieving specific values of a field for whichan index may be available.andP;  All the 4GL systems analyzed support creation ofone or more indices using a unique key (primary indices).andP;  With the exceptionof PC-FOCUS they also allow indexing on non-unique keys (secondary indices).andM;Queries Q6 and Q7 are included to estimate these important aspects of fileoperations.andP;  Q6 sorts the PART table on ascending values of the key Part#,and query Q7 uses the same key attribute, Part#, to create a primary indexfor the PART table.andM;Record RetrievalandM;Queries Q8A and Q8B are used to evaluate what in the COBOL environment isknown as Sequential file access and Index-sequential (ISAM) file access,respectively.andP;  Query Q9 is used to test the response of the retrieval systemsto a more selective access path involving an ISAM file and a secondary index.andM;Query Q8A implements a complete sequential scan on the PART table.andP;  Nouser-created index is employed in this query.andP;  Each part record is read afterthe previous one, and its weight value is added to an accumulator.andP;  Query Q8Brepeats the same scanning of Q8A, but a Part# index is activated.andP;  Nospecific actions to force the searching into the index are provided in any ofthe 4GL systems.andP;  Thus, it is left to the 4GL system to detect and use theindex.andP;  The times reported in the Appendix correspond to the scanning phaseof PART table; creation of the index is not included in the total time toanswer Q8B.andM;The measure of the sensitivity to alternative access paths that can be usedto answer a select query is attempted with Q9.andP;  A secondary index onattribute PartColor is created and left in active status; then, query Q2 isrepeated.andP;  Presumably, this query should now take into account the existenceof this secondary index in order to reduce the execution time.andP;  A total often different colors were uniformly assigned to the different stored parts.andO;Therefore, at most, 10 percent of the part records (those with the colorblue) should be retrieved.andP;  This reduction of the search space should bereflected in the total time required to answer query Q9 (time to generate thecolor index is not included in Q9).andM;Data MaintenanceandM;Even though the relational database model [9] does not provide explicitdefinitions for maintenance operators, it is clear that a major aspect in thelife of a database system is the updating of the stored data.andP;  In order tomaintain the data, the operators MODIFY, DELETE, INSERT are also incorporatedin our set of basic building blocks.andP;  The COBOL implementations of the updateoperators are based on an ISAM file for which a primary index on the keyattribute Part# is available.andM;A total of 10 percent of the part records keys (Part#) are randomly extractedfrom the PART file and stored in a transaction table.andP;  All active indices aredropped, and an update process driven by the data stored in the transactionfile is initiated.andP;  First, with the modify query Q10 the Part# values storedin the temporal file are used to modify the color field of each matching PARTrecord (color value is changed to red).andP;  Second, the delete query Q11 is usedto delete from PART table each record whose Part# key is contained in thetransaction file.andP;  Finally, the insert query Q12 inserts into PART tablerecords whose keys are stored in the temporal file.andM;ANALYSIS OF RESULTSandM;In this section, we discuss the execution time performance of the different4GLs and the equivalent COBOL programs necessary to implement the operationsindicated in Table III.andP;  For each one of these queries, the best 4GL timeexecution is selected and contrasted to that of COBOL, and the (COBOL_time:4GL_best_time) performance ratio is computed.andP;  The Appendix summarizes theexecution times of COBOL and individual 4GL systems.andM;The entire set of measurement results is shown in the Appendix.andP;  In addition,a number of graphs and bar charts derived from the data will be presented aswe describe the results for each of the 13 queries.andM;Execution of Relational QueriesandM;Figure 1 shows the results of implementing the relational algebra operators(queries Q1 to Q5).andP;  It can be seen that three out of five operators runfaster in 4GL environments than the custom made COBOL programs.andM;Projection query Q1 takes two columns from the SUPPLIER file and produces alist of unique pair combinations.andP;  The best 4GL for this operation isPARADOX, which consumes a total of 55 seconds for all combionations of thefirst seven database file sizes.andP;  For the same combination of file sizesCOBOL takes 13 seconds to execute, which is 81 percent less than the best4GL.andP;  Thus, the performance ratio COBOL/4GL for Q1 is approximately 1:4.andO;This result was to be expected.andP;  Notice also that Figures 2 and 3 show afaster Sort operation and sequential scan in COBOL.andP;  Both operations arerequired to produce the resulting pairs of values and eliminate duplicates.andO;We speculate that the better COBOL performance is based on (a) contiguousrecord allocation, (b) larger I/O buffers, and (c) double buffering.andP;  Thefirst assumption implies that the physical ordering of records matches thelogical arrangement of records in the file.andP;  Thus, COBOL does not require aslow pointer-based fetching mechanism to get access to the next record.andP;  Thesecond assumption indicates that because of the relatively small size of theCOBOL program Q1 (compared to the large memory requirements of DBMS engines)more free memory can be used for Input/Output: the default for our COBOL istwo 4 kilobyte I/O buffers per file.andM;The COBOL implementation of the selection query Q2 is twice as fast as thebest 4GL (PARADOX, in this case).andP;  No indices were used by the programs.andP;  Aqualified sequential scan is employed to collect the unique part recordssatisfying the conditions (PartColor = Blue) and (PartWeight [is less than orequal to] 700).andP;  The dominant factor is the speed of the sequential scanwhich, as indicated before, is significantly faster in COBOL than in anyother 4GL system (see Q8A in Figure 3).andP;  Notice that the selection predicateonly involves subformulas patterned after (attribute = constant)construction, where the attributes PartColor and PartWeight are not primarykeys.andM;In order to test the effect of using an index for the attribute, we createdan index on the non-primary key PartColor and then repeated the execution ofquery Q2 (index-creation is not part of the reported times).andM;Figure 4 shows how some 4GLs can take advantage of secondary indices toimprove their execution of selection query Q2.andP;  RBASE and CONDOR reduce thesearch time by 54 percent and 60 percent, respectively.andP;  On the otherextreme, dBASE, PARADOX, ORACLE, and INFORMIX have a higher overhead.andP;  Theyconsume more time to execute Q2 when the secondary index on PartColor isactive.andP;  The relative performance ratios are 1:4, 9:11, 2:3, and 1:3,respectively.andP;  The significant improvement in RBASE and CONDOR suggests theadvantage of creating/maintaining secondary indices whenever queriesinvolving a non-primary key are frequently used.andM;Figure 5 show how the addition of the secondary color index causes RBASE toperform almost as fast as a sequential COBOL search for small samples andeven better than COBOL for larger file sizes.andP;  COBOL performance on an ISAMfile having a secondary color index is also illustrated.andP;  This implementationis twice as fast as the RBASE execution for files that contain less than 2000records.andP;  After this point, COBOL performance begins to degrade and reaches apoint in which RBASE is again faster (with more than 5000 records).andM;The difference query (Q3) and union query (Q4) have a similar pattern.andP;  Inboth cases the 4GL result is better than COBOL by a 3:2 performance ratio.andO;In query Q4, the SUPPLIER table and an exact copy of these supplier recordsare combined.andP;  Clearly, each record is repeated, and the extra copy must beeliminated.andP;  The dominant cost in the execution of Q4 is, therefore, theelimination of repeated records.andP;  The best 4GL for Q4 is PARADOX, whichdirectly supports the insertion of distinct tuples in a file.andP;  The worst caseis offered by RBASE which is about two hundred times slower than COBOL.andM;In the difference query Q3, two input data sets are compared, and thenonmatching records from the first file are stored in a Result table.andP;  QueryQ3 is implemented in COBOL using a modified Sort-Merge algorithm.andP;  TheSupplier table and an exact copy of supplier records are used as input files.andO;After sorting the input tables a record from each file is read.andP;  If no matchfor the first record is found, this is sent to the output file.andP;  Otherwise,pointers are properly advanced to access next records, and the process isrepeated.andP;  Clearly, the result of this operation on the given input must bean empty table.andP;  The best 4GL for Q3 is CONDOR with a 3:2 performance ratiobetter than COBOL.andP;  Whereas, the worst case is found in dBASE which is aboutseven hundred times slower than COBOL.andM;The join query Q5 illustrates the relational mechanism used to combine two ormore tables by matching values of a given attribute.andP;  In the case of COBOL,the join operator is typically implemented using a straight Sort-Merge or aNested-Loop algorithm [6, 21].andP;  In this test, the nested-loop method with anauxiliary index was used.andP;  Each STOCK record is sequentially read and thePart# value is used to search the index for a matching PART record.andP;  Theprocess is repeated until no more stock records are left.andP;  The time to createthe index is not considered in the resulting time table.andM;An interesting finding in this experiment is that the response of some4GL-DBMSs to the Join operator competes with the COBOL code described above.andO;PARADOX is about six times faster than COBOL, and CONDOR is only twice asslow as COBOL.andP;  On the other extreme the other systems are about forty timesslower than COBOL.andP;  We speculate that the fast response from PARADOX andCONDOR come from hidden indices on primary keys associated with each file.andO;Note that Part# is the primary key in PART file and is a component of theprimary key in STOCK table.andM;Figures 6 and 7 show the asymptotic time behavior of the join operator forthe different database file sizes.andP;  As the size of the data file grows theexecution increases at a non-linear rate.andP;  Systems are shown in two groups:&quot;fast&quot; and &quot;slow,&quot; according to the time they need in implementing the joinoperation for the PART and STOCK tables.andP;  ORACLE becomes notably slow for aSTOCK file containing more than 2000 records.andP;  The other systems have a moremoderate rate of increase.andM;Execution of File OperationsandM;Figure 2 shows the results of Sort and Create Index operators (Q6 and Q7,respectively).andP;  In both cases COBOL execution is faster than 4GLs.andP;  The best4GL for sorting and indexing is PARADOX which shows a ratio of 3:7 forsorting and 2:3 for indexing.andP;  We have already shown that, in some cases,indices accelerate the searching process (Figure 4), but, in some 4GLsystems, the presence of active indices may affect the search time in anadverse way.andM;Figure 8 shows the comparison of a sequential scan on the entire PART filewhen (a) no user created index is active and (b) there is a primary index onPart# opened at the time of scanning the file.andM;As expected, the COBOL sequential scan of a sequential file is much fasterthan the sequential scan of an indexed (ISAM) file.andP;  The sequential versusindexed-sequential COBOL ratio is 3:97.andP;  This result indicates that it onlytakes 3 units of time to sequentially read the whole file whereas it takes 97units to do the same for an Indexed file.andM;In other systems, the difference is not as dramatic and may even go the otherway.andP;  In CONDOR, the presence of the primary index actually improves thesequential retrieval of records.andP;  PARADOX and ORACLE are slightly fasterdoing a sequential scan without an index.andP;  RBASE and dBASE have a behaviorsimilar to COBOL where sequential access without indices is much faster.andM;Execution of Record Retrieval OperatorsandM;Figure 3 compares the performance of COBOL and the fastest 4GL (CONDOR, inthis case) in accessing a file sequentially from beginning to end versusaccessing the file randomly with as many accesses as records in the file.andP;  Asdiscussed previously, COBOL has a much better ratio for sequential accessthan the fastest 4GL (2:3).andP;  On the other hand, COBOL is considerably slower(1:10) than the fastest 4GL for random access.andM;Execution of Data Maintenance OperatorsandM;Queries Q10, Q11, and Q12 implement Modify, Delete, and Insert operators,respectively.andP;  In order to test the speed of these operators, 10 percent ofthe part numbers are randomly selected and stored in a transaction file.andP;  TheCOBOL implementation is based on an indexed-sequential PART file which ismodified according to the data stored in the transaction file.andP;  A primaryindex on Part# was also used in each 4GL to improve the access to the set ofselected records.andM;The modify query (Q10) reads a record from the temporary file and changes thecolor of the part record whose key is indicated in the transaction record tored.andP;  A similar procedure is used for the other update operators.andP;  Modifyoperator is slightly faster in the COBOL program than in the fastest 4GL(RBASE, in this case) showing a 9:11 performance ratio.andP;  The other operatorsQ11 (delete) and Q12 (insert) are faster in RBASE and PARADOX, showingperformance ratios 11:8 and 4:1, respectively (as shown in Figure 9.)andM;Our experiments indicate that, overall, it is faster to update a databasefile from the 4GL environment rather than the COBOL-ISAM file.andM;CODE SIZE AND DEVELOPMENT EFFORTandM;Important criteria for choosing a software language or tool is the amount ofcode that needs to be written for a given task and the human effort requiredfor programming.andP;  In developing the queries for the various 3GL and 4GL toolsfor this study, we did not try to directly measure development time for thefollowing reasons: (1) the authors were very familiar with some tools but notat all familiar with others; (2) the test queries were mostly very shortwhere the time it takes to learn to use a given tool would have totallyovershadowed the development time.andM;Misra and Jalics [17] have, in another study, focused on development time fora somewhat larger parallel development involving COBOL, dBASE III, andPC/Focus.andM;Figure 10 shows the total volume of source code generated in theimplementation of queries Q1-Q12 using COBOL and 4GL systems.andP;  The sizes arequoted in characters rather than the more typical lines of code because in anumber of the 4GL tools the concept of lines is either absent or not clearlydefined.andP;  Also, we have tried to equalize the basis for counting charactersso that oddities like the first six columns being unused in COBOL areeliminated from the count.andM;COBOL code appears to be from 11 to 22 times as large as the equivalent 4GLprograms.andP;  Furthermore, the relative sizes among the 4GL tools vary by nomore than a factor of 2.andP;  The COBOL source code for the queries is about 17times as large as the average 4GL code.andP;  We feel that one would need a largersample containing more and larger programs before drawing more detailedconclusions about relative code sizes.andP;  One thing is clear, however, 4GLtools produce substantially smaller code sizes, which has several kinds ofimplications for software development and maintenance.andM;While we cannot draw precise conclusions about development time, it isprobably the case that it takes substantially more time to develop softwarethat consists of 10 to 20 times as much code as another that accomplishes thesame task.andP;  Studies by Walston-Felix [24] and others have shown that aprogrammer can write a certain number of lines of code per day, regardless ofthe programming language.andP;  Halstead [12] has attempted to quantify therelationship between code volume and programming effort and has found it tobe a linearly increasing function for a given language.andP;  Both of thesestudies support our perception that while no precise conclusions are in orderbased upon such a small sample, development time is likely to be amonotonically increasing function of code size.andM;CONCLUSIONSandM;We have implemented and measured the execution time of a set of operations on4GL systems to seek insights into their relative performance.andP;  One result ofour work is a set of performance benchmarks consisting of thirteen differentfunctions.andP;  Each tries to measure some aspect of database operations.andM;The benchmark is simple enough so that one can easily implement it in any 4GLsystem, yet it offers substantial information about the suitability of agiven 4GL tool for specific kinds of tasks.andP;  Such experimentation isespecially important in 4GL systems which are often outstanding tools if theymatch the application envisioned, and disastrous or impossible for otherapplications.andP;  Note that such experimentation is of much less importance in3GL tools which are typically more complete and open-ended, so there islittle question that a given tool can be applied to any problem.andM;From the implementations, it seems clear that 4GL systems do offer a muchhigher-level programming environment.andP;  4GL code is easier to produce, debug,and maintain than the equivalent COBOL programs.andP;  COBOL performance is betteroverall than 4GL systems, but we have identified several operations in which4GLs perform better than COBOL programs, specifically, relational union,difference, join, and insert/delete record.andM;Performance ratios are mixed.andP;  For instance, the largest advantage in favorof COBOL is 1:4 for sequential scan, but for joins, the ratio is 6:1 in favorof 4GLs.andP;  Also interesting is that, in some cases, the inclusion ofsupporting indices can accelerate the searching process and match the COBOLperformance.andP;  For instance, query Q9 uses a secondary index to improve thefast COBOL sequential scan.andP;  Note that the select query does not needmodification of syntax in any of the 4GL queries.andP;  Some systems detect thepresence of the index and implement an index driven access path.andP;  Same can bedone from COBOL, but the user must program it manually.andM;There are tremendous performance differences among the various 4GLs.andO;Operators such as JOIN are hundreds of times faster in a given system than inothers.andP;  No one single 4GL product completely outperforms the others, anddifferent systems are better suited for different operations.andP;  For example,PARADOX and CONDOR are very fast, but CONDOR lacks a programmable environmentin which relational operators can be nested in a conventional 3GL language.andO;PARADOX is not available in either mini or mainframe configurations.andP;  ORACLEand INFORMIX are available for PCs and mid-range computers.andP;  ORACLE, however,is very slow, particularly in the execution of the join operator for largedata files, and INFORMIX has a complex prototyping interface.andP;  RBASE anddBASE are slow systems and are only available for PCs.andM;There are several facilities around 4GL systems that make them attractive,such as logical (rather than physical) data manipulation, non-proceduralretrieval sub-languages, screen-handlers, user-friendly report writers,on-line/off-line programming capabilities, and data import/export/exchangefacilities.andP;  Also, most of the 4GLs are actively being further developed sothat we are likely to see performance improvements.andM;The final conclusion is obvious: PC based 4GL systems are an efficient yetsimple tool for small database applications.andP;  4GL packages are, in manycases, a better choice than 3GL ones and, contrary to the common assumption,their simplicity may not seriously have to compromise their efficiency interms of execution time.andM;REFERENCESandM;[1] Ansa Software.andP;  PARADOX User's Guide, Release 1.1.andP;  Belmont, Calif.,andO;1986.andM;[2] Ashton-Tate, Co.andP;  dBASE III Plus Programming Manual.andP;  1985andM;[3] Astraham, M., et al.andP;  System R: A relational approach to databasemanagement.andP;  ACM Trans.andP;  Database Syst.andP;  1, 2 (June 1976), 96-137.andM;[4] Astraham, M., and Chamberlin, D. D.andP;  Implementation of a structuredEnglish query language.andP;  Commun.andP;  ACM 18, 10 (Oct.andP;  1975), 580-588.andM;[5] Biton, D., and DeWitts, D. Duplicate record elimination in large datafiles.andP;  ACM Trans.andP;  Database Syst.andP;  8, 2 (June 1983), 255-265.andM;[6] Blasgen, M. W., and Eswaran, K. P.andP;  On the evaluation of queries in arelational data base system.andP;  IBM Res.andP;  Rep.andP;  RJ-1745, 1976.andM;[7] Chamberlin, D. D., et al.andP;  SEQUEL 2: A unified approach to datadefinition, manipulation and control.andP;  IBM J. Res.andP;  Devel.andP;  20, 6 (1976),560-575.andM;[8] Codd, E. F.andP;  Extending the database relational model to capture moremeaning.andP;  ACM Trans.andP;  Database Syst.andP;  4, 4 (Dec.andP;  1979), 397-434.andM;[9] Codd, E. F.andP;  Relational completeness of database sublanguages.andP;  InCourant Computer Science Symposia, N6, Database Systems.andP;  Prentice-Hall, NewYork, 1972.andM;[10] Candor Computer Corp.andP;  Condor 3.andP;  Ann Arbor, Mich., 1986.andM;[11] Date, C. J.andP;  An Introduction to Database Systems, 3d ed.andO;Addison-Wesley, Reading, Mass., 1981.andM;[12] Halstead, M. H.andP;  Elements of Software Science.andP;  Elsevier, New York,1977.andM;[13] Information Builders Co.andP;  PC-FOCUS Release 2.0 Reference Manual, NewYork.andM;[14] Informix Software Corp.andP;  INFORMIX-4GL Version 1.00 Reference Manual.andO;Menlo Park, Calif., 1986.andM;[15] Jalics, P.andP;  COBOL on a PC: New perspective of a language and itsperformance.andP;  Commun.andP;  ACM 30, 2 (Feb.andP;  1987), 142-154.andM;[16] Microrim Inc.andP;  RBASE System V Version 1.1--User's Manual.andP;  Redmond,Wash., 1986.andM;[17] Misra, S., and Jalics, P.andP;  A case study in third vs.andP;  fourth softwaredevelopment.andP;  IEEE Softw.andP;  15, 4 (July 1988),andM;[18] Misra, S., Matos, V., and Jalics, P.andP;  Nonprocedural report generationusing 4GL tools.andP;  In Proceedings of the International Business SchoolsComputer Users Group (Ohio, July).andP;  1988.andM;[19] Oracle Co.andP;  ORACLE Programmers Guide, Version 4.0.andP;  Menlo Park, Calif.,andO;1984.andM;[20] Realia Co.andP;  Realia-COBOL Version 3.0--User Manual.andP;  Chicago, Ill., 1987.andM;[21] Selinger, P. G., et al.andP;  Access path selection in a relational databasemanagement system.andP;  In Proceedings of ACM SIG-MOD International Conference onManagement of Data (Boston, May 30-June 1).andP;  ACM/SIGMOD, New York, 1979, pp.andO;23-34.andM;[22] Stonebraker, M., et al.andP;  The design and implementation of INGRES.andP;  ACMTrans.andP;  Database Syst.andP;  1, 3 (Sept.andP;  1976), 189-222.andM;[23] Ullman, J.andP;  Principles of Database Systems.andP;  Computer Science Press,1982.andM;[24] Walston, C. E., and Felix, C. P.andP;  A method of programming measurementand estimation.andP;  IBM Syst.andP;  J. 16, 1 (1977), 54-73.andM;[25] Zloof, M. M.andP;  Query-by-example: A database language.andP;  IBM Syst.andP;  J.andO;(1977).andM;VICTOR M. MATOS is currently an assistant professor of computer andinformation science at Cleveland State University.andP;  His research interestsinclude statistical database design, software-performance, and the study ofmicrocomputer-based applications.andM;PAUL J. JALICS is professor of computer and information science at ClevelandState University.andP;  His research interests include operating systemperformance, program portability, the performance of user applicationprograms, and the functionality and performance of fourth generationlanguages.andP;  Authors' Present Address: Computer and Information ScienceDepartment, Cleveland State University, 2121 Euclid Ave., Cleveland OH 44115.andO;</TEXT></DOC>