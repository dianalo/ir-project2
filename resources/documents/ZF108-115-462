<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-115-462  </DOCNO><DOCID>08 115 462.andM;</DOCID><JOURNAL>Dr. Dobb's Journal  Dec 1989 v14 n12 p48(7)* Full Text COPYRIGHT Mandamp;T Publishing 1989.andM;</JOURNAL><TITLE>Writing correct software; assertion and exception techniques canaid in class correctness.andO;</TITLE><AUTHOR>Meyer, Bertrand.andM;</AUTHOR><SUMMARY>Reliability should be a concern of software publishers.andP;  TheEiffel programming language demonstrates how certain softwaredevelopment techniques can ensure reliability.andP;  Routines, likelegal contracts, consist of preconditions and postconditions.andP;  Toexpress the 'contract,' both sets of conditions must be integratedwith assertions.andP;  Documentation is another key application ofassertions.andP;  Eiffel offers a tool that yields a class ofdocumentation based on its assertion.andP;  Invariants must be ensuredby the Create of the class and preserved by every exported classroutine.andP;  Run-time assertion monitoring offers a debuggingmechanism.andP;  Assertions, however, are not a way to program specialcases.andP;  Exception mechanisms occur in certain situations.andP;  When anexception occurs, programmers can execute a rescue clause.andP;  Also,programmers can fine-tune Eiffel to further ensure reliability.andM;</SUMMARY><DESCRIPT>Topic:     ReliabilityProgramming InstructionObject-Oriented ProgrammingProgramming LanguagesPerformanceProgram Development Techniques.andO;Feature:   illustrationtablechart.andO;Caption:   Contract between a publisher and an author. (table)Circle intersection. (chart)A routine contract. (table)andM;</DESCRIPT><TEXT>Writing Correct SoftwareandM;My aim is designing Eiffel was to produce a major programming language forthe 1990s, catering to the needs of those software engineers willing to dowhat it takes to produce high-quality software.andP;  A key aspect of Eiffel,which makes it original in the world of object-oriented languages, and in theworld of programming languages at large, is its strong emphasis on techniquesthat help produce highly reliable software.andM;Although, there are many more aspects to Eiffel (including those described inmy book Object-Oriented Software Construction, Prentice-Hall, 1988) thereliability features deserve a presentation of their own.andP;  That is the focusof this article.andP;  I will show how it is possible to write software thatprogrammers (and users) can place a much higher degree of confidence in thanthat written with traditional techniques.andP;  In particular, I will discuss theall important notion of assertion -- the specification element includedwithin the software itself.andP;  This will lead to a systematic view of exceptionhandling, and a look at techniques (such as those offered by Ada) that I findsomewhat unsafe.andM;Why All the Fuss?andM;The issue is simple.andP;  It is great to have flexible software that is easy tobuild and easy to maintain, but we also need to be concerned that thesoftware does what it is supposed to do.andM;From reading most of the object-oriented literature, one would think this isnot a problem.andP;  Correctness concerns are hardly ever mentioned.andP;  Actually, itis unfair just to pick on object-oriented programming.andP;  Take any standardtextbooks you have on programming, algorithms, data structures, and similartopics.andP;  See how many of them list &quot;correctness,&quot; &quot;reliability,&quot; &quot;invariant,&quot;or &quot;assertion&quot; in their indexes.andP;  I have quite a few textbooks on my shelves,but could not find many that passed this simple test.andM;This apparent disregard for correctness issues cannot last forever.andP;  Evenbarring the occurrence of a major catastrophe resulting from faulty software,sooner or later someone will call the software engineers' bluff and ask themexactly why they think their systems will perform as announced.andP;  It isdifficult to answer that question convincingly given the current state of theart.andM;Eiffel won't provide the magical key to the kingdom of software reliability.andO;No existing method or tools will.andP;  I do believe, however, that the Eiffeltechniques are an important step in the right direction.andM;If you are expecting a sermon telling you to improve your software'sreliability by adding a lot of consistency checks, you are in for a fewsurprises.andP;  I suggest that one should usually check less.andP;  According toconventional software engineering wisdom, &quot;defensive programming&quot; isconsidered to be a programmer's best shot at reliability.andP;  I believe thatdefensive programming is a dangerous practice that defeats the very purposeit tries to achieve.andP;  To program defensively is one of the worst pieces ofadvice that can be given to a programmer.andM;That more checking can make software less reliable may seem foolish.andO;Remember, though, that in science common sense is not always the best guide.andO;If you have ever hit a wooden table with your fist, you probably found ithard to believe the physics professor who told you that matter is a set oftiny atoms with mostly nothing in-betweenandM;Expressing the SpecificationandM;The ideas that help achieve correctness in Eiffel are much older than Eiffelitself.andP;  They come from work on program proving and formal specification.andO;Oddly enough, research on these topics has remained estranged from most&quot;real-world&quot; software development.andP;  Part of the reason, at least in theUnited States, is the widespread view that formal specification andverification are specialized research topics whose application is mostlyrelevant to &quot;mission-critical&quot; software.andP;  Correctness, however, should be auniversal concern.andP;  Eiffel looked at specification and verification work tosee how much of it could be made part of a standard programming methodology.andM;Eiffel is a production language and environment.andP;  It is not a researchvehicle.andP;  Eiffel relies on the technology of the last part of the twentiethcentury.andP;  It has to work now.andP;  This means that no miracles can be expected.andO;In fact, the techniques are modest and almost naive.andP;  They are the result ofan engineering trade-off between what is desirable in an ideal world and whatcan realistically be implemented today.andP;  But they make a big difference and Ican't understand why no widespread language, other than Eiffel, has made anysignificant attempt in a similar direction.andM;The basic idea is rather trivial.andP;  Correctness is a relative notion.andP;  Nosoftware element is correct or incorrect per se; it is correct or incorrectonly concerning a particular specification, or statement of its purpose.andO;Correct elements cannot be written unless the time is taken to express all orpart of this specification.andM;Writing the specification will not guarantee that it is met.andP;  But thepresence of a specification, even one that is only partially spelled out,goes a surprisingly long way toward helping produce elements that satisfytheir correctness requirements.andM;This idea was captured by the title of an article by Harlan Mills, then ofIBM, published in 1975: &quot;How to Write Correct Programs and Know Why.&quot;andP;  If youare a serious software engineer, you don't just want to hope that yourprograms are correct because you have been careful, and done a lot oftesting, and so on.andP;  You need precise arguments that document the correctnessof your software.andM;In Eiffel, such arguments are expressed as assertions -- elements of formalspecification that can be attached to software components, classes and theirroutines.andM;The ContractandM;Let's look at routines first.andP;  A routine is the description of somecomputation on the instances of a class, made available by that class to itsclients (to other classes relying on its services).andP;  How do we specify thepurpose of a routine?andM;The view I find most helpful is that a routine provides clients with a way tocontract out for a certain task that the client's designer finds advantageousnot to implement within the text of the client.andP;  This is the same way that wehumans at times contract out for part or all of a task that we need toperform.andM;Human contracts have two important properties:andM;* Each party expects some benefits and is prepared to incur some obligationsin return.andP;  What is an obligation for one party is a benefit for the other.andM;* The obligations and benefits are spelled out in a contract document.andM;Figure 1 illustrates an example of a contract between a publisher and anauthor.andP;  The author's obligation is to bring in a manuscript before March1st.andP;  The benefit to the author is that the manuscript will be publishedbefore May 1st.andP;  The publisher's obligation is to publish the manuscriptbefore the second date.andM;The publisher is not bound by any obligation if the author violates his partof the deal.andP;  In such a case the publisher may still publish the manuscript,but does not have to.andP;  The situation is outside of the contract's bounds.andM;Routine as ContractandM;Specifying a routine is based on the transposition of these observations tosoftware.andP;  First, we need the equivalent of the contract document.andP;  Itbewilders me that no such concept exists in standard approaches to softwareconstruction.andM;The specification consists of two parts:andM;* The precondition of a routine states the obligations of clients, which arealso the benefits for the routine itself.andM;* The postcondition states the obligations of the routine, which are also thebenefits for the clients.andM;The precondition is a set of initial conditions under which the routineoperates.andP;  Ensuring the precondition at the time of any call to the routineis the clients' responsibility.andM;The postcondition is a set of final conditions the routine is expected toensure.andP;  Ensuring the postcondition at return time (if the precondition wasmet on entry) is the routine's responsibility.andM;The concept of a contract is one of the most useful aids to understandingEiffel programming.andP;  The role of contracts in Eiffel can be compared to whatmessage passing represents in Smalltalk.andM;Figure 3 illustrates this idea.andP;  The function intersect1 in a class CIRCLE(assumed to be part of some graphic package) returns one of the twointersecting points of two circles (see Figure 2).andP;  We will look at how toassociate the precondition and the postcondition to the text of the functionin the actual Eiffel class.andP;  In this example:andM;* The precondition is that the two rectangles should intersect.andM;* The postcondition is that the function result is a point that is on bothcircles.andM;Contract VariantsandM;This is not the only possible specification.andP;  Programmers may fee uneasyabout the just mentioned &quot;demanding&quot; form of the routine, which only works insome cases.andP;  Instead, a tolerant version implementing a different contractmay be designed.andP;  For example:andM;* There is no precondition.andP;  More precisely, the precondition is true, andautomatically satisfied by any client.andP;  Here, the routines will be applicablein all cases.andM;* The postcondition is more difficult to express in this case.andP;  Either thetwo circles intersect and the function result is a point on both circles; orthe two circles do not intersect, the function result is an arbitrary point,and an error message has been displayed somewhere.andP;  The awkwardness ofstating the postcondition in such a way is the first sign of why &quot;demanding&quot;versions are often better.andM;Expressing the ContractandM;Let's see how the preconditions and postconditions will be integrated.andO;Listing One, page 125, shows what a class CIRCLE might look like.andP;  Assume theavailability of a class POINT describing points, and a function distance,such that p1.distance (p2) is the distance between any two points (p1 andp2).andM;Result is a predefined variable which, in a function, denotes the result ofthat function.andP;  Create is the initialization procedure.andP;  It is automaticallyexported.andM;The precondition of a routine, if any, is given by the require clause.andP;  Thepostcondition is given by the ensure clause.andP;  Preconditions andpostconditions are assertions -- logical constraints expressed as one or moreBoolean expressions, separated by semicolons.andP;  They are essentiallyequivalent to Boolean ANDs, but allow assertion components to be identifiedindividually.andP;  These components can be tagged for even better identification.andO;For example, consider Listing Two, page 125.andM;Note that the first clause in this precondition (as well as clauses in thepreconditions of inside and outside) express that the argument must benon-void.andP;  Void is a predefined language feature expressing whether there isan object associated with a certain reference.andM;Uses of AssertionsandM;Along with invariants (discussed later), preconditions and postconditionsplay a fundamental role in the design of Eiffel classes.andP;  They show thepurpose of routines and the constraints on their uses.andP;  A brief look at anywell-designed set of Eiffel classes shows how wide their application is.andP;  TheBasic Eiffel Library, which covers fundamental data structures andalgorithms, is an example of a set of carefully designed classes that comefully loaded with expressive assertions.andM;The first application of assertions, perhaps the most powerful, is as aconceptual design aid for producing reliable software.andP;  In this role,preconditions and postconditions directly support the goal stated earlier:Writing correct software and knowing why it is correct.andP;  When a routine iswritten, its goal (contract) is expressed.andP;  If this goal cannot be expressedin a formal way, it should still be expressed as formally as possible.andM;Documentation is another key application of assertions.andP;  One of the mostpervasive myths of software engineering literature is the idea thatdocumenting software is a worthy goal.andP;  Instead, documentation should beviewed as an evil, made necessary by the insufficient abstraction level ofcurrent tools, techniques, and languages.andP;  It is an evil not just becausedocumentation is tedious to produce, but also because it is almost impossibleto maintain the consistency of a software system with its documentationthroughout the system's evolution.andP;  Incorrect or out-of-date documentation isoften worse than no documentation at all.andM;In an ideal world, software should be self-documenting, with no need foroutside documentation.andP;  Failing this programmer's Eden, we should strive tohave as little need for external documentation as possible.andP;  Documentationshould be deduced from the software itself.andP;  &quot;Self-documenting software&quot; doesnot mean that the software is its own documentation.andP;  Instead,self-documenting software should contain part, or (ideally) all, of itsdocumentation, corresponding to various levels of abstraction, which can beextracted by automatic tools.andM;Preconditions and postconditions play a key role because they document theessential properties of routines: What each routine expects and what eachensures in return.andP;  The Eiffel environment provides an automatic tool thatyields the documentation of a class based on its assertion.andP;  This tool, theclass abstracter, is implemented by a command called &quot;short.&quot;andP;  Applying shortto a class yields the description necessary to determine whether the classcan be used in a certain situation, and, if so, how to use it effectively.andM;The result of short applied to class CIRCLE would be of the form shown inListing Three, page 125.andM;As shown in this example, short keeps, as a complement to formal assertions,the natural language header comments of routines, if present, at awell-defined place.andP;  Only exported features are kept by short.andM;short provides documentation &quot;for free&quot; -- it is extracted from the software.andO;short is the major tool for documenting Eiffel classes.andP;  A companion tool,good, produces high-level system documentation in graphic form, showing theclass structure with client and inheritance relationships.andP;  Remember, though,that short is meaningless without the presence of assertions in the language.andM;InvariantsandM;Preconditions and postconditions can be used in a non-object-orientedcontext.andP;  Another use of assertions that is inseparable from theobject-oriented approach is the class invariant.andP;  This is an optional clauseof Eiffel classes.andP;  An invariant is a consistency constraint that applies toall instances of the class.andM;In the CIRCLE example, the invariant clause might state the followingassertion:andM;radius [is greater than] = 0; inside (center)andM;In larger examples the invariants can be much more extensive.andM;Invariants can be viewed as general clauses that are implicitly added to allcontracts of a certain class, without being expressly repeated for each ofthese contracts.andP;  The precise definition of the class invariant is that it isan assertion that:andM;* Must be ensured by the Create of the classandM;* Must be preserved by every exported routine of the classandM;In principle, we could do away with the invariant by adding its clauses tothe precondition and postcondition of every exported routine, and to thepostcondition of the Create.andP;  But, besides making these assertions undulyrepetive, this would be losing sight of the role of the invariant as a globalintegrity constraint on the class, independent of a particular routine.andM;The two properties used earlier to define the invariant imply that theinvariant is satisfied in all observable states in the life of every instanceof the class.andP;  Observable states are those immediately following the Create,and before and after applicaiton of exported routines.andP;  The life of a typicalobject is pictured in Figure 4, with observable states marked as squareblocks.andP;  The idea of an observable state is important in the context ofparallel programming.andM;In spite of its name, an invariant is not necessarily satisfied at all times.andO;It may be temporarily violated during execution of exported routines, so longas it is restored for the next observable state.andM;An invariant captures the semantic properties of a class, independently ofits current implementation, by a set of attributes and routines.andP;  Theseproperties must be understood in a software engineering context in whichsoftware is always subject to change.andP;  Invariants can help bring some orderto a constantly changing environment by expressing what does not change in aclass--the basic semantics of the class.andM;Invariants can play a major part in establishing a scientific basis forsoftware activities that currently rest on a rather shaky basis: Qualityassurance, regression testing, and maintenance.andP;  Because an invariantexpresses the essential semantics of a class that should be preserved throughsuccessive modification and extension, it provides a framework for making QAand associated activities more systematic.andM;Limitations of AssertionsandM;The Eiffel assertion techniques are only partial.andP;  The assertion sublanguageis based on Boolean expressions with some extensions.andP;  Sometimes more isneeded, such as first-order predicates.andP;  In the CIRCLE class it would be niceto have the invariant express that no point can be both inside and outsidethe circle, or that any such point must also be &quot;on&quot; the circle.andP;  Thenotation for this could be:andM;for p: POINT then inside (p) and outside (p) implies on (p) endandM;This is not possible in current Eiffel, although properties involvingquantifiers (&quot;for all,&quot; &quot;there exists&quot;) can sometimes be expressed throughBoolean expressions involving function calls.andP;  These function calls requiresome care.andP;  Other limitations of assertions are due to the reference-baseddynamic model used for objects.andM;The mechanism is the result of an engineering trade-off.andP;  Though limited,assertions are a tremendous asset in Eiffel programming.andM;Assertions and InheritanceandM;Assertions also play an important role in the context of inheritance.andO;Invariants are always inherited.andP;  When a routine is redefined, itsprecondition may be weakened, but not strengthened.andP;  Its postcondition may bestrengthened but not weakened.andP;  To understand these rules, the contractingmetaphor must be viewed in the context of inheritance, redefinitioin(subcontracting), and dynamic binding.andM;Monitoring AssertionsandM;The question of what happens when an assertion is violated (such as ifintersect1 is called on two circles that do not intersect) is secondary.andP;  Themain question is: How can we, as responsible software professionals, makesure that we produce software that is correct?andM;The tendency to reverse the priorities and ask the secondary question firstis a sign of how insecure most of us in the software engineering professionfeel about our techniques and tools.andP;  This article won't reverse thissituation.andP;  Still, we must get our priorities straight.andM;The answer to what happens when an assertion is violated depends on how youhave compiled your class.andP;  If you have made the effort of spelling out themental hypotheses that underlie the correctness of your software, you couldexpect a theorem prover to check the software against these hypotheses.andO;Unfortunately, this is beyond today's technology.andP;  The next best thing tostatic proof is run-time monitoring.andP;  If you compile a class under the ALLASSERTIONS mode, all assertions (preconditions, postconditions, invariants)are checked at the appropriate times during execution.andP;  If one is found to beviolated, an exception is triggered.andP;  Unless you have made explicitprovisions to handle it, the exception will result in program terminationwith a clear message identifying the context of the failure.andM;There is never a good reason to compile a class under any option other thanALL ASSERTIONS, except performance.andP;  If you are sure your software is correctand do not want to incur the overhead of checking, use the NO ASSERTION CHECKmode.andP;  If a bug does remain, though, you are on your own.andP;  The default is anintermediate mode, which generates code that checks preconditions only.andO;Switching modes may be needed a number of times during development.andP;  Thisswitch is easy.andP;  Only the last stage of compilation is repeated for thecorresponding class.andM;Run-time monitoring of assertions provides a powerful debugging mechanism.andO;Assertions are a way to make explicit the otherwise implicit mentalassumptions that lie behind our software.andP;  It is typical for a bug to causeone of these assumptions to be violated.andP;  When this occurs, run-timemonitoring will catch the violation.andP;  This debugging technique takes on itsfull meaning in the object-oriented context.andP;  I used it when using the AlgolW compiler in the seventies.andP;  Its superiority over usual debugging methods ishard to imagine until you have actually applied it.andM;Defensive is OffensiveandM;If a routine has a precondition p, defensive programming would mean that thetext of the routine should test again for p, in case the client forgot.andP;  Forinstance, consider Listing Four, page 125.andM;The form as shown in Listing Four is never acceptable.andP;  It is a sloppy styleof programming in which responsibility for ensuring various consistencyconditions (contract clauses) have not been clearly assigned.andP;  Because thecontract is unclear, the scared programmer includes redundant checks &quot;just incase.&quot;andP;  This is a self-defeating policy.andP;  Complexity is the single, worstenemy of software reliability.andP;  The more redundant checks, the more complexthe software becomes, and the greater the risk of introducing new errors.andM;Reliability is not obtained by cowardly adding even more checks, but byprecisely delineating whose responsibility it is to ensure each consistencyrequirement.andP;  A party in a contract may fail to meet the requirement imposedon it.andP;  This is precisely what a bug is.andP;  The solution, however, is not tomake the software structure more complex by introducing redundant checking,which only makes matters worse.andP;  For fault-tolerant design, you should beable to rely on a general-purpose run-time checking mechanism.andP;  In Eiffel,this mechanism is the monitoring of assertions as described above.andM;With redundant checking being unacceptable, we still face a choice betweenthe &quot;demanding&quot; (strong precondition) style and the &quot;tolerant&quot; (noprecondition) style, with the intermediate spectrum.andP;  Mathematically,tolerant routines represent total functions and demanding routines representpartial functions.andP;  Which one to use depends on the circumstances.andP;  Thecloser a routine is to uncontrolled &quot;end users,&quot; the more tolerant it shouldbe.andP;  But even with general-purpose library routines, there is a strong casefor demanding routines.andM;With a strong precondition, a routine can concentrate on doing a well-definedjob and doing it well, rather being concerned with other things.andP;  Theintersect1 routine becomes a mess if it isn't assumed that the circles dointersect.andP;  Tolerant routines must address user interface concerns for whichthe routines do not have the proper context.andP;  The intersect1 routine mustaddress problems of geometrical algorithmics (computing the intersection oftwo intersecting circles in the best possible way).andP;  It is difficult toreconcile these two aspects in a single routine.andP;  The solution that willensure reliability more certainly than blindly checking all constraints allthe time, is to separate the checking and the computation.andM;Conventional wisdom, which says &quot;never assume anything, anywhere,&quot; is wrongand dangerous.andP;  Its pervasiveness can only be explained by the absence of anynotion of contract in standard approaches to programming.andP;  If clients have noprecise specification of the conditions they are supposed to observe, theycan't be trusted to observe these conditions and there is no choice but toinclude as many consistency checks as possible.andP;  In a systematic approach tosoftware construction, however, the contract is clearly and adequatelyexpressed, independently of its implementation, through assertions.andP;  By usingthe short command to let client designers see this contract, you canconcentrate on doing you job rather than checking theirs.andM;Considered in the perspective of other engineering disciplines, the oftenrecommended ban on &quot;partial&quot; routines seems absurd.andP;  If you ask an electricalengineer to design an amplifier that will work for any input voltage, or amechanical engineer to build a bridge that will hold any load, they willlaugh at you.andP;  Any engineering device has preconditions.andP;  There really is nogood reason why software routines should be required to be total.andM;The reference to electronic components is not coincidental.andP;  One of the mostexciting advantages of object-oriented techniques is the ability to work fromlibraries of standardized, off-the-shelf, reusable components.andP;  Thesecomponents are similar to hardware components used in electrical engineering.andO;These libraries cannot be successful unless the components are specified in aprecise and standardized way.andP;  Trying to sell a class without its invariant,preconditions and postconditions is like trying to sell an amplifier withoutits engineering specs.andM;Programming by PrayerandM;Assertions are not a way to program the handling of special cases.andP;  Anexception violation is not an expected situation that you want to handleseparately from the others--it is the manifestation of a bug.andP;  To handlespecial cases, there is not much substitute for what you learned on day twoof Introduction To Programming 100--the if .andP;  .  .  then .andP;  .  .  elseconstruct.andM;There seems to be another pervasive myth in the industry that one can forgetabout special cases through a form of faith healing.andP;  This can be called&quot;programming by prayer.&quot;andP;  In Ada, the sacred word is raise.andP;  Whenever youencounter a situation that threatens to disrupt the spiritual harmony of yourprogram, kneel down and say, raise some exception and a saint or angel willcome and take your worries away.andM;It doesn't work this way.andP;  The &quot;angel&quot; has to be programmed, and usually byyou.andP;  Postponing a problem does not solve it.andM;In Ada, after a raise, a chain of calls that led to the exception isexplored, in reverse order, until a block is found that includes an exceptionclause of the form:andM;exception when some exception = [is greater than] some action; when otherexception = [is greater than] other action; ...andM;One of the when branches names the current exception.andP;  Then the code someaction is executed and control returns to the handling block's caller.andM;If your aim was to make your software simpler by separating the processing of&quot;normal&quot; and &quot;special&quot; cases, you will be disappointed.andP;  Special cases willnot go away through the raise attempt at absolution.andP;  Such as old sins, theywill come back to haunt you in your exception clauses.andP;  In the program text,such clauses are far away from the source of the exception.andP;  They usuallylack the proper context to deal with the exception.andM;There are two cases of exception handling.andP;  One is when the exception must behandled identically for all calls of the routine.andP;  This type of exception ismuch better handled by an if .andP;  .  .  then .andP;  .  .  else .andP;  .  .  clause inthe routine itself.andP;  In other words, the routine should be made moretolerant.andM;The second is when the handling of the special case is different for eachclient.andP;  This can be achieved by protecting each call with an if .andP;  .  . andO;then .andP;  .  .  else.andP;  The routine itself remains demanding.andP;  In either case nospecial control structure is needed.andM;ExceptionsandM;Once the naive faith in exceptions as exorcism has been dispelled, there isstill room for an exception mechanism.andP;  Exceptions should not be used ascontrol structures.andP;  They have no advantage over standard control structures,and have many drawbacks.andP;  Some mechanism is needed however, to deal with anoperation that might fail in such a way that it is difficult or impossible tocheck for with a standard control structure.andP;  Following are three mainexamples:andM;1.andP;  Bugs.andP;  By definition, a bug is unexpected.andP;  If you were able to test forits occurrence, you would correct the bug in your software, not handle it atrun time.andP;  If, in spite of your best efforts, a bug does occur, you stillwant the ability to recover from it somehow at run time, even if only toterminate the execution gracefully.andM;2.andP;  Uncheckable consistency conditions.andP;  Some preconditions may be impossibleto check as part of an if .andP;  .  .  then .andP;  .  .  else, either because theyare too complex to express formally, or because the applicability of anoperation can only be ascertained by attempting the operation and seeing ifit fails.andP;  For example, a write to disk operation may fail, but it is notuseful to ask first and then write.andP;  The only way to know if you can write isto attempt to write.andP;  Then, if something goes wrong, you must be able torecover.andP;  Another example, in an interactive system, is the implicitprecondition that the user will not hit the BREAK key.andP;  Obviously, you cannottest for the occurrence of such events.andM;3.andP;  Impractical to check before each call.andP;  These are operations for whichexpressible preconditions exist in principle, but for which it is impracticalto check before each call.andP;  For example, few programmers want to protectevery addition by a test for non-overflow, or every object alloation (Create)by a check that enough memory remains.andP;  As in the previous case, but forpractical, rather than theoretical reasons, you want to be able to attemptthe operation, proceed as if everything went all right, but recover ifsomething goes wrong.andM;These three cases are ones for which exceptions are needed.andP;  They are not&quot;special&quot; or expected algorithmic cases, but abnormal situations that cannotbe properly handled by standard algorithmic techniques.andM;In Eiffel, an exception occurs in the following situations:andM;* Assertion violations (if monitored).andP;  The violation of an assertion isalways a bug.andP;  A violated precondition reflects a bug in the client; aviolated postcondition reflects a bug in the routine.andM;* Hardware or operating system signals, such as arithmetic overflow, memoryexhaustion, and so forth.andM;* An attempt to apply an operation to a non-existent object (Void reference).andM;* Failure of a called routine.andM;The range of such exceptions is much less extensive in Eiffel because of thedisciplined nature of the language.andP;  In particular, the static typingmechanism of Eiffel implies that for a correctly compiled system there is noexception for a &quot;feature applied to an object that cannot handle it (amessage sent to an object that cannot process it).&quot;andM;Dealing with ExceptionsandM;What happens when an exception occurs?andP;  The Ada answer is dangerous.andP;  Becauseyou can do essentially anything you like in a when clause, there is noguarantee that you will achieve anything remotely resembling the originalpurpose of the routine that failed.andM;To obtain a satisfactory solution, it is necessary to think in terms of thecontract that a routine is meant to ensure.andP;  The routine initially tries tosatisfy its contract by following a certain strategy, implemented by theroutine's body (the do clause).andP;  An exception occurs when this strategyfails.andP;  In the disciplined approach, only two courses of action make sense:andM;* The routine (contractor) may have a substitute strategy.andP;  If so, it shouldbring the target object back to a stable state and use this strategy.andP;  Thisis the resumption case.andM;* If no substitute strategy is available, the routine should bring the targetobject back to a stable state, concede failure, and pass the exception to itsclient.andP;  This is the failure case.andM;In the exception history table shown in Figure 5, some exceptions are dealtwith in each of these two modes.andP;  The table, shown as it is printed at runtime, is divided into periods, separated by double lines.andP;  Each period,except the last, ended with a retry.andM;The absence of a clear-cut choice between resumption and retry is what makesthe Ada mechanism too general, and hence dangerous.andP;  Some Ada examples showcases in which a routine reacts to an exception, fails to correct the causeof the exception, and returns to its caller without signalling the exception.andO;This is extremely dangerous.andM;Eiffel enforces the choice between resumption and retry.andP;  The key idea isthat of routine failure--a routine may succeed or fail.andP;  If it fails toachieve its contract, it may either try again or give up.andP;  It should notconceal the failure from its caller.andM;This explains the fourth case in the earlier list of Eiffel exceptions.andP;  Thefailure of a routine automatically triggers an exception in its caller.andP;  Thisis implemented by the optional routine clause rescue.andP;  If present, the rescueclause is executed whenever an exception occurs during the routine'sexecution.andM;If a rescue clause is executed to the end, the routine terminates by failing.andO;As noted, this automatically raises an exception in the caller, whose ownrescue clause should handle it.andP;  If a routine has no rescue clause, as willtypically be the case with most routines, then it is considered to have anempty rescue clause--any exception occurring during the execution of theroutine leads to immediate failure and an exception in the caller.andP;  If noroutine in the call chain has a rescue clause, the entire execution fails andan appropriate message, recording the history of recent exceptions in reverseorder, is printed.andP;  Note the use of assertion tags, when present, in themessages shown in Figure 5.andM;Not all exceptions cause failure.andP;  A rescue clause may execute a retryinstruction, in which case the body (do clause) of the routine must be triedagain, presumably because a substitute strategy is available.andP;  This is theresumption case.andM;For example, consider the routine in Listing Five, page 125, for attemptingto write to disk, from a generic class C.andM;Here it is assumed that the actual write is performed by a lower-levelexternal routine attempt-to-write, written in another language, over which wehave no control.andP;  If this routine fails, it triggers an exception, which iscaught by the rescue clause.andP;  This results in a retry.andP;  Local routinevariables are initialized on routine entry.andP;  An integer variable such asattempts, is initialized to 0.andM;The routine write never fails.andP;  Its contract says, &quot;write if you can,otherwise record your inability to do so by setting the value of attributewrite successful to false, so that the client can determine what happened.&quot;andO;It is always possible to satisfy such a contract.andM;The version of write shown in Listing Six, page 125 is a variant of the classthat does not include attribute write successful.andP;  It may succeed or fail.andM;In this version, after five attempts, the routine terminates through thebottom of its rescue clause.andP;  This means the routine fails, triggering anexception in the caller.andP;  This contract is more restrictive than the oneshown in Listing Three.andP;  It requires that the routine be able to write.andP;  Ifthis contract cannot be fulfilled, the only exit is through failure.andM;Formal RequirementsandM;The deeper meaning of the rescue clause can be understood in theobject-oriented context, and with reference to the contract of a routine, asexpressed by assertions.andM;The following expresses the requirements on a contractor that implementssoftware element e:andM;{P} e {Q}andM;This means the contractor must write e in such a way that, whenever P issatisfied on entry, Q will be satisfied on exit.andP;  The stronger P is, theeasier the contractor's job (more can be assumed); the stronger Q is, theharder the contractor's job is (more must be produced).andM;Consider routine r with body do, precondition pre, and postcondition post, ina class with invariant INV.andP;  The requirement on the author of the do clauseis:andM;{pre and INV} do {post and INV}andM;In other words, the invariant and the precondition can be assumed, theinvariant must be preserved, and the postcondition must be ensured.andP;  Now,consider a branch rescue, of the rescue clause, not ending with a retry.andP;  Therequirement here is:andM;{true} do {INV}andM;The input condition is the weakest possible (hardest from the contractor'sviewpoint), because an exception may occur in any state.andP;  The rescue clausemust be prepared to work under any condition, but the output condition onlyincludes the invariant.andP;  Ensuring the invariant brings the object back to astable state.andP;  Integrity constraints play a similar role in data basesystems.andP;  The rescue clause is not, however, constrained to ensure the entirepostcondition.andP;  This is the sole responsibility of the do clause.andP;  If thecontractor satisfies the routine's contract, there is no need for the rescueclause.andM;This shows the clear separation of concerns between the do clause and therescue clause.andP;  The former is responsible for achieving the contract whenpossible.andP;  The latter takes over in case the do clause falters.andP;  The rescueclause restarts the do clause under improved conditions, or closes the storeafter putting things in order.andP;  The requirements on the rescue clause areboth harder (a weaker precondition) and easier (a weaker postcondition).andM;Fine-Tuning the MechanismandM;Those are the basics of Eiffel exception handling.andP;  In practice, somefine-tuning may be needed for particular applications.andP;  This is done notthrough the language itself, but through the library class EXCEPTIONS.andO;Classes needing the corresponding facilities should inherit this class.andM;It is sometimes necessary to treat various exceptions differently.andP;  Attributeexception in class EXCEPTIONS has the value of the code of the last exceptionthat occurred.andP;  Exception codes are integer symbolic constants (attributes)defined in that class.andP;  Examples include Precondition (precondition violated)and other assertion-related exceptions, No object, No more memory, operatingsystem signals (Sighup and so on.) and others.andP;  A rescue clause may contain atest of the form:andM;if exception=No more memory then .andP;  .  .  elsif and so on.andM;Generally, it is wise to resist the temptation to attach too much meaning tothe precise nature of an exception.andP;  An exception usually points to asymptom, rather than a cause.andM;For programmers who want to define and raise their own exceptions, theroutine raise is available in class EXCEPTIONS.andP;  The default handling ofcertain exceptions, especially operating system signals, can be changed byredefining certain routines from class EXCEPTIONS.andP;  By using classEXCEPTIONS, application software can access information about the lastexception.andP;  This information includes the exception type, its meaningexpressed as a plain English string, and so on.andP;  This is particularly usefulfor printing informative error messages.andM;Why Not Make It Right?andM;Reliability is a primary concern in any serious view of softwareconstruction.andP;  In the object-oriented approach, it is even more essential.andO;Reusability of software is meaningless unless the reusable components arecorrect and robust.andP;  Static typing is an important aspect of Eiffel'scontribution to this goal (see the article &quot;You Can Write, but Can You Type?&quot;andO;in the March 1989 issue of the journal of Object-Oriented Programming formore on this subject).andM;The assertion and exception techniques described in this article provide thecomplement to static typing.andP;  They don't absolutely guarantee that yourclasses will be correct and robust, but they sure can help.andM;Bertrand is the president of Interactive Software Engineering and is the maindesigner of the Eiffel language.andP;  His book, Object-Priented SoftwareConstruction, was published by Prentice Hall in 1988.andP;  He can be reched at805-685-1006, or through e-mail as Bertrand at Eiffel.com.andO;</TEXT></DOC>