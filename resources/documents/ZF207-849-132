<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-849-132  </DOCNO><DOCID>07 849 132.andM;</DOCID><JOURNAL>Hewlett-Packard Journal  Oct 1989 v40 n5 p90(8)* Full Text COPYRIGHT Hewlett Packard 1989.andM;</JOURNAL><TITLE>User-centered application definition: a methodology and casestudy. (includes related articles on interviewing andstoryboarding techniques)</TITLE><AUTHOR>Berlin, Lucy M.andM;</AUTHOR><SUMMARY>A practical and systematic user-centered design methodology isdeveloped for the definition and development of softwareapplications (in particular, their user interface) that arecongruent with the users' model of their own functional domain andoperations.andP;  Effective and easy-to-use software reflects the way aperson naturally functions rather than the internal architectureand functioning of the application itself.andP;  The new methodologyinvolves six steps: understanding customer needs and currentappropriate technologies, selection of multiple contrasting tasksor applications, analysis of the common user tasks involved,storyboarding the tasks to identify more optimal processes,synthesis of platform goals and requirements, and prioritizationimplementation.andP;  A hypertext-based software prototype is developedwith the methodology.andM;</SUMMARY><DESCRIPT>Topic:     User InterfaceSoftware DesignCase StudyDocument Preparation.andO;Feature:   illustrationchart.andO;Caption:   Methodology for doing user-centered application definition.andO;(chart)A sample task for a document preparation system. (chart)andM;</DESCRIPT><TEXT>User-Centered Application Definition: A Methodology and Case StudyandM;GOOD PRODUCTS MEET USERS' NEEDS, present their interactions in terms of theirusers' model of operations, and are easy to use.andP;  They accomplish this byembodying knowledge about the user's tasks and sequencing of operations, andabout the relationship of the tasks to the overall work context.andP;  Forexample, VCRs can be difficult to use because they have an obscure tapecounter, a control that reflects the internal structure of the machine,rather than a &quot;minutes of playing time&quot; indicator which would reflect theuser's view of the information.andP;  In contrast, a washing machine is easy touse, since the user simply indicates the type of clothes and the size ofload, and is not required to understand the machine's internals or to specifythe hot water flow rate, gallons of rinse water, and spin rate of thespindle.andP;  Good products present user interfaces that are consistent with theuser's model of their operation rather than mapping too directly to theproduct's internal organization.andM;Software applications, and in particular their user interfaces, also need tobe consistent with their users' model of operations.andP;  Dramatic advances inhardware integration and an exponential decline in costs have expandedcomputer use beyond the original computer science and engineering domainsinto many new contexts.andP;  As a result, software users can no longer be assumedto be computer experts who are comfortable with the traditionally terse userinterfaces.andP;  These noncomputer specialists are too often required totranslate between their professional domain and the restrictive terms of thecomputer.andP;  For them, commands such as find.andP;  - type f - mtime - 7 - exec grep- I'Hello' {}+; are viewed as magical incantations, not meaningfulcommunication.andP;  (*1)  They must try to model their needs into the system'sinternal structures and concepts (similar to manipulating tape counter)instead of communicating with the system in the terms of their domain andtasks.andP;  To provide good products for these new users, developers mustactively seek out an understanding of their users' domain and tasks.andP;  It isthis need for developers to do more to understand users and their needs thatwe call user-centered design.andM;In the project covered in this paper, we set an explicit goal to produce auser interface design that is focused on user tasks.andP;  We developed theuser-centered design methodology described here to help us gain this crucialunderstanding of our users' needs, and now propose it as a more generallyuseful process.andP;  Using this approach, other developers may learn, forexample, that seemingly similar tasks in different domains or involvingdifferent users may actually have very different, domain-specificrequirements for functionality and user interface.andP;  For example,computer-aided design applications for VLSI circuits and for mechanicalengineering appear similar at first glance.andP;  Both systems use hierarchical,multiple-view design representation data structures and graphical editing.andO;However, these two domains use very different design verificationmethodologies, each with its own optimal user interface.andP;  Each system is mostuseful if the users can interact using their own domain concepts, if commontasks are easy to perform, and if the systems fit into the specific workcontext.andP;  To be done well, both applications require that the developers gobeyond their own experience and acquire an understanding of the problem spacefrom their users' point of view.andP;  The methodology described here may helpdevelopers acquire this understanding and provide systems and user interfacesthat more closely match their users' task models.andM;Since we use our project's hypertext platform definition process as a casestudy of the application of the user-centered methodology, we brieflydescribe the project's background and goals in the next section.andP;  Thefollowing section defines the user-centered methodology we developed and howit relates to other work.andP;  Each succeeding section details a single step ofthe methodology, and uses our project as a case study of how the step wasapplied in practice.andP;  We end with a discussion of the project's currentstatus and a retrospective view of the contributions and generalapplicability of the methodology.andM;Project Background and GoalsandM;The information interfaces project is in the Human-Computer InteractionDepartment of the Software Technology Laboratory at Hewlett-PackardLaboratories.andP;  The Software Technology Laboratory develops environments,tools, and methodologies to improve software productivity.andM;Our project's charter is to explore information management issues andtechnologies.andP;  We hypothesized that hypertext is a useful enabling technologyin many applications that access complex information.andP;  Our approach was todemonstrate the power of hypertext by defining and prototyping ahypertext-based software platform.andP;  A software platform is a common toolkitof concepts and capabilities for use by developers of many applications.andP;  Thehypertext capability makes available nonlinear text with connections (calledlinks) among related items.andM;To define a platform to meet the applications' needs, we needed to understandapplications and their uses in detail.andP;  This is a common problem of platformdevelopers, yet there was not set of guidelines available.andP;  Our lab's focuson software productivity led us to develop a methodology for softwaredevelopers, to apply it within our project, and to introspect about themethodology's effectiveness and impact on our success.andM;User-Centered MethodologyandM;The user-centered software definition methodology we are using in thisproject is a six-point process.andP;  Its components, illustrated in Fig.andP;  1, are:andM;* Understand customer needs and available technologies.andM;* Select multiple contrasting tasks or applications.andM;* Analyze common user tasks in the applications.andM;* Storyboard scenarios to explore how the tasks could be better performed.andM;* Use the scenarios to synthesize platform goals and requirements.andM;* Prioritize features to implement.andM;This methodology is synthesized from ideas in software engineering, systemsanalysis, market research, and contextual field research.andP;  Traditionally,software methodologies (1,2) do emphasize &quot;building software to meet users'needs,&quot; but do not teach how to identify the needs.andP;  They cover thetransitions from requirements specifications to design and code, but givelittle detail on the requirements specification itself.andM;Systems analysis, for example Fitzgerald's text, (3) teaches the analysis ofa system's inputs, operations, and outputs, but is oriented to streamlining aformalized business system, rather than unstructured information managementtasks.andP;  Market research (4,5) teaches selection and analysis of potentialusers to identify users' general problems and potential solutions, but ismostly oriented to tangible consumer goods, not processes or complex systems.andO;Understanding users is seen as essential, but software poses problems notfound in consumer goods needs analysis.andP;  End-user customers of software oftento not have enough technical computer background to know what is feasible andwhat they can request.andP;  Focus groups of unrelated customers often do notprovide enough detail of tasks to specify platform capabilities.andP;  However,contextual field research (6,7) provides a framework for identifying usefulsolutions.andP;  This technique focuses on users' problems in the context of theiroverall job and organizational structure, using observation and fieldinterviews to learn what users really do and what problems they have.andM;Our methodology combines the process focus of systems analysis and marketresearch, the user focus of the human-machine interaction community, (8) andthe tools of contextual field research and traditional human factorsengineering, and applies them to the domain of application definition insoftware development.andP;  Thus, we aim to provide a practical path for softwaredevelopers truly to &quot;build software to meet users' needs.&quot;andM;Understanding User Needs and TechnologiesandM;Studying user needs is a first step to any solution, along with gaining anunderstanding of available technologies and existing tools.andP;  These two tasksinteract.andP;  Without an understanding of technologies one may aim for theimposible, and without an understanding of needs, one may solve the wrongproblem.andM;A software project often begins with a general statement of need or marketopportunity.andP;  The problem statement is likely to be broad--for example, &quot;anonline library catalog and inventory system,&quot; a &quot;blood bank control andinformation system,&quot; or a &quot;general multiuser information managementplatform.&quot;andP;  In current practice, a software engineer is typically expected tobe able to build systems across this wide range of domains.andP;  To succeed, thesoftware engineer's knowledge of algorithms and data structures must besupplemented with an understanding of the users' domain.andM;As mentioned earlier, it is difficult to build systems to solve needs thatare not well-understood, or to build systems for users who are different fromthe developer.andP;  A deep understanding requires &quot;walking a mile in the user'sshoes.&quot;andP;  This can be best achieved by spending a few hours interviewingselected customers, discussing their jobs and their interactions with otherpeople.andP;  These interviews give a richer understanding of the problem, mayexpose misunderstandings and hidden constraints, and can point out novelsolutions.andP;  See the box on page 92 for the interview guidelines we followed.andM;In addition to exploring user needs, the software engineers must activelylearn about the available technologies and state-of-the-art products bycomparing product goals and successes and learning how these technologiesinteract.andP;  The goal is to identify technologies with the potential to helpmeet the identified customer needs.andP;  The result of this approach should be awell-understood set of user needs and knowledge about relevant technologiesand potential solutions.andM;Since we are a research group, our focus is necessarily somewhat longer-termthan that of a product development team.andP;  We are interested in researchsystems as well as products already in the market.andP;  When we approached thetask of understanding the available technologies and customer needs, wecompiled a bibliography of papers on hypermedia research and discussed thestate of the technology with our potential user community.andP;  We organized astudy group in which we distributed and discussed selected papers andanalyzed the goals and capabilities of existing systems.andP;  We evaluated theirusefulness for different tasks and what was required to implement them.andP;  Wealso invited speakers to give their perspectives on the field and on theirneeds.andP;  These contacts exposed us to a diverse range of applications andcustomer needs and helped us gain a better understanding of theirfunctionality requirements.andM;Selecting Multiple ApplicationsandM;After selecting a general area to be supported by a software platform,detailed requirements must be identified.andP;  Platform designers need diverse,representative, example applications to help determine and validate theplatform's specific capabilities.andP;  A good validation application is one thatcould clearly benefit from the proposed solutions, is based on technologyavailable to the customer, is doable and will exercise many features of theplatform (otherwise it would not help define and constrain the platform).andP;  Wefound it useful to define a table of technical and pragmatic criteria for usein selecting an application.andM;Examining multiple applications helps to avoid false optimizations, identifythe crucial requirements, prioritize features, and decide among trade-offs,and may define the boundaries of the problem space.andP;  The applications wechose were a multiuser, annotatable, hypertext-structured, on-line manual anda community calendar interface to group information.andP;  Each applicationappeared doable, could be important to HP, and could clearly benefit fromhypertext capabilities.andP;  However, the two applications emphasized verydifferent mixtures of platform capabilities.andM;Wehn designing an application instead of a platform, the requirementsdefinitions must be more specific and should cover the full range of usertasks rather than just representative ones.andP;  For example, applicationdesigners might consider both data generation and the specific requirementsfor producing a variety of graph types on multiple output devices rather thansimply looking at general graphing functionality requirements.andP;  To ensurecoverage of the full range of tasks, developers should consider theapplication users' goals and their associated tasks.andM;Analysing Common TasksandM;The goal of this step is to experience a user's tasks and problems and thecurrently available applications and tools first-hand, thereby building adetailed understanding of the issues involved.andP;  For each chosen application,the common tasks should be listed and characterized, preferably with the helpof a &quot;customer.&quot;andP;  Then, each project member should select a specific task inthe list.andP;  This should be a concrete, nontrivial task--for example, &quot;Find thelast eight quarters' earnings and expenses and present the result as a slidecontaining a bar graph.&quot;andM;Using the existing tools, each engineer then records the specific stepsrequired to accomplish the goal, frustrations encountered, sources ofproblems or mistakes, and ideas for new tools.andP;  Each engineer also interviewscurrent users of similar products, or potential users, to learn how theywould go about solving the problem.andP;  In addition to observing current workstyles and tool use, the interviewer also asks open-ended questions about theuser's needs for computer support in the area, and requests prioritizedsuggestions for improvements.andM;The result of this process is an insider's understanding of the tasks and theaspects that make the current solution frustrating or time-consuming, plus adeveloping vision of a better solution.andM;After discussing the goals and expected results of the task analysis, eacheningeer in our project selected an example of a common, nontrivial task inthe target application.andP;  We conducted interviews with users and gained anumber of surprising insights into what users really do, how they use or whythey avoid a system, and what they would really like to have help with.andP;  Weconfirmed that even a few hours of interviews can be very valuable, even whenconducted by engineers who have had only brief training in interviewing anduser needs analysis.andP;  We were fortunate to have a couple of project memberswho had been formally trained in interviewing techniques and were able tobrief the rest.andP;  An overview of the guidelines we use is presented in the boxon page 92.andM;One sample task involving the manual for a document preparation system was todiscover how to print labels for three figures on a page: two for figures inthe upper quadrants and one across the lower half of the page, as shown inFig.andP;  2.andP;  In analyzing the way in which the current paper manual is used, itbecame clear that there are some strong advantages of a paper document thatwe would want to preserve, and some glaring problems where we could make acontribution.andP;  A physical book can be skimmed, highlighted, dog-eared, andwritten on.andP;  On the other hand, a good solution using this particular systemrequires understanding of the concepts and syntax of &quot;floating object,&quot;&quot;figure,&quot; &quot;caption,&quot; and &quot;fragile command,&quot; and it was difficult to identifyall the correct names for the concepts and then flip among the scattereddescriptions to understand how they fit together.andM;In solving this problem using the manual, the project engineer would skipback and forth among about eight groups of pages that described the concepts,a tutorial section, and the index, using pieces of paper, pens, and fingersholding papges open as bookmarks to facilitate moving among the eightsections of text.andP;  It was frustrating not to be able to differentiate indexentries for the main definition of a concept, an example, or a mere mentionin the tutorial.andP;  Other problems included the facts that electronic mailconcerning use suggestions, questions, and bugs in the system was keptelsewhere and not indexed in the manual, that there was no good way to addnew entries to the index, and that once the problem was solved there was noeasy way to annotate the book with the solution and links to the relevantentries or to share the solution with colleagues.andM;We found that working through this example task using the current system wasquite revealing.andP;  In particular, being exposed to the low-level interactiondetails brought out user issues and requirements that might otherwise havebeen overlooked.andM;Storyboarding ScenariosandM;Based on the previous step's learning process, analysis, interviews, andsuggestions, each engineer prepared a report summarizing the user problems tobe solved and ideas for an improved application.andP;  The engineer's presentationof this report to the group tended to enhance the organization of the designprocess and to expose he proposed solution to the different mental models,approaches, and domain knowledge of the other group members.andM;Part of the report is a sample scenario of a user's path through the improvedsystem, showing how the user solves the selected problem.andP;  This scenario ispresented in the form of a storyboard (see box, page 95).andP;  It may be a mostlytextual, sequential description of the low-level steps the user goes through,including a description of what tools and information are visible atdifferent times, how the user navigates through the system and uses the helpfacility, and how data is moved from one tool to another.andP;  The scenario mayalso be a graphical sequence of screen images, with captions that describethe transitions and user actions.andM;The goal of the scenario is to clarify assumptions about the user's goal andcontext and to expose missing components, awkward lins between steps, andconstraints on the technology.andP;  The scenario presentation includes a list oftechnical capabilities it assumes, which represents functionality the teammust either get or build.andP;  At this point, the scenarios communicateindividuals' visions to the group and do not represent a group vision; infact, diversity of perspectives is an advantage.andM;After each scenario is presented, the group discusses any omissions andbrainstorms improvements.andP;  The resulting requirements are categorized aseither resources to be provided by other groups, capabilities to be built bythe project team, or paradigms and tools that are useful additions to besupported but not built.andP;  These lists form the starting points of thesynthesis phase.andM;We found that succeeding scenarios built on previous ones, but also had verydifferent foci--multiuser interactions, help and error recovery, performance,or navigation in complex information.andP;  This diversity was especially strongbecause of the variety of backgrounds and interests in our project, andgreatly enhanced the quality and versatility of the resulting platform.andO;However, even in a homogeneous group, we feel that members should try for adiversity of approaches because it leads to insights and exposes issues.andM;Synthesizing Goals and RequirementsandM;The first step in synthesis is to reexamine the original problems to besolved and refine them according to the user feedback and task analyses ofthe above steps.andP;  Then, use the project goals to combine and filter the listsof requirements from the storyboarding step.andM;For a software platform this results in three lists: the platformrequirements and programmatic interface, the set of capabilities to be builtby the project, and the functionality expected to be imported from otherprojects or products.andP;  For an end-user application, the lists would be:user-level functional requirements including extensibility and customizationhooks, capabilities to be built by the project, and capabilities expected tobe imported.andM;After we discussed each task and collected the lists, we began the synthesisphase.andP;  We reexamined and agreed on the results we wanted to achieve.andP;  Ourgoals were to understand the interaction of programmatic and user interfaceissues in the proposed group environment for information management and tobuild a prototype hypertext platform and application prototypes to validateit.andP;  When we agreed on the goals, we were able to combine the various listsof requirements into a platform definition.andM;Prioritizing FeaturesandM;The last step is to set up a plan of attack for the project.andP;  The goal is todefine a phased process, so that critical issues can be resolved quickly andproblems identified, and yet provide a vision of the full system.andM;Especially for a new domain, or a combination of new technologies, it iscritical to constrain the size of the first prototype.andP;  It is common tounderestimate the problems in a new area, so one needs to make sure that thefirst pass is doable.andP;  In building an application, it is often possible toplan a vertical slice of useful functionality and a user interface, which maythen be given to users for early feedback.andP;  A platform may not have a userinterface and may not solve any application's complete problem.andP;  This makesgetting early user feedback difficult and makes it even more important forthe developers to match the application requirements carefully to theplatform capabilities and to build and test the critical capabilities first.andM;Defining a core is not enough; it is also necessary to define the fullsystem, to consider the dimensions in which the system should be extensible,and to understand how such extensibility will be designed in.andP;  Theselonger-term plans need not be as detailed as the definition of the corefeatures, but must be detailed enough that the full functionality andextensibility requirements can be anticipated and incorporated into theinitial design.andM;We reorganized the requirements lists into three groups, corresponding tothree implementation phases.andP;  In the first layer were items whose design hadfundamental impact on our architecture and that would provide a core slice ofmultiuser functionality.andP;  The second layer defined the higher capabilitiesneeded to provide a programmatic interface for hypertext applicationdevelopers.andP;  Our top layer's list included the new tools and organizingconcepts we felt would be useful in various end-user applications but werenot part of the core platform.andM;Our goal was to define an extensible platform architecture with which wecould validate our theories or expose problems early.andP;  In our first-passprototype our plan was to design and implement core data structures,algorithms, and communication strategies.andP;  We designed and implemented asimple, extensible user interface, which was adequate for our initialapplications.andM;For our second pass, we planned to revise the basic architecture based onlessons learned in the first prototype, and to have a couple of applicationsthat would be sufficiently complete and efficient to allow us to evaluatedaily use by a few dozen users.andP;  We even planned a third-pass system, whichhad much richer functionality.andP;  We didn't design that fully, but checked ourfundamental decisions to see if they would meet the third pass'sfunctionality requirements.andM;Current Status and EvaluationandM;Our methodology greatly influenced our design of the platform for hypertextapplications.andP;  In design meetings we often referred back to a scenario toidentify the user model we wished to support or to check the impact of adesign decision.andP;  This simplified the design discussions.andM;We have now built the first-pass prototype platform and are analyzing how itwas used to build a computer-conferencing application.andP;  This application wasdesigned and built as the thesis project of an MIT Master's student intern.andO;It has been a fine validation system for our platform, since the student didnot participate in our definition phase and this system was not one of theapplications we had analyzed in detail.andP;  Our platform matched theconferencing application's requirements quite well.andP;  Only one missing conceptwas identified, which required only minor redesign.andP;  On the whole, theplatform design was quite robust; our planned versatility paid off well.andM;We expect to use storyboarding again before we prototype one of ourvalidation applications.andP;  This time we would use it as a group tool to buildconsensus and to define and document a shared view of the application'sgoals, constraints, and tasks.andM;Contributions and ApplicabilityandM;This paper has tried to show that to develop applications that truly helpusers, developers must understand their users' needs and constraints.andP;  Whilethis may seem obvious, it is tempting to begin immediately to &quot;solve&quot;quickly, rather than taking the time to probe and listen with an open mind.andO;A principled, objectives study of users and their overall goals will elicittheir real obstacles and needs and simplify the selection and design of theappropriate technical platform application solutions.andM;Our user-centered methodology contributed to our goals in many ways.andP;  Wefound that the analysis of how existing systems are actually used, the focuson two diverse applications, and the analysis of multiple scenarios of usertasks were very revealing.andP;  By focusing on representative tasks anddeveloping realisting scenarios, we identified how people actually do tasks,what their concerns are, and where their current methods fail to meet theirneeds.andP;  In so doing, we identified the essential capabilities of thehypertext platform and a set of desirable extensions, the crucial featuresfor initial test applications, and evaluation questions for the platformprototype.andM;The selection of criteria for user applications and analysis of user needstook less than two weeks, including the synthesis of platform requirements.andO;Our results let us prioritize the capabilities to provide, and also suggestednew tools for organizing the richly interconnected information.andP;  Thesynthesis phase resulted in a shared, documented vision, which focused andguided decisions throughout the design and implementation phases.andP;  Themethodology also provided validation metrics for the resulting platform viatwo test applications which represent diverse uses for the platform.andM;We believe that our strategy was a successful implementation of auser-centered analysis of a new technology, and that this simple and powerfulmethodology is widely applicable to application design both witn and outsideHewlett-Packard.andM;AcknowledgmentsandM;We wish to thank Nancy Kendzierski (our early project manager and the currentdepartment manager) and Robin Jeffries for leading this project and for theirinsightful comments on the HP Technical Women's Conference talk and on draftsof this paper.andP;  Cathy Fletcher designed all the illustrations and ably helpedrevise many sections.andP;  Bob Leichner, Jarrett Rosenberg, and Vicki O'Dayparticipated in the definition and implementation of our system and gavehelpful comments on this paper.andP;  Michael Creech, Cathy Fletcher, DennisFreeze, Andreas Paepcke, and Warren Harris generalized and adapted theirexperimental technologies to meet our platform's needs.andP;  Shari Jackson, ourMIT student intern, defined and built the conferencing application whichhelped us test and refine our platform.andP;  Jean Gascon (then of HPLaboratories), Merijane Lee (then of the HP Application Support Division),and many others provided insight through discussions of their realinformation management tasks.andP;  Will Willams and Bryan Hoover of the HPSystems Technology Division discussed the central role that storyboardingplayed in their project and analyzed their use of the storyboardingmethodology in requirements analysis and design.andM;ReferencesandM;[1] M.A.andP;  Jackson, Principles of Program Design, Academic Press, 1975.andM;[2] M. Page-Jones, The Practical Guide to Structured Systems Design, SecondEdition, Yourdon Press, 1988.andM;[3] J. Fitzgerald, A. Fitzgerald, and W.D.andP;  Stallings, Jr., Fundamentals ofSystems Analysis, Second Edition, Wiley, 1981.andM;[4] J.L.andP;  Pope, Practical Marketing Research, AMACOM, 1981.andM;[5] G.A.andP;  Churchill, Jr., Marketing Research, Fourth Edition, Dryden Press,1987.andM;[6] J. Whiteside, J. Bennett, and K. Holtblatt, &quot;Usability Engineering: OurExperiences and Evolution,&quot; in M. Helander, editor, Handbook ofHuman-Computer Interaction, Elsevier, 1988, pp.andP;  791-817.andM;[7] M. Good, chair, &quot;Experience with Contextual Field Research,&quot; CHI'89Conference Proceedings, 1989, pp.andP;  21-24.andM;[8] J. D. Gould and C. Lewis, &quot;Designing for Usability: Key Principles andWhat Designers Think,&quot; in B. Shackel, edior, INTERACT '84: First Conferenceon Human-Computer Interaction, North-Holland, 1985.andO;</TEXT></DOC>