<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-746-882  </DOCNO><DOCID>08 746 882.andM;</DOCID><JOURNAL>UNIX Review  August 1990 v8 n8 p50(12)* Full Text COPYRIGHT Miller Freeman Publications 1990.andM;</JOURNAL><TITLE>Parallel graphics applications. (rendering on multiprocessorgraphics workstations)</TITLE><AUTHOR>Baum, Daniel R.; Winget, James M.andM;</AUTHOR><SUMMARY>Graphics applications are taking advantage of the potential ofmultiprocessor graphics workstations as the rendering capabilitiesof graphics processors grow.andP;  In postprocessing,application-specific results are computed up front, and thegraphics display application is free to use any available CPUcycles with acceleration hardware in order to boost performance.andO;The 'tracking' method computes results by the analysis task as thedisplay task alternates between servicing user-input requests anddisplay updates driven by new analysis results.andP;  The 'steering'method couples display and analysis tasks bi-directionally,allowing users to change the course of analysis computation viathe display task's interactive user interface.andP;  Using multipleprocessors increases linear throughput in both approaches.andM;</SUMMARY><DESCRIPT>Topic:     Graphics SystemsApplicationsMultiprocessingWorkstationsParallelismThree-Dimensional Graphics.andO;Feature:   illustrationchart.andO;Caption:   (The Power Series). (chart)(The VGX graphics subsystem). (chart)(The IRIX system). (chart)andM;</DESCRIPT><TEXT>Like the performance of multiprocessor workstations, the of graphicsprocessors are growing by leaps and bounds.andP;  Here we explore several graphicsapplications that take advantage of multiprocessor graphics workstations, andexamine the parallelization of three different approaches to analysis andvisual interaction.andM;Over the last five years, the graphics workstation's ability to render 3Dgeometry interactively has made it the computing platform of choice for avariety of applications, including scientific visualization, CAD/CAM,engineering analysis, and photorealistic image synthesis.andP;  The renderingcapability of graphics processors has tended to increase by an order ofmagnitude every two to three years.andP;  Such advances have been accomplishedusing innovative hardware architectures that employ combinations ofpipelining and various forms of parallelism.andM;Fortunately, the performance of RISC-based multiprocessor workstations hasincreased at a rate matching that of increases in the performance andcost-effectiveness of these dedicated graphics accelerators.andP;  It is notunusual for today's deskside, multiprocessor graphics workstations to offerover 100 times the analysis capability of yesterday's standard multiusercomputer, the venerable DEC VAX 11/780.andP;  While this level of performancemight seem excessive for dedicated,  single-user  environments, the currentcomputing demands of many users often exceed even this level of performance,which itself is expected to grow.andM;This combination of high-performance, general-purpose multiprocessing andspecial-purpose graphics hardware has enabled several new and exciting formsof analysis and user-computer interaction to develop.andP;  Making fullsynergistic use of multiprocessor and  graphics hardware may require someredesign of the application software.andP;  The benefits gained from developingnew applications and porting existing applications into this new environment,however, prove well worth the effort.andP;  In fact, it is often the case that theapplication flexibility and functionality of the new concurrent whole is muchgreater than the sum of the powers of its original sequential parts.andM;In this article we will explore several graphics applications that can takeadvantage of multiprocessor graphics workstations, and examine theparallelization of three different approaches to analysis and visualinteraction.andP;  In the first -postprocessing-all application-specific resultsare computed up front, leaving the graphics-display application free to useall available CPU cycles in conjunction with the graphics-accelerationhardware to boost interactive rendering performance.andP;  In the secondexample--tracking-results -are computed &quot;on the fly&quot; by the analysis taskwhile the display task alternates between servicing user-input requests anddisplay updates driven by new analysis results.andP;  Here multiple CPUs areallocated to the analysis and display tasks according to each tasks'individual computing needs.andP;  Finally, when the steering method is used, theanalysis and display tasks are bi-directionally coupled, enabling users toalter the course of analysis computation through the display task'sinteractive user interface.andM;System Hardware/Software Architecture.andP;  We parallelized our sampleapplications on the Silicon Graphics 4D Series multiprocessor graphicsworkstations [1,2].andP;  The 4D environment consists of the Power Series CPUsystem architecture, the GTX and VGX graphics subsystems, and the IRIXoperating system.andM;The fundamental Power Series design supports one to eight processors in atightly coupled, symmetric, shared-memory, multiprocessing architecture thatprovides, according to the manufacturer, up to 234 MIPS and 33 DP MFLOPS touser applications.andP;  Each CPU contains the R3000 microprocessor, designed byMips Computer Systems, coupled with the companion R3010 floating-point chip,both running at either 25 or 33 MHz.andM;Figure 1 shows a block diagram of the system.andP;  Of the important buses shown,the Sync Bus provides the high-speed hardware support for synchronization ofthe main processors, allowing efficient, fine-grained parallelism.andP;  Theindividual processor buses allow full-speed access (zero wait states) toinstructions and data from the individual first-level caches of the mainprocessors.andP;  The read and write buffers ensure efficient information flowbetween processors and the system main memory.andP;  The second-level data cachesprovide the additional memory bandwidth needed by such high-speed processorsto support a transparent, shared-memory computing model.andP;  Finally, the MPlinkbus supports protocols for consistent data sharing and high-speed block-datatransfers among the processors, main memory, the I/O system, and the graphicssubsystem.andM;Through the use of advanced parallel-processing technology and 85 proprietarygraphics processors of ten different types, the GTX and VGX architecturesallow users to interact with complex 3D images in real time, rendering up to1.0 million polygons per second.andP;  Graphics data is processed by fourindependent, pipelined graphics subsystems-one each for geometry, scanconversion, raster, and display-before being displayed on the screen.andM;Each subsystem is itself composed of multiple functional units working intandem, as shown in Figure 2.andP;  First the geometry subsystem receives 32-bitor 64-bit graphical data from the RISC-based host and converts it toscreen-space data.andP;  Next, the scan-conversion subsystem breaks down points,lines, polygons, meshes, and surfaces into pixel data.andP;  This pixel data isthen sent to the raster subsystem, where the Z-buffer is used to removehidden surfaces.andP;  The raster subsystem also performs various blending andtexture-mapping functions on a pixel-by-pixel basis in parallel, as thepixels are written to the frame buffer.andP;  Finally, the display subsystem readsthe frame buffer and displays the generated image on the color monitor.andM;By combining tightly coupled processors sharing a common memory with fastaccess to the graphics pipeline, it is possible to support multiple processesusing the CPU and graphics subsystems simultaneously.andP;  Ownership of thegraphics hardware can be distributed across competing processes on aper-context-switch basis.andP;  Alternately, a group of cooperating processes mayuse other methods for controlling the flow of information to the graphicspipe.andP;  In either case, while one process accesses the graphics pipe, otherscan take advantage of the other CPUs in the system, so that full performancecan be obtained from both the CPU and the graphics subsystem.andM;The IRIX operating system is a symmetric multiprocessing version of UNIXbased on ATandamp;T's System V Release 3.andP;  Some of its more important augmentationsinclude logical volume support, disk striping, a variety of real-timeextensions (that utilize kernel preemption), batch processing, and most BSDfeatures.andP;  To provide full OS symmetry, the IRIX kernel is partitioned intomany fine-scaled data structures such as inodes, buffers, and process-tableentries, each of which is protected by a hardware-supported lock.andP;  Thisallows multiple processors to access the kernel in parallel with minimalinterference.andM;To provide a firm foundation for cooperative, parallel computation, IRIXoffers enhanced resource sharing, which extends the classic UNIX processparadigm to the concept of share-groups.andP;  Members of a share-group may shareaddress space, file privileges, and other resources.andP;  Aside from sharingresources, members of share-groups behave exactly like normal IRIX processes,and may run on any processor.andP;  In the parallel computation model, the numberof share-group members is kept lower than or equal to the number ofprocessors, and all members run simidtaneously, usually executing the samealgorithm and synchronizing often.andP;  Additionally, most system services(malloc, perror, and standard 1/0) have been semaphored, so multipleshare-group members may access them without risking data corruption.andM;To increase linear throughput using multiple processors, it is important toexploit all the hardware parallelism available.andP;  In the IRIX system, this isaccomplished with the help of three levels of software parallelism: automaticprocessor scheduling, explicit library constructs, and automaticparallelizing compilers (both C and FORTRAN) for user applications (seeFigure 3).andP;  Automatic scheduling is implemented using a single run queuewhich any idle processor may search independently.andP;  Since each processor isself-scheduling, typical UNIX workloads are balanced automatically.andM;The explicit multiprocessing library, libmp, provides programmers withsupport for a wide variety of parallel-programming paradigms includingapplication-level spin-locks, semaphores, shared memory, and dynamic processcreation and control.andM;Both C and FORTRAN compilers have been extended to perform sophisticateddata-flow analysis, optimization, and code generation automatically, to takeadvantage of the hardware available.andP;  In many cases, the automaticparallelizing compilers provide all the support necessary to obtain goodperformance.andP;  If need be, the user can further assist in this effort by usingexplicit parallelization directives.andM;In the following examples we consider parallelizing each of three methods foranalysis of and visual interaction with data.andP;  The first and most prevalentmethod is postprocessing.andP;  Here the calculations are performed in advance,and when complete, the results database is used as input to an interactiveviewer.andP;  In the second method-tracking-the interactive viewer is able toquery the results database as the computation proceeds.andP;  This allows fortimely termination of divergent calculations.andP;  Finally, using the steeringmethod, the interactive viewer is able to watch as the computation proceeds,and to intervene and direct the calculations back on track should they startto diverge.andM;Octree-Based Geometry Viewer.andP;  In the first example, a large, previouslyconstructed geometric database is postprocessed [3].andP;  The task of viewinglarge geometric databases is one whose performance can be increasedsignificantly using the power of multiprocessor graphics workstations.andO;Consider a geometric database that describes a city.andP;  A simple approach topostprocessing for each frame is to have the application send the entiredatabase to the graphics-acceleration hardware and let it discard sections ofthe city that are not in view.andP;  This method is inherently inefficient,however, because the graphics hardware spends most of its time cullingout-of-view geometry rather than rendering geometry that is in view.andM;Sequential approaches to solving this problem have focused on using the hostprocessor to eliminate invisible portions of the database before sending thegeometry to the graphics hardware for rendering.andP;  One common technique is tospatially partition the database during a preprocessing step using a 3D datastructure such as an octree [4] that effectively groups portions of thedatabase that are in close proximity into common volumes (see Figure 4).andM;When a volume is partitioned, it is subdivided into eight equal-sized childvolumes, or octants.andP;  The partitioning occurs in a recursive manner until atermination criterion is met.andP;  This termination criterion assures that eachleaf octant contains approximately an equal number of polygons.andP;  Cullingoperations can then be performed on octants rather than on individualpolygons.andP;  Since determining whether an octant is in view requires roughlythe same amount of computation as determining whether an individual polygonis in view, culling decisions made in this manner for a significant number ofpolygons take only as much time as they ordinarily would for a singlepolygon.andM;Although spatial partitioning somewhat improves viewing performance on auniprocessor graphics workstation, it also creates performance handicapswhich can be overcome through parallel processing.andP;  While the uniprocessor iscomputing which octants are in view, it cannot send geometry contained invisible octants to the graphics acceleration hardware.andP;  As a result, thegraphics hardware is not driven to its maximum capacity; in an effort to usethe hardware more efficiently by displaying only in-view polygons, a newinefficiency is introduced.andM;In designing the parallel-viewing application, our two primary goals weredriving the graphics hardware at its maximum rate and determining the visiblevolumes as quickly as possible.andP;  The first goal precludes having multipleprocesses perform volume-visibility checks in parallel, with each processfeeding the contents of visible volumes to the graphics hardware.andP;  Ifmultiple processes write to the graphics hardware, the hardware must betreated as a critical section to avoid the intermixing of geometric data.andO;The resultant synchronization overhead might prevent full utilization of thegraphics hardware.andM;We achieved both design goals by dedicating one processor to sending thecurrent list of in-view geometry to the graphics hardware while the remainingprocessors performed the culling operations on the octree in parallel (seeFigure 5).andP;  Since one processor repeatedly traversed a linear list ofpolygons and fed them to the graphics hardware, maximum display-up-date rateswere sustained.andM;The problem that remained was how the culling process could keep pace withchanging view parameters.andP;  Although the sequential solution cannot deliveruninterrupted display updates, the list of in-view geometry alwayscorresponds to the current viewing direction.andP;  With the multiprocessorapproach, the culling operations occur asynchronously to the traversal anddisplay of in-view geometry.andP;  The list of in-view geometry to be rendered isupdated only after the culling is completed.andP;  Thus, if the culling operationcannot keep up with the moving viewer, some geometry that should be displayedis momentarily missing from the rendered scene.andP;  Once the culling iscompleted, the missing geometry pops&quot; into view.andP;  We minimized this poppingeffect by taking a parallel approach to the culling algorithm.andM;Our parallel culling algorithm was basically a parallel, depth-firsttraversal of an octree.andP;  We invoked multiple culling processes using routinesprovided in the multiprocessing library (libmp), each of which worksasynchronously on one octant at a time.andP;  If the current octant for a processwas wholly or partially contained in the viewer's field of view, the polygonsin that octant were tagged as being in view.andP;  Next, the process added sevenof the eight child octants to a queue of octants that still needed to beprocessed.andP;  It then descended recursively to the eighth child octant.andP;  If thecurrent octant was not in view, then the child octants need never be visited.andO;Once a process reached a leaf octant, it took the next octant off the frontof the queue for processing.andP;  The culling process was completed when thequeue was empty and all processes had reached leaf octants.andM;Using a four-processor system and a model of midtown Manhattan containingover 150,000 polygons (shown in Figure 6), our parallel viewer achievedrendering rates 3 to 4 times as fast as that of a sequential implementation.andM;Real-Time Finite Element Analysis.andP;  In this example we consider the use ofmulti-processors in the acceleration of analysis-tracking of a preexistingapplication.andP;  In particular, this example provides one possible template forbringing older analysis-application architectures into the visual computingenvironment of the 1990s.andP;  The code we tracked was DYNA3D, athree-dimensional finite-element program for analyzing large-deformationdynamic response in inelastic solids.andP;  The original program was developed in1976 at Lawrence Livermore National Laboratory, and has since evolved into ahighly vectorized collection of algorithms well suited for super-computerarchitectures [5].andP;  This code and its derivatives are in daily use throughoutthe world; in this country, a primary use in the automotive industry is tosimulate and analyze the behavior of cars in crash situations, thus reducingthe amount of costly automotive testing automakers must conduct.andM;When analyzing complex problems such as car crashes, engineers often need togenerate many trial solutions before a complete and accurate final solutioncan be run.andP;  During this development stage, boundary conditions, materialspecifications, and model geometry may require modification.andP;  Due toequipment and software limitations, validating the model incrementally hasgenerally involved issuing a series of small batch runs.andP;  As confidence isgained, the runtimes are slowly increased to cover the entire duration ofinterest and obtain more complete results.andP;  Unfortunately, in the initialstages of model definition and specification, the user frequently runs intounexpected model behavior.andP;  Detecting and correcting these problems hasproven to be both costly and time-consuming.andP;  Tracking provides an importantmechanism to detect these anomalous calculations early on in the analysiscycle without unnecessary stops and restarts.andP;  This both allows the user tomake timely corrections to the model and substantially reduces the number ofcycles spent going down the wrong paths.andM;Our tracking implementation for DYNA3D incurs low overhead while providingconsiderable flexibility.andP;  The modifications required to make DYNA3Dtrackable were quite small: a global shared-memory region had to be openedduring program initialization and updated analysis results posted at suitabletime intervals during problem solution.andP;  We chose mmap to open theshared-memory area, as it provided both the desired protections and namingconvenience using UNIX file descriptors [2].andP;  This allowed otherwiseunrelated processes to map a shared region of memory independently into theirown logical address spaces.andP;  Additionally, this globally-shared-memory area&quot;opened up&quot; the architecture.andP;  We were then free to attach and detachinteractive viewers during the execution of DYNA3D.andP;  In fact, multipleindependent viewers could be used simultaneously if desired.andM;One viewer of particular interest is &quot;Solidview&quot; [6], a program designed forviewing finite-element results.andP;  It has options for displaying computedresults in a variety of interactive modes.andP;  The user can &quot;slice&quot; through themodel using a geometric cutting plane to view results in the interior of themodel.andP;  Additionally, the user may control the generation of translucentiso-surfaces interactively, in order to better understand the distribution ofstress throughout the interior of the model.andP;  This graphics program has alsobeen modified to look for specified shared-memory communications areas and toupdate its view accordingly in real time.andP;  When neither new data nor new userinput is available, it sleeps, reducing CPU usage.andM;The initial dual-processor implementation of the DYNA3D interactive trackingenvironment had the DYNA3D process running on one processor while theSolidview process ran on the other.andP;  Analysis of CPU time used by bothprograms indicated that DYNA3D was a performance bottleneck, and thatadditional benefit could be gained by speeding up the DYNA3D task.andP;  Thisacceleration was accomplished through automatic parallelization of the DYNA3DFORTRAN source code using the Power FORTRAN Accelerator (PFA) [2], adata-flow analyzer layered on top of the f77 FORTRAN compiler.andP;  PFA generatesdirectives to the f77 compiler indicating how to parallelize the loopstructure of the original program.andM;If necessary, PFA performs additional optimizations such as loop reorderingto enhance the degree of parallelism.andP;  The fact that this program was alreadywell-tuned for vector architectures contributed greatly to the speedupsachieved using PFA.andP;  The loops that were previously  &quot;vectorized&quot; were primecandidates for natural, automatically detected parallelization.andP;  Using onlythree of the processors on a four-processor system, we were able to speed upDYNA3D analysis by 2.7 times.andP;  The fourth processor was dedicated tointeractive results-tracking using the Solidview program.andP;  This guaranteedfast visual interaction under direct user-input device control.andP;  A screenshot of a typical usage of this architecture is shown in Figure 7.andM;Real-Time Radiosity.andP;  In the third case, we used multi-processors toaccelerate and steer a computer-graphics illumination model known asradiosity.andP;  Radiosity is a technique for simulating global illuminationeffects in a scene consisting of diffusely reflecting surfaces [7].andP;  Theradiosity method is based on thermal engineering techniques for determiningthe exchange of radiant (light) energy between surfaces.andP;  Local illuminationtechniques such as Phong shading take into account only the light-sourceposition, and orientation and reflectance properties of the surface beingilluminated.andP;  Local techniques are frequently used in computer graphicsbecause they are relatively inexpensive to process.andM;Global illumination models, on the other hand, account for all surfaces inthe scene when making their computations.andP;  As a result, important effectssuch as shadows, inter-reflections, and color bleeding are realized.andP;  Anadditional benefit of the radiosity method is that the solution isview-independent.andP;  That is, once the color values for each surface have beencomputed, no further lighting calculations need be made when the viewparameters change.andP;  This feature makes the method very attractive forapplications such as architectural &quot;walk-throughs&quot;.andM;The most popular radiosity algorithm is iterative and allows users to viewpartial solutions as the algorithm progresses [8].andP;  The first step in thealgorithm is to discretize the 3D model into many small surface patches.andP;  Thegoal of the algorithm is to determine the correct color for each surfacepatch.andP;  At each iteration, the patch with the most light energy to contributeto the scene &quot;shoots&quot; its energy to the rest of the environment.andP;  Todetermine how much energy, if any, each patch receives, a visible-surfacecalculation is applied from the point of view of the shooting patch.andM;The computational cost and structure of the radiosity method made it anexcellent candidate for parallel processing.andP;  At a high level, we partitionedthe algorithm for parallel processing by splitting the computation into aproducer task and a consumer task [9].andP;  The producer task was responsible foridentifying which surface patches were visible to the shooting patch for thehemisphere of directions surrounding the shooting patch.andP;  Because thisvisible-surface calculation had requirements very similar to those forrendering 3D geometry, we used the graphics hardware rather than the hostprocessors for this task.andM;Of the three analysis techniques, our parallel radiosity implementation wasunique in that it used the graphics hardware to perform tasks other thanrendering.andP;  The result of the visible-surface calculation was a 2D array oritem-buffer.andP;  Item-buffer entries corresponded to the directions surroundingthe shooting patch.andP;  Each entry contained the ID of the patch visible to theshooting patch for the corresponding direction.andM;Since the producer task needed only one host processor to feed surfacepatches to the graphics hardware, we dedicated the remaining processors tothe consumer task.andP;  The consumer task processed the item-buffer to determinewhat portion of the light energy radiated by the shooting patch would bereceived by the remaining surface patches.andP;  This processing required that anarea integral be evaluated for each visible patch.andP;  To process theitem-buffer in parallel, the consumer task first divided it into a number ofequal-sized blocks, then spawned several processes, one for each availablehost processor.andP;  Since block-processing times varied, blocks were scheduleddynamically.andP;  We created and scheduled processes explicit constructs providedby libmp.andM;Choice of block size plays an important role in utilizing multiple processorsefficiently.andP;  If the blocks are too small, too much time is spent onsynchronization for dynamic scheduling; if blocks are too large, there is aninsufficient number of blocks to balance processor loads.andM;Since we relegated production of the item-buffers to the graphics hardware,there was no reason for the host processors to remain idle while theitem-buffers were produced.andP;  We employed a buffered producer-consumer schemeto overlap production of the item-buffer with remaining host calculations.andO;While one processor sent the 3D scene description to the geometry subsystemto produce the item-buffer for the current iteration, the remainingprocessors processed the item-buffer from a previous iteration.andM;We were able to track the partial results of the radiosity computation usinga method similar to the one we used with DYNA3D, employing an interactiveviewer that communicated via shared memory.andP;  After each iteration, theradiosity program updated the surface colors in shared memory and notifiedthe viewing program that the update had taken place.andP;  The viewing programthen read the updated colors and used them for display until a subsequentcolor update occurred.andP;  The protocol between the viewing and radiosityprograms was actually bi-directional, allowing the interactive viewer to&quot;steer&quot; the radiosity computation.andP;  In addition to receiving updated surfacecolors, the viewer sent the current viewer position and direction back to theradiosity program.andP;  The radiosity program used this view information todetermine where in the scene it should accelerate the illuminationcomputation.andP;  The overall algorithm organization is shown in Figure 8.andM;Using an eight-processor system, we achieved a sixfold speedup when sevenprocessors were allocated to the radiosity program, and the remainingprocessor was used by the interactive viewer to monitor and control theprogress of the computation.andP;  Figure 9 shows an image displayed by theinteractive viewer.andM;As we can see, the use of multiprocessor graphics workstations can greatlyenhance the performance of the three fundamental forms of data analysis andvisual interaction.andP;  Given an architecture that harmoniously integratesmultiple host CPUs with dedicated graphics hardware, the host CPUs can beused to boost rendering performance (postprocessing) or support simultaneousanalysis and graphics-display tasks (tracking and steering).andP;  Because oftheir high price/performance benefits and programming flexibility,multiprocessor graphics workstations are quickly becoming the visualcomputing tools of the 90s.andM;Daniel R. Baum received an AB in engineering science from Dartmouth Collegeand an MS from the Program of Computer Graphics at Cornell University.andP;  Hecurrently manages the graphics software group in the Advanced SystemsDivision of Silicon Grap Inc. At SGI he has participated in the design andimplementation of the GT, GTX, and VGX graphics systems.andP;  Baum's researchinterests include realistic image synthesis and parallel graphics algorithms.andM;James M. Winget is a principal scientist at Silicon Graphics.andP;  He waspreviously the director of application software in the MCAE Division at SGI,and before that was a research assistant professor in biomedical engineeringat Duke University.andP;  He has been a consultant for Sutherland, Sproull, andAssociates, and for Lockheed Missiles and Space Co. Winget earned his BS inengineering from the University of Cincinnati and his PhD in appliedmechanics from the California Institute of Technology.andP;  ReferencesandM;[1] Kurt Akeley, &quot;The Silicon Graphics 4D/240GTX Superworkstation&quot;, IEEEComputer Graphics and Applications, Vol.andP;  9, No.andP;  4, pp.andP;  7183 (July 1989).andM;[2] Silicon Graphics Computer Systems, Technical Report: Power Series,Mountain View, CA (1989).andM;[3] Benjamin Garlick, Daniel R. Baum, and James M. Winget, &quot;InteractiveViewing of Large Geometric Databases Using Multiprocessor GraphicsWorkstations,&quot; SIGGRAPH '90 Course Notes (Parallel Algorithms andArchitectures for 3D Image Generation), No.andP;  28 (August 1990).andM;[4] Hanen Samet, Applications of Spatial Data Structures, Addison-WesleyPublishing Co., Reading, MA (1989).andM;[5] J.0.andP;  Hallquist, &quot;DYNA3D User's Manual (Nonlinear Dynamic Analysis ofSolids in Three Dimensions)&quot;, University of California, Lawrence LivermoreNational Laboratory, Rept.andP;  UCID-19401 (1982).andM;[6] James M. Winget, &quot;Advanced Graphics Hardware for Finite Element ResultsDisplay&quot;, Advanced Topics in Finite Element Analysis, PVP-Vol.andP;  143, ASME(1988).andM;[7] Michael F. Cohen and Donald P. Greenberg, &quot;The Hemi-Cube: A RadiositySolution for Complex Environments&quot;, Computer Graphics (SIGGRAPH '85Proceedings), Vol.andP;  19, No.andP;  3, pp.andP;  31-40 (July 1985).andM;[8] Michael F. Cohen, Shenchang Eric Chen, John R. Wallace, and Donald P.andO;Greenberg, &quot;A Progressive Refinement Approach to Fast Radiosity Generation&quot;,Computer Graphics  SIGGRAPH'88 Proceedings), Vol.andP;  22, No.andP;  4, pp.andP;  75-84(August 1988).andM;[9] Daniel R. Baum and James M. Winget, &quot;Real Time Radiosity Through ParallelProcessing and Hardware Acceleration&quot;, Computer Graphics (Proceedings of the1990 Symposium on Interactive 3D Graphics), Vol.andP;  24, No.andP;  2, pp.andP;  67-75(March 1990).andO;</TEXT></DOC>