<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-290-863  </DOCNO><DOCID>07 290 863.andM;</DOCID><JOURNAL>Communications of the ACM  Jan 1989 v32 n1 p9(15)* Full Text COPYRIGHT Assn. for Computing Machinery, Inc. 1989.andM;</JOURNAL><TITLE>Computing as a discipline. (final report of the Task Force on theCore of Computer Science) (technical)</TITLE><AUTHOR>Denning, Peter J.; Comer, Douglas E.; Gries, David; Mulder,Michael C.; Tucker, Allen; Turner, A. Joe; Young, Paul R.andM;</AUTHOR><SUMMARY>The Task Force on the Core of Computer Science offers its finalreport for a new intellectual approach for the discipline ofcomputing and computing curricula.andP;  Offered is a condensation ofthe full report presenting the charter of the task force,paradigms for the discipline, the role of programming, adescription of computing and a curriculum model.andP;  Curriculum isdivided into the introductory sequence and the laboratories andthe requirements and prerequisites for each.andP;  An appendix with adefinition of computing as a discipline is given in outline form.andM;</SUMMARY><DESCRIPT>Topic:     Computer scienceComputer EducationReports.andM;</DESCRIPT><NOTE>Only Text is presented here; see printed issues for graphics.andO;</NOTE><TEXT>COMPUTING AS A DISCIPLINE It is ACM's 42nd year and an old debate continues.andO;Is computer science a science?andP;  An engineering discipline?andP;  Or merely atechnology, an inventor and purveyor of computing commodities?andP;  What is theintellectual substance of the discipline?andP;  Is it lasting, or will it fadewithin a generation?andP;  Do core curricula in computer science and engineeringaccurately reflect the field?andP;  How can theory and lab work be integrated in acomputing curriculum?andP;  Do core curricula foster competence in computing?andM;We project an image of a technology-oriented discipline whose fundamentalsare in mathematics and engineering--for example, we represent algorithms asthe most basic objects of concern and programming and hardware design as theprimary activities.andP;  The view that &quot;computer science equals programming&quot; isespecially strong in most of our current curricula: the introductory courseis programming, the technology is in our core courses, and the science is inour electives.andP;  This view blocks progress in reorgnizing the curriculum andturns away the best students, who want a greater challenge.andP;  It denies acoherent approach to making experimental and theoretical computer scienceintegral and harmonious parts of a curriculum.andM;Those in the discipline know that computer science encompasses far more thanprogramming--for example, hardware design, system architecture, designingoperating system layers, structuring a database for a specific application,and validating models are all part of the discipline, but are notprogramming.andP;  The emphasis on programming arises from our long-standingbelief that programming languages are excellent vehicles for gaining accessto the rest of the field, a belief that limits our ability to speak about thediscipline in terms that reveal its full breadth and richness.andM;The field has matured enough that it is now possible to describe itsintellectual substance in a new and compelling way.andP;  This realization arosein discussions among the heads of the PhD.-granting departments of computerscience and engineering in their meeting in Snowbird, Utah, in July 1984.andO;These and other similar discussions prompted ACM and the IEEE ComputerSociety to form task forces to create a new approach.andP;  In the spring of 1985,ACM president Adele Goldberg and ACM Education Board Chairman Robert Aikenappointed this task force on the core of computer science with theenthusiastic cooperation of the IEEE Computer Society.andP;  At the same time, theComputer Society formed a task force on computing laboratories with theenthusiastic cooperation of the ACM.andM;We hope that the work of the core task force, embodied in this report, willproduce benefits beyond the original charter.andP;  By identifying a common coreof subject matter, we hope to streamline the processes of developingcurricula and model programs in the two societies.andP;  The report can be thebasis for future discussions of computer science and engineering as aprofession, stimulate improvements in secondary school courses in computing,and can lead to a greater widespread appreciation of computing as adiscipline.andM;Our goal has been to create a new way of thinking about the field.andP;  Hoping toinspire general inquiry into the nature of our discipline, we sought aframework, not a prescription; a guideline, not an instruction.andP;  We inviteyou to adopt this framework and adapt it to your own situation.andM;We are pleased to present a new intellectual framework for our discipline anda new basis for our curricula.andM;CHARTER OF THE TASK FORCEandM;The task force was given three general charges:andM;1.andP;  Present a description of computer science that emphasizes fundamentalquestions and significant accomplishments.andP;  The definition should recognizethat the field is constantly changing and that what is said is merely asnapshot of an ongoing process of growth.andM;2.andP;  Propose a teaching paradigm for computer science that conforms totraditional scientific standards, emphasizes the development of competence inthe field, and harmoniously integrates theory, experimentation, and design.andM;3.andP;  Give a detailed example of an introductory course sequence in computerscience based on the curriculum model and the disciplinary description.andM;We immediately extended our task to encompass both computer science andcomputer engineering, because we concluded that no fundamental differenceexists between the two fields in the core material.andP;  The differences aremanifested in the way the two disciplines elaborate the core: computerscience focuses on analysis and abstraction; computer engineering onabstraction and design.andP;  The phrase discipline of computing is used here toembrace all of computer science and engineering.andM;Two important issues are outside the charter of this task force.andP;  First, thecurriculum recommendations in this report deal only with the introductorycourse sequence.andP;  It does not address the important, larger question of thedesign of the entire core curriculum, and indeed the suggested introductorycourse would be meaningless without a new design for the rest of the core.andO;Second, our specification of an introductory course is intended to be anexample of an approach to introduce students to the whole discipline in arigorous and challenging way, an &quot;existence proof&quot; that our definition ofcomputing can be put to work.andP;  We leave it to individual departments to applythe framework to develop their own introductory courses that meet localneeds.andM;PARADIGMS FOR THE DISCIPLINEandM;The three major paradigms, or cultural styles, by which we approach our workprovide a context for our definition of the discipline of computing.andP;  Thefirst paradigm, theory, is rooted in mathematics and consists of our stepsfollowed in the development of a coherent, valid theory:andM;(1) characterize objects of study (definition);andM;(2) hypothesize possible relationships among them (theorem);andM;(3) determine whether the relationships are true (proof);andM;(4) interpret results.andM;A mathematician expects to iterate these steps (e.g., when errors orinconsistencies are discovered.andM;The second pradigm, abstraction (modeling), is rooted in the experimentalscientific method and consists of four stages that are followed in theinvestigation of a phenomenon: (1) form a hypothesis; (2) construct a modeland make a prediction; (3) design an experiment and collect data; (4) analyzeresults.andM;A scientist expects to iterate these steps (e.g., when a model's predictionsdisagree with experimental evidence).andP;  Even though &quot;modeling&quot; and&quot;experimentation&quot; might be appropriate substitutes, we have chosen the word&quot;abstraction&quot; for this paradigm because this usage is common in thediscipline.andM;The third paradigm, design, is rooted in engineering and consists of foursteps followed in the construction of a system (or device) to solve a givenproblem: (1) state requirements; (2) state specifications; (3) design andimplement the system; (4) test the system.andM;An engineer expects to iterate these steps (e.g., when tests reveal that thelatest version f the system does not satisfactorily meet the requirements).andM;Theory is the bedrock of the mathematical sciences: applied mathematiciansshare the notion that science advances only on a foundation of soundmathematics.andP;  Abstraction (modeling) is the bedrock of the natural sciences:scientists share the notion that scientific progress is achieved primarily byformulating hypotheses and systematically following the modeling process toverify and validate them.andP;  Likewise, design is the bedrock of engineering:engineers share the notion that progress is achieved primarily by posingproblems and systematically following the design process to construct systemsthat solve them.andP;  Many debates about the relative merits of mathematics,science, and engineering are implicitly based on an assumption that one ofthe three processes (theory, abstraction, or design) is the most fundamental.andM;Closer examination, however, reveals that in computing the three processesare so intricately intertwined that it is irrational to say that any one isfundamental.andP;  Instances of theory appear at every stage of abstraction anddesign, instances of modeling at every stage of theory and design, andinstances of design at every stage of theory and abstraction.andM;Despite their inseparability, the three paradigms are distinct from oneanother because they represent separate areas of competence.andP;  Theory isconcerned with the ability to describe and prove relationships among objects.andO;Abstraction is concerned with the ability to use those relationships to makepredictions that can be compared with the world.andP;  Design is concerned withthe ability to implement specific instances of those relationships and usethem to perform useful actions.andP;  Applied mathematicians, computationalscientists, and design engineers generally do not have interchangeableskills.andM;Moreover, in computing we tend to study computational aids that supportpeople engaged in information-transforming processes.andP;  On the design side,for example, sophisticated VLSI design and simulation systems enable theefficient and correct design of microcircuitry, and programming environmentsenable the efficient design of software.andP;  On the modeling side,supercomputers evaluate mathematical models and make predictions about theworld, and networks help disseminate findings from scientific experiments.andO;On the theory side, computers help prove theorems, check the consistency ofspecifications, check for counterexamples, and demonstrate test cases.andM;Computing sits at the crossroads among the central processes of appliedmathematics, science, and engineering.andP;  The three processes are of equal--andfundamental--importance in the discipline, which is a unique blend ofinteraction among theory, abstraction, and design.andP;  The binding forces are acommon interest in experimentation and design as information transformers, acommon interest in computational support of the stages of those processes,and a common interest in efficiency.andM;THE ROLE OF PROGRAMMINGandM;Many activities in computing are not programming--for example, hardwaredesign, system architecture, operating system structure, designing a databaseapplication, and validating models--therefore the notion that &quot;computerscience equals programming&quot; is misleading.andP;  What is the role of programmingin the discipline?andP;  In the curriculum?andM;Clearly programming is part of the standard practices of the discipline andevery computing major should achieve competence in it.andP;  This does not,however, imply that the curriculum should be based on programming or that theintroductory courses should be programming courses.andM;It is also clear that access to the distinctions of any domain is giventhrough language, and that most of the distinctions of computing are embodiedin programming notations.andP;  Programming languages are useful tools for gainingaccess to the distinctions of the discipline.andP;  We recommend, therefore, thatprogramming be a part of the competence sought by the core curriculum, andthat programming languages be treated as useful vehicles for gaining accessto important distinctions of computing.andM;A DESCRIPTION OF COMPUTINGandM;Our description of computing as a discipline consists of four parts: (1)requirements; (2) short definition; (3) division into subareas; and (4)elaboration of subareas.andP;  Our presentation consists of four passes, eachgoing to a greater level of detail.andM;What we say here is merely a snapshot of a changing and dynamic field.andP;  Weintend this to be a &quot;living definition,&quot; that can be revised from time totime to reflect maturity and change in the field.andP;  We expect revisions tooccur most frequently in the details of the subareas, occasionally in thelist of subareas, and rarely in the short definition.andM;RequirementsandM;There are many possible ways to formulate a definition.andP;  We set fiverequirements for ours:andM;1.andP;  It should be understandable by people outside the field.andM;2.andP;  It should be a rallying point for people inside the field.andM;3.andP;  It should be concrete and specific.andM;4.andP;  It should elucidate the historical roots of the discipline inmathematics, logic, and engineering.andM;5.andP;  It should set forth the fundamental questions and significantaccomplishments in each area of the discipline.andM;In the process of formulating a description, we considered several otherprevious definitions and concluded that a description meeting theserequirements must have several levels of complexity.andP;  The other definitionsare briefly summarized here.andM;In 1967, Newell, Perlis, and Simon [5] argued that computer science is thestudy of computers and the major phenomena that surround them, and that allthe common objections to this definition could just as well be used todemonstrate that other sciences are not science.andP;  Despite their eloquence,too many people view this as a circular definition that seems flippant tooutsiders.andP;  It is, however, a good starting point because the definition wepresent later can be viewed as an enumeration of the major phenomenasurrounding computers.andM;A slightly more elaborate version of this idea was recently used by theComputing Sciences Accreditation Board (CSAB), which said, &quot;Computer scienceis the body of knowledge concerned with computers and computation.andP;  It hastheoretical, experimental, and design components and includes (1) theoriesfor understanding computing devices, programs, and systems; (2)experimentation for the development and testing of concepts; (3) designmethodology, algorithms, and tools for practical realizationf and (4) methodsof analysis for verifying that these realizations meet requirements.&quot;andM;A third definition is, &quot;Computer science is the study of knowledgerepresentations and their implementations.&quot;andP;  This definition suffers fromexcessive abstraction and few people would agree on the meaning of knowledgerepresentation.andP;  A related example that suffers the same fate is, &quot;Computerscience is the study of abstraction and the mastering of complexicity,&quot; astatement that also applies to physics, mathematics, or philoosophy.andM;A final observation comes from Abelson and Sussman, who say, &quot;The computerrevolution is a revolution in the way we think and in the way we express whatwe think.andP;  The essence of this change is the emergence of what might best becalled procedural espistemology--the study of the structure of knowledge froman imperative point of view, as opposed to the more declarative point of viewtaken by classical mathematical subjects.andP;  Mathematics provides a frameworkfor dealing precisely with notions of 'what is.'andP;  Computation provides aframework for dealing precisely with notions of 'how to' [1].&quot;andM;Short DefinitionandM;The discipline of computing is the systematic study of algorithmic processesthat describe and transform information: their theory, analysis, design,efficiency, implementation, and application.andP;  The fundamental questionunderlying all of computing is, &quot;What can be (efficiently) automated?&quot;andM;Division into SubareasandM;We grappled at some length with the qeustion of dividing the discipline intosubareas.andP;  We began with a preference for a small number of subareas, such asmodel versus implementation, or algorithm versus machine.andP;  However, thevarious candidates we devised were too abstract, the boundaries betweendivisions were too fuzzy, and most people would not have identifiedcomfortably with them.andM;Then we realized that the fundamentals of the discipline are contained inthree basic processes--theory, abstraction, and design--that are used by thedisciplinary subareas to accomplish their goals.andP;  Thus, a description of thediscipline's subareas and their relation to these three basic processes wouldbe useful.andP;  To qualify as a subarea, a segment of the discipline must satisfyfour criteria: (1) underlying unity of subject matter; (2) substantialtheoretical component; (3) significant abstractions; (4) important design andimplementation issues.andM;Moreover, we felt that each subarea should be identified with a researchcommunity, or set of related communities, that sustains its own literature.andM;Theory includes the processes for developing the underlying mathematics ofthe subarea.andP;  These processes are supported by theory from other areas.andP;  Forexample, the subarea of algorithms and data structures contains complexitytheory and is supported by graph theory.andP;  Abstraction deals with modelingpotential implementations.andP;  These models suppress detail while retainingessential features; they are amenable to analysis and provide means forcalculating predictions of the modeled system's behavior.andP;  Design deals withthe process of specifying a problem, transforming the problem statement intoa design specification, and repeatedly inventing and investigatingalternative solutions until a reliable, maintainable, documented, and testeddesign that meets cost criteria is achieved.andM;We discerned nine subareas that cover the field: 1.andP;  Algorithms and datastructures 2.andP;  Programming languages 3.andP;  Architecture 4.andP;  Numerical andsymbolic computation 5.andP;  Operating systems 6.andP;  Software methodology andengineering 7.andP;  Database and information retrieval systems 8.andP;  Artificialintelligence and robotics 9.andP;  Human-computer communicationandM;Elaboration of SubareasandM;To present the content of the subareas, we found it useful to think of a 9 X3 matrix, as shown in Figure 1.andP;  Each row is associated with a subarea, andtheory, abstraction, and design each define a column.andM;Each square of the matrix will be filled in with specific statements aboutthat subarea component; these statements will describe issues of concern andsignificant accomplishments.andM;Certain affinity groups in which there is scientific literature are not shownas subareas because they are basic concerns throughout the discipline.andP;  Forexample, parallelism surfaces in all subareas (there are parallel algorithms,parallel languages, parallel architectures, etc.) and in theory, abstraction,and design.andP;  Similar conclusions hold for security, realiability, andperformance evaluation.andM;Computer scientists will tend to associate with the first two columns of thematrix, and computer engineers with the last two.andP;  The full description ofcomputing, as specified here, is given in the appendix.andM;CURRICULUM MODELandM;Competence in the DisciplineandM;The goal of education is to develop competence in a domain.andP;  Competence, thecapability for effective action, is an assessment of individual performanceagainst the standard practices of the field.andP;  The criteria for assessment aregrounded in the history of the field.andP;  The educational process that leads tocompetence has five steps: (1) motivate the domain; (2) demonstrate what canbe accomplished in the domain; (3) expose the distinctions of the domain; (4)ground the distinctions in history; and (5) practice the distinctions [4].andM;This model has interesting implications for curriculum design.andP;  The firstquestion it leads to is, In what areas of computing must majors be competent?andO;There are two broad areas of competence:andM;1.andP;  Discipline-Oriented Thinking: The ability to invent new distinctions inthe field, leading to new modes of action and new tools that make thosedistinctions available for others to use.andM;2.andP;  Tool Use: The ability to use the tools of the field for effective actionin other domains.andM;We suggest that discipline-oriented thinking is the primary goal of acurriculum for computing majors, and that majors must be familiar enough withthe tools to work effectively with people in other disciplines to help designmodes of effective action in those disciplines.andM;The inquiry into competence reveals a number of areas where current corecurricula in computing is inadequate.andP;  For example, the historical context ofthe computing field is often deemphasized, leaving many graduates ignorant ofcomputing history and destined to repeat its mistakes.andP;  Many computinggraduates wind up in business data processing, a domain in which mostcomputing curricula do not seek to develop competence; whether computingdepartments or business departments should develop that competence is an oldcontroversy.andP;  Discipline-oriented thinking must be based on solidmathematical foundations, yet theory is not an integral part of mostcomputing curricula.andP;  The standard practices of the computing field includesetting up and conducting experiments, contributing to team projects, andinteracting with other disciplines to support their interests in effectiveuse of computing, but most curricula neglect laboratory exercises, teamprojects, or interdisciplinary studies.andM;The question of what results should be achieved by computing curricula hasnot been explored thoroughly in past discussions, and we will not attempt athorough analysis here.andP;  We do strongly recommend that this question be amongthe first considered in the design of new core curricula for computing.andM;Lifelong LearningandM;The curriculum should be designed to develop an appreciation for learningwhich graduates will carry with them throughout their careers.andP;  Many coursesare designed with a paradigm that presents &quot;answers&quot; in a lecture format,rather than focusing on the process of questioning that underlies alllearning.andP;  We recommend that the follow-on committee consider other teachingparadigms which involve processes of inquiry, an orientation to using thecomputing literature, and the development of a commitment to a lifelongprocess of learning.andM;INTRODUCTORY SEQUENCEandM;In this curriculum model, the motivation and demonstration of the domain mustprecede instruction and practice in the domain.andP;  The purpose of theintroductory course sequence is precisely this.andP;  The principal areas ofcomputing--in which majors must develop competence--must be presented tostudents with sufficient depth and rigor that they can appreciate the powerof the areas and the benefits from achieving competence in them.andP;  Theremainder of the curriculum must be carefully designed to systematicallyexplore those areas, exposing new concepts and distinctions, and givingstudents practice in them.andM;We therefore recommend that the introductory course consist of regularlectures and a closely coordinated weekly laboratory.andP;  The lectures shouldemphasize funamentals; the laboratories technology and know-how.andM;This model is traditional in the physical sciences and engineering: lecturesemphasize enduring principles and concepts while laboratories emphasize thetransient material and skills relating to the current technology.andP;  Forexample, lectures would discuss the design and analysis of algorithms, or theorganization of network protocols in functional layers.andP;  In the correspondinglaboratory sessions, students would write programs for algorithms analyzed inlecture and measure their running times, or instal and test networkinterfaces and measure their packet throughputs.andM;Within this recommendation, the first courses in computer science would notonly introduce programming, algorithms, and data structures, but introducematerial from all the other subdisciplines as well.andP;  Mathematics and othertheory would be well integrated into the lectures at appropriate points.andM;We recommend that the introductory course contain a rigorous, challengingsurvey of the whole discipline.andP;  The physics model, exemplified by theFeynman Lectures in Physics, is a paradigm for the introductory course weenvisage.andM;We emphasize that simply redesigning the introductory course sequencefollowing this recommendation without redesigning the entire undergraduatecurriculum would be a serious mistake.andP;  The experience of physics departmentscontains many lessons for computing departments in this regard.andM;PrerequisitesandM;We assume that computing majors have a modest background in programming insome language and some experience with computer-based tools such as wordprocessors, spreadsheets, and databases.andP;  Given the widening use of computersin high schools and at home, it might seem that universities could assumethat most incoming students have such a background and provide a &quot;remedial&quot;course in programming for the others.andP;  We have found, however, that theassumption of adequate high school preparation in programming is quitecontroversial and there is evidence that adequate preparation is rare.andP;  Wetherefore recommend that computing departments offer an introduction toprogramming and computer tools that would be a prerequisite (or corequisite)for the introductory courses.andP;  We further recommend that departments providean advanced placement procedure so that students with adequate high schoolpreparation can bypass this course.andM;Formal prerequisites and corequisites in mathematics are more difficult tostate and will depend on local circumstances.andP;  However, accrediting boards incomputing require considerable mathematics, including discrete mathematics,differential and integral calculus, and probability and statistics.andP;  Theserequirements are often exceeded in teh better undergraduate programs.andP;  In ourdescription of a beginning computing curriculum, we have spelled out in somedetail what mathematics is applicable in each of the nine identified areas ofcomputing.andP;  Where possible we have displayed the required mathematicalbackground for each of the teaching modules we describe.andP;  This will allowindividual departments to synchronize their own mathematical requirements andcourses with the material in the modules.andP;  In some cases it may beappropriate to introduce appropriate underlying mathematical topics as neededfor the development of particular topics in computing.andP;  In general, werecommend that students see applications of relevant mathematics as early aspossible in their computing studies.andM;Modular OrganizationandM;The introductory sequence should bring out the underlying unity of the fieldand should flow from topic to topic in a pedagogically natural way.andP;  It wouldtherefore be inadequate to organize the course as a sequence of ninesections, one for each of the subareas; such a mapping would appear to be ahodge-podge, with difficult transitions between sections.andP;  An ordering oftopics that meet these requirements is: Fundamental algorithm conceptsComputer organization (&quot;von Neumann&quot;) Mathematical programming Datastructures and abstraction Limits of computability Operating systems andsecurity Distributed computing and networks Models in artificial intelligenceFile and database systems Parallel computation Human interfaceandM;We have grouped the topics into 11 modules.andP;  Each module includes challengingmaterial representative of the subject matter without becoming a superficialsurvey of every aspect or topic.andP;  Each module draws material from severalsquares of the definition matrix as appropriate.andP;  As a result, many moduleswill not correspond one-to-one with rows of the definition matrix.andP;  Forexample, the first module in our example course is entitled FundamentalAlgorithm Concepts.andP;  It covers the role of formalism and theory, methods inprogramming, programming concepts, efficiency, and specific algorithms, drawsinformation from the first, second, fourth, and sixth rows of the definitionmatrix and deals only with sequential algorithms.andP;  Later modules, onDistributed Computing and Networks, and on Parallel Computation, extend thematerial in the first module and draw new material from the third and fifthrows of the definition matrix.andM;As a general approach, each module contains lectures that cover the requiredtheory and most abstractions.andP;  Theory is generally not introduced until it isneeded.andP;  Each module is closely coupled with laboratory sessions, and thenature of the laboratory assignments is included with the modulespecifications.andP;  Our specification is drawn up for a three-semester coursesequence containing 42 lectures and 35 scheduled laboratory sessions persemester.andP;  Our specification is not included here, but is in the full report.andM;We reemphasize that this specification is intended only to be an example of amapping from the disciplinary description to an introductory course sequence,not a prescription for all introductory courses.andP;  Other approaches areexemplified by existing introductory curricula at selected colleges anduniversities.andM;LABORATORIESandM;We have described a curriculum that separates principles from technologywhile maintaining coherence between the two.andP;  We have recommend that lecturesdeal with principles and laboratories with technology, with the two beingclosely coordinated.andM;The laboratories serve three purposes:andM;1.andP;  Laboratories should demonstrate how principles covered in the lecturesapply to the design, implementation, and testing of practical software andhardware.andP;  They should provide concrete experiences that help studentsunderstand abstract concepts.andP;  These experiences are essential to sharpenstudents' intuition about practical computing, and to emphasize theintellectual effort in building correct, efficient computer programs andsystems.andM;2.andP;  Laboratories should emphasize processes leading to good computingknow-how.andP;  They should emphasize programming, not programs; laboratorytechniques; understanding of hardware capabilities; correct use of softwaretools; correct use of documentation; and proper documentation of experimentsand projects.andP;  Many software tools will be required on host computers toassist in constructing, controlling, and monitoring experiments on attachedsubsystems; the laboratory should teach proper use of these tools:andM;3.andP;  Laboratories should introduce experimental methods, including use anddesign of experiments, software and hardware monitors, statistical analysisof results, and proper presentation of findings.andP;  Students should learn todistinguish careful experiments from casual observations.andM;To meet these goals, laboratory work should be carefully planned andsupervised.andP;  Students should attend labs at specified times, nominally threehours per week.andP;  Lab assignments should be planned, and written descriptionsof the purposes and methodology of each experiment should be given to thestudents.andP;  The depth of description should be commensurate with students'prior lab experience: more detail is required in early laboratories.andP;  Labassignments should be carried out under the guidance of a lab instructor whoensures that each student follows correct methodology.andM;The labs associated with the introductory courses will require closesupervision and should contain well-planned activities.andP;  This implies thatmore staff will be required per student for these laboratories than for moreadvanced ones.andM;The lab problems should be coordinated with material in the lecture parts ofthe course.andP;  Individual lab problems in general will deal with combinationsof hardware and software.andP;  Some lab assignments emphasize technologies andtools that ease the software development process.andP;  Others emphasize analyzingand measuring existing software or comparing known algorithms.andP;  Othersemphasize program development based on principles learned in class.andM;Laboratory assignments should be self-contained in the sense that an averagestudent should be able to complete the work in the time allocated.andO;Laboratory assignments should encourage students to discover and learn thingsfor themselves.andP;  Students should be required to maintain a proper lab bookdocumenting experiments, observations, and data.andP;  Students should also berequired to maintain their software and to build libraries that can be usedin later lab projects.andM;We expect that, in labs as in lectures, students will be assigned homeworkthat will require using computers outside the supervised realm of alaboratory.andP;  In other words, organized laboratory sessions will supplement,not replace, the usual programming and other written assignments.andM;In a substantial number of labs dealing with program development, theassignment should be to modify or complete an existing program supplied bythe instructor.andP;  This forces the student to read well-written programs,provides experience with integration of software, and results in a larger andmore satisfying program for the student.andM;Computing technology constantly changes.andP;  It is difficult, therefore, to givea detailed specification of the hardware systems, software systems,instruments, and tools that ought to be in a laboratory.andP;  The choice ofequipment and staffing in laboratories should be guided by the followingprinciples:andM;1.andP;  Laboratories should be equipped with up-to-date systems and languages.andO;Programming languages have a significant effect on shaping a student's viewof computing.andP;  Laboratories should deploy systems that encourage good habitsin students; it is especially important to avoid outdated systems (hardwareand software) in core courses.andM;2.andP;  Hardware and software must be fully maintained.andP;  Malfunctioning equipmentwill frustrate students and interfere with learning.andP;  Appropriate staff mustbe available to maintain the hardware and software used in the lab.andP;  Thesituation is analogous to laboratories in other disciplines.andM;3.andP;  Full functionality is important.andP;  (This includes adequate response timeon shared systems.)andP;  Restricting students to small subsets of a language orsystem may be useful in initial contacts, but the restrictions should belifted as the students progress.andM;4.andP;  Good programming tools are needed.andP;  Compilers get a lot of attention, butother programming tools are used as often.andP;  In UNIX systems, for example,students should use editors like emacs and learn to use tools like the shell,grep, awk, and make.andP;  Storage and processing facilities must be sufficient tomake such tools available for use in the lab.andM;5.andP;  Adequate support for hardware and instrumentation must be provided.andP;  Someprojects may require students to connect hardware units together, takemeasurements of signals, monitor data paths, and the like.andP;  A sufficientsupply of small parts, connectors, cables, monitoring devices, and testinstruments must be available.andM;The IEEE Computer Society Task Force on Goal Oriented Laboratory Developmenthas studied this subject in depth.andP;  Their report includes a discussion of theresources (i.e., staff and facilities) needed for laboratories at all levelsof the curriculum.andM;ACCREDITATIONandM;This work has been conducted with the intent that example courses beconsistent with current guidelines of the Computing Sciences AccreditationBoard (CSAB).andP;  The details of the mapping of this content to CSAB guidelinesdoes not fall within the scope of this committee.andM;CONCLUSIONandM;This report has been designed to provoke new thinking about computing as adiscipline by exhibiting the discipline's content in a way that emphasizesthe fundamental concepts, principles, and distinctions.andP;  It has alsosuggested a redesign of the core curriculum according to an education modelused in other disciplines: demonstrating the existence of useful distinctionsfollowed by practice that develops competence.andP;  The method is illustrated bya rigorous introductory course that puts the concepts and principles into thelectures and technology into closely coordinated laboratories.andM;A department cannot simply replace its current introductory sequence with thenew one; it must redesign the curriculum so that the new introduction is partof a coherent whole.andP;  For this reason, we recommend that the ACM establish afollow-on committee to complete the redesign of the core curriculum.andM;Many practical problems must be dealth with before a new curriculum model canbecome part of the field.andM;For example,andM;1.andP;  Faculties will need to redesign their curricula based on a new conceptualformulation.andM;2.andP;  No textbooks or educational materials based on the framework proposedhere are currently available.andM;3.andP;  Most departments have inadequate laboratories, facilities, and materialsfor the educational task suggested here.andM;4.andP;  Teaching assistants and faculty are not familiar with the new view.andM;5.andP;  Good high school preparation in computing is rare.andM;We recognize that many of our recommendations are challenging and willrequire substantial work to implement.andP;  We are convinced that theimprovements in computing education from the proposals here are worth theeffort, and invite you to join us in achieving them.andM;APPENDIXandM;A DEFINITION OF COMPUTING AS A DISCIPLINEandM;Computer science and engineering is the systematic study of algorithmicprocesses--their theory, analysis, design, efficiency, implementation, andapplication--that describe and transform information.andP;  The fundamentalquestion underlying all of computing is, What can be (efficiently) automated.andO;This discipline was born in the early 1940s with the joining together ofalgorithm theory, mathematical logic, and the invention of the stored-programelectronic computer.andM;The roots of computing extend deeply into mathematics and engineering.andO;Mathematics imparts analysis to the field; engineering imparts design.andP;  Thediscipline embraces its own theory, experimental method, and engineering, incontrast with most physical sciences, which are separate from the engineeringdisciplines that apply their findings (e.g., chemistry and chemicalengineering principles).andP;  The science and engineering are inseparable becauseof the fundamental interplay between the scientific and engineering paradigmswithin the discipline.andM;For several thousand years, calculation has been a principal concern ofmathematics.andP;  Many models of physical phenomena have been used to deriveequations whose solutions yield predictions of those phenomena--for example,calculations of orbital trajectories, weather forecasts, and fluid flows.andO;Many general methods for solving such equations have been devised--forexample, algorithms for systems of linear equations, differential equations,and integrating functions.andP;  For almost the same period, calculations that aidin the design of mechanical systems have been a principal concern ofengineering.andP;  Examples include algorithms for evaluating stresses in staticobjects, calculating momenta of moving objects, and measuring distances muchlarger or smaller than our immediate perception.andM;One product of the long interaction between engineering and mathematics hasbeen mechanical aids for calculating.andP;  Some surveyors' and navigators'instruments date back a thousand years.andP;  Pascal and Leibniz built arithmeticcalculators in the middle 1600s.andP;  In the 1830s, Babbage conceived of an&quot;analytical engine&quot; that could mechanically and without error evaluatelogarithms, trigonometric functions, and other general arithmetic functions.andO;His machine, never completed, served as an inspiration for later work.andP;  Inthe 1920s, Bush constructed an electronic analog computer for solving generalsystems of differential equations.andP;  In the same period, electromechanicalcalculating machines capable of addition, subtraction, multiplication,division, and square root computation became available.andP;  The electronicflip-flop provided a natural bridge from these machines to digital versionswith no moving parts.andM;Logic is a branch of mathematics concerned with criteria of validity ofinference and formal principles of reasoning.andP;  Since the days of Euclid, ithas been a tool for rigorous mathematical and scientific argument.andP;  In the19th century a search began for a universal system of logic that would befree of the incompletenesses observed in known deductive systems.andP;  In acomplete system, it would be possible to determine mechanically whether anygiven statement is either true or false.andP;  In 1931, Godel published his&quot;incompleteness theorem,&quot; showing that there is no such system.andP;  In the late1930s, Turing explored the idea of a universal computer that could simulateany step-by-step procedure of any other computing machine.andP;  His findings weresimilar to Godel's: some well-defined problems cannot be solved by anymechanical procedure.andP;  Logic is important not only because of its deepinsight into the limits of automatic calculation, but also because of itsinsight that strings of symbols, perhaps encoded as numbers, can beinterpreted both as data and as programs.andM;This insight is the key idea that distinguishes the stored program computerfrom calculating machines.andP;  The steps of the algorithm are encoded in amachine representation and stored in the memory for later decoding andexecution by the processor.andP;  The machine code can be derived mechanicallyfrom a higher-level symbolic form, the programming language.andM;It is the explicit and intricate intertwining of the ancient threads ofcalculation and logical symbol manipulation, together with the modern threadsof electronics and electronic representation of information, that gave birthto the discipline of computing.andM;We identified nine subareas of computing: 1.andP;  Algorithms and data structures2.andP;  Programming languages 3.andP;  Architecture 4.andP;  Numerical and symboliccomputation 5.andP;  Operating systems 6.andP;  Software methodology and engineering 7.andO;Databases and information retrieval 8.andP;  Artificial intelligence and robotics9.andP;  Human-Computer communicationandM;Each has an underlying unity of subject matter, a substantial theoreticalcomponent, significant abstractions, and substantial design andimplementation issues.andP;  Theory deals with the underlying mathematicaldevelopment of the subarea and includes supporting theory such as graphtheory, combinations, or formal languages.andP;  Abstraction (or modeling) dealswith models of potential implementations; the models suppress detail, whileretaining essential features, and provide means for predicting futurebehavior.andP;  Design deals with the process of specifying a problem, derivingrequirements and specifications, iterating and testing prototypes, andimplementing a system.andP;  Design includes the experimental method, which incomputing comes in several styles: measuring programs and systems, validatinghypotheses, and prototyping to extend abstractions to practice.andM;Although software methodology is essentially concerned with design, it alsocontains substantial elements of theory and abstraction.andP;  For this reason, wehave identified it as a subarea.andP;  On the other hand, parallel and distributedcomputation are issues that pervade all the subareas and all their components(theory, abstraction, and design); they have been identified neither assubareas nor as subarea components.andM;The subsequent numbered sections provide the details of each subarea in threeparts--theory, abstraction, and design.andP;  The boundaries between theory andabstraction, and between abstraction and design, are necessarily fuzzy; it isa matter of personal taste where some of the items go.andM;Our intention is to provide a guide to the discipline by showing its mainfeatures, not a detailed map.andP;  It is important to remember that this guide tothe discipline is not a plan for a course or a curriculum; it is merely aframework in which a curriculum can be design.andP;  It is also important toremember that this guide to the discipline is a snapshot of an organismundergoing constant change.andP;  It will require reevaluation and revision atregular intervals.andM;1.andP;  ALGORITHMS AND DATA STRUCTURESandM;This area deals with specific classes of problems and their efficientsolutions.andP;  Fundamental questions include: For given classes of problems,what are the best algorithms?andP;  How much storage and time do they require?andO;What is the tradeoff between space and time?andP;  What is the best way to accessthe data?andP;  What is the worst case of the best algorithms?andP;  How well doalgorithms behave on average?andP;  How general are algorithms--i.e., what classesof problems can be dealt with by similar methods? 1.1 TheoryandM;Major elements of theory in the area of algorithms and data structures are:andM;1.andP;  Computability theory, which defines what machines can and cannot do.andM;2.andP;  Computational complexity theory, which tells how to measure the time andspace requirements of computable functions and relates a problem's size withthe best- or worst-case performance of algorithms that solve that problem,and provides methods for proving lower bounds on any possible solution to aproblem.andM;3.andP;  Time and space bounds for algorithms and classes of algorithms.andM;4.andP;  Levels of intractability: for example, classes of problems solvabledeterministically in polynomially bounded time (P-problems); those solvablenondeterministically in polynomially bounded time (NP-problems); and thosesolvable efficiently by parallel machines (NC-problems).andM;5.andP;  Parallel computation, lower bounds, and mappings from dataflowrequirements of algorithms into communication paths of machines.andM;6.andP;  Probabilistic algorithms, which give results correct with sufficientlyhigh probabilities much more efficiently (in time and space) than determinatealgorithms that guarantee their results.andP;  Monte Carlo methods.andM;7.andP;  Cryptography.andM;8.andP;  The supporting areas of graph theory, recursive functions, recurrencerelations, combinatorics, calculus, induction, predicate and temporal logic,semantics, probability, and statistics.andP;  1.2 AbstractionandM;Major elements of abstraction in the area of algorithms and data structuresareandM;1.andP;  Efficient, optimal algorithms for important classes of problems andanalyses for best, worst, and average performance.andM;2.andP;  Classifications of the effects of control and data structure on time andspace requirements for various classes of problems.andM;3.andP;  Important classes of techniques such as divide-and-conquer, Greedyalgorithms, dynamic programming, finite state machine interpreters, and stackmachine interpreters.andM;4.andP;  Parallel and distributed algorithms; methods of partioning problems intotasks that can be executed in separate processors.andP;  1.3 DesignandM;Major elements of design and experimentation in the area of algorithms anddata structures are:andM;1.andP;  Selection, implementation, and testing of algorithms for importantclasses of problems such as searching, sorting, random-number generation, andtextual pattern matching.andM;2.andP;  Implementation and testing of general methods applicable across manyclasses of problems, such as hashing, graphs, and trees.andM;3.andP;  Implementation and testing of distributed algorithms such as networkprotocols, distributed data updates, semaphors, deadlock detectors, andsynchronization methods.andM;4.andP;  Implementation and testing of heuristic algorithms as garbage collection,buddy system, lists, tables, and paging.andM;5.andP;  Extensive experimental testing of heuristic algorithms for combinatorialproblems.andM;6.andP;  Cryptographic protocols that permit secure authentication and secretcommunication.andM;2.andP;  PROGRAMMING LANGUAGESandM;This area deals with notations for virtual machines that execute algorithms,with notations for algorithms and data, and with efficient translations fromhigh-level languages into machines codes.andP;  Fundamental questions include:What are possible organizations of the virtual machine presented by thelanguage (data types, operations, control structures, mechanisms forintroducing new types and operations)?andP;  How are these abstractionsimplemented on computers?andP;  What notation (syntax) can be used effectively andefficiently to specify what the computer should do? 2.1 TheoryandM;Major elements of theory in the area of programming languages are:andM;1.andP;  Formal languages and automata, including theories of parsing and languagetranslation .andM;2.andP;  Turing machines (base for procedural languages), Post Systems (base forstring processing languages), [lambda]-calculus (base for functionallanguages).andM;3.andP;  Formal semantics: methods for defining mathematical models of computersand the relationships among the models, language syntax, and implementation.andO;Primary methods include denotational, algebraic, operational, and axiomaticsemantics.andM;4.andP;  As supporting areas: predicate logic, temporal logic, modern algebra andmathematical induction.andP;  2.2 AbstractionandM;Major elements of abstraction in the area of programming languages include:andM;1.andP;  Classification of languages based on their syntactic and dynamic semanticmodels; e.g., static typing, dynamic typing, functional, procedural,object-oriented, logic, specification, message passing, and dataflow.andM;2.andP;  Classification of languages according to intended application area; e.g.,andO;business data processing, simulation, list processing, and graphics.andM;3.andP;  Classification of major syntactic and semantic models for programstructure; e.g., procedure hierarchies, functional composition, abstract datatypes, and communicating parallel processes.andM;4.andP;  Abstract implementation models for each major type of language.andM;5.andP;  Methods for parsing, compiling, interpretation, and code optimization.andM;6.andP;  Methods for automatic generaton of parsers, scanners, compilercomponents, and compilers.andP;  2.3 DesignandM;Major elements of design and experimentation in the area of programminglanguages are:andM;1.andP;  Specific languages that bring together a particular abstract machines(semantics) and syntax to form a coherent implementable whole.andP;  Examples:procedural (COBOL, FORTRAN, ALGOL, Pascal, Ada, C), functional (LISP),dataflow (SISAL, VAL), object-oriented (Smalltalk, CLU), logic (Prolog),strings (SNOBOL) and concurrency (CSP, Occam, Concurrent Pascal, Modula 2).andM;2.andP;  Specific implementation methods for particular classes of languages:run-time models, static and dynamic execution methods, typing checking,storage and register allocation, compilers, cross compilers, andinterpreters, systems for finding parallelism in programs.andM;3.andP;  Programming environments.andM;4.andP;  Parser and scanner generators (e.g., YACC, LEX), compiler generators.andM;5.andP;  Programs for syntactic and semantic error checking, profiling, debugging,and tracing.andM;6.andP;  Applications of programming-language methods to document-processingfunctions such as creating tables, graphs, chemical formulas, spreadsheetsequations, input and output, and data handling.andP;  Other applications such asstatistical processing.andM;3.andP;  ARCHITECTUREandM;This area deals with methods of organizing hardwre (and associated software)into efficient, reliable systems.andP;  Fundamental questions include: What aregood methods of implementing processors, memory, and communication in amachine?andP;  How do we design and control large computational systems andconvincingly demonstrate that they work as intended despite errors andfailures?andP;  What types of architectures can efficiently incorporate manyprocessing elements that can work concurrently on a computation?andP;  How do wemeasure performance? 3.1 TheoryandM;Major elements of theory in the area of architecture are:andM;1.andP;  Boolean algebra.andM;2.andP;  Switching theory.andM;3.andP;  Coding theory.andM;4.andP;  Finite state machine theory.andM;5.andP;  The supporting areas of statistics, probability, queueing, reliabilitytheory, discrete mathematics, number theory, and arithmetic in differentnumber systems.andP;  3.2 AbstractionandM;Major elements of abstraction in the area of architecture are:andM;1.andP;  Finite state machine and Boolean algebraic models of circuits that relatefunction to behavior.andM;2.andP;  Other general methods of synthesizing systems from basic components.andM;3.andP;  Models of circuits and finite state machines for computing arithmeticfunctions over finite fields.andM;4.andP;  Models for data path and control structures.andM;5.andP;  Optimizing instruction sets for various models and workloads.andM;6.andP;  Hardware reliability: redundancy, error detection, recovery, and testing.andM;7.andP;  Space, time, and organizational tradeoffs in the design of VLSI devices.andM;8.andP;  Organization of machines for various computational models: sequential,dataflow, list processing, array processing, vector processing, andmessage-passing.andM;9.andP;  Identification of design levels; e.g., configuration, program,instruction set, register, and gate.andP;  3.3 DesignandM;Major elements of design and experimentation in the area of architecture are:andM;1.andP;  Hardware units for fast computation; e.g., arithmetic function units,cache.andM;2.andP;  The so-called von Neumann machine (the single-instruction sequence storedprogram computer); RISC and CISC implementations.andM;3.andP;  Efficient methods of storing and recording information, and detecting andcorrecting errors.andM;4.andP;  Specific approaches to responding to errors: recovery, diagnostics,reconfiguration, and backup procedures.andM;5.andP;  Computer aided design (CAD) systems and logic simulations for the designof VLSI circuits.andP;  Production programs for layout, fault diagnosis.andP;  Siliconcompilers.andM;6.andP;  Implementing machines in various computational models; e.g., dataflow,tree, LISP, hypercube, vector, and multiprocessor.andM;7.andP;  Supercomputers, such as the Cray and Cyber machines.andM;4.andP;  NUMERICAL AND SYMBOLIC COMPUTATIONandM;This area deals with general methods of efficiently and accurately solvingequations resulting from mathematical models of systems.andP;  Fundamentalquestions include: How can we accurately approximate continuous or infiniteprocesses by finite discrete processes?andP;  Ho do we cope with the errorsarising from these approximations?andP;  How rapidly can a given class ofequations be solved for a given level of accuracy?andP;  How can symbolicmanipulations on equations, such as integration, differentiation, andreduction to minimal terms, be carried out?andP;  How can the answers to thesequestions be incorporated into efficient, reliable, high-quality mathematicalsoftware packages? 4.1 TheoryandM;Major elements of theory in the area of numerical and symbolic computationare:andM;1.andP;  Number theory.andM;2.andP;  Linear algebra.andM;3.andP;  Numerical analysis.andM;4.andP;  Nonlinear dynamics.andM;5.andP;  The supporting areas of calculus, real analysis, complex analysis, andalgebra.andP;  4.2 AbstractionandM;Major elements of abstraction in the area of numerical and symboliccomputation are:andM;1.andP;  Formulations of physical problems as models in continuous (and sometimesdiscrete) mathematics.andM;2.andP;  Discrete approximations to continuous problems.andP;  In this context,backward error analysis, error propagation and stability in the solution oflinear and non-linear systems.andP;  Special methods in special cases, such asFast Fourier Transform and Poisson solvers.andM;3.andP;  The finite element model for a large class of problems specifiable byregular meshes and boundary values.andP;  Associated iterative methods andconvergence theory: direct, implicit, multigrids, rates of convergence.andO;Parallel solution methods.andP;  Automatic grid refinement during numericalintegration.andM;4.andP;  Symbolic integration and differentiation.andP;  4.3 DesignandM;Major elements of design and experimentation in the area of numerical andsymbolic computation are:andM;1.andP;  High-level problem formulation systems such as CHEM and WEB.andM;2.andP;  Specific libraries and packages for linear algebra, ordinary differentialequations, statistics, nonlinear equations, and optimizations; e.g., LINPACK,EISPACK, ELLPACK.andM;3.andP;  Methods of mapping finite element algorithms to specificarchitectures--e.g., multigrids on hyper-cubes.andM;4.andP;  Symbolic manipulators, such as MACSYMA and REDUCE, capable of powerfuland nonobvious manipulations, notably differentiations, integrations, andreductions of expressions to minimal terms.andM;5.andP;  OPERATING SYSTEMSandM;This area deals with control mechanisms that allow multiple resources to beefficiently coordinated in the execution of programs.andP;  Fundamental questionsinclude: What are the visible objects and permissible operations at eachlevel in the operation of a computer system?andP;  For each class of resource(objects visible at some level), what is a minimal set of operations thatpermit their effective use?andP;  How can interfaces be organized so that usersdeal only with abstract versions of resources and not with physical detailsof hardware?andP;  What are effective control strategies for job scheduling,memory management, communications, access to software resources,communication among concurrent tasks, reliability, and security?andP;  What arethe principles by which systems can be extended in function by repeatedapplication of a small number of construction rules?andP;  How should distributedcomputations be organized so that many autonomous machines connected by acommunication network can participate in a computation, with the details ofnetwork protocols, host locations, band-widths, and resource naming beingmostly invisible? 5.1 TheoryandM;Major elements of theory in the area of operating systems are:andM;1.andP;  Concurrency theory: synchronization, determinacy, and deadlocks.andM;2.andP;  Scheduling theory, especially processor scheduling.andM;3.andP;  Program behavior and memory management theory, including optimal policiesfor storage allocation.andM;4.andP;  Performance modeling and analysis.andM;5.andP;  The supporting areas of bin packing, probability, queueing theory,queueing networks, communication and information theory, temporal logic, andcryptography.andP;  5.2 AbstractionandM;Major elements of abstraction in the area of operating systems are:andM;1.andP;  Abstraction principles that permit users to operate on idealized versionsof resources without concern for physical details (e.g., process rather thanprocessor, virtual memory rather than main-secondary hierarchy, files ratherthan disks).andM;2.andP;  Binding of objects perceived at the user interface to internalcomputational structures.andM;3.andP;  Models for important subproblems such as process management, memorymanagement, job scheduling, secondary storage management, and performanceanalysis.andM;4.andP;  Models for distributed computation; e.g., clients and servers,cooperating sequential processes, message-passing, and remote procedurecalls.andM;5.andP;  Models for secure computing; e.g., access controls, authentication, andcommunication.andM;6.andP;  Networking, including layered protocols, naming, remote resource usage,help services, and local network protocols such as token-passing and sharedbuses.andP;  5.3 DesignandM;Major elements of design and experimentation in the area of operating systemsare:andM;1.andP;  Prototypes of time sharing systems, automatic storage allocators,multilevel schedulers, memory managers, hierarchical file systems and otherimportant system components that have served as bases for commercial systems.andM;2.andP;  Techniques for building operating systems such as UNIX, Multics, Mach,VMS, and MS-DOS.andM;3.andP;  Techniques for building libraries of utilities; e.g., editors, documentformatters, compilers, linkers, and device drivers.andM;4.andP;  Files and file systems.andM;5.andP;  Queueing network modeling and simulation packages to evaluate performanceof real systems.andM;6.andP;  Network architectures such as ethernet, FDDI, token ring nets, SNA, andDECNET.andM;7.andP;  Protocol techniques embodied in the Department of Defense protocol suite(TCP/IP), virtual circuit protocols, internet, real time conferencing, andX.25.andM;6.andP;  SOFTWARE METHODOLOGY ANDandM;ENGINEERINGandM;This area deals with the design of programs and large software systems thatmeet specifications and are safe, secure, reliable, and dependable.andO;Fundamental questions include: What are the principles behind the developmentof programs and programming systems?andP;  How does one prove that a program orsystem meets its specifications? How does one develop specifications that donot omit important cases and can be analyzed for safety?andP;  How do softwaresystems evolve through different generations?andP;  How can software be designedfor understandability and modifiability? 6.1 TheoryandM;Major elements of theory in the area of software methodology and tools are:andM;1.andP;  Program verification and proof.andM;2.andP;  Temporal logic.andM;3.andP;  Reliability theory.andM;4.andP;  The supporting areas of predicate calculus, axiomatic semantics, andcognitive psychology.andP;  6.2 AbstractionandM;Major elements of abstraction in the area of software methodology and toolsare:andM;1.andP;  Specification methods, such as predicate transformers, programmingcalculi, abstract data types, and Floyd-Hoare axiomatic notations.andM;2.andP;  Methodologies such as stepwise refinement, modular design, modules,separate compilation, information-hiding, dataflow, and layers ofabstraction.andM;3.andP;  Methods for automating program development; e.g., text editors,syntax-directed editors, and screen editors.andM;4.andP;  Methodologies for dependable computing; e.g., fault tolerance, security,reliability, recovery, N-version programming, multiple-way redundancy, andcheck-pointing.andM;5.andP;  Software tools and programming environments.andM;6.andP;  Measurement and evaluation of programs and systems.andM;7.andP;  Matching problem domains through software systems to particular machinearchitectures.andM;8.andP;  Life cycle models of software projects.andP;  6.3 DesignandM;Major elements of design and experimentation in the area of softwaremethodology and tools are:andM;1.andP;  Specification languages (e.g., PSL 2, IMA JO), configuration managementsystesm (e.g., in Ada APSE), and revision control systems (e.g., RCS, SCCS).andM;2.andP;  Syntax directed editors, line editors, screen editors, and wordprocessing systems.andM;3.andP;  Specific methodologies advocated and used in practice for softwaredevelopment; e.g., HDM and those advocated by Dijkstra, Jackson, Mills, orYourdon.andM;4.andP;  Procedures and practices for testing (e.g., walk-through, handsimulation, checking of interfaces between modules, program path enumerationsfor test sets, and event tracing), quality assurance, and project management.andM;5.andP;  Software tools for program development and debugging, profiling, textformatting, and database manipulation.andM;6.andP;  Specification of criteria levels and validation procedures for securecomputing systems, e.g., Department of Defense.andM;7.andP;  Design of user interfaces.andM;8.andP;  Methods for designing very large systems that are reliable, faulttolerant, and dependable.andM;7.andP;  DATABASE AND INFORMATION RETRIEVALandM;SYSTEMSandM;This area deals with the organization of large sets of persistent, shareddata for efficient query and update.andP;  Fundamental questions include: Whatmodeling concepts should be used to represent data elements and theirrelationships?andP;  How can basic operations such as store, locate, match, andretrieve be combined into effective transactions?andP;  How can these transactionsinteract effectively with the user?andP;  How can high-level queries be translatedinto high-performance programs?andP;  What machine architectures lead to efficientretrieval and update?andP;  How can data be protected against unauthorized access,disclosure, or destruction?andP;  How can large databases be protected frominconsistencies due to simultaneous update?andP;  How can protection andperformance be achieved when the data are distributed among many machines?andO;How can text be indexed and classified for efficient retrieval? 7.1 TheoryandM;Major elements of theory in the area of databases and information retrievalsystems are:andM;1.andP;  Relational algebra and relational calculus.andM;2.andP;  Dependency theorty.andM;3.andP;  Concurrency theory, especially serializable transactions, deadlocks, andsynchronized updates of multiple copies.andM;4.andP;  Statistical inference.andM;5.andP;  Sorting and searching.andM;6.andP;  Performance analysisandM;7.andP;  As supporting theory: cryptography.andP;  7.2 AbstractionandM;Major elements of abstraction in the area of databases and informationretrieval systems are:andM;1.andP;  Models for representing the logical structure of data and relations amongthe data elements, including the relational and entity-relationship models.andM;2.andP;  Representations of files for fast retrieval, such as indexes, trees,inversions, and associative stores.andM;3.andP;  Methods for assuring integrity (consistency) of the database underupdates, including concurrent updates of multiple copies.andM;4.andP;  Methods for preventing unauthorized disclosure or alteration and forminimizing statistical inference.andM;5.andP;  Languages for posing queries over databases of different kinds (e.g.,andO;hypertext, text, spatial, pictures, images, rule-sets).andP;  Similarly forinformation retrieval systems.andM;6.andP;  Models such as hypertext, which allow documents to contain text atmultiple levels and to include video, graphics, and voice.andM;7.andP;  Human factors and interface issues.andP;  7.3 DesignandM;Major elements of design in the area of database and information retrievalsystems are:andM;1.andP;  Techniques for designing databases for relational, hierarchical, network,and distributed implementations.andM;2.andP;  Techniques for designing database systems such as INGRES, System R, dBaseIII, and DB-2.andM;3.andP;  Techniques for designing information retrieval systems such as LEXIS,Osiris, and Medline.andM;4.andP;  Design of secure database systems.andM;5.andP;  Hypertext systems such as NLS, NoteCards, Intermedia, and Xanadu.andM;6.andP;  Techniques to map large databases to magnetic disk stores.andM;7.andP;  Techniques for mapping large, read-only databases onto optical storagemedia--e.g., CD/ROM and WORMS.andM;8.andP;  ARTIFICIAL INTELLIGENCE AND ROBOTICSandM;This are deals with the modeling of animal and human (intelligent) behavior.andO;Fundamental questions include: What are basic models of behavior and how dowe build machines that simulate them?andP;  To what extent is intelligencedescribed by rule evaluation, inference, deduction, and pattern computation?andO;What is the ultimate performance of machines that simulate behavior by thesemethods? How are sensory data encoded so that similar patterns have similarcodes?andP;  How are motor codes associated with sensory codes?andP;  What arearchitectures for learning systems, and how do those systems represent theirknowledge of the world? 8.1 TheoryandM;Major elements of theory in the area of artificial intelligence and roboticsare:andM;1.andP;  Logic; e.g., monotonic, nonmonotonic, and fuzzy.andM;2.andP;  Conceptual dependency.andM;3.andP;  Cognition.andM;4.andP;  Syntactic and semantic models for natural language understanding.andM;5.andP;  Kinematics and dynamics of robot motion and world models used by robots.andM;6.andP;  The supporting areas of structural mechanics, graph theory, formalgrammars, linguistics, philosophy, and psychology.andP;  8.2 AbstractionandM;Major elements of abstraction in the area of artificial intelligence androbotics are:andM;1.andP;  Knowledge representation (e.g., rules, frames, logic) and methods ofprocessing them (e.g., deduction, inference).andM;2.andP;  Models of natural language understanding and natural languagerepresentations, including phoneme representations; machine translation.andM;3.andP;  Speech recognition and synthesis, translation of text to speech.andM;4.andP;  Reasoning and learning modes; e.g., uncertainty, nonmonotonic logic,Bayesian inference, beliefs.andM;5.andP;  Heuristic search methods, branch and bound, control search.andM;6.andP;  Machine architectures that imitate biological systems, e.g., neuralnetworks, connectionism, sparse distributed memory.andM;7.andP;  Models of human memory, autonomous learning, and other elements of robotsystems.andP;  8.3 DesignandM;Major elements of design and experimentation in artificial intelligence androbotics include:andM;1.andP;  Techniques for designing software systems for logic programming, theoremproving, and rule evaluation.andM;2.andP;  Techniques for expert systems in narrow domains (e.g., Mycin, Xcon) andexpert system shells that can be programmed for new domains.andM;3.andP;  Implementations of logic programming (e.g, PROLOG).andM;4.andP;  Natural language understanding systems (e.g., Margie, SHRDLU, andpreference semantics).andM;5.andP;  Implementations of neural networks and sparse distributed memories.andM;6.andP;  Programs that play checkers, chess and other games of strategy.andM;7.andP;  Working speech synthesizers, recognizers.andM;8.andP;  Working robotic machines, static and mobile.andM;9.andP;  HUMAN-COMPUTER COMMUNICATIONandM;This area deals with the efficient transfer of information between humans andmachines via various human-like sensors and motors, and with informationstructures that reflect human conceptualizations.andP;  Fundamental questionsinclude: What are efficient methods of representing objects andauthomatically creating pictures for viewing?andP;  What are effective methods forreceiving input or presenting output?andP;  How can the risk of misperception andsubsequent human error be minimized?andP;  How can graphics and other tools beused to understand physical phenomena through information stored in datasets? 9.1 TheoryandM;Major elements of theory in human-computer communication are:andM;1.andP;  Geometry of two and higher dimensions including analytic, projective,affine, and computational geometries.andM;2.andP;  Color theory.andM;3.andP;  Cognitive psychology.andM;4.andP;  The supporting areas of Fourier analysis, linear algebra, graph theory,automata, physics, and analysis.andP;  9.2 AbstractionandM;Major elements of abstraction in the area of human-computer communicationare:andM;1.andP;  Algorithms for displaying pictures including methods for smoothing,shading, hidden lines, ray tracing, hidden surfaces, transparent surfaces,shadows, lighting, edges, color maps, representations by splines, rendering,texturing, antialiasing, coherence, fractals, animation, representingpictures as hierarchies of objects.andM;2.andP;  Models for computer-aided design (CAD).andM;3.andP;  Computer representations of physical objects.andM;4.andP;  Image processing and enhancement methods.andM;5.andP;  Man-machine communication, including psychological studies of modes ofinteraction that reduce human error and increase human productivity.andP;  9.3DesignandM;Major elements of design and experimentation in the area of human-computercommunication are:andM;1.andP;  Implementation of graphics algorithms on various graphics devices,including vector and raster displays and a range of hardcopy devices.andM;2.andP;  Design and implementation of experimental graphics algorithms for agrowing range of models and phenomena.andM;3.andP;  Proper use of color graphics for displays; accurate reproduction ofcolors on displays and hardcopy devices.andM;4.andP;  Graphcis standards (e.g., GKS, PHIGS, VDI), graphics languages (e.g.,andO;PostScript), and special graphics packages (e.g., MOGLI for chemistry).andM;5.andP;  Implementation of various user interface techniques including directmanipulation on bitmapped devices and screen techniques for characterdevices.andM;6.andP;  Implementation of various standard file interchange formats forinformation transfer between differing systems and machines.andM;7.andP;  Working CAD systems.andM;8.andP;  Working image enhancement systems (e.g., at JPL for pictures receivedfrom space probes).andO;</TEXT></DOC>