<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-330-016  </DOCNO><DOCID>08 330 016.andM;</DOCID><JOURNAL>Communications of the ACM  April 1990 v33 n4 p389(3)* Full Text COPYRIGHT Association for Computing Machinery 1990.andM;</JOURNAL><TITLE>The fate of Fortran-8x. (ANSI/ISO Fortran standard)(Viewpoint)(column)</TITLE><AUTHOR>Hunter, Geoffrey.andM;</AUTHOR><DESCRIPT>Topic:     Programming LanguagesStandardizationComputer ScienceFORTRANAmerican National Standards InstituteInternational Organization for Standardization.andM;</DESCRIPT><NOTE>Only Text is presented here; see printed issues for graphics.andO;</NOTE><TEXT>The Fate of Fortran-8x A new ANSI/ISO standard for Fortran seemed to beimminent in October, 1987, when the draft specification for the new language(provisionally called Fortran-8x) was published for public review, this beingthe formal ANSI procedure prior to adoption of a new standard.andP;  During thefour-month public-comment period (October 23, 1987-February 23, 1988) I readthe specification (a 340-page book designated S8.104) (1) and sent my 61-pageComment to the ANSI drafting committee (X3J3) in February, 1988.andM;My comment was broadly critical of the specification for reasons that aresummarized here, and I was invited to present my views to the X3J3 committeeat its meeting in Jackson, Wyoming, in August, 1988.andP;  Attendance at theweek-long meeting was educational.andP;  I learned that the X3J3 committeeconsists of about 40 volunteers representing the major computer vendors andFortran users.andM;The X3J3 meetings had the flavor of a political forum dominated by debateabout procedure and agenda with frequent votes on alternative proposals.andP;  Thekind of technical discussion that one would expect in a language designcommittee played a very small part in the proceedings.andP;  The chair of X3J3,Jeanne Adams, acted mainly as a mediator between the four or five factionswithin the committee; Fortran-8x only reached the public-comment stage aftercompromises within X3J3, as evidenced by Removed Extensions in S.8.104.andM;The dissension within X3J3 arises from a deep-seated technicalincompatibility.andP;  Fortran-77 and earlier dialects are fundamentally flawed bystatic memory allocation (as will be explained), and some members of X3J3clearly recognize that in order to change it into a modern, well-designedlanguage, one must not only introduce new features, but also remove some oldfeatures because old and new cannot rationally co-exist.andP;  This is explicitlyrecognized in S8.104 in a list of deprecated and obsolescent features.andM;The countervailing argument is that the new language must beupward-compatible with the old language.andP;  The S8.104 specification attemptedto reconcile these conflicting purposes through the concept of LanguageEvolution, whereby redundant and obsolescent features would be slowly removedfrom the ANSI standard over a 20-30-year period.andP;  However, at the August 1988meeting the concept of Language Evolution was abandoned as one morecompromise between desirable change and upward compatibility.andM;Following several more X3J3 meetings, version 112 of the specification wasput out for public review in 1989 (July 27-November 24).andP;  The revisions sincethe first public review are (from my standpoint) minor; they do not addressthe fundamental problems that formed the basis for my criticism andrecommendations.andP;  (2)andM;Synopsis of RecommendationsandM;The purpose of the summary is to re-affirm my technical judgment thatFortran-8x should not become an ANSI Standard regardless of further (minor)revisions to the specification.andP;  Fortran-77 should be retained as the last,ANSI/ISO Standard dialect, (3) and its deficiencies should be remedied byselection of an established block-structured language (probably ADA, possibleAlgol-68) as an alternative to Fortran-8x.andP;  Fortran programmers should beadvised to switch to this alternative language for their future programmingprojects.andP;  Translation of existing programs should be automated with aFortran-77 to ADA/Algol-68 pre-processor.andM;This strategy would bring U.S.andP;  practice up to the state of the art in theU.S.S.R., where Algol-68 is both the dominant programming language and thearchitectural basis of their mainframe computers.andP;  While similar, technicallywell-designed systems are available in the U.S.andP;  (on the Unisys/Burroughsmainframes), they are not widely used.andM;My overall conclusions about Fortran-8x are as follows:andM;* Its semantic implications are not fully defined in S8.104 especially inregard to the introduction of dynamic memory allocation.andP;  This is theimplicit new semantic feature of Fortran-8x that makes it radically differentfrom all earlier dialects of the language.andM;* Fortran-8x will be a vast and complex language similar to PL/1.andP;  Thecreation of fully defined, bug-free free compilers will be difficult andcostly.andM;* The plethora of different concepts and elements of the language, each withits own rules, exceptions, prohibitions, and constraints, will makeprogramming in Fortran-8x a highly error-prone, laborious, and costlybusiness.andP;  Many of the elements are redundant, and some of the concepts arelogically wrong.andM;* The introduction of Fortran-8x would be contrary to the trend in computersystems, i.e., towards simple, orthogonal designs based on a minimal set ofessential concepts.andM;Politics, History, Commerce, andandM;TechnologyandM;My recommendations will surprise the many people who accept Fortran as thelingua franca of scientific and engineering programming.andP;  In view of itswidespread use there must be very well-founded reasons for abandoning Fortranin favor of an alternative language.andP;  These reasons are best appreciated inthe context of the history of computing, presented here from a personalperspective.andM;I wrote my first computer program in 1961, and in 1962 I began using a newcomputer (the Manchester Atlas) that implemented dynamic memory allocationvia a hardware stack.andP;  Its algebraic programming language, Atlas Autocode (anAlgol-60 dialect) had nested block structure, dynamic array dimensioning, andrecursive routines, features that I recognized then as vitally important andwhose fundamental significance was revealed to me some years later afterstudying the theory of computation.andM;Yet, Fortran programmers will have to wait until the 1990s for these vitalprogramming tools--until ADA of Algol-68 supersedes Fortran-77.andP;  You may wellask (as I have been asking for the past 25 years) why had it taken so long?andO;And furthermore, what are the likely consequences for Fortran programmers?andM;The brief answer to the &quot;why so long&quot; question is that IBM adopted thefundamentally flawed design strategy of static memory allocation for theSystem/360, and as a result of their dominant influence on the wholeindustry, the design flaw was propagated into many other manufacturers'hardware and software.andP;  The flaw became a defacto &quot;standard,&quot; whosedetrimental effects on the art and science of computing seem destined to lastwell into the 21st century.andM;The Fundamental TheoryandM;The constraint of static memory allocation is a fundamental flaw because themost general kind of computational process (a Turing Machine process)requires dynamic memory allocation.andP;  This requirement distinguishes theTuring Machine from the Finite-Automaton in the theory of computation; thelatter is characterized by static memory allocation.andM;Every process involves a program and data, the essential distinction betweenthem being that the program is the fixed (invariant) part of the algorithmwhile the data is different in each run of the program.andP;  The split betweenthe program part and the data part depends on the algorithm's specification.andM;Any process whose specification implies a variable amount of data storage isa Turing Machine process, and if the program is to have its invariantattribute, then the programming language and hardware must allow for dynamicallocation of memory for the variable amount of data.andM;The vast majority of computing tasks are Turing Machine processes, i.e., theydemand dynamic allocation of memory.andP;  For example, a typicalscientific/engineering application has at least one array whose size is datadependent.andP;  The array declaration in the program should contain a run-timegenerated number as its size, and this should compile into run-time (i.e.,andO;dynamic) allocation of the requisite amount of memory for the array.andO;Recursion, which has an essential role in the theory of computation, alsorequires dynamic memory allocation--for the stack of return addresses and forthe local variables of each recursive call.andM;If the programmer is restricted to a language that does not allow for dynamicmemory allocation (as I was restricted to Fortran in 1965-75), then he or shemust inevitably make the program data-dependent, thus vitiating the essentialdistinction between program and data.andM;When is a Program not a Program?--whenandM;it is written in Fortran.andM;The practical consequence of this fundamental flaw in the Fortran language isthat the user of the program finds him or herself having to revise andrecompile the program to match the data that is being processed.andP;  In caseswhere array dimensions are necessarily calculated at run-time, the programmermay find him or herself &quot;inside a loop&quot; (from personal experience), editingand recompiling the program until he or she iterates (by trial and error) toarray dimensions that match the data.andM;Thus, the static-allocation design-philosophy underlying Fortran causesinefficiency (in both machine and programmer time) compared with dynamicallocation systems such as Algol on a Burroughs mainframe.andM;After 30 years (1957-87) of unwittingly laboring under the debilitatingconstraint of static memory allocation Fortran programmers are to be releasedfrom their shackles.andP;  Fortran-8x or preferably ADA/Algol-68 will have dynamicarray dimensioning, recursive routines, and nested block structure.andP;  However,Fortran-8x (unlike the preferable ADA/Algol-68 alternative) would limit thenesting to two levels--one of its rational compromises.andM;Block structure, which originated in Algol-60, is fundamentally important forlocalizing environments and for achieving communication between a subroutineand its calling environment.andP;  A detailed exposition is appended to mycomments on Fortran-8x.andM;Fixing the Flaw vs.andP;  a Fresh StartandM;Despite the inclusion of dynamic memory allocation facilities, the prospectoffered by Fortran-8x is not an attractive one.andP;  The overall problem is thatthe X3J3 committee is trying to reconcile two conflicting purposes:andM;(1) The desire for compatibility with Fortran-77 so that existing programswill compile.andM;(2)) The need to enhance the language with new features:andM;* to correct the design flaws that were built into Fortran 30 years ago, andandM;* to add features (such as array-returning functions) that have beenavailable elsewhere (i.e., in Algol-68) for 20 years or more.andM;The complexity of Fortran-8x arises from adding a large collection of newlanguage elements while retaining all the old ones.andP;  Conflicts andredundancies between old and new are inevitable.andP;  For example, there are sixdifferent kinds of array declaration in Fortran-8x, and yet analysis showsthat only two are essential: one to allocate memory for an array and theother for array parameters of subroutines.andP;  Even if the other four weredeleted from Fortran-8x (in the year 2021, according to X3J3's schedule forlanguage evolution--prior to its abandonment of evolution), the syntax of theremaining two should be changed to reflect their very different semantics.andM;The features of the S8.104 specification illustrate its overall lack ofcoherence and rationality: the SAVE and RECURSIVE declarators.andP;  SAVE wasintroduced into Fortran-77 as a semantically insignificant feature.andP;  TheDigital/VAX Fortran-77 manual says that SAVE is &quot;redundant&quot; to theircompiler--because everything is always saved, i.e., statically allocated.andP;  InFortran-8x, where dynamic memory allocation must be implemented, the absenceof SAVE declarations in old and trusted &quot;proven&quot; programs will cause them tofail, notwithstanding X3J3's claim that any Fortran-77 program will conformunder the Fortran-8x specification.andP;  I named this phenomenon The SAVE TimeBomb because it will likely cause explosions throughout the Fortran-speakingwould.andM;While Fortran-8x will allow recursive routines, the s8.104 specification saysthat these must be qualified with the RECURSIVE declarator.andP;  If subroutinecall and return is implemented by the well-known mechanism of using a stackfor the return addresses, there is no penalty in CPU time and memory usage(compared with alternative mechanism), and the bonus of recursion is obtainedautomatically, i.e., without any modifications (to allow for recursion) toeither the parser or the code generator.andM;Thus, the RECURSIVE declarator is totally redundant.andP;  For this reason,programmers should not be faced with the needless task of deciding whether asubroutine is (indirectly) recursive or not.andP;  Hence, I concluded that theRECURSIVE declarator is a design error in Fortran-8x.andP;  Its total redundancyparallels that of SAVE in Fortran-77.andM;In SummaryandM;Despite important technical enhancements, notably implicit Dynamic MemoryAllocation, (4) the Fortran-8x proposal is unsatisfactory because thelanguage is encumbered with many redundant and mutually incompatiblefeatures.andM;The only technically rational way of advancing the art of scientific andengineering programming is to abandon Fortran in favor of a modern,block-structured language such as Algol-68 or ADA.andM;Geoffrey Hunter Chemistry Department York University 4700 Keele StreetToronto, Ontario Canada M3I 1P3andM;(1) i.e., the version of the specification for Fortran-8x current at the104th meeting of X3J3.andM;(2) Despite ANSI's mandate.andP;  X3J3 has not formally responded to my publiccomment.andM;(3) ANS Fortran-77 was re-affirmed by the ANSI Board of Standards Review onAugust 1, 1989.andP;  Furthermore, on October 18, the ANSI X3 committee voted toretain Fortran-77 as a distinct standard regardless of the eventual fate ofFortran-8x.andO;</TEXT></DOC>