<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-415-878  </DOCNO><DOCID>07 415 878.andM;</DOCID><JOURNAL>Communications of the ACM  July 1989 v32 n7 p862(10)* Full Text COPYRIGHT Assn. for Computing Machinery, Inc. 1989.andM;</JOURNAL><TITLE>Efficient placement of audio data on optical disks for real-timeapplications. (Special Section) (technical)</TITLE><AUTHOR>Yu, Clement; Wei Sun; Bitton, Dina; Qi Yang; Bruno, Richard;Tullis, John.andM;</AUTHOR><SUMMARY>Audio data must be extracted from a spinning disk fast enough tobe processed and provided as continuous sound.andP;  The braininterprets a series of 'stills' as continuous motion, but thebrain does not do this with sound.andP;  Therefore, placement of audiodata on disks is more important than placement of video data.andO;Here, an optimal algorithm is described that merges two audiorecords.andP;  The result is a record with a minimum length.andP;  Thealgorithm minimizes space for storing audio files, whilemaintaining realistic sound.andM;</SUMMARY><DESCRIPT>Topic:     MultimediaReal-Time SystemsOptical DisksSound ProcessingAlgorithmsInteractive Systems.andO;Feature:   illustrationchart.andO;Caption:   A possible merging of two records. (chart)Subrecords and their associated storage patterns. (chart)Successful merge with finite subrecord. (chart)andM;</DESCRIPT><NOTE>Only Text is presented here; see printed issues for graphics.andO;</NOTE><TEXT>Efficient Placement of Audio Data on Optical Disks for Real-Time ApplicationsOptical disks have both a large storage capacity for a low cost and a longarchiving lifetime.andP;  This medium isused in many data-intensive applicationareas.andP;  Optical disks come in various sizes ranging from about 30 cm to about7 cm.andP;  There are various categories of optical disks, such as ready-onlydisks, write-once-read-many-times disks (WORMs), and erasable disks such asmagneto-optical disks.andM;Optocal disks, differing from conventional magnetic disks, have their owncharacteristics.andP;  The write-once-read-many-times (WORMs) optical disks havethe property that information is stored by the presence or absence of a pitburned by a laser into the reflective layer of the disk medium.andP;  Such pitscannot be erased nor rewritten.andP;  Certain classes of applications (such as forthe Library of Congress, a patent library, etc.) can be effectively stored onWORM or, in some cases, read-only disks.andM;Read-only optical disks come in various formats, but there is a distinctcategory of optical disk called the compact disk.andP;  Compact disks are the4-3/4 inch versions of optical disks.andP;  They come in many flavors, includingCD-DA (compact disk digital audio), CD-ROM (compact disk read only memory),CD-I (compact disk interactive), CD-V (compact disk video), and CD-ROM XA(compact disk read only memory extended architecture).andP;  Each holds digitaldata and uses the same physical encoding scheme.andP;  The differences betweenthese formats lie in the amount of data integrity that is achieved by theencoding scheme, the data coding schemes that are used or allowable, and theallowed disk data topography.andM;It has become an accepted practice to place computer data on optical diskssuch as WORMs.andP;  Audio data in Pulse Code Modulated (PCM) form has been storedon CD-DA disks for almost seven years.andP;  Alphanumeric and binary data havebeen stored on commercial CD-ROM's since 1985.andP;  However, multimediaapplications on optical disks are slowly growing in usage.andP;  Multimediaapplication may be considered as those applications using two or more datatypes.andP;  Thus, a disk may contain audio, video, text and binary data.andP;  Thevideo information may be displayed as a ful screen image, or images that fillonly part of the screen.andP;  Video images that fill only part of the screen arecalled partial images.andP;  This allows multiple video images to be displayed onthe screen simultaneously.andM;The placement of audio data on the optical disk is of primary importancebecause the audio data is being extracted from the optical disk in &quot;realtime.&quot;andP;  Real time means that system hiccups greater than 30 msec cannot betolerated.andP;  Typically, the audio data buffer for a decoder is not muchgreater than 4 kbytes, holding about 16/75 of a second of sound.andP;  Therefore,the audio data must be extracted from the spinning disk fast enough that itcan be processed and provided to the human listener as a continuous flow ofsound.andP;  Since the human brain is willing to interpret a slower update ratefor video information while still accepting the series of video &quot;stills&quot; asmotion, the placement of audio data on the disk is of greater importance thanthe placement of video data.andM;An optical disk that contains multimedia information can be divided intotracks.andP;  Each track would then be further subdivided into sectors.andP;  Thenumber of tracks, and the size of each sector within the track, varies amontthe different formats for optical disks.andP;  For a CD-I disk, there may be asfew as 1 or as many as 99 data tracks.andP;  The sector size in the data tracks ofa CD-I disk is approximately 2 kbytes.andP;  Sectors are randomly accessible, and,in the case of CD-I, sectors can be multiplexed in up to 16 channels foraudio and 32 channels for all other data types.andP;  For audio these channels areequivalent to having 16 parallel audio data channels instantly accessibleduring the playing of a disk.andP;  An example might be a travelogue with 16different language channels.andP;  However, real time playback of the audiorequires that the audio data take fixed interleaving patterns on the disk.andO;Video graphic data do not have this fixed interleaving pattern constraint.andO;In effect, the video data may be &quot;puttied into the cracks&quot; around the audiodata.andM;Another factor is that different levels of audio and video quality requiredifferent levels of data storage and rate of extraction.andP;  In the case ofCD-I, high level stereo requires that every other sector contain audioinformation from the same audio sequence.andP;  Lower grade audio, such as mono AMradio quality sound, merely requires that every 16th sector be allocated toaudio data storage.andP;  This would be the case in the travelogue example withthe 16 different language channels (of course, when audio occupies all 16channels, video cannot be simultaneously updated).andM;In this article an audio record is considered to be a single contiguous pieceof audio.andP;  An example would be a short song or message.andP;  Each record iscomposed of subrecords.andP;  In a multimedia application, it is necessary toorganize the data on the optical disk such that different audio records donot conflict.andP;  CD-I disk subrecords that are part of the same record cannotbe interleaved but it may be possible for subrecords from dissimilar recordsto be interleaved.andP;  This permits saving of disk space.andP;  In order to optimizethe disk topography of a read only optical medium for efficiency of randomaccess, the first problem that needs to be solved is the file interleavingfor multichannel audio data.andM;THE PROBLEMandM;Real-time records that support real-time playback of audio/video data are tobe stored on optical disks.andP;  A real-time record contains one or morereal-time subrecords.andP;  When two records are merged, subrecords of one recordare to be merged with subrecords of the other record.andP;  Consider the mergingof two subrecords, one from each record, to yield a resulting subrecord.andP;  Theresulting subrecord will then be merged with a subrecord from one of therecords.andP;  When this process is repeated for as long as there are subrecordsin the records, the two records containing the subrecords will be merged.andO;Thus, it is sufficient to study the merging of two subrecords.andP;  Figure 1shows a possible merging of two records.andP;  Subrecord R.sub.a.1 is merged withsubrecord R.sub.c.1 to yield a resulting subrecord, which is in turn mergedwith R.sub.c.2.andP;  The resulting subrecord is then merged with R.sub.a.2 and soon.andM;In this article, we concentrate on the storage of audio data.andP;  Audio data arerequired to be retrieved at a very precise rate in order to reproduce anaesthetic sound.andP;  In other words, audio data must arrive at the audioprocessor in certain intervals in order to be perceived as a realistic sound.andO;The rotational latency of optical disk drives makes it impossible to achievethe required data rate by simply reading reading an audio data block, pausingfor a predetermined time, and then reading the next audio data block.andO;Instead, audio data blocks must be physically interspaced at certainintervals whose lengths depend on the quality of sound reproduction(mono/stereo, fidelity requirement, etc.).andP;  Thus, an audio subrecord isdescribed as a storage pattern(D, B) repeated several times, where D is thenumber of units to store audio data and B is the number of blank units neededto interspace the audio data as required.andM;Let R.sub.a and R.sub.c be two audio subrecords with lengths of L.sub.a andL.sub.c in storage units, respectively.andP;  The storage units, or simply units,can be measured in bytes, words, disk sectors, blocks, etc.andP;  Associated withthe subrecords are storage patterns P.sub.a = (D.sub.a., D.sub.a.) andP.sub.c = (D.sub.c., B.sub.c.) as shown in Figure 2, where D.sub.a andD.sub.c are the number of storage units need to store the data portion forpattern A and pattern C, respectively; and B.sub.a and B.sub.c are the numberof blank units in pattern A and pattern C, respectively.andP;  All D.sub.a.,andO;B.sub.a., D.sub.c are integers.andP;  The patterns are repeated in theirsubrecords.andP;  The patterns vary depending on the quality of sound reproductionof audio data during playback.andP;  The length of a subrecord R.sub.x., L.sub.x.,andO;is a multiple of its pattern.andP;  Thus, L.sub.a = C.sub.a * L(P.sub.a.) andL.sub.c = * L(P.sub.c.) for some integers C.sub.a and C.sub.c., whereL(P.sub.a.) = D.sub.a + B.sub.a and L(P.sub.c.) = D.sub.c + B.sub.c are thelengths of patterns A and C, respectively.andM;We are interested in merging subrecord A and subrecord C so that as manyblank spaces as possible of one subrecord will be occupied by the data of theother subrecord.andP;  The constraints for merging are:andM;1.andP;  The pattern for each subrecord has to be maintained, i.e., within eachpattern (D, B), and the numbers of units allocated for data (D) and forblanks (B) are fixed.andM;2.andP;  There is no blank space (in addition to the blank units in patterns)between consecutive patterns.andM;3.andP;  No data portion of one pattern can overlap with the data portion ofanother pattern in the merged subrecord.andM;Definition 2.1.andP;  Two subrecords A and C with patterns P.sub.a = (D.sub.a.,andO;B.sub.a.) and P.sub.c = (D.sub.c, B.sub.c.) are mergeable if conditions 1, 2,and 3 are satisfied.andP;  If the data portion of one pattern overlaps with thedata portion of another pattern, there is a data collision.andM;Example 1  Suppose pattern P.sup.a = (1, 1) and pattern P.sub.c = (1, 3), andthe lengths of subrecords A and C are L.sub.c = L.sub.a = 12.andP;  If we put thefirst unit of subrecord C in the second unit of subrecord A, then subrecordsA and C are mergeable, as shown in Figure 3.andM;Example 2  Suppose pattern P.sub.a = (1, 2) and pattern P.sub.c = (2.andP;  2),and the lengths of subrecords A and C are L(P.sub.c.) = L(P.sub.a.) = 12.andP;  Adata collision occurs if we place the first unit of subrecord C in the secondunit or third unit of subrecord A (Figure 4).andP;  However, if we place the firstunit of subrecord C in the eighth unit of subrecord A, then subrecord A andsubrecord C are mergeable (Figure 5).andM;MERGING SUBRECORDS WITH INFINITEandM;LENGTHSandM;Next, we address the case where the lengths of both subrecords are infiniteand show a necessary and sufficient condition that they are mergeable.andP;  Wewill later apply this result to the situation where subrecords are of finitelengths.andM;Let m = GCD(D.sub.a + B.sub.a, D.sub.c + B.sub.c), where GCD[X, Y] is thegreatest common divisor of integers X and Y.andP;  Since m = GCD(L(P.sub.a),L(P.sub.c)), L(P.sub.a) = k.sub.a, * m and L(P.sub.c) = k.sub.c * m for someintegers k.sub.a and k.sub.c, and GCD(k.sub.a, k.sub.c) = 1 by definition ofm.andM;Let every m units be called a word.andP;  Then P.sub.a and P.sub.c have k.sub.awords and k.sub.c words, respectively.andP;  The words of P.sub.a and P.sub.c arenumbered from 0 to k.sub.a - 1 and from 0 to k.sub.c - 1, respectively.andP;  Theunits within a word are numbered from 1 to m.andP;  Suppose P.sub.C is put intosubrecord R.sub.a and the first data unit of P.sub.c, denoted by x, is placedat the kth unit of a word of P.sub.a, 1 [is less than or =] k [is less thanor =] m.andP;  Then we have the following observations:andM;OBSERVATION 1.andP;  When P.sub.c repeats, the next occurrence of x will also bethe kth unit of some word of P.sub.a, because the two occurrences of x areseparated by an integral number of words (k.sub.c words in this case).andP;  Thus,all occurrences of x fall on the same unit (kth unit) of some words inP.sub.a (see Figure 6).andM;OBSERVATION 2.andP;  If x is placed on the kth word of pattern P.sub.a, 0 [is lessthan or =] k [is less than or =] k.sub.a, then when pattern P.sub.c isrepeated on subrecord R.sub.a, the next occurrence of x appears on the ((k +k.sub.c) mod k.sub.a)th word of some pattern P.sub.a, the  third occurrenceof x appears on the ((k + 2k.sub.c) mod k.sub.a)th word of some patternP.sub.a, etc.andP;  (see Figure 7), where (U mod V) is the remainder of integer Uwhen divided by integer V.andM;The following lemma shows that the words visited by k.sub.a consecutiveoccurrences of x are precisely [0, 2, ..., k.sub.a - 1].andP;  In other words,when pattern P.sub.c is repeated k.sub.a times, all words (from 0 to k.sub.a- 1) of pattern P.sub.a will be visited by x (see Figure 7).andM;LEMMA 1.andP;  [X.sub.i] X.sub.i = (k + (i - 1) k.sub.c) mod k.sub.a, 1 [is lessthan or[ i [is less than or[ k.sub.a) = [0, 1, 2, ..., k.sub.a - 1] for any 0[is less than or =] k [is less than or =] k.sub.a - 1, if GCD(k.sub.c.andO;k.sub.a) = 1.andM;Proof.andP;  Suppose (k + (i - 1) * k.sub.c) mod K.sub.a = (k + (j - 1) * k.sub.c)mod k.sub.a, for some i and j, 1 [is less than or =] i andless; j [is less than or=] k.sub.a.andP;  Then ((j - i) * k.sub.c) mod k.sub.2 = 0, i.e., (j - i) *k.sub.c = c.sub.o * k.sub.a for some integer c.sub.o.andP;  But (j - i) andless; k.sub.a,and k.sub.c and k.sub.a are relatively prime.andP;  This implies a contradiction.andO;Since all X.sub.i, 1 [is less than or =] i [is less than or =] k.sub.a, aredistinct, and each X.sub.i is in [0, 1, ..., k.sub.a - 1], the desired resultfollows.andM;It is clear that (k + k.sub.c) mod k.sub.a = (k + k.sub.c(k.sub.a + 1)) modk.sub.a, i.e., if pattern P.sub.c is repeated the kth word visited by thefirst occurrence of x will also be visited by the (k.sub.a + 1)th occurrenceof x.andP;  This situation will be repeated for every k.sub.a repetitions ofpattern P.sub.c on  R.sub.a.andM;Example 3  Using Example 2, m = GCD(3, 4) = 1, k.sub.a = 3 and k.sub.c = 4.andO;Let k = 1 and X.sub.1 = 1.andP;  Thus, X.sub.2 = (1 + k.sub.c) mod k.sub.a = (1 +4) mod 3 = 2 and X.sub.3 = (1 + 2 * k.sub.c) mod k.sub.a = (1 + 2 * 4) mod 3= 0, as shown in Figure 4.andM;Based on our earlier observations, we have a necessary and sufficientcondition for subrecords R.sub.a and R.sub.c to be mergeable, if the patternsare repeated an infinite number of times.andM;PROPOSITION 1.andP;  Suppose the patterns P.sub.a and P.sub.c are repeatedinfinitely many times in subrecords R.sub.a and R.sub.c, respectively.andO;Subrecords A and C are mergeable if and only if m [is greater than or =]D.sub.a + D.sub.c, where m = GCD(D.sub.a + B.sub.a, D.sub.c + B.sub.c).andM;Proof.andP;  Let x be the first data unit of pattern C.andM;Sufficiency:andM;If m [is greater than or =] D.sub.a + D.sub.c, then we place the data portionof P.sub.a on the first D.sub.a units of the zeroth word, and x on the(D.Sub.a + 1)th unit of the zeroth word of subrecord A.andP;  (Note that the otherdata units of P.sub.c are on the following (D.sub.c - 1) units.)andP;  Since m [isgreater than or equal] D.sub.a + D.sub.c., then for the first occurrence ofpattern C on the subrecord A, all data units D.sub.c of P.sub.c lie betweenthe (D.sub.a + 1)th unit and (D.sub.a.andP;  + D.sub.c.)th unit of the zerothword.andP;  From Observation 1, all data units of P.sub.c lie between the (D.sub.a+ 1)th unit and (D.sub.a + D.sub.c.)th unit of some word, irrespective of thenumber of times P.sub.c is repeated.andP;  In other words, none of the data unitsof P.sub.c is on the first D.sub.a units of any word.andP;  Thus, no datacollision is possible, because the data portion of pattern P.sub.a is alwayson the first D.sub.a units of some words.andP;  After every k.sub.a repetitions ofP.sub.c on subrecord R.sub.a., x returns to the (D.sub.a + 1)th unit of thezeroth word of pattern P.sub.a visited in the first time, and this isrepeated infinite number of times.andP;  Necessity:andM;Without loss generality, let the data portion of P.sub.a be placed on thefirst D.sub.a units of some word, say the wth word.andP;  If m andless; D.sub.a +D.sub.c., then no matter where x is placed, at least one of the data units ofD.sub.c., say y, must occur on one of the first D.sub.a unit of some word ofpattern P.sub.a..andP;  By Lemma 1, within k.sub.a repetitions of patternP.sub.c., y must visit the wth word of Pattern P.sub.a..andP;  This creates a datacollision.andM;Example 4andM;Using Example 1, since P.sub.a.andP;  = (1, 1) P.sub.c = (1, 3), then m = GCD(1 +1, 1 + 3) = 2 which is equal to D.sub.a + D.sub.c..andP;  The necessary andsufficient condition in Proposition 1 is satisfied.andP;  Therefore these twosubrecords are mergeable, as shown in Figure 3.andM;Example 5andM;Using Example 2, since P.sub.a = (1, 2) and P.sub.c = (2, 2), then m = GCD(1+ 2, 2 + 2) = 1 which is less than D.sub.a + D.sub.c = 3.andP;  The necessary andsufficient condition in Proposition 1 is not satisfied.andP;  Therefore these twosubrecords are not mergeable if they are of infinite lengths as shown inFigure 4.andP;  In Figure 5, subrecords of finite lengths are considered, so thatcollisions can be avoided.andM;MERGING RECORDS WITH FINITE LENGTHSandM;In this section we consider the situation where subrecords R.sub.a andR.sub.c have finite lengths L.sub.a and L.sub.c., respectively, where L.sub.aand L.sub.c are multiples of the lengths of the patterns P.sub.a and P.sub.c,respectively.andP;  Let L(P.sub.a.) and L(P.sub.c.) be the lengths of patternsP.sub.a and P.sub.c., respectively.andM;It is obvious that R.sub.a and R.sub.c can always be merged into a singleresulting subrecord by concatenating one subrecord with the other.andP;  Ourobjective is to have the resulting subrecord with the minimum length.andP;  In theresulting subrecord, either R.sub.a starts first or R.sub.c starts first.andO;Suppose we place subrecord R.sub.c onto subrecord R.sub.a (R.sub.a startsfirst in the resulting subrecord) and obtain the minimum lengthMINLEN.sub.a., among all placements of R.sub.c onto R.sub.a..andP;  LetMINLEN.sub.c be the minimum length of the corresponding resulting subrecordby placing subrecord R.sub.a onto subrecord R.sub.c (R.sub.c starts first inthe  resulting subrecord).andP;  Then the resulting subrecord has minimum lengthMINLEN: MINLEN = min[MINLEN.sub.c., MINLEN.sub.a.].andM;We shall concentrate on the placement of subrecord R.sub.c onto R.sub.a.,andO;since the other case can be handled in a similar fashion.andM;We note that the total length, TOTAL_LENGTH, of any merged subrecord is thesum of L.sub.a and L.sub.c minus the overlapped length OVERLAP, that is:TOTAL_LENGTH = L.sub.a + L.sub.c - OVERLAP where the OVERLAP is the lengththat R.sub.a and R.sub.c overlap each other in the resulting subrecord.andP;  Thusthe problem of finding the minimum total length of resulting subrecord isequivalent to the problems of finding the maximum overlapping length of thetwo given subrecords.andM;If m [is greater than or equal] D.sub.a + D.sub.c., then we place Z, thefirst data unit of R.sub.c., on the (D.sub.a + 1)th unit of the subrecordR.sub.a..andP;  By Proposition 1, there is no data collision.andP;  Furthermore, sinceZ is placed at the leftmost position in R.sub.a without data collision,maximum overlap between R.sub.a and R.sub.c is assured and therefore theminimum length of resulting subrecord is guaranteed.andP;  In the following, wefocus our discussion on the more complex situation where m andless; D.sub.a +D.sub.c..andM;If m andless; D.sub.a + D.sub.c., then by earlier discussion, P.sub.c cannot berepeated k.sub.a times within R.sub.a..andP;  Without loss of generality, let thedata portion of P.sub.a always occur in the first n.sub.1 = floor(D.sub.a./m)words (zeroth word, first word, ..., up to (floor(D.sub.a./m) - 1)th word)and the first n.sub.2 = D.sub.a mod m, (0 [is less than or equal] n.sub.2 [isless than or equal] m) units of the n.sub.1.th word as shown in Figure 8,where floor (X) is the greates integer which is less than or equal to X.andM;Let z be the first data unit of R.sub.c and w be the first unit of somepattern P.sub.c in R.sub.c..andP;  consider the placement of z on the kth unit ofsome word in some P.sub.a in R.sub.a..andP;  As P.sub.c is repeated withinR.sub.c., w will visit different words in P.sub.a.'s in R.sub.a as given byLemma 1.andP;  Suppose the word visited by w is the X.sub.1.th word.andP;  There aretwo possible types of data collisions for this occurrence of P.sub.c inR.sub.a.:andM;1.andP;  Front crash, in which the collision condition is: X.sub.i * m + k [isless than or equal] n.sub.1 * m + n.sub.2andM;This is the situation that w is placed in the dta portion of the P.sub.a..andO;This is called a front collision because w, the fron tpart of P.sub.c.,andO;causes the collision.andM;2.andP;  Rear crash, in which the collision condition is: L(P.sub.a.) - (X.sub.i *m + k) andless; D.sub.candM;This is the situation that the blank space from the (k + 1)th unit of theX.subi.th word in the P.sub.a to the end of the P.sub.a is not enough to holdthe data portion of the occurrence of the P.sub.c., causing the rear part ofthe data portion of P.sub.c to collide with the data portion of next patternP.sub.a (if any) of R.sub.a..andP;  This is called the rear collision.andM;We want to decide the precise location (the word number and the unit number)where z should be placed.andP;  The next lemma says that z should be placed at the(n.sub.2 + 1)th unit of some word in order to maximize the overlap betweenR.sub.a and R.sub.c.. LEMMA 2.andP;  Let z be the first data unit of R.sub.c.andM;1.andP;  If Z is placed at the y.sub.1.th unit, n.sub.2 + 1 andless; y.sub.1 andless; y.sub.1[is less than or equal] m, of some word Z.sub.1 in some P.sub.a of P.sub.aand there is no data collision in the resulting subrecord, then there is nodata collision in the resulting subrecord if Z is placed at the (n.sub.2 +1)th unit of the word Z.sub.i in the same position pattern P.sub.a ofR.sub.a., and more overlap is achieved.andM;2.andP;  If z is placed at the y.sub.2.th unit, 1 [is less than or equal] y.sub.2[is less than or equal] n.sub.2., n.sub.2 S 0, of some word in Z.sub.i insome P.sub.a of R.sub.a and there is no data collision in the resultingsubrecord, then there is no data collision in the resulting subrecord if z isplaced at the (n.sub.2 + 1)th unit of the word Z.sub.i - 1 (the previousword) in the same pattern P.sub.a of R.sub.a., and more overlap is achieved.andO;Proof:andM;1.andP;  For any occurrence of P.sub.c (of R.sub.c.) on R.sub.a., if there is norear collision for this occurence of P.sub.c., then there is no rearcollision if this occurence of P.sub.c is moved (y.sub.1 - (n.sub.2 + 1))units earlier.andP;  Hence, it is sufficient to show that there is no frontcollision by placing z precisely (y.sub.1 - (n.sub.2 + 1)) units earlier.andP;  Itshould be noted that if z is moved y.sub.1 - (n.sub.2 + 1) units earlier, wis also moved the same number of units earlier.andP;  From Figure 8, it is clear aword B.sub.i of P.sub.a can be fully occupied by the data portion of P.sub.a(B.sub.i.andP;  E [0, 1, ..., n.sub.1 - 1]) or an empty word (B.sub.i E [n.sub.1 +1, ..., k.sub.a - 1])  or the word whose first n.sub.2 units are data and theremaining part is blank (B.sub.i = n.sub.1.).andP;  The first case violates thecondition that there is no data collision by placing w in B.sub.i.; for thesecond and third cases, it can be easily verified that there is no frontcollision by placing w at the (n.sub.2 + 1)th unit of the B.sub.i.th word.andO;Furthermore, we can directly observe that more overlap is achieved by movingR.sub.c precisely (y.sub.1 - (n.sub.2 + 1)) units earlier where R.sub.astarts first in the resulting subrecord.andM;2.andP;  In a similar fashion, this case can be proved.andM;From Lemma 2, we conclude that, in order to achieve the maximum overlap byputting R.sub.c onto R.sub.a., it is sufficient to consider the situationthat z is placed at the (n.sub.2 + 1)th unit of some word Z.sub.i of someP.sub.a in subrecord R.sub.a., because only this position will yield the bestresult.andP;  Therefore, in the following discussion of putting R.sub.c ontoR.sub.a., placing z in a word Z means placing z at the (n.sub.2 + 1)th unitof the word Z.andM;Consider the placement of z in the X.sub.1.th word of some P.sub.a inR.sub.a..andP;  Suppose the length of R.sub.a is sufficiently long, so that aspattern P.sub.c is repeated, w will visit words X.sub.2., X.sub.3., etc.,andO;where words X's are defined by Observation 2 and Lemma 1.andP;  Thus, a circle(X.sub.1., X.sub.2., ..., X.sub.ka., X.sub.1.), called a merge circle asindicated in Figure 9, is obtained.andP;  Based on equations 3 and 4, we markthose X's in the merge circle as X.sup.f.'s and X.sup.r.'s which cause frontcollisions and rear collisions, respectively.andP;  X.sup.f.'s and X.sup.r.'s arecalled marked X's, denoted by X.sup.*.'s if there is no need to differentiatefron collisions from rear collisions.andP;  The merge circle will be identicalwhatever word is chosen as X.sub.1..andM;Example 6andM;Suppose P.sub.a = (2, 7), P.sub.c = (2, 13); then m = GCD(9, 15) = 3.andP;  ChooseX.sub.1 = 1.andP;  The merge circle is (1.sup.f., 0, 2, 1.sup.f.).andM;Let Q: (X.sub.i+1., ..., X.sub.i+n., X*.sub.i+n+1.), be a subsequence in amerge circle, where X*.sub.1+n+1 is marked.andP;  This subsequence means that if zis placed in the X.sub.i+1.th word of some pattern P.sub.a then within nrepetitions of pattern P.sub.c on subrecord R.sub.a there is no datacollision (no matter how long R.sub.a is).andP;  If X*.sub.i+n+1 is a frontcollision, we call  this subsequence a front collision subsequence; ifX*.sub.i+n+1 is a rear collision, we call this subsequence a rear collisionsubsequence.andP;  The overlapping length can be maximized with respect to thissubsequence as follows (if both R.sub.a and R.sub.c are long enough):andM;1.andP;  Q is a front collision subsequence, i.e., X.sup.f.sub.i+n+1.. Theoverlapping length can not be greater than n repititions of pattern P.sub.s.,andO;otherwise there is a (front) data collision immediately when the (n + 1)thP.sub.c starts.andP;  Therefore, the best way we can place R.sub.c onto R.sub.awith respect to this subsequence Q is:andM;Placing Strategy F; Let the first unit of the (n + 1)th P.sub.c in R.sub.cstart X.sub.i+n+1 words and n.sub.2 units after the end of R.sub.a so thatbefore this (predicted) front collision occurs, R.sub.a has just terminated,as shown in Figure 10.andM;It is clear the maximum achievable overlap with respect to this subsequence Qis: OVERLAP(Q) = n * L(P.sub.c.) - (X.sub.i+n+1 * m + n.sub.2)andM;2.andP;  Q is a rear-collision subsequence, i.e., X.sup.p.sub.i+n+1.. In thiscase, the overlapping length should be greater than n repetitions of patternP.sub.c (if R.sub.c and R.sub.a are long enough), as shown in Figure 11.andO;Therefore, the best way we can place R.sub.c onto R.sub.a with respect tothis subsequence is:andM;Placing Strategy R: Let the first unit of the (n + 1)th P.sub.c in R.sub.c beplaced in the (n.sub.2 + 1)th unit of the X.sub.i+n+1.th word in the lastoccurence of P.sub.a in R.sub.a., so that before this rear collision actuallyoccurs, R.sub.a has just terminated, as shown in Figure 11.andP;  It is clear themaximum achievable overlap with respect to this subsequence Q is: OVERLAP(Q)= n * L(P.sub.c.) + (L(P.sub.a.) - (X.sub.i+n+1 * m + n.sub.2.))andM;We first consider the maximum possible overlap which can be achieved by allfront-collision subsequences.andP;  Based on Equation 5, it can be directlyobserved that the longer the subsequence is (the larger the n is), the largerthe overlapping length is achieved.andP;  Therefore, it is sufficient for us toconsider only the subsequence(s) with the largest n in all front-collisionsubsequences.andP;  If there are two or more subsequences with the same largest n,again based on Equation 5, we choose the longest subsequence with the minimumX.sup.f.sub.i+n+1..andP;  By Lemma 1.andP;  all X's are distinct in a merge circle.andO;Thus, X.sub.i+n+1 is distinct from all other X's in the merge circle.andP;  Andhence, there is only one such front-collision subsequence, say subsequenceQ.sup.f.. Similarly, based on equation 6, there is only one suchrear-collision subsequence, say subsequence Q.sup.r..andP;  The subsequence whichachieves the largest possible overlap in the marge circle must be eitherQ.sup.f or Q.sup.r., Q.sup.r and Q.sup.f may have different values of n.andP;  Letsubsequence T: (T.sub.1.,..., T.sub.n0., T*.sub.n0+.), allowing n.sub.0repititions of P.sub.c without data collision, be defined as:andM;That is, T is the subsequence which acheives the largest possible overlappedlength in the merge circle.andP;  This length, denoted by OVERLAP.sub.0., can becomputed by Equation 5 or 6 depending upon the data collision type ofT*.sub.n0+1..andP;  Thus, the smallest number of repititions of P.sub.a.,andO;y.sub.0., which contains the largest possible overlap is (see Figures 10 and11):andM;where ceiling [X] is the smallest number which is greater than or equal to X.andM;Thus, given P.sub.a and P.sub.c., the merge circle can be constructed.andP;  Inturn, the subsequence T which determines the largest possible overlap amongall subsequences in the merge circle, and y.sub.0., the smallest number ofrepetitions of P.sub.a which contains the overlap can be determined.andP;  SinceR.sub.a and/or R.sub.c can be of any length (namely, they are not necessarilylong enough as assumed), the maximum possible overlap may not be actuallyachieved in some cases.andP;  Depending on different lengths of R.sub.a andR.sub.c., we have different strategies in order to maximize the actualoverlap.andP;  The lengths of R.sub.a and R.sub.c can be classified into thefollowing:andM;1.andP;  L.sub.c andgt; n.sub.o * L(P.sub.c) and L.sub.a [is greater than or =] y.sub.o* L (P.sub.a) (i.e., both R.sub.a and R.sub.c are long enough)andM;2.andP;  L.sub.c andgt; n.sub.o * L(P.sub.c) and L.sub.c andless; y.sub.o * L(P.sub.a) (i.e.,andO;R.sub.c is long enough, but R.sub.a is short) orandM;3.andP;  L.sub.c [is less than or =] n.sub.o L(P.sub.c) (R.sub.c is short).andP;  Case1.andP;  L.sub.c * L(P.sub.c.) and L.sub.a.[is greater than or =] y.sub.0 *L(P.sub.a.)andM;Since L.sub.c.andgt;n.sub.0 * L(P.sub.c.) and L.sub.a.[is greater than or =]y.sub.0 * L(P.sub.a.), it can be observed from Figure 10 or 11 that R.sub.astarts first and terminates before R.sub.c in the resulting subrecord andmaximum possible overlap is actually achieved by the subsequence T. Case 2.andO;L.sub.c.andgt;n.sub.0 * L(P.sub.c.) and L.sub.a.andless;y.sub.0 * L(P.sub.a.)andM;In this case, R.sub.c is long enough, i.e., L.sub.c.andgt;n.sub.0 * L(P.sub.c.);andO;but R.sub.a is short, i.e., L.sub.a.andless;y.sub.0 * L(P.sub.a.).andP;  Using PlacingStrategy F or R for the subsequence T, it can be observed that R.sub.a can becompletely placed within R.sub.c without data collision (by starting R.sub.aat position * in Figure 10 or 11 for the case L.sub.a.= (y.sub.0.-1) *L(P.sub.a.)), that is R.sub.c will start first in the resulting subrecord andR.sub.a will terminate first in the resulting subrecord.andP;  The minimum totallength of the resulting subrecord is L.sub.c..andP;  This solution is certainlybetter than any solution that can be obtained by letting R.sub.a start firstin the resulting subrecord, since any such solution will yield a length of aresulting subrecord greater than L.sub.c..andP;  Since R.sub.c starts first inthis case, thus, this solution is actually obtained by placing R.sub.a ontoR.sub.c.. Case 3.andP;  L.sub.c.[is less than or =] n.sub.0 * L(P.sub.c.)andM;Let L.sub.c.=C.sub.c * L(P.sub.c.) [is less than or =] n.sub.0., andL.sub.a.=C.sub.a * L(P.sub.a.), where C.sub.a and C.sub.c are integers.andO;Using the subsequence T, we know there is no data collision if we place thefirst unit of R.sub.c in the T.sub.1.th word in the first occurrence ofP.sub.a of R.sub.a.andP;  (By the definition of the subsequence T.andP;  (T.sub.1.,andO;..., ..., T.sub.no., T.sub.no+1.), if z is placed in the T.sub.1.th word ofany P.sub.a in R.sub.a., then there is no data collision while P.sub.arepeats n.sub.o ([is greater than or =] C.sub.c.) times).andP;  But this strategyis not necessarily the best choice.andP;  It may be possible to find a subsequenceY: (Y.sub.j+1., Y.sub.j+2., ..., Y.sub.j+q., Y.sup.*.sub.j+q+1.)., q [is lessthan or = n.sub.o., of shorter or equal length which starts earlier (i.e.,andO;Y.sub.j+1 [is less than or =] T.sub.1.; Y.sub.j+1 [is greater than or =]n.sub.1 is obvious since there is no front collision caused by wordY.sub.j+1) in which z can be placed and there is no data collision (seeFigure 12).andM;Consider a subsequence Y: (Y.sub.j+1., ...., Y.sub.j+q., Y.sup.f.sub.j+q+1.),andO;the following lemma gives a necessary and sufficient condition that there isa data collision if the first unit of R.sub.c is to be placed in the (n.sub.2+ 1)th unit of the Y.sub.j+1.th word in the first P.sub.a in R.sub.a..andM;LEMMA 3andM;1.andP;  For a given subsequence Y: (Y.sub.j+1., ...., Y.sub.j+q.,andO;Y.sup.f.sub.j+q+1.) in the merge circle, the first unit of R.sub.c is placedat the (n.sub.2 + 1)th unit in the Y.sub.j+1.th word of the first  occurrenceof P.sub.a of R.sub.a..andP;  There is a data collision in the resulting subrecordif and only if: q.sup.*.L(P.sub.c.) andless; L.sub.a - (Y.sub.j+1 * m + n.sub.2.)andO;and q andless; C.sub.c (9)andM;2.andP;  For a given subsequence Y: (Y.sub.j+1., ...., Y.sub.j+q.,andO;Y.sup.r.sub.j+q+1.) in the merge circle, the first unit of R.sub.c is placedat the (n.sub.2 +1)th unit in the Y.sub.j+1.th word of the first patternP.sub.a of R.sub.a..andP;  There is a data collision in the resulting subrecord ifand only if: q.sup.*.L(P.sub.c.) andless; L.sub.a - (Y.sub.j+1 * m + n.sub.2.) -andO;L(P.sub.a.) and q andless; C.Sub.c (10)andM;Proof.andP;  We prove only the first case, since the second case can be provedsimilarly.andM;Necessity:andM;1.andP;  q andless; C.sub.candM;By definition of the subsequence, P.sub.c can be repeated q times without anydata collision irrespective of the length of R.sub.a.. Thus, if there is adata collision, P.sub.c has to be repeated more than q times, i.e., C.sub.c andgt;q.andM;2.andP;  q * L(P.sub.c.) andless; L.sub.a - (Y.sub.j+1 * m + n2)andM;We prove this by contradiction.andP;  Suppose q * L(P.sub.c.) [is greater than or=] L.sub.a - (Y.sub.j+1 * m + n.sub.2.).andP;  We now show that there is no datacollision in the resulting subrecord.andP;  In the resulting subrecord, the firstcollision, if it exists, occurs at the (q * L(P.sub.c.) + Y.sub.j+1 * m +n.sub.2 + 1)th unit from the beginning of R.sub.a which is also the beginningof the resulting subrecord (see Figure 10 in which X.sub.i+1 is replaced byY.sub.j+1., n is replaced by q and i replaced by j).andP;  Thus, if R.sub.a isshorter than the location of first collision, i.e., L.sub.a andless; q * L(P.sub.c.)andO;+ (Y.sub.j+1 * m + n.sub.2.) + 1, then no collision is possible.andP;  Note that q* L(P.sub.c) [is greater than or =] L.sub.a - (Y.Sub.j+1 * m + n.sub.2.) isequivalent to L.sub.a andless; q * L(P.sub.c.) + (Y.sub.j+1 * m + n.sub.2.e + 1.andM;Sufficiency:andM;Since q andless; C.sub.c., we now show that there is a front collision when (q +1)th pattern P.sub.c starts.andP;  By definition of Y.sup.f.sub.j+q+1., there is afront collision if R.sub.a is not terminated when the (q + 1)th patternP.sub.c of R.sub.c starts.andP;  When the first unit of R.sub.c is placed in theY.sub.j+1.th word in the first pattern P.sub.a of R.sub.a., by q *L(P.sub.c.) andless; L.sub.a - (Y.sub.j+1 * m + n.sub.2.), it is true that when the(q + 1)th P.sub.c of R.sub.c starts, R.sub.a is not terminated.andP;  Hence, thereis a front collision when the (q + 1)th P.sub.c of R.sub.c starts.andM;Let Y: (Y.sub.j+1., ...., Y.sub.j+q., Y.sup.*.sub.j+q+1.) be a subsequence inthe merge circle.andP;  The sequence is a feasible subsequence if there is no datacollision by placing z in the Y.sub.j+1.th word of the first occurrence ofP.sub.a in R.sub.a..andP;  A subsequence can be determined whether it is afeasible subsequence or not by Lemma 3.andP;  The maximum overlap is achieved bychoosing the smallest Y.sub.j+1 among all feasible subsequences i.e., zshould be placed in the Wth word of the first P.sub.a in R.sub.a where:andM;Now we summarize the preceding discussions.andP;  In order to minimize the totallength of the resulting subrecord by placing R.sub.c onto R.sub.a., we firstconstruct the merge circle from the given P.sub.a and P.sub.c.. Thensubsequence T, n.sub.o and y.sub.o are determined.andP;  The best strategy toplace R.sub.c onto R.sub.a is obtained as follows:andM;Case 1: R.sub.a and R.sub.c are long enough, e.e., L.sub.c andgt; n.sub.o *L(P.sub.c) and L.sub.a [is greater than or =] y.sub.o * L(P.sub.a)andM;The strategy used is either Placing Strategy F or Placing Strategy R for Tdepending on the type of subsequence T.andP;  The overlapping length is giveneither by Equation 5 or 6.andM;Case 2: R.sub.c is long enough but R.sub.c is short, i.e., L.sub.c andgt; n.sub.o* L(P.sub.c) and L.sub.a andless; y.sub.o * L(P.sub.a.)andM;The optimal strategy is obtained by placing R.sub.a onto R.sub.c..andM;Case 3: R.sub.c is short, i.e., L.sub.c [is less than or =] n.sub.o *L(P.subc)andM;An initial solution is constructed using either Placing Strategy F or PlacingStrategy  R for T, depending on the type of subsequence T.andP;  Let the startingposition of this strategy on R.sub.a be the word T.sub.1..andP;  Improve theinitial solution, if possible, by choosing, among all feasible subsequences(as determined by Lemma 3), the one with the smallest starting positionY.sub.f+1 (andless; T.sub.1.).andM;Based on the preceding discussion, the minimum total length MINLEN.sub.a byplacing R.sub.c onto R.sub.d (R.sub.a starts first in the resultingsubrecord) can be computed.andP;  In a similar fashion, the way to place R.sub.aonto R.sub.c (R.sub.c starts first in the resulting subrecord) can beanalyzed and the minimum total length MINLEN.sub.c can be computed.andP;  Thus,the final result to merge R.sub.a and R.sub.c to yield the resultingsubrecord of the minimum total length MINLEN is: MINLEN = min[MINLEN.sub.a.,andO;MINLEN.sub.c.]andM;Example 7 Suppose P.sub.a = (4, 29) and P.sub.c = (4, 8).andP;  Thus, m = GCD(33,12) = 3.andP;  We only analyze the way to place R.sub.c onto R.sub.a., since theway to place R.sub.a onto R.sub.c is similar.andP;  The merge circle is (0.sup.f.,andO;4, 8, 1, 5, 9, 2, 6, 10.sup.r., 3, 7, 3.sup.f.).andP;  Thus, Q.sup.f = (3, 7,0.sup.f) and Q.sup.r = (4, 8, 1, 5, 9, 2, 6, 10.sup.r.).andP;  By Equation 7, T =Q.sup.r and n.sub.o = 7.andP;  Since D.sub.a = 4, thus n.sub.1 = 1 and n.sub2 = 1(see Figure 6).andP;  The largest possible overlap, OVERLAP.sub.o, is by Equation6: OVERLAP.sub.o = n.sub.o * L(P.sub.c.) + L(P.sub.a.) - (T'.sub.x+n.sub.o.+1* m + n.sub.2.) = 7 * 12 + 33 - (10 * 3 + 1) = 86 units.andP;  and y.sub.o =ceiling (OVERLAP.sub.o / L(P.sub.a.)) = ceiling (86 / 33) = 3andM;1.andP;  Suppose L.sub.a = 4 * L(P.sub.a) = 132 units and L.sub.c = 9 *L(P.sub.c.) = 108 units.andP;  This satisfies the Case 11 condition.andP;  Therefore,we use Placing Strategy R for T to place R.sub.c or R.sub.a., maximum overlapof 86 units by placing r.sub.c onto R.sub.a is achieved.andP;  The length of theresulting subrecord is L.sub.a + L.sub.c -- OVERLAP.sub.o = 132 + 108 -- 86 =154 units.andM;2.andP;  Suppose L.sub.a = 2 * L(P.sub.a.) = 66 units and L.sub.c = 9 *L(P.sub.c.) = 108 units.andP;  This satisfies the Case 2 condition.andP;  Therefore, weuse Placing Strategy R for T to place R.sub.c onto R.sub.a., then in theresulting subrecord, R.sub.c will start first and R.sub.a will be terminatedbefore R.sub.c.andP;  The length of the resulting subrecord is L.sub.c = 108units.andM;3.andP;  Suppose L.sub.a = 4 * L(P.sub.a.) = 132 units and L.sub.c = 4 *L(P.sub.c.) = 72 units.andP;  This satisfies the Case 3 condition.andP;  Therefore, theinitial solution can is obtained using Placing Strategy R for T, i.e., we canplace the first unit of R.sub.c at the second unit of the fourth word of thefirst P.sub.a in R.sub.a.andP;  Since the subsequence (1, 5, 9, 2, 6, 10.sup.f.)andO;is a feasible subsequence, so we can place the first unit of R.sub.c at thesecond unit of the 1st word (note that there is a oth word) of the firstP.sub.a in R.sub.a.andP;  This is the leftmost position by placing R.sub.c ontoR.sub.a.andP;  The minimum length of the resulting subrecord is L.sub.a &quot; 132units.andO;</TEXT></DOC>