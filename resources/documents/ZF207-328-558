<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-328-558  </DOCNO><DOCID>07 328 558.andM;</DOCID><JOURNAL>Dr. Dobb's Journal of Software Tools  July 1989 v14 n7 p56(8)* Full Text COPYRIGHT Mandamp;T Publishing Inc. 1989.andM;</JOURNAL><TITLE>Turbo Pascal with objects. (combining the object-oriented approachwith structured concepts)</TITLE><AUTHOR>Floyd, Michael.andM;</AUTHOR><SUMMARY>Turbo Pascal 5.5 includes new features which make it suitable forobject-oriented programming.andP;  It treats objects like any othervariable, allowing either static or dynamic declarations.andP;  Fournew keywords, 'object', 'virtual', 'constructor' and 'destructor'let the programmer create objects dynamically at run time ordeclare them statically within the code.andP;  'Virtual' is also usedto define a virtual method.andP;  The new compiler supportspolymorphism, late binding of virtual methods, and inheritance, asystem in which objects can inherit code and data from a parentobject type.andP;  Turbo Pascal 5.5 allows experienced Pascalprogrammers to easily learn the benefits of object-orientedprogramming.andM;</SUMMARY><DESCRIPT>Company:   Borland International Inc. (products).andO;Product:   Turbo Pascal 5.5 (Program development software) (usage).andO;Topic:     Object-Oriented ProgrammingStructured ProgrammingSoftware DesignTutorialCompilersType-In ProgramsPASCAL.andO;Feature:   illustrationprogram.andO;Caption:   The general form for an object definition (program)Code for a basic window object (program)andM;</DESCRIPT><TEXT>Turbo Pascal with ObjectsandM;If artificial intelligence was the buzzword for the mid-1980s, then itsequivalent for the late 1980s (and early 1990s) must be object-orientedprogramming (OOP).andP;  But instead of the distant promises offered by AI, OOPrepresents a superior method for the design and construction of today'ssoftware.andM;Because OOP's approach encourages good programming practices that complementstructured programming, combining Pascal and OOP seems a natural evolutionarystep, one that Borland has taken with its most recent release of TurboPascal.andP;  In this article, I'll explore the major features that have beenadded to Turbo Pascal (TP) 5.5, including object-oriented extensions to thelanguage and to the debugger.andP;  We'll also examine TP's overlay manager andtake a look at the new capabilities of the Smart Linker.andP;  Finally, we'llprovide a full-blown example that demonstrates most of TP 5.5sobject-oriented features.andM;Language OverviewandM;Turbo Pascal has added only four new keywords to the language set: object,virtual, constructor, and destructor.andP;  With these four keywords, you candeclare objects statically within your program or create them dynamically atrun time.andP;  These objects can inherit code and data from a parent (orancestor) object type, and you can override any inherited method.andO;Constructors and destructors provide automated initialization and cleanup ofobjects.andP;  In addition, constructors and destructors can be used inconjunction with the expanded New and Dispose procedures to allocate anddeallocate heap storage for dynamic objects.andM;TP 5.5 supports the notion of virtul methods (as does C++).andP;  Virtual methodsallow you to implement polymorphism.andP;  Both TP's Integrated Debugger and TurboDebugger 1.5 provide object support.andP;  Additionally, as previously mentioned,enhancements have been made to TP's overlay manager and the Smart Linker andimprovements have been made to speed up the compiler.andM;SyntaxandM;In Turbo Pascal, objects can be thought of as records that have the abilityto inherit code and data from ancestor object types.andP;  The generalized formfor an object definition is shown in Example 1.andP;  Defining an object issimilar to defining a record.andP;  The object keyword replaces the recordkeyword, and object takes an optional argument -- the ancestor that this newobject will inherit from.andM;Methods in TP are simply procedure and function headers placed directly inthe object definition.andP;  The virtual keyword (which is optional) is used todefine a virtual method.andP;  Methods not using the virtual keyword are staticmethods.andM;As an example, consider a windowing environment that contains a menu bar,pull-down menus and a text window that, in turn, contains other windows suchas scroll bars and resize boxes.andP;  Window systems are a natural for anobject-oriented programming approach.andM;First, let's create the basic window object type like that coded in Example2.andP;  From this basic window, we can create an object hierarchy of morespecialized windows like the MenuBar and PullDown object types shown inExample 3.andM;Notice that MenuBar inherits three virtual methods (Done, Show, and Hide) andthen adds two static methods (Highlight and Select).andP;  Also notice that theconstructors for each of these object types are different as well.andP;  Eachmethod is like a forward declared procedure that must be defined in the sameunit or program module.andP;  The syntax for defining a method isObjectType.Method and is illustrated in Example 4.andM;You invoke an object's method in the same manner that you would reference thefields of a record using the familiar dot syntax.andP;  Refer to Example 4 for anexample of how to call the Window object's Show method.andM;TP objects are just like any other variable -- they can be declaredstatically in a VAR declaration or dynamically allocated on the heap andreferenced via pointers.andM;I've left out a lot of the details in this example so that you can easily seethe overall structure and calling sequence.andP;  I've also provided an exampleprogram that highlights the creation and use of objects in TP 5.5.andP;  FDEMO.PAS(see Listing One, page 95) implements a simple forms editor.andM;The fact that objects can be used across units is important, particularly asyou begin developing your own libraries.andP;  Therefore, the example consists oftwo units and a main.andP;  FDEMO, as previously mentioned, contains the mainprogram.andP;  FORMS.PAS (see Listing Two, page 95) is a unit that implements aForm object and its associated Fields, and SLIDERS.andP;  PAS (see Listing Three,page 97) adds a graphic counter feature.andM;Because of space considerations, I won't go into detail on the example.andP;  Youshould, however, find the forms demo instructive as you read through the nextsection.andM;Virtual MethodsandM;There are two required features for any object-oriented programming languageand TP 5.5 has both.andP;  The first, which you've already seen, is inheritance.andO;The other is support for late binding of virtual methods and polymorphism.andM;From an implementation standpoint, the major difference between static andvirtual methods is simple when they are bound: A static method call is just aspecial procedure call that can be resolved at compile-time for maximumefficiency (early binding).andM;A virtual method call, on the other hand, requires a table lookup based onthe RUN-TIME identity of the object.andP;  This table lookup gives an object theability to respond appropriately to a requested action (late binding).andM;To illustrate this important idea, consider an example where a linked list ofwindows can contain either menu windows or text windows.andP;  This allows adisplay routine to traverse the linked list and send a &quot;display message&quot; toeach window: NextWin := Head; while NextWin andless;andgt; nil do begin NextWin .Show;NextWin := NextWin .Next; end;andM;To resolve a virtual method call at runtime, TP creates one Virtual MethodTable (VMT) in the data segment for each object type.andP;  The VMT contains thesize of an object type, and a pointer to the code of each of the methods forthat object.andP;  An instance of an object is linked to the VMT through aconstructor call.andM;Defining a method as virtual is a simple matter of appending the virtualkeyword to the method's header.andP;  However, there are a few rules to keep inmind.andM;If you declare a method as virtual in an ancestor type, you must also declareany overriding methods as virtual.andP;  In addition, the parameters foroverriding methods must be exactly the same, including the number ofparameters and the parameter types.andP;  This is different than the case forstatic methods, which can vary, both the number of parameters and theparameter type.andM;Also, as mentioned earlier, each instance of an object must be linked to itsVMT so every newly instantiated object must be initialized by a constructorcall.andP;  Failure to make the constructor call can result in a system crash.andO;You can detect this error by setting the $R+ compiler directive.andP;  Thiscompiler directive provides range checking for all virtual methods called inyour program, and issues a run-time error if the object's VMT pointer has notbeen initialized.andM;Objects are structured types that generally require some initializationbefore they are used and some cleanup before they are disposed of.andP;  A typicalsequence of instructions would beandM;1.andP;  Allocate an object on the heapandM;2.andP;  Call its &quot;initialization&quot; method and pass in relevant parameters forstorage or computation inside the objectandM;3.andP;  Use the object (repeat until done with object)andM;4.andP;  Call its &quot;cleanup&quot; method to close files, release any dynamic memory usedby the object, and so onandM;5.andP;  Deallocate the object.andM;The standard procedures New and Dispose already perform the first and lastoperations described above.andP;  TP's new construction and destructor methods areintended to perform steps 2 and 4 respectively.andP;  Because the ordering ofthese steps is important, New has been extended to take a constructor methodcall as an optional second parameter.andP;  Similarly, Dispose accepts adestructor method call as a second parameter.andM;Debugger SupportandM;Turbo Pascal provides support for debugging objects as well.andP;  The integrateddebugger, for instance, allows you to either step over or trace throughmethod calls.andP;  Because the debugger is actually executing the code in yourprogram, there's no different between tracing a static or virtual method.andM;The Integrated Debugger allows you to view objects using the Evaluate Window.andO;You can view just the object's data fields or you can view the address of themethod's code.andP;  In addition, an object can be added to the Watch window.andP;  Inboth the Watch and the Evaluate windows, all expressions that are valid forrecords are also valid for objects.andM;Finally, the Integrated Debugger allows you to enter expressions into theFind Procedure command (available from the Debug menu).andP;  A legal expressionmust evaluate to an address in the code segment.andM;The stand-alone debugger, Turbo Debugger (TD) 1.5, has everything in theIntegrated Debugger plus an object inspector (for both object types andinstances) and a hierarchy browser.andP;  Again, there's no difference betweentracing a static or virtual method because the debugger is actually executingthe code in your program.andP;  This brings up another important point.andP;  Methodscan be executed from within the Turbo Debugger environment.andM;The best way to get a feel for the objects in your program and explore thefeatures of TD 1.5 at the same time is to load your program up into TD andcrank up the hierarchy browser.andP;  The hierarchy browser brings up a two-panedwindow that displays an alphabetical list of objects used in the left pane,and the ancestor/descendent relationships between objects in the right pane.andO;The hierarchy browser is shown in Figure 1.andM;The hierarchy browser allows you to scroll through a graphical representationof the hierarchy and highlight object types.andP;  TD also provides an incrementalsearch feature that allows you to quickly locate object types in a complexhierarchy.andP;  Once you've highlighted an object type, you can select it bypressing Enter, which brings up the Object Type Inspector.andM;The Object Type Inspector (see Figure 2) is also a two-paned window thatdisplays the data fields of an object type in the upper pane and itsassociated methods in the lower pane.andP;  Highlighting and selecting a datafield brings up another Object Type Inspector for browsing complex or nestedobject structures.andP;  Highlighting and selecting a method, on the other hand,brings up a Method Inspector.andM;This Method Inspector displays the method's code address, the name and typesof the method's parameters, and whether it is a procedure or a function.andO;Pressding Enter anywhere in the Method Inspector takes you to the source codefor that method.andM;TD also provides an Object Instance Inspector that allows you to examine thedata of object instances.andP;  The Object Instance Inspector, which is similar tothe record inspector, adds a new feature that displays an instance's methodsalong with their associated code addresses.andP;  Of course, these addresses takepolymorphic objects and their VMT into account.andM;Overlay ManagerandM;One of the more interesting parts of TP is the overlay manager.andP;  Until now,the internals of the overlay manager have largely been undocumented.andP;  TP'soptimized Least Recently Used (LRU) algorithm provides a major step inoptimizing the way overlays are loaded into memory.andP;  Before describing thisnew optimization, however, let's take a look at how TP 5.0's overlay managerworks.andM;When an overlay is called, it is loaded into a section of memory between thestack segment and the heap called the overlay buffer.andP;  This buffer can bethought of as a &quot;ring&quot; buffer that has two pointers -- one pointing to thebeginning of the buffer (head pointer) and the other pointing to the end(tail pointer).andP;  Figure 3 illustrates the behavior of the ring buffer andshould be referred to in the following discussion.andM;Initially, the head and tail pointers point to the same address.andP;  When anoverlay is loaded into the overlay buffer, the head pointer advances into thefree memory area and marks the beginning of the overlay.andP;  As more overlaysare loaded the free area is eventually taken up.andP;  Typically, some free spaceremains, but not enough to accommodate the size of the overlay.andM;At this point, when another overlay is called, the head pointer wraps aroundto the bottom of the overlay buffer keeping the free area between the headand tail pointers.andP;  The new overlay is then loaded at the head, which slideseverything up in the buffer and bumps the first overlay off the ring.andP;  Thisis referred to as the least recently loaded method.andM;One possible problem with the least recently loaded method is that the ringbuffer doesn't take frequency of use into account.andP;  So, it is possible for aless frequently used overlay to replace one that is used more often simplybecause it was loaded last.andP;  TP 5.5 provides an option to optimize theloading of overlays by intelligently selecting which overlay gets bumped offthe ring.andM;TP accomplishes this selection by placing on &quot;probation&quot; overlays nearing thetail.andP;  While on probation, the overlay manager monitors and traps any callsmade to the overlay.andP;  If a call is made, the overlay is placed at the head ofthe overlay buffer and is given a free ride around the ring.andM;The overlay manager adds two new routines to get and set the size of theprobation area.andP;  The size of the probation area will depend largely on yourapplication.andP;  Therefore, the OvrLoadCount and OvrTrapCount variables areprovided to monitor how often an overlay has been loaded or trapped.andP;  Byplacing these variables in the Watch window of the debugger, for instance,you can monitor the effect of different probation sizes on your program.andM;The overlay manager provides a couple of other goodies, such as OvrFileMode,to get and set on overlay's file mode.andP;  This is particularly useful in anetwork environment.andP;  Another variable, OvrReadBuf, allows you to interceptoverlay load operations for error handling, or to check for a removable disk.andO;Finally, TP 5.5 allows you to append overlays to the end of your .EXE files.andM;Smart LinkerandM;TP 5.0 included a built-in linker that removes code and data not actuallyreferenced in the program.andP;  In building an .EXE file, the smart linkerremoved code on a per procedure basis, and removed data on a per declarationbasis.andM;TP 5.5 extends this capability to objects.andP;  In particular, the smart linkerremoves code for static methods on a per method basis, meaning that if yourprogram never calls a particular static method, the code for that method willnot be included in the .EXE file.andP;  Virtual methods of a given object type,however, are treated as a single group by the linker.andP;  If your program everinstantiates an object of a type that contains any virtual methods, all ofthem will be linked into the .EXE.andM;The benefits of the smart linker with objects will become particularlyapparent as you build your own libraries of standard objects.andP;  You'll be ableto link these object libraries (as units) with your programs knowing that thesmart linker will strip out any unused objects.andM;ConclusionandM;One of the difficulties with AI was the tremendous learning curve thatprogrammers had to go through.andP;  First you had to learn a language like Listor Prolog.andP;  Next, you had to become familiar with concepts like expert systemdesign, neural networks, natural language processing, and the like.andM;TP 5.5, on the other hand, provides an excellent migration path to OOP.andP;  Oldcode runs fine under the new compiler, and the OOP approach works well withstructured concepts.andP;  You can, therefore, add objects as you need them andalleviate the need to learn everything at once.andP;  Ultimately, you'll gain thebenefits of objects including flexibility, reusability, and extensibility.andO;</TEXT></DOC>