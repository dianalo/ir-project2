<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-486-596  </DOCNO><DOCID>07 486 596.andM;</DOCID><JOURNAL>Computer Language  August 1989 v6 n8 p73(7)* Full Text COPYRIGHT Miller Freeman Publications 1989.andM;</JOURNAL><TITLE>Using the Common LISP Object System.andO;</TITLE><AUTHOR>Gabriel, Richard P.andM;</AUTHOR><SUMMARY>The Common LISP Object System (CLOS) is an object-orientedextension to the LISP language that implements a generalization ofthe message-passing model, inheritance of class structure andbehavior, a generic function approach, and the concept ofmetaclass.andP;  Message passing is extended to generic functions.andO;Inheritance of behavior is effected by associating methods withclasses, while inheritance of structure passes a representation ofthe state of an object.andP;  Generic functions are ordinary functionsimplemented as a set of methods which can be combined to effect anoperations.andP;  Metaclasses are classes of instances of classes andare capable of controlling representation of instances of theirinstances.andP;  The structure of CLOS makes it an object to studyobject-oriented programming.andM;</SUMMARY><DESCRIPT>Topic:     LISPSystem DesignSpecificationsApplicationsObject-Oriented ProgrammingMethodsProcedures.andO;Feature:   illustrationchart.andO;Caption:   Simple class hierarchy. (chart)Inheritance of structure. (chart)Metaclasses. (chart)andM;</DESCRIPT><TEXT>Using the Common LISP Object System Object-oriented programming is becomingincreasingly popular and important.andP;  Among the benefits claimed forobject-oriented programming are code reusability, separation of interfacefrom implementation, simplified protocols, increased modularity, rapidprototyping, and distributed procedure definitions.andM;Experimentation with object-oriented concpets in LISP has been going on sincethe early 1970s within a subdiscipline of artificial intelligence calledknowledge representation, involving framelike systems, semantic nets, andprocedural attachment.andM;Because LISP is a language with extraordinary features related toobject-orientedness, object-oriented extensions to LISP zre unlike ordinaryobject-oriented languages.andP;  This article reviews some features of the CommonLISP Object System (CLOS).andM;Object-oriented programmingandM;The term &quot;object-oriented&quot; refers to the fact that most object-orientedlanguages attach behavior or code to objects.andP;  Programs in these languagesare collections of objects with attached behavior rather than collections ofcode.andP;  To trigger behavior in some of these systems, messages are sent toobjects.andP;  Smalltalk is the best-known message-passing language.andM;The concept of sending a message has two implications.andP;  First, themessage-response mechanism is associated with the object that is asked torespond.andP;  Second, the model for a program is similar to a group of people ororganizations that interact to solve the problem.andP;  Message passing is oftencited as one of the hallmarks of object-oriente programming.andM;CLOS does not use the message-passing model but a generalization of it thatfits more smoothly into the LISP framework: generic functions.andM;Classification and inheritanceandM;Two other hallmarks of object-oriented programming are classification andinheritance.andP;  When a number of objects behave similarly, it is economical tocluster that behavior into an object that represents the shared behavior.andO;For example, all integers are printed using the same procedure, so it makessense to attribute the property of how to print an integer to the class ofall integers rather than to each integer individually.andP;  And since thatproperty holds for all integers, whether or not they exist in some runningprogram, it is truly class-specific.andM;Therefore, almost all object-oriented systems have some mechanism forattributing behavior to classes either in addition to or instead ofattributing behavior to individuals.andP;  This is known as classification.andM;The set of all odd integers is a subset of the set of all integers.andP;  If wewere to define a class to capture properties of odd integers, we would rathernot have to duplicate the properties odd integers share with all integers.andO;Because many properties are shared, copying them would be a major andinconvenient duplication.andP;  If we wanted to modify the code that implementedsome behavior in one of the classes, we might forget to modify the code forthe other class; that is, we wish to avoid redundancy and ensure consistency.andM;In the property called inheritance, behavior is automatically shared betweena class and a subclass.andP;  Of course, the sharing is only one-way: specialbehavior defined in the subclass is not shared by the class.andP;  One implicationof this is that the set of operations that can be applied to a subclass is asuperset of the operations that can be applied to its superclass.andM;Two important properties can be inherited: structure and behavior.andP;  Tounderstand inheritance, look at the class hierarchy example in Figure 1.andP;  Itis called a class hierarchy because it is an arrangement of classes assuperclasses and subclasses.andP;  In this example, [C.sub.2] is a subclass of[C.sub.1], [C.sub.3] is a subclass of [C.sub.1], [C.sub.4] is a subclass of[C.sub.3], and [C.sub.5] is a subclass of [C.sub.3].andP;  We could define thishierarchy using the following expressions:andM;(defclass c1()()) (defclass c2(c1)()) (defclass c3(c1)()) (defclass c4(c3)())(defclass c5(c3)())andM;[I.sub.2] is an instance of [C.sub.2], [I.sub.3] is an instance of [C.sub.3],[I.sub.4] is an instance of [C.sub.4], and [I.sub.5] is an instance of[C.sub.5].andP;  Subclasses inherit structure and behavior from superclasses.andP;  Thestate of being a superclass is transitive, so [C.sub.1] is a superclass of[C.sub.5] and [C.sub.5] is a subclass of [C.sub.1].andP;  Also, we say [I.sub.5]is an instance of [C.sub.1].andP;  In contrast, we say [I.sub.5] is a directinstance of [C.sub.5].andM;For example, integer is the class that represents all integers; integer is asubclass of number.andP;  The number 3 is an instance of integer and of number.andO;Generally this stilted but accurate form of expression is abbreviated, as in&quot;3 is an instance of integer.&quot;andM;T is the most general class and is a superclass of every other class.andM;Inheritance of behaviorandM;Inheritance of behavior is achieved by associating methods with classes.andP;  Aclass that does not have a method directly associated with it for someoperation can inherit one.andP;  A method for an operation is defined for a classif the method is defined directly for the class or one of its suerclasses.andO;In the latter case, the method is said to be inherited from the most specificsuperclass.andP;  In the previous diagram, [C.sub.3] is more specific than[C.sub.1] and [C.sub.5] is more specific than [C.sub.3].andM;We can associate print methods with [C.sub.1] and [C.sub.5] as follows:andM;(defmethod print((self c1)) ...) [1] (defmethod print ((self c5)) ...) [2]andM;The numbers in square brackets to the right of the defmethod expressions areused to explain code and are not part of CLOS syntax.andM;In CLOS, we use an expression like (print i5) to print [I.sub.5].andP;  Thisapplies the print function to [I.sub.5].andP;  Since a print method is associatedwith [C.sub.5] (namely method [2]), that method is invoked.andP;  To print[I.sub.4] we would use an expression such as (print i4).andM;Because no print method is associated with [C.sub.4], thefunction-application mechanism looks for a print method associated with thesuperclass of [C.sub.4]; namely, it looks at [C.sub.3].andP;  No print method isfound, so it looks at [C.sub.1], where it finds method [1].andP;  Therefore, topring [I.sub.4], method [1] is invoked.andM;We say C.sub.4 inherits its print method from C.sub.1.andP;  When invokingmethods, this behavior is called inheritance of behavior.andP;  Of course,invocation of methods is usually not implemented using such a search at runtime.andM;Related to inheritance of behavior is something that could be calledself-relative method invocation.andP;  A method defined on a subclass can addclass-specific behavior to a general method if the specific method cansomehow invoke the general one.andM;Let's look at an example involving printing.andP;  Suppose instances of [C.sub.5]are printed by using angle brackets around the printed representation ofsuperclass of [C.sub.5.andP;  Methods [1] and [2] in more detail are:andM;(defmethod print ((self c1)) (format t ...))  [1] (defmethod print ((selfc5))  [2] (format t &quot;andless;&quot;) (call-next-method) (format t &quot;andgt;&quot;))andM;When method [2] is invoked, it first prints andless;, then invokes the next mostspecific method (which happens to be method [1]), and finally prints andgt;.andP;  Thefunction call-next-method calls the next most specific method if one exists;otherwise, it invokes an error handler.andP;  Using this simple mechanism, aprogrammer can compose methods associated with a particular class.andM;Inheritance of structureandM;Other attributes of objects might be inherited.andP;  The most important isstructure.andP;  The structure of an instance provides a mechanism forrepresenting the state of an object.andP;  Many languages have facilities fordefining structured objects--STRUCTs in C and DEFSTRUCTs in Common LISP.andM;Sometimes the structure of one object is similar to the structure of someother one.andP;  For example, the structure of a Jeep's representation will be asuperset of an automobile's.andP;  A Jeep is simply an automobile with additionalcharacteristics.andP;  Also, most of the behavior of a Jeep will be shared withautomobiles, so it makes sense to inherit both structure and behavior.andP;  Whena subclass is defined, we say it specializes its superclass.andM;Let's look at two classes, [C.sub.1] and [C.sub.2], from a structural pointof view:andM;(defclass c1()(s1s2s3)) (defclass c2(c1)(r1r2))andM;The class [C.sub.1] defines the structure of its instance: all instances of[C.sub.1] will have the named slots [S.sub.1], [S.sub.2], and [S.sub.3].andO;[C.sub.2] is a subclass of [C.sub.1], so it will inherit the structuredefined by [C.sub.1].andP;  The definition of [C.sub.2] specifies that itsinstances will have the named slots [R.sub.1] and [R.sub.2].andM;Because all instances of [C.sub.2] are instances of [C.sub.1], instances of[C.sub.2] will also have the named slots [S.sub.1], [S.sub.2], and [S.sub.3].andO;This is illustrated in Figure 2.andP;  The order of the slots is not important.andM;It might make sense to have an object-oriented system in which theinheritance of structure could be separate from the inheritance of behavior.andO;One reason not to use this approach would be that behavior depends on thestate of the object, and the state is contained in the structure of theobject.andP;  Therefore, behavior and structure are intertwined, and theirinheritance details should be the same.andM;Generic functionsandM;CLOS uses a technique called the generic function approach.andP;  Common LISP--andmost LISPs--support ad hoc polymorphism.andP;  In ordinary polymorphism, thedefinition of an operation is such that it is insensitive to the types ofarguments passed to it.andP;  In ad hoc polymorphism, the types of the argumentsare examined and appropriate code executed.andM;In Common LISP, the expression (+xy) does not imply that x and y are of anyparticular type or of the same type.andP;  For example, x might be an integer andy a complex number, and the + operation is required to perform the correctcoercions to produce an appropriate result.andM;Thus, it is possible to add a floating-point number to a complex number bywriting the expression (+ a-float a-complex), where a-float is afloating-point number and a-complex is a complex is a complex number.andP;  Thecode for + simply looks at the types of its arguments and dispatches to theproper code.andP;  In CLOS, we could write the method for + that would handle thisoperation as:andM;(defmethod + ((x float) (y complex)) ...)andM;where the elided code is specific to the case at hand.andP;  The full definitionof + could be a set of such method definitions.andP;  In Common LISP, however, +is not usually implemented this way.andM;A generic function is an ordinary function implemented as a set of methods,one (or some) of which is selected for invocation depending on the classes ortypes of the supplied arguments.andP;  CLOS is integrated into Common LISP soevery CLOS class is a Common LISP type, and most built-in Common LISP typesare classes.andM;In the sample method definitions, I have used the distinguished variable selfto refer to the object to which the message was sent.andP;  We've used thisconvention until now, but there is no essential reason to adopt a specialnaming mechanism when Common LISP has an acceptable binding mechanism.andP;  Wecan write the definition of print in CLOS as (defmethod print (objectclass))...).andP;  This method will be invoked when the argument to print is aninstance of class.andM;In the generic function approach, objects and functions are autonomousentities, and neither is a property of the other.andP;  Generic functions decoupleobjects and operations upon objects; they serve to separate operations andclasses.andP;  In the case of operations on zero or more arguments, the operationis a generic function and methods are defined that perform the operationdepending on the classes of the supplied arguments.andP;  For example, suppose anoperation oper exists on two parameters.andP;  The following two methoddefinitions partially define the generic function oper:andM;(defmethod oper ((x class1) (y class2)) ...)andP;  [1] (defmethod oper ((x class3)(y class4)) ...)andP;  [2]andM;If oper is applied to two arguments, the first an instance of class1 and thesecond an instance of class2, method [1] will be run; we say method [1] isapplicable.andP;  If it is applied to two arguments, the first an instance ofclass3 and the second an instance of class4, method [2] will be run.andP;  Method[1] is said to be defined on class1 and class2.andP;  We also say oper specializesits two arguments.andP;  Generic functions are made up of the set of methodsdefined for them.andP;  Some people refer to methods whose applicability dependson the classes of two or more arguments as multimethods.andM;Generic functions provide not only an elegant solution to the problem ofoperations of more than one argument, but also a clean generalization of theconcept of functions in Common LISP.andP;  Each method of the generic functiondefines how to perform an operation on arguments that are instances ofparticular classes or subclasses of those classes.andP;  The generic functionpackages those methods and selects the right one to invoke.andM;Because CLOS is a system for Common LISP, it is important that genericfunctions be first-class objects and that the concept of generic functions bean extension to and a generalization of the concept of Common LISP functions.andM;In a message-passing system, the class graph and the instances are trulycentral because the methods are associated with a particular class orinstance.andP;  It makes sense in this setting to think of the methods as part ofthe structure of a class or an instance.andM;In a generic-function system, the generic functions provide a very differentview of methods.andP;  Generic functions become the focus of abstraction; they arerarely associated unambiguously with a single class or instance.andP;  They sitabove the substrate that is the class graph, and the class graph providescontrol information for the generic functions.andM;In CLOS, if we restrict ourselves to methods whose applicability depends onlyon the first argument and class hierarchies in which classes have at most onesuperclass and we use only call-next-method for self-relative methodinvocation, the system we have is basically equivalent to Smalltalk.andM;In a generic-function system, the most specific of all the applicable methodsis invoked.andP;  If two methods that specialize on two arguments are applicableto a pair of arguments, the methods must be ordered to know which to invoke.andM;CLOS uses a simple lexicographic ordering to determine the most specificmethod.andP;  Consider the operation oper.andP;  Suppose the following two methods areapplicable to a given pair of arguments:andM;(defmethod oper ((x class1) (y class2)) ...)andP;  [1] (defmethod oper ((x class3)(y class4)) ...)andP;  [2]andM;If class1 is a subclass of class3, then method [1] is more specific.andP;  Ifclass3 is a subclass of class1, then method [2] is more specific.andP;  If class1= class3, then method [1] is more specific only if class2 is a subclass ofclass4.andP;  (If class2 = class4, one of these two methods has overridden theother.)andM;Method combinationandM;If several classes provide methods for the same generic function, the methodsare combined.andP;  Method combination is one of the most interesting concepts inCLOS.andP;  All methods for the same generic function inherited by a class arecombined into a single effective method used to implement an operation.andM;The simple behavior of invoking the most specific applicable method is aspecial but common case of method combination.andP;  When one class is defined toinherit from another, the structure specified for both classes is combined toform the structure of the instances of the subclass.andP;  In other words, a classdefines a partial structure and the total structure is the combination of thestructures provided by all the classes.andM;We can look at methods the same way.andP;  Each method definition is actually apartial definition of the total method--the effective method--that applies toa particular instance or set of instances.andP;  The way a structure combines iswell-defined and relatively simple.andP;  The way methods combine is a little morecomplicated, but this is the result of the complexity of the desiredeffective method and the freshness of this concept.andM;The mechanism to achieve method combination is to provide different types ofmethods.andP;  When a generic function is invoked, all the applicable methods arecombined into a single effective method, where the type of a method and itsprecedence determine its role in the effective method.andP;  These types arerepresented by method qualifiers, which are used as markers to distinguishfour types of methods: primary methods, methods that run before a primarymethod, methods that run after a primary method, and methods that run beforeall other types of methods.andM;The markers are :around, :before, and :after.andP;  Methods without markers arethe primary methods.andP;  Because methods are instances of classes, it would makesense for these different types of methods to be represented by differentclasses.andP;  However, the definition of CLOS is at least partly constrained byexisting--and sometimes naive--current practice.andM;The use of method combination and the roles of the markers will beillustrated using the example of an object-oriented spreadsheet.andM;MetaclassesandM;The final hallmark of object-oriented programming is the concept of themetaclass.andP;  Most object-oriented systems provide a means to define classesand place them within a hierarchy that is used for inheritance.andP;  Instances ofthese classes are the objects in the object-oriented system.andP;  A uniformlyobject-oriented system would be one in which every object is an instance ofsome class.andP;  In such a system, each class is an instance of some class.andP;  Aclass whose instances are classes is called a metaclass.andM;In Figure 3, [I.sub.2] is an ordinary instance of the class [C.sub.2].andO;[C.sub.2] is an instance of [M.sub.2].andP;  [M.sub.2] is a metaclass sometimescalled the metaclass of [I.sub.2].andP;  [M.sub.2] is also an instance of someclass, but the chain of metaclasses is finite.andP;  Some classes end up beinginstances of themselves, and some are both instances and subclasses ofanother class.andP;  In CLOS, standardclass is the metaclass for almost all of theclasses in CLOS.andP;  This class is an instance of itself, and its subclasses areinstances of standardclass.andM;Among other things, metaclasses control the representation of instances oftheir instances.andP;  This is in contrast to classes, which control the structureof their instances.andP;  The structure of an instance is the set of slots in theinstance.andP;  The representation of an instance is the way that storage is laidout; it might be like a vector or a list.andP;  Everything in Common LISP is aninstance of some class; that is, everything is an object.andP;  For example,floating-point numbers are instances of the class float.andP;  The metaclass offloat is not standard-class because the representation of floating-pointnumbers is not the same as the structurelike representation of ordinaryinstances.andM;To see that metaclasses control representation, let's look again at howgeneric functions and methods are defined and used.andP;  Suppose we have anoperation oper we want to apply to ordinary instances.andP;  If a particularmethod should be invoked when the argument to oper is an instance of theclass [C.sub.2], we would write (defmethod oper ((x c2))...) and perform theoperation by writing (oper i2).andM;A generic function called make-instance takes a class and makes an instanceof it (it also initializes the fresh instance, but that is not importantyet).andP;  We invoke make-instance as (make-instance c2 ...) and define a methodfor it as (defmethod make-instance ((x m2)...)...).andP;  The method make-instanceis on a metaclass because we will be passing classes as arguments.andP;  Thismethod allocates storage and initializes the instance.andP;  Therefore,make-instance, which is a function of metaclasses, controls therepresentation of instances of its instances.andM;Classes obey a number of other protocols that are controlled by metaclasses.andO;For example, when accessing a slot in an instance with slots, the metaclasscontrols the mapping from slot names to storage.andM;Some object-oriented systems, such as CLOS, have an elaborate metaclassstructure.andP;  Others, such as Smalltalk, have a simpler structure; some, suchas C++, have no metaclass structure whatsoever.andM;CLOS is an excellent language with which to study object-oriented programmingconcepts because it embodies traditional practices and new trends.andP;  CLOSgeneralizes the concept of message passing to generic functions.andP;  Multipleinheritance and method combination provide a mechanism for inheriting complexstructure and behavior while maintaining abstraction.andP;  First-classmetaclasses provide a means to change underlying representations andprotocols.andP;  The rich initialization protocol helps solve thornyinitialization and consistentcy problems.andM;Even though object-oriented programming is almost 30 years old, many newthings remain to be discovered and new ways of programming have yet to beexplored.andM;Richard P. Gabriel is chief technical officer of Lucid Inc. in Menlo Park,Calif., and consulting associate professor at Stanford University.andO;</TEXT></DOC>