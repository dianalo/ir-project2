<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-501-390  </DOCNO><DOCID>07 501 390.andM;</DOCID><JOURNAL>Communications of the ACM  August 1989 v32 n8 p988(7)* Full Text COPYRIGHT Assn. for Computing Machinery, Inc. 1989.andM;</JOURNAL><TITLE>Using a relational system on Wall Street: the good, the bad, theugly, and the ideal.andO;</TITLE><AUTHOR>Rozen, Steve; Shasha, Dennis.andM;</AUTHOR><SUMMARY>The BondDB decision support system was designed to exploit arelational data base management system used by Wall Streetinvestors to buy and sell bonds.andP;  The existing applicationreplaced by BondDB had a number of problems, including theinability to handle new analytical applications and to exchangedata with other company information.andP;  The earlier application alsohad an primitive teletype user interface.andP;  The relational modelwas the key to the success of the new system, but a number ofproblems still remained.andP;  The developers found that, while thereare benefits to relational systems, their limitations sometimesresult in clumsy and confusing applications.andM;</SUMMARY><DESCRIPT>Product:   BondDB (Computer program) (usage).andO;Topic:     Wall StreetRelational DBMSData base designFinancial SoftwareBondsDecision Support Systems.andM;</DESCRIPT><NOTE>Only Text is presented here; see printed issues for graphics.andO;</NOTE><TEXT>Using A Relational System On Wall Street: The Good, The Bad, The Ugly, AndThe Ideal Conventional wisdom has it that complex decision support is anextremely promising application of the relational model.andP;  Partly for thisreason, one of the authors (Rozen) was hired to design the database for adecision support system used by Wall Street investment managers.andP;  Theapplication, based on the Oracle relational database management system, wasto replace a previous one written on top of a file system.andP;  Problems with theprevious application system included the inability to enhance itsfunctionality to suit new analytical applications, the inability to exchangedata with other company information, and an antiquated teletype userinterface.andM;The developers were able to reimplement the functionality of the old systemin seven months, and their success depended largely on the virtues of therelational model.andP;  However, problems still remained.andP;  To illustrate both thepromise and the problems, in this article, we focus on several criticaldesign requirements and the ability of the relational system to satisfy them.andO;In all important respects, our analysis is independent of Oracle and reflectsissues that the use of any relational database management system would raise.andM;Our view of the relational model is that defined by standard SQL or QUEL.andO;Technically, these are languages equivalent in expressive power to therelational calculus augmented with aggregates (and grouping), a small set offunctions on column domains (e.g., addition, substring), a data definitionlanguage, update operations, and sorting operators.andP;  We assume thatrelational systems support sharing (concurrency control) and transactionrecovery.andM;THE APPLICATIONandM;The application, called BondDB, is designed to support buying and sellingbonds by institutional sales people, traders, and risk managers in aninvestment bank.andP;  Users of BondDB canandM;(1) try to find investments for a client that are both less expensive thanthe client's current investments and more profitable as long as interestrates remain below some specific value,andM;(2) estimate a likely decline in the value of an investment for a typicalday, based on the recent variability of a bond's price, to try to keep atrader from holding too many risky bonds, orandM;(3) evaluate the fair value of an investment today for different futureinterest rate scenarios.andM;To perform these analyses, BondDB requires information about the bonds andtheir historical behavior.andM;BondDB's financial calculations and user interfaces made it impractical toconstruct the entire system using only a combination of SQL and applicationgeneration tools provided with the database management system.andP;  Therefore theapplication programs are written almost entirely in a conventionalprogramming language.andM;THE DATAandM;BondDB contains the following data:andM;(1) basic information on the characteristics of about 10,000 different bonds,andM;(2) time series of daily quotes for about 3,000 of these bonds, totaling some1.8 million points,andM;(3) about a dozen different kinds of bonds, andandM;(4) information on portfolios of bonds.andM;We draw our examples from the representation of two main entity types: bondsand portfolios.andP;  Figure 1 is a simplified entity-relationship diagram ofBondDB's data-representation requirements.andM;BondsandM;A bond is basically a loan from the holder of the bond to the issuer.andP;  Itspecifies a sequence of payments of principal and interest according to somerules or schedule.andP;  Here is a simple example.andP;  Issuer: U.S.andP;  Treasury FaceValue: $1,000.00 Payments: 5/31/88--$38.75 11/30/88--$38.75 5/31/89--$38.7511/30/89--$38.75 +$1,000.00 face value Type of Bond: Treasury Note Coupon:7-3/4% Maturity date: 11/30/89andM;In this case there are four semi-annual interest payments of $38.75, and theprincipal is paid back in a lump sum after two years.andM;PortfoliosandM;A portfolio is set of bonds that have been bought in various quantities.andO;Each andless;bond, quantityandgt; pair is called a position.andP;  For some analyses BondDBalso needs to record when the bond was bought and for how much.andP;  BondDB alsoincludes some information about the portfolio itself, such as the name of itsowner, and the order in which to display the portfolio's positions.andM;BondDB AND THE RELATIONAL MODEL--HOWandM;GOOD A MATCH?andM;In this section, we discuss central data management requirements of BondDBand how the developers tried to meet them using the relational databasemanagement system.andP;  We then describe features of an ideal (yet, we believe,realizable) system that could provide superior support.andM;Management of Bulk Data TypesandM;One of the virtues of the relational model is that statements of its querylanguage operate on entire relations at a time.andP;  One can formulateset-oriented expressions such as the following, SELECT BOND_ID FROM BONDWHERE BOND_ID NOT IN (SELECT BOND_ID FROM PRICE); which prints the IDs of allbonds that have no price history (the good).andM;A bulk data type is a composite data type whose instances contain adynamically varying, and potentially large, number of elements.andP;  Thus setsand relations are bulk data types, as are multisets, sequences (lists),trees, and graphs.andP;  BondDB required usable implementations of bulk data typesother than relations and the ability to include instances of such types asattributes of bonds and portfolios.andM;For example, many bonds are characterized by a sequence of time intervals andprices indicating when and for how much the issuer can call the bond (i.e.,andO;prepay the loan to the bond holder).andP;  An example is the following: Issuer:Brooklyn Union Gas Type of Bond: Preferred stock Last dividend: $ 2.47 Facevalue: $25.00 Moody's Rating: A2 SP rating: A 'Call' schedule: 8/31/81 to8/30/86--$27.92 8/31/86 to 8/30/91--$27.36 8/31/91 to 8/30/96--$26.81 8/31/96to 1/01/15--$26.25andM;In this case, the issuer can call the bond at $27.36 per share any timebetween 8/31/86 and 8/30/91.andP;  The most common query is to retrieve the callinformation when the other information about this security is fetched.andP;  Amore sophisticated query might want to know the monetary value of the calls,which is a function of the bond's current price, price volatility, time tomaturity, and remaining call schedule.andP;  Both queries require manipulation ofthe CALL SCHEDULE as a sequence.andM;Representing the call schedule with multiple attributes, that is, BOND( .andP;  . andO;., CALL_DATE.sub.1, CALL_PRICE.sub.1, .andP;  .  ., CALL_DATE.sub.1,CALL_PRICE.sub.1, .andP;  .  .), would lead to well-known problems.andM;One of the problems is that maximum size of a call schedule may not be knownwhen the schema is designed.andP;  If CALL.sub.n+1 is added, all code using callschedules will need to be modified.andP;  Furthermore, variables in SQL cannotrange over columns.andP;  For example, to print just the remaining call dates andprices, we would have to write: SELECT CALL_DATE.sub.1, CALL_PRICE.sub.1 FROMBOND WHERE CALL_DATE.sub.1 andgt; TODAY; .andP;  .  .  SELECT CALL_DATE.sub.n,CALL_PRICE.sub.n FROM BOND WHERE CALL_DATE.sub.n andgt; TODAY;andM;Therefore the developers include a separate table for this information forall bonds in the database: CALL(BOND_ID, CALL_DATE, CALL_PRICE), whereBOND_ID and CALL_DATE constitute the key.andP;  The information for the BrooklynUnion Gas (BUG) example is then stored in two tables, BOND and CALL as seenFigure 2.andP;  To fetch all information about the bond BUG-PS from a relationalsystem into a host language one needs two queries (the ugly): SELECT* FROMBOND WHERE BOND_ID = 'BUG-PS'; and SELECT* FROM CALL WHERE BOND_ID = 'BUG-PS'ORDER BY CALL_DATE;andM;Ideally, one would like to express this relationship directly by defining anattribute CALL_SCHEDULE of type SEQUENCE (of tuples) on the BOND table:CREATE TABLE BOND ( BOND_ID CHAR(10), .andP;  .  .  CALL_SCHEDULE SEQUENCE (CALL_DATE DATE, CALL_PRICE FLOAT, ) .andP;  .  .  );andM;Then to retrieve this information one would simply write: SELECT* FROM BOND;andM;This would be followed by operations that can handle sequences as standardrelational query languages handle relations.andM;Procedures as DataandM;BondDB's developers tood advantage of the capability of relational systems tostore queries as views.andP;  For example, the following statements basicallystore a procedure to ensure that only the owner of a portfolio can modify it.andO;CREATE VIEW UPDATE_PORTFOLIO AS SELECT* FROM ALL_PORTFOLIO WHEREALL_PORTFOLIO.OWNER = USER; GRANT SELECT, UPDATE, INSERT, DELETE ONUPDATE_PORTFOLIO TO PUBLIC;andM;In this example the stored equity, which takes advantage of the set-at-timerelational operators, provides a succinct, executable specification of themodifiability constraints on portfolios (the good).andM;Some relational systems offer triggers, i.e., statements to be executedwhenever some change to the data, such as an insert, occurs.andP;  Many databasemanagement system implementors consider triggers to be an exotic feature, butthey could have been useful to BondDB's developers.andP;  For example, in BondDB,to make the most recent price quickly available, it is stored with the bondcharacteristic information in the BOND table.andP;  Thus an insert or update ofthe PRICE table may actually require modifications to two tables, PRICE andBOND.andP;  BondDB could have used triggers to ensure that the prices stored inthe BOND table were always up-to-date as shown in Figure 3.andP;  For a DBMS withtriggers, application programs would need to modify PRICE only.andP;  If the needto maintain the most recent price disappeared, or if it became necessary tomaintain the most recent five prices, there would be no need to modify theapplication programs, because the update action on PRICE would beencapsulated in the database.andM;BondDB's need to store procedures went further than triggers and views.andP;  Somedata can be stored succinctly in the form of a rle, but viewed by clientsoftware as the data generated by the rule (an extension of the viewconcept).andP;  For example, in some, but not all, call schedules, a sequence ofrows can be expressed as a rule, e.g., BUG-PS becomes callable on 8/31/81 at$27.92; thereafter the call price declines three times by 55-2/3 cents atfive-year intervals; the call price is rounded to the nearest cent.andM;Other information can be expressed only procedurally, such as rules thatdetermine the coupon of floating rate bonds based on the London interbanklending rate and the treasury bill rate.andP;  For example, the following formuladetermines one bond's coupon payments:andM;A typical query is: For a given future interest rate scenario, and during agiven time period, what payments will the holder receive?andM;In cases such as these it would be best if the database could store theprocedure but allow client software to view the data as a sequence (theideal).andP;  What the developers have to do now is to represent BUG-PS as thesequence that host-language applications must manipulate (the ugly).andP;  They donot represent the lending-rate-dependent data at all, since it depends onvalues that are unknown in advance (the bad).andM;Data AbstractionandM;Initially, BondDB's developers represented financial entities by astraightforward transcription of the normalized relational schema into Cstructs.andP;  The developers assumed it would be satisfactory to supplyapplication programmers with routines which return query results as arrays ofstructs.andP;  They also assumed that the programmers could be relied on tomanipulate the struct representations of database tuples appropriately.andO;There were two main flaws with the approach:andM;(1) different application programmers tended to write routines withoverlapping functionality, andandM;(2) some kinds of bonds have important information in more than one table(e.g., the BOND and CALL tables in Figure 2) because of normalization, makingit difficult for the progammer to know which tables contain information abouta given bond.andM;Thus this approach caused reliability problems from the beginning.andM;Eventually, the developers realized that bonds and portfolios are modifiedand analyzed in certain stereo-typical ways.andP;  For example, portfolios may befetched from or written to the database, and manipulated or analyzed usingmathematical tools.andP;  So, to an application, the portfolio is a collection ofdata with some set of operations that can be issued on that data.andP;  This isthe definition of an abstract data type.andM;When the developers recognized the abstract data type character of entitiesrepresented in BondDB, they defined ADTs in C to represent BondDB's majorfinancial constructs, (e.g., bonds and portfolios).andP;  The developers use therelational system for its virtues of ensuring recovery and concurrencycontrol, associative access, the facility with which they can set up andmodify relational schemas, and the ease with which they can generate querycode for tables.andP;  In order to operate on an entity, the developers must mapthe date from relations to the C-language structures of the ADT, manipulateit using C-based abstract data type primitives, and then possibly return itto relations.andM;Ideally, the developers would define the abstract data types directly in thedatabase system.andP;  Putting ADTs into the database dovetails well with theideals of the previous sections, becauseandM;(1) BondDB's ADTs have component instances of bulk data types,andM;(2) one would like to store the operations of the ADT in the database as wellas the data, andandM;(3) sufficiently powerful ADT facilities could be used to define new bulkdata types if necessary.andM;Physical Data IndependenceandM;The relational model provides the application program with independence frominternal data structures in three main ways:andM;(1) Queries will have the same result regardless of the physical organizationof the tables and the availability or unavailability of indexes.andM;(2) Application programmers need to be concerned with the order of columns intables or with columns that are not referenced since columns are referencedby name rather than by offset from the beginning of a record, for example.andM;(3) Stored procedures in the form of views let the database management systempresent virtual tables, providing an optional additional layer ofindependence.andM;BondDB developers relied on all three kinds of physical data independence(the good).andM;The options for specifying details of physical implementation, however, didnot always provide enough efficiency for BondDB (the bad).andP;  Performanceconsiderations forced the developers to implement part of the database usingoperating system facilities.andP;  In particular, they installed a copy of theBOND table in shared memory, thus partly duplicating the function of thedatabase management system's cache (the ugly).andP;  At that point they had tohand-code search structures since a linear search of the shared memoryconsumed more CPU resources than a lookup in the database using indexes.andM;The developers also were forced to rely on reserved fields to enable them toincorporate additional columns to the C struct without simultaneouslyre-compiling and re-linking all application programs.andP;  The managementheadaches introduced in maintaining the copied data were substantial.andP;  Forexample, whenever important data needed to be corrected, the shared memorycopy had to be reinitialized making it unavailable for about 15 minutes.andO;Furthermore, there was a period of several hours each day when the sharedmemory copy did not agree with the database copy.andM;To say that, ideally, the hardware should have run faster is not helpful.andP;  Atthe least, an ideal database management system should provide more optionsfor specifying implementation aspects.andP;  In this example, being able to fix atable in memory would have been helpful.andM;Recovery and Concurrency ControlandM;There is one final issue we observed that ties the physical level to theabstract level.andP;  One of the important steps forward in database systems wasthe decoupling of concurrency control and recovery from the data model(relational, network, or hierarchical).andP;  This decoupling is not alwaysdesirable, at least for BondDB.andM;Users must be able to modify portfolios when they buy or sell bonds in them.andO;Each modification may require several operations.andP;  For example, to add abond, a user provides the characteristics of the bond (if it does not alreadyexist in the database) and the quantity bought.andP;  To make this set ofoperations atomic (i.e., all-or-nothing) in a file system which only providesatomic operations on records, the developers would have to order theoperations carefully and provide adequate redundancy to ensurerecoverability.andP;  For example, when adding a position with a bond not yet inthe database, one would first save the bond characteristic information, andthen the position because without the bond characteristic information, theposition is meaningless.andM;The transaction notion, supported by relational systems, is a big improvementover the facilities usually provided by a file system (the good).andO;Transaction support automatically provides recoverability at the level of awhole group of operations constituting, for example, the addition of a bondto a portfolio.andM;Implementing such transactions normally requires holding update locks untilthe end of the transaction (to prevent other transactions from readinguncommitted updates).andP;  In most systems the smallest item that can be lockedis a page, and BondDB stored several portfolio positions per page.andO;Unfortunately, there is a small set of actively modified portfolios to whichmost position records are added.andP;  This results in records from differentportfolios interleaved on the same pages being updated concurrently.andP;  Thedevelopers therefore frequently received the complaint that a user was lockedout of his portfolio when no one else was accessing it (the bad).andM;To overcome this problem, the developers defined a protocol in whichprocesses only select for update (i.e., exclusively lock) the header record(the one containing the portfolio ID, the owner, and so on).andP;  All otherportfolio information (hundreds of positions) is selected from the databasewithout locking.andP;  BondDB then modifies the portfolio in user space.andP;  Thisworks, but is incovenient because to avoid unnecessary database updates,BondDB must keep track of what data in the portfolio has been modified andwhat has not.andP;  Code to keep track of how the portfolio has changed is hard todebug and test.andP;  Furthermore, there is the danger that an interactive SQLuser, unaware of the protocol, might accidentally circumvent it.andP;  In an idealsystem the unit of locking would be a portfolio, which is an abstract datatype, so two users could modify different portfolios concurrently.andM;RELATED WORKandM;Codd has faulted the SQL language for inadequate handling of null values andother design problems, and has faulted SQL implementations for permittingduplicate rows.andP;  Here we assess the utility of the relational model per se,rather than a particular query language.andP;  For example, some systems maypermit duplicate rows partly out of real need for multi-relations.andO;Associated difficulties are often due to inconsistent or obscure rules forhandling the duplicate rows.andM;Much criticism of the relational model focuses not on its possibleshortcomings for traditional business applications, but on eitherandM;(1) its inadequate expressiveness for non-traditional database applications,such as design databases, cartographic databases, and multi-media databases,orandM;(2) its inadequate performance for high transaction applications,notwithstanding recent advances in high-transaction systems such as NonStopSQL.andM;Sometimes both criticisms play a role, as in Peinl, Reuter, and Sammer'sdiscussion of a bid-matching system for a stock exchange.andP;  In this systemproblems arise because the relational system has inadequate knowledge of thesemantics of the ADTs represented in it and therefore cannot makeoptimizations necessary for the application's stringent performancerequirements.andM;Nevertheless, some researchers have observed the shortcomings that BondDBencountered.andP;  For example, Bancilhon and Maier assert that current systemsare not satisfactory for business applications because of the impedancemismatch between the relational system and the host language and then go onto discuss possible improvements.andP;  The impedance mismatch is thediscontinuity in type system and computational model between the databasemanagement system and the host language; the database management systemutilizes set-at-a-time expressions with a non-procedural language, while thehost language offers record- and field-level expressions in an imperativelanguage.andP;  Indeed the impedance mismatch was one of the factors that forcedBondDB's developers to manage two representations of each financial entityand supply translation code between the two.andM;Many workers are constructing systems that might be more satisfactory.andP;  Thedesign space is large, but the work is promising.andM;Stonebraker, citing the success of the relational model, proposesevolutionary changes in POSTGRES, which supports user-defined data types andcomplex objects via the storage of procedures as attribute values.andP;  POSTGRESalso allows lower-level access when performance requirements demand it.andO;Another approach to extending the relational model, by allowing nestedrelations, is taken by AIM-II and R.sup.2.D.sup.2., which supports, inaddition, user defined ADTs for complex objects.andM;Many projects (e.g., ENCORE, GARDEN, Iris, O.sub.2., ORION, PROTEUS,Trellis/Owl) and even products (e.g., OPAL/Gemstone, PROBE, Vbase) have begunto build object-oriented database management systems whose basic persistentobjects are ADT instances.andM;Some of the systems above, and others (e.g., Starburst) allow the applicationdeveloper to include additional database access structures.andP;  Other systems(e.g., EXODUS, GENESIS) provide a set of building blocks from which toassemble a database management system tailored to a particular application.andO;Finally, some researchers are attempting to erase the distinction between theprogramming language and the database management system altogether.andP;  Examplesof this approach are Galileo, and PS-Algol.andM;CONCLUSIONandM;This article attempted an empirical assessment of the tools BondDB'sdevelopers had at their disposal--a relational database management systemwith a conventional programming language.andM;We saw that, while relational systems are good, their limitations requireugly workarounds, even though realizable improvements would result in acleaner application implementation.andM;This was by no means a complete listing of all issues the developers faced.andO;Some, such as politics, are pervasive but immune to a technological solution.andO;Others, like the need for rapid development in a competitive environmentdepend on factors other than the data model such as the availability ofpeople and machine resources.andP;  Application programmers do not ask for magic,however, just the best tools that can be efficiently implemented.andM;Necessary features of an ideal system begin to emerge.andP;  It would:andM;(1) include a richer selection of built-in bulk data types than relationsonly, and support data abstraction to allow users to introduce instances oftheir own complex data types--our example was call schedule sequences andcorresponding operations as database values,andM;(2) allow procedures written in arbitrary programming languages to be storedin the database and viewed either as procedures or as the data that theyproduce at any given time--our example was floating rate coupons,andM;(3) offer more tuning options, such as the ability to fix certain data inmain memory, andandM;(4) allow locking of logical objects, such as portfolio instances.andM;To summarize our challenge to designers of future database managementsystems: Go ahead, make our database.andM;Acknowledgments.andP;  This work was partially supported by the Office of NavalResearch under grant N00014-85-K-0046.andP;  Special thanks to Norman M. Birkett,David M. Siegel, and Gudmundur Vigfusson, who helped define BondDB'sinformation architecture, for many enlightening discussions on what would bebetter for BondDB, and to Yosi Ben-Dov for balancing the short-termexigencies of the users against the long-term exigencies of maintainabledevelopment.andP;  We also thank Norman M. Birkett, Gudmundur Vigfusson, and theanonymous reviewers for suggesting improvements.andO;</TEXT></DOC>