<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-102-870  </DOCNO><DOCID>07 102 870.andM;</DOCID><JOURNAL>Communications of the ACM  March 1989 v32 n3 p382(5)* Full Text COPYRIGHT Assn. for Computing Machinery, Inc. 1989.andM;</JOURNAL><TITLE>Abstracts from other ACM publications.andM;</TITLE><DESCRIPT/><NOTE>Only Text is presented here; see printed issues for graphics.andO;</NOTE><TEXT>Abstracts from Other ACM PublicationsandM;Distributed Cooperation with Action Systems Action systems provide a methodto program distributed systems that emphasizes the overall behavior of thesyste.andP;  System behavior is described in terms of the possible interactions(actions) that the processes can engage in, rather than in terms of thesequential code that the processes execute.andP;  The actions provide a symmetriccommunication mechanism that permits an arbitrary number of processes to besynchronized by a common handshake.andP;  This is a generalization of the usualapproach, employed in languages like CSP and Ada, in which communication isasymmetric and restricted to involve only two processes.andP;  Two differentexecution models are given for action systems: a  sequential one and aconcurrent one.andP;  The sequential model is easier to use for reasoning, and isessentially equivalent to the guarded iteration statement by Dijkstra.andP;  It iswell suited for reasoning about system  properties in temporal logic, butrequires a stronger fairness notion that it  is reasonable to assume adistributed implementation will support.andP;  The concurrent execution modelreflects the true concurrency that is present in a distributed execution, andcorresponds to the way in which the system is actually implemented.andP;  Anefficient distributed implementation of action systems on a local areanetwork is described.andP;  The  fairness assumptions of the concurrent model canbe guaranteed in this implementation.andP;  The relationship between the twoexecution models is studied in detail in the paper.andP;  For systems that will becalled fairly serializable, the two models are shown to be equivalent.andP;  Proofmethods are given for verifying this property of action systems.andP;  It is shownthat for fairly serializable systems, properties that hold for any concurrentexecution of the system can be established by temporal proofs that areconducted entirely within the simpler sequential execution model.andM;For Correspondence: R. J. R. Back, Abo Akademi, Department of ComputerScience, Lemminkaisenkatu 14, SF-20520 Abo, Finland; R. KurkiSuonio, TampereUniversity of Technology, Computer Systems Laboratory, P.O. Box 527, SF-33101Tampere, Finland.andM;Analysis of Functional Programs to DetectandM;Run-Time Garbage CellsandM;We propose a method for detecting the generation of garbage cells byanalyzing a source text written in a functional programming language whichuses ordinary linked lists to implement list-type values.andP;  For asubexpression such as F(G(...)) in a program where the function values of Fand G are of list type, if a cell c is created during the computation of Gand if c does not appear in a list-type value of F, then c becomes a garbagecell at the end of the computation of F.andP;  We discuss this problem on thebasis of formal languages derived from the functional program text and showsome sufficient conditions that predict the generation of garbage cells.andO;Also, we give an efficient algorithm to detect at compile time the generationof garbage cells which are linearly linked.andP;  We have implemented thesealgorithms in an experimental LISP system.andP;  By executing several sampleprograms on the system, we conclude that our method is effective in detectingthe generation of garbage cells.andM;For Correspondence: Department of Information and Computer Sciences, Facultyof Engineering Science, Osaka University, Toyonaka, Osaka, 560, Japan.andM;Efficient Synchronization on Multiprocessors with Shared MemoryandM;A new formalism is given for read-modify-write (RMW) synchronizationoperations.andP;  This formalism is used to extend the memory reference combiningmechanism introduced in the NYU Ultracomputer, to  arbitrary RMW operations.andO;A formal correctness proof of this combining mechanism is given.andP;  Generalrequirements for the practicality of combining are discussed.andP;  Combining isshown to be practical for many useful memory access operations.andP;  Thisincludes memory updates of  the form mem[val:=mem[val op val, where op neednot be associative, and a variety of synchronization primitives.andP;  Thecomputation involved  is shown to be closely related to parallel prefixevaluation.andM;For Correspondence: C. P. Kruskal, Computer Science Department, Institute forAdvanced Computer Studies, University of Maryland, College Park, MD 20742; L.andO;Rudolph, Institute of Mathematics and Computer Science, The Hebrew Universityof Jerusalem, Jerusalem, Israel; M. Snir, IBM T. J. Watson Research Center,P.O. Box 218, Yorktown Heights, NY 10598.andM;Director Strings as CombinatorsandM;A simple calculus (the Director String Calculus--DSC) for expressingabstractions is introduced, which captures the essence of the &quot;long reach&quot;combinators introduced by Turner.andP;  We present abstraction rules that preservethe applicative structure of the original lambda term, and that cannotincrease the number of subterms in the translation.andM;A translated lambda term can be reduced according to the evaluation rules ofDSC.andP;  If this terminates with a DSC normal form, this can  be translated intoa lambda term using rules presented below.andP;  We call this process ofabstracting a lambda term, reducing to normal form in the space of DSC terms,and translating back to a lambda term an implementation.andM;We show that our implementation of the lambda calculus is correct: For lambdaterms with a normal form that contains no lambdas (ground terms), theimplementation is shown to yield a lambda calculus normal form.andP;  For lambdaterms whose normal forms represent functions, it is shown that theimplementation yields lambda terms that are beta-convertible in zero or moresteps to the normal form form of the original lambda term.andP;  In this sense,our implementation involves weak reduction according to Hindley et al.andP;  [9].andM;For Correspondence: School of Information Systems, University of East Anglia,Norwich NR4 7TJ, U.K.andM;Smarter RecompilationandM;Tichy's Smart Recompilation method can be made smarter by permitting benigntype inconsistencies between separately compiled modules.andP;  This enhancedmethod helps the programmer to make far-reaching changes in small, manageablesteps.andM;For Correspondence: R. W. Schwanke, Siemens Research and TechnologyLaboratories, 105 College Road East, Princeton, NJ 08540; G. E. Kaiser,Department of Computer Science, Columbia University, New York, NY 10027.andM;A Solution to a Problem with Morel and Renvoise's &quot;GlobalandM;Optimization by Suppression of Partial Redundancies&quot;andM;Morel and Renvoise have previously described a method for global optimizationand code motion by suppression of partial redundancies [1].andP;  Morel andRenvoise use data flow analysis to determine expression computations thatshould be inserted at the end of certain basic blocks and to determineredundant computations that can be eliminated.andP;  The execution of thesetechniques results in the movement of loop invariant expressions out of theloop.andP;  In addition to [1] Morel and  Renvoise's techniques can also beapplied to subexpressions of larger expressions.andP;  Then, however, in certainspecial cases these optimization techniques move expressions to places wheresome of its subexpressions are neither available nor moved together with theexpression.andP;  In this paper we present a modification of Morel and Renvoise'salgorithm that avoids the above described situations.andM;For Correspondence: Siemens AG, ZTI SOF 22, Otto-Hahn-Ring 6, 8000 Munchen83, Federal Republic of Germany.andM;ACM Transactions on Programming Languages and Systems  January 1989andM;A Simple Interprocedural Register Allocation Algorithm and ItsandM;Effectiveness for LISPandM;Register allocation is an important optimization in many compilers, but withper-procedure register allocation, it is often not possible to make good useof a large register set.andP;  Procedure calls limit the improvement from globalregister allocation, since they force variables allocated to registers to besaved and restored.andP;  This limitation is more pronounced in LISP programs dueto the higher frequency of procedure calls.andP;  An interprocedural registerallocation algorithm is developed by simplifying a version of interproceduralgraph coloring.andP;  The simplification corresponds to a bottom-up coloring ofthe interference graph.andP;  The scheme is evaluated using a number of LISPprograms.andP;  The evaluation considers the scheme's limitations and comparesthese &quot;software register windows&quot; against the hardware register windows usedin the Berkeley RISC and SPUR processors.andM;For Correspondence: P.A.andP;  Steenkiste, Computer Science Department,Carnegie-Mellon University, Pittsburgh, PA 15213; J. L. Hennessy, ComputerSystems Laboratory, Stanford University, Stanford, CA 94305.andM;Row Replacement Algorithms for Screen EditorsandM;Interactive screen editors repeatedly determine terminal command sequences toupdate a screen row.andP;  Computing an optimal command sequence differs from thetraditional sequence comparison problem in that there is a cost for movingthe cursor over unedited characters and the cost of an n-character command isnot always the cost of n one-character commands.andP;  For example, on anANSI-standard terminal, it takes nine bytes to insert one character, ten toinsert two, eleven to insert three, and so on.andP;  This paper presents an O(MN)dynamic programming algorithm for row replacement where an n-charactercommand costs [alpha]n + [beta] for constants [alpha] and [beta].M is thelength of the original row and N is the length of its replacement.andP;  Alsogiven is an O(Cost X (M + N)) &quot;greedy&quot; algorithm for optimal low replacement.andO;Here Cost is the optimal cost (in bytes) of the replacement, so the algorithmis fast when the required update is small.andP;  Though the algorithm is rathercomplicated, it is fast enough to be useful in practice.andM;For Correspondence: E. W. Myers, Department of Computer Science, Universityof Arizona, Tucson, AZ 85721; W. Miller, Department of Computer Science, ThePennsylvania State University, University Park, PA 16802.andM;Scheduling Expressions on a Pipelined Processor with a MaximalandM;Delay of One CycleandM;Consider a pipelined machine that can issue instructions every machine cycle.andO;Sometimes, an instruction that uses the result of the instruction precedingit in a pipe must be delayed to ensure that a program computes a right value.andO;We assume that issuing of such instructions is delayed by at most one machinecycle.andP;  For such a machine model, given an unbounded number of machineregisters and memory locations, an algorithm to find a shortest schedule ofthe given expression is presented and analyzed.andP;  The proposed algorithm is amodification of Coffman-Graham's algorithm [7], which provides an optimalsolution  to the problem of scheduling tasks on two parallel processors.andM;For Correspondence: D. Bernstein, IBM T. J. Watson Research Center, P.O. Box704, Yorktown Heights, NT 10598; I. Gertner, Center for Large-SaleComputation, The Graduate School, CUNY, 25 W. 43 St., Suite 400, NY, NY10036.andM;Typed Representation of Objects by FunctionsandM;A systematic representation of objects grouped into types by constructionssimilar to the composition of sets in mathematics is proposed.andP;  Therepresentation is by lambda expressions, which supports the representation ofobjects from function spaces.andP;  The representation is related to a ratherconventional language of type descriptions in a way that is believed to benew.andP;  Ordinary control-expressions (i.e., case- and let-expressions) arederived from the proposed representation.andM;For Correspondence: Department of Computer Science, DTH, Bygning 344, KD-2800Lyngby, Denmark.andM;Distributed FIFO Allocation of Identical Resources Using SmallandM;Shared SpaceandM;We present a simple and efficient algorithm for the FIFO allocation of kidentical resources among asynchronous processes that communicate via sharedmemory.andP;  The algorithm simulates a shared queue but uses exponentially fewershared memory values, resulting in practical savings of time and space aswell as program complexity.andP;  The algorithm is robust against process failurethrough unannounced stopping, making it attractive also for use in anenvironment of processes of widely differing speeds.andP;  In addition to itspractical advantages, we show that for fixed k, the shared space complexityof the algorithm as a function of the number N of processes is optimal towithin a constant factor.andM;For Correspondence: M. J. Fischer, Department of Computer Science, YaleUniversity, 10 Hillhouse Avenue, P.O. Box 2158, Yale Station, New Haven, CT06520-2158; N.A.andP;  Lynch, Department of Electrical Engineering and ComputerScience, MIT, Cambridge, MA 02139; J. E. Burns, School of Information andComputer Science, Georgia Institute of Technology, Atlanta, GA 30332-0280; A.andO;Borodin, Department of Computer Science, Sanford Fleming Building, 10 KingsCollege Circle, Room 2303B, Toronto, Ontario M5S1A4.andM;Efficient Implementation of Lattice OperationsandM;Lattice operations such as greatest lower bound (GLB), least upper bound(LUB), and relative complementation (BUTNOT) are becoming more and moreimportant in programming languages supporting object inheritance.andP;  We presenta general technique for the efficient implementation of such operations basedon an encoding method.andP;  The effect of the encoding is to plunge the givenordering into a boolean lattice of binary words, leading to an almostconstant time complexity of the lattice operations.andP;  A first method isdescribed based on a transitive closure approach.andP;  Then a morespace-efficient method minimizing code-word length is described.andP;  Finally apowerful grouping technique called modulation is presented, which drasticallyreduces code space while keeping all three lattice operations highlyefficient.andP;  This technique takes into account idiosyncrasies of the topologyof the poset being encoded that are quite likely to occur in practice.andP;  Allmethods are formally justified.andP;  We see this work as an original contributiontowards using semantic (viz., in this case, taxonomic) information in theengineering pragmatics of storage and retrieval of (viz., partially orquasi-ordered) information.andM;For Correspondence: H. Ait-Kaci, DEC/Paris Research Laboratory, 85 AvenueVictor Hugo, 92563 Rueil Malmaison Cedex, France; P. Lincoln, ComputerScience Department, Stanford University, Stanford, CA 94305; R. Nasr, MCC,ACA Program, 3500 West Balcones Center Drive, Austin TX 78759; R. Boyer,Department of Computer Sciences, University of Texas, Austin, TX 78712.andM;Verifying Temporal Properties without Temporal LogicandM;An approach to proving temporal properties of concurrent programs that doesnot use temporal logic as na inference system is presented.andP;   The approach isbased on using Buchi automata to specify properties.andP;  To show that a programsatisfies a given property, proof obligations  are derived from the Buchiautomata specifying that property.andP;  These obligations are discharged bydevising suitable invariant assertions and variant functions for the program.andO;The approach is shown to be sound and relatively complete.andP;  A mutualexclusion protocol illustrates  its application.andM;For Correspondence: B. Alpern, IBM T. J. Watson Research Center, P.O. Box218, Yorktown Heights, NY 10598; and F. B. Schneider, Department of ComputerScience, Cornell University, Ithaca, NY 14853.andM;Journal of the Association for Computing Machinery  January 1989andM;Incremental Modular DecompositionandM;Modular decomposition is a form of graph decomposition that has beendiscovered independently by researchers in graph theory, game theory, networktheory, and other areas.andP;  This paper reduces the time needed to find themodular decomposition of a graph from [omega](n.sup.3.) to[omicron](n.sup.2.).andP;  Together with a new algorithm for transitiveorientation given in [21], this leads to fast new algorithms for a number ofproblems in graph recognition and isomorphism, including recognition ofcomparability graphs and permutation graphs.andP;  The new algorithm works byinserting each vertex successively into the decomposition tree, using[omicron](n) time to insert each vertex.andM;For Correspondence: J. H. Muller, Department of Computer Science, Universityof Toronto, Ont., Canada M5S 1A1; J. Spinrad, Department of Computer Science,Vanderbilt University, Nashville, TN 37235.andM;A Unified Framework for Race Analysis of AsynchronousandM;NetworksandM;A unified framework is developed for the study of asynchronous circuits ofboth gate and MOS type.andP;  A basic network model consisting of a directed graphand a set of vertex excitation functions is introduced.andP;  A race analysismodel, using three values (0, 1, and X), is developed for studying statetransitions in the network.andP;  It is shown that the results obtained using thismodel are equivalent to those using ternary simulation.andP;  It is also provedthat the set of state variables can be reduced to a minimum size set offeedback variables, and the analysis still  yields both the correct statetransitions and output hazard information.andP;  Finally, it is shown how thegeneral results above are applicable to both gate and MOS circuits.andM;For Correspondence: J. A. Brzozowski, Department of Computer Science,University of Waterloo, Waterloo, Ontario, Canada N2L 3G1; C-J.andP;  Seger,Computer Science Department, Carnegie-Mellon University, Pittsburgh, PA15213.andM;Maintaining State Constraints in Relational Databases: A ProofandM;Theoretic BasisandM;If a relational database is required to satisfy a set of integrityconstraints, then when the database is updated, one must ensure that itcontinues to satisfy the constraints.andP;  It is desirable not to have toevaluate each constraint after each update.andP;  A method is described that takesa constraint C and a class of updates, and either proves that an update inthe class cannot violate C, or produces a formula C' (a complete test) thatis satisfied before the update if and only if C would continue to besatisfied were the update to occur.andP;  C' is frequently much easier to evaluatethan C. In addition, a formula D (a sufficient test) is sometimes producedsuch that if D is satisfied before the update, then C would continue to  besatisfied were the update to occur.andP;  The method is proved correct.andP;  Themethod is substantially more general than other reported techniques for thisproblem.andP;  The method has been implemented, and a number of experiments withthe implementation are presented.andM;For Correspondence: W. W. McCune, Mathematics and Computer Science Division,Argonne National Laboratory, Argonne, IL 60439-4801 and L. J. Henschen,Department of Electrical Engineering and  Computer Science, NorthwesternUniversity, Evanston, IL 60201.andM;Minimizing Function-Free Recursive Inference RulesandM;Recursive inference rules arise in recursive definitions in logic programmingsystems and in database systems with recursive query languages.andP;  Let D be arecursive definition of a relation t. D is considered minimal if for anypredicate p in a recursive rule in D, p must appear in a recursive rule inany definition of t.andP;  It is shown that testing for minimality is, in general,undecidable.andP;  However, an efficient algorithm for a useful class of recursiverules is presented, and it is used to transform a recursive definition to aminimal recursive definition.andP;  Evaluating the minimized definition avoidsredundant computation without the overhead of caching intermediate resultsand run-time checking for duplicate goals.andM;For Correspondence: Department of Computer Science, Princeton University, 87Prospect Avenue, Princeton, NJ 08540.andM;A Common Schema for Dynamic Programming and Branch andandM;Bound AlgorithmsandM;A new model for dynamic programming and branch and bound algorithms ispresented.andP;  The model views these algorithms as utilizing computationallyfeasible dominance relations to infer the orderings of application objects,thereby implicitly enumerating a finite solution space.andP;   The formalism isbroad enough to apply the computational strategies of dynamic programming andbranch and bound to problems with non-associative objects, and can model bothoblivious and nonoblivious algorithms, as well as parallel algorithms.andP;  Themodel is used to classify computations based, in part, on the types ofcomputationally  feasible dominances that they employ.andP;  It is demonstratedthat the model is computationally precise enough to support the derivation oflower bounds on the number of operations required to solve various types  ofproblems.andM;For Correspondence: Department of Computer Science, University of New Mexico,Albuquerque, NM 87131.andM;Inferring Sequences Produced by Pseudo-Random NumberandM;GeneratorsandM;In this paper, efficient algorithms are given for inferring sequencesproduced by certain pseudo-random number generators.andP;  The generatorsconsidered are all of the form X.sub.n = [sigma].sup.k/.sub.j=1.andO;[alpha].sub.j.[phi].sub.j.(X.sub.0, X.sub.1, .andP;  .  .  , X.sub.n-1.) (mod m).andO;In each case, we assume that the functions [phi].sub.j are known andpolynomial time computable, but that the coefficients [alpha].sub.j and themodulus m are unknown.andP;  Using this general method, specific examples ofgenerators having this form, the linear congruential method, linearcongruences with n terms in the recurrence, and quadratic congruences areshown to be cryptographically insecure.andM;For Correspondence: Department of Computer Science, University of Chicago,Chicago, IL 60637.andM;Multiplicative Complexity of Polynomial Multiplication over FiniteandM;FieldsandM;Let M.sub.q.(n) denote the number of multiplications required to compute thecoefficients of the product of two polynomials of degree n over a q-elementfield by means of bilinear algorithms.andP;  It is shown that M.sub.q.(n) [isgreater than or =] 3n - o(n).andP;  In particular, if q/2 andless; n [is less than of =]q + 1, we establish the tight bound M.sub.q.(n) = 3n + 1 - [q/2].andP;  Thetechnique we use can be applied  to analysis of algorithms for multiplicationof polynomials modulo a polynomial as well.andM;For Correspondence: Department of Computer Science, Technicon--IsraelInstitute of Technology, Haifa 32000, Israel.andM;Calculating Availability and Performability Measures ofandM;Repairable Computer Systems Using RandomizationandM;Repairable computer systems are considered, the availability behavior ofwhich can be modeled as a homogeneous Markov process.andP;  The randomizationmethod is used to calculate various measures over a finite observation periodrelated to availability modeling of these systems.andP;  These measures includethe distribution of the number of events of a certain type, the distributionof the length of time in a set of states, and the probability of anear-coincident fault.andP;  The method is then extended to calculateperformability distributions.andP;  The method relies on coloring subintervals ofthe finite observation period based on the  particular application, and thencalculating the measure of interest using  these colored intervals.andM;For Correspondence: E. de Souza e Silva, Federal University of Rio deJaneiro, NCE, Rio de Janeiro, Brazil; H. R. Gail, IBM Thomas J. WatsonResearch Center, Yorktown Heights, NY 10598.andM;Calculating Joint Queue-Length Distributions in Product-FormandM;Queuing NetworksandM;A new computational algorithm called distribution analysis by chain (DAC) isdeveloped.andP;  This algorithm computes joint queue-length distributions forproduct-form queuing networks with single-server fixed rate, infinite server,and queue-dependent service centers.andP;  Joint distributions are essential inproblems such as the calculation of availability measures using queuingnetwork models.andP;  The algorithm is efficient since the cost to evaluate jointqueue-length probabilities is of the same order as the number of theseprobabilities.andP;  This contrasts with the cost of evaluating theseprobabilities using previous algorithms.andP;  The DAC algorithm also computesmean queue lengths and throughputs more efficiently than the recentlyproposed RECAL and MVAC algorithms.andP;  Furthermore, the algorithm isnumerically stable and its recursion is surprisingly simple.andM;For Correspondence: E. de Souza e Silva, Federal University of Rio deJaneiro, NCE, Rio de Janeiro, Brazil; S. S. Lavenberg, IBM Research Division,T. J. Watson Research Center, P.O. Box 704, Yorktown heights, New York 10598.andM;ACM Transactions on Office Information Systems  July 1988andM;VAGUE: A User Interface to Relational Databases that PermitsandM;Vague QueriesandM;A specific query establishes a rigid qualification and is concerned only withdata that match it precisely.andP;  A vague query establishes a targetqualification and is concerned also with data that are close to this target.andO;Most conventional database systems cannot handle vague queries directly,forcing their users to retry specific queries repeatedly with minormodifications until they match data that are satisfactory.andP;  This articledescribes a system called VAGUE that can handle vague queries directly.andP;  Theprincipal concept behind VAGUE is its extension to the relational data modelwith data metrics, which are definitions of distances between values of thesame domain.andP;  A problem with implementing data distances is that differentusers may have different interpretations for the notion of distance.andP;  VAGUEincorporates several features that enable it to adapt itself to theindividual views and priorities of its users.andM;For Correspondence: Computer Science Department, University of SouthernCalifornia, University Park, Los Angeles, CA 90089-0782.andM;Knowledge-Based Tools to Promote Shared Goals andandM;Terminology Between Interface DesignersandM;Two tools that support cooperation are described: one for the construction ofconsistent and principled human-computer interfaces and the other for theconstruction of AI knowledge bases.andP;  These tools provide a central repositoryfor design knowledge that otherwise would not be easily shared among users.andO;The AI knowledge representation technology upon which the tools are foundedis first described.andP;  A knowledge-based approach to interface construction isdiscussed, and how that approach applies to detecting design conflicts andinconsistencies stemming from two different kinds of team communicationfailure is illustrated.andP;  Next, a knowledge acquisition aid that is utilizedwithin the interface construction paradigm and that also illustrates the sameapproach to supporting cooperative work is described.andP;  Finally, four sourcesof difficulty in team design efforts, which this approach seeks to address,are reviewed.andM;For Correspondence: University of Southern California, Information SciencesInstitute, 4676 Admiralty Way, Marina del Rey, CA 90292.andM;A Rule-Based Message Filtering SystemandM;Much computerized support for knowledge workers has consisted of tools tohandle low-level functions such as distribution, storage, and retrieval ofinformation.andP;  However, the higher level processes of making decisions andtaking actions with respect to this information have not been supported tothe same degree.andP;  This paper describes the ISCREEN prototype system forscreening text messages.andP;  ISCREEN includes a high-level interface for usersto define rules, a component that screens text messages, and a conflictdetection component that examines rules for inconsistencies.andP;  An explanationcomponent uses text generation to answer user queries about past ot potentialsystem actions based on Grice's conversational maxims.andM;For Correspondence: Bell-Northern Research, 522 University Ave., Toronto,Ontario, Canada, M5G 1W7.andM;Access to, Usage of, and Outcomes from anandM;Electronic Messaging SystemandM;This study examines relationships among perceived accessibility to anelectronic messaging system (EMS), computer-monitored and reported usage ofthe system by approximately 100 employees of one division  of an aerospacefirm, user's job type, perceived appropriateness of the EMS, and reportedoutcomes such as changes in effectiveness and use of paper-based media.andO;Greater accessibility resulted in more usage and reported increases ineffectiveness.andP;  Physical distance to a terminal affects the associations ofother aspects of accessibility with usage and  has a greater influence onthese associates earlier in one's adoption process.andP;  Differences in job typeshowed statistically significant associations with usage, independent of theinfluence of accessibility.andP;  Computer-monitored and reported usage measureswere only moderately correlated and were differentially associated with theaccess measures and with the two outcomes.andP;  The article ends by discussingimplications for implementation and evaluation of computer-basedcommunication systems, theories of media characteristics and informationvalue, and methodological issues in using computer-monitored usage data.andM;For Correspondence: R. E. Rice, School of Communication, Library andInformation Science, Rutgers University, New Brunswick, NJ 08903,roaa120@uscmvsa.bitnet; D. E. Shook, Advanced Computing Systems, Universityof Southern California, Los Angeles, CA 90089, soaa040@uscmvsa.bitnet.andM;Wireless Intraoffice NetworksandM;An overview of the existing and growing demands for wireless officeinformation networks is provided, and the existing research activities areassessed in some detail.andP;  The radio frequency (RF) and infrared (IR)communication technologies are examined as candidates for wirelessintraoffice communications.andP;  The available bandwidths, according to federalregulations and characteristics of the channels for RF communications, aregive.andP;  Digital narrow-band and wideband spread-spectrum RF communications areassessed in terms of supportable data rate or number of simultaneous users inone cell of a cellular architecture in an office environment.andP;  Variouslimitations of IR communications are discussed and existing systems andarchitectures are reviewed.andM;For Correspondence: Worcester Polytechnic Institute, 100 Institute Rd.,andO;Worcester, MA 01609.andM;ACM Computing Surveys  December 1988andM;Survey of Software Tools for Evaluating Reliability, Availability,andM;and ServiceabilityandM;In computer design, it is essential to know the effectiveness of differentdesign options in improving performance and dependability.andP;  Various softwaetools have been created to evaluate these parameters, applying both analyticand simulation techniques, and this paper reviews  those related primarily toreliability, availability, and serviceability.andP;  The purpose, type of modelsused, type of systems modeled, inputs, and outputs are given for eachpackage.andP;  Examples of some of the key modeling elements such as Markovchains, fault trees, and Petri nets discussed.andP;  The information is compiledto facilitate recognition of similarities and differences between variousmodels and tools and can be used to aid in selecting models and tools for aparticular application or designing tools for future needs.andP;  Tools includedin the evaluation are CARE-III, ARIES-82, SAVE, MARK1, HARP, SHARPE, GRAMP,SURF, SURE, ASSIST, METASAN, METFAC, ARM, and SUPER.andP;  Modeling tools, such asREL70, RELCOMP, CARE, CARSRA, and CAST, that were forerunners to some of thecurrent tools are noted for their contributions.andP;  Modeling elements that havegained widespread use for general systems, as well as fault-tolerant systems,are included.andP;  Tools capable of modeling both repairable and nonrepairablesystems, accepting constant or time varying failure rates, and predictingreliability, availability, and serviceability parameters are surveyed.andM;For Correspondence: Allen M. Johnson, Jr., IBM, Advanced Engineering Systems,Austin, Texas 78758; Miroslaw Malek, Department of Electrical and ComputerEngineering, University of Texas at Austin, Austin, Texas 78712.andM;Hierarchical Representations of Collections of Small RectanglesandM;A tutorial survey is presented of hierarchical data structures forrepresenting collections of small rectangles.andP;  Rectangles are often used asan approximation of shapes for which they serve as the minimum rectilinearenclosing object.andP;  They arise in applications in cartography as well as verylarge-scale integration (VLSI) design rule checking.andP;  The different datastructures are discussed in terms of how they support the execution ofqueries involving proximity relations.andP;  The focus is on intersection andsubset queries.andP;  Several types of representations are described.andP;  Some aredesigned for use with the plane-sweep paradigm, which works well for staticcollections of rectangles.andP;  Others are oriented toward dynamic collections.andO;In this case, one representation reduces each rectangle to a point in ahigher multidimensional space and treats the problem as one involving pointdata.andP;  The other representation is area based--that is, it depends on thephysical extent of each rectangle.andM;For Correspondence: Computer Science Department, Center for AutomationResearch, and Institute foe Advanced Computer Studies, University ofMaryland, College Park, Maryland 20742.andM;ACM Transactions on Graphics  October 1988andM;A Window-Based Graphics Frame Store ArchitectureandM;A proposal for a scalable frame store architecture for a hardware-basedwindow graphics system is described.andP;  The architecture is based on adistributed linear array of common elements called microframe stores.andP;  Eachwindow and viewpoint can be independently configured in size and color depth.andO;Unlike the strip-based hardware window systems referenced, this system placesno restrictions on the number of transitions that can be accomodated on eachscanline.andP;  The approach described allows real-time window graphics to beachieved on a variety of full-color, high-resolution, high-refresh-rate,raster-scan displays with pixel rates of up to 400 MHz.andM;For Correspondence: National Semiconductor, 2900 Semiconductor Drive, MS16-181, Santa Clara, CA 95052-8090.andM;Color Gamut Mapping and the Printing of Digital Color ImagesandM;Principles and techniques useful for calibrated color reproduction aredefined.andP;  These results are derived from a project to take digital imagesdesigned on a variety of different color monitors and accurately reproducethem in a journal using digital offset printing.andP;  Most of the images printedwere reproduced without access to the image as viewed in its original form;the color specification was derived entirely from colorimetric specification.andO;The techniques described here are not specific to offset printing and can beapplied equally well to other digital color devices.andM;The reproduction system described is calibrated using CIE tristimulus values.andO;An image is represented as a set of three-dimensional points, and the coloroutput device as a three-dimensional solid surrounding the set of allreproducible colors for that device, called its gamut.andP;  The shapes of themonitor and the printer gamuts are very different, so it is necessary totransform the image points to fit into the destination gamut, a process wecall gamut mapping.andP;  This paper describes the principles that control gamutmapping.andP;  Included also are some details on monitor and  printer calibration,and a brief description of how digital halftone screens for offset printingare prepared.andM;For Correspondence: M. C. Stone, Computer Science Laboratory, Xerox Palo AltoResearch Center, 3333 Coyote Hill Road, Palo Alto, CA 94304; W.B.andP;  Cowan,National Research Council of Canada, Ottawa, Ontario Canada; current address:J. C. Beatty, Computer Science, University of Waterloo, Waterloo, Ontario,N2L 3G1 Canada.andO;</TEXT></DOC>