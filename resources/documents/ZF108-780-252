<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-780-252  </DOCNO><DOCID>08 780 252.andM;</DOCID><JOURNAL>Dr. Dobb's Journal  Sept 1990 v15 n9 p16(12)* Full Text COPYRIGHT Mandamp;T Publishing 1990.andM;</JOURNAL><TITLE>Making the move to Modula-2.andO;</TITLE><AUTHOR>Auping, J.V.; Johnston, J.C.andM;</AUTHOR><SUMMARY>A decision to standardize on using Modula-2 for softwareprogramming has proven successful.andP;  Modula-2 is very suitable formultiprogrammer projects.andP;  The language's modular structurepermits the programmer to write reusable code.andP;  Modula-2 allowsprogrammers to retain their own coding styles, habits, and senseof ownership without hindering the collaboration necessary on amultiprogrammer project.andP;  Writing and testing functions arestreamlined by Modula-2's modular setup; it is easy to isolate andgroup similar procedures.andP;  Error handling, however, is a problem.andO;Modula-2 is case sensitive, but this is not a burden after therules are learned.andP;  One annoyance is that Modula-2 does not haveget and put statements as Pascal does.andM;</SUMMARY><DESCRIPT>Topic:     Programming LanguagesProgrammingModular ProgrammingModula-2.andO;Feature:   illustrationtablechart.andO;Caption:   Library functions. (table)Sample output from our data-plotting program. (chart)andM;</DESCRIPT><TEXT>Three years ago, we had occasion to upgrade a group of small scientificcomputers used for laboratory data acquisition.andP;  We chose to standardize allof our new software efforts and use Modula-2.andP;  In this article, we'll talkabout why we chose Modula-2 and about the benefits and drawbacks of thelanguage.andM;As support programmers for a materials research laboratory, we are involvedin writing application programs that perform control functions and acquiredata from special-purpose experimental furnaces.andP;  There are about a dozensuch furnaces for controlled heating and cooling of metals and alloys and forcrystal growth activities.andP;  Each furnace had been initially equipped with adata acquisition and control system made up of a small desktop computer thatwas programmable in Basic and an IEEE-488-based data acquisition unit.andP;  Asour researchers came up with more complex experiments, we were limited by thespeed and memory capacity (32K words of user space) of the desktop computers.andM;In addition, as the researchers became familiar with the capabilities of thePC systems appearing in their offices, they grew dissatisfied with the smalldisplay and slow tape drives of the data acquisition computers.andP;  The decisionwas made to replace the old computers with faster, larger, PC-type systems.andO;We had been quite satisfied with the capabilities of the data acquisitionunits, and also had invested significant amounts of time in the wiring ofthermocouples and other transducers.andP;  We were determined to keep them withwhatever new systems we developed.andP;  This put some constraints on our choiceof hardware.andM;After a survey of the available computers, we settled on an 80286-basedAT-compatible system with a 40-Mbyte hard disk and EGA display.andP;  We alsochose an IEEE-488 interface card that promised code to support most of thepopular programming languages.andP;  Since we had been dissatisfied with thecryptic nature of even our own most carefully written Basic code, we werepleased to have the chance to move to a more satisfactory programminglanguage.andP;  This was an important decision for us, because we wanted tostandardize on one language throughout the lab.andP;  As the different furnaceshave many functions in common, we wanted to be able to share code.andM;Looking at LanguagesandM;The first language we considered was Pascal, as one of us had hadconsiderable experience with it prior to this project.andP;  After trying to applyPascal to our experiments, we decided we liked the strong typing andstructured design of the language, but were concerned that it would be unableto support a joint programming effort.andP;  We had been intrigued by literature(1,2) that described Modula-2 as a language designed for team programming.andO;Its similarity to Pascal was convenient, and it seemed well-suited to jointprojects that required low-level access to the computer hardware.andP;  So, wedecided to test a Modula-2 development system.andM;We were particularly interested in and wanted to evaluate a number offeatures described in the articles on Modula-2:andM;*  The modular structure, which would allow two or more programmers to workin a controlled manner and permit code interaction without unforeseen sideeffects.andM;*  Transparent access to the low-level facilities of the machine withoutdisturbing the rest of the program.andM;*  Increase in program reliability because of built-in type checking.andM;*  The idea of creating independent modules that can be used in otherprograms.andM;A number of things looked as if they would be real (if minor) annoyances:andM;*  The issue of case sensitivity.andP;  All of Modula-2's identifiers are casesensitive, and reserved words are required to be uppercase.andM;*  Modula-2's inability to do I/O on complex types (records and arrays, forinstance) directly, without byte counting.andM;*  The relative scarcity of commercial software libraries available forModula-2.andM;After installing the Modula-2 development system and writing a few short testprograms, we were sufficiently encouraged to embark on a fairly major&quot;learning project.&quot; We looked around for something that would be a goodmultiprogrammer test project and that would be useful to us later if wedecided to standardize on Modula-2.andP;  At that time, nearly all of ourexperiments were already running on the smaller computers, generating datathat required plotting.andP;  Our researchers had also begun clamoring for theability to view their data graphically while an experiment was in progress.andO;To evaluate Modula-2's ability to solve our problems we decided to implementa library of screen and plotter graphing routines for our data acquisitionand control programs.andM;Developing Modula-2 LibrariesandM;The first step in developing our library was to determine exactly whatcapabilities it would provide.andP;  We were pleased with the plotting functionsavailable in the Basic ROMs in our small computers, and we decided to includemany of these functions but improve on the calling syntax.andP;  This gave us abase set of &quot;high-level&quot; procedures that would have to be implemented.andP;  Thesewould be the only procedures invoked directly by an applications programmerusing the library.andP;  We defined a number of other functions that would beneeded either as additions to the base set or as lower-level functionsrequired to implement the base calls.andM;Once we had an idea of what we had to write, we needed to break the projectinto two more or less equal pieces.andP;  Based on our examination of theprocedures we had already identified, the project seemed to divide naturallybetween the low-level hardware manipulation functions and the higher-levelgraphing calls.andP;  The procedure for drawing an axis doesn't need to know abouthow the lines are drawn or that drawing lines on the display and the plotterare handled differently.andP;  on the other hand, the line drawing proceduredoesn't need to know what is being drawn.andP;  Table 1 lists the low-levelhardware manipulation and high-level plotting functions.andP;  Although it maylook like an unequal division of labor, most of the low-level function callscontain separate code for each plotting device included in the system; so thelow-level section required more lines of code.andM;In Modula-2, all modules except for the main program module have two parts: Adefinition module that formally defines what procedures and variables areavailable, and an implementation module where the executable code to performthose functions resides.andP;  The definition module for the high-level plottingfunctions, ModPlot, is shown in Listing One, page 76, and the module for thelow-level functions GDriver is shown in Listing Two [omitted].andP;  We alsocreated the module DataDefs to hold all of the global types.andP;  By definingcolor types, device types, and so forth, we are able to use statements suchas SetBackgroundColor(Blue) or SetPlotDevice (EGA) rather than a crypticnumerical code.andP;  The price we pay for this increased program readability isthat the relevant types must be explicitly imported from DataDefs into everyother module using those types.andP;  Note that DataDefs is an example of aModula-2 definition module with an empty implementation module.andP;  It allows usto define a number of types and variables to be imported whenever necessarybut contains no executable code; its only function is to define thevariables.andM;In our case, determining which of us would do what part of the project waseasy.andP;  The division into high-level (user-related) and low-level(hardware-related) functions matched our interests fairly well.andP;  But we stillhad to decide how to pass information from one part to the other and how tohandle range checking and error reporting.andP;  Since we already had the DataDefsmodule for defining global types, we decided to use it to also hold a set ofglobal variables that would contain the current settings for the graphicsparameters.andP;  This would reduce the number of formal arguments needed to passinformation.andP;  We decided to do all of the checking for the validity of datain the high-level procedures.andP;  The procedures in GDriver trust that they arebeing passed legal pixel coordinates by the code that calls them.andM;Part of the idea behind Modula-2 is that it allows programmers to define aninterface between modules that is stable and isolates one module fromanother.andP;  In theory you should think deep thoughts about the interface (thedefinition module), define it, and never change it again.andP;  In our experience,reality was only a little different.andP;  Both the high-level ModPlot definitionmodule and the low-level GDriver definition module were remarkably stableonce we had thought about them for a while.andP;  GDriver did require oneaddition, the CleanUp procedure, unforeseen in the original design.andP;  (Thecleanup procedure was needed because of the way one of the compiler-suppliedlibrary modules managed the interrupt system.andP;  Another compiler might handlethings differently, making the additional procedure unnecessary.) We made afew minor changes to the types of the arguments in some of the ModPlotprocedure calls.andP;  The DataDefs module, however, an importantbehind-the-scenes part of the interface, was a lot more fluid.andM;The actual process of implementing our library was straightforward.andP;  We spenttwo weeks defining and partitioning the functions.andP;  We then went our separateways to do the coding and some independent testing of the sections.andO;Obviously, as in any hierarchically divided project, it was more satisfyingto test the low-level modules.andP;  Testing of the high-level ModPlot functionswas limited to producing textual output such as &quot;Call to DrawAbs made withthe following arguments .andP;  .  .  &quot;, whereas the testing of the low-levelprocedures generated pretty pictures right from the start.andP;  On the otherhand, when the low-level modules malfunctioned they were harder to debug, asthe errors usually were not obvious and sometimes were catastrophic.andP;  Afterabout a month of separate coding and testing, we were able to link the twosections together in a test program.andP;  We spent a relatively short time usingtest programs to debug the library.andP;  The whole project took about two months(four man months) from start to finish.andM;Listing Four, and Figure 1 [omitted] show the source code and output of aprogram, Example, which demonstrates the use of the ModPlot library.andP;  Notethat Example imports types from DataDefs that do not explicitly appear invariable declarations, but do have instances appearing in the code.andP;  Forexample, SizeType must be imported because Small is used in the statementSetCharSize(Small).andM;Team Programming and Modula-2andM;Of course, the big question is, how did the use of Modula-2 affect theprocess of writing a team-programming project? Our feeling is that themodular nature of the language streamlined the process of writing and testingeach function.andP;  Granted, this could be done with any &quot;good&quot; structuredlanguage, but the formal, definition module/implementation module structuremade it particularly easy to isolate and group similar procedures.andM;Comparison with our past experience shows that the strict typing of Pascal orModula-2 eliminates the source of a lot of errors that creep into Basic orFortran programs.andP;  In comparing Pascal to Modula-2, it is more difficult tosee a great difference.andP;  The tendency (in well-written programs, at least)for Modula-2 programs to be broken into many small parts makes the isolationand elimination of errors easier than in Pascal and makes Modula-2 code morereliable from the outset than Pascal or C code.andP;  We have, of course, foundoccasional bugs in our library during the past year and a half.andP;  Almost allof these, however, have been due either to errors in logic or to timingproblems caused by moving to machines with different clock speeds.andM;The reusability of modules is an important part of the rationale behindModula-2.andP;  Once you write and debug a module you can put it in your libraryand use it whenever you need that function again.andP;  A problem arises inmodules that import information from other modules.andP;  GDriver imports a modulecalled HdwDefs.andP;  That means that GDriver can't be used in another programunless HdwDefs is available too.andP;  We have found that the most easily reusablemodules are often the lowest-level ones that perform one simple, clearlyfocused function.andP;  Reusability of more complicated modules must be plannedfor in the original design of the code because you need to minimize thenumber of dependencies.andM;On the other hand, GDriver is a general-purpose drawing and labeling moduleavailable for any program needing it.andP;  This approach is preferable to writingthe same functions again the next time they are needed.andP;  in a broader sense,this was the purpose of the entire plotting package.andP;  It provides a simpleinterface for a programmer who needs to add some simple graphing functions toa program.andP;  As a byproduct of its creation we now have a number of modulesthat we can use anytime.andM;The issue of transparent access to low-level facilities was also important tous.andP;  Some of the functions that we require in our experiments involve the useof boards that plug into the AT bus.andP;  Many of these require special softwareto access their registers and onboard memory.andP;  Modula-2 has enabled us to dothat quite successfully.andP;  Some of these devices use interface code that iswholly or partially written in assembly language but is called from a Modulaprogram as if it were any other module.andP;  Modula-2 can access individualmemory locations and I/O ports, allowing the programmer to do much of thismanipulation without resorting to assembler.andP;  It is, however, a good idea toisolate any such extremely machine-dependent code in its own module.andM;Error handling has been and continues to be more of a problem.andP;  If anexternal error occurs deep in a nested set of procedures, there is no easyway of invoking some error-handling procedure unless an error flag is testedeach step of the way back.andP;  For example, if the plotter goes off-line duringa plot (someone inadvertently turns it off or the paper-load lever is moved),the transmission code deep in the low-level routines will eventually timeout, generating a serial error.andP;  The error is posted in a variable inDataDefs along with a string explaining the problem.andP;  There is no way toguarantee that the calling program will notice this condition unless theerror flag is checked after every call to GDriver.andP;  This means that everycall to DrawAbs, MoveAbs, or DrawString in GDriver has to be checked, and therest of the calling routine short-circuited, returning an error indication tothe external calling program.andP;  This issue has not been resolved to oursatisfaction.andP;  our working solution has been to have the low-level code thatdiscovers the error Post a message to a reserved area on the display screenexplaining the problem and giving the user a chance to fix it.andM;The Upside and Downside of Modula-2andM;One unanticipated benefit of Modula-2 has been that it allows us to maintainour own coding styles and habits and a sense of ownership of our own codewithout impeding the collaboration necessary to make a project like thiswork.andP;  (As you may have gathered, we have not progressed to the point of&quot;egoless&quot; programming.andP;  We are, at best, pursuing &quot;ego-reduced&quot; programming.)andO;For example, one of us likes the indented structure:andM;IF SomeCondition THENandM;DoThis;andM;ThenThat;andM;ELSEandM;DoSomethingElse;andM;END  (* if *);andM;while the other prefers:andM;IF SomeConditionandM;THENandM;DoThis;andM;ThenThat;andM;ELSE DoSomethingElse;andM;END  (* if *);andM;The fact that we can each write and maintain our own code in separate modulesmeans that neither has to put up with the other's unspeakably ugly IF-THENstyle.andM;We expected that the language's case sensitivity would turn out to be anannoyance.andP;  Instead, we have found that once you are used to the rules itisn't a burden at all, especially if you use a syntax-assisted editor.andP;  Infact, we have both grown to like the fact that reserved words are all incaps.andP;  Using normal capitalization for variable and procedure names allowsyou to quickly pick them out from the reserved words in the code.andP;  Casesensitivity forces you to clean up the variable names so they all matchexactly.andP;  In Pascal, case insensitivity allows you to put off cleaning up thecode to make it prettier.andP;  Modula-2's case sensitivity does have a drawbackin that it makes some new errors possible, It is legal to declare a localvariable with the same name as a global variable.andP;  No changes can be made tothe global variable inside the procedure where the local variable isdeclared, protecting the global from unforeseen side effects.andP;  However, ifyou miscapitalize the declaration of the local you can inadvertently changethe global.andP;  This situation actually occurred in some code a student wrotefor us, and it took quite a while for us to help him locate the problem.andM;A real annoyance with Modula-2 is that it has no equivalent for Pascal's getand put statements, which allow a program to automatically handle I/O oncomplex data structures such as records.andP;  In order to write a record variablein Modula-2, a program has to calculate the size of the record and then writethat number of bytes.andP;  Presumably, this is in keeping with the philosophythat all I/O in Modula-2 would be through a procedure specific to the datatype involved.andP;  it would be nice if there were a more automatic way to dothis.andP;  The random access I/O of data to/from disk files has the same kind oflimitation, also probably for the same reason.andP;  It seems that the compilercould do this for you.andM;Another drawback of using Modula-2 becomes evident if you are writing a shortprogram from which you want quick results.andP;  There is some significantoverhead in typing in the numerous FROM SomeLibrary IMPORT SomeProcedure;statements necessary to do any useful task.andP;  For a while, we both returned toTurbo Pascal when we had to do something quickly.andP;  Eventually, as we becamemore involved with Modula-2, we evolved template main program modules thatcontain the imports (such as WriteLn, WriteString, Assign, Concat, and soforth) that we typically use in our work.andP;  However, there are still thefrustrating times when you discover at compile time that you've forgotten toimport one or more of the procedures you need.andM;The scarcity of commercially available software libraries for Modula-2 wasnot an insurmountable problem for us.andP;  We invested about six months inwriting our own utility routines, including both a program to producestraightforward scientific plots and a useful set of generic field editingroutines.andP;  We have also successfully used packages designed to be called fromother languages, with more or less trouble depending on what memory model thelibrary uses.andP;  One image-processing library written to be called fromMicrosoft Pascal required an assembly language interface module to rearrangethe stack so that the arguments were passed correctly.andP;  (3)andM;ConclusionsandM;After extensive use, we have both become rather fanatical about Modula-2 andhave standardized on it for all new development in the lab.andP;  We have hiredundergraduate and graduate students for summer jobs who were able to learnthe language quickly and produce modules for us in reasonably short periodsof time.andP;  We have certainly met resistance from programmers unfamiliar withModula-2, but we have adhered to our decision to maintain a single language.andM;In short, we feel that Modula-2 has delivered on its promise to be verysuitable for multiprogrammer projects.andP;  Its modular structure has allowed usto write efficient, reusable code that can be used in a variety ofapplications.andP;  At this point, we're looking forward to more support, bothcommercial and user group.andM;REFERENCESandM;1.andP;  &quot;Modula II, An Overview - Excerpts From A Talk By Niklaus Wirth,&quot; MicroCornucopia (Aug/Sept 1985), 25.andM;2.andP;  N. Wirth, &quot;History and Goals of Modula-2,&quot; BYTE (August 1984),145.andM;3.andP;  C. Johnston, &quot;Modula-2 in the Mainstream,&quot; Computer Language (June,1989), p.71.andM;NASA does not endorse commercial products.andP;  Details about any products namedin this article were included for completeness and accuracy.andP;  No endorsementor criticism of these products by NASA should be assumed.andP;  The source codefor the entire package is available from the authors upon request.andM;Low-level Hardware Manipulation FunctionsandM;Determine what graphics devices are availableandM;Move the active position to the specified device coordinatesandM;Draw from the active position to the specified device coordinatesandM;Draw a label stringandM;Clear the video screen and set to text, graphics, or menu (noandM;cursor) modeandM;High-level Plotting FunctionsandM;Initialize the graphics functionsandM;Choose a plotting device for subsequent outputandM;Set plotting boundariesandM;Set boundaries for a scaled areaandM;Set the scale for the scaled areaandM;Set the type of plotting unitsandM;Set the size of characters for subsequent labelsandM;Set the angle for subsequent labelsandM;Set the line type for subsequent draw commandsandM;Set the pen colorandM;Set the background colorandM;Set the label orientation relative to the active positionandM;Set the number of digits to the right of the decimal pointandM;Return the ratio of the physical dimensions of the plotting areaandM;of the current deviceandM;Set the character font to be used in subsequent labelsandM;Draw a line from the active position to the specified coordinatesandM;Move to the specified coordinatesandM;Do an incremental draw from the active positionandM;Do an incremental move from the active positionandM;Draw an X-axis with tic marksandM;Draw a Y-axis with tic marksandM;Draw a set of X-Y axes with tic marksandM;Draw an X-Y gridandM;Draw a label at the active position according to the currentandM;character size, label orientation, and label angle settingsandM;Draw a set of X-Y axes with tic marks, labelled according to theandM;current character size and fixed decimal settingsandM;Draw an X-Y grid, labelled according to the current characterandM;size and fixed decimal settingsandM;Draw a box around the current plotting areaandM;Draw a symbol of specified size and type at the active positionandM;Return the coordinates of the active positionandM;Clear the screen and set the modeandM;Judy Auping and Chris Johnston work in the Microgravity Materials ScienceLaboratory at NASA's Lewis Research Center in Cleveland.andP;  They both boldPh.D.s in chemistry from Cleveland State University.andP;  Chris Johnston's book,The Microcomputer Builder's Bible, was published by Tab Books in 1983.andP;  Theycan be reached at 216-433-5016 and 216-433-5029, respectively.andO;</TEXT></DOC>