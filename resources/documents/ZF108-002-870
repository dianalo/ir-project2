<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-002-870  </DOCNO><DOCID>08 002 870.andM;</DOCID><JOURNAL>AI Expert  Jan 1990 v5 n1 p40(8)* Full Text COPYRIGHT Miller Freeman Publications 1990.andM;</JOURNAL><TITLE>Domain-specific shells for experts in PROLOG.andO;(artificial-intelligence programming) (tutorial)</TITLE><AUTHOR>Knaus, Rodger; Blecker, Herb.andM;</AUTHOR><SUMMARY>Techniques for building domain-specific shells in PROLOG expertsystems are discussed.andP;  Shell building and knowledge acquisitionare generally separate but partly equivalent; choosing a high-endshell with a flexible knowledge language avoids the frustrationsof rigid knowledge languages, but these shells are complex.andO;Custom shells provide the flexibility needed for a specific systemwithout the overhead needed to control unnecessary features.andP;  Acustom shell developed for ICARUS Corp's engineering activities isdescribed.andP;  It includes a natural knowledge language and aknowledge-acquisition system designed for engineering users.andO;Building a custom parser involves selecting grammars, implementinga knowledge compiler, and adding error messages to definite clausegrammars.andP;  The system's inference engine is fairly standard.andO;Shells are likely to become specialized tools in the future.andM;</SUMMARY><DESCRIPT>Topic:     Artificial IntelligenceExpert SystemsKnowledge-Based SystemsTutorialProgramming InstructionPROLOG.andO;Feature:   illustrationprogram.andO;Caption:   Project contingency rules. (program)Knowledge base syntax. (program)Parsing a frame. (program)andM;</DESCRIPT><TEXT>Domain-Specific Shells FOR EXPERTS INandM;Writing your own shell for expert-system development is the road lesstraveled for a good reason: it passes through a programming swamp.andP;  Mostmanagers choose the commercial-shell path through the forest of knowledgeaquisition, where you have to see the trees (rules, objects, and so on)instead of the forest (the expert's knowledge).andP;  However, ICARUS ServicesLtd. determined that improved knowledge acquisition and control of the expertsystem justified building a custom shell.andP;  Maybe you should build one, too.andM;WHEN TO CUSTOMIZEandM;Imagine that we want to build an expert system for musicians -- a compositionadvisor, for example.andP;  An important feature of this application is that mostmusicians would want to customize their own knowledge bases of rhythms,melodies, harmonic progressions, and voicing rules to make the expert systemcompose in their personal style.andP;  In other words, users are also experts inthe field who &quot;knowledge engineer&quot; a personal knowledge base expressing aunique perspective and insight into the application.andM;If we gave the musician a general-purpose shell, it would be possible (butvery difficult) to put musical knowledge into the system.andP;  A special-purposemusic shell featuring patterns as musical scores or in MIDI notation would bemuch easier to use; a shell that can read in knowledge played on a pianokeyboard and output its results in a synthesizer would be even better.andM;Providing a shell with these special features is difficult but notimpossible.andP;  Even so, during the system's lifecycle, the accumulated timesaved by using the system is worth many times its development cost becausemany musicians would use the system and for each musician, enriching theknowledge base is a continuing activity.andM;More generally, shell building and knowledge acqusition are separate butpartially equivalent activities.andP;  You can pay up front and build a shell witha knowledge language suited to the natural form in which experts already havetheir knowledge.andP;  This speeds knowledge acquisition and improves the qualityof the resulting knowledge base -- but at the expense of building a customshell.andP;  Alternatively, you can use an existing standard shell and save theeffort and expense of building one.andP;  However, you pay later when the experthas to translate and restructure their knowledge into the shell's requiredform.andP;  This translation is often difficult, because many knowledge languagesare rigid and limited (without else or or, for example), forcing experts topulverize their knowledge into unnaturally small pieces.andM;Another approach avoids the frustration of a rigid knowledge language bychoosing a high-end shell with a rich and flexible one.andP;  However, powerunavoidably complicates language; the high-end shell languages are at leastas complex as programming languages.andP;  (To become proficient in writing inthese complex languages, most high-end shell vendors recommend a trainingclass.)andP;  These languages must be complex because they control tools andfeatures powerful enough to solve various complicated problems.andP;  But anysingle problem usually requires only a subset of these tools; that subsetcould be controlled with a simpler custom language.andP;  The additionalcomplexity needed to control unnecessary features is overhead that reoccurswith each knowledge base you write.andM;With this background, let's analyze the &quot;custom-shell or standard-shell&quot;decision.andP;  Suppose we are building an expert system whose knowledge basecontains some pieces of expert knowledge; we'll call them Knowledge_items.andO;For a standard shell we'll call the average cost of entering each piece intothe knowledge base Standard_item_cost; Custom_item_cost is the average costof putting a piece into a custom shell.andP;  In addition, both standard andcustom shells have start-up costs: training for the standard shell andprogramming for the custom shell.andP;  As a first approximation for the twoexpert-system strategies, Table 1 shows the production costs.andM;Subtracting equation 2 from equation 1 (Table 1) gives the cost differencebetween using custom and standard shells, shown in equation 3.andP;  Now let's useequation 3 to see when to build a custom shell.andP;  Here are some estimates forprogramming and training based on our experience:andM;* Programming time: Using some of the techniques we'll discuss later, you canbuild a custom shell in about six person-months -- less if your job is simpleor you're experienced in AI programming, more if your job is complex and it'syour first AI project.andM;* Training: For both strategies the expert needs some training for writingknowledge bases.andP;  If the custom shell did its job, the training is minimalfor the custom shell.andP;  Training for a standard one is probably several daysto several weeks, depending on the computer sophistication of the domainexpert and the shell's complexity.andM;Now let's see what equation 3 says about some knowledge-engineeringsituations:andM;* Good fit with standard shell: if a standard shell's knowledge language fitsthe form of your expert's knowledge, Custom_item_cost -- Standard_item_costis small and you probably won't write enough rules to save the programmingcost of a custom shell.andP;  Use a standard shell in this case.andM;* Expert has trouble with standard representations: in this case a customshell may save a day per knowledge item, and pays for itself after only 100items.andP;  In some cases, the Standard_item_cost essentially goes to infinity,making the custom shell the only alternative.andP;  This event occurs when theexpert finds the standard knowledge representation so unsuitable, tedious, ordifficult that they can't or won't provide enough knowledge to the system tomake it work.andP;  Consider a custom shell in this case.andM;* Professional users: Some expert systems are designed for professionals touse in their practice.andP;  These users often want to build or tailor their ownknowledge base; they need an easy-to-use shell rather than a black-box expertsystem or a complicated shell requiring a knowledge-engineering background.andO;Moreover, professional users typically continue to refine their knowledgebases.andP;  This enlarges the number of Knowledge_items in equation 3;Knowledge_items = 10,000, for example, if 100 professional users each write100 rules.andP;  In this case (not extreme in either number of users or items peruser), saving five minutes per knowledge item with a custom shell pays fordevelopment.andP;  For professional users, the minimal training and start-up timefor using a well-tailored custom shell is an additional savings and maydetermine whether a busy professional ever uses an expert system.andP;  For userswho continually improve their knowledge base, a custom shell fitting theirexact requirements is usually a savings in the long run.andM;THE ICARUS PROBLEMandM;ICARUS Services Ltd. and its U.S.andP;  affiliate ICARUS Corp. develop and marketcomputer-aided design and estimating systems for process industries.andP;  Thesesystems prepare detailed design and cost data from relatively brief userinput and are used in more than 350 locations worldwide to assist companiesin the chemical, petrochemical, oil, pharmaceutical, food, and miningindustries in their evaluation of capital projects.andM;In addition to the technical support ICARUS provides, we wanted to make 20years of experience in the design and estimation of processing facilitiesavailable to our customers.andP;  We decided to do this by putting our expertisein the knowledge base of an expert system.andP;  It is important to ICARUS thatcustomers be able to read and modify the knowledge base so they can customizethe computer-aided design and estimating systems to their corporation'srequirements.andM;After studying customer needs and the available AI technology, ICARUSdeveloped the following technical and business specifications for its expertsystem:andM;* The syntax of the knowledge base must be intuitive and learnable in a fewminutes by a nontechnical, PC-literate user.andP;  This point was critical sincewe anticipate many occasional users (engineers working on the early stages ofproject evaluation, for example).andM;* The shell must be multilingual.andM;* It must be portable to the hardware platforms on which ICARUS markets itssystems.andM;* The user should not need documentation to query the system's knowledgebase, and an expert should need only minimal documentation to build one.andP;  Thesystem must inform the user of its current status and provide instructions atevery point of use.andM;* No training should be needed for either the user or the expert building aknowledge base.andM;* The knowledge language should allow mathematical formulas in reasoning andfinal solutions.andP;  ICARUS required this capability since it expects most usersto be engineers, whose knowledge is represented as mathematical formulas andpropositional logic statements used in most shells.andM;* No run-time royalties.andP;  ICARUS did not want to enter into a royaltyrelationship with another vendor.andM;ICARUS was unable to satisfy these requirements in a single off-the-shelfshell.andM;THE KNOWLEDGE LANGUAGEandM;In designing the shell, we developed a knowledge language natural for ICARUS'engineering knowledge bases.andP;  Some example rules in this language appear inListing 1; they are drawn from a knowledge base that estimates projectcontingency.andP;  For our knowledge domain, project contingency is the percentageof construction costs to be placed in a reserve fund for unexpected costs.andO;The knowledge base contains expertise to determine a reasonable value to usefor project contingency.andP;  (For example, the expected future inflation rate,the status of the economy and the contractor's work backlog can affect theproject contingency.)andM;The second rule in Listing 1 combines the inputs from factors affectingproject contingency; the first finds the detailed information about a singlefactor, future inflation rate.andP;  Rule 2 computes contingency as a weightedaverage.andP;  For example, suppose contingency depended only on future inflationrate and contract type (end of rule 2), the future inflation rate is fivepercent, and the contract type is fixed price.andP;  The rules assign acontingency value of 10% and a weight of 90 to future inflation rate, and acontingency value of 10 and a weight of 100 to the contract type.andP;  Theoverall contingency is:andM;(20 * 90% + 10 * 100%) / (90 + 100) = 14.73andM;These rules let the engineer specify the choices for each variable in acompact form, the contingency value and weight of each choice, and aconfidence factor for the result.andP;  A general-purpose shell cannot possiblyprovide such a compact rule syntax for this specialized need.andM;KNOWLEDGE ACQUISITIONandM;Our primary justification for a custom shell is that it speeds knowledgeacquisition, so let's examine the facilities we've added to help build aknowledge base.andP;  Many of these features don't depend on AI and don't affectthe shell's inference engine or the semantic scope of the knowledge language,but do help the user learn and use the system faster.andM;Our users are engineers.andP;  They may not have a lot of computer expertise, butthey generally know how to use a word processor.andP;  Many of them routinelyprepare ASCII files as source programs for a FORTRAN compiler or as data foran application program.andP;  Therefore, we designed the ICARUS Expert to acceptknowledge bases as ASCII text files you can create with your favorite wordprocessor (you shouldn't have to learn a new piece of software to create aknowledge base).andP;  For users who are not already addicted to a particular wordprocessor, we included an intuitive what-you-see-is-what-you-get text editorwith functions similar to the IBM Personal Editor II.andP;  The functions areuser-assignable to keys, so users can adapt the editor to their keyboard,typing style, and key assignments of their favorite word processor.andP;  Finally,we included a syntax checker for the knowledge-base language.andM;We used the slot_name:  slot_value frames notation as a unifying syntacticprinciple in designing a knowledge language, illustrated by a small butcomplete example knowledge base in Listing 2.andP;  The topic :information-about-it notation is one that many people already use on occasionin informal notes and outlines.andP;  Since the order of slots doesn't matter,frame notation frees the user from remembering a required order forknowledge-base information.andM;When necessary, we've used this same frame-slot notation in rules andquestions.andP;  (For example, when they have associated help text or procedures.)andO;We suppressed brackets around the frames and commas between slots in a frameto give the knowledge base the appearance of notes jotted down for personaluse.andP;  By using different slot names for knowledge-base parts (introduction,hypothesis, rule, question) and rule parts (proven, questions, help), theparser can determine where frames begin and end, and how frame parts shouldbe nested.andM;Within a single rule, we have suppressed slot names to make the notation moreconcise.andP;  The rule conclusion is followed by a confidence factor, conditionsthat should be true already (if any) and conditions that must be satisfied.andO;The conditions are Boolean expressions.andP;  Each expression contains a groundclause that describes the proposition or numerical variable for which a valueis sought, a list of acceptable values, the confidence factor or value foraveraging each value, and in rules which perform weighed averages, thevalue's weight.andM;Herb Blecker developed this syntax because he could quickly write down hisexpertise using it.andP;  Other engineers who saw sample knowledge bases he wrotestarted changing them immediately -- a sign that the notation was easy forits target group to understand.andP;  The knowledge language worked for itsintended experts because an expert in the field designed the language byfinding something that worked using paper and pencil.andM;When the experts are ready to compile a knowledge base, we want them to getas much help finding errors (there usually are some initially) as possible.andO;To provide information during compilation about possible problems as theknowledge compiler finds them, we display a continually updated scoreboard(Figure 1).andP;  With a familiar knowledge base, this high-level information issometimes enough to point out the problem.andM;At the same time, the ICARUS Expert writes detailed error information to afile (Listing 3).andP;  Each of these error messages points to the line and columnof the error and contains a general explanation of the type of error.andP;  Inaddition, we frequently include a little tutorial about the point in questionas part of the error message, so users have all the information they need tomake corrections just from looking at the error message.andP;  The user can viewthis tutorial error message in one window of the ICARUS Expert editor whilefixing the knowledge base in the other.andP;  Since we also want theknowledge-base author to discover all the syntax errors in as few runs aspossible, we used a heuristic compiler that determines the scope of anyreasonably large constituent and then parses it in detail.andP;  No matter howmany errors occur in the constituent, the parser can continue error checkingin the next constituent.andM;COMPILER IMPLEMENTATIONandM;We implemented the knowledge compiler in PROLOG and used definite clausegrammars (DCGs) extensively.andP;  This implementation technique keeps programmingtime at a minimum and produces a compiler that is easy to maintain andextend.andP;  The DCG-based compiler takes 15 seconds to compile the contingencyknowledge base containing 223 lines, five rules, and 16 questions (partiallyshown in Listing 1); once compiled, it takes less than a second to load aknowledge base.andM;As an informal comparison showing just how much DCGs speed up writing acompiler or interpreter, one of the authors worked with several grad studentsfor most of a year -- at least six person-months -- to build ascreen-oriented Pascal interpreter in Pascal.andP;  Using DCGs, Richard Holsager,a professor at American University, wrote a one-page interpreter for a subsetof Pascal in a couple of hours.andP;  Allowing time to write the screenhandling,we estimate that by using DCGs, we could complete the six-month project inone to two weeks, about a 15-to-one savings.andP;  DCGs make it possible to builda knowledge language you like with an investment you can afford.andM;DCGs are Backus-Nauer (BNF) grammars with variables added to the syntax forthe semantic structures found by the grammar.andP;  If you can describe what youwant in a BNF grammar, you can read it into the computer with a DCG, and youcan build the DCG from the BNF in an almost mechanical way.andP;  Forillustration, let's write a DCG to read a parenthesized list of confidencefactors.andP;  The first step is to write a BNF (Listing 4).andP;  Then we addvariables to hold the structure each BNF nonterminal recognizes, producing aDCG (Listing 5).andM;In translating from the BNF to the DCG, we have used the following rules(constituents occur in corresponding places in both BNF and DCG rules):andM;* Break alternatives (s) in the BNF into separate DCG rules, putting therules in the same order as the alternatives.andM;* Add a variable to each BNF term for what it recognizes, if you need thatconstituent for later processing.andP;  Since we want the lists of confidencefactors, we added a variable to the cf_list and cf rules; since we don't careabout saving the punctuation, we left their nonterminals alone.andM;* Add a cut (!) whenever you know you are in the right rule; for example, ifwe find a confidence factor, we know we want to recurse on cf_list, so we puta cut there.andM;* Use PROLOG patterns and possibly some inline code to build the output of arule from output of the constituents; put PROLOG code in curly brackets.andM;The third step in building your custom parser is to elaborate the basic DCGto include error messages.andP;  To do so you often have to break the existingrules into a sequence of rules, each of which calls its own error message ifit doesn't find the expected input.andP;  Listing 4 shows the parser code similarto ICARUS Expert's and corresponding to the grammars in Listing 5.andP;  Whilethis restructuring is tedious, it's not difficult, and the resulting parseroutputs an error message tailored to the particular error in the user'sknowledge base.andM;As we mentioned earlier, we want the compiler to recover enough from errorsto continue looking for other errors later on.andP;  For this reason, we've mixedthe DCG's default form of parsing -- recursive descent, which works strictlyleft to right, top down, and quits if it finds an error -- with preliminarylook-ahead analysis.andP;  One procedure we use extensively to implement thislook-ahead is frame_parse (Listing 6).andP;  To Build a frame, frame_parse firstfinds the part of the input that ought to contain the value of a slot, thentries to build the value, writes out error information if necessary, andcontinues with the compilation.andM;One of the inputs to frame_parse is the name of a procedure that reads in thevalue of a frame slot.andP;  frame_parse's helper item_parse calls this passed-inprocedure, passing to it the name of the slot it's supposed to fill.andP;  Thiseffectively partitions the DCG for the information in the frame as a whole(for example, a knowledge base) into a lot of independent DCGs, one for eachslot in the frame, making the DCG easier to maintain.andM;We use frames as an external notation for the user and also as a flexibleinternal knowledge representation.andP;  The source and internal representationsof a Mycin-like rule are shown in Listing 7.andP;  (For a discussion of how to useframes in PROLOG, see Expert's Toolbox, AI EXPERT, Mar. 1989, pp.andP;  19-24 andMay 1989, pp.andP;  19-24).andM;THE INFERENCE ENGINEandM;The inference engine for ICARUS Expert is a standard Mycin-like one.andP;  TheExpert's Toolbox column in this issue shows you how to build a simplifiedinference engine of this kind.andP;  Figure 2 shows a typical screen where theinference engine asks the user a question.andP;  The default mode of the inferenceengine is backward chaining, but since rules can have entry conditions andattached procedures, the user can program in forward-chained actions withouthaving to know any expert system jargon.andM;Since our system is for engineers, rules can conclude numbers as well aslogical propositions.andP;  Rules and questions can also have attached procedures,to help the engineer perform calculations as the expert system runs.andO;Together, these features let an engineer write a computation with nestedheuristics.andP;  At each level, the expert system determines which formula isappropriate and calls on more specialized expert systems to estimate thenumbers needed in that formula.andP;  We implement the various specialist systemsas separate knowledge bases similar to that for contingency.andM;As the inference engine runs, it accumulates facts consisting of the itemlearned, (current inflation rate), its value (five percent), the confidencelevel (90%), and the source of the information (either the user or a rule) inthe knowledge base.andP;  The expert system uses this information to explain itsreasoning and saves it in a decision log (Figure 3).andP;  This decision logsummarizes a consultation with the expert system in a form you can edit intoa report for management.andM;When interactive programs like expert systems become production tools, theycause terminal tedium, as the user enters similar problems interactively.andO;Our shell eliminates this tedium with a batch mode: it can read in a decisionlog and begin a consultation with this information.andP;  To run a variant of aprevious problem, the user edits an old decision log and resubmits it toICARUS Expert.andM;SHELL TRENDSandM;We hypothesized that we could do some of the work of knowledge acquisitiononce and for all with a custom shell.andP;  Our work with the shell has confirmedthis strategy, because ICARUS can concentrate on the content rather than theform of its knowledge bases.andM;Our experience suggests that we may see more special-purpose expert-systemshells.andP;  A similar trend has occurred in an older software genre, wordprocessors.andP;  During the first years word processors were on the market,almost all were general-purpose, intended for anyone who had to manipulatetext and produce documents.andP;  Now, however, specialized shells have beencreated for scholars, scientists, writers, and lawyers -- groups withoverlapping but not identical text-processing needs.andP;  As expert systemsmature as a software genre, we expect to see specialized tools for thespecialized knowledge representation needs of professionals.andM;Some of these tools will be shells.andP;  However, the experience with our shell-- we can modify its features by changing some code and recompiling --suggests another tool class for building specialized shells: libraries ofcallable expert-system functions.andP;  Engineers write special-purpose numericalcalculations by calling on library routines to invert matricies, solvedifferential equations, and perform similar tasks that are difficult toprogram well.andP;  These libraries are a collection of interchangeable numericalprogram parts that the application developer can assemble as needed.andP;  With asimilar library of expert-system routines -- inference engines, knowledgecompiler-compilers, and general-purpose explanation facilities -- a knowledgeengineer could write a customized expert system by writing a littlehigh-level code, mostly just procedure calls.andM;A shell written in this way is a computer program, so it's fairly easy tointegrate into an existing computational environment without the frustrationof extensive custom programming; in fact, one of the reasons that ICARUSprogrammed a shell was to facilitate this integration.andP;  As expert systemmature and standards for knowledge representation emerge, we will see morecallable expert system libraries and specialized shells.andO;</TEXT></DOC>