<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-234-057  </DOCNO><DOCID>07 234 057.andM;</DOCID><JOURNAL>Microsoft Systems Journal  Jan 1989 v4 n1 p11(30)* Full Text COPYRIGHT The Microsoft Corporation 1989.andM;</JOURNAL><TITLE>Porting Apple Macintosh applications to the Microsoft Windowsenvironment.andO;</TITLE><AUTHOR>Schulman, Andrew; Valdes, Ray.andO;AttFile:   MSJ\V04N01\BADHELLO.EXE;2 Program:  BADHELLO.EXE  MAC to windows.andO;MSJ\V04N01\GENAPP.ARC;2 Program:  GENAPP.ARC  MAC to windows.andO;MSJ\V04N01\HELLO.EXE;2 Program:  HELLO.EXE  MAC to windows.andM;</AUTHOR><SUMMARY>Microsoft Windows presents a viable avenue for Macintoshprogrammers to port their applications.andP;  The Windows environment-- which is incorporated into Presentation Manager -- has becomethe standard windowing environment within the PC market.andO;Macintosh applications can expand their usage by taking advantageof the large market for PCs.andP;  The transition for Macintoshprogrammers into the Windows environment is actually easier thantraditional DOS programmers who are working with Windows for thefirst time.andP;  Windows shares a lot of procedures and structure withthe Macintosh interface on the surface.andP;  However, there aredistinct differences in detail.andP;  The article details the processof porting a graphics package from the Macintosh to Windows.andM;</SUMMARY><DESCRIPT>Ticker:    MSFT.andO;Product:   Microsoft Windows (Graphical user interface) (usage).andO;Topic:     Graphical User InterfaceSoftware MigrationProgramming.andO;Feature:   illustrationprogram.andO;Caption:   Code fragments from stop mac.c. (program)Take one of Windows version. (program)Portable version of stop sign. (program)andM;</DESCRIPT><TEXT>Porting Apple Macintosh Applications to the Microsoft Windows EnvironmentandM;You're happy with your Macintosh program.andP;  It cooperates with other programsunder MultiFinder, it runs like the wind in color on the Mac II, and evenyour customers with Mac 512Ks are fairly happy with the program.andP;  Yourdevelopment goes smoothly using the Lightspeed C compiler and TMON debuggerand, though you wish Lightspeed's editor weren't so simplistic, you've puttogether some dynamite EMACS macros using Quickeys.andP;  You wish you had C++,but Apple is coming out with MPW C++ soon.andP;  And you've got to love that MacII.andM;Why then would you want to port your program to the PC, Windows, and the OS/2Presentation Manager (hereafter referred to as PM)?andM;A Wider WorldandM;Windows has become a de facto standard for graphical windowed software in theIBM world, as evidenced by its incorporation into the IBM OS/2 PresentationManager.andM;Windows can be your entree to the larger world of the Graphical UserInterface (GUI) standard.andP;  Not only is Windows on the path to OS/2Presentation Manager, and from there to the promise of SAA, but the Windowsprogramming model is much closer to that of X Windows than is the Mac's.andM;There's another sense in which porting to Windows will widen yourperspective.andP;  Not only is the PC software market significantly larger thanthe Mac market, but there is a much wider range of hardware.andP;  Right now, Macsoftware only runs on screens with square pixels.andP;  Windows is fairlydevice-independent so that, if you port to Windows, your software will runeven on screens and printers wit pixel ratios like 12:5, 1.43:1, and 1.37:1.andO;You may think such screen ratios odd, and we would agree with you, but theseghastly monitors represent the majority of the real world.andM;Working with WindowsandM;If you're a Macintosh programmer who needs to learn how to program forWindows, there is some good news and some bad news.andM;The good news is that everything you know is not wrong.andP;  You already know thecentral ideas behind Windows programming: event-driven input; text is justanother form of graphics output; relocatable memory; and resources.andM;Ironically, a Mac programmer who has never sat down at an IBM PC is in abetter position to learn Windows than a seasoned DOS programmer who has notyet gone through the infamous &quot;everything you know is wrong&quot; learning curve.andO;If you know Mac programming, then under Windows much of what you know isstill true.andM;A Mac programmer has already learned that application code is inert andpassive, and simply waits to be activated by a data structure (called anEventRecord on the Mac and an MSG under Windows).andP;  A C programmer on the Machas probably said good-bye to old friends like printf and gets and, sureenough, you won't use these for Windows programs either.andP;  Relocatable memoryblocks?andP;  Mac programmers handle these routinely, so the fact that Windowsmoves memory around is not an issue.andP;  Your Mac knowledge can be leveraged inprogramming for a market with millions of IBM and IBM-compatible computers.andM;After you've worked with the application program interfaces (API) of severalgraphical windowed environments, you begin to realize how similar they are.andO;There are many strong resemblances between the Macintosh Toolbox and theWindows API, even some one-to-one correspondences.andP;  Take the functionPtInRect: how could determining whether a given point falls within a givenrectangle not be the same in all systems?andM;Everything Is DifferentandM;There are many other formal analogies.andP;  For example, the Macintosh memorymanager provides a function, NewHandle, which returns a handle to a block ofrelocatable memory, and the Windows kernel provides GlobalAlloc which, whencalled with the GMEM_MOVEABLE flag, also returns a HANDLE to a block ofrelocatable memory.andM;A Windows HANDLE sounds just like a Macintosh Handle.andP;  There are many suchseeming similarities between the Mac and Windows.andP;  Believe it or not, that isthe bad news.andP;  While the Mac, Windows, and Presentation Manager are in someformal sense identical and after a while feel all the same, it's the littlesubtle differences that matter when you're porting code.andP;  Although they areconceptually identical, when you get to the details, a Windows HANDLE isalmost nothing like a Macintosh Handle.andM;Here are further illustrations of the same point: Windows regions are not atall like regions on the Mac; the Windows function FindWindow has nothing todo with the Mac function FindWindow; the Windows equivalent for the Macfunction FrameRect is the function Rectangle and not the function FrameRect.andM;In this article, we will first port a tiny fragment of Mac graphics code toWindows, illustrating the similarities and differences between Mac'sQuickDraw and Windows' graphical device interface (GDI), and we will show oneapproach to portable code that takes advantage of the similarities, whileisolating you from the differences.andP;  We then present a complete applicationthat shows a unified approach to Macintosh and Windows events, windows, andmemory management.andP;  A PC port is not only desirable, but possible, asportable code is both desirable and possible.andM;The Update EventandM;Kernighan and Ritchie in The C Programming Language, (Prentice Hall, 1988),2nd edition, p.andP;  5 say, &quot;The only way to learn a new programming language isby writing programs in it,&quot; but probably the only way to learn a new windowedgraphical environment's API is by writing parts of programs in it.andP;  Even&quot;Hello World&quot; in such an environment typically involves more code than anewcomer can be expected to type, especially on a new machine using anunfamiliar editor.andM;One of the more bizarre (until you get used to it) features of GUIenvironments actually comes to our rescue in the form of redrawing oldoutput.andP;  Whether on the Mac or Windows, your program must be prepared toreproduce its output at any time.andP;  The reason for this is that the window towhich you send your output (text or graphics) may get damaged.andM;When this happens, the Mac sends your application an updateEvt, and Windowssends the damaged window a WM_PAINT message.andP;  On the Mac one responds to anupdateEvt by bracketing QuickDraw calls between a BeginUpdate and anEndUpdate and, similarly, in Windows the response to a WM_PAINT message is tosandwich GDI calls between a BeginPaint and an EndPaint.andP;  So you can see thatprogramming for Windows won't be that unfamiliar.andM;Since your application must be prepared to meet an update event by redrawingthe window's contents, an application can confine all of its drawing to thisone place.andM;Let's begin by writing some code that will get called whenever our windowreceives a WM_PAINT message.andP;  What we propose to do is take the HELLO&quot;application&quot; (it's actually more of a skeleton) from the Windows SoftwareDevelopment Kit (SDK), remove the call to the function HelloPaint, replace itwith some Mac code, and alter the Mac code into something that will compileand run on the PC.andP;  We will start with as little alteration as possible, thengradually work up to full Windows code, writing a real version that runsunder both systems.andM;The Mac code found in the function StopSign illustrates QuickDraw's MoveTo,Move, and Line functions, and is loosely borrowed from Stephen Chernicoff'ssuperb book Macintosh Revealed (Hayden Books, 1987), 2nd edition, Vol.andP;  I,pp.andP;  189-191.andP;  The code appears in Figure 1, along with bits of surroundingcontext, so you can see how the function StopSign would get called on theMac.andP;  The function scales the stop sign to the size of the window into whichit's being drawn.andP;  If you resize the window, you not only generate amouseDown inGrow; you also generate an updateEvt that causes the stop sign tobe rescaled and redrawn to the new window dimensions.andM;The Hard PartandM;A Mac programmer who wants to put this Mac code into a Windows program facesone hurdle that has nothing to do with the code itself: you have to set upthe SDK and the C compiler on your PC/AT or 386 machine, you need a texteditor, and you'll soon want a set of tools like grep and diff.andM;Note that Windows/386 lets you perform tasks from within the graphicalwindowed environment (see Figure 2), whereas Windows/286 makes you edit andcompile in character mode, just dropping into Windows long enough to test theresulting program.andP;  Integrated programming environments such as QuickCcompiler and Turbo C unfortunately will not generate code for Windows.andM;If you're used to the &quot;double-click and you're done&quot; simplicity of installingsoftware on the Mac, then installing tools like C 5.1 and the Windows SDK onyour 286 or 386 is going to be more difficult.andP;  All we can tell you is, onceyou can compile HELLO.EXE from the SDK, then writing code is going to seemeasy.andM;Take OneandM;Figure 3 shows our first take at a Windows equivalent.andP;  While we could getthe exact same Mac code to run on a PC by emulating a GrafPort and a set offunctions to manipulate it, we've already worked on such a project and theresulting performance was unacceptably slow.andP;  Instead we're using &quot;native&quot;Windows code, while trying to preserve as much of the feel of the Mac aspossible.andM;The only parameter the Macintosh version of StopSign needs is a WindowPtr,which comes along with the updateEvt in event.message.andP;  Because WindowPtr isjust another name for GrafPtr, StopSign uses this single parameter to getboth the portRect into which to scale the stop sign, and the GrafPort whereoutput calls are directed.andM;In the Windows version, notice that we pass in two parameters: an HWND and anHDC.andP;  An HWND is a handle to a window and an HDC is a handle to a DeviceContext (DC), which is a data structure maintained by Windows that, like aGrafPort, maintains graphics states such as the current pen, clipping region,current position, font, and so on.andM;While the Mac keeps a very close association between a window and a GrafPort(in fact, a WindowRecord is a GrafPort, with some extra fields stuck on theend), under Windows an HWND often has only an HDC associated with it whilethe application is servicing a WM_PAINT message.andP;  One of the most importanttasks of BeginPaint is to give an HDC to an HWND that's received a WM_PAINT.andO;While the pairs BeginUpdate/EndUpdate and BeginPaint/EndPaint aresyntactically nearly identical, each serves a little different purpose.andM;The &quot;Magic Cookie&quot;andM;From the code in Figures 1 and 3 we can see that, where the Mac version grabsthe dimensions of the window's content region by directly peeking atport-andgt;portRect, under Windows we use the API function GetClientRect.andP;  TheportRect and the client rect are conceptually similar, except the Macinconveniently includes scroll bars as part of the portRect and we have tocompensate for them.andM;A more important difference, though, is that under Windows we made a functioncall to get at something that is simply a field in a data structure on theMac.andP;  This is a key philosophical difference between the Mac and Windows: Macprograms directly manipulate the fields of a GrafPort (for example,thePort-andgt;info) while Windows programs have no knowledge of the internalstructure of a DC or of nearly any other Windows data structure, and have touse function calls to find things out (for example, GetInfo(hDC)).andM;However, don't we have a Handle to a DC?andP;  No, we have a HANDLE.andP;  A WindowsHANDLE is not a pointer to a pointer (**hThing is the thing itself) like aMacintosh Handle; it is a &quot;magic cookie.&quot;andP;  In the call GetClientRect(hWnd,andamp;r), hWnd is the &quot;magic cookie&quot;: we pass it in, and when the functionreturns, r contains our information.andP;  We don't know where in the WND datastructure the client rect is kept, and we need not; GetClientRect is a blackbox.andP;  In complete contrast, thePort-andgt;portRect is more like Pandora's box.andO;The Windows API is not perfect, and in some areas it is inferior to theMacintosh Toolbox; but for data abstraction Windows wins hands down.andM;In other words, the Windows API has a function-call interface (narrowchannels of communication between your program and the environment); theMacintosh approach of working directly with the data structures andlow-memory globals approach works well right now, but the channel is too wideto constitute an interface.andM;Being ExplicitandM;One of the most noticeable differences between the Mac code in Figure 1 andthe Windows code in Figure 3 is that, on the Mac a line may be drawn withLine(8 * scale, 0), while in the Windows version we say Line(hDC, 8 * scale,0).andM;That one little hDC parameter is quite important.andP;  Whereas QuickDraw callsoperate implicitly on thePort, and therefore establish the current port withSetPort (squirreling away a pointer to the previous port so that it can berestored at a later time), every GDI call takes an HDC as an explicitparameter.andM;This passing around of hDC from function to function as though it were a hotpotato will seem tedious for tiny applications with only one window and onlyone DC but, for real applications with multiple windows, it can result incleaner code than the frequent GetPort/SetPorts one often sees in Mac code.andM;The Fleeting GrafPortandM;To establish a border of 5 units on all four sides of the stop sign, bothversions reduce the size of the drawing area by 10 units and shift its originsoutheast by 5 units.andP;  On the Mac, this is done with SetOrigin.andP;  The previousorigin is saved so that, when we finish, we can restore things to the way wefound them.andM;Under Windows we could use SetViewportOrg, but using OffsetViewportOrg seemedmore suitable, since then we don't need to know what the previous origin was.andO;Why viewport?andP;  We'll get back to that when we discuss our second version ofthe stop sign.andM;A more important point is that in this case it is not absolutely necessary toundo the OffsetViewportOrg at the end of the Windows version.andP;  Remember thatan HDC is not tied tightly to a Windows window as a GrafPort is to a Macwindow.andP;  Each time BeginPaint is called, we get a fresh DC.andP;  Any alterationswe made to a DC, such as altering the origin or selecting a different pen orfont, disappear after calling EndPaint.andP;  This means that, if you're about tocall EndPaint anyway, you may be able to avoid undoing some changes; but italso means that you have to set up what you need each time you callBeginPaint.andM;Many Mac programs will have a hard time with this fleeting GrafPort, becausethey assume they can ask at any time about, say, GrafPtr-andgt;pnLoc.andP;  When theseprograms are ported to Windows, the assumption is that at any time you cancall, say, GetCurrentPosition(hDC), not realizing that you often don't havean HDC.andM;There is a way for a Windows program to give each of its windows a DC thatpersists even after you've called EndPaint and for which EndPaint is, infact, a NOP.andP;  When you establish a window class during the initialization ofa Windows program, you can specify its style as CS_OWNDC.andP;  All Windowscreated with this class then have their own DC.andM;Don't do this!andP;  However tempting it is for ported Mac code to use CS_OWNDC,don't succumb to this temptation.andP;  Using CS_OWNDC results in a lot ofunnecessary window invalidation and generally causes problems in the form ofweird repainting bugs.andM;Emulating Toolbox CallsandM;Returning to the code in Figure 3, note that we had to write our own Line andMove functions.andP;  Where the Mac has LineTo, MoveTo, Line, and Move, Windowshas only LineTo and MoveTo.andP;  Here we get into one strategy for portable code:rather than rewriting StopSign so it uses only LineTo and MoveTo, we wroteour own Line and Move for Windows.andM;For simple functions like these, emulating the Toolbox under Windows workswell.andP;  While MoveTo moves the current position to an absolute location in thecurrent GrafPort (on the Mac) or the designated HDC (under Windows), Moveoffsets the pen relative to its current position.andP;  To write a Windows versionof Move, we need to know the current position.andP;  GetCurrentPosition returns(x,y) packed into an unsigned long; the individual components are broken outusing the LOWORD and HIWORD macros from windows.h.andP;  Always use these macrosto extract such packed information.andP;  Never write your own code to do so.andM;While we're supplying these Mac-like routines, it is useful to make thembehave as much like other Windows functions as possible.andP;  Although we neveruse the return value, we pass it along.andP;  And for consistency's sake we usethe FAR PASCAL modifiers.andP;  Both the Macintosh Toolbox and the Windows API usethe Pascal calling convention, but for different reasons.andP;  FAR is somethingthat we'll explain later, when we talk about memory.andM;There's one other change to make: adding stop.c to the Hello make file.andO;While editing the make file, add the -W2 switch to the compiler command lineso that you get adequate warnings from the C compiler.andM;To compile the code, all you have to type is MAKE HELLO.andP;  All sorts ofinscrutable compiler switches will fly by on the screen.andP;  If all goes well,make will also run the linker and the RC resource compiler.andM;We've been focusing on the changes to the Mac code in Figure 1 to turn itinto the Windows code in Figure 3, but the two versions are actually similar.andO;Both use the same formula to compute the scale by which all coordinates aremultiplied.andP;  The scale is divided by 18 because that's the largest unit ofmeasurement in the sequence of MoveTo/Line/Move calls.andM;A PC is Not a MacandM;It's time to run our modified HELLO.EXE.andP;  If you're developing underWindows/386, you can just double-click on HELLO.EXE.andP;  If you're usingWindows/286, first you'll have to go into Windows.andP;  Either way, you start upthe new application and ...andP;  it's awful! Unless you're running on a VGA or amonitor with square pixels, the stop sign is horribly elongated.andP;  It'sparticularly nasty on a CGA (see Figure 4).andP;  The stop sign resizes itselfnicely enough when we resize the window (so at least GetClientRect is workingfor us), but the shape remains distorted.andM;Here we discover that a PC, even a PC running Windows, is not a Mac.andP;  Macshave screens with square pixels, and more and more PCs (and all PS/2machines) come with square-pixel monitors, while Windows programs have to runon a variety of monitors, good, bad, and ugly (otherwise known as VGA, EGA,and CGA).andP;  Windows programs can make fewer assumptions than Mac programs.andM;For a guide to the world of PC graphics adapters, see Richard Wilton'sProgrammer's Guide to PC andamp; PS/2 Video Systems (Microsoft Press, 1987).andO;Microsoft Windows will shield you from having to know whether you're runningin 640 x 480 or 640 x 200--if you let it.andM;The stop sign is elongated because we're using Windows' default mapping mode,MM_TEXT, in which units of measurement, such as the ones we use in ourMoveTo/Move/Line calls, represent pixels on the screen.andP;  This results ingraphical output that depends on the display being used, but it is closest tothe arrangement on the Mac--where all the coordinates represent pixels on thescreen, 72 to the inch, and where there is a good match between printers andmonitors.andM;This presents a problem: using the default MM_TEXT mapping mode may be theeasiest way to port Mac code to Windows, because Mac programs assume that aunit is a pixel and they do their own scaling.andP;  But bear in mind that squareswill only look square on a VGA.andP;  Using the closest analogies between twosystems does not always produce good results, so beware of using MM_TEXT forgraphics.andP;  The units-are-pixels arrangement just happens to works well onmonitors with square pixels by coincidence.andP;  This is why your developmenthardware should include at least one CGA monitor.andP;  Don't do your testing onone of those beautiful 8-1/2 x 11 paper-white monitors; everything looksgreat on those, making them nice to work with, but worthless for testing.andM;Take TwoandM;Do we to have to check what monitor we're running on, and scale differentlyin the x and y directions?andP;  No, in fact, we can dispense with the (.sup.*andO;scale) stuff altogether for the PC version, and let Windows do all ourscaling for us.andM;Windows has programmable coordinate systems.andP;  We can set up a mapping mode sothat the stop sign will come out square, no matter what screen is used.andP;  Wecan set up our own units of measurement so that, for example, 18 units alwaysfills the window no matter what the window's size.andM;But we don't want arbitrary scaling along both the x and y axes; we want thestop sign to fill the window as completely as possible, without distortingits shape.andP;  We can do this using the MM_ISOTROPIC mapping mode, which is usedin the analog CLOCK program that comes with Windows (and the source code forwhich comes with the Windows SDK).andM;The Mac doesn't really have any built-in facility for programmable coordinatesystems.andP;  Macintosh pictures have a picFrame which is scaled to a destinationrectangle when you call DrawPicture, resulting in an arbitrary scaling alongthe x and y axis.andP;  This is similar to Windows' MM_ANISOTROPIC mapping mode.andO;The Mac also has the ScalePt and MapPt functions, but there isn't anything asgeneral as Windows' mapping modes.andM;In order to use the isotropic mapping mode, Windows needs to know what unitof measurement you're using and what rectangle these should be mapped onto.andO;For example, our stop sign seems to be in a unit of measurement whose largestunit is 18, and we want 18 to map to the extent of the portRect, minus ourborder of 5 units on each side--actually not that difficult.andM;The rectangle that you're mapping into (the destRect, so to speak) is calledthe &quot;viewport,&quot; and the unit that you're mapping from is called,unfortunately, the &quot;window.&quot;andM;We've been discussing our second version for quite a while, but it's just atiny change in Figure 5.andP;  We set the map mode to MM_ISOTROPIC, and we set ourwindow and viewport extends.andP;  Instead of actually deleting all the (.sup.*andO;scale) code, we left it in and just set the scale to 1.andP;  If you enter thechanges in Figure 5, recompile (MAKE HELLO), and run the new HELLO.EXE,you'll see a big improvement.andP;  The stop sign keeps its shape, no matter whatthe window shape, the window size, or what monitor is used.andM;Because the mapping mode takes care of the conversion of &quot;logical units&quot; (avery powerful idea) to device units, we can also use it for the rotation ofobjects.andP;  To rotate the stop sign, just replace the line: SetWindowExt (hDC,18, 18); with: SetWindowExt (hDC, -18, 18); SetWindowOrg (hDC, 18, 18);andM;More information on using mapping modes for rotation of objects can be foundin Brian Myers and Chris Doner's useful book Graphics Programming UnderWindows (Sybex, 1988).andM;Take ThreeandM;Notice that we've been passing StopSign the window handle hWind so it can doa GetClientRect each time we get an update event (WM_PAINT).andP;  Not only isadding this extra parameter a bit of a nuisance, but often when we get aWM_PAINT, the size hasn't changed.andM;We can make a minor change to HELLO,C to keep the current client rect around,updating it whenever we get a WM_SIZE message.andP;  If you search throughHELLO.C, though, you won't find any explicit handling of size messages.andP;  Thisseems like a Mac program that doesn't handle a mouseDown inGrow; how can webe resizing our windows as we've been doing, if the application doesn'thandle this event?andM;In Windows, &quot;window classes&quot; really do behave like classes inobjecdt-oriented programming: they have a default behavior.andP;  Messages notexplicitly handled by a window procedure in its switch statement, fallthrough to the default case where they are passed to DefWindowProc.andP;  AWindows program doesn't manage the tracking of the mouse during windowresizing, the way a Mac program does by calling GrowWindow and SizeWindow.andM;Figure 6 shows the changes needed so that we can maintain the client rectourselves, rather than asking Windows for it every time.andP;  We trap for theWM_SIZE message now, updating the global variable client_rect.andP;  StopSign nolonger takes an HWND parameter; instead, it inspects the global variableclient_rect.andP;  In a sense we've thinned StopSign's interface, since now ittakes one parameter instead of two, but now we're peeking at globalvariables, which is worse.andP;  We'll fix this in our fifth version.andM;Take FourandM;If it makes sense for us to maintain our own state for the window size, itmakes even more sense to do the same for the current position, which we'vebeen inquiring after each time in our functions Move and Line.andP;  We could addtwo more global variables, curr_x and curr_y, and use them and update them inMove and Line--except that the current position is also changed by theWindows functions MoveTo and LineTo.andP;  Of course, we didn't write our ownversions of MoveTo and LineTo, since Windows supplies these itself.andP;  In orderto keep curr_x and curr_y up to date, we'll have to write tiny front-ends,MyMoveTo and MyLineTo, which simply update our variables and then callWindows' MoveTo and LineTo.andM;It may sound silly, but writing this front-end is our most powerful idea sofar.andP;  Making our own versions of the &quot;primitives&quot; supplied by the operatingenvironment is the first real step toward portable code.andM;If you don't have a certain routine, it's often useful to create ahypothetical one; textbooks on computer science call this &quot;wishful thinking.&quot;andO;Later on, you write the routine that you hypothesized you had.andP;  Conversely,when writing portable code it's often useful to do the opposite; the APIprovides a routine, but you pretend that it doesn't.andP;  You call your owninterface routine instead; this routine can call the underlying service.andO;When switching from one environment to another, all that you rewrite are yourinterface routines.andM;Now that we have a little set of four output routines and two variable thatthey monitor, it makes sense to package all this in a separate module.andP;  Inour third version we added a global variable (client_rect) that's visible allover the place, but here we've done things properly; curr_x and curr_y arestatics that are visible only to the routines that use them in our newmodule, DRAW.C (see Figure 7).andM;DRAW.H provides the external interface to the functions in DRAW.C.andP;  It alsouses some #defines to remap all LineTo calls to MyLineTo and all MoveTo callsto MyMoveTo.andP;  For consistency checking, DRAW.C #includes DRAW.H.andP;  But, inDRAW.C we actually have to call the &quot;real&quot; MoveTo, not MyMoveTo.andP;  DRAW.C#defines the preprocessor symbol DRAW_C; if DRAW.H sees that DRAW_C is#defined, it doesn't change the MoveTo and LineTo calls.andP;  Writing portablecode certainly seems to involve a lot of wrestling with the preprocessor.andM;Don't forget to update the HELLO make file again, this time adding DRAW.C andDRAW.H.andM;Take FiveandM;At this point, we had better get this code running back on the Mac again.andP;  Bywriting front-ends for LineTo and MoveTo, we are well on the way to portablecode.andP;  Instead of raw in-line calls to Windows, we're calling our ownroutines, which then take care of calling Windows.andP;  Except for that hDC inthe function parameters, the routines would just as well call the MacToolbox.andM;The first things we must do is get rid of that HDC parameter, yet somehowstill have an HDC to pass to the Windows routines.andP;  We want each environmentto do scaling in its &quot;native&quot; way, yet not have separate code at theapplication level.andM;Figure 8 shows the changed portions of HELLO.C and new STOP.C.andP;  It also showsa fragment of a Macintosh main calling the new portable StopSign function.andM;What is most noticeable about the new STOP.C is that it does not #include&quot;windows.h&quot; and it does not #include &quot;QuickDraw.h&quot;.andP;  Instead we include asmall file, called CANVAS.H, which is the external interface to a new module,CANVAS.C (see Figure 9), that provides one common interface to our twodifferent operating environments.andP;  For instance, STOP.C calls the procedureoffset_org, which sets the origin of a drawing context (a GrafPort or anHDC).andP;  If compiling for the Macintosh (#ifdef MAC), offset_org takes care ofcalling SetOrigin; otherwise it calls Windows' OffsetViewportOrg.andM;But OffsetViewportOrg requires an hDC parameter and, on the Mac--depending onwhich GrafPort we want to do a SetOrigin on--we may need to switch thePort.andO;How can we provide the same external interface to these two operations whichare perhaps conceptually similar, but so completely different in practice?andM;HCANVASandM;Continuing with this example, the first parameter to offset_org is hCanvas, ahandle to a CANVAS, our new data type provided by CANVAS.C.andP;  A CANVAScontains all the information needed to talk to a GraftPort on the Macintoshand to an HWND or HDC under Windows.andM;On the Mac, the window field of a CANVAS contains a WindowPtr; under Windowsit contains an HWND.andP;  On the Mac, offset_org fiddles with the portRect andpossibly switches thePort.andP;  Under Windows, we use the macroCANVAS_HDC(hCanvas) to extract the HDC from a CANVAS so we have an hDC topass to OffsetViewportOrg.andP;  We manage to pass around some number (an HCANVAS)at our application level, yet we still have an HDC when the time comes tomake the Windows call.andP;  Using the HCANVAS to get at a GrafPort or an HDC ishandled entirely inside CANVAS.C.andM;But how can an HDC be kept around inside a CANVAS when we know that the HDCis fleeting?andP;  We are not using the CS_OWNDC trick.andP;  Instead, while we areservicing a WM_PAINT message, the CANVAS contains a valid HDC.andP;  It is putthere by the function begin_update.andP;  When we are done servicing an updateEvtor WM_PAINT, we call end_update which on the Mac calls EndUpdate andDrawGrowIcon, but under Windows calls EndPaint and, most important, sets theHDC in the CANVAS to zero.andM;Any canvas function, like offset org, whose Windows version requires an HDC,first checks to see if (!CANVAS_HDC(hCanvas)).andP;  If offset_org has been calledbetween calls to begin_update and end_update, then there will be a valid HDCand we can make the Windows call.andP;  Otherwise, CANVAS_HDC(hCanvas) will bezero.andM;In the code presented in Figure 9, we return when the HDC is zero.andP;  This isparticularly important because a debugging version of Windows checks forinvalid HDCs.andP;  If it finds one, it tries to send a FatalExit (RIP) code outto an AUX device, and, if you don't have an AUX device, Windows hangs withthe &quot;Cannot write to device AUX&quot; dialog box, waiting for you to attach an AUXdevice.andP;  For an introduction to debugging Windows, see Durant, Carlson, andYao, Programmer's Guide to Windows (Sybex, 1988), 2nd edition, Chapter 15.andM;Rather than simply returning, our code should do something in order toacquire an HDC.andP;  This technique is used in the functions env_StarDrawing andenv_EndDrawing in ENVRNMT.C, from which CANVAS.C has been extracted, andwhich is used in the larger application we will discuss later in thisarticle.andP;  The Windows version of env_StartDrawing sets the HDC field in aCANVAS by calling GetDC(CANVAS_HWND(hCanvas)).andP;  GetDC is a Windows function,and CANVAS_HWND is our macro for extracting the HWND stored in a CANVAS.andP;  Ourfunction env_EndDrawing clears the HDC field with: ReleaseDC (CANVAS_HWND(hCanvas), CANVAS_HDC (hCanvas)); CANVAS_HDC (hCanvas) = 0;andM;Env_StarDrawing and env_EndDrawing do something completely different on theMac.andP;  At the application layer, though, the effect is the same.andM;Looking back at STOP.C in Figure 8, note that the multiplication of (x,y)coordinates by a scaling factor is gone.andP;  All scaling has been moved toCANVAS.C.andP;  The large macro with the strange name MAYBE_SWITCHING_PORT iscalled from the Macintosh versions of move, line, move_to, and line_to, andmultiplies the (x,y) coordinates by CANVAS_SCALE(hCanvas).andO;CANVAS_SCALE(hCanvas) is set by the function set_scale on the Mac, but underWindows, set_scale sets the map mode, the window extent, and the viewportextent.andM;As seen in Figure 9, a CANVAS contains all sorts of things besides GrafPortsor HWNDs and HDCs.andP;  Everything that in previous versions was scattered allover the code, like the global variable client_rect from the third version,or the statics curr_x and curr_y from the fourth, are now part of a CANVAS.andO;The CANVAS has become our own machine-independent GrafPort or DC.andM;Raw or CookedandM;While STOP.C contains no explicit Windows calls, it is still Windows code; itis simply portable Windows code.andP;  At the same time, while it contains noexplicit Mac Toolbox calls, it is also Macintosh code, because the functionsit calls in turn make Mac Toolbox calls.andM;It is important to note that you can have Windows code that doesn't contain&quot;raw&quot; calls to OffsetViewportOrg or to BeginPaint.andP;  Something can be Mac codewithout containing raw calls to SetOrigin or BeginUpdate.andM;Code found in good commercial applications does not resemble the codepublished in Microsoft Systems Journal or in MacTutor because, in order toshow how to use an API, such sources must of necessity present nonportablesystem-dependent calls intermixed with higher-level code.andP;  We call this theraw style of coding, in contrast to the &quot;cooked&quot; form shown in STOP.C.andM;Calling the cooked transform_something, rather than the raw API callTransformSomething, is only the beginning.andP;  Most commercial applicationsrequire a higher level of abstraction than that.andP;  Many commercialapplications use typedefs and #defines to alter C so that it's unclear tooutsiders and newcomers.andP;  However, this is essential for keeping the codeclose to the problem at hand, and for maintaining portability.andM;Portable code is broken into an application layer (core) and an environmentlayer (edge).andP;  Ideally, the application layer doesn't change, no matter whatsystem it's running under, and only #includes your own .h files.andP;  This meansyou must ensure that the application layer of your application knows nothingabout files such as &quot;windows.h&quot; or &quot;QuickDraw.h.&quot;andP;  This is a litmus test todetermine how well you have isolated yourself from system-level dependencies.andM;Depending on the level of your commitment to portability, the &quot;only our own.h files&quot; rule might even extend to the C standard library.andP;  For instance,while Microsoft C has the memset routine--declared in andless;string.handgt; for ANSI Ccompatibility and in andless;memory.handgt; for UNIX System V compatibility--Lightspeed Con the Mac has a function setmem which does the same thing, except itsarguments are in a different order and its declaration is in andless;unix.handgt;.andP;  Usingthese routines is preferable to writing your own, because the compilermanufacturers are supposed to implement them efficiently (using REP STOSB onthe PC, for example), but you also want to be shielded from minordifferences.andP;  One solution might be a file, STD.C, to handle all nonstandardstandard library routines, and so the environment layer might even includesuch standard routines as memset.andM;In order to highlight the correspondence between Mac Toolbox functions andtheir Windows equivalents, our files CANVAS.C (see Figure 9) and MEMMGR.C(see Figure 13) are designed to compile on either environment using the flag#ifdef MAC.andP;  But as Rex Jaeschke points out in his new book, Portability andthe C Language (Hayden Books, 1988), p.andP;  9, &quot;A general misconception is thatexactly the same source code files must be used on all targets such that thefiles are full of conditionally compiled lines.andP;  This need not be the case atall.&quot;andP;  There ought to be two separate CANVAS.C files--one for the Mac and onefor Windows.andM;There is one serious problem with our use of #ifdef MAC.andP;  We have assumedthat we are either compiling for the Mac or for Windows.andP;  But what about theOS/2 Presentation Manager, X Windows, or Display PostScript systems likeNeWS, or the NeXT computer?andP;  In actual code, you would want multiple versionsof a file like CANVAS.C, one for each environment.andP;  Additionally, rather than#ifdef MAC, we might have used the various compilers' predefined symbols,such as THINK_C for Lightspeed C 3.0 or the Macintosh symbol defined byApple's MPW C compiler.andM;The code that we show in CANVAS.C and MEMMGR.C is filled with #ifdef MACs,and while it should be done with a separate CANVAS.C or MEMMGR.C for eachenvironment, remember that there are no #ifdef MACs at our application level.andM;While we're proposing a separate environment-specific module for eachenvironment, also remember that the external interface does not change.andO;There might be a CANVAS.C for the Mac, a CANVAS.C for Windows, and anotherfor X Windows, but there need only be one CANVAS.H.andP;  We set up a commoninterface to disparate systems, using C files such as a Modula - 2IMPLEMENTATION module and H files such as a DEFINITION module.andM;There is an argument against using layers for reasons of portability:efficiency.andP;  But note that the same argument can be made against using Crather than assembler.andP;  Writing raw Windows or Mac code is in a wayequivalent to writing in assembler.andM;Pictures and MetafilesandM;It is true that, now that we're going through the extra layer of CANVAS.C,our stop sign code runs a little slower.andP;  Each time we call move_to or line,the first parameter is checked to ensure that it's a valid HCANVAS.andP;  Beforewe can call the underlying Mac or Windows call, we must extract theappropriate field from the CANVAS data structure.andM;It would be preferable to have all this validation the first time we callmove_to or line, without continual checking every time we get an updateEvt orWM_PAINT message.andP;  If only there was some way to compile our CANVAS callswhen the program starts up, and then play back the compiled object wheneverwe get an updateEvt or WM_PAINT.andM;The Macintosh has a very general facility for doing just that: pictures.andO;Between calls to OpenPicture and ClosePicture, any QuickDraw calls arecompiled into a GrafPort's picSave field, instead of being drawn to thescreen.andP;  The picture can be displayed by calling DrawPicture.andP;  When you'redone with it, the picture's memory is freed by calling KillPicture.andM;Similarly, Windows has metafiles.andP;  Between calls to CreateMetaFile and toCloseMetaFile, GDI calls can be sent to a metafile HDC instead of to avisible HDC on the screen.andP;  The metafile can be drawn by callingPlayMetaFile.andP;  To free the memory occupied by a metafile, callDeleteMetaFile.andM;In Figure 9, the CANVAS open_picture, close_picture, draw_picture, andkill_picture functions provide a common interface to Mac pictures and Windowsmetafiles.andP;  In Figure 10, StopSign uses these routines, creating the pictureonce, but drawing it every time.andM;This presents an interesting question.andP;  Since the CANVAS (GrafPort or DC)onto which we are drawing the picture can change in size, how does ourscaling take place?andP;  We've saved QuickDraw or GDI calls into a picture whenthe CANVAS was one size, but when we play the picture back the CANVAS sizemay have changed.andM;As we mentioned during the discussion of scaling in our second version, Macpictures have a picFrame which is scaled to a destination rectangle when youcall DrawPicture.andP;  This is similar to the Windows MM_ANISOTROPIC mappingmode, in that there is arbitrary scaling in both dimensions.andM;In Windows, the same metafile can be drawn into any mapmode/viewport/windowconfiguration.andP;  As Charles Petzold explains in Programming Windows (MicrosoftPress, 1988), p.andP;  628, the contents of a metafile &quot;are simply units.andP;  Theywill take on meaning only when you play the metafile.&quot;andP;  What is displayedwhen you play a metafile depends, not on the configuration when you saved thefile, but on the configuration when you play it back.andP;  Scaling also workshere.andM;We have made Windows metafiles seem similar to Mac pictures.andP;  A picture cancontain any QuickDraw calls, but only a subset of GDI calls can be compiledinto a metafile; in particular, no Getxxxx functions can go into a metafile,and this was the real reason for removing the call to GetCurrentPosition fromLine and Move in our fourth version.andM;Since Windows is more restrictive in this situation, we'll have to restrictourselves on the Mac as well if we want our code to be portable.andP;  We feelthat accepting these restrictions is better than the other choice, as takenin the XVT Toolkit: that of using Windows bitmaps rather than metafiles asthe analog for pictures.andM;In addition to the drawing opcodes that you usually put into a picture on theMac, you can also use the PicComment function to introduce arbitrary datainto a picture.andP;  One might, for example, put PostScript commands in a picturecomment.andP;  They are called comments because they are usually ignored byDrawPicture.andP;  However, by setting the commentProc field of the grafProcsfield of a GrafPort, you can hook into the stream of PicComments and processthem [see Scott Knaster, Macintosh Programming Secrets (Addison-Wesley,1988), pp.andP;  174-181].andM;Windows doesn't have anything exactly like this.andP;  Using EnumMetaFile toenumerate all the records within a metafile and PlayMetaFileRecord to playback an individual GDI opcode, you can define your own metafile processing.andO;Windows metafiles can easily be stored on disk and shared between programs.andM;Note that PostScript and the Apple LaserWriter are fully supported byWindows, but in a manner different from the LaserWriter driver's use ofPicComments.andM;Proof-by-ExistenceandM;We can agree that an intermediate layer between an application and itsenvironment is a useful mechanism for providing portability.andP;  The tricky partis the detail involved in implementing this layer.andP;  Windows and the MacToolbox are two very complex and rich environments, each with its ownidiosyncrasies.andP;  In each environment there lurk several &quot;gotchas&quot; waiting totrip the unsuspecting programmer.andM;Things that seem second nature to an experienced Mac programmer areunavailable on Windows, and vice versa.andP;  Often these discrepancies are onlydiscovered when attempting to write a large application and port it from oneenvironment to the other.andM;The sample application described in this article represents our attempt tocreate a medium-sized generic application that raises as many potentialproblems as possible to provide a proof-by-existence of the validity of ourapproach.andP;  Time did not allow completion of a truly representativeapplication, but the program does illustrate relevant issues regardingwindows, events, graphics drawing, memory allocation, and command processing.andM;Application StructureandM;The application, GENAPP, is a first draft of a draw program that allowscreation of graphic objects and selection and manipulation of these objects.andO;Draw programs are often called object-oriented programs by way of contrastingthem with bitmap-oriented paint programs.andP;  With paint programs the usermanipulates the bits on the screen almost like physical entities.andP;  With adraw program the user manipulates abstract geometric objects such asrectangles or polygons through their screen representation or view.andP;  thesegeometric objects exist in some abstract mathematical space (the worldcoordinate space) separate from their screen representation.andM;GENAPP highlights this distinction, between the set of abstract geometricobjects and their representation on the screen display.andP;  Thii is achieved byproviding both a graphics view and a textual view of the data model.andP;  Forexample, a rectangle object has both a graphic representation (therectangular shape drawn on the screen) and a textual representation (a lineof text describing the rectangle's attributes).andP;  The user can select andmanipulate objects through either the graphics view or the text view.andO;Moreover, there can be multiple graphics views and/or text views onto thesame data model.andP;  Finally, the application can maintain multiple data modelsconcurrently, in the same way word processing programs let you open multipledocuments for editing at the same time.andM;The program is split into these two major parts:andM;* an environment-specific layer that serves as an intermediary between therest of the application and the host environment, be it PC or Mac.andP;  This isin the file ENVRNMT.C (filenames have been truncated to eight characters orless because of MS-DOS requirements).andM;* an environment-independent core section that represents the heart of theapplication.andP;  In a real-life substantial application, this might representmany modules and tens of thousands of lines of code.andP;  In our example, it isone file called APPLCATN.C, containing many of the components of largerapplications.andM;The structure of the sample application parallels in miniature thearchitecture of many illustration, word-processing, page layout, and CAD/CAMprograms.andM;The major elements of the environment-independent section (APPLCATN.C) are asfollows:andM;* The doucment manager: a document is an entity that contains a single datamodel and any number of views onto that data model.andM;* The view manager: a view maintains a consistent screen representation of adocument's data model.andP;  There can be either graphics or text views.andP;  A viewis closely linked with a CANVAS.andM;* The data model manager: a data model is owned by a document and contains acollection of objects.andP;  In our toy application, this is the only entity thatis dynamically allocated via the memory allocation routines provided byENVRNMT.C.andM;* The object manager: implements operations on individual objects, such asdrawing or highlighting an object or changing its attributes.andP;  Many of theseoperations are carried out by calling routines in ENVRNMT.C.andM;* The application-level event loop: requests application-level abstractevents (APPEVENTs) from the environment-specific layer (which has its owninternal event loop as well).andP;  Depending on the type of event received, callsare made to appropriate application-level modules such as the view manager ordocument manager to handle these events.andM;* The menu command dispatcher: called by the application event loop uponreceipt of a COMMAND event.andM;The header file APPLCATN.H contains function prototypes for all the routinesof the managers listed above.andP;  It is therefore a useful summary of what hasbeen implemented and what has been left out.andM;Environment-SpecificandM;LayerandM;The file ENVRNMT.C.andP;  contains environment-specific modules to deal with thefolllowing functions:andM;* Memory allocation: functions to allocate relocatable chunks of memory, toresize these chunks, to lock them and get a pointer to the object's contents,to unlock an object, and finally to deallocate or dispose of an existingmemory block.andM;* Menu handling: environment-specific menu initialization, as well ashandling of the system menu (known on the Mac as the Apple menu, whichcontains coresident desk accessory programs).andM;* Event processing: the function GetAppEvent, which handles allenvironment-specific events and transforms them as appropriate intoapplication-level events.andM;* Window management: functions to create a physical window on the screendisplay (controlled by our abstract entity known as CANVAS), and functions toactivate, resize, update, and move these physical windows.andP;  The internalCANVAS data structures are maintained in consistency with the physicalwindows in the environment.andM;* Graphics rendering: these functions are closely linked with the windowmanagement functions above by means of the CANVAS entity.andP;  The functions drawbasic graphic shapes on the screen (rectangle, line, ellipse, and text), andmaintain a coordinate system which is independent of the screen aspect ratio.andM;* Environment initialization: on the Mac, initialize the appropriatemanagers.andP;  Under Windows, register the application window classes.andM;The key factor is that the external interface to this environment-specificcode is, like our earlier CANVAS code, environment-independent.andM;What's MissingandM;Due to publication deadlines, large areas of functionality provided by theMac and Windows are completely ignored by GENAPP and its environment layer.andO;These include all functions having to do with: printing, reading and writingof files, putting up dialog boxes, dealing with scroll bars and scrollevents, and tracking the mouse to interactively resize an object.andM;With a few exceptions, it is our opinion that these functional areas areconceptually similar enough that adding them to the existingenvironment-application framework can be a largely straightforward (albeitlengthy) exercise for the reader.andP;  Still, there are probably enough gotchasfor the exercise to remain interesting.andM;One messy area is the tracking of the mouse, for interactively resizing orrubberbanding a graphic object.andP;  An approach that should prove viable here isthe one used by the Mac TEClick, TrackGoAway, or DrawWindow routines.andP;  In allthese cases, the mouse click is used to initiate an internal mouse trackingprocess that continues until the mouse button is released.andP;  The actualrendering of the graphic object can then be implemented by anapplication-supplied callback routine.andM;GENAPP provides a skeleton for adding this kind of functionality.andP;  Alsomissing from the sample application is a lot of detail on existing sectionsin ENVRNMT.C.andP;  For example, the memory management section has no functionthat returns the size of a memory block.andP;  Adding one would be trivial forboth the Mac and Windows (through calls to Mac GetHandleSize or WindowsGlobalSize).andP;  It happens that our sample application does not need thisparticular function.andM;Our section on graphics rendering only supplies a few basic primitives (forrectangle, ellipse, and text).andP;  Both the Mac and Windows have many moredrawing primitives that can be mapped to each other.andP;  One known area ofdifficulty is the treatment of fonts and text attributes.andP;  Windows has acomplex largely undocumented font selection method which is both verydifferent from that on the Mac, and substantially changed for PresentationManager.andM;Getting InputandM;So far, we have examined how an application draws correct output to thescreen display.andP;  This is done in a portable fashion by introducing anintermediate layer between the application and the GUI.andP;  An equally importantsubject is how the application program gets its input from the user.andM;Programmers writing nongraphics applications formerly had to deal withcharacters entered at the keyboard, or perhaps coming in from a serial port.andO;As Mac programmers know, the Mac environment dramatically extended the rangeof possible inputs, to include not just keystrokes, but also mouse actions(mouse up, mouse down) and other possible inputs (network, device driver, andinternally derived inputs).andP;  Because of the high degree of interactivitybetween program and user, it became useful to conceive of an application'sstructure as passive and event-driven, rather than as active anddata-oriented (as found, for example, in old-fashioned batch utilities thattransform or filter simple streams of data).andM;Unlike batch-oriented programmers, Mac programmers are familiar with theconcept of structuring an application as a passive event loop that waits forand responds to a variety of events.andP;  These events include inputs from theuser as well as internally derived inputs such as window activation andwindow updating events.andM;To encompass all the information an application would need about an event,the Macintosh defines the EventRecord data structure, and Windows defines thesimilar MSG data structure.andP;  Both structures include what type of eventoccurred (event.what on the Mac, msg.message under Windows), the time ithappened (event.when or msg.time), as well as where the mouse was(event.where or msg.pt).andM;The Mac and Windows are very similar here, but the terminology may be alittle confusing.andP;  While Mac events are called messages in Windows, note thatthe Mac EventRecord also refers to a message.andP;  This is the extra informationthat comes along with an event; its meaning differs depending on event.what.andO;For instance, if (event.what == keyDown), then event.message will contain theASCII code and key code.andP;  Under Windows, this same type of information iskept in the fields wParam and lParam (see Figure 11).andM;Many MessagesandM;Most of the changes from Mac events to Windows messages involve makingfamiliar concepts more flexible and more general.andM;Inside Macintosh defines eleven types of system events.andP;  By way of contrast,the standard Windows header file defines 96 types of messages.andP;  What do these96 messages consist of?andM;* Twenty types of mouse messages (rather than two mouse event types on theMac).andP;  These types are necessary to handle one, two, and three button mice.andO;They also treat a double-click as its own type, rather than relying on theapplication program to detect it (assuming that the window has beenregistered as one accepting double-clicks).andP;  In addition, there is parallelset of mouse messages dealing with events in the non-client area of a window(known to Mac programmers as what lies outside the inContent part of thewindow: title bar, close box, etc).andP;  Unlike the Mac, where programs have toquery the environment with GetMouse calls during null events, Windowsconsiders simple movement of the mouse to be sufficiently interesting tomerit its own WM_MOUSEMOVE message.andP;  Note that the WM prefix stands forWindow Message, as every MSG includes the window for which it is intended.andM;* Twelve types of keystroke messages (rather than three on the Mac).andP;  Some ofthese deal with system keys, which are distinguished from other keys.andM;* Fifteen types of clipboard messages (rather than none on the Mac).andP;  Thesemessages inform the application of changes in the content of the clipboard,in the chain of clipboard viewers, or in various other clipboard-relatedrequests.andP;  See &quot;Exchanging Data Between Applications Using the WindowsClipboard,&quot; MSJ, (Vol.andP;  3, No.andP;  5).andM;* Twenty-three types of window messages (rather than two on the Mac).andP;  Someof this population explosion results from parallel sets of messages dealingwith events in the content area of a window and outside the content area.andO;Additional message types come from the fact that the Windows environment doesthe equivalent of a Mac FindWindow call for you in response to a mouse-downevent.andP;  This means that a user action such as clicking on the close box of awindow is abstracted into a WM_CLOSE message, rather than being passed to theapplication as a mouse-down event requiring further interpretation anddecoding.andP;  Similarly, Windows does not require the application program toworry about mouse-down events in the menu bar.andP;  These are tracked by theenvironment and abstracted into appropriate menu COMMAND messages.andM;Even Though Windows has a WM_NULL message, this is not nearly as important toWindows programs as a nullEvent is to Mac programs.andP;  Many Mac programs usenullEvent to handle a multiplicity of housekeeping tasks, such as menucoloring.andP;  This has been a problem for Mac programmers wanting to modifytheir programs to be MultiFinder-friendly.andP;  Apple now strongly discouragesprogrammers from doing a lot of processing when handling a nullEvent.andM;This brings up a major difference between Windows and the Mac: Windows wasdesigned from the start to be multitasking.andP;  In practice, this is a difficultjob because Windows is not an operating system, but an application-levelpiece of software running on top of MS-DOS.andP;  This affects its performance,not its design.andP;  Because Windows was designed to have multiple applicationsexecuting concurrently, it is not surprising that there is much greatersupport for interapplication communication and data transfer.andP;  This is donethrough flexible user-defined messages (much better than applEvt on the Mac),clipboard messages, and message protocols such as Dynamic Data Exchange(DDE).andM;An analogous situation exists on the Mac with regard to networking.andP;  The Macwas designed to support a cheap built-in local area network (the AppleTalkport has always been standard on Macs, so it is not surprising that theToolbox has a network event type).andP;  In contrast, most PC-compatible machinesthat Windows runs on presently lack hardware to support local area networks,so this message type is missing from Windows.andM;Events and MessagesandM;Fortunately for the programmer, though Windows gives you 96 types ofmessages, it also provides a default handler for them, called DefWindowProc.andO;This brings up a significant difference between event/message handlers on theMac and on Windows.andM;On the Mac, applications wait in a loop, requesting events with GetNextEvent,or with WaitNextEvent, which is used by MultiFinder-aware applications andspecifying which events they are interested in handling by means of aneventMask.andP;  The following code should be very familiar to Mac programmers:while (! done) [ if(GetNextEvent ( everyEvent, andamp;theEvent)) [ switch(theEvent*what) [ case mouseDown: doMouseDown; break; case updateEvt:doWindowUpdate; break; * ] ] ]andM;In Windows, all programs need a callback function for each type of windowthey create.andP;  This callback function is known as a window procedure, orWndProc.andP;  You must call Window first, to get it to call you, with a messageloop that looks similar to the Macintosh event loop: while (GetMessage((LPMSG) andamp;msg, NULL, 0, 0)) [ TranslateMessage ((LPMSG) andamp;msg);DispatchMessage ((LPMSG) andamp;msg); ]andM;DispatchMessage is the Windows routine that decides which of the variousmessage handling WndProcs it will call.andP;  In some ways it is similar toFindWindow on the Mac, transforming a low-level raw event, like a mouse-down,into a slightly higher-level, more abstract event, like a menu-bar click.andM;Windows has a routine, WindowFrontPoint, that does the same thing asFindWindow, but it is hardly ever used because of the all-importantDispatchMessage.andM;By the way, note that the return value of the Windows GetMessage is a Booleanvalue telling the application when to quit.andP;  In contrast, GetNextEventreturns a Boolean value telling the application whether or not it shouldhandle the particular event that just passed.andM;The message-handling WndProc on Windows (the one called by DispatchMessage)typically looks like this: long far pascal myWndProc ( hWnd, message, wParam,1Param) HWND hWnd; int message; WORD wParam; LONG 1Param [ switch (message) [case wM_SYSCOMMAND: doSysCommand ( hWnd, wParam, 1Param); break; caseWM_CREATE: doCreate ( hWnd, wParam, 1Param); break; * ] ]andM;As you can see, the parameters to a WndProc callback are nothing more thanthe key components of the Windows MSG structure show in Figure 11.andM;Parenthetically, note that Windows uses a Pascal calling convention similarto that on the Mac, though for different reasons.andP;  The Microsoft C compilerrequires this non-Kandamp;R keyword to be in a different place from where theMacintosh C compiler looks.andP;  Note also the additional non-Kandamp;R keyword, far,which refers to how this function is addressed in memory.andM;Object-Oriented WindowsandM;The significant difference between Mac and Windows event handling is that--asopposed to a single event stream on the Mac that contains bothapplication-specific events (desktop events such as menu-bar click) for allwindows--Windows uses multiple message streams flowing to each type ofapplication window.andP;  Windows applications, therefore, have as many messagehandlers as there are window types.andM;Why did Microsoft make this change?andP;  It comes from an approach that extendsthe Macintosh Toolbox's modular structure toward object-oriented programming.andO;On the Macintosh the various subsystems are controlled by managers, whichgenerally own one particular data structure (such as an EventRecord orWindowRecord).andP;  Application programmers call Toolbox routines to manipulatethese data structures.andP;  (Ignore for now the fact that Apple makes these datastructures available for direct manipulation by the programmer.)andM;In Windows, a window is not just a data structure manipulated byWindowManager routines.andP;  It is conceived as an objectlike entity of aparticular type, or class, and therefore exhibits behavior associated withthat class.andP;  A window's behavior is defined as its particular responses tomessages it may received.andP;  The generic or archetypal window has genericbehavior that is defined by the default message handler.andP;  This defaultmessage handler (DefWindowProc) is provided by the Windows environment.andM;Conceptually the desktop can be thought of as the root or parent window tomultiple applications.andP;  Applications each have their own main window (withits associated menu bar of commands), and may have any number of subsidiary,or child windows.andP;  These windows may all be the same type (representing adocument or page), or they may be various types (document window, palettewindow, status window, etc.).andP;  Each of these types can therefore behavedifferently.andP;  Similarly the system has different classes of windows fordifferent purposes: dialog boxes, alert boxes, control, menus.andM;When an application starts up, it registers its classes of windows with thesystem.andP;  It must provide a message handling procedure for each registeredclass.andP;  This message handler is part of a chain of message handlers, and ispassed all messages that flow through from the system to that particularwindow type.andP;  The handler will examine the message stream for message typesit is interested in, and pass all other messages to the next handler on thischain, which may simply be the default window class handled by DefWindowProc.andM;When we said earlier that clicking on the close box of a window is abstractedinto a WM_CLOSE message--rather than being passed to the application as a rawmouse-down event--this wasn't quite true.andP;  The application does see thelow-level event (it's called WM_NCHITTEST, For non-client hit test), but mostapplications just pass it on to DefWindowProc, where it's graduallytransformed into higher-level events such as WM_CLOSE.andM;Programmers writing applications specifically for Windows have learned to usethe technique called sub-classing, which modifies the behavior of some otherexisting window class (system or application) by chaining a message handlerin front of the handler for an existing window class.andP;  This new handler needsto implement the behavior being added or changed, and can then pass othermessages to the existing handler to implement the standard behavior.andM;This is an elegant, general, and flexible scheme that unfortunately does notmap very well to the more limited system on the Macintosh.andP;  In the Mac'sdefense, it should be noted that there are certain window features on the Macwhich are not provided by Windows.andP;  For example:andM;* On the Mac, you can specify at window-creation time the particular layeringorder (that is, front-to-back) for the window you are creating.andM;* You can also, if you wish, specify a callback procedure to radicallycustomize a window's behavior.andP;  For example, you can specify a window-frameroutine that might draw elliptically shaped windows rather than rectangularones.andP;  This type of function is called a windowDefProc on the Mac, whichsounds like but has nothing to do with Windows' DefWindowProc.andM;Writing portable applications that run on more than one environment requireseither a subset of features common to both environments, or simulating themissing functionality on the lesser environment.andP;  In the case of windowtypes, we have chosen the former approach in our sample application.andP;  Thewindow types used by our application are very simple, and map easily to bothMac and Windows.andP;  In the case of events/messages, we have chosen an approachthat simulates a small amount of functionality that is missing on theMacintosh but present under Windows.andM;Application EventsandM;In our sample application, there is an intermediate layer that shields thecore part of the program from the differences between Macintosh events andWindows messages.andP;  This is done by defining an entity known as an applicationevent or APPEVENT.andM;The structure of our application is similar to a Macintosh program, in thatthere is a single top-level event handler that loops through and processesevents as they occur.andP;  The event handler gets these APPEVENTs from theenvironment through calls to GetAppEvent.andM;As an example, the application-level event loop in APPLCATN.C looks somethinglike this: while (! done) [ env_GetAppEvent(andamp;theAppEvent); switch(theAppEvent.event_type) [ case CMD_EVENT: doCommand( andamp;theAppEvent); break;case MOUSEDOWN_EVENT: doMouseDown( andamp;theAppEvent); break; * ] ]andM;The above example is very similar to the Mac event loop shown earlier.andP;  Thedifferences are in the data structure used (of type APPEVENT rather than typeEventRecord), and the kinds of events processed.andP;  There are 12 differenttypes of APPEVENTs, representing what's needed to achieve our purpose.andM;If our sample application were to evolve into greater functionality andcomplexity, it is likely that additional types of events would be needed.andO;But this would be some number less than 20, rather than the 96 types definedfor Windows.andP;  The 12 APPEVENT types are shown in Figure 12.andM;The alert reader will note that there are six types of view events, andviews, while not yet discussed, are presumably analogous to windows.andP;  But theMacintosh has only two event types dealing with windows (update andactivate).andP;  Where do these other types come from?andM;Our intermediate environment-specific layer contains an internal event loopthat actually handles the &quot;real&quot; events provided by the Macintosh or Windowsenvironment.andP;  The particular environment-specific events are transformed bythis internal handler into the more abstract APPEVENTs seen by theapplication.andP;  Windows, with its 96 message types, has to screen and disposeof uninteresting messages internally.andP;  The Macintosh has to handle moreprimitive actions (such as a mouse-down in the menu bar), and translate theseinto menu CMD_EVENTS similar to the WM_COMMAND messages found in Windows.andM;Memory ManagementandM;Memory allocation is one area where the Mac and Windows approaches seemextremely similar.andP;  In fact, there appears to be almost a one-to-onecorrelation between Mac and Windows memory functions.andP;  This close correlationmasks some very significant differences that can cause major difficulties forexperienced Mac programmers.andM;However, once a Mac programmer accepts some rigid but useful constraints, andbecomes aware of differences in the underlying hardware memory architecture,writing portable code can be straightforward--as the sample code inAPPLCATN.C shows, calling environment-independent memory allocationprimitives in ENVRNMT.C.andM;The memory allocation code in ENVRNMT.C is basically a series of one-liners,with one line calling a Mac function and another the corresponding Windowsroutine.andP;  For instance, env_AllocMem allocates a relocatable memory block bycalling Mac NewHandle or Windows GlobalAlloc, and env_GraspMem locks a memoryblock by calling Mac HLock or Windows GlobalLock.andP;  Ourenvironment-independent memory functions are shown in Figure 13.andM;These environment-independent one-liners contribute to the deceptiveappearance of similarity.andP;  On both systems, you request a relocatable chunkof memory and receive what both systems call a handle to an object.andP;  But, aswe have already said, a Mac Handle is not a Windows HANDLE.andP;  A Mac Handle isa 32-bit pointer to a pointer to the actual object in memory.andP;  A HANDLE inWindows, however, is an abstract 16-bit integer used internally by theenvironment to keep track of memory objects.andM;Magic Cookie or **?andM;Macintosh programmers have come to rely on the double-indirection property ofhandles in order to reference an object's content.andP;  That is, if ppo is aMacintosh handle (that is, a pointer to a pointer to an object), then the Clanguage construct *ppo gives you the pointer to the object (po), and **ppogives you the object's contents (o).andP;  For example: typedef struct [ intfirst_field; int second_field; ] SOME_OBJECT; Handle aHandle =NewHandle(sizeof(SOME_OBJECT)); (**aHandle).first_field = some_value;(**aHandle).second_field = another_value;andM;In contrast a Windows programmer obtains a pointer to an object by means of aLock request to the system.andP;  This always happens before referencing theobject's content, and is then followed by a corresponding Unlock requestafter use: HANDLE aHandle = GlobalAlloc(GMEM_MOVEABLE, sizeof(SOME_OBJECT));SOME_OBJECT far *ptr = (SOME_OBJECT far *) GlobalLock(aHandle);ptr-andgt;first_field = some_value; ptr-andgt;second_field = another_value;GlobalUnlock(aHandle);andM;Although the Mac has similar functions to lock and unlock a memory object,many Mac programmers will only lock an object when repeated references aregoing to be made.andP;  For the quick-and-easy assignment of a value into a singlefield of an object, it is much more convenient to use the double-indirectionmethod illustrated above.andP;  Referencing of a memory objecths content via the&quot;star-star&quot; approach is an atomic or indivisible operation (at the C languagestatement level, though in C++ one could overload the * dereferencingoperator), and therefore does not require locking an object, because the MacToolbox has no opportunity to shuffle memory around within that C languageconstruct.andM;Even when using the Mac lock/unlock functions, many Mac programmers havelearned the exact circumstances under which the Mac Toolbox will shufflememory, and therefore often use a pointer to a memory object without lockingthe object.andP;  This won't work in Windows.andP;  The Mac programmer has two choicesfor handling this discrepancy between the two environments.andP;  One is tosimulate the feature missing from the environment by means of an intermediatelayer of software at the application level.andP;  The other is to restrict oneselfto the functionality that is common to both environments.andM;In the case of Mac events and Windows messages discussed previously, it wasrelatively easy to simulate the Windows message types that were &quot;missing&quot; onthe Macintosh: COMMAND_EVENT, QUIT_EVENT, etc.andP;  In the case of memorymanagement, however, this kind of simulation is much more difficult.andM;We once wrote a large piece of code to simulate Macintosh-style ** handles onWindows, but there was a significant loss in performance.andP;  Our currentopinion is that the Mac programmer is better off learning a little disciplineand limiting himself to the more restricted style of Windows memorymanagement.andM;Additional DiscrepanciesandM;It is helpful to note that the lock/unlock functions do not nest on theMacintosh but do on Windows.andP;  Every Lock statement needs to be balanced by acorresponding Unlock in Windows.andP;  On the Mac, a single Unlock on a particularobject will take effect immediately, regardless of how many Lock requestshave previously occurred.andP;  The Mac uses a single bit per object to maintainlock information, while Windows uses a 16-bit counter incremented anddecremented by respective Lock and Unlock requests.andP;  In GENAPP the lockoperations do not nest at all, so this will work on either system.andM;Another difference is that Windows' GlobalReAlloc, unlike the Mac'sconceptually identical SetHandleSize, can return a different handle than theone given at object creation time.andP;  This means that applications should havea single place where a handle's value is stored; otherwise copies of thathandle that are left lying around in other data structures may become invalidwhen that block is resized by some other part of the program.andM;A further difference between corresponding functions is that Windowsallocates memory in units of 16 bytes.andP;  Say you ask for a 1-byte object inWindows, then later request its size with a call to GlobalSize (which isequivalent to GetHandleSize on the Mac).andP;  The size returned by GlobalSizewill be 16 bytes, while on the Mac it will be 1.andP;  For certain applicationprograms that use this value to control further processing, it would be anannoying, but resolvable, difference.andM;Environment-IndependentandM;Memory FunctionsandM;As stated earlier, you can sidestep the mismatch between Windows and Macmemory functions by using an environment-independent layer of functionscommon to both environments.andP;  This approach will impose some constraints onthe Mac programmer.andM;Consider the following function from the sample application in APPLCATN.C.andO;AddGraphicsObjectToModel adds a graphics object to the previously allocateddata model.andP;  Writing the code as a Mac programmer would, with ** memoryreferences and no locking, we get the code shown in Figure 14.andM;In AddGraphicsObjectToModel, the argument data_model is of type HMODEL, andis a handle to a collection of graphic objects.andP;  Don't confuse graphicobjects (which are geometric entities like a rectangle object or an Ellipseobject), with memory objects.andP;  The data_model is a memory object which waspreviously allocated with a call to AllocMem.andM;The data_model, as a dynamic array of graphic objects, must grow in size inorder to contain the new graphic object being added to the model.andP;  Thisoccurs with a call to ReAllocMem, which on the Mac calls SetHandleSize and inWindows calls GlobalReAlloc.andP;  Once the data_model has grown to a larger size,our sample function calls a subordinate routine named MakeGraphicsObject toset the fields in the graphic object with attribute information (such asrectangle dimensions or whether it is round-cornered).andM;The code in Figure 14 would need several modifications to run under Windows:andM;* The data_model argument needs to be a pointer to a handle rather than ahandle, because its value may change when the memory block is resized (thoughin this particular piece of code it won't).andM;* The data_model needs to be locked and unlocked twice--first to get thevalue of the num_objects field (and increment this field), and second to callMakeGraphicsObject with a pointer to the new graphics object.andP;  Between thesetwo steps, the data_model needs to be unlocked so that it can be resized.andM;* The pointer to the data_model needs to be of type PMODEL rather than MODEL* due to the segmented memory architecture of the Intel CPU.andP;  Likewise, theargument to MakeGraphicsObject needs to be of type POBJECT rather thanOBJECT*.andM;The revised portable version of AddGraphicsObjectToModel is shown in Figure15.andM;Still More DifferencesandM;There are some big differences between Windows and the Mac in theirunderlying operating system and CPU architecture.andP;  These differences are notthe sort that manifest themselves in formal discrepancies between memoryfunctions in one environment or the other (such as those we have beendiscussing until now).andP;  The manifestation is more subtle, yet differences aremore significant.andM;These hardware and operating system differences, in order of importance, areas follows:andM;* the 640Kb memory limitation imposed by MS-DOSandM;* the size difference between near and far pointers caused by the segmentedarchitecture of the Intel CPUandM;* the differences in byte ordering between the Motorola and Intel CPUs.andM;In practice, these differences cause more problems for Mac programmers thanthe imprecise correlation between memory management functions.andP;  The followingsections describe these differences in more detail, presenting strategies todeal with the consequent problems.andM;The NUXI ProblemandM;Hacker folklore says that it was UNIX programmers who first faced thedifferences in machine byte ordering between different brands of CPUs.andP;  Theseprogrammers were porting UNIX software from one hardware platform to anotherand found that, if you stored the word UNIX as a sequence of bytes on onemachine (for example, the PDP-11 minicomputer), then moved this data toanother machine that had a different memory architecture (the Sunworkstation, for instance), the stored text would be printed out as &quot;NUXI&quot;(depending on how the memory access was made).andM;Other literature calls this the difference between &quot;big endian&quot; and &quot;littleendian&quot; machines.andP;  Given a 16-bit number (that is, two bytes worth), one CPUwill store the high-order value of that number in the byte with the biggermemory address, while another CPU will do the opposite.andP;  A similar situationexists with 32-bit long integers in the storage and accessing of thehigh-order and low-order words of that numerical quantity.andM;GENAPP does not encounter this problem because, in its current form, it doesnot support reading and writing of data models to disk, and therefore datacannot be transferred from one machine to the other.andP;  In real-worldapplications, we have found the following rules useful for staying out ofNUXI trouble:andM;* When problems occur, it is because a value was written by one method (forexample, bytes), then read back on a different machine by a different method(for example, words).andP;  Avoid this.andM;* Reading and writing an object a byte at a time will give the same resultson both machines.andM;* Reading an object's value by using the same C language construct that wrotethat object's value will not cause problems (or, at least won't causeproblems that can't be remedied by machine-specific header file definitions).andM;So Near, Yet So FarandM;The segmented architecture of the Intel CPU used by Windows machines causesdifferent sized pointers.andP;  These two sizes of memory pointers are called nearand far, and place the elusive goal of portability a little farther away fromthe Mac programmer.andM;Many Mac programmers have learned to write software only on the Macintosh andoften produce reckless code like the following call to the Mac ToolboxNewWindow function: WindowPtr w = NewWindow( 0, andamp;rect, &quot;\pUntitled&quot;,1,0,-1,0,0);andM;The least of the sins committed by the above code is the lack of namingconventions to give a hint as to the types of arguments to the NewWindowfunction.andP;  It would be nice if C let you use labels inside a function call,so that you could use named parameters: WindowPtr w = NewWindow( wStorage: 0,boundsRect: andamp;rect, title: &quot;\pUntitled&quot;, visible: 1, procID: 0, behind: -1,goAwayFlag: 0, refCon: 0);andM;But even if Windows had a NewWindow function that took the same types ofarguments as the Mac function, the above code will behave horribly.andP;  For onething, since the Mac Toolbox knows only about Pascal strings, the windowtitle &quot;Untitled&quot; must be converted from a C string (null-terminated string)to a P string (whose first byte contains the strlen) In this code our Macprogrammer has used the Lightspeed C '\p' escape, which turns a C string intoa P string.andP;  On a PC, though, Microsoft C just sees the '\p' as anothercharacter.andM;There are Mac programmers who have more experience writing software for othermachines (a VAX or Sun workstation), and have therefore a more carefulapproach to writing portable code.andP;  We have seen such programmers write theabove function call as follows: WindowPtr w = NewWindow ( NIL, andamp;rect, CtoPstr(&quot;Untitled&quot;), TRUE, 0, -1L, FALSE, 0L);andM;These programmers will perhaps become still more careful after the jarringrevelation that, in the Windows/Intel environment, not all pointers arecreated equal and are not interchangeable with long integers.andP;  The - 1Largument above will throw the rest of the arguments out of phase on thestack.andP;  That argument, which is supposed to be a pointer to data, shouldinstead be ((WindowPtr) -1).andP;  Likewise, many Motorola and VAX programmersdefine NIL to be 0L in their standard header file, when it should be((void*)0) or ((char *)0).andM;Pointers on Intel CPUs can be 16-bit near pointers, pointing to a location inthe current local address space (a memory segment up to 64Kb in size).andP;  Orthey can be 32-bit far pointers, pointing to a location in some other segmentin the global address space (whose size is 20-bits, or 1Mb, on the 808xfamily of processors, but larger on the 80x86 generation of CPUs).andM;Pointers to program code are not necessarily the same size as pointers toprogram data, depending on a particular convention (called the memory model)which is chosen at compile time.andP;  Furthermore a program's static data canexist in a different data segment from the program's automatic variables.andO;Automatic variables are allocated on a program's execution stack, which canbe chosen at compile time to exist in a different memory segment from theprogram's static data.andM;Memory models are defined as follows: small, medium, compact, large, andhuge.andP;  These names refer to the various possible permutations of near/farpointers as they relate to a program's code and data spaces.andP;  For additionaldetails, check out the appropriate section of the C compiler manual you areusing for Windows.andM;Before you Mac porgrammers get too complacent about such things asdifferent-sized pointers, we might point out that, even with the big linearaddress space of the Motorola chips, Apple has gone to a great deal oftrouble to simulate a segmented memory architecture for the Mac, as evidencedby the Segment Loader.andP;  Segmented memory makes a lot of sense when you wantmovable, discardable resources.andM;Saluting TypedefandM;What all this near/far pointer situation means in practice is that, whenpassing a particular pointer as an argument down a chain of subordinatefunctions, the routines further down need to be aware of the near/farancestry of the pointer they have been passed.andP;  In some cases it might evenbe necessary to have two duplicate routines, one of which accepts nearpointers as arguments while the other one takes the far variety.andM;In this near/far situation, typedef assumes an importance much greater thanits creators may have envisioned.andP;  In the original UNIX source code, writtenfor a PDP-11 where ints and pointers were all the same size, typedef is notused very often even with structs.andM;When porting to the more hostile Intel environment, it is criticallyimportant to typedef everything, especially pointers.andP;  In GENAPP, we werewriting APPLCATN.C on the Mac at first, and originally typedef'd our datamodel as shown in Figure 16.andM;A new data model was then dynamically allocated at run time by a call toenv_AllocMem (see Figure 17).andM;On the PC, however, we were using medium model (which defaults to 16-bit nearpointers to program data, and 32-bit far pointers to program code).andP;  Aproblem arose because the memory allocation routines, even in medium model,allocate memory objects from the global heap and have to return 32-bit farpointers to these objects.andP;  Declaring a pointer to a data model as MODEL *meant that the pointer size defaulted to the 16-bit near size.andP;  Our solutionwas to create a separate type for a pointer to model as follows: typedefMODEL far *PMODEL; /* a 32-bit pointer to data model */andM;The above NewModel routine then had to be revised (see Figure 18).andM;This change produced a ripple effect in our application due to the fact thatthe data model was used as a collection of graphic objects.andP;  The ObjectManager section of APPLCATN.C contained routines to manipulate these graphicobjects.andP;  Many of these routines were passed an OBJECT* as an argument.andP;  Thiscode needed to be changed to use the type POBJECT in place of OBJECT*, wherePOBJECT was declared as follows: typedef OBJECT far * PMODEL; /* a 32-bitpointer to graphic object */andM;In addition to the unsung typedef, there is a newer C language construct thatassumes great importance in this near/far pointer situation: functionprototyping.andP;  Function prototyping is an enhancement to the original Clanguage definition and is part of the proposed ANSI standard.andM;Function prototyping and typedefs are the two most powerful weapons in thewar against stray pointer bugs.andP;  In GENAPP, the header files APPLCATN.H andENVRNMT.H contain function prototypes for every function in the program, andwere invaluble in bringing both real and potential problems to our attention.andM;Large Model DrawbacksandM;Mac programmers, when encountering these unexpected ripple effects ofnear/far pointers in an existing program, may feel a sense of delight indiscovering the compiler convention called large model, which establishes32-bit pointers to both program code and program data.andP;  This closelyparallels the Mac; however, there are several strong reasons not to use thelarge model convention:andM;* The large model can cause a significant increase in program size.andM;* This increase in size can have a severe impact on program performance.andM;* The data segment for static data becomes fixed and unrelocatable, affectingboth performance and the possibility of having multiple instances of theprogram running concurrently.andM;* Certain tools and third-party libraries don't support large model (forexample, the XVT library is only available in medium model).andM;This just shows that utilizing the closest analogies between two systems maymake your port easier in the short run but will not necessarily improve yourcode.andM;640Kb + 4Mb = 640KbandM;Ironically the biggest single memory-related problem that Mac programmerswill encounter on Windows is not discernible anywhere in the program listingof GENAPP.andP;  This obstacle is the 640Kb memory limitation imposed by DOS.andM;Unlike the problems already discussed, this one has no visible effect on ourprogram code (in terms of the language syntax or constructs used).andP;  And itcan be safely ignored by toy programs like GENAPP.andP;  But writers of largerreal-world applications on Windows will face this issue time and again.andM;Apple encourages Mac programmers to think of the Toolbox as if it were almostpart of the hardware.andP;  The mouse tracking software on the Mac is as close tothe hardware as you can get without being hardwired into the 6800 instructionset.andP;  This is why the cursor movement on even an old Mac 128 feels smootherand more responsive than the cursor motion on a 386 machine running Windows.andM;Windows is based on lessons learned in part from the Mac, so its API is moreelegant and ambitious than the Mac Toolbox.andP;  Although its programminginterface is better, the resulting programs sometimes have a slightly clunkyfeel compared to their Mac versions.andM;The Windows environment is, strictly speaking, an application-level programrunning on top of an operating system which was never designed to support it.andO;The 640Kb that MSDOS gives you is meant to be shared among the operatingsystem, the windowing environment, your application program's code and data,and the code and data of any other application programs that the user willhope to run at the same time.andM;Mac programmers are used to taking the cover off their machine, putting in4Mb worth of memory chips and having close to 4Mb of memory show up on theFinder About box.andP;  On DOS systems, you can take the cover off the machine,put in 4Mb worth of memory chips, and you'll still have less than 640Kbavailable when you start Windows.andM;Windows/386 helps alleviate much of this problem for non-Windows old apps(such as Lotus 1-2-3), by giving each of them their own 640Kb virtualmachine, but ironically Windows apps (such as Meta Software's Design) arestuck having to share the same cramped 640Kb machine with Windows itself.andM;It is any wonder that longtime DOS users are excited about OS/2, which breaksthe 640Kb barrier?andP;  Mac programmers may be unaware of the various kludgesthat let you add memory to your machine without breaking the 640Kb barrier.andO;Expanded memory is a pretty good kludge, and you'll probably need to knowabout it to get your Mac program running on the PC.andP;  The ultimate kludge isthe recently unveiled HIMEM.SYS, which goes through major contortions inorder to provide DOS with another 64Kb.andP;  HIMEM.SYS is a sure sign that DOS isin its death throes.andP;  Forward to OS/2 and Presentation Manager!andM;There are several practical ramifications of this particular MS-Windowsconstraint:andM;* The usual space/time tradeoff when writing programs no longer holds.andO;Programmers on other systems are used to increasing a program's datarequirements in order to improve execution speed (for example, by cachingcomputed results for later use).andP;  On Windows, if you increase the run-timesize of your application, you may invoke lots of disk swapping and memoryshuffling and suffer a huge performance loss.andM;* Space is always at a premium, and needs to be considered in all decisions(for example, in deciding whether to use large model or medium model).andM;One advantage of the additional discipline imposed in writing for Windows isthat memory-conserving techniques have become more valuable on the Mac withthe advent of MultiFinder, as users find that 2Mb is not really very muchwhen you are running several applications.andP;  The small tightly codedapplication is bound to be preferred in any environment over its fatter,slower competitors.andP;  In many other ways as well, MultiFinder is helping bringthe Macintosh and Windows worlds closer together.andM;You Can Do It!andM;We have presented many details in this article that make it seem as if thepath from the Macintosh to Windows is a dangerous one.andP;  The large PC marketis inviting, but is it worth the difficulties with nonsquare pixels,eight-character filenames, and having to really lock memory handles?andP;  The PCworld may seem strange compared to the simplicity of the Mac, but it is animportant market, and Windows and OS/2 have done a lot to improve the qualityof PC computing.andM;Don't be misled by all the minor problems discussed here into thinking thatporting Mac programs to the PC is enormously difficult.andP;  Our interest inseeing much of the Mac software migrate to the PC, made us want to include asmany details as possible.andM;On the other hand, we have only scratched the surface.andP;  We coveredQuickDraw/GDI, event management, and memory management, and we presented ageneral approach to porting code.andP;  However such topics as printing,scrolling, the clipboard, dialog boxes, text editing, file management, andmore are completely missing from this discussion.andM;In some of these areas, the parallels between Windows and the Mac are veryclose, while in others the differences are sufficiently large that it shouldbe interesting developing a higher-level interface.andP;  Finally an additionalbenefit you will find, is that programming for more than one environment willmake you a better programmer in your favorite environment.andO;</TEXT></DOC>