<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-777-228  </DOCNO><DOCID>08 777 228.andM;</DOCID><JOURNAL>Data Based Advisor  August 1990 v8 n8 p40(4)* Full Text COPYRIGHT Data Based Solutions 1990.andM;</JOURNAL><TITLE>Fast types: to optimize your Clarion programs, make sure you usethe right data types. (includes related article briefly describingthe new 2.1 version of Clarion) (column)</TITLE><AUTHOR>Hanson, Mike.andM;</AUTHOR><SUMMARY>The manner in which Clarion data base management system (DBMS)data types are used determines how efficiently a Clarionapplications runs.andP;  The eight Clarion field (data) types areSTRING, BYTE, SHORT, LONG, REAL, DECIMAL, MEMO and GROUP.andO;Strategies for optimizing the use of each type are described andexemplified by a sample file declaration.andP;  A series of changes inthe file declaration compact the file to half the size whiledoubling the speed of the program.andM;</SUMMARY><DESCRIPT>Product:   Clarion Professional Developer 2.0 (Data base management system)(programming).andO;Topic:     Performance ImprovementProgramming InstructionTutorialData Base Management SystemsOptimizationData TypesUtilization.andO;Feature:   illustrationprogram.andO;Caption:   Two code examples. (program)A file declaration and revised file declaration. (program)andM;</DESCRIPT><TEXT>When you create files in Clarion you have a  number  of options.andP;  The firstdecision you'll have to make concerns field types.andP;  Clarion has eightdifferent data types: STRING, BYTE, SHORT, LONG, REAL, DECIMAL, MEMO, andGROUP.andP;  How you use data types can determine how efficiently your programruns.andP;  In this article, I'll explain how to optimize your use of each type.andM;STRINGandM;A STRING variable is used to store alpha-numeric information like a name orzip code.andP;  A STRING can be from one to 255 characters long.andP;  The interestingthing about a STRING is that you can declare it using a picture rather thanspecify its length.andP;  I know this sounds confusing, so here are two codeexamples to clarify things.andM;! ----- Example 1 ----- !andM;PROGRAMandM;s          STRING(5) !5 characters longandM;CODEandM;S = FORMAT (1234, @N.5)andM;SETHUE(7,0); BLANK; SETHUEandM;SHOW(J,J,S)andM;ASKandM;! ----- Example 2 ----- !andM;PROGRAMandM;s          STRING(@N5) !Picture andless;,andless;andless;#andM;CODEandM;S = 1234andM;SETHUE(7,0); BL=; SETHUEandM;SHOW(1,1,S)andM;ASKandM;The difference between the two examples is that the FORMAT is implied in thesecond.andP;  When you declare a STRING using a picture, it'll always try toformat any number assigned to it.andP;  Alternately, if you assign it a stringvalue rather than a numeric value, it won't convert it.andP;  In most cases,you'll probably use the STRING type for normal text information.andM;BYTEandM;BYTE is a small positive integer less than 256 (values range from 0 to 255).andO;You normally use this to count an entity that never exceeds 255.andP;  A goodexample of this is children.andP;  (It's very unlikely that an individual wouldhave more than 255 children.)andM;SHORTandM;This is equivalent to the 8086's two-byte signed integer.andP;  If you're notfamiliar with this terminology, a SHORT variable will hold any integer valuefrom -32,768 to 32,767.andP;  1 normally use SHORTs in two situations.andP;  The firstis a four-digit sequence number that will never exceed 10,000.andP;  The other isthree-digit sequence number that may be too big for a byte (maximum 255), butwill never exceed 1,000.andM;LONGandM;A LONG is similar to a SHORT, except that it's four-bytes long rather thantwo.andP;  These means it can represent integers that range from -2,147,483,648 to2,147,483,647.andP;  As you can see, it's reliable up to nine digits.andP;  It worksfine for a seven-digit phone number, but it won't work if you need to includethe area code.andP;  It's also used internally by Clarion for record pointers.andO;LONGs come in very handy as sequence numbers.andP;  Most of the files I createcontain more than 10,000 records but fewer than two billion (I hope).andM;REALandM;This variable type is commonly referred to as a floating-point variable.andO;That means it represents fractional amounts of numbers with a varying numberof decimal points.andP;  Because I usually create business databases, I almostnever use REALs.andP;  They're more commonly found in scientific applications.andO;They're also used internally to do non-integer math.andP;  In situations where Ineed to manipulate fractional numbers, I typically use a DECIMAL.andP;  A REAL canrepresent any number from 4.19x10-307  to 1.67x10 308 (positive or negative)and uses eight bytes of storage space.andM;DECIMALandM;This is a special type of variable that can hold a fixed number of decimaldigits.andP;  The decimal point can be inserted anywhere within the number.andP;  Avariable declared as DECIMAL(5) is a five digit, signed integer.andO;DECIMAL(10,2) could be used to declare a monetary amount ranging from $99,999,999.99 to $99,999,999.99.andP;  (Note that there are a total of 10 digitsin this number with two decimal places.) DECIMALs require a half-byte perdigit, plus an additional half-byte for the sign.andP;  DECIMAL(5) uses threebytes and DECIMAL(10,2) six bytes.andM;MEMOandM;MEMO fields are used to hold large blocks of data.andP;  It might be either textor binary data, depending on how you handle it.andP;  Memo fields can be from onebyte to 64K.andP;  However, MEMOs are stored in 252-byte sections.andP;  That meansthat if your memo is less than 252 bytes, you should use a string.andP;  If yourMEMO is 1,000 bytes long but you're using fewer than 500 bytes, only two252-byte sections will be saved on disk.andM;The one performance problem associated with MEMO fields is that they'restored in separate files.andP;  When a record is retrieved, the MEMO is loadedfrom a different file, which can easily triple the access time.andP;  If only afew records in a given file are going to contain MEMO information, I normallyput the MEMO into a separate file.andP;  That way I can retrieve the MEMO onlywhen I definitely need it.andP;  This inflicts programming overhead, so you shouldonly use it when MEMOs are few and far between.andM;GROUPandM;A GROUP is much like a string, except that it can enclose other variables.andO;There are many uses for GROUPs (far too many for me to mention here), butI'll cover one particular example shortly.andM;Dates and timesandM;There are two other common types of data that aren't directly represented inClarion: dates and times.andP;  In Clarion, dates are simply five-digit numbersthat are converted to meaningful values by the display and edit routines.andO;Instead of having a DATE variable type, you can use DECIMAL(5), which usesthree bytes of storage.andP;  A time variable is similar, except that it requiressix digits.andP;  We could use DECINUL(6), but it would require four bytes ofstorage (the same as a LONG).andP;  Because LONGs are more intrinsic to the 8086architecture, they're handled quicker than Clarion's DECIMALs.andP;  So use a LONGfor storing time values.andM;File 1/0 benchmarksandM;Here's a simple Clarion file declaration.andP;  It contains very basic customerinformation, such as customer number, name, phone number, birthdate, numberof children, salary, and average payment.andP;  In addition, there are two keysfor the name and customer number.andP;  A few of these fields are somewhatimpractical, but they'll do just fine for our purposes.andM;Customer         FILE,CREATE,RECLAIMandM;NameKey             KEY(LName,FName),DUP,NOCASEandM;SeqNoKey            KEY(SeqNo)andM;Record              RECORDandM;SeqNo                 LONGandM;LName                 STRING(30)andM;FName                 STRING(20)andM;Phone                 DECIMAL(10)andM;PhoneExt              SHORTandM;Birthdate             DECIMAL(5)andM;NChildren             BYTEandM;Salary                DECIMAL(10,2)andM;AvgPayment            REALandM;As you can see, I use a LONG for the customer sequence number (SeqNo), twoSTRINGs for the first and last names, a 10-digit DECIMAL integer for thephone number, a SHORT for the three-digit extension, a byte for the number ofchildren (less than 255), a 10-digit, two-decimal point DECIMAL for thesalary, and a REAL for the average payment (I want to record minute fractionsof a penny).andM;I've done a number of benchmarks to get a feel for what operations take themost time.andP;  I've also compared a variety of optimization techniques to helpdetermine where I should concentrate my speed-up efforts.andM;My sample database contains 1,000 records.andP;  I'm running on a 25MHz 386 fromGateway 2000.andP;  The hard disk is a 25 ms Microscience 160M drive run by anUltrastor 12(F) ESDI controller.andP;  I defragmented the partition and disabledSuper PCKwik before testing.andP;  All times are in seconds.andM;The &quot;unoptimized&quot; data type timing testsandM;File creation (no keys) 27.32andM;Name key creation              7.53andM;SeqNo key creation             2.91andM;Sequential file orderandM;The first few tests involve reading the file in a variety of ways.andP;  UsingClarion you can read a file in order by physical position in the file or bykey value.andP;  For each of these two methods, you can retrieve recordssequentially or randomly.andP;  In each subsequent test I slowly tweaked the codeto get some useful numbers.andP;  The first test is a sequential read in fileorderandM;SET(Customer)andM;X# = CLOCK()andM;LOOP UNTIL EOF(Customer)andM;NEXT(Customer)andM;.SHOW(1,1,(CLOCK()-X#)/100); ASKandM;This program took 2.69 seconds to complete.andP;  For each iteration of the loop,the routine goes to the disk to get the next record.andM;To speed this up, the next program contains a BUFFER(Customer, 100) statementafter the SET(Customer) statement and a FREE(Customer) statement at the end.andO;This tells Clarion to get 100 records when it gets the first record.andP;  Thesubsequent 99 reads are done from memory rather than disk.andP;  Then the disk isqueried for another 100 records, and so on.andP;  Making this modificationdecreased the time to 2.14 seconds.andM;For the next test I simply increased the buffer size to 1,000 records.andP;  Idiscovered that it still took 2.14 seconds.andP;  This suggests that there is alimit to the performance increases obtained using buffered reads.andP;  Sequentialkey orderandM;The next set of tests are also sequential, but they use the key order ratherthan the file order.andP;  The first program simply reads the records in Nameorder, without optimization.andM;SET(NameKey)andM;X# = CLOCK()andM;LOOP UNTIL EOF(Customer)andM;NEXT(Customer)andM;.SHOW(1,1,(CLOCK()-X#)/100); ASKandM;You'll notice that the only difference in this code is in the SET command,which refers to a key (NameKey) rather than a file (Customer).andP;  This bit ofcode took 16.92 seconds.andM;Again, I decided to try the BUFFER command even though I knew it wouldn'thelp.andP;  After making the change and testing it, I discovered that it tookprecisely the same amount of time as the unbuffered code.andP;  Why? BecauseBUFFER is used to read the file in physical order, not key order.andP;  Using theBUFFER statement simply forces the system to hop around the file a littlesooner.andM;I removed the BUFFER statement and added CACHE(NameKey,2) in its place.andP;  TheCACHE statement causes a portion of the key file to be read into memory.andO;This actually increased the time to 16.97 seconds.andP;  I triedCACHE(Customer,1), which loads the entire key file into memory, and itregained an inconsequential bit (16.09 seconds).andP;  This isn't as strange as itsounds.andP;  We're reading the file in key order, and Clarion's key files aresorted in key order.andP;  The time consuming task here involves reading therecords corresponding to the keys, not reading the key file.andP;  BecauseCACHE(NameKey,2) doesn't load a sequential portion of the key file intomemory, we actually lose performance by using it.andP;  CACHE(NameKey, 1) loadsthe entire key file into memory (only because the key file is small), whichis similar to the BUFFER statement when processing in file order.andM;Random key orderandM;To test random access using a key, I used the SeqNo key.andP;  Before beginningthe random access tests, I duplicated the sequential key order tests usingSeqNoKey rather than NameKey.andP;  The non- cached time was 3.46 seconds; thecached time using CACHE(SeqNoKey,1) was 3.08 seconds.andM;The random access test involved looking for a randomly-generated SeqNo 500times.andP;  Without caching this took 17.24 seconds.andP;  With CACHE(SeqNoKey,2)  ittook 16.37 seconds.andP;  With CACHE(SeqNoKey, 1) it took 8.34 seconds.andP;  The moralof this story is that you should load as much of the key file into memory aspossible.andM;Update a fileandM;So far all we've done is read data from the file; we haven't actually writtenanything.andP;  The next test involves reading each record, changing one field,then rewriting the record.andP;  Without optimization, the test took 150.49seconds.andM;The first step I took was to STREAM and FLUSH the file.andP;  During fileprocessing, Clarion closes the file after each write.andP;  Although thismaintains the highest file integrity possible, it's very slow.andP;  For manyoperations it's quite acceptable to close the file after completing a batchprocess, rather than after each individual write.andP;  The STREAM command doesjust that, while the FLUSH command reverts the system to normal.andP;  AfterSTREAMing the operation, it ran in 24.12 seconds (much better).andM;Finally, since we're processing in file order, we can use the BUFFER command.andO;After adding BUFFER(Customer, 100) to the code, the operation took 15.54seconds (approximately one tenth of the original time).andM;Saving space and time with groupsandM;The data file for this test case is approximately 80K.andP;  The name key is 66K.andO;Because the last and first name fields are rarely full, we can use only aportion of the fields for the key.andP;  This is where groups come in.andP;  Here's thenew file definition:andM;Customer          FILE,CREATE,RECLAIMandM;NameKey             KEY(LName_,FName_),DUP,NOCASEandM;SeqNoKey            KEY(SeqNo)andM;Record              RECORDandM;SeqNo                  LONGandM;LName                  GROUPandM;LName_                   STRING(15)andM;STRING(15)andM;FName                  GROUPandM;FName_                   STRING(10)andM;STRING(10)andM;Phone                  DECIMAL(10)andM;PhoneExt               SHORTandM;Birthdate              DECIMAL(5)andM;NChildren              BYTEandM;Salary                 DECIMAL(10,2)andM;AvgPayment             REALandM;..As you can see, the name fields are now GROUPS, but they'll be treated as ifthey were still STRINGS.andP;  Within each group are two smaller strings, onelabeled and one unlabeled.andP;  The labeled string is used for the key.andP;  Afterthis modification, the key file is half the size, and the program operatestwice as fast.andM;PrecautionsandM;There's one thing you should always remember to do.andP;  If you turn optimizationon, you have to shut it off when you're done.andP;  The three optimization pairsare as follows:andM;BUFFER(File); FREE(File)andM;CACHE(Key);      FREE(Key)andM;STPEM(File);     FLUSH(File)andM;After playing with these techniques, you'll start to understand when they'rehelpful.andP;  All it takes is a little practice.andM;For next timeandM;The next subject I'll cover is pick tables.andP;  I'll discuss a variety ofoptions for marking choices on a table.andP;  There are many ways to accomplishthis feat-using everything from menus to fancy repeat structures.andP;  Watch forit !andP;  Mike Hanson is affiliated with a number of software consulting firms,including his company, BoxSoft Development.andP;  He has written applications in avariety of languages since 1985 and used Clarion since version 1.1.andP;  You canreach him through the Data Based Advisor Readers Exchange BBS, (619)270-2042, or on the Clarion BBS, (305) 785-9172.andP;  3andM;* Quick Look at Clarion 2.1andM;It's early May and I've finally got my copy of 2.andP;  1! I must say I'm veryhappy with many of the new features.andP;  My biggest thrill came from the newversion of Designer.andP;  It now generates only the modules that you change,which can save hours of generate-and-compile time.andP;  It also consumes far lessmemory than its predecessor.andP;  A number of my applications became so large,Designer could no longer load them.andP;  I had to swap my VGA card for amonochrome card so QEMM could give me an extra 60K of memory.andP;  Theapplications that required 660K to generate under 2.0 survive in 520K underversion 2.andP;  1.andM;For those of you who use overlays, a Clarion-specific version of RTLink fromPocket Soft is included with Clarion 2.1.andP;  This will save you the cost of anoverlay linker.andM;Clarion's also bundled its ad hoe report writer with the package.andP;  It letsyou create extremely complex reports without writing a single line of code.andO;This can be extremely helpful for adding robust reporting capabilities to analmost-finished application.andP;  Or you can let your users buy a standalone copyof Report Writer and create their own reports, since it's easy to use.andP;  Itcan send reports to the screen, printer, or disk.andM;There is, however, one aspect of the new version that has severelydisappointed me.andP;  All the documentation has been rewritten-which is good.andO;All of the old READ.ME files have been incorporated into the manuals-alsogood.andP;  And there are many new examples to help you understand various aspectsof the language-wonderful.andP;  The problem lies with the new format.andP;  The oldmanuals came in standard three-ring binders.andP;  Rather than continue thistradition, Clarion chose to publish their manuals in paperback form, likeBorland's Paradox.andP;  This is fine if you only read the manuals once.andP;  Oddlyenough, I like referring to my manuals daily.andP;  There's nothing morefrustrating than a book that won't stay open.andP;  When you finally train it tostay down, it starts falling apart.andP;  Sure, you're thinking, what a spoilsport.andP;  Well, I have a novel idea: why not offer an alternate set of themanuals for those who prefer the original format? Your move, Clarion.-MikeHanson</TEXT></DOC>