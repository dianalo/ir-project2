<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO> ZF32-041-260 </DOCNO><DOCID>11 445 185</DOCID><JOURNAL>C Users Journal  Oct 1991 v9 n10 p40(9)* Full Text COPYRIGHT R andamp; D Publications Inc 1991.andM;</JOURNAL><TITLE>Debugging instrumentation wrappers for heap functions. (tutorial)</TITLE><AUTHOR>Ward, Robert.andM;</AUTHOR><SUMMARY>Effective heap instrumentation can be built with a few lines ofcode.andP;  Existing code can be retrofitted with simple pre-processortricks.andP;  The preprocessor can be used to attach instrumentation tothe heap allocation and de-allocation functions.andP;  There are twogeneral categories of heap bugs: sequencing errors and pointerdamage.andP;  Both categories can cause hidden damage to the internalstructure of the heap.andP;  This damage is not always immediatelyapparent, and may not be noticed until thousands of lines of codelater, thus becoming difficult to trace.andP;  A heap is a datastructure initialized by the system and can be damaged by attemptsto write or copy through an invalid pointer.andP;  Heap problems arerelatively easy to find by using a set of tools in combinationwith a breakpoint debugger.andM;</SUMMARY><DESCRIPT>Topic:     TutorialProgramming InstructionHeapsDebuggingSource CodeDebugging ToolsDynamic Programming.andO;Feature:   illustrationchartprogram.andO;Caption:   Space allocated by malloc. (chart)Modified malloc wrapper. (program)New object structure. (chart)andM;</DESCRIPT><TEXT>While modern debuggers like CodeView and Turbo Debugger supply at least someminimal tools for dealing with most types of bugs, neither supply anymeaningful facilities for finding bugs affecting the heap.andP;  Fortunately, youcan build some very effective heap instrumentation with only a few lines ofcode.andP;  Moreover, using some simple pre-processor tricks, you can retrofitexisting code with this instrumentation.andM;Heap bugs fall into two general classes: sequencing errors and pointerdamage.andP;  Both kinds of bugs can potentially cause hidden damage to the heap'sinternal structure, damage that may not become visible until thousands oflines of code later.andP;  Such delayed-symptom bugs are very difficult to traceto their causes using the built-in tools in typical breakpoint debuggers.andM;In this article, I'll show you how to use the preprocessor to attachinstrumentation to the heap allocation and deallocation functions.andP;  Thisinstrumentation, used together with a sort utility, can quickly and easilyidentify sequencing errors in even large and complex programs.andP;  In additionto identifying sequencing errors, the instrumentation will generate theinformation you need to quickly identify the cause of the error (using yourbreakpoint debugger).andP;  Later, I'll suggest ways you can enhance the generalframework to add protection against freeing a damaged dynamic object.andM;The tools presented here, however, won't be of any help if you have a pointerbug that is directly writing on the free list.andP;  The heapwalk functionsupplied with your compiler is your tool of choice in that situation.andM;Sequencing ErrorsandM;By sequencing errors, I mean bugs created by incorrectly allocating orfreeing dynamic memory.andP;  An example is attempting to free an object thatwasn't created through a call to calloc or malloc.andP;  Another is failing tofree an object before allowing its pointer to go out of scope, or attemptingto free an object that hasn't yet been allocated.andM;The standard free supplied with many compilers fails to detect even the mostcommon sequence errors, and instead blindly links some piece of garbage intothe heap, potentially causing malloc to get very confused when it laterattempts to create new objects from this garbage space.andP;  Unfortunately thecorresponding malloc function is seldom intelligent enough to know it isconfused.andP;  malloc assumes afl is well and builds the requested object - butit may build the new object from heap space already used by some other activeobject, or from space on the stack, or from space in static memory.andM;While sequencing errors are generated by errors in program logic, theyfrequently result in symptoms that appear to be completely unrelated to theprogram's logic.andP;  For example, if you accidently free a local variable, yourprogram might run normally until some subordinate subroutine attempts toreturn.andP;  If you fail to free some dynamic object, the program will probablyrun correctly for long periods of time and then suddenly fail when it can nolonger allocate new objects.andM;In all cases, you are not guaranteed any visible cause-and-effectrelationship between the erroneous code and the visible symptoms.andM;While you can locate sequence errors by meticulously tracing and validatingevery dynamic memory operation in your program, only masochists would want todo so.andP;  Single-stepping and other kinds of tracing can be effective methodswhen you have some clues about where to find the cause.andP;  In this instance,your only clue is that the error involves some call to malloc or free,somewhere in your program.andM;Pointer DamageandM;Because the heap is simply a data structure (albeit, one initialized by thesystem instead of by your application code), it too can be damaged byattempts to write or copy through an invalid pointer.andP;  Unallocated portionsof the heap are linked into a &quot;free list.&quot; If a pointer operation shouldoverwrite one of the nodes in this list, the list will be corrupted.andO;Allocated objects also contain hidden bookkeeping information that allowsfree to efficiently return the object to the free list.andP;  If this hiddeninformation is overwritten, free will corrupt the free list when it tries todeallocate the object.andM;Sequence InvariantsandM;It's simple to write a set of rules that identify correctly sequenced dynamicmemory operations:andM;Every unique object is allocated exactly once.andM;Every unique object is freed exactly once.andM;An object is allocated before it is freed.andM;These rules are always true (invariant) for every correct dynamic memoryoperation.andP;  Whenever you can describe correct behavior with simple rules likethese, you should look for a way to automate exception detection.andP;  When youdo, you've automated some of your debugging effort.andM;To detect exceptions to these rules, you must generate for each dynamicmemory operation a record of what object was involved and what operation wasperformed.andP;  I enforce this record keeping by wrapping the real calls tomalloc and free in a &quot;debugging wrapper.&quot; (See Listing 1.) Using thepreprocessor, I redefine malloc and free everywhere except within thiswrapper.andP;  The redefined calls invoke the wrapper function which then invokesthe real function.andM;Each wrapper function writes a record in a debugging log file on each call.andO;The malloc function writes a record consisting of the pointer to the newobject, the word &quot;anew&quot; (chosen, like the 99999, to force the &quot;new&quot; record tosort before the &quot;free&quot; record) and the serial number assigned to thisinstance.andP;  The free wrapper reports the pointer value and the word free.&quot;andM;To add this instrumentation to any program, you merely #include Listing 1 inevery file that performs calls to malloc or free and #define the preprocessorvariable DEBUG, as illustrated in Listing 3.andP;  The #include should appearearly in the program, but since the header defines all its own data (and evenopens its own files on demand), you have considerable latitude in the exactplacement.andM;Listing 3 is a simple tree sort, structured as a filter, complete with twointentional errors.andP;  If you need a sort utility and don't care about highperformance, you can remove the lines marked /* error */ and recompile.andP;  InListing 3, I've defined DEBUG in the code.andP;  If instead you define DEBUG onthe compiler command line, you can generate both test and production versionsof your code without editing the file.andM;The reported pointer value together with the serial number uniquely identifyeach allocated object.andP;  Unfortunately, with this implementation, the serialnumber is no longer available when the object is freed - so the object cannotbe uniquely identified when it is freed (two dynamic objects might have usedthe same heap space at different times).andP;  Some programs (Listing 3, forexample) always use dynamic objects in a FIFO pattern.andP;  For such programs,the simple wrapper of Listing 1 is adequate.andM;Other programs will require a more complex wrapper, one that not only insertsinformation-logging code, but that also modifies the structure of the dynamicobject.andP;  The malloc wrapper in listing 2 requests a block of memory largerthan that needed by the application, inserts the serial number at thebeginning of the allocated block, and then returns a pointer to spacefollowing the serial number (see Figure 1).andP;  The serial number will now beavailable to the free wrapper, but is hidden from the application.andP;  Theapplication thinks the pointer it receives points to the beginning of theallocated object.andP;  In fact, the application receives a pointer that points tojust after the start of the allocated object, but since the object is nowlarger than expected, the deceit is harmless.andM;The application will invoke free with the same offset pointer.andP;  The freewrapper will use pointer arithmetic to back up to the true start of theobject and use that corrected pointer to invoke the standard free function.andM;Additionally, to make it easier to identify particular free operations, Ihave added a separate counter for calls to free.andP;  This second &quot;serial number&quot;is printed to the right of the word &quot;free&quot; in the log entry.andM;With this enhancement, both wrappers can know and report the allocationserial number, guaranteeing a unique object identifier for both free andmalloc operations.andM;Detecting ExceptionsandM;Running the sort program of Listing 3 with the simple form of logging enabledproduced the log file in Listing 4.andP;  I used a correct sorting program toproduce the sorted file in Listing 5.andP;  For a short file, sorting is enough tomake the sequencing errors obvious.andP;  For more complex runs, producing verylong log files, sorting isn't enough.andP;  The program in Listing 6 is a smallstate machine (see Figure 2) that operates as a filter.andP;  Its input is asorted log file, its output is a list of sequencing errors.andP;  I created thetest data in Listing 7 by editing the log file from a normal run with theenhanced logging enabled.andP;  Listing 8 shows the result of feeding this testfile to the exception filter.andM;Finding The BugandM;These three pieces (instrumentation wrappers, sort utility, exception filter)will tell you if your program commits a sequencing error - they won't tellyou what part of the program commits the error.andP;  However, you can use theserial numbers of the object and the free call together with your breakpointdebugger to find the code involved.andM;First, you must be able to control input well enough to exactly replicate therun that produced the log file.andP;  Exact replication will be easiest if you canredirect input from a file.andP;  If you can't, consider using the wrappertechnique to add &quot;debugging input&quot; capabilities to the low-level inputroutines.andM;Once you can replicate a run that includes a sequencing error, load theapplication under the debugger and set a breakpoint at the beginning ofmalloc.andP;  Use the reported serial number to set a passcount for thisbreakpoint.andP;  Start the application.andP;  It should stop on the malloc call thatcreates the object involved.andP;  Using a stack traceback and other browsingtools, you should be able to identify the calling context.andP;  If the sequencingerror involved an improper free, you would follow the same process, but setthe breakpoint at the beginning of free and use the free serial number as thepass count.andM;Adding FencepostsandM;The malloc function hides heap-related information in front of the pointer toeach dynamic object - just as my instrumentation wrappers do.andP;  If an errantpointer writes over this information, the heap will be corrupted when theobject is freed.andP;  Since dynamic objects are physically adjacent to oneanother in memory, damage to the hidden information in one dynamic object isusually the result of writing beyond the end of some other dynamic object.andM;In Listing 9, I've modified the malloc wrapper so that it adds some paddingto the end of the object as well as the beginning.andP;  The malloc wrapper storesan infrequently used pattern (a signature word) in this trailing space,creating a fencepost.andP;  Now the program can't write beyond the end of theobject without destroying the signature.andP;  The free wrapper checks thesignature word and reports any change.andP;  Note that the leading pad has beenexpanded to include size information.andP;  The free wrapper must know the size ofthe object to know where to look for the fencepost.andP;  If the fencepost hasbeen overwritten, the free wrapper will write a &quot;damaged object&quot; message inthe log.andP;  Figure 3 shows the new object structure.andM;If you know enough about your compiler's heap mechanism, you can avoidstoring the size.andP;  The standard heap routine is already storing sizeinformation somewhere in the dynamic object - you just need to figure out howto access it.andP;  I prefer this redundant method because it's easier tounderstand and adapt to different compilers.andM;CaveatsandM;My wrappers assume that every dynamic object is created with malloc.andP;  If yourprogram uses realloc or calloc you will need to create separate wrappers (andseparate serial number statics) for those functions.andP;  Also, since thewrappers replace function calls with macro calls, they may break existingcode that has side-effects in the arguments to the malloc or free calls.andO;(However, the nature of these functions would naturally discourage suchusage).andM;All code presented here was tested with Turbo Debugger in small model.andP;  Forother models and compilers, you may need to modify the pointer arithmetic inthe wrappers.andM;ConclusionsandM;This set of tools isn't subtle, complex, or particularly original, but whenused in combination with a breakpoint debugger, they make heap problemsrelatively easy to find.andM;More important, the techniques and ideas used in this package transport tomany debugging problems.andP;  Instrumentation wrappers can often be used toattach debugging code to critical functions.andP;  Serial numbers are usefulanytime you are debugging dynamic data structures.andP;  Fenceposts can even beinserted between static data elements and used to detect out-of-range writes.andM;Effective debugging, like effective programming, depends upon mastering arange of tools and applying them in appropriate combinations.andO;</TEXT></DOC>