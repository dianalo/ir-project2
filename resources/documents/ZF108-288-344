<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-288-344  </DOCNO><DOCID>08 288 344.andM;</DOCID><JOURNAL>AI Expert  April 1990 v5 n4 p38(8)* Full Text COPYRIGHT Miller Freeman Publications 1990.andM;</JOURNAL><TITLE>Factories, objects, andamp; blackboards. (artificial-intelligence-basedfactory control systems)(includes related article on proportionalintegral derivative controllers)</TITLE><AUTHOR>Larner, Daniel J.andM;</AUTHOR><SUMMARY>'Blackboard' architectures for building intelligent factorycontrol systems such as proportional integral derivative (PID)controllers are discussed.andP;  A blackboard architecture allowsmodular knowledge representation and inference, and it offersmechanisms implementing a variety of reasoning strategies.andP;  Asample blackboard framework, Distributed Operating System-basedBlackboard Architecture for Real-time control (DOSBART) ispresented.andP;  DOSBART can be partitioned to run on multipleprocessors but is not based on a distributed operating system.andP;  Anarbitrary LISP form allows one machine to initiate computation onanother.andP;  The system uses data servers, which encapsulate andstructure data, and activities, which have expected-CPU andinterrupt-function slots, as its basic objects.andP;  DOSBART combinesAI technologies with object-oriented programming and networkingprinciples.andM;</SUMMARY><DESCRIPT>Topic:     Factory ManagementProcess ControlKnowledge-Based SystemsArtificial IntelligenceDistributed Systems.andO;Feature:   illustrationcharttable.andO;Caption:   PID control. (chart)Limitations of conventional control framework. (table)Data server class hierarchy. (chart)andM;</DESCRIPT><TEXT>FACTORIES, OBJECTS, andamp; BlackboardsandM;The word &quot;factory&quot; conjures up a spectrum of environments ranging from thehot, dirty recesses of an aging foundry to the pristine, robotic whir of amodern assembly line.andP;  All these domains are the realm of factory controlsystems.andP;  Besides contending with physical concerns such as harshenvironments, restrictive geometry, and multiple I/O connections, thecontroller must adequately serve the logical aspects of the control task.andM;For example, to produce paper from raw materials, a mill uses many steps; oneof the first is to create pulp.andP;  Trees are transported to a chipper thatgrinds the wood to a particular size.andP;  The grind must be correct for thequality of paper produced.andP;  Next, proportions of ground material and liquidcombinations are placed in a cooking and mixing vessel.andP;  Here the mixture iscooked and pumped into storage tanks to await pressing into paper.andP;  Thisdescription is enormously simplified but it illustrates the types ofprocesses control engineers tend to think about: continuous and discrete.andM;Grinding and cooking actions are examples of continuous processes.andP;  Theseparation of the chipper cutters must be continuously adjusted to ensureproper grind size; the temperature of the mixture must have a certain profileso the appropriate chemical changes may take place.andP;  Proportional integralderivative (PID) controllers (Figure 1) are a classic continuous-controlapproach.andP;  The difficulties encountered with PID controllers include how toset the gains initially and modify them when process characteristics orcontrol goals change.andM;Sequencing the actuation of valves and pumps to route the fluids is anexample of a discrete process.andP;  These ordered operations tend to have anon-off nature.andP;  For discrete control, a typical programmable controllerinterprets ladder-diagram programs.andP;  (This representation is an artifact fromwhen control logic was implemented with relays.)andP;  Relays and switches form aladder &quot;rung&quot; on the wiring diagram that connects power to a load.andP;  Figure 2shows some simple functions.andM;This language is complete in that we can perform the basic logical operationsthat support everything else.andP;  However, it lacks representational andexpressive power when building an intelligent factory controller.andP;  Imagineusing ladder diagrams to construct an embedded expert system that diagnosesanomalous behavior.andP;  Table 1 lists a smattering of problem types difficult toaddress with current factory controllers and some of the technologies thatmay help solve them.andP;  What's needed: a more sophisticated framework forprogramming and embedding these approaches toward intelligent control.andM;Blackboard architectures provide many of the required qualities for such aframework: they allow modularity in knowledge representation and inference,freedom of control, and mechanisms that implement a variety of reasoningstrategies.andP;  [1,2]  Blackboard architectures furnish abstractions well suitedto real-time control, including event handling, task control, deadlines,simultaneity, and resource allocation.andP;  [3,4]andM;A framework called Distributed, Operating-System based, BlackboardArchitecture for Real-Time control (DOSBART) broadens some features ofblackboard architecture to provide a tool for building real-time controlsoftware and, in particular, distributed AI approaches [5] (running onSun-3s, SPARCstations, TI microExplorers, and Symbolics machines).andP;  DOSBARThas provided intelligent monitoring and diagnostics on a queueing-theorymodel of a production line.andP;  These concepts are also being utilized in thedevelopment of an intelligent real-time controller for a paper pulp process.andM;DISTRIBUTIONandM;In factories, control systems run on many processors tied together byassorted communication mechanisms.andP;  [6]  In the pulp-making process, therecould be a controller for each cooking vessel, for the ingredient tanks, thepumps and valves, and the chipper.andP;  Many arguments can be made fordistribution.andP;  In the pulp situation, handling emergencies in a timely mannermakes response time an issue.andP;  Similarly, failure autonomy is important ifone vessel fails so others may continue processing.andP;  Reduction of wiring isnot as obvious an issue since the pulp process may be spread over a widearea.andP;  The limited capabilities of control computers, whether restricted I/Obandwidth or some other limitation, can also be a justification for multiplecontrollers.andP;  Unfortunately, distribution necessarily burdens the programmerusing current controller languages.andP;  These languages force the distributednature of the system to be taken into detailed consideration and limit thedistribution granularity.andM;DOSBART provides a single blackboard abstraction for control-system designthat can be partitioned to run on multiple processors; the blackboardabstraction for real-time control is gained without sacrificing the benefitsof distribution.andP;  DOSBART is not based on a distributed operating system;[7-9] the system is distributed and operating-system based.andP;  &quot;Distributed&quot;means the system runs on a heterogeneous set of machines connected bycommunications networks over which data sharing and remote computation occurtransparently.andP;  The &quot;operating-system&quot; basis refers to the operating-systemfacilities that create and schedule actions.andP;  A distributed knowledge baseallows knowledge to reside where used most but still be accessible from othernodes.andP;  A mechanism for data and process distribution also facilitatessegregation of activities; for example, a vessel controller may use an I/Opreprocessing subsystem to monitor data changes.andP;  This approach reduces andsmoothes the computational load on the controller since it no longercontinually samples sensor input for changes.andM;For representational purposes, elements of blackboard architectures mapextraordinarily well onto an object-oriented language.andP;  The Common LISPObject System (CLOS) [10,11] is the primary implementation language ofDOSBART.andP;  A DOSBART subsystem called DIStributed Clos Objects (DISCO), builton top of CLOS, is the foundation for distribution.andP;  It allows objects to beshared transparently by DOSBARTs running on distributed machines and, moregenerally, permits methods on objects to be performed either locally orremotely.andM;DISTRIBUTED OBJECT SYSTEMSandM;One requirement for constructing a distributed object system includes afacility for machines to initiate computation on another machine.andP;  Such amechanism can be used for clock synchronization, load balancing, and datasharing.andP;  In the DOSBART subsystem remote-eval, an arbitrary LISP form can besent to another machine on the network.andP;  Upon arrival the form is evaluatedand the result returned to the caller.andP;  The communication necessary toimplement remote-eval functionality can be performed by remote procedure callmechanisms, TCP streams, or both.andP;  A standard interface to the communicationfacilities for each computer platform is maintained by a set of files thatconditionally evaluate interface function definitions based on the LISP*features* list.andM;Second, we need the ability to reference nonlocal objects.andP;  In DISCO, thisreference is provided by a proxy object that acts as a representative of itsconstituent object.andP;  Its class definition looks approximately like Listing 1.andO;The reference to the constituent cannot be made with the usual LISP pointermechanism since the constituent is on another machine; the reference is bymeans of an object identifier (called object ID) given to each object whencreated.andP;  This identifier is unique within the network.andP;  Now the referencesays who the constituent is but not its location: this information iscontained in the residence-host slot.andM;You may wonder why the constituent identifier doesn't contain the locationinformation.andP;  The reason is object migration.andP;  Sometimes an object's locationneeds to be changed (for example, to place objects where frequency of accessis greatest).andP;  The object-finder-form-producer slot provides a means ofinitializing and updating the ID and residence slots.andP;  We want updatecapability since the constituent may move.andM;Note that we can't really pass the objects themselves across the networksince they are locally specific LISP references.andP;  When machines need to referto objects in a communication, they must encode the objects as their IDs andthen decode them on the other end.andP;  Proxies are a special case in the sensethat when a proxy is referenced it normally refers to the proxy'sconstituent.andP;  Thus, proxies are normally encoded as their constituent ID.andP;  Onthe decoding end, if an ID is that of an object in residence, it is decodedas that object.andP;  If it's for an object that is not in residence but wealready have a resident proxy for it (one whose constituent has that ID), wedecode the ID as that proxy object.andP;  Otherwise we have no reference to theobject and we need to create and appropriately initialize a proxy whoseconstituent is the object having that ID.andP;  We then use this new proxy as thedecoding for the ID.andM;A means of redirecting method computations to the machine where the proxy'sconstituent is located is often necessary.andP;  When a CLOS generic function iscalled on a set of arguments and no matching method is found, CLOS calls theno-applicable-method function.andP;  DISCO augments this function with :aroundcode that examines the types of the arguments.andP;  If some of the arguments areproxy objects, the remote eval facility is used to attempt execution of theoriginal call on the residence host of the proxy.andP;  (On these other machines,at least some of the arguments will no longer be proxies; they'll be the realconstituent objects for which an applicable method potentially exists.)andP;  Ifan applicable method is there and the remote evaluation succeeds, the resultis returned as the result of the original call.andM;Figure 3 depicts an activity on a vessel controller modifying the value of aflow object.andP;  This object's value slot is the setpoint for the gallons ofingredient per minute from the tank controlled by the ingredient controller.andO;The flow object is resident on the ingredient controller since it is heavilyreferenced there by control loops.andP;  Flow is represented by a proxy object onthe vessel controller because it references flow only occasionally.andP;  Anactivity on the vessel controller changes the flow value without knowing thatthe object resides on another machine.andP;  The distributed object machinerytransfers this change to the real objects location.andP;  This type oftransparency is our objective: a value change in an object on a distantmachine is seen by the activity as a local event.andM;Errors may occur when a method is performed on another machine; executing amethod remotely may in turn execute more methods remotely.andP;  DISCO definessome error-handling conventions for user code and augments several CLOSmethods with code that &quot;kicks back&quot; the error to the machine where the firstremote call occurred.andP;  This kick-back support builds up an informativemessage as the computation backs out through nested remote calls and passesthis call-trace information to the error-handling code at the originatingpoint.andM;This description of DISCO was greatly simplified.andP;  Many difficult issues needto be resolved, including object termination, migration and replication, andincorporation of nonobjects.andP;  DISCO addresses the common situations and isbut a single approach to building distributed object systems.andM;ORGANIZATIONandM;Having profiled an approach toward distribution transparency we can outlineDOSBART's organizational approach.andP;  The intent is to provide a foundationthat can support the remaining technologies listed in Table 1 in a controlenvironment.andP;  The representation consists of two basic types of CLOS objects:data servers (DSs) and activities.andP;  DSs encapsulate and structure data.andM;A basic DS has a value slot and a primary method of accessing it.andP;  Its classforms the root for a broad level of subclasses, allowing the application tocreate the necessary types of DSs by using CLOS multiple inheritance andmethod combination (Figure 4).andP;  Lockable DSs provide mutually exclusiveaccess to their value.andP;  Preventing more than one activity at a time fromsetting flow rate is one situation where a lock is necessary.andP;  Slots thatcontain the activity holding the lock, reason for access, adn the time eachlock was set can assist metalevel routines attempting to detect conflicts,break deadlocks, and so on.andM;Control systems often contain data and computation that is functionallydependent; flow rate and pressure are related to a pipe's fluid resistance,for example.andP;  These dependencies can be maintained by demoned DSs that runfunctions when the value slot is accessed.andP;  If the temperature changes in themiddle of a complicated heat-transfer calculation, we'd like to incorporatethe new value into the calculation.andP;  Instances of the informing DS classcontain a list of activities whose computation is dependent upon the DS'svalue.andP;  When a change occurs, an interrupt method is invoked on all thedependent activities.andM;Interfaces to the system being controlled are handled by port DSs.andP;  They makeit possible to filter, threshold, log, delay, or simulate I/O.andP;  A blackboardDS ties together DSs and activities associated with each other.andP;  Rule DSshold implications that can be used by the theorem prover in performingplanning and other rule-based reasoning.andP;  Timebase DSs provide clocks thatrun at various rates, can be started and stopped (for timers, alarms, ordebugging), or synchronized to real time.andP;  Queue DSs record state,automatically maintain statistics for quality control and other endeavors,and implement ordered agendas.andM;Parallel execution of knowledge sources is a powerful conceptual principle ofblackboard architectures [12] but is infrequently present in implementations.andO;[13]  Generally, knowledge sources are run serially to completion beforemaking other decisions.andP;  The operating-system basis of DOSBART refers to theuse of existing operating-system facilities to create and schedule actions.andO;DOSBART uses the multitasking (time-sliced) functionality in the operatingsystem to run the blackboard activities, making parallelism real.andP;  Manyissues in real-time control (interrupts, task control, predictability) becomemore readily addressable with this approach.andM;Activities are the organizational structures for computation, each being aninstance of some activity class (Figure 5).andP;  Every activity has anoperating-system process that performs its computation.andP;  The term &quot;activity&quot;is used to distinguish the class from knowledge sources not inherently activeand having no thread of control.andP;  Additionally, the term refers to DOSBART'striggers that are themselves active.andP;  Since the processes are time-sliced bythe operating system, all activities run in parallel.andP;  This is pervasive:triggers run in parallel with knowledge activities, an activity runs inparallel with any children it spawns, and so on.andM;With this approach, interrupts can be caught within a time window the size ofthe operating system's scheduler wake-up interval rather than waiting for anactivity to terminate or explicitly pass control before noticing an interruptor change in data.andP;  (Either one is extremely unpalatable in a real-timecontrol system.andP;  Imagine waiting for the vessel cooking-control loop tofinish its recipe before it was noticed the vessel's mixing motor had caughtfire.)andP;  Triggers are always being checked so events can be detected nearer intime to their occurence.andP;  This technique allows for continuous diagnosticroutines that monitor for anomalies in factory equipment.andM;Basing the activities' computation on the operating system also provides theability to suspend an activity easily and possibly resume it whenappropriate.andP;  Resources can be saved by terminating activities when theybecome obviated or by adjusting (but not discarding) their computation whenimportant conditions have changed.andP;  Sophisticated coroutining activities,such as cooperating simultaneous control of dependent subsystems, are alsopossible.andP;  This approach supports techniques that are easily achieved only byusing different threads of control executing in parallel.andP;  In a practicalsense, this approach also exploits the years of design experience built intothe operating system.andM;All activities have several basic slots.andP;  Parent and child slots are usefulfor automatic subgoal termination, trigger instantation control, andreasoning about computational dependencies.andP;  An expected-CPU slot containsthe amount of time an activity is expected to run and is useful for metalevelreasoning about resource consumption.andP;  Blackboard and local DS slots containlists of DSs shared by all instances of that activity (analogous to globalsand statics in C).andM;Any interruptible activity has an interrupt method that forces the activity'soperating-system process to run a function in the activity'sinterrupt-function slot.andP;  When it returns, the system process continues theinterrupted but potentially adjusted computation.andP;  Handling an interrupt isdependent upon the problem-solving method and the particular application.andO;The user must design an  activity to support interruptions and supply theinterrupt function.andP;  A simple example is activity termination, when a changeindicates an activity is no longer needed.andP;  More than trivial adjustments tocomputation (termination or suspension, for example) often require use ofcatch, throw and unwind-protect mechanisms for nonlocal exits, anddynamically scoped variables.andM;A port server activity polls ports; a period slot specifies elapsed timebetween polling cycles for uniform sampling or to ensure I/O integrity innoisy environments.andP;  Many factories are very noisy, and periodic polling canincrease the resistance to noise by ensuring an output is in the properstate.andM;A knowledge activity is rather unrestricted in form; it may use the theoremprover, create new objects, or implement any sort of problem-solving strategyor reasoning control.andP;  It has an argument DS slot that contains a list of DSsused only by this activity instantiation (similar to passed parameters).andO;These DSs are created and initialized from a trigger or other activity everytime an instantiation of the activity is made.andP;  For example, we may have manyinstances of a PID control activity, each with different setpoints, gains,and so on, passed as arguments when the instance was created.andM;Trigger activities are the primary mechanism for causing event-drivencomputation.andP;  When one runs, a trigger form is evaluated.andP;  In the blackboardstyle, this form's evaluation generally depends on the existence of internaland external events related to the control of some real-world process or thecontrol of the architecture itself.andP;  The evaluation may take place eitherwithin the operating systemhs scheduler process or the trigger activity'ssystem process.andP;  In the former case, the trigger is evaluated on eachscheduler wake-up, making this form useful for responding quickly tointerrupt conditions.andP;  In the later case, a call of the trigger activity'strigger form is performed under the trigger activity's operating-systemprocess.andM;If the form returns non-nil, some action is taken depending ont he whetherthe trigger activity is of the simple or spawning type.andP;  The simple case hasa body-function that is called; during the function the trigger is no longerevaluated and the activity is much like a knowledge activity.andP;  Its uses areprimarily to watch for a specific event and perform small actions that do notwarrant a new activity performing in parallel with continued trigger checks.andM;The spawning trigger activity spawns other activities as a result of anon-nil trigger form evaluation.andP;  These spawned activities are scheduled justas any other process.andP;  The spawned activity may, for example, startadditional trigger activities to monitor a new set of process variables orinvoke knowledge activities to handle an alarm situation.andP;  When a triggerform evaluates to non-nil, the result is taken as a set of variables thatcharacterize how the trigger was satisfied.andP;  A spawning trigger activitypasses the trigger values on as &quot;actual&quot; arguments to the spawned childactivities.andP;  In the pulp-production process, such an activity could be usedto watch for an order's arrival at a vessel.andP;  Upon arrival, the activitycould spawn a vessel-control activity instance, passing the order and vesselas arguments.andM;Since all processes run simultaneously, activities working a subproblem willbe running in parallel with their parent activities and any activitiesworking on sub-sub problems.andP;  This feature facilities communication betweendifferent problem-solving levels (for example, to force a shift in focus).andP;  Agood example of this &quot;focus shift&quot; would be a control algorithm selectionactivity noticing that the PID control activity it had chosen to spawn for arecipe was not controlling vessel temperature.andP;  A different control activity,perhaps one based on qualitative-modelling techniques, could be spawned toreplace the first attempt.andM;Two specializations of spawning trigger activity are controlled and one-shottrigger activities.andP;  Many sets of variables satisfying a trigger expressionmay exist.andP;  In some cases we would like to spawn a set of activities for eachinstantiation that makes the trigger true.andP;  For example, we want to spawn aset of diagnostic routines for each suspected problem.andP;  Occasionally we wouldlike to have a single spawning occur for each instantiation (we don't needmultiple diagnostic routines for the same problem).andP;  At other times, werequire spawning each time the same instantiation satisfies the triggerwhether the previous set still exists or not.andP;  We may also want to limit thenumber of instantiations that can be running concurrently to reducecontention for shared data or to model a physical resource limitation.andP;  Thecontrol of multiple instantiations in all these regards is supported by theclass controlled-trigger-activity.andP;  A one-shot trigger activity preventsspawning more than one set at a time for efficiency in situations where atrigger expression does not need variables.andM;Predicate trigger activities are based on queries to a theorem prover.andP;  Thetrigger is basically a logical statement whose proof is attempted in atheory.andP;  (For example, the diagnostic monitoring routine in the productionline model tries to &quot;prove&quot; a server defective and spawns a response activitywhen the proof is successful.)andP;  Its operation can be paraphrased as(Defective ?X) Then Spawn-(Maintenance Response, ?X).andP;  The theory isgenerally constructed at each query call to provide a fresh snapshot ofcurrent state.andP;  Each time the theorem prover finds a binding list, activitiesare spawned with the bindings that satisfy the query packaged up as argumentDSs (Figure 6).andP;  Thus the theorem prover improves response time by spawningactivities as it finds answers, rather than waiting until all possiblepatterns that satisfy the query have been found.andP;  A DOSBART function thatcreates a theory from the slots and values of a list of objects, along with(as the default) the instances of the rule DS class, makes theory generationeasier.andM;STATUSandM;You may be wondering, &quot;Where's the AI application?&quot;andP;  DOSBART is not an AIapplication such as a typical diagnostician or planner; it's an architecturethat uses several technologies including some from AI (pattern matching,event-driven blackboard notion, and theorem proving).andP;  It makes use of theobject-oriented programming paradigm (having roots in simulation) and relieson principles and practice in the operating system, networking, anddistributed computation communities.andP;  The integration of these technologiesprovides a framework in which to apply AI and non-AI techniques to systemcontrol.andP;  It's the kind of framework needed to implement advanced controlapproaches, much like an expert-system shell is used to implement aparticular expert system.andM;Like most tools for real working systems, DOSBART is evolving.andP;  As newapplication areas are tackled, strengths and weaknesses within its frameworkwill be found.andP;  DOSBART consists of approximately .25MB of CLOS and LISPsource code supporting all platform versions (some C supports remoteprocedure calls in the Sun version).andP;  Some planned enhancements includeimproved support for temporal reasoning (such as intervals), greaterspecifications regarding activity's resource consumption, interfacing toother object-oriented language systems, activity and DS migration across thenetwork for resource utilization concerns, and support for replicatedblackboard objects to improve availability and performance.andM;REFERENCESandM;[1] Nii, P.andP;  &quot;The Blackboard Model of Problem solving&quot; and &quot;BlackboardApplication Systems.&quot;andP;  AI Magazine 7 (2,3): 1986andM;[2] Englemoore, R., and T. Morgan (eds.).andP;  Blackboard Systems.andP;  Reading,Mass.: Addison-Wesley, 1988.andM;[3] Allworth, S.T.andP;  Introduction to Real-Time Software Design.andP;  New York,N.Y., Springer-Verlag, 1981.andM;[4] Glass, R.L.andP;  Real-Time Software.andP;  Englewood Cliffs, N.J.: Prentice-Hall,1983.andM;[5] Bond, A.H., and L. Gasser, eds.andP;  Readings in Distributed ArtificialIntelligence.andP;  San Mateo, Calif.: Morgan Kaufmann, 1988.andM;[6] Choobineh, F., and R. Suri (eds.).andP;  Flexible Manufacturing Systems.andO;Norcros, Ga.: Industrial Engineering and Management Press, 1986.andM;[7] Rashid, R.F.andP;  &quot;Threads of A New System,&quot; UNIX Review, Aug. 1986.andM;[8] Campbell, R., J. Hine, and V. Russo.andP;  &quot;Choices for Mission CriticalComputing.&quot;andP;  Department of Computer Science, University of Illinois,Urbana-Champaign, 1986.andM;[9]  Fortier, P.J.andP;  Design of Distributed Operating Systems.andP;  New York, N.Y.:andO;Intertext Publications Inc., McGrawHill, 1986.andM;[10] Bobrow, DeMichiel, Gabriel, Keene, Kiczales, Moon.andP;  &quot;Common Lisp ObjectSystem Specification.&quot;andP;  X3J13 Document 88-002R: June 1988.andM;[11] Keene, S.E.andP;  Object-Oriented Programming in Common Lisp.andP;  Reading,Mass.: Addison-Wesley, 1989.andM;[12] Nii, P.andP;  &quot;CAGE and POLIGON: Two Frameworks for Blackboard-BasedConcurrent Problem Solving.&quot;andP;  Stanford Technical Report KSL-86-41, 1986.andM;[13] Hayes-Roth, B.andP;  &quot;A Blackboard Architecture For Control,&quot; ArtificialIntelligence 26, 1985.andM;[14] Ogata, K.andP;  Modern Control Engineering, Englewood Cliffs, N.J.: PrenticeHall, 1970.andM;Daniel L. Larner is a computer scientist in Allen Bradley's advancedtechnology department.andP;  His interests include AI, languages, and distributedcomputation.andO;</TEXT></DOC>