<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-621-178  </DOCNO><DOCID>07 621 178.andM;</DOCID><JOURNAL>Patricia Seybold's Unix in the Office  August 1989 v4 n8 p1(11)* Full Text COPYRIGHT Seybold Office Computing Inc. 1989.andM;</JOURNAL><TITLE>Graphical user interfaces: a developer's quandary. (includesglossary of terms and related article about X-Window)</TITLE><AUTHOR>Brown, Laure.andM;</AUTHOR><DESCRIPT>Topic:     Graphical User InterfaceLaw SuitStandardsApplications ProgrammingInterfaceConnectivityObject-Oriented ProgrammingTrendsCoprocessors.andO;Feature:   illustrationchartgraph.andO;Caption:   GUI component reference model. (chart)GUI capabilities (graph)VGM architecture. (chart)andM;</DESCRIPT><TEXT>NO DOUBT YOU'VE been inundated lately with information on graphical userinterfaces: the picks, the perspectives, the right graphical metaphor, thecomparisons and contrasts, the distinction between look and feel, thestandards, the lawsuits.andP;  Admittedly, we've contributed to that inundation.andO;However, behind all the discussions about intuitive displays and colorschemes and menu implementations sit bewildered software developers staringat an unsettled world of multiple user interfaces.andP;  So, although weconsidered taking on a discussion of the main Unix user interface contendersfor this article, the developer's dilemma seems a more pressing issue.andM;The heart of the problem is portability.andP;  Graphical user interfaces (GUIs)will critically impact next-generation computting environments, especiallydistributed computing and object orientation.andP;  But with so many GUI optionsout there, developers are stymied.andP;  There's X and its many flavors; there'sPM (and eventually PM/X); there's NextStep; there's Macintosh; there'sMetaphor; there's NewWave.andP;  They're all contenders in the GUI game, and theyshare no common application programming interfaces (APIs).andP;  You have tocompletely rewrite an application to run it on each platform.andP;  Which do youwrite to? All of them? Not quite, although that's the ideal option.andP;  WritingGUI applications is tricky-very tricky-and it's all the more so if you're adeveloper coming from a text-based DOS world.andP;  And the cost of re-porting anapplication from system to system is simply too expensive.andM;Solutions? Few.andP;  Neuron Data has come up with one: die Open InterfaceToolbox.andP;  However, it's only used internally by Neuron Data.andP;  A similar toolis available from Advanced Program ming Institute.andP;  Both technologies areworth looking at, so we'll do that, but not without first putting thedeveloper's position into better prespective.andP;  We'll begin by painting in thebackgroundof GUIs: the benefits and the motivations behind them.andP;  Then we'llzero in on windowing programming environments: the levels of complexityinvolved, the dominant window systems, and the portability issues.andP;  More ThanMeets the EyeandM;Graphical user interfaces are more than a slicker, easier way to interactwith computers.andP;  They offer significant advantages to users over characteruser interfaces (CUIs), including:andM;* Non-modal operation.andP;  An application doesn't take over your entire screen.andM;* Direct manipulation of information on screen.andM;* Task orientation (as opposed to tool orientation).andP;  Rather than worryingabout what application you need to load and how to work with it to get atthose budget figures, for example, you grab the budget icon and run.andM;* Easy data-sharing between applications.andP;  * Most GUIs run on lugerdisplays-more real estate for viewing multitasking applications.andM;*More consistency across applications and platforms.andP;  This is where a lot ofthe standardization issues come into play.andP;  Consistent behavior (the&quot;hows&quot;-things like moving windows, changing icons, scrollbar movements)across platforms is somewhat more critical than a consistent appearance.andP;  Aslong as you know how to manipulate GUI components, it doesn't really matterhow they look on screen.andP;  * Transparency among applications.andM;* Ease of learning-with a caveat.andP;  Too many graphical user interfaces withdifferent interface principles will only confuse users.andM;* Coprocessing support.andP;  With a windowing environment, a GUI can give you theproper front-end tools as well as a view to the back-end processors.andM;A number of changes in the marketplace are driving the transition tographical user interfaces.andP;  As businesses continue to thrive on change andglobalization, getting information from a number of sources quickly, diecomputer industry is moving from standalone, single-tasking, proprietary,disposable solutions to networked, multitasking, integrated, multivendor,scalable solutions.andP;  Clearly, distributed network computing (DNC) and objectorientation have roles here.andM;But do GUIs? Yes, in that they support DNC and object orientation.andP;  Graphicaluser interfaces are inherent in objectoriented environments.andP;  Consider, as anobvious example, compound document/object architectures.andP;  You sure can't seea raster on a character-based screen.andP;  In DNC, a distributed windowingenvironment, such as X-Window, is in order.andP;  Thus, you can open a window andmanipulate an application that lives on another machine on the network.andM;Although GUIs have much to contribute to the commercial users, right now, themarket remains in scientific and research communities, where workstationsprevail.andP;  No doubt, that has something to do with the fact that innovativedevelopments often come out of these environments.andP;  Of course, the work ofmany scientists and researchers demands investments in new technology.andM;For the typical commercial user working with 1-2-3 all day long, theinvestment doesn't seem quite as appropriate.andP;  His computer most likelydoesn't support GUIs, and the ones that do are pricey.andP;  Be that as it may,everyone agrees that future interfaces will be graphical.andP;  And that's dienot-too-distant future.andP;  Because next-generation computing is upping the userinterface ante, the commercial world has taken a marked interest in windowingenvironments during die past year.andM;Windowing EnvironmentsandM;While GUIs may be helping users reach a higher computing plateau, they'regiving developers a tough time.andP;  Graphical systems are relatively new, andwriting to a them is a whole new ball game for most progammers.andP;  Actually,few even use them.andP;  Today, most Unix programmers-like users-are still sittingat character-based terminals.andP;  GUI and CUI (character user interface)progamming models are worlds apart.andP;  Developers have their hands full justmigrating traditional characterbased applications, let alone newapplications.andP;  Furthermore, because they're richer, GUI environments are morecomplex than CUI environments.andP;  You have to worry about things like graphicsdisplay, multifonts, and interapplication connections between windows.andO;Writing to a bit-mapped screen is a much more exacting exercise than iswriting to a character-based screen.andP;  Lots more coding is required.andP;  Huntingdown a bug can take relentless effort.andM;A REFERENCE MODEL.andP;  From a programmer's perspective, a generic, X-based,graphical user interface can be made up of four programmatic interfacelayers, which are hierarchical in terms of coding complexity: the base windowsystem interface, the toolkit, the window manager (a.k.a.andP;  the presentationor style guide), and the user interface management system (UIMS).andP;  As youmove up through the layers, GUI programming gets less convoluted.andP;  Writingapplications at the window system interface will put you down in the guts ofthe GUI, whereas, with a UIMS, programming is simpler.andM;So, you ask, if complexity is such a big deal, why not simply use the UIMSinstead of mucking around at a lower layer? Basically because (as we'll pointout below) UIMS s are, by-and-large, still immature.andP;  Some GUIs don't offerUIMS capabilities at all (see illustration, page 6).andP;  Furthermore, exh layerdepends on what's underneath it.andP;  The window manager, for instance, relies oncomponents built by toolkit programmers.andP;  So it comes down to a question ofprogramming expertise.andP;  Generally speaking, the person fiddling with toolkitmechanisms to create GUI components is not the same person who uses thecomponents to create an interface.andP;  And the person who creates the interfaceis not going to be the one who writes the application code.andP;  And none of themwill be the user who wants to configure existing applications and interfacesto meet his or her whim.andP;  The programmatic interface depends enfirely onaptitude.andP;  If you have your hands on a window system whiz-a rarecommodity-you're not going to waste that talent on interface design; you'regoing to have him or her programming toolkit components.andM;Moreover, you may write at the lower layers to keep more control over thelook and feel of the application at hand.andP;  The deeper you are in the layers,the less confined you are by the style conventions and functionality of theGUI.andM;Base Window System Interface.andP;  The lowest rung on die GUI programming ladderis the base window system interface, which converts messages between theapplication and the display device.andP;  Think of it as the middleman between theapplication and display.andP;  When an application makes a window management call,the base window interface changes the call into a format that the display caninterpret.andP;  It then changes event messages (e.g., mouse clicks or windowchanges) into values for the application.andM;This interface provides only minimal window operations such as primitivegraphic functions, print string, and I/O events.andP;  Therefore (as mentioned),writing applications at this level is a painstaking process.andM;Toolkit.andP;  A less demanding interface is ale toolkit, a set of developmentresources that makes life easier for programmers.andP;  The toolkit itself is madeup of two layers: intrinsics and widgets.andP;  Intrinsics are the basic buildingblocks of the toolkit-the toolkit's toolkit, so to speak-which are used tocreate widgets.andP;  The toolkit spares programmers from the coding drudgeryinvolved at the base window system interface.andP;  They don't have to write theirown routines to generate things like menus, pop-up panels, and windows.andM;Window Manager.andP;  The window manager is where appearance and behavior enterthe picture.andP;  Its guidelines specify the style of user interaction: wherefunctions should be placed on screen and how features such as pull-down menusshould be implemented.andM;UIMS.andP;  The industry is still pretty hazy about user interface managementsystems (UIMS s).andP;  Ask 10 different people what a UIMS is, get 10 differentanswers-anything from a screen painter to an interface layout tool to aninterface customization facility.andP;  A more clear-cut defini8tion needs to befound-what belongs in a UIMS, what doesn't, and evaluation criteria.andP;  In themeantime, we'll give you a working definition:andM;* Paint, not code.andP;  A UIMS lends the developer some GUI advantages.andP;  Considerit a graphical programming interface.andP;  Whereas toolkit progammers need anintimate relationship with widget design and intrinsics, a UIMS spits outcode as you paint.andP;  (However, the functions of toolkits and UIMS s areblurring as toolkit implementations pick up UIMS capabilities, and UIMS toolsincorporate traditional toolkit characteristics-like widget-building.)andM;* Dialog management.andP;  A UIMS deals only with interaction between the user andthe application, it doesn't touch application code.andP;  To that end, there needsto be a clear split between function and interface.andP;  Why? Because we'relooking for a more modular way to design user interfaces-a plug-and-playsolution.andP;  It should be possible to borrow interface functions from otherapplications.andP;  The split also makes sense in terms of performance.andP;  Toolkitsare huge and, to keep things from being unbearably slow, they should bestored locally (in X terms, on the server).andM;* Portability.andP;  Ideally, you should just be able to say, &quot;Hey, I want this tobe a NextStep application,&quot; pick NextStep from a menu, and the UIMS will bangout the right code and style conventions.andP;  However, the modular approach wehope for doesn't lend itself well to multiple systems.andP;  Unlessthe developeris very familiar with each target platform (and, with the newness of GUIsystems, this is just not the case), modules will carry nonportable code ofthe interface system that the developer knows best.andP;  Cuff enfly, most toolsare strapped to a single window manager.andP;  This fact also stifles creativity,because you're locked into that window manager's look and feel.andM;* Testing, prototyping, and evaluation tools.andP;  A UIMS can execute a userinterface (UI) without it being fled to the application.andP;  In other words, youcan test and refine the behavior of the UI before actually binding it to theprogram.andP;  And we don't just mean testing the way it looks and interacts withdie user.andP;  It's also essential that a UIMS spot any hidden domino effects.andO;Just deleting a button might cause a ripple of unforeseen repercussions andscrew up the whole application.andM;The UIMS to Come.andP;  Today, UIMS s are programmer's tools, and that's too bad.andO;Interface designers are just that-designers, not programmers.andP;  They knowabout the cosmetics, the composidon, and the psychological implications ofuser interface design.andP;  UIMSs should be geared for them.andP;  The current UIMStools still demand some knowledge of widgets and toolkits.andP;  Refinement is inorder.andM;End-user UIMSs aren't out of the question, either.andP;  Eventually, users shouldbe able to customize an existing application for the way they want tointeract with it.andP;  Or they can design their own applications, or overlapthem, or reuse functions they like from other programs and libraries.andM;Standard Foundations:andM;X-Window and Presentation Manager (...and NextStep?)andM;Though plenty of GUI options exist, the industry is hovering around twowindow systems: X-Window and OS/2's Presentation Manager (PM).andM;From a Unix perspective, we're obviously most interested in PresentationManager's influence on Unix user interfaces.andP;  Because of its MS Windowsheritage and its IBM SAA (Systems Application Architecture) affiliations, PMis setting the user interface tone in the office.andP;  (IBM was rather quiet inits recent SAA announcement about how OfficeVision would fit into its AIXstrategy.andP;  There isn't an easy short-term answer.andP;  Porting SAA to AIX wouldcertainly take a while.andP;  IBM could always port the look of OfficeVision toAIX, but it wouldn't have the same SAA underpinnings.andP;  In the interim, IBMhas stated that it will provide for interoperability between SAA and AIX, itstwo strategic environments.andP;  In addition, IBM has promised a native officeimplementation under AIX, but no time frame was mentioned.)andM;OSF sensed as much when it chose a PM look and feel for Motif.andP;  But look andfeel we as close as PM- and X-based GUIs come to each other, and, for thetime being, X owns the Unix market.andP;  There's also PM's Unix version, PM/X,and, though it's a work in progress, it, too, may affect the direction ofUnix user interfaces.andP;  The fact that PM/X hasn't reached the market yet putsit at somewhat of a disadvantage, and X has jumped out as a standard.andM;X: SOME GOOD POINTS.andP;  The industry has certainly taken a shine to MIT'sX-Window system, and its very acceptance is one of its biggest advantages.andO;The fact that MIT put X in die public domain didn't hurt its chances.andP;  Justin the past year, X has completely transcended its academic heritage.andO;Witness, for example, die Xhibition conference in June.andP;  Attendance more thandoubled over last year's, and a good many of those attendees were commercialdevelopers.andM;X is significant for a number of reasons:andM;* It's free.andM;* It's portable-hardware-, software-, and operating systemindependent.andP;  WhileX has taken off in the Unix world, it supports any system: DOS, Macintosh,VMS, MVS-you name it.andM;* It's distributed, and, as such, is an enabling technology for distributednetwork computing.andM;* It's a framework for object orientation.andP;  Not only does it provide for theessential graphical capabilities of object orientation, it also has anobject-oriented programming model.andP;  Widgets are objects.andP;  They have specificproperties, and an extended widget inherits the properties of its rootwidget.andM;* Its client/server model encourages the split of applications and interfacethat we talked about with UIMSs.andM;SOME BAD.andP;  X has an inherent paradox.andP;  It was designed to be highly portable(and it is).andP;  To that end, it's a very low-level facility.andP;  Plain X doesn'taddress the presentation or UIMS aspects of a GUI.andP;  Its designers made aconscious decision not to impose any conventions on top of X, but rather tolet individual implementers develop and extend widgets to satisfy theirspecific goals.andP;  And that's just what's happened.andP;  Organizations havedeveloped individual toolkits, but none of diem has been commonly accepted.andO;As a result, no common API has been established.andP;  From a developer'sstandpoint, the portability of X has flown out the window.andM;The lack of a common API is X's most notable problem, but it has otherlimitations as well:andM;* Unless the client lives on die server, X is slow-even when you're usingpowerful machines as servers.andP;  So-called lowend X terminals have Motorola68020 and 68030 chips.andM;* X is expensive.andP;  Not X itself-that's licensed free--but the hardware itrequires.andP;  Not everyone who wants to use X has the right equipment to do so.andM;*Most of the applications being written to X are Unix applications and don'tport to PCs.andP;  cts'Most&quot; is the operative word here.andP;  X applications are beingwritten to other platforms; look at VMS.)andM;* X doesn't address security at all.andP;  Any jerk go in and tamper with or spyon your work.andM;* There seems to be a misconception about X and its relationship to DNC.andP;  DNCencompasses the notion of distributed applications.andP;  X only separates diedisplay from the application and lets the application run in terminalemulation; it has nothing to do with parsing up the application.andP;  Therefore,additional application distribution tools are necessary.andM;PRESENTATION MANAGER.andP;  OS/2's Presentation Manager is a more complete systemthan X.andP;  Whereas no-frills X stops before window management enters thepicture, PM defines all the graphics functions.andP;  Unlike X, PM has a singleAPI, and all PM applications portray the same look and feel.andP;  More to thepoint, however, is that X is a distributed application environment.andO;Presentation Manager (and PM/X) isn't.andP;  That's a fundamental differencebetween them.andP;  A PM application fives on your machine-mr at least a componentof it does; an X application can be anywhere on the network.andM;Like X, PM has an object-oriented, hierarchical windowing paradigm.andP;  Mainwindows are independent of each other and encapsulate an application.andP;  Thesewindows can have child windows, which inherit the class characteristics ofthe main window.andP;  Those child windows can spawn children of their own, and soon.andP;  Each window has a class handler that knows its interrelationships toother windows.andP;  For example, in a typical windowing scenario, several partsof an application may be spread over several windows.andP;  In this situation, theclass handier keeps track of the relationship between parts of theapplication.andM;Presentation Manager's graphics programming interface is comparable toDisplay PostScript in function, and supports graphics (including kerning,bezier, cubic splines, and polygonal clipping), bit maps, and text editing.andO;In addition, PM has die advantage of OS/2's dynamic fink library, whichallows for extra extensions.andM;CUA 2.andP;  First, let's get one thing straight PM is not CUA; PM uses CUA.andP;  CUA(Common User Access) is pan of IBM's SAA; it gives users a single interfaceacross all IBM platforms.andP;  CUA provides basic guidelines for things likepanel types and formats, selection techniques, and function keys.andP;  PM, on theother hand, is a full graphical user interface.andP;  You can consider CUA asubset of PM's functionality.andM;CUA has recently been extended from the text orientation of level one (whichprovided graphical menus) to a more graphical orientation based on an iconicrepresentation of the desktop-a more object-oriented approach.andP;  IBM hasdubbed this second level &quot;workplace extensions.&quot; Its early releases will havelimited functionality.andP;  For example, users will not be able to add a new iconto the desktop, nor will they be able to manipulate existing icons.andP;  However,releases in the first quarter of 1990 will provide much more flexibility.andO;Users will be able to add new applications to the desktop and to registerapplicadons and devices.andP;  (Registering is an administrative process thatestablishes relationships between applications and devices, or objects.) Forexample, a document can be registered with a printer so that die user canprint the document simply by dragging a document icon to a printer icon.andO;Additionally, through die direct manipulations of objects, users will be ableto cut and paste between windows without the use of a clipboard.andP;  We expectthat, over time, IBM will add more functionality, including the ability tocreate live links between applications.andM;PM OBSTACLES.andP;  PM is new.andP;  Granted, this is a temporary setback, but, at themoment, few developers are familiar with it.andP;  It may look like MS Windows toa user, but not to a programmer.andP;  In addition, because it defines appearanceand behavior, it has a lot more--and completely different-rules than X.andO;Although multiple implementations leave X without a common API, once you getto know X, it's not hard to move from, say, DECwindows to Open Look.andP;  WithPM, you're working with a separate and more complex model.andP;  Couple itsnewness with its inherent sophistication, and PM is intimidating.andM;Dialog Manager.andP;  Compounding the problem is the fact that PM hasn't had thesame sophisticated development tools that X has (i.e., the various widgetsets and toolkit implementations), and implementing windowing PM applicationshas been a difficult task.andP;  To alleviate some of the complexity, IBM isshipping the PM Dialog Manager in September, which will help programmers takeadvantage of PM facilities, including windows and graphics.andP;  Specifically,the Dialog Manager provides APIs for display services, variable handling, andsession control.andP;  Programs written with the Dialog Manager conform to SAA/CUAconventions.andM;THE PROMISE OF PM/X.andP;  PM/X sounds like Presentation Manager on top of X,doesn't it? Wishful thinking, perhaps, because it isn't.andP;  PM/X is the Unixversion of PM.andP;  PM is being rewritten from Assembler to C.andP;  Although it'sstill under development, when PM/X does arrive, it will mean a single API setfor both OS/2 and Unix applications.andP;  With Motif, OS/2 and Unix applicationscan share the same look and feel-Feat for the user, but not for thedeveloper.andP;  A common programming interface, on the other hand, is great forthe developer.andP;  Furthermore, given X's status in the market, we suspect thatPM/X may evenwally support both local and remote X-based applications inaddition to OS/2 applications (see illustration, page 9).andP;  Considering thegrowing demand for DNC solutions under Unix, PM/X may even become distributeditself.andP;  However, neither distribution nor support for X would be availableany time soon.andP;  (We're talking years.)andM;...  AND NEXTSTEP.andP;  Ah, NextStep-the dark horse-an enticing developmentenvironment that could greatly influence the fuwre of Unix, especially sinceIBM has licensed it.andP;  (IBM, though, has a number of GUI options: CUA 1, CUA2, AIX Motif, AIX NextStep, and even Metaphor.) What makes NextStep such aseductive environment is its tools.andP;  NextStep reaches into the UIMS layer.andO;In fact, it was created especially to reduce the level of programmingexpertise necessary for application development.andM;The Pros.andP;  NextStep has a number of advantages over both X and PM:andM;* NextStep was designed from the bottom up as an objectoriented system.andP;  It'sactually written in objective C, a C variant that implements support forclasses, encapsulation, inheritance, and so forth.andM;*NextStep fronts PostScript with a window server, which gives softwaredevelopers a strong front end to their applicadons.andM;* NextStep encourages users to build their own applications using graphical,system-provided building blocks.andP;  Class libraries give users and developers astrong foundation to build on.andP;  NextStep includes 38 object classes,including a PostScript manager, a text editor, system controls, ScrollView, aprogramming interface, and a storage object.andP;  Because of theirobject-oriented structure, these libraries make it easier to buildsophisticated interfaces.andM;*NextStep applications cooperate with each other using Mach's object-orientedmessage-passing scheme, an application-to-application communicationfoundation for distributed environments.andP;  (For a close look at the Machoperating system, see Vol.andP;  4, No.andP;  6.)andM;The Cons.andP;  But NextStep is not the ideal environment (what is?).andP;  The folksat NeXT are a cocky crew, and they didn't really address compatibility.andP;  NeXTis its own environment and demands yet another APT.andP;  Furthermore, since NeXTuses Mach (hardly a standard operating system), other systems won't be ableto communicate with NextStep applications in a heterogeneous network.andM;A few other gotchas: We mentioned that NextStep has UIMS capabilities, but itmakes no separation between display and underlying data.andP;  Also, NeXT hasfocused primarily on the developer at this point.andP;  Its user environment, onthe other hand, is still immature.andP;  For instance, users can't embed objectswithin other objects.andP;  In other words, users can't stick a spreadsheet objectinto a document object-pretty limiting.andM;Issues and OptionsandM;We hope you weren't expecting some happy ending here, where some whiz-bangtools come bounding in to save our developers in distress.andP;  The API problemis no small one, There are a bunch of APIs under X alone.andP;  An X applicationgenerated under one window manager will crash another.andP;  But the multiple APIplight is not being ignored.andP;  In the X world, standards bodies are zeroing inon X intrinsics.andP;  The X Consortium is considering developing a commonprogramming interface based on X intrinsics, and X/Open and the NationalInstitute of Standards and Technology &quot;ST) have decided to adopt X intrinsicsas a basis for standardization efforts.andP;  Frankly, these attempts we a littletoo little and a little too late.andP;  It's not as if they'll have any solutionssoon, and they only address X.andM;In the meantime, commercial software houses have a couple of options:andM;* Sit and wait for the standard GUI to surface.andP;  But let's face it-you mightmiss the boat.andP;  The GUI market might be troublesome, but it's alsoopportunistic.andP;  Many predict that the window system that takes off will bethe one that sits under hot new applications.andM;* Go for one.andP;  Developers could also just choose the platform they deem mostpromising and keep their fingers crossed (Russian Roulette style).andP;  You'llnotice a blatant risk factor.andP;  But there's another consideration here.andP;  Ifmost developers choose this path, it will severely damage Unix's commercialchances.andP;  Since things aren't settled with X, many developers would wind upchoosing a more stable UI environment, like OS/2, Mac, or VMS, and postponeUnix until things calm down.andP;  And one thing the Unix market doesn't need issoftware houses postponing Unix application development.andM;*Go for them all.andP;  While that may be an option for the bigger softwarecompanies (and even they only have the resources to write to a choice few),it would blow away small ISVs.andP;  (Small companies are very often the source ofinnovation.andP;  We've been disappointed with the blase, state-of-the-marketstuff we're seeing coming out of the big software shops.)andM;ABOUT THAT LAST OPTION.andP;  Let's rethink that last option.andP;  Rewritingapplications for X, Mac, PM, etc., may be impossible, and we've alreadytalked you blue in the face about the lack of a common API.andP;  Can't there beanother way besides support for all the GUIs?andM;Actually, yes.andP;  We've seen a scant few approaches-pathfinders in the frontierof open systems portability technology.andP;  One example comes from Neuron Data'sOpen Interface Toolbox (OIT), an internally-used, GUI-independent developmentenvironment that supports a number of systems.andP;  Advanced ProgrammingInstitute (APD, a Boulder, Colorado-based organization, provides anotherexample--the Extensible Virtual Toolkit (XVT).andP;  Both tools feawre similardesign: an intermediate, portable library that's independent of the systemit's running on.andP;  Open Interface ToolboxandM;ABOUT NEURON DATA.andP;  Neuron Data, a four-year-old company based in Palo Alto,California, peddles expert system shells and artificial intelligence (AI)design and programming environments.andP;  Its marketing premise has been toprovide AI products that are not hampered by lofty development costs,esoteric languages, extensive customization, and special purpose hardware(hurdles sometimes tripped over by AI vendors in the past).andP;  So far, it seemsto be the right strategy.andP;  Since the company began shipping products in 1985,Neuron Data has sold over 6,500 software licenses--and that during a timewhen the AI industry has been on the decline.andM;Nexpert Object.andP;  Neuron Data's premiere product is Nexpert Object, a C-based,graphical, rule- and object-oriented expert system shell that runs on variousmachines, including VAXs, Macintoshes, PCs, mid Unix systems.andP;  Nexpert usesobjects and an inference engine to pool software resources for expert systemdevelopmenL (Essentially, an inference engine is responsible for thereasoning capabilities of an expert system.) Neuron Dam has taken the &quot;whydon't we let customers integrate the applications they already have&quot; approachwith Nexpert.andP;  Currently, the product provides access to major Unixdatabases-Oracle, Sybase, Informix, and Ingres (as well as DB2)and tools suchas 1-2-3, Excel, and HyperCard.andM;WINDOW TO WINDOW TO WINDOW.andP;  Nexpert is interoperable across a number ofdifferent machines and window systems.andP;  You can develop an application on anX terminal, recompile it, and run it on a Macintosh.andP;  The product isconceptually window-system and operating-system independent.andP;  Clearly, thiscompany has done something to leap over interface swamps.andP;  The bridge is theOpen Interface Toolbox (OIT).andM;Neuron Data submitted the OIT as a candidate for OSF's user interfacecomponent last September, but it's not a commercial product.andP;  It's only usedinternally by Neuron Dam's own developers for graphical user interfacedesign.andP;  The toolbox has an extensive widget set and interface design tools.andO;To its credit, Nexpert has a nice interface, giving the user colorful,graphically rich tools for visualizing the structure of data and thesequences and relationships of rules.andP;  From the outset, the company wasworking against the notion of expensive hardware for AI applications;portability became a necessity.andP;  OIT can potentially map to a whole slew ofsystems.andP;  Right now, the toolbox supports VMS/UIS, DECwindows, X, Macintosh,and Pm.andP;  Support for NeXT, MS Windows, and Display PostScript are in theworks.andM;OIT DESIGN.andP;  The structure of OIT targets two major concerns: portability andproductivity.andP;  Portability is handled mainly by an intermediate layer calledthe virtual graphics machine (described in &quot;Portability: The Orr Library&quot;below).andP;  Productivity gets a shot in the arm from an object-orientedprogramming paradigm.andP;  OIT's extensible widget set is based on objectorientedprinciples.andP;  In addition, Neuron Data distinguishes among various levels ofprogramming skills and has architected the toolbox accordingly.andM;More Layers.andP;  Yes, we're going to talk programmatic interface layers again.andO;The toolbox has three (and you'll notice resemblances between Neuron Data'smodel and ours):andM;* Widget progamming.andP;  Programmers create and extend widgets with the OITtoolkit.andP;  Again, Neuron Data took an objectoriented approach towidget-building and widget extensions.andP;  In other words, core widgets havespecific properties that can be modified for customization (and mostgraphical applications require custom widgets, such as die drawing area of apaint program or the cell manager of a spreadsheet).andP;  Because OIT is notmerely an X implementation, the toolkit widgets are not related to Xtkwidgets.andP;  Instead, widgets are built on top of the virtual graphicsmachine.andM;*Application programming.andP;  The person doing the actual application design isnot the widget builder.andP;  The designer works with a tool called the resourceeditor, which allows drawing or painting interfaces without much coding (see&quot;Productivity: The Resource Editor&quot; below).andM;* End-user progamming.andP;  For end users, the OIT is essentially an editingtool.andP;  Users can tailor programs visually to suit their preferences.andM;Productivity: The Resource Editor.andP;  The crux of OIT operation for theapplication programmer is the resource editor.andP;  Developers generate userinterfaces as if using a paint or draw program.andP;  Parameters such as the typeof text button to implement (e.g., push button, toggle, check), its shape,its font type, and its behavior to mouse events we handled visually.andP;  Inother words, developers determine the style of a widget by drawing it, not bycoding in its parameters.andM;The resource editor produces two types of files: OIT ASCII resource filesthat describe the layout of the UI (its form) and progamming source code (itsfunction).andP;  While programmers can draw the look of an OIT-generated userinterface, they still must do source-coding for its functionality.andP;  OIT givessome guidance for source-coding by providing templates of the functions inthe OIT library (described in &quot;Portability: The OIT Library&quot; below).andO;Basically, coding is reduced to a &quot;fill in the blank&quot; situation.andP;  You fill inthe proper function call, and each screen you paint is linked to a library ofOIT functions.andM;OIT also has a style guide, so applications have a consistent look and feel.andO;Although extensions and variations can be made to the style guide, NeuronData doesn't exactly recommend iL assuming (correctly) that your typicalapplications programmer is not going to know a whole lot about userinteraction design.andP;  The style guide, we were told, was designed to maximizeefficiency, &quot;which requires a good understanding of the psychological issuesinvolved.&quot;andM;Portability: The OIT Library.andP;  If the crux of Orr operation for theapplications developer is the resource editor, die widget programmer dependson the virtual graphics machine and die OIT library.andP;  Actually, the libraryhas various versions-one for each system OIT supports.andP;  OIT works with aleconcept of an intermediate layer between the underlying window system(Macintosh, PM, X, etc.) and the OIT development platform.andP;  You port an OITapplication to another system by moving source code and resource filesbetween machines and finking the appropriate OIT library.andM;The library has a panner in portability: the virtual graphics machine (VGM).andO;The VGM is crucial to the overall design of OIT.andP;  Programmers actually usethe VGM interface rather than the window subsystem to create and extendgraphical components (or widgets; Neuron Data uses X terminology), so thefunctionality of OIT isn't dependent on any one system.andP;  The VGM interfacesupplies low-level functions and drawing operations.andP;  New widgets are storedin the OIT library, which sits on top of the VGM.andP;  The VGM interfaces to theunderlying system with a VGM driver (like the library, one driver persystem).andM;The VGM has a number of responsibilities, including:andM;* Encapsulating windowing system implementation detailsandM;*Defining core widget structureandM;*Dispatching events to widgetsandM;*Processing exposure events clippingandM;* Dispatching timer eventsandM;* Managing window operations (move, resize, iconify, etc.)andM;COMMENTS.andP;  The toolbox is a very workable solution for Neuron Data.andP;  However,die company obviously jumped through a few hoops to develop it.andP;  We'vealready mentioned the difficulty of finding developers who have a solidrelationship with multiple GUIs.andP;  Apparently, Neuron Data did just that.andP;  Thelibrary contains abstractions of several window systems.andP;  However, manycompanies do not have the resources to go through these gyrations.andM;Extensible Virtual ToolkitandM;Advanced Programming Institute's (API's) Extensible Virtual Toolkit (XVT) mayspare companies those gyrations because it's an actual product.andP;  Like OIT,it's a portable user interface programming environment It was first shippedin January 1988 for the Macintosh and MS Windows, and API is just finishingversions for PM, X.11, and character-based terminals.andM;WORKING ASSUMPTIONS.andP;  API started developing XVT with a number of groundrules.andP;  Because portability was the main goal, the toolkit had to abstractthe features common to a number of systems.andP;  API wanted its function callsnot only to look like those of a window system and toolkit (with events,windows, graphics, fonts, and so forth), but also to be simpler than theunderlying system.andP;  In order to hit die right level of abstraction, diecompany set out with six assumptions about XVT's design:andM;* Commercial viability is a must.andP;  To API, the only way to really test XVTwas to release it commercially, exposing it to scrutinization underreal-world applications.andM;* XVT should support all standard environments, especially X, MS Windows, PM,and Macintosh.andM;* The interface must be thin.andP;  That is, it must use whatever the host windowsystem offers for window management, menus, resources, dialog, and so on.andM;* The programming language had to be plain C-without any preprocessing orinterpretation.andM;* The developer shouldn't have to dive into the native window system.andO;Portability must be achieved through abstraction, not through multiple paths.andM;* The developer should be able to dive into the native window system if hemust (i.e., if XVT doesn't support a certain feawre).andM;XVT DESIGN.andP;  With these rules in mind, API, like Neuron Data, adopted amiddle layer concept for XVT.andP;  The XVT library has a single interface that isidentical across all systems.andP;  It contains about 200 function prototypesalong with type definitions for abstract objects, such as windows and fonts.andO;Therefore, applications developers just write to one interface.andP;  The libraryitself has multiple implementations-one for each host system it supports (seeillustration at left).andM;COMMENTS.andP;  The features XVT provides are, by nature, lowest commondenominator, and that may prove to be a stumbling block for some developers.andO;(Incidentally, the same can be said for OIT.) Yet, developers rarely need 100percent portability; they need tools that reduce the cost of porting, andthat's what XVT does.andP;  Certainly, 90 percent portability is better than noportability at all.andM;ConclusionandM;PORTABILITY, NOT STANDARDIZATION.andP;  At first, you'd think it would be good tosee the industry standardize on a user interface-just mandate something likeMotif or Presentation Manager.andP;  But, aside from political ramifications(let's face it, would ATandamp;T stand for industry standardization on Motif orPM?), such a move would severely cramp innovation of better, more seductive,streamlined interfaces.andM;A common API is a more practical solution.andP;  Developments such as NeuronData's OIT and API's XVT are precisely die kinds of tools developers need.andO;additional portability techniques would also help: portable UIMSs and modularuser interface libraries.andP;  What we're after is interoperability.andP;  We want tobe able to mix and match applications.andP;  We want our applications to plug andplay together.andP;  It isn't the difference in appearance that's annoying; it'sthe inability to jump back and forth as quickly as we would like, and toperform operations as easily across applications as we can withinapplications.andM;THE SOFTWARE SANDBAR.andP;  At the Executive UniForum Conference in April, BillJoy, the ever-blunt VP of Research and Development at Sun Microsystems,dismissed the recent user interfaces hullabaloo as &quot;much ado about not much.&quot;andO;He touted application development instead.andP;  If it takes five minutes to learna different interface for a really neat application, who cares?andM;The user interface wars, though, are getting in the way of applicationdevelopment.andP;  As software vendors continue to stress choosing a developmentenvironment, we continue to wait for better aplications.andP;  In time, as GUIsbecome more mainstream, programmers will be more competent to build portabletoolkits that abstract the functionality of a number of systems (Ala XVT andOIT).andP;  In the meantime, users are pulling their hair out looking forsolutions for their emerging needs: coprocessing, interoperability,modularity, object orientation, portability.andP;  We need to look several levelsbelow the surface, not at the look and feel of computer systems.andM;X-Window: Just a ReviewandM;BY NOW, you're probably familiar with X, so we'll just give you a quickrun-through of the X fundamentals.andP;  (For an in-depth look, see Vol.andP;  3, No.andO;10.)andM;Client/Server Model.andP;  X is client/server based, but it's backwards.andP;  Theclient is die machine that's acwally running the application, and the serveris the workstation that's providing display services.andP;  In other words, the Xserver runs on what most people generally consider a client: the workstadon.andM;Windows.andP;  X has the familiar hierarchical, layered window structure thatallows windows within windows within windows...andP;  (you get the picture).andP;  Themain workstation window, called the root window, displays the backgound.andP;  Itschildren are shell windows and are associated with a particular application.andM;Architecture.andP;  X-Window is made up of four main components (seeillustration):andM;* The X server is the workstation program that the user interacts with; itcreates the user interface, displays graphics, etc.andM;* The X protocol defines the data structures that pass requests betweenclients and servers.andP;  It's independent of operating system, networktransport, and application language, thus letting users access applicationsin a typical smorgasbord network.andM;* The X library (Xlib) is X's interface to die X protocol.andP;  It is representedby the bottom layer in our model, translating messages between client andserver into protocol requests and providing very primitive graphicsprimitives.andM;* The vanilla Xtoolkit (Xtk) has a full set of intrinsics, but only a fewwidgets.andP;  The range of widget sets fluctuates from toolkit implementation totoolkit implementation.andM;UI Glossary of TermsandM;Server.andP;  The display device.andM;Library.andP;  In X terminology, the base window system interface is die X library(Xlib), which consists of primitive graphics routines (e.g., for windowfunctions and graphics resource functions).andM;Intrinsics.andP;  Intrinsics are low-level user interface development tools.andP;  Theyare the general utility routines for implementing code and work inconjunction with higherlevel, screen-based components called widgets.andM;Widgets.andP;  Widgets, basically, are specialized windows with I/O capabilities.andO;They provide graphical interactive components like scrollbars, dialog boxes,text fields, and such.andP;  Widget sets can also include more sophisticatedcomponents such as multifont text and rasters.andM;Gadgets.andP;  Gadgets are essentially widgets, but are more limited functionally.andO;However, they give applications better performance by creating fewer windowsand using less memory.andP;  Gadgets include labels, push buttons, toggle buttons.andO;You use them just the way you use widgets, with similar programmatic access.andO;They are just streamlined implementations.andO;</TEXT></DOC>