<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-326-381  </DOCNO><DOCID>07 326 381.andM;</DOCID><JOURNAL>Microsoft Systems Journal  March 1989 v4 n2 p45(18)* Full Text COPYRIGHT Microsoft Corp. 1989.andM;</JOURNAL><TITLE>MDI: an emerging standard for manipulating document windows.andO;(Multiple Document Interface user interface) (technical)</TITLE><AUTHOR>Welch, Kevin P.andO;AttFile:   MSJ\V04N02\MDI.ARC;2 Program:  MDI.ARC  Multiple document interface.andM;</AUTHOR><SUMMARY>The Multiple Document Interface (MDI) is a user interface standarddeveloped for Microsoft Windows and OS-2 Presentation Manager.andO;MDI supports viewing of multiple child windows within a mainapplication; each child window can be used to display differentsets of data or multiple views of the same data set.andP;  The standardis described with a focus on the user interface and programmingfeatures.andP;  A Windows library is discussed that lets the usereasily incorporate the MDI interface into applications, and theuse of the library is demonstrated within the context of a simpleapplication.andP;  MDI is compared and contrasted to IBM's SAA CommonUser Access (CUA) guidelines for user interfaces.andM;</SUMMARY><DESCRIPT>Product:   OS/2 Presentation Manager (Graphical user interface) (standards)Microsoft Windows (Graphical user interface) (standards).andO;Topic:     TechnologyStandardsWindowingDocument PreparationGraphical User InterfaceSoftware DesignProgram Development Tools.andO;Feature:   illustrationcharttable.andO;Caption:   Standard MDI menu template. (chart)MDI keyboard accelerators. (table)MDI message flow. (chart)andM;</DESCRIPT><TEXT>MDI: An Emerging Standard for Manipulating Document WindowsandM;The Multiple Document Interface (referred to herein as MDI) is a userinterface style developed for Microsoft Windows and OS/2 Presentation Manager(referred to herein as PM) that supports the viewing of multiple childwindows within a main application.andP;  Each of these smaller child windows canbe used to display different sets of data or multiple views of the same setof data.andM;This article describes MDI, focusing on the user interface (see Figure 1) aswell as programming aspects of the standard.andP;  In the process, it describes aWindows library (MDI.LIB), which will let you easily incorporate the MDIinterface into your own applications.andP;  The use of this library will then bedemonstrated within the context of a simple application (COLORS.EXE).andO;Finally, the MDI standard will be contrasted and compared to the IBM SystemsApplication Architecture (SAA) Common User Access (CUA) guidelines for userinterfaces.andM;Background andamp; MotivationandM;Windows and PM developers have long been fascinated with applications thatcontain windows within windows.andP;  This interest stems from both the naturalcapabilities of the host environments and the influence of other windowingsystems.andP;  MDI can therefore be considered an outgrowth of programmers'interest and experience as they have attempted to create a shared-menuenvironment inside Windows.andP;  This work, after considerable refinement in theWindows environment, is now being applied to OS/2 PM.andM;To a degree, the development of MDI satisfied some creative instinctsexpressed by developers while also providing multi-window functionality forIBM-compatible personal computers.andP;  In addition, its specification isfacilitating the development of an entirely new class of interoperableapplications that create similar user interfaces on the Macintosh, Windows,and OS/2 PM.andM;From this beginning, the MDI specification was refined and extended(primarily by Microsoft) in a determined effort to make it reasonably CUAconformant.andP;  The result of this effort was the formal definition of MDI inthe Microsoft Windows Software Development Kit (SDK) followed by itsimplementation in Microsoft Excel--the first major application to use the newspecification.andM;Following the lead of Microsoft Excel, many software developers have triedusing multiple child windows in their applications, but unfortunately only afew have succeeded in fully implementing the original specification.andP;  Thisfailure is due in part to the fact that MDI is reasonably difficult toimplement correctly since it requires a good low-level understanding of theunderlying environment.andP;  Furthermore, implementing MDI in Windows involves anumber of subtle tricks, which in the best circumstances might be consideredpoor programming practice.andM;Despite its difficulties, in recent months the acceptance of MDI has beenfurther solidified with its incorporation into the new (although in myopinion not very well designed) OS/2 file system (see Figure 2).andP;  Thiscoupled with the also new but more consistent PM programming model shouldfurther enhance its appeal to both developers and publishers alike.andM;Definition andamp; SpecificationandM;From the start, it must be clearly understood that MDI is a user interfacestyle; that is, it is not a set of absolute rules but a collection of a fewunderdefined guidelines.andP;  Although many software developers have implementedMDI within the general style guidelines, few have implemented it in exactlythe same way.andM;The first thing to understand about MDI is its main, or top-level, desktopwindow.andP;  This window is almost always resizable, with a title bar equippedwith a standard system menu and minimize/maximize icons.andP;  In mostcircumstances, the title bar, or caption, of the main window contains onlythe name of the application (more on this later).andP;  As with most windows, thestandard system menu is provided with the following options and accelerators:Restore  Alt-F5 Move Alt-F7 Size  Alt-F8 Minimize  Alt-F9 Maximize  Alt-F10Close  Alt-F4andM;The main window is also used to display each of the application menusbelonging to its associated child windows.andP;  The application menus varyaccording to the type of document the active child window contains.andP;  Forexample, when the user moves from a child window that contains a chartdocument to one that contains a spreadsheet document, the main applicationmenu changes to reflect the capabilities of the active child window.andP;  Somemenu items can remain active regardless of which child window is selected(for example, various file or formatting commands that have equivalentmeaning in different contexts).andM;In addition, the main menu provides a Window management pull-down menu.andO;Commands on the pull-down menu are applicable regardless of the child windowselected, allowing the user to manage the main window and all its children.andO;The first part of the pull-down menu has commands that allow the user tomanage the size, position, and visibility of each of the child windows.andP;  Thenext part has a list of all the currently visible (including iconic) childwindows.andP;  In most cases, the Window pull-down menu looks something likeFigure 3.andM;The New command lets the user create a new view into the currently selecteddocument.andP;  That is, the user creates a new child window that contains thecurrently active document.andP;  Although this might not always be appropriate, itis useful in situations in which the user wishes to view a different portionof the same document.andP;  It could be used, for example, to support multipleenlargements of a drawing in a paint program: one window could contain theentire image and another a detailed view.andM;Since screen &quot;real estate&quot; is quite limited, most MDI implementationsincorporate some mechanism to arrange the various child windows.andP;  Here,following the New command, are two commands that help manage the visualarrangement of the child windows.andM;The Tile command &quot;tiles&quot; each of the active child windows inside the parentclient area.andP;  Although many effective tiling algorithms can be devised, mostassign some sort of priority to the currently active child window and placeit in the largest space available.andP;  Note that in most implementations theTile command is a one-time event--any subsequent movement of the childwindows will destroy the tiling.andM;The Tile Always command is an extension of the Tile command as it forces allof the child windows to remain cotinuously tiled.andP;  When the size of one childwindow is adjusted, the relative sizes of the other children are changed tocompensate.andP;  Any change to the parent window or to one ofthe childrenautomatically causes a tiling to occur around it (much as it did with WindowsVersion 1.03).andP;  Although this technique has not been used in any majorWindows or PM applications, it has many merits that warrant seriousconsideration.andM;Frequently users end up with many documents open simultaneously, resulting ina cluttered desktop.andP;  Following the tiling commands are therefore twocommands that enable the user to hide or show one or more child windows.andP;  TheHide command lets the user hide the currently active child window (see Figure4).andP;  One popular variation on this theme is to let the user simultaneouslyhide one or more child windows using a dialog box that contains a multipleselection list box.andP;  This makes it possible for the user to clear a portionof the desktop in one fluid motion.andM;When windows are hidden, they remain active but cannot be accessed.andP;  By usingthe Unhide command, the user can select one or more windows (from a list ofall hidden windows) and make them visible again (see Figure 5).andP;  The windowscan be restored to their original size and location or, if tiling is active,merged into the desktop.andM;The last group of items on the Window pull-down menu is a list of allcurrently active child windows.andP;  The windows are listed by title, with eachtitle preceded by a digit that serves as a short mnemonic.andP;  This facilitatesquick and consistent keyboard access to each child window regardless of thecurrent title.andP;  If a currently active child window exists, it is indicated bya check mark beside its title.andM;In some applications, certain commands may only be applicable to the mainwindow.andP;  When this is the case, the main window may be listed at thebeginning of the window list.andP;  This allows the user to access the commandsthat are supported by the main window quite easily.andP;  Applications that do notneed this feature can omit the main window from the window list.andM;Child WindowsandM;The next thing to understand about MDI--after its main desktop window--is itsassociated child windows.andP;  Like the desktop, each child window is resizableand contains a title bar.andP;  The title bar normally has the name of thedocument being edited.andP;  If a single document is being viewed by more than onechild window, a number is appended after the document name; for example,CHART.XLC:1 CHART.XLC:2 CHART.XLC:3andM;Only one child window can be active at a time, and it is distinguished fromthe others by a change in the color or pattern of the title bar (usually withthe same mechanisms used to differentiate the main desktop from othertop-level windows).andP;  Note that the main desktop window remains active whenone of the child windows is enabled.andP;  To a certain extent, this appears to bea visual contradiction since the input focus seems to be simultaneouslyshared between two windows, to say nothing of the programmatic hoops you haveto jump through to accomplish this sleight of hand.andM;The active MDI child window also contains a control or system menu box.andO;Although similar to the one maintained by the parent window, it is activatedby the Alt-Minus key combination (I'm not completely sure of the rationalebehind this).andP;  The commands on the child system menu are identical to thoseon the main window, except that the Alt key is replaced by the Ctrl key.andP;  Theend result is a system menu that contains the following options andaccelerators: Restore Ctrl-F5 Move  Ctrl-F7 Size  Ctrl-F8 Minimize  Ctrl-F9Maximize Ctrl-F10 Close  Ctrl-F4andM;It is left up to the application to disable or gray any of these commandsthat are inappropriate.andP;  In most implementations, only the Minimize commandis disabled.andM;The Move and Size commands (accessed by Ctrl-F7 and Ctrl-F8, respectively)allow the location and size of the child window to be controlled.andP;  Thesefunctions mirror the ones available on the desktop but are restricted to keepthe child window inside the parent.andP;  Like most operations, the movement andresizing of the child windows can also be accomplished using the mouse.andM;An interesting item to note is how the child window frame is handled whenmoved.andP;  Although the mouse is clipped to the client area of the desktop, inWindows the frame can extend outside the parent window boundary.andP;  In PMimplementations of MDI, the frame is clipped by the system to the client areaof the desktop.andM;The Minimize command (Ctrl-F9), seldom implemented in Windows, reduces thechild window to an icon inside the MDI desktop.andP;  The resulting icon can thenbe selected, moved around the desktop to a new location, and restored to itsoriginal size and location.andP;  As is the case with all visible child windows inthe MDI desktop, the icon can be hidden or selected using the Windowpull-down menu.andP;  Note that throughout this process the icon must remaininside the client area of the desktop window and cannot be moved elsewhere onthe display.andP;  Although this is relatively easy to accomplish in OS/2 PM, itadds a whole new level of complexity to a Windows implementation of MDI (andso is seldom implemented).andP;  In PM, however, it is considerably easier toimplement this feature, and I expect that more applications will takeadvantage of it when implementing MDI.andP;  Refer to the WITHIN sampleapplication in the MS OS/2 Software Development Kit Version 1.1 (OS/2 SDK) ifyou're curious.andM;The Maximize command (Ctrl-F10) causes the child window to be enlarged tofill the entire client area of the desktop window (see Figure 6).andP;  As ashortcut, you can use the mouse and clikc inside the maximize icon ordouble-click anywhere in the title bar.andM;Since the client area of the child window fills the main window, you canconsider that the title bar of the child &quot;slides under&quot; the menu bar of thedesktop window.andP;  When this happens, two other changes occur.andP;  The firstregards the main window caption.andP;  Originally, it contains only theapplication name.andP;  But when a child window is maximized, the title bar of thedesktop is changed to include the name of the currently active document, muchas is done in normal, non-MDI applications.andP;  The second, and perhaps evenmore complicated change, involves the movment of the child window's systemmenu to the beginning of the application menu.andP;  This allows continued accessto the child system menu, letting you close or restore the window to itsoriginal size.andM;If you think things are complicated enough, consider what happens when a newMDI child is created or an existing one is selected while another ismaximized.andP;  The MDI specification dictates that when a different child windowis selected or a new one created, it automatically assumes thecharacteristics of the previously selected window.andP;  This implies that if youcreate a new child window while in a maximized state, the new window willalso be displayed in a maximized state.andP;  Similarly, when you close amaximized child window, the MDI desktop automatically selects the nextavailable child window and maximizes it for you--whether you wanted it to ornot.andM;The Restore command (Ctrl-F5), as you might expect, causes the maximizedchild window (or minimized if implemented) to be restored to its originalsize and location among the other windows, much as it does with top-levelsystem menus.andM;Finally, the Close command (Ctrl-F4) destroys the currently selected childwindow.andP;  In situations in which the child window is one of several views intoa common document, the title bars of the remaining windows are automaticallyrenumbered to reflect the change.andP;  If the child window being closed is thelast one accessing a document, a dialog box is normally displayed to confirmany required save operations.andP;  As is the case with all system menus,double-clicking the mouse inside the system menu box is a shortcut forchoosing the Close command.andM;Another item to note about all these commands is that they apply only to thechild window that is currently active.andP;  This means only that the window has asystem menu and minimize/maximize menu boxes.andP;  Unfortunately, the originalMDI specification does not make this terribly clear.andP;  The end result is thateach of the child window is responsible for changing its visible attributeswhen it receives and loses the input focus.andM;If that isn't enough, the MDI specification also calls for a number ofkeyboard accelerators to move between the various child windows (see Figure7).andP;  Despite the fact that they keyboard accelerators are not listed on thechild system menu, they represent the only mechanism for moving between childwindows without a mouse.andP;  It is left up to users to remember (assuming theyread their manuals) what they are and how they work.andP;  Furthermore, the taskof implementing these accelerators is yet another activity that must bemanaged by the already overburdened MDI desktop window.andM;Design IssuesandM;Before I get into the actual programming issues involved with implementingMDI, it seems appropriate to discuss the design issues that are bound to comeup when working with the specification.andP;  Perhaps foremost is the additionalcomplexity associated with using MDI.andP;  If you don't have the idea by now, ittakes a great deal of time to implement MDI and get it to work correctly.andO;From a design standpoint, MDI requires that each child window beobject-oriented in nature (maintaining its own instance data) yet be able toaccess shared data that is held in common when multiple views are in effect.andO;In addition, the standard has some serious performance implications since itintroduces more support code and yet another level of hierarchy into thesystem.andM;It is also natural to compare multiple instances of tightly coupledapplications to the MDI alternative.andP;  On the positive side, a group ofindependent applications are often easier to design, implement, and test,especially when the environment takes care of the data-handling issues foryou.andP;  This approach works especially well when using non-Windows-awareapplications or those whose hold on the environment is tenuous in the best ofcircumstances.andM;On the negative side are the resulting cluttered display, lack ofinteroperable consistency with the Macintosh, and difficulties ofwell-integrated inter-process communication between separate applications.andO;Furthermore, since many applications require the use of multiple views intothe same document, MDI is something you will probably have to think seriouslyabout.andM;Another troublesome design area with MDI is the way that it treats menus.andO;Although menus are relatively simple to structure when each child window ishomogeneous in nature and shares the same or similar capabilities, the designcan be difficult when child windows are very heterogeneous or involvecompound documents.andM;Menu design is further complicated when the desktop is empty or all the childwindows are hidden.andP;  Most of the normal menu options will be disabled and ofno interest to the user.andP;  Many applications (for example Microsoft Excel, asshown in Figure 8) respond to this situation by severely pruning their menus,adding additional menu-handling complexity.andM;One of the most serious drawbacks of the MDI standard is the problem thatresults when the desktop window is resized.andP;  Although you can't move a childwindow completely outside the client area, it is possible to have it end upthere if you change the size of the MDI parent.andP;  The end result is a window(perhaps even an active one) that is completely invisible.andP;  Despite the factthat you can't point to the invisible window with a mouse, you can use thechild window accelerators to get to it--but you still can't see it.andM;An interesting visual phenomenon can be created if you use the Ctrl-Minus keycombination while the active child window is outside the client area.andP;  As youwould expect, the child's system menu appears but the child window remainshidden.andP;  The result is that the child's system menu appears unconnected tothe desktop, magically making itself visible with no apparent connection toanything else (ssee Figure 9).andP;  Interesting, maybe, but certainly somewhatconfusing for users.andM;MDI APIandM;By now you may be wondering whether MDI is something you want to takeon--especially since it doesn't really do anything except manage a collectionof related child windows.andP;  But there is a good reason to use it--thedefinition and implementation of an Application Program Interface (API) thatmanages the MDI.andP;  The end result of the API is a small library of objectmodules (approximately 16Kb in total size) that performs all the work ofintegrating MDI into your application for you.andP;  And best of all, it's noextra charge with the price of your MSJ subscription.andM;In order to accomplish the task of integrating the API into an application Ienlisted the help of friend, long-time associate, and Windows guru--GeoffreyNicholls.andP;  Together we came up with an API that lets you write complex MDIapplications as if they were standalone, independent applications.andM;We recognized from the start that developing such an API would be quite dirty(doing things we would never do in conventional Windows programming) and thatwe would really have to try to keep it small and simple.andP;  We also realizedthat we would not be able to implement the entire specification, only some ofthe more important facets--the rest we would leave to you.andP;  Finally, wewanted to make it as object-oriented as possible.andP;  After several false startsand rewrites we ended up accomplishing our goals but in so doing perhaps usedproperty lists and window offsets to excess.andM;The MDI API we came up with in a sense represents an analog of the existingWindows API.andP;  From previous experience, we knew that to a large degree theoperating characteristics of a window are defined by the default windowmessage processing function.andP;  The MDI API attempts to change this foundationand give each window a new and different set of characteristics.andP;  The netresult is a small number of routines with familiar parameter lists that canbe used together to give your application MDI chracteristics.andP;  They are shownin Figure 10.andM;Message Flow andandM;Process SequencingandM;In the next two sections we will examine the inner workings of the MDI API.andO;We first describe the general message flow and processing sequence used bythe API.andP;  Then we describe each of the top-level functions and explain someof the subtle ways in which they work.andP;  As you read these sections, refer tothe MDI source code listings accompanying this article.andP;  The code isreasonably well documented, so you should be able to understand it if youhave a good background in Windows programming.andM;Now, perhaps the most efficient way to learn about the MDI API is to studythe MDI message flow diagram carefully (see Figure 11).andP;  It tracks the pathof each message received by an application that uses the API, focusing onthose that are of particular interest.andM;The first thing to notice is the rather normal message retrieval,translation, and dispatch loop at the top of the diagram.andP;  This occurs muchas it would in any other Windows application, the only difference being in aspecific check for menu-related messages (performed inside the MdiGetMessagefunction).andP;  When such messages are encountered, they are immediatelydispatched to a window function in order to activate the various system andapplication menus correctly.andM;After the message-handling loop, each message is dispatched to an appropriatewindow function.andP;  As far as MDI is concerned, there are only two types ofwindows present--a desktop or parent window and child or document windows.andO;On the left side of the diagram, the flow of events for the desktop window islisted; on the right side, a similar flow for each of the document windows islisted.andM;Tracing down the left, or desktop side, each message is processed by the mainapplication window function, then passed on the default MDI main windowfunction.andP;  The remainder of events listed below occur inside this defaultfunction, finally ending in most messages being sent on to the standardDefWindowProc.andM;As you can see from the diagram, the default MDI main window function isprimarily interested in activation, initialization, and command-relatedmessages.andP;  All other messages are sent on without modification to theDefWindowProc.andP;  Of those intercepted, some result in a particular actionbeing performed (like the activation of a particular child window); othersare processed and sent directly to an appropriate child window--bypassing thedefault window function.andM;On the right, or document side of the diagram is the sequence of events thatoccur when messages are received by the default MDI child window function.andO;As is the case with the left side, the flow of events listed occur insidethis default function, ending with most of the messages being sent on to thestandard DefWindowProc.andM;Like the default desktop window function, the child window function isprimarily interested in activation, initialization, and command-relatedmessages.andP;  Of particular importance are the various system commands.andP;  Someare handled directly and not passed to the system.andP;  In certain cases, such asthose that involve activation of a menu or a new document window, the messageis sent directly to the desktop.andM;In key places in the diagram you can see highlighted rectangles, whichrepresent the activation of a child or document window.andP;  Figure 12 separatesthis activation step into a number of smaller components.andM;In a normal Windows application, the activation of a child window occurs withlittle fanfare, but in an MDI implementation a number of important steps mustbe performed.andP;  The first is changing the title bar color.andP;  Although Windowsallows only one window to have the input focus, when a child window isselected it seems that both the desktop and the child are simultaneouslyactive.andP;  This is done by manually sending a WM_NCPAINT message (withappropriate parameters) to the DefWindowProc of the window being activated.andM;Furthermore, under the interface specification, only the currently activedocument window contains an MDI system menu and maximize/minimize icons.andO;Because of this, the second step is to change the style of the window toinclude these new attributes and then force the system to display thechanges.andM;The next major task to perform when a document window is activated involvesreplacing the desktop menu.andP;  Each child window is associated with its ownmenu.andP;  When it is activated, the current desktop menu is replaced and the newone inserted, retaining all the attributes that it previously had.andP;  Finally,just before the input focus is transferred to the document, the Windowpull-down menu has to be updated to reflect the current status of thedesktop.andM;Like Figure 12, Figures 13 and 14 list the sequence of events that transpireseither when a document window is maximized or a different document window isselected while in maximized state.andP;  Of these two sequences, the only somewhattechnical task is the automatic insertion of the MDI system menu at thebeginning of the application menu.andP;  This involves retrieving the MDI menuicon from Windows with the following call: hBitmap = LoadBitmap( NULL,MAKEINTRESOURCE( OBM_CLOSE) );andM;The resulting bitmap contains both the standard system menu icon and the MDIone.andP;  After retrieving the bitmap dimensions (via a GetObject call), you canextract the MDI system menu bitmap for use when updating the applicationmenu.andP;  This entire sequence of events (never before publicly documented) isperformed by the MdiCreateChildSysBitmap function, should you have theinclination to see how it is actually accomplished.andM;Top-Level FunctionsandM;Now that I've discussed the message flow and process sequencing of MDI, Iwill focus on the top-level function calls provided by the API.andO;Programmatically speaking, if you understand these functions, you will beable to use the MDI interface in your own applications without a great dealof difficulty.andM;The first of these calls is MdiMainCreateWindow, which is responsible for thecreation of the main desktop window and all the associated MDI property listsrequired to make the interface work.andP;  The actual data structures used by theAPI are maintained with property lists attached to the desktop and documentwindows.andP;  A property list is an attempt to give each window access to somesort of instance data (to borrow an object-oriented programming term).andP;  Thisis accomplished by associating a window handle with a named block of memory.andO;Using the interface provided by Windows, any window can set, enumerate,retrieve, and destroy properties.andP;  Although there is no predefined limit tothe number of properties that a window can have, the property list itself,like other window-related data, is actually allocated in the local heap ofthe user library.andP;  The MdiMainCreateWindow function also attaches the Windowpull-down menu to the main application menu, making the MDI interface almosttransparent to the desktop.andM;The second API call is MdiMainDefWindowProc.andP;  As described in the MDI messageflow diagram, this function is responsible for the default processing of alldesktop-related messages.andP;  More specifically, it is interested in messagesthat involve the activation and deactivation of the desktop, menu-relatedmessages, and messages relating to the visibility and sizing of theassociated document windows.andP;  Implemented as a large switch statement, itpasses most of the messages on to the DefWindowProc.andM;The next API call is the MdiChildCreateWindow function.andP;  This function,identical in many ways to the standard Windows CreateWindow call, creates anew child window inside the desktop.andP;  Behind the scenes it sets up therelated property lists, keeps track of the window menu and accelerator table,and activates the child window correctly, depending on the current state ofthe desktop.andM;As with the desktop window, each document window is associated with a defaultMDI message-processing function, MdiChildDefWindowProc.andP;  This function isresponsible for the default handling of all document window related messages,especially those that involve system menu choices and window creation,activation, and destruction.andP;  Those messages not handled are either sentdirectly to the desktop window or are passed on to the DefWindowProc.andM;After the default child window function is a replacement for the standardWindows message function, MdiGetMessage.andP;  This function is responsible forretrieving all of the application messages from the system queue.andP;  It alsochecks for keyboard menu access and activates the correct menu when cursorkeys are used while a pull-down menu is visible.andM;Following this is the MdiTranslateAccelerators function, which is responsiblefor translating each message according to the currently active acceleratortable.andP;  Though most Windows applications have only one accelerator table, MDIapplications can have several--one for the main desktop and one for each typeof document window.andP;  This function automatically checks the state of theapplication and uses the appropriate accelerator table.andM;Finally, there are two utility functions contained in the MDI API--MdiGetMenuand MdiSetAccel--that are implemented as macros.andP;  These two functions arerequired since most applications need to define an accelerator table andaccess the current menu.andP;  The current menu handle is retrieved by theMdiGetMenu macro which returns it to the document window.andP;  The MdiSetAccelmacro attaches an accelerator table to the property list of the documentwindow.andP;  The accelerator table can then be used automatically when messagesare translated and dispatched throughout the application.andM;Taken together, these eight functions represent the entire MDI API.andP;  Althoughyou cannot use these functions with impunity, they should work well even inthe most demanding applications.andP;  If carefully used, they hide most of thesubtleties of MDI and let you focus on solving customer problems, notimplementing yet another scheme for managing child windows.andP;  The only reallynasty side effect is the installation of a system keyboard message hook.andO;This hook intercepts cursor movement keystrokes while manipulating menus.andO;Without this message hook it would be very difficult to implement a trulyauthentic MDI keyboard user interface.andM;Building MDI.LIBandM;In order to build the MDI API library, you will have to create the fileslisted in Figure 15 (these files, not included here due to spaceconsiderations, are available for downloading from any MSJ bulletinboard--Ed.).andP;  In addition to these source files, you will need the MicrosoftWindows Version 2.1 SDK and the Microsoft C Optimizing Compiler Version 5.1.andM;The library MAKE file (MDI) will compile each of the modules in the mediummodel and combine them into an object library using the LIB utility providedwith the C compiler.andP;  The resulting library is then ready for use withoutmodification by any medium model Window application.andP;  If you wis, you canchange the make file compilation flags and create equivalent small, compact,or large versions of the same library.andM;Using the MDI APIandM;I will use the program COLORS.EXE to show how the MDI API is used in thecontext of a simple application.andP;  I chose this program since it will celarlydemonstrate the simple and straightforward use of the MDI API.andP;  In many ways,COLORS can be considered a collection of three different, yet relatedprograms.andP;  For one, although the three parts of COLORS share the same windowprocedure, they act as if they were three separate applicattions.andP;  Using theMDI API they are brought together into one desktop.andM;With the COLORS desktop, you can create a number of red, green, and bluecolored document windows.andP;  The colored windows are created by using theNew...andP;  option under the File pull-down menu.andP;  Each window is successivelynumbered and, via an associated pull-down menu, can be modified to displaydifferent intensities of color.andP;  Of the three types of document windows, theblue one is unique in that it is also associated with an accelerator table.andO;By using keys 0, 1, 2, 5, and 7 you can change the intensity of the bluebackground color to 0 percent, 100 percent, 25 percent, 50 percent, and 75percent respectively.andP;  See Figure 16 for an example.andM;When several documents are present on the desktop, you can move from windowto window using one of three mechanisms--selecting a window with the mouse,moving to another window using the keyboard user interface, or pulling downthe Window menu and manually selecting a different window.andP;  Additionally,using the Window pull-down menu, you can hide the currently active documentwindow or possibly redisplay hidden ones in a traditional MDI fashion.andM;You can build COLORS from the source code listed in Figure 17, which includesthe following files: COLORS COLORS.DEF COLORS.RD COLORS.H COLORS.CandM;Each reference to the MDI API is clearly identified and highlighted in Figure17.andP;  The first reference to notice is in the appliction MAKE File.andP;  Here,COLORS is dependent on both MDI.H and MDI.LIB.andP;  In addition, the MDI libraryis referenced in the linkage command line, which allows COLORS to use any ofthe public MDI API routines we previously defined.andM;The next MDI reference of interest is contained in COLORS.DEF, which is whereboth the MdiMsgHook and MdiDlgUnhide functions are exported.andP;  They both mustbe exported since they represent movable entry points used by the system.andO;Failure to do so will cause serious problems.andM;The third reference to the MDI API is in COLORS.RC.andP;  Note the inclusion ofthe MDI.H header file and the definition of a number of MDI-related resourcesat the end of the file.andP;  The first of these resources, the MDI window menu,is used as a template for the Window pull-down menu.andP;  The MDI API creates aduplicate of this menu, attaching a list of the currently visible documentwindows at the end.andM;The next resource is the MDI child window accelerator table.andP;  This table,which is automatically loaded by the API, is used to implement the documentwindow keyboard user interface.andP;  Last in the resource file is the templatefor the MDI Unhide dialog box.andP;  This dialog box is displayed when theUnhide...andP;  command is selected from the Window pull-down menu.andP;  With thisdialog box you can select a hidden document window and hav it redisplayed onthe desktop.andP;  You can also change the style and characteristics of the dialogbox to suite your application, although you should be careful not to alterthe name and identifiers used.andM;Following the resource file is COLORS.C, which contains all of the C sourcecode for the COLORS application and is structured much like any other windowsprogram.andP;  COLORS.C (like COLORS.RC) also references MDI.H.andP;  In addition todefining all MDI related identifiers, MDI.H needs to be included since itdefines function prototypes for each member of the MDI API.andM;The first MDI-related task COLORS performs is the creation of the maindesktop window using the MdiMainCreateWindow function inside MainInit.andP;  Thiscall creates an empty window that contains the default desktop menu.andP;  Notlong after MdiMainCreateWindow is a call to ColorCreate, a utility functionthat creates a new document window using the MdiChildCreateWindow functionand associates it with an appropriate accelerator table.andP;  In this case, thedefault action is to create a single red document window.andM;Once the desktop has been created and initialized, the application retrievesand processes all related messages.andP;  Like most Windows applications, this isaccomplished with a simple GetMessage loop followed by the translation anddispatch of each message retrieved.andP;  In this case, however, MdiGetMessage andMdiTranslateAccelerators are used in place of the normal Windows functions.andM;The next reference to the MDI API occurs in the MainWndProc of COLORS.andP;  Eachmessage that is dispatched by the message-processing loop is sent directly tothe responsible window function.andP;  The MainWndProc handles all the messagesthat relate to the desktop window.andP;  In addition, since the desktop window isthe only one that contains a menu, it also receives all menu-relatedmessages.andM;The desktop message processing function traps only the file-related commandsand passes the rest of the messages to the MdiMainDefWindowProc foradditional handling.andP;  The MdiMainDefWindowProc in turn processes the commandsin which it is interested (redirecting some to the appropriate documentwindow function) and passes the rest on to the system via the DefWindowProc.andM;Throughout this process, the main window message processing function canreceive menu commands belonging to any one of the child windows.andP;  because ofthis capability, it is recommended that each document window menu share acommon set of commands that are applicable at the desktop level.andP;  In COLORS,these commands are all those listed under the File pull-down menu.andM;Note that it is only necessary to conceptually separate the desktop anddocument menus, not each of the associated document menus.andP;  This is becausemenu commands not intercepted by the desktop are only destined for thecurrently active document window, not for those that are inactive.andM;The last references to the MDI API occur in the ColorWndProcmessage-processing function.andP;  This function, shared among each of the coloredchild windows, responds to the document menu commands and paints the windowbackground using the default color at the selected intensity level.andO;Throughout ColorWndProc, MdiGetMenu is used in place of GetMenu.andP;  This isbecause the desktop window contains the menu for the document window andisn't always the immediate parent [else GetMenu(GetParent(hWnd)) would be asuitable alternative].andM;Like the desktop window function, ColorWndProc passes most of the messages onto the default MDI message-processing function, in this caseMdiChildDefWindowProc.andP;  This function in turn processes a subset of themessages and passes the balance on to the DefWindowProc.andP;  In certainsituations, messages are redirected to he desktop window and not sentdirectly to the system.andM;When you build COLORS, experiment with it and see how the internal functionsrespond in a variety of situations.andP;  Try and hide all the document windows orcreate new ones while one is in a maximized state.andP;  In particular try out thekeyboard user interface, moving from document to document without the aid ofa mouse.andM;In a while you will begin to appreciate how much is going on in thebackground to make the interface work consistently.andP;  Yet despite the visualsophistication, there is the increased overhead required by the API.andP;  If youswitch rapidly between different document windows, then the additionaloverhead will be readily apparent.andP;  Although in part due to the relativelysimple-minded message-handling approach of COLORS (which passes everything onto the default window function), to a large degree it can be attributed tothe MDI API itself.andM;Nevertheless, keep in mind that the MDI API implemented here was designed forclarity and readability, not for size and performance.andP;  Our internal workingversion of the API (on which the published library was based) implemented thefull MDI specification considerably more efficiently than this one does(including Window New, Tiling, and the ability to minimize document windows).andO;The central structure, however, remains the same--with a little tuning andenhancement, the base API presented here is capable of supporting world-classMDI applications with unparalleled ease.andP;  Coupled with a little rethinking ofyour current data-handling techniques, you will be able to adapt many of yourexisting Windows applications to the MDI user interface easily.andP;  And, perhapsbest of all, with the MDI API you can accomplish this with few changes toyour source code.andM;MDI and SAAandM;In addition to the interoperability benefits of MDI, one of the mostsignificant forces behind its acceptance in the development community isIBM's SAA.andP;  Although a comprehensive overview of SAA is outside the scope ofthis article, we will briefly describe it to show how the SAA specificationinfluences MDI.andM;SAA is a set of selected software interfaces, conventions, and protocols thatserve as a common framework for application development, portability, and useacross three major computing platforms--the IBM System/370, System/3X, andthe personal computer.andM;A significant part of SAA is the CUA specification.andP;  This standard defines,in a lengthy set of rules and guidelines, what SAA-compliant user interfacesshould look like and how they are to be used.andP;  The end result is a 300+ pagedocument (available from your local IBM representative or branch office) thatdescribes in laborious detail the SAA human/machine interface.andM;Why are SAA and CUA important?andP;  Regardless of what you think about them, thecompelling fact of the matter is that many large corporations are attemptingto settle on a common user interface that spans a variety of hardwareplatforms.andP;  This drive is in part motivated by the hope that users will beable to migrate easily from machine to machine without the customary learningcurve associated with the transition.andP;  Corporations are starting to requirevendors to provide SAA, CUA-compliant software.andP;  Microsoft has been activelytrying to capitalize on this by making Windows SAA, CUA-compliant (hence allthe unusual keyboard accelerators).andM;MDI, being an integral part of the Microsoft Windows strategy, fits into thisoverall standard.andP;  The net effect--and this is why MDI is important for youas a software developer--is that if you use the MDI interface (as opposed tosome other scheme) in your application, your potential users will already befamiliar with the interface and you could potentially sell more software.andP;  Atthe very least, you should take a close look at the IBM SAA, CUAspecification and give it careful consideration.andP;  Personally, I have a hardtime living with the constraints CUA puts on me as a developer, but I amwilling to live with them if I am put my programs in front of a largercustomer base.andM;I hope this discussion has given you ideas and insights that will help you inyour own development.andP;  MDI just might be the answer to some technical problemyou are struggling with.andP;  As you consider MDI, realize that to a large extentit has evolved from the need for an organized way of handling multipledocuments within a single desktop.andP;  This evolution has been at besttroublesome and is still somewhat at odds with the underlying environment.andO;Perhaps in the future something like the MDI API might be included in theWindows or OS/2 Presentation Manager API, saving both you and me a great dealof effort.andP;  Until that time, you have access to a little more informationthan you did before.andO;</TEXT></DOC>