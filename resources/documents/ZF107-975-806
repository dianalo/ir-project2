<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF107-975-806  </DOCNO><DOCID>07 975 806.andM;</DOCID><JOURNAL>Communications of the ACM  Dec 1989 v32 n12 p1415(11)* Full Text COPYRIGHT Association for Computing Machinery 1989.andM;</JOURNAL><TITLE>Design complexity measurement and testing. (using design metricsto quantify the complexity of a software design ) (technical)</TITLE><AUTHOR>McCabe, Thomas J.; Butler, Charles W.andM;</AUTHOR><SUMMARY>Methods of using cyclomatic complexity to modularize and testsoftware architectures are discussed.andP;  This mathematical techniquecan be readily applied to architectural hierarchical design.andO;Software metrics include adding compound predicates, whichincrease program complexity.andP;  A path-subtree analogy is given,along with examples of module design complexity, designcomplexity, and integration complexity.andP;  Each measure provides ameans of quantifying the complexity of a design and can be animportant management tool.andM;</SUMMARY><DESCRIPT>Topic:     Software DesignComplexity ClassesSoftware ValidationTechnologySoftware EngineeringProgram TestingDebugging.andO;Feature:   illustrationcharttable.andO;Caption:   Sample flowgraph with cyclomatic complexity. (chart)Reduction example 1. (chart)Integration path test metrics. (table)andM;</DESCRIPT><NOTE>Only Text is presented here; see printed issues for graphics.andO;</NOTE><TEXT>Design Complexity Measurement and Testing During the past decade, softwaredevelopment concepts have undergone a dynamic revolution.andP;  Softwaredevelopment methodologies have evolved to meet changing life cycle patternswhich have had as their objective, emphasis on analysis and design.andP;  Inaddition, computer-assisted software engineering (CASE) has emerged to meetthe unprecedented growth in analysis and design activities and is affectinghow future systems will be developed and tested.andP;  These methodologiesreinforce the need to accurately define systems specification prior toimplementation.andM;The concern over present and future software quality has grown as the volumeand complexity of applications increase.andP;  Software applications are criticalto business operation and lead to severe maintenance problems when they fail.andO;This fact has prompted many firms to develop software engineering programswhich attempt to define and implement techniques for software validation,verification, and testing throughout the development life cycle.andM;THE PROBLEMandM;Since there is increased emphasis on earlier stages of the life cycle, thereas a need to build design complexity measures for the development of softwaresystems and to formulate a procedure to utilize them in testing.andP;  Users,software managers, and project leaders try to justify projected cost and timefor development as the development cycle proceeds.andP;  Projections made duringdesign have to improve upon those made during specification and shouldgenerate a more accurate projection of future testing requirements.andP;  Sincecomplexity is a significant determinant of a system's success or failure, therisk is high for development decisions based strictly on qualitativeevaluations.andP;  A number of the same concerns which are addressed for programcomplexity apply equally as well at th design level:andM;1.andP;  Designs with which we deal are overwhelmingly complex.andM;2.andP;  Designs cannot be fully comprehended by developer or reviewer.andM;3.andP;  Designs are not rigorously verified through a testing process.andP;  In thisinstance, testing strategy is not derived directly from the designspecification (nor is the level of testing directly proportional to thecomplexity of the design).andM;Quality software should have the characteristics of being understandable andmeasurable [1].andP;  Measurements are closely linked to software metrics theorywhich has received growing attention over the past decade.andP;  Much of theresearch on software metrics has been involved with program complexitylanguages such as PL/I, Pascal, Fortran, adn C.andP;  While many studies dealtwith the subject of measuring program complexity, few studies haveconcentrated on measuring complexity of development specifications.andM;THE OBJECTIVEandM;The software engineer should consider the design complexity and shouldunderstand its implication before proceeding into the construction stage ofsoftware development.andP;  Furthermore, few formal theories exist from which adesign complexity measure can be generated.andP;  One such approach, cyclomaticcomplexity, is a mathematical technique for program modularization and unittesting.andP;  Before cyclomatic complexity can be used in measuring designcomplexity, certain aspects must be examined.andM;The objective of this article includes two elements.andP;  The first is to extendthe mathematical basis of cyclomatic complexity into architectural design ofa system.andP;  In this context, architecture design is defined as the frameworkor structure of a system such as a hierarchy chart with its associatedfunctions and control interretationships.andP;  The second element is to develop atesting methodology integrating the intuitive notions of design complexityand integration testing requirements.andM;To accomplish the stated objectives, cyclomatic complexity is applied toarchitectural hierarchical design.andP;  The cyclomatic complexity approach is tomeasure and control the number of paths through a program.andP;  It limits thenumber of basis paths in a source module.andP;  The analogous design entity is thesubtree.andP;  Therefore, a major component of the methodology is to measure thenumber of subtrees through an architectural design.andM;In addition, fundamental tenets of structured testing for program areutilized to build a testing methodology for integration testing of anarchitectural design.andP;  Two tenets, cyclomatic complexity and a basis set oftest paths, are utilized as components of structured integration testing.andO;From this methodology, refinements are added and important integrationstrategies, such as top down and critical piece implementation areconsidered.andM;CYCLOMATIC COMPLEXITYandM;Since 1976, a number of software metrics have been developed.andP;  From the widerange of software metrics, four basic theories have been the source of themajority of the research conducted on software metrics.andP;  The first threetheories were defined by Halstead, Albrecht, and DeMarco [2, 8-11, 13].andP;  Thelast of these theories was defined by McCabe, as cyclomatic complexity, ameasure of the number of paths through a program [16].andP;  The number of pathscan be infinite if the program has a backward branch.andP;  Therefore, thecyclomatic measure is built on the number of basis paths through the program.andM;Cyclomatic complexity, v(G), is derived from a flowgraph and ismathematically computed using graph theory.andP;  More simply stated, it is foundby determining the number of decision statements in a program and iscalculated as:andM;v(G) = number of decision statements + 1andM;By counting the decision statements, called predicates, the complexity of aprogram can be calculated.andP;  However, many decision statements containcompound conditions.andP;  An example in a comppound IF statement:andM;IF A = B AND C = D THENandM;If the predicates are counted in this example, v(G) is equal to 2 (1 IFstatement + 1).andP;  If compound conditions are counted, the statement could beinterpreted as:andM;IF A = B and IF C = D THENandM;Therefore, v(G) would be 3.andP;  Cyclomatic complexity recognizes that compoundpredicates increase program complexity and integrates individual conditionsin order to calculate v(G).andP;  An upper limit of 10 for program complexity isprosposed because greater complexity would be less manageable and testable[16].andM;Software Metric ResearchandM;Although cyclomatic complexity yields quantification, there is no researchwhich was established absolute thresholds for quality software.andP;  A number ofstudies, however, have investigated its significance.andM;In one study, Myers calculated v(G) for the programs contained in the classictext by Kernigan and Plauger.andP;  For every case in which an improved programwas suggested, this improvement resulted in a lower value for cyclomaticcomplexity [15, 17].andP;  In a second study, Walsh collected data on the numberof software errors detected during the development phase of the AEGIS NavalWeapon System.andP;  The system contained a total of 276 modules, approximatelyhalf of which had a v(G) of 10 or less and half a v(G) more than 10.andP;  Theaverage error rate for the modules in the first group was 4.6 per 100 sourcestatements while the corresponding error rate for the more complex moduleswas 5.6 [21].andP;  In a series of controlled experiments conducted at GeneralElectric, v(G) was found to predict the performance of programmers oncomprehension, modification, and debugging tasks [19].andP;  Finally, Henry,Kafura, and Harris reported empirical error data collected on the UNIXoperating system.andP;  The correlation between cyclomatic complexity and thenumber of errors was above 0.90 [14].andM;More recently, research has provided evidence of the management potential ofsoftware metrics.andP;  A study by Butler, Richardson, and Hodil utilized softwaremetrics as an important ingredient for a prototype knowledge-based system [3,4].andP;  The knowledge representation scheme was rule-based, and the rules weredeveloped to evaluate and prescribe maintenance action for commercialsoftware.andP;  Since cyclomatic metrics correlated with key performance measuressuch as mob failure and success, they were integrated into the rules for theKBS.andM;Taking a different approach, Carver measured the effects of programmodification during testing on nuermous complexity metrics [5].andP;  One of theconclusions reached by Carver was that if viable estimates of complexityincreases are computed early in the software development process, thesoftware designer can determine when a module should the subdivided.andO;Subdivision, itself, creates a practical dilemma within the testing phase.andM;Petschenik outlined the need for practical priorities in system testing [18].andO;While identifying three priority rules that provide criteria for selectingtest cases, he found that developers focused on individual system componentsrather than how those components worked together.andP;  However, as Carveralluded, it would represent an important mangement tool for the softwaredesigner, if the metric could be used to quantify individual components andtheir integration needs.andM;DESIGN COMPLEXITY METRICSandM;BackgroundandM;The current principles of the cyclomatic complexity metric are to (1) applyit to source code; (2) avoid excessive complexities that cause reliabilityproblems; and (3) use the quantification to drive a testing process that willdetect errors.andP;  Given a program, a flowgraph can be associated with it.andP;  Inthe graph, each node corresponds to a block of code where the flow issequential and arcs correspond to branches in the program.andP;  The cyclomaticcomplexity of a graph with n vertices, e edges, and p connected components is[20]andM;v(E) = e - n + pandM;Based on established mathematical properties, the cyclomatic complexity isequal to the maximum number of linearly independent paths through theprogram.andP;  Thus, as illustrated in Figure 1, the cyclomatic complexity of theflowgraph isandM;v(E) = 15 - 11 + 1 = 5 for e = 15, n = 11, and p = 1andM;A basis set of five paths is also defined representing the maximum number oflinearly independent paths through the program.andM;Path Subtree AnalogueandM;In structured design, the primary design instrument is the structure chat orhierarchy tree.andP;  As stated earlier, the previous cyclomatic work waspath-based.andP;  The analogous design entities are a design tree and a designsubtree.andP;  A design three is the ordering established by the hierarchicalrelationship among modules of a system.andP;  A design subreee is a realizablesubset of this hierarchy that can be executed through a design's input data.andO;Invoking a design tree means that it is entered at the top, executeslower-level modules and eventually exits through the top.andP;  This processresults in a subtree within the original design tree structure.andP;  Just as aprogram can have an inordinately high number of paths, it is possible that adesign tree can have an overwhelming finite number of subtrees.andM;An example will help illustrate the design tree and design subtree concepts.andO;Figure 2 shows a design with complexity 1, the only subtree is the designstructure itself.andP;  The design tree in Figure 3 has the same number of modulesand interrelationships as the design tree in Figure 2.andP;  It is, however, moredynamic as there are six decisions within it, noted by the decision (dot) andrepretition (loop) conditions.andP;  One subtree is 1, 2, 5, 10, and 11 indicatingthe functions 1, 2, 5, 10, and 11 are invoked.andP;  However, function 2 does notinvoke function 6 and function 1 does not invoke functions 3 and 4 and theirassociated subordinate functions.andM;Assume in the design structure illustrated in Figure 3 that the loop inModule 1 iterates between 1 and 3 times.andP;  The following expression quantifiesthe number of possible subtrees in the design.andP;  [1]andM;[Mathematical Expression Omitted]andM;= 3,485,040andM;The reader can see that compared to everyday designs the illustrated designis relatively straightforward, but it yields a total of more than threemillion distinct subtrees.andP;  For this reason, the total number of subtreescannot be used as a practical design structure quantification.andM;In building the architectural design analogue, design reliability is enhancedwhen (1) design complexity is quantified; (2) design complexity is limited;and (3) the integration testing process is driven with design metrics.andP;  Giventhe fact that the number of distinct subtrees can be arbitrarily high evenwithin a relatively simple design, counting the subtrees for our designcomplexity is nonsensical.andP;  We will, therefore, define integration complexityto be a basis set of subtrees that, when taken in linear combinations, yieldthe entire set of subtrees.andM;Subtrees vs.andP;  PathsandM;Generally, the structure chart defines how modules work together.andP;  Astructure chart does not define how each individual module works.andP;  Given thispremise as a basis, consider the design tree C in Figure 4, Module Mconditionally invokes modules A and B.andP;  Pseudocode for module M yields theflowgraph in Figure 4.andP;  In the flowgraph, darkened nodes A and B representthe CALL's to invoke subordinate modules A and B.andP;  The cyclomatic complexityv(M) is 4.andP;  However, a portion of the complexity of module M has no influenceon module M's control over A and B.andP;  Module M's flowgraph can be reduced to Ras shown in Figure 5.andP;  The complexity of the reduced graph, iv(M), is 3.andO;Each basis path through R yields a subtree in the design tree C.andP;  First, pathEAX yields subtree MA.andP;  Second, path EBX yields subtree MB.andP;  Finally, path EXyields subtree M.andP;  Thus, the reduced flowgraph corresponding to the controlstructure between modules generates the subtrees with the design.andM;Module Design ComplexityandM;This process produces the first design metric.andP;  Module design complexity of agraph G. iv(G), is the cyclomatic complexity of its reduced graph.andP;  Reductionis performed to eliminate any complexity which does not influence theinterrelationship between design modules.andM;There are four reduction rules which are applied to produce a module's designcomplexity.andP;  The key to the reduction principles is the existence andrelationship of predicate nodes and black dots (calls), illustrated in Figure6.andM;The reduction rules are as follows:andM;1.andP;  Sequential black dot: a call to a subordinate module cannot be reduced.andM;2.andP;  Sequential white dot: a sequential node can be reduced to a single edge.andM;3.andP;  Repetitive white dots: a logical repetition without a black dot can bereduced to a single node.andM;4.andP;  Conditional white dots: a logical decision with two paths without a blackdot can be reduced to one path.andM;Applying these four reduction principles to a module's flowgraph results in amodule's primary control structure for calling subordinate modules.andM;The application of the first three reduction rules is straightforward; rule4, however, will be elaborated upon.andP;  Consider the initial flowgraphs inFigure 7.andP;  Assume that this flowgraph represents module A with cyclomaticcomplexity of 4.andM;Step 1: Nodes 5 and 7 are eliminated using rule 2.andM;Step 2: An edge from node 2 to node 6 is removed using rule 4.andM;Step 3: Node 2 is eliminated using rule 2.andM;Step 4: Node 6 is eliminated using the 2.andM;Step 5: The edge from Node 1 to Node 8 is removed using rule 4.andM;Step 6: Node 8 is eliminated using rule 2.andM;The resulting subalgorithm is a module design complexity iv(A) = 2.andP;  Noticethat a set of 2 basis paths through the reduced graph is the desiredintegration test strategy.andM;Design ComplexityandM;After determining the module design complexity of the individual componentsof a design, it is possible to calculate the design complexity of a structurechart.andP;  The design complexity, called [S.sub.0.,] of a module M is defined asandM;[Mathematical Expression Omitted]andM;where D is the set of descendants of M unioned with M.andP;  Both design andmodule design complexities are calculated for the modules in Figure 8.andP;  Inthe illustrated design, modules C, D, E, and and F have module designcomplexity of 1, since none call descendants.andP;  Reduced subalgorithms for M,A, and B produce a module design complexity of 3, 2 and 2 respectively.andO;Module A design complexity is its own module design complexity plus itsdescendant's module design complexity [(S.sub.0.(A)] = iv(A) + iv(D) = 2 + 1= 3).andP;  The same computation is used to calculate Module M and B designcomplexity.andP;  Module B is the sum of its module design complexity (iv(B) = 2)plus its descendants (iv(E) = 1 and iv(F) = 1).andP;  Module M design complexityfor this illustration is 11 which represents the complexity for the entirestructure chart.andM;Figure 8 is a design which is a pure tree meaning there are no commonmodules.andP;  In this case, design complexity is upwardly additive [(S.sub.0.(M)]= iv(M) + [S.sub.0.(A)] + [S.sub.0.(B)] + [S.sub.0.(C)).]  Designs aretypical not pure trees in which case [S.sub.0] is not upwardly additive.andO;Figure 9 is a design with a common module, E. In this case, design complexitycalculations are completed by applying the formula for [S.sub.0].andP;  For moduleA, its design complexity is its own module design complexity plus itsdescendants' module design complexityandM;[S.sub.0.(A)] = iv(A) + iv(C) + iv(D) + iv(E) = 2 + 2 + 1 + 1 = 6andM;Thus, [S.sub.0] can be calculated by summing the individual module designcomplexities.andM;Integration ComplexityandM;The last design metric, integration complexity, is a measure of integrationtests.andP;  This measure, [S.sub.1.,] is a function of [S.sub.0] and the numberof modules, n.andP;  In general, integration complexity isandM;[S.sub.1] = [S.sub.0] - n + 1andM;In Figure 9, [S.sub.1] = 4 indicating there should be 4 integration tests toqualify the design.andP;  More detailed discussion of [S.sub.1] follows in thesection on a test methodology.andM;The importance of the integration complexity is inherent to its testingrequirements.andP;  Studies have shown that integration errors are as much as 30times more costly to fix than unit errors.andP;  Most of the erros found in thelater stages of development are integration errors.andP;  Consequently, propertiesof integration complexity include the following:andM;1.andP;  [S.sub.1] should be used to qualify the integration tests on a projectand their validation should be part of an early validation of the design.andM;2.andP;  [S.sub.1] quantifies a basis set of integration tests.andM;3.andP;  Each [S.sub.1] test validates the integration of several modules.andM;Each of these properties plays an important role in the development of atesting methodology.andM;Properties of Design ComplexityandM;Design complexity, [S.sub.0.,] as a measure, exhibits a number of importantproperties.andP;  First, [S.sub.0] is bounded as:andM;[Mathematical Expression Omitted]andM;where n = number of modules in the designandM;A design where [S.sub.0] = n always behaves the same way.andP;  There are noconditions calls to subordinate modules.andP;  Therefore, in this case, iv(G) = 1for each module.andP;  On the other hand, if every decision within the designaffects intermodule flow, then [S.sub.0] = [Sigma] [v(E.sub.i.),] or[S.sub.0] is equal to the summation of cyclomatic complexity for all modules.andM;The concept of design predicates can be used to calculate design complexity.andO;At the design stage, when the structure chart is the only product to analyze,design predicates are a feasible way to bound design complexity.andP;  With thisapproach, a design is evaluated without looking at the internal pseudocodefor each module.andP;  Generally, the convention is to show a conditional CALLfrom a superordinate to a subordinate module with a dot, as illustrate inFigures 3 and 10.andP;  Repetition is illustrated with an arc as shown for modules3 and 4 in Figure 3.andP;  In these cases, we define condition and repetition asdesign predicates.andP;  Moreover, for a module M, iv(M), is equal to the numberof design predicates plus one.andM;There are a number of additional properties of design complexity.andM;1.andP;  Adding a module to a design increases [S.sub.0] by at least 1.andM;2.andP;  Adding a decision to call a module increases [S.sub.0] by 1.andM;3.andP;  Multiple calls to a module M (reusable code) reduce [S.sub.0] by[S.sub.0.(M).]andM;4.andP;  [S.sub.0 is defined for any subdesign D (a module M and all itsdescendants) by:andM;[Mathematical Expression Omitted]andM;When two subsystems A and B are integrated into a larger system M thefollowing holds:andM;a.andP;  The modules of M are determined by the union denoted as U of A and B:andM;M = AUBandM;b.andP;  The number of modules (denoted n(M)) is n(M) = n(A) + n(B) - n(A[Omega]B)where the intersection, denoted as [Omega], is the number of modules commonto A and B.andM;c.andP;  The design complexity [S.sub.0.(M) is determined byandM;[S.sub.0.(M)] = [S.sub.0.(A) + [S.sub.0.(B)] = [S.sub.0.(A[Omega]B)]andM;where [S.sub.0.(A[Omega]B)] is the design complexity of modules common to Aand B.andM;d.andP;  The number of integration tests [S.sub.1.(M)] isandM;[S.sub.1.(M)] = [S.sub.1.(A)] + [S.sub.1.(B)] - [S.sub.1.(A[Omega]B)]andM;where [S.sub.1.(A[Omega]B)] is the integration complexity of modules commonto A and B.andP;  Figure 10 illustrates the integration of two systems, M and N.andM;Assume two designs M and N are integrated through an interface at Module B.andO;Systems M and N have [S.sub.0] of 9 and 9 respectively.andP;  For the new system,[M.sup.1.,] the union of M and N yieldsandM;[S.sub.0.(MUN)] = [S.sub.0.(M)] + [S.sub.0.(N)] - [S.sub.0.(M[Omega]N)] = 9 +9 - 0 = 18 [S.sub.1.(MUN)] = [S.sub.1.(M)] + [S.sub.1.(N)] -[S.sub.1.(M[Omega]N)] = 5 + 5 - 1 = 9andM;Proper utilization of these properties provides the designer with a tool toefficiency package and test the design.andM;A STRUCTURED INTEGRATIONandM;TEST METHODOLOGYandM;Structured integration testing utilizes the design metrics developed in theprevious section to produce a testing strategy derived from the designspecification.andP;  Generally, the methodology is applied at two levels: moduleintegration testing and design integration testing.andM;Module Integration TestingandM;The scope of module integration testing is a module and its immediatesubordinates.andP;  This testing requirement is a particularly significantactiivty when packaging modules into single programs.andP;  Generally, themethodology is implemented using three steps.andM;1.andP;  Apply the reduction rules to the selected module.andM;2.andP;  The cyclomatic complexity of the subalgorithm is the module designcomplexity of the original algorithm.andP;  Module design complexity determinesthe number of module integration tests required to qualify integration of themodule with its immediate subordinates.andM;3.andP;  The baselines method applied to the subalgorithm yields the designsubtrees and the module integration tests.andM;In order to illustrate the methodology, review the design shown in Figure 9.andO;Assume that module C's integration test strategy with modules D and E is tobe developed.andP;  The flowgraph in module C represents the subalgorithm afterapplying the reduction rules (step 1).andP;  Module design complexity, iv(C), is 2(step 2).andP;  Therefore, two tests are required to qualify module C'sintegration with modules D and E.andP;  The design subtrees to be executed are CDand CE.andP;  Moreover, the module integration test produre should be applied tomodules A and M since they are superordinate functions.andM;Design Integration TestingandM;A second level of testing is is derived from integration complexity.andP;  Sinceintegration complexity quantifies a basis set of integration tests, it alsocan be used to establish the integration test strategy of design.andO;Consequently, it determines the level of effort for testing a design.andO;Generally, the methodology is applied using the following steps.andM;1.andP;  Calculate iv for each module.andM;2.andP;  Calculate [S.sub.0] for each module.andM;3.andP;  Using the top level module, calculate [S.sub.1.]andM;4.andP;  [S.sub.1] is the number of basis subtrees required to qualify the design.andM;5.andP;  Build a path matrix, which is [S.sub.1] X n, to establish the basis setof subtrees.andM;6.andP;  Identify and label each predicate on the design tree.andM;7.andP;  Place the predicate label above each column in the path matrixcorresponding to the module it influences.andM;8.andP;  Apply the baseline method to the design to complete the matrix.andP;  Use 1 toindicate a module is executed and 0 to indicate it is not executed.andM;9.andP;  Identify the subtrees for the matrix.andM;10.andP;  Identify the conditions which drive the subtrees.andM;11.andP;  Build the corresponding test cases for each subtree.andM;In order to illustrate the entire methodology, consider the design structurein figure 11.andP;  The design is composed of six modules, and it contains twodesign predicates.andP;  Since module D is a shared module, the design structureis nonadditive.andP;  After applying steps 1 through 4, the iv's, [S.sub.0.'s,]and [S.sub.1] for the design yield design and integration complexity of 8 and3.andM;The path matrix (steps 5 through 7) for the integration tests is built as a 3X 8 matrix as shown in Figure 12.andP;  In this example, the two design predicatesare labeled [p.sub.1] and [p.sub.2.,] and they have been placed over modulesA and E, since they affect module execution.andP;  Applying the baseline method, abaseline is selected which executes all the modules in the system.andO;Consequently, 1's are placed under each module to indicate that it isexecuted.andP;  Alternate subtrees are found by evaluating the predicates on thebaseline, generally working from left to right.andP;  When predicate, [p.sub.1.,]andO;is evaluated on the baseline, the condition is negated.andP;  Since [p.sub.1] waspreviously set to execute module A, it now is set to not execute module A.andO;Therefore, each module subordinate to module A alone will not be executed.andO;For the third subtree, predicate, [p.sub.2.,] is evaluated.andP;  In this example,it also was set to execute in the baseline.andP;  By negating [p.sub.2] andidentifying its subordinate modules, the third subtree is defined.andP;  As aresult, the path matrix would appear as shown in Figure 12.andM;The subtrees are identified, and the conditions which drive the subtrees areestablished using the completed path matrix.andP;  Assume that [p.sub.1] and[p.sub.2] are simple predicates such as W = X and Y = Z, respectively.andP;  Then,the integration test requirements for the design would contain three subtreeswith their associated conditions (steps 9 and 10).andM;It is at the architectural level that the design metric can provideadditional development support.andP;  Historically, there have been a number ofdesign approaches such as top down, bottom up, critical piece first, andothers.andP;  These approaches can be used to evaluate the testing requirementsand establish a test plan to support the selected design approach.andP;  We canreturn to the example in Figure 11 and assume that a baseline is chosen givena critical piece first approach.andP;  If module E is critical due to performanceneeds of a real-time system, the baseline can be selected to isolate, as muchas possible, module E.andP;  Only those unconditional modules and module E'ssuperordinate modules are included.andP;  Applying the testing methodology, with afocus on module E, generates an alternative path matrix.andM;Readers should note in Figure 13 that the relative frequency of execution ofa number of modules during the test is altered.andP;  In this simple illustration,modules A and C are not executed as frequently.andP;  Given individual designapproaches, the baseline can be established to focus on key components duringthe actual tests.andP;  Consequently, the software designer can implement atesting strategy best suited for the selected design approach and derivedfrom the design specification.andM;SUMMARYandM;Quantifying the complexity of a design provides the system developer metricswhich represent an important management tool.andP;  Our design metrics--moduledesign complexity, design complexity, and integration complexity--are threesuch measures.andP;  These metrics are derivatives of the well-founded cyclomaticcomplexity.andP;  As the decision structure of a program is an importantindication of program complexity, the design structure which specifies therelationship among modules in a design also defines the overall designcomplexity.andP;  The reduction technique used to determine design complexityaddresses the need to test how modules work together rather than how eachmodule works.andP;  More importantly, the quantification can be used to drive thetesting process at two levels: individual modules and overall designframework.andP;  Calculation of design metrics represents a new management andtesting tool previously unavailable to software developers.andM;Intuitively, the design complexity metrics exhibit a number of desiredproperties which support their applicability.andM;* The metric intuitively correlates with the difficulty of comprehending adesign.andP;  When we view large complicated designs, the metric should yield ahigh number.andP;  Designs we intuitively deem as simple should have a relativelylow number.andP;  As a minimum, the complexity metric will certainly initiate hotdebate about particular designs and design methodologies in general.andM;* The metric is objective and mathematically rigorous.andP;  In addition to beingintuitive, it is critical that the metric be objective.andP;  The same designviewed at two different times or by two people should yield the samecomplexity.andP;  If it is not objective, the various vested interests involved ina development job will no doubt have differing interpretations.andM;* The metric should be related to the effort to integrate the design.andP;  Themost costly activity associated with a design is the effort to integrate themodules and subsystems within it.andP;  The proposed metrics should correlatedirectly with the cost and effort experienced in the integration phase.andM;* The metric should be of operational help.andP;  A metric that correlates andpredicts phenomena like cost and error is useful.andP;  In addition, if the metriccan directly drive the design modularization process and integration phase,it will be of immediate operational help to software developers, and it willbe very attractive to managers and quality assurance personnel.andM;* The metric should help generate an integration test plan early in the lifecycle.andP;  If the metric can be computed in the design phase, a set of teststhat are derived from the design can traverse the architecture in a rigorousway.andP;  Design errors can be a factor of 30 times more expensive than codeerrors, so catching these errors early will save substantial cost.andM;* The metric and associated process should be automatable.andP;  With the rapiddevelopment of CASE software, module design complexity, design complexity,integration complexity, and the test development process can be automated.andO;Then, the integration process becomes even more viable.andP;  In fact, a tool hasbeen developed by McCabe andamp; Associates that computes the design metrics andproduces the integration subtrees.andP;  The automated tool is currently beingapplied successfully on several projects.andM;A number of observations on limiting design complexity have been made.andM;1.andP;  Most of the designs we have seen in textbooks have [S.sub.0] less than40.andP;  In practice, [S.sub.0] is much larger.andP;  We have observed designs withover 4000 modules which represent [S.sub.0] [is greater than or equal to]4000.andM;2.andP;  Design complexity can be limited by abstracting subdesigns.andM;3.andP;  The influence of source language on design complexity can be held to aminimum.andP;  The definition of how system components work together generallyprecedes language implementation.andP;  However, packaging issues pertinent tolanguages can be addressed through module design complexity.andM;4.andP;  Design complexity can be limited by visualizing domains, utilities, andsubdesigns.andP;  Automated tools can implement these features.andM;5.andP;  Design complexity should be limited to our human bandwidths--how much wecan comprehend and how much we can integrate.andP;  Complex designs can be viewedas composites with several component designs with less design complexity.andP;  Intoday's real world, there is generally no basis for controlling and limitingarchitectural design.andM;6.andP;  Cyclomatic complexity of 10 has proved an acceptable limit of complexityat the code level; Walsh [21], for example, shows a quantum jump in errorcount at complexity 11.andP;  Since the v(G) metric quantifies the number of basispaths in a program, its closest design metric is [S.sub.1]--the number ofindependent subtrees in a design.andP;  Since it has been shown that programmershave difficulty comprehending programs with v(G) [is greater than] 10, it maywell follow that an integration domain has a similar boundary.andM;Future empirical research should provide clarification of the magnitude ofdesign metrics to each of the above points.andM;The design metrics introduced in this article are measures for quantifyingthe design in structured methodologies and establishing the integrationtesting requirements of a system.andP;  They do not suggest what magnitude ofdesign measures is detrimental to the success of a system.andP;  However, sincecyclomatic complexity is a widely studied metric and mathematical limits havebeen found, a corresponding intuitive argument can be built regarding anacceptable level of design complexity.andP;  When these design limits areestablished, they will be useful parameters to a broad range of softwaredevelopers.andM;Design metrics of the type developed in our research are needed to guide themanagers and software designers with a practical methodology for evaluatingand building an adequate test strategy.andP;  They are also valuable forcontrolling the complexity of a design and forcing the partitioning ofsystems into more manageable sizes.andP;  From this perspective, future researchcould have significant implications.andP;  If design metrics are related to timeand resources needed to develop a system, a quantifiable leading indicator ofresource requirements is gained.andP;  If viable estimates of complexity increasescan be computed as a result of requirement changes, the software developerwill be better equipped to assess requirement changes and estimate the impacton the remaining phases of the development cycle.andP;  Then, the full potentialof design metrics can be realized.andM;REFERENCESandM;[1] Adrion, W.R., et al.andP;  Validation, verification, and testing computersoftware.andP;  ACM Comp.andP;  Surv.andP;  14, 2 (June 1982), 160.andM;[2] Albrecht, A.J.andP;  Function points help managers assess applications.andO;Computerworld (Aug.andP;  26, 1985), SR20-SR21.andM;[3] Butler, C.W., Hodil, E.D., and Richardson, G.L.andP;  Knowledge-based systemsin the commercial environment.andP;  IBM Syst.andP;  J. 25, 2 (1986), 47.andM;[4] Butler, C.W., Hodil, E.D., and Richardson, G.L.andP;  Applying expert systemstechology to software maintenance.andP;  In Proceedings of the 1987 Conference onSoftware Maintenance (May 1987).andM;[5] Carver, D.L.andP;  Criteria for estimating module complexity.andP;  J. Syst.andO;Manag.andP;  (Aug.andP;  1986), 18-23.andM;[6] Curtis, B., Sheppard, S.B., and Milliman, P.andP;  Third time charm: Strongerprediction of programmer performance by software complexity metrics.andP;  InProceedings of the Fourth International Conference on Software Engineering.andO;New York: IEEE, 1979.andM;[7] Curtis, B., Sheppard, S.B., Milliman, P., Borst, M.A., and Love, T.andO;Predicting performance on software maintenance tasks with the Halstead andMcCabe metrics.andP;  IEEE Trans.andP;  Softw.andP;  Eng., 5 (1979), 95-104.andM;[8] DeMarco, T.andP;  Controlling Software Projects: Management, Measurement andamp;Estimation.andP;  Yourdon Press, New York, 1982, 79-128.andM;[9] Drummond, S.andP;  Measuring applications development performance.andO;Datamation.andP;  (Feb.andP;  1985), 103-108.andM;[10] Elshoff, J.L.andP;  The PEEK Measurement Program.andP;  Res.andP;  Pub.andP;  GMR-4208,General Motors Research Labs, Warren, Mich.andP;  (Nov.andP;  15, 1982), 18.andM;[11] Elshoff, J.L.andP;  Characteristic program complexity measures.andP;  Res.andP;  Pub.andO;GMR-4446, General Motors Research Labs, Warren, Mich.andP;  (Dec.andP;  5, 1983), 2.andM;[12] Fitzsimmons, A., and Love T.andP;  A review and evaluation of softwarescience.andP;  ACM Comp.andP;  Surv.andP;  10, 1 (Mar.andP;  1978), 6.andM;[13] Halstead, M.H.andP;  Elements of software science.andP;  Elsevier, New York, 1977,3.andM;[14] Henry, S., Kafura, D., and Harris, K.andP;  On the relationships among thethree software metrics.andP;  In Proceedings of the 1981 ACM Workshop/Symposium onMeasurement and Evaluation of Software Quality (March 1981)andM;[15] Kernigan, B.W., and Plauger, P.J.andP;  The Elements of Programming Style.andO;Bell Telephone Laboratories, N.J., 1974.andM;[16] McCabe, T.J.andP;  A complexity measure.andP;  IEEE Trans.andP;  Softw.andP;  Eng.andP;  SE-2, 4(Dec.andP;  1976), 308.andM;[17] Myers, G.J.andP;  An extension to the cyclomatic measure of programcomplexity.andP;  ACM SIGPLAN Not.andP;  12, 10 (Oct.andP;  1977), 61-64.andM;[18] Petschenik, N.H.andP;  Practical priorities in system testing.andP;  IEEE Trans.andO;Softw.andP;  Eng.andP;  (Sept.andP;  1985), 18-23.andM;[19] Sheppard, S.B., and Kruesi, E.andP;  The effects of the symbology and spatialarrangement of software specifications in a coding task.andP;  Tech.andP;  Rep.andO;TR-81-388200-3.andP;  General Electric Company, Arlington, VA, 1981.andM;[20] &quot;Structured Testing: A Software Testing Methodology Using the CyclomaticComplexity Metric,&quot; National Bureau of Standards Special Publication No.andO;500-99, December 1982.andM;[21] Walsh, T.J.andP;  Software reliability study using a complexity measure.andP;  InProceedings of the National Computer Conference.andP;  New York: AFIPS, 1979.andM;THOMAS J. McCABE, founder and Presidsent of McCabe andamp; Associates, Inc., is aconsultant, researcher and authority in the areas of quality softwaredevelopment, testing, and validation techniques.andP;  However, he is best knownfor his research and publications on software complexity and by thecomplexity measure, that bears his name.andP;  As an extension of his work oncomplexity, he also developed a testing methodology called StructuredRequirements and Testing (SRT) which quantifies the requirements complexityand derives a complete set of acceptance tests.andP;  Author's Present Address:McCabe andamp; Associates, Twin Knolls Professional Center, 5501 Twin Knolls Road,Suite 111, Columbia, MD 21045.andM;CHARLES W. BUTLER is an associate professor in the Department of ComputerInformation Systems at Colorado State University.andP;  He earned his Ph.D.andP;  atTexas Aandamp;M University.andP;  His research and teaching interests center on softwaredevelopment methodology, software metrics, and expert systems.andP;  In additionto his academic teaching and research, he has worked with McCabe andamp; Associatesdeveloping testing methodologies and professional seminars.andP;  Author's PresentAddress: CIS, CLK, C115; Colorado State University, Ft.andP;  Collins, CO 80523.andM;Permission to copy without fee all or part of this material is grantedprovided that the copies are not made or distributed for direct commercialadvantage, the ACM copyright notice and the title of the publication and itsdate appear, and notice is given that copying is by permission of theAssociation for Computing Machinery.andP;  To copy otherwise, or to republish,requires a fee and/or specific permission.andM;(1) The following may help the reader track the subtree quantification withthe design structure.andP;  There are two possible subtrees through module 2 (M2),(M1-M2-M5-M10-M11) and (M1-M2-M5-M10-M11-M6).andP;  Since the loop at M1 iteratesbetween 1 and 3 times, we have 2 X [[Sigma.sup.3.sub.i=1]] (# of subtreesfrom M3 and M4).andP;  The expression [2.sup.2] represents the number of subtreesfrom M12 (M12, M12-M13, M12-M13-M14, M12-M14); the expression (1 + [2.sup.2])represents the number of subtrees from M8.andP;  The desired result for the # ofsubtrees from M3 and M4 is the number of subtrees from M3 (1 + 1(1 +[2.sup.2])) multiplied by the number of subtrees from M4 [(1 + 1([2.sup.2]))X [2.sup.2].andO;</TEXT></DOC>