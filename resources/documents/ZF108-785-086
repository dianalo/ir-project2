<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-785-086  </DOCNO><DOCID>08 785 086.andM;</DOCID><JOURNAL>Computer Language  Sept 1990 v7 n9 p123(3)* Full Text COPYRIGHT Miller Freeman Publications 1990.andM;</JOURNAL><TITLE>Our object-oriented future. (OOP Alley) (column)</TITLE><AUTHOR>Bergman, Noel J.andM;</AUTHOR><SUMMARY>An analysis of the outlook for object-oriented programming through1995 is presented, based in large part on observations first madein 1987.andP;  Future development will occur in two primary areas, eachof which has several parts: basic development tools, including alanguage for object programming, robust class libraries offoundation classes, environment interfaces, relatively commondomain-specific problem solving and application frameworks; and anintegrated development environment serving as an extensibleplatform spanning the entire software development cycle.andP;  Includedin the environment would be a graphical windowed user interfaceand an extensible software architecture supporting all aspects ofsoftware development.andP;  Tools integrated in the environment wouldsupport specification, design, source-code control, librarymanagement, configuration management, application generation,debugging, documentation and project tracking.andP;  Other aspects ofthe environment and classes within it are described.andM;</SUMMARY><DESCRIPT>Topic:     Object-Oriented ProgrammingProgram Development ToolsApplications ProgrammingOutlookProgram Development TechniquesForecastingIntegrated SystemsObject-Oriented LanguagesProject Management.andM;</DESCRIPT><TEXT>Our object-oriented future I've been fortunate enough to correctlyprognosticate the availability of some types of class libraries for C++ thisyear.andP;  I've decided to go further out on a limb and make a five-yearprediction.andP;  Although some of the information that will appear here relatesto the plans of other companies, most of it is from a proposal I drafted andpresented to Microsoft during the summer of 1987, giving us an effectiverange of eight years.andM;First, I have to advance a disclaimer.andP;  Being a software developmentconsultant and columnist at times seems conflictive.andP;  It's in no one's bestinterest to jeopardize relationships with software developers, many of whomare both clients and friends.andP;  I won't state anything not already made publicby its owner or for which permission to publish was not explicitly granted.andO;For example, in the case of Microsoft, the information planned for thisseries of columns is taken from a paper Dr. Gregory Whitten presented atSCOOP '89 and a backgrounder published by Microsoft.andP;  Future columns mayupdate that information when and if I get permission from Microsoft.andM;The vision of our development future I presented in 1987 consisted of twomajor areas, each with several parts.andP;  The first area is basic developmenttools: a language for object programming (for example, C++ and ObjectPascal), robust class libraries of foundation classes, environmentinterfaces, relatively common domain-specific problem solving (compounddocument processing), and application frameworks.andP;  These are the tools of thetrade for which we have already seen examples, although the PC market iswoefully lacking inapplication frameworks.andM;The second area is an integrated development environment.andP;  The term&quot;integrated development environment&quot; did not refer to the anemic offeringsfrom Borland, Microsoft's Quick languages, or even Microsoft's programmableProgrammer's WorkBench.andP;  Rather, the term was used to discuss an extensibleplatform that would span the entire cycle of software development across allareas of a development shop.andM;The environment would have a graphical windowed user interface and anextensible software architecture supporting all aspects of the softwaredevelopment process.andP;  Some of the tools integrated into the environment wouldassist in such critical areas as specification, design, source-code control,library management, configuration management, application generation,debugging, documentation, and project tracking.andM;The environment would support multiple projects and work groups, spanheterogeneous local area networks, and connect programmers at different worksites.andP;  As a normative condition, a database abstraction at the core of theenvironment should be able to support projects ranging from very small onesto corporate-wide libraries.andM;One goal of this environment is to permit enhanced programmer productivity.andO;Another is to provide closer coordination and information exchange betweenprogrammers, managers, support personnel, and others.andM;The scope of the environment is enormous and would represent a majorundertaking for any software developer.andP;  The suggestion, however, was thatonly the framework and a starting set of tools be offered initially, withadditional tools added at later dates.andP;  Also, the enabling technology forthis environment has so many other uses that its development costs could beunder-written by many separate groups within a diverse development firm.andM;An architecture that permits this type of extensibility and seamlessintegration merges many of the concepts of hypertext with those taken fromother development environments (for example, Smalltalk's concepts of modelsand views) to provide ways to look at different types of objects andinterrelationships.andP;  One important concept is extending the hypertextparadigm to encode semantic information in the database, analogous to the wayattribute grammars encode semantic content in a language specification.andM;The essential enabling technology in this design is a good persistent objectstore.andP;  Each object in the database is an instance of some class, whose codeis available to process requests made on it.andP;  Input events on visual objects(icons that represent parts of a program) are translated into messages to theunderlying object models.andM;Any type of information could be stored as an object within the environment,provided it has tools that know how to interpret it.andP;  Source code, projectinformation, customer information, binary objects such as icons or bitmaps,and esoterica such as internal data from an incremental compiler are examplesof objects that might be found in the environment, along with informationrelating them to one another.andM;Ideally, we want these to be objects in the real sense of object programming:they are members of some class that defines their methods.andP;  Realistically, weneed to be consistent with tools in today's programming environments.andP;  Insome cases, the object stored in the database might be a surrogate for anobject stored elsewhere within our computer (such as in an external file),and the methods would invoke external tools on the external &quot;real&quot; data.andM;Some classes available within the environment would provide source-codecontrol, make facilities, resource management and scheduling, and binaryobject (fonts and bitmaps, for example) editing.andP;  The environment wouldprovide different views of the data within it.andP;  Here are some of the waysdifferent people could use the environment:andM;* A programmer could locate and use objects developed by others and stored inthe system, receiving notification of new versions and changes in theirinterface.andM;* A manager could easily monitor the progress of large projects and trackwhat remains to be done, what progress is made, what effect changes have madeon the schedule, and so on.andM;* A customer-support engineer could submit reports of bugs to be verified andfixed, and the effect of these reports on the software development processcould be tracked (although not necessarily by the engineer).andM;For purposes of compatibility with existing tools, the environment could havefacilities to let tools be used without change, although without the fullbenefits of being integrated into the environment.andP;  Source code could betemporarily deposited in a file to be edited by an external editor that isnot integrated into the environment, for example.andM;If you're a C++ programmer, put down this magazine and run (don't walk) tothe nearest computer-book dealer.andP;  When you get to the bookstore, buy a copyof The Annotated C++ Reference Manual by Margaret Ellis and Bjarne Stroustrup(Addison-Wesley, 1990).andP;  It's a must have for every C++ programmer.andM;The Annotated C++ Reference Manual (or ARM, as it has become known aroundthese parts) is a reproduction of the C++ language standard, plus annotationsand commentary on all aspects of the language.andP;  Most C++ ambiguities can becleared up by reading the ARM's annotations.andP;  When my copy arrived, arepresentative of one of the C++ compiler vendors was on site with one of myclients, cleaning up problems in the C++ translator.andP;  The ARM was invaluablein determining whether a feature was improperly implemented or merelymisunderstood.andP;  The ARM covers C++ 2.1, along with the two major experimentalareas--templates and exception handling).andM;The ARM should be considered essential to every C++ programmer's library.andP;  Nomatter what books you've used to learn the language, this book will define itfor you and explain its mysteries.andM;Noel J. Bergman is president of Development Technologies Inc., a softwaredevelopment consulting firm with special interests in OS/2, Windows, andobject-oriented programming.andP;  He can be reached on CompuServe (CIS ID:76704,34), where he is a volunteer sysop on Microsoft's CompuServe fora.andO;</TEXT></DOC>