<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-439-626  </DOCNO><DOCID>08 439 626.andM;</DOCID><JOURNAL>Communications of the ACM  May 1990 v33 n5 p584(3)* Full Text COPYRIGHT Association for Computing Machinery 1990.andM;</JOURNAL><TITLE>Technical correspondence: uncertainty in computer application.andO;(column)</TITLE><AUTHOR>Lehman, M.M.andM;</AUTHOR><DESCRIPT/><NOTE>Only Text is presented here; see printed issues for graphics.andO;</NOTE><TEXT>Uncertainty in Computer Application Individually and collectively, humanityis becoming ever more dependent on computers and, therefore, on software.andP;  Issuch dependence justified? The computer community has long been aware of theproblems implied by this question as illustrated most recently by theeditorial and three papers on social responsibility in the August 1989 issueof the Communications.andP;  The concern expressed there is closely related to oneaspect of the issues underlying the exchanges between Fetzer [5] and his manyrespondents' and specifically identified in his response to Dobson andRandell in the above-mentioned issue.andP;  In his final Forum contribution,Fetzer included the broad statement that &quot;Specific outcomes [of computerprogram execution] depend upon a variety of factors, only one of which is theprogram itself&quot;  6].andP;  1 believe that the point being made is that,independently of the value of verification techniques, the time intervalbetween the verification of a program and use of the results of its executionintroduces an element of doubt into those results.andP;  It follows that oursocial conscience must accept and implement reservations about the use ofcomputers in certain applications and about the use of softwareimplementation technologies where, in either case, the uncertainty or riskassociated with such usage may be too high.andP;  It also indicates that theimplementation of any application requires extreme care and conscientiousnessin design to take account of the potential for error and to minimize itspossible consequences.andM;This contribution to the Technical Correspondence columns identifies aspecific source of the various problems implied by the discussions in theabove-cited references.andP;  It sharpens the question posed above and  offers ananswer.andP;  The more precise question is:andM;Is there a limit to the confidence one may have in the correctness of theresults of execution of programs that solve problems in the real world(E-type programs) [13, 17]?andM;The answer follows directly from an Uncertainty Principle of ComputerApplication recently outlined [15].andP;  The present communication presents amore complete derivation of this principle on the basis of three categoriesof uncertainty about the detailed properties of E-type programs relative tothose of their environment.andM;Other possible sources of uncertainty such as the reliability of errordetection, development and maintenance technologies, and the relativereliability of decisions by humans and by machine are not considered here.andO;It is, however, noteworthy that the increasing use of method-based, oftenformal, program specification and development [10, 27] and of computer-basedtools [14, 24] represents major progress in relation to these.andP;  The presentcommunication will also make clear that the writer has no doubts on eitheraccount and, equally, that the software development technology now emergingcan control the problems and limit the consequences.andM;An E-type program is a model of a model ...andP;  of a model of a computerapplication in the real world [13].andP;  Turski considers each pair of neighborsin this chain of models as a theory and a model (in the mathematical sense)of that theory respectively or equally as a specification and animplementation of that specification [26].andP;  At one extreme, this view isreflected in his interpretation of the  &quot;two-legged&quot; software-developmentprocess model [22], which is interpreted as one in which a description of thereal-world application and the final implementation are both models of aspecification: the theory that forms the bridge between concept andrealization.andP;  At the other extreme, the base and target representations atthe core of each step of the canonical LST software (and systems) developmentprocess paradigm [18] also form a theory and model pair.andM;It follows that every E-type program is Godel incomplete [15], an instance ofBondi's more general observation [1].andP;  The properties of such programs cannotbe completely known from within the system.andP;  Now those involved in systemdevelopment and usage are an integral part of the system.andP;  Their mentalactivities direct and drive the process of system development and evolution.andO;The degree of satisfaction that the operational system yields is ultimatelydetermined by the judgment, action, and inaction of designers and users.andO;Thus neither developers nor users can fully know system properties.andP;  Godelincompleteness is transformed into Godel-type uncertainty [15].andP;  The processmust seek to limit this uncertainty to representational incompleteness.andM;A second form of uncertainty arises from system development and operation.andO;Understanding of the application changes.andP;  User ambitions are stimulated.andO;Alternative methods of solution are recognized.andP;  Apparent opportunities forimprovement abound.andP;  Moreover, the system must evolve.andP;  Anyone usingcomputers seriously will have experienced the continuing maintenance that theassociated software appears to require.andP;  This is not entirely due toshortsightedness on the part of either users or developers.andP;  All artificialsystems must evolve [23] if they are to remain satisfactory; but the rate ofsoftware evolution will be substantially greater than that of physicalsystems.andP;  One source of the continuing pressure for change in E-type systemsis that each system includes an implicit model of itself.andP;  Moreover, theapplication, its domain, and human perception of both change duringdevelopment and usage.andP;  It is the associated feedback that drives evolution[17].andP;  Changes to the software are the primary means whereby adaptation isachieved.andM;The intrinsic delay between recognition of a need or opportunity for changeand its implementation means that a mismatch between human desires and systemproperties cannot be permanently eradicated.andP;  Satisfaction with the systemdeclines unless the software (which largely determines system properties) isrepeatedly updated  first law of program evolution [11, 17]).andP;  Moreover, asthe system evolves, change implementation requires combinatorially increasingrelative effort (second law of program evolution [11, 17]).andP;  Thus, the moreprecise knowledge is of the application, its solution, and their respectivedomains the less is it possible to maintain satisfactory system behavior anddeliver satisfactory results.andP;  The source of dissatisfaction is a function ofperception and understanding and cannot be completely predicted.andP;  Hence thesystem displays Heisenberg-type uncertainty [12].andP;  Here, too, the process andits management is key to minimization of the consequences of this inherentuncertainty.andM;There is also a third type of uncertainty [15].andP;  The domain of an E-typeapplication is, in general, unbounded, effectively continuous, and dynamic,always changing.andP;  The solution system is finite, discrete, and in the absenceof human intervention, static.andP;  The process of deriving one from the otherinvolves abstraction and reification on the basis of assumptions.andP;  These willrelate to the application itself, to its domain, to perceived needs andopportunities, to human responses to real-world events, to computationalalgorithms, to theories about all these, to solution system properties, andso on.andP;  Some assumptions will be explicitly stated; others will be implicitin the design and implementation detail.andP;  All will be built into the finalsystem.andM;In a dynamic world the facts on which any assumption set is based will bemodified by system-exogenous events.andP;  However carefully the validity ofassumptions is controlled when they are adopted, some will be less than fullyvalid when the results of execution are used.andP;  But this is when, to be fullysatisfactory, a program needs to be correct.andP;  Correctness of a programspecification and its derivation is a means to that end, necessary but notsufficient.andP;  The assumption set must be maintained by appropriate changes toprogram or documentation texts in a time frame determined by the applicationand the nature of the required change in order to remain correct.andP;  For anE-type program in its entirety this is, in general, not possible even if allassumptions were explicit and their location precisely known.andP;  Such programsare finite models of an unbounded, effectively infinite universe ofdiscourse, and one can never be certain that one has identified all necessaryassumptions.andP;  Pragmatic uncertainty in computer system behavior isinevitable.andP;  It is intrinsic to mechanized computation and is intimatelylinked to Heisenberg-type uncertainty.andM;This analysis leads to an Uncertainty Principle for Computer Application:andM;In the real world, the outcome of software system operation is inherentlyuncertain with the precise area of uncertainty also not knowable [15].andM;Godel-type uncertainty is primarily a matter of formalism, of theoreticalinterest, but unlikely to have significant practical implications.andP;  Theconsequences of both Heisenberg- and Pragmatic-type is the never-endingmaintenance burden that accompanies all serious computer usage.andP;  Inparticular, the former can be, however, largely controlled by adequatemanagement whenever the system is adapted or extended.andP;  Pragmaticuncertainty, being a consequence of incomplete and imperfect knowledge aboutthe real world, is more challenging.andP;  It leads to concerns that must increaseas computer-based systems become larger, more complex, and more intimatelyinterwoven with the life and activity of individuals and of society at large.andO;Research and development in programming methodology and software technologyis providing methods and tools to ensure that programs can be satisfactorilydeveloped and maintained.andP;  This work must continue.andP;  And processes thatexploit the results must be introduced into general industrial practice.andM;It has long been recognized that, in general, the quality of industrialsoftware development and of its product falls far short of the levels ofreliability demanded by the expanding range of computer applications.andO;Concern was first publicly expressed at the Garmisch International Workshopon Software Engineering [19].andP;  Dijkstra [3, 4], Hoare [8, 9], IFIPprogramming methodology working group WG 2.3 [7], and many others have beenstressing the need for program correctness ever since.andP;  The debates on theStrategic Defense Initiative (SDI), led by Parnas [21] and others, and on theuse and limitations of proof techniques [2][.sup.2] and program verification[1] reflect strong concern within the wider computing community.andP;  Neuinann[20], Thomas [25], and many others are actively engaged in exposing thelimitations of computer control in life-critical applications.andP;  Each of theseauthors discusses specific aspects of the problem of achieving reliablesoftware development.andP;  Moreover.andP;  concern is not confined to academiccircles.andP;  Awareness of the problem is also widespread in industry, though isoften attributed to human failure.andM;Relative to such concerns.andP;  the Uncertainty Principle and, in particular,some of its more abstract aspects may appear to have little practicalsignificance.andP;  This is not so.andP;  The phenomena and issues related to itreflect basic and intrinsic properties of the process of computer programdevelopment, usage, and evolution with the Principle and the observationsfrom which it is derived, thus providing a unifying concept for a theory ofsoftware development.andP;  Such a theory is essential for rapid progress towardsa reliable, responsive, and cost-effective technology for the development ofcomputer-based systems that can be commissioned with every confidence thatthey will provide continuing satisfactory service.andP;  The immediate practicalimplications of the Principle are discussed elsewhere [16].andM;Computer usage is penetrating ever deeper into the very fabric of society.andO;The dependence of humanity on the correctness of computer systems in generaland on software in particular becomes ever greater.andP;  Software correctness isa specific relationship between a program or system and its specification.andO;What is required is an analogous relationship between the state of theapplication domain at the time when the results of a computation are appliedand the software that prescribes the computation.andP;  The technology, extension,and wide application of formal methods to maximize the opportunity forinitial correctness relative to the application domain is a most significantfirst step.andP;  To ensure continuing safety in system application it must beaccompanied by the wider use of advanced software engineering technology.andO;That discipline, as reflected in the software development and evolutionprocess, in the methods used, and in process mechanization, is the meanswhereby uncertainty and the consequences of uncertainty can be minimized anduser satisfaction maintained.andP;  Above all, however, emphasis must be placed onresponsibility, conscientiousness, and care in the selection, definition,development, and control of computer applications.andP;  This is a matter thatconcerns not only computer scientists and software engineers.andP;  It is a matterfor industry, for government, for all levels of the educational system,indeed, for all of humanity.andM;M.andP;  M. Lehman Department of Computing Imperial College of Science,Technology, and Medicine 180 Queen's Gate London SW7 2BZandM;REFERENCESandM;1.andP;  Bondi, H. The lure of completeness.andP;  In The Encyclopedia of Ignorance, R.andO;Duncan and M. Weston-Smith, Eds.andP;  Pergamon Press, London, 1977, pp.andP;  5-8.andM;2.andP;  DeMillo, R.A., Lipton, R.J., and Perlis, A.J.andP;  Social processes andproofs of theorems and programs.andP;  Commun.andP;  ACM 22, 5 (May 1979), 271-280.andM;3.andP;  Dijkstra, E.W.andP;  A constructive approach to the problem of programcorrectness.andP;  BIT 8, 3 (1969), 174-186.andM;4.andP;  Dijkstra, E.W.andP;  The humble programmer.andP;  Commun.andP;  ACM 15, 10 (Oct.andP;  1972),859-866.andM;5.andP;  Fetzer, J.H, Program verification: The very idea.andP;  Commun.andP;  ACM 31, 9(Sept.andP;  1988), 1048-1063.andM;6.andP;  Fetzer, J.H.andP;  Another point of view.andP;  Commun.andP;  ACM 32, 8 (Aug.andP;  1989),920-921.andM;7.andP;  Gries, D. Programming Methodology-A Collection of Articles by Members ofIFIP WG2.3.andP;  Springer Verlag, New York, 1978.andM;8.andP;  Hoare, C.A.R.andP;  An axiomatic basis for computer programming.andP;  Commun.andP;  ACM12, 10  Oct. 1969), 576-583.andM;9.andP;  Hoare, C.A.R.andP;  Proof of a program FIND.andP;  Commun.andP;  ACM 14, 1 (Jjan.andO;1971), 39-45.andM;10.andP;  Jones, C.B.andP;  Software Development-A Rigorous Approach.andP;  Prentice-HallInc., New York, 1980.andM;11.andP;  Lehman, M.M.andP;  Programs, Cities, Students-Limits to Growth.andP;  Vol.andP;  IX,Inaugural Lecture Series 1970-1974.andP;  Also in [6], pp.andP;  42-69 and in [14],pp.133-163.andM;12.andP;  Lehman, M.M.andP;  Human thought and action as an ingredient of systembehaviour, In The Encyclopedia of Ignorance, R. Duncan and M. Weston-Smith,Eds.andP;  Pergamon Press, London, 1977, pp.andP;  347-354.andM;13.andP;  Lehman, M.M.andP;  Programs, life cycles and laws of software evolution.andO;Proc.andP;  IEEE (Sept.andP;  1980), 1060-1076.andM;14.andP;  Lehman, M.M.andP;  Model-based approach to IPSE architecture and design-TheISTISTAR project as an instantiation.andP;  Inv.andP;  Contr., Q. Bul., IEEE 10, 1(Mar.andP;  1987), 2-13.andM;15.andP;  Lehman, M.M.andP;  Uncertainty in computer application and its controlthrough the engineering of software.andP;  J. Softw.andP;  Maint.andP;  1, 1 (Sept.andP;  1989),3-27.andM;16.andP;  Lehman, M.M.andP;  Uncertainty in computer application-Software engineeringas a control.andP;  In Proceedings of the IEEE International Conference onComputer Systems and Software Engineering (CompEuro 90) (Tel Aviv, Israel,May 7-9).andP;  IEEE/CS, New York, 1990.andP;  To be published.andP;  Also see, ICSTandamp;M DoCRes.andP;  Rep.andP;  89/2.andM;17.andP;  Lehman, M.M., and Belady, L.A.andP;  Program Evolution-Processes of SoftwareChange.andP;  Academic Press, London, 1985.andM;18.andP;  Lehman, M.M.. Stenning, V., and Turski, W.M.andP;  Another look at softwaredesign methodology.andP;  ICST DoC Res.andP;  Rep.andP;  83/13, 1983.andP;  Also, Softw.andP;  Eng.andO;Notes 9, 2 (Apr.andP;  1984), 38-53,andM;19.andP;  Naur, P., and Randell, B. Software Engineering-Report on a Conference.andO;Sponsored by the NATO Science Committee, Garmisch, 1968, Scientific AffairsDivision, NATO, Brussels 39, 1969.andM;20.andP;  Neumann, P.(,., Ed.andP;  Risks to the public in computers and relatedsystems.andP;  Softw.andP;  Eng.andP;  Notes 10, 2 (Apr.andP;  1985)-present.andM;21.andP;  Parnas, D. Software aspects of strategic defense systems.andP;  Amer.andP;  Sci.andO;75, 3 (Sept.-Oct.andP;  1985), 432-440.andP;  Revised version in Commun.andP;  ACM 28, 12(Dec.andP;  1985), 1326-1335.andM;22.andP;  Potts, C., Ed.andP;  Proceeding of the Software Process Workshop (Egham,Surrey, U,K., Feb. 6-8).andP;  ACM, BCS, ERO, IEEE/CS, Washington, D.C., 1984.andM;23.andP;  Simon, H.A.andP;  The Sciences of the Artificial.andP;  2d ed.andP;  M.I.T.andP;  Press,Cambridge, Mass., 1981.andM;24.andP;  Stenning, V. Software engineering: Present and future in The corporatedatabase.andP;  In State of the Art Reports, D. Iggulden Ed.andP;  Pergamon InfotechLtd.. Maidenhead, England, 1985, pp.andP;  83-93.andM;25.andP;  Thomas, M. Development methods for trusted computer systems.andP;  In FormalAspects of Computing, Vol.andP;  1, no.andP;  1, 1989, pp.andP;  5-18.andM;26.andP;  Turski, W.M.andP;  Specification as a theory with models in the computerworld and in the real world.andP;  Infotech State of the Art Report, 9, 6 (1981),pp.andP;  363-377.andM;27.andP;  Turski, W.M.. and Maibaum, T. The Specification of Computer Programs.andO;Addison Wesley, London, 1987.andO;</TEXT></DOC>