<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO> ZF32-188-104 </DOCNO><DOCID>10 625 144</DOCID><JOURNAL>EXE  April 1991 v5 n10 p12(4)* Full Text COPYRIGHT Process Communications Ltd. (England) 1991.andM;</JOURNAL><TITLE>32-bit programming under Windows 3. (tutorial)</TITLE><AUTHOR>Dodd, Tony.andM;</AUTHOR><SUMMARY>Microsoft Windows 3.0's protection mechanism limits the 32-bitapplications programming functions it provides to those thatprogrammers cannot write themselves; no functions are providedthat users would expect in a normal development environment.andP;  Thefunctions can be used to make 32-bit applications accessible tousers, however; porting of one such application, Prolog-2, isdescribed.andP;  Windows 3.0 has three modes: real mode, standard modeand 386 enhanced mode; each is described, but only the problem ofwriting protected mode programs is addressed here.andP;  Windows 3.0overcomes the DOS 64Kbyte memory limit by arranging successivesegments that tile an area larger than 64Kbytes in sequence in thesegment table.andP;  Also described are Windows system services, thecharacteristics of 32-bit programs and loading 32-bitapplications.andM;</SUMMARY><DESCRIPT>Product:   Microsoft Windows 3.0 (Graphical user interface) (Programming).andO;Topic:     Program Development TechniquesTutorialApplications Programming32-BitGraphical User InterfaceProgramming Instruction.andO;Feature:   illustrationtableprogram.andO;Caption:   Limitations of DOS calls in protected mode. (table)Using DPMI to access a real mode function. (program)Allocating a 32-bit segment. (program)andM;</DESCRIPT><TEXT>32-bit programming under Windows 3 When I discovered the notes tucked away atthe back of the SDK Reference for Windows 3 advertising support for 32-bitapplications my first thought was 'why hasn't this been accorded moreimportance?' and my second was 'why is it so small?'.andP;  The answer to bothquestions is the same: Windows 3.0 only supplies functions that you could notwrite yourself because of the processor's protection mechanism.andP;  It doesn'tprovide functions that you would expect to find in a normal developmentenvironment.andM;However, systems programmers can take these functions and use them to make32-bit applications accessible to users.andP;  This article describes how I portedone such application, Prolog-2, which is an implementation of the Prologlanguage for PCs.andP;  I hope to encourage other developers to change theirlanguages and toolkits so as to provide easy access to the full power of the80386 for those who cannot cope if only given the bare essentials supplied byMicrosoft.andM;Because this is an article for system developers, and because a small bookwould be needed to explain all the conventions, standards, architectures andinterfaces involved, I shall assume that the reader already understands thedifferent members of the 80386 family.andM;Protected mode programsandM;The 80386 processor contains a museum of old PC architectures too complex forconsideration here.andP;  To summarise very briefly:andM;* if the processor operates in real mode then it behaves very like an 8086;andM;* if the processor operates with the virtual 8086 bit set then it behavesrather like an 8086 but uses paging so that the 8086 memory need not be thefirst 640 KB of physical memory;andM;* if the code being executed is in a small code segment (a USE 16 segment, asthe assembler calls it) then it behaves like 80286 protected mode code.andM;We have all got used to PCs running in real mode when the operating system isMS-DOS, and protected mode when it is OS/2; but Windows 3 has changed allthat.andP;  There are three modes:andM;* in real mode the processor is in real mode;andM;* in standard mode the processor is in protected mode but switches to realmode to run DOS applications;andM;* in 386 enhanced mode the processor is in protected mode and DOSapplications are run as virtual 8086 tasks.andM;We shall only be concerned with Windows applications in this article, so wemust address the problem of writing protected mode programs.andP;  In fact thisisn't usually a problem.andP;  Compiled C programs should not make assumptionsabout the values in segment registers, so the program should not care whethersegment registers contain physical addresses (as in real mode) or offsets ina table (as in protected mode).andP;  A few problems may be envisaged: forexample, what about huge arrays?andP;  How can the compiler produce portable codeto pass a 64 KB boundary?andP;  The solution in Windows 3 is particularlyingenious: successive segments that tile an area greater than 64 KB arearranged in sequence in the segment table, so that the distance between themis fixed.andP;  In real mode this distance is also fixed - it is 1000H.andP;  So ineach case a constant needs to be added to a segment register to pass a 64 KBboundary; and this constant is defined appropriately by the Windows kernel.andM;System servicesandM;Suppose we agree, then, that it is not impossible that a Windows applicationwill run in protected mode as well as in real mode.andP;  Directly or indirectlythe code will almost certainly issue DOS calls through interrup 21H; shouldwe assume that these will work too?andM;The answer to this question must be a resounding no.andP;  First, DOS operates inreal mode, and makes assumptions about segments that prevent it from runningin protected mode.andP;  Second, any parameters passed to DOS that use segmentregisters will be interpreted quite wrongly; DOS will convert them to linearaddresses by multiplying them by 16, which isn't the idea at all.andP;  Third,protected mode interrupts do not use the interrupt locations in low memory;they use a separate interrupt table.andM;Issuing interrupts in protected mode and hoping that they will work as inreal mode is therefore not advisable.andP;  However, in order to make Windowsapplications operate correctly in protected mode, Microsoft provides almostall DOS services via the protected mode interrupt 21H (which, as we shall seelater, is a 286 trap gate).andP;  The few restrictions are summarised in Figure 1.andM;It should be noted that providing these services involves more than thetranslation of a few addresses.andP;  For example, to read from a file into abuffer at a protected mode address is straightforward only if the protectedmode address has a real mode equivalent; othewise some clever remapping ofpages is called for.andP;  For this reason, more obscure DOS calls cannot copewith transfer of more than 4 KB of data at a time.andM;A few DPMI calls are of use to the Windows programmer, however.andP;  (For adetailed description of DPMI, please see Dan O'Brien's article elsewhere inthis issue - Ed.)andP;  For example, access to an interrupt other than 21H mayrequire direct use of DPMI.andP;  My example shows how the DOS case conversionfunction may be accessed from protected mode; of course, Windows 3 alreadyhas a perfectly good case conversion function, but the use of the DOS versionserves as a nice simple example.andM;Recall that DOS call 38H returns, among other things, the address of aprocedure that can be called to convert a character to upper case.andP;  As thisaddress is only suitable for use in real mode, we must use a special DPMIcall to invoke the routine from protected mode.andP;  A parameter block containingthe desired register settings in real mode is built and passed to DPMI; thecode for the example is given in Figure 2.andM;Of course, code like this must be used with caution; it will not work in realmode.andP;  Programs that need to do such low-level operations must use GetWinFlags to find out which mode the processor is in.andM;32-bit programsandM;32-bit code offers the programmer tremendous advantages.andP;  The full addressspace of the machine can be accessed from a single offset register, withoutthe use of segments.andP;  Segments are still useful as a relocation andprotection mechanism, but they are no longer needed as a way of accessinglarge blocks of memory.andP;  My own PC software product, Prolog-2, has alwaysbeen hampered by the segmented architecture; languages like Prolog like tohave a large pool of memory available in which objects of any size can beallocated and deallocated at will.andP;  Huge arrays are no solution, and most PCProlog implementations have had to restrict run-time stacks to 64 KB.andP;  The32-bit architecture of the 80386 solves all that.andM;Unfortunately it is not that simple.andP;  Presented with a chip that at lastlifted the major limitation of the 8086 family of processors and madeavailable 32-bit facilities comparable to those that had been in every othermajor processor for years, what did Microsoft and IBM do?andP;  They designed anew OS that prevented code from running in 32-bit mode.andP;  They forced users tooperate their nice new 80386 processors as faster versions of the ghastly old80286, and every few months they made an announcement about a 32-bit versionof OS/2 being available at some unspecified future time.andM;A short term solution was the DOS extender.andP;  A DOS extender is a small 32-bitoperating systmes that can be bund with a 32-bit application and run fromDOS.andP;  The DOS extender switches the processor into protected mode, and offersservices comparable to DOS services to the application; it may also allow itto communicated with real mode code.andP;  I use the Phar Lap DOS extender for the80386 version of Prolog-s; it is an excellent system, well tested across arange of odd PCs and very nicely document.andP;  Virtual memory support is alsoavailable .andP;  But are problems with DOS extenders:andM;* a DOS extender application cannot run as a DOS application under Window 3,thogh this will be fixed when DOS extender support DPMI.andM;* a DOS extender application cannot run as a Windows 3 application, and Iknow of no plans to fix this.andM;* DOS extender vendors charge run-time license fees.andP;  Tough this would be toounreasonable if one were selling a packaged application, there is a problemfor those selling language compilers that require the run-time support of aDOS extender; people who use the language to ship applications must payrun-time fees to the DOS extender vendor.andM;The services that a DOS extender offers may be divided into groups:andM;* it switches the processor between real and protected mode.andM;* it loads applications.andM;* it offers operationg system services to applications.andM;We have seen that Windows 3 offers all these services as well; but only for16-bit applications.andP;  On the other hand, whereas moving from real toprotected mode requires a processor mode switch, a USE 32 segment is a merelong jump away from a USE 16 segment.andM;There is one technical difficulty: WIndows normally allocates USE 16 segmentsfor code.andP;  To load a 32-bit application it is necessary to get a large datasegment, read the code into it as thopugh it were data, and then change thesegment to a USE 32 code segment.andP;  Because Windows 3 applications cannot useprivileged instructions, it is impossible possible to goe and hack thesesegments out of the segment table: but Windows 3 provides a set of functions,frouped in the 32-bit DLL (described in Appendix E of the SDK Referencemanual), that perform just the tasks required.andM;In summary, then, to run 32-bit application under Windows 3 we need a loaderprogram that waill load the code as described and transger control to it, andwe need to supply the code with system services.andM;On course, we also need a 32-bit application.andP;  Several compliers andassembles are available; I use the Phar Lap set.andP;  Whichever you use, makesure that you have a description of the linker output format, as you willhave to load the code yourself, make sure that the application is written touse a single segment for all code and data.andM;Loading a 32-bit applicationandM;Loading a .EXE file is not one of life's great pleasures.andP;  But apart from theodd poage size, most of the annoyance derives from the need to fix upsegments.andP;  In a flat 32-bit application that problem does not arise: thereshould be no segments hard-coded into the program.andP;  For various odd purposes,like accessing the PSP, my Phar Lap program used fixed interger segmentnumbers; such things musst, of course, be removed, because they assume theparticular segment usage of Phar Lap's own DOS extender.andM;Before loading the program you need to know how much memory to allocate, howmuch memory to load, where the stack pointer is to go and where the codebegins.andP;  All these items will be availabe in the header, though the exactformat will differ from linker to linker.andP;  In more detail, the sequence ofoperations is:andM;* open the file to be loaded.andM;* read the header and extract the fields you need.andM;* use Global132Alloc to allocate the desired amount of memory.andM;* read the load image from the file into memory.andM;* close the file.andM;* use Global132CodeAlias to get a code segment alias for the data segment.andM;* switch to the application stack.andM;* perform a long jump to the start address.andM;Because the loader perform needs to mix 16-bit and 32-bit offsets in acomplicated way it is easiest to write it in assembler.andP;  The loader segmentneeds to be declared as USE16.andP;  Remember to use pascal calling conventionsfor Windows routines; in other words, push the first argument onto the stackfirst.andP;  Thus the initial call to allocate memory may be as in Figure 3 whichsegment selector in selector.andM;Reading the load image requires some thought.andP;  If there are 20000H bytes itwill not do to use the code in Figure 4, because DOS will ignore the top halfof the ECX register and simply read O bytes.andP;  The file must be read inportions smaller than 64 KB.andP;  So we may start with the code;andM;reading the first 0C000H bytes into memory.andP;  This works ok, but it should beclear that adding 0C000H to EDX abd doing the same again will not work.andP;  Itwill correctlly read the 4000H bytes of code starting at DS:0C000H, but atthe end of the 64 KB segment DOS will wrap around and start again at DS:0.andM;Fortunately there is a call available to remedy this: we can obtain a newselection for a segment starting at DS:0C000H, as in Figure 5.andP;  Such aselector is called an alias, and allows you to tile segment selectors so thatthe whole of a very large segment is covered by tiles whose individual sizesare less than 64 KB.andP;  Now the data may be read using the code;andM;When the operation is finished, the 16-bit alias should then be freed withGlobal11PointerFree.andP;  Jumping into the data segment we have just loaded withcode would cause an error: but getting a code segment alias isstraightforward: see Figure 6.andP;  At this point all that remains is to startthe application, as in Figure 7.andP;  It is for the sake of tricks like this thatwe must program in assembler.andM;Generally assemblers have not caught up with mixed USE16 and USE32 segments.andO;The and for procs.andP;  In a USE16 segment a nearproc pushers just a returnoffset on the stack while a far proc pushes a 16-bit offset and segment onthe stack; but nothing pushes a 32-bit offset and a segment.andP;  Similarly withreturn statements.andM;In the instruction encoding of the 80386 processeor there are not separateopcodes for 16 and 32 bit operations.andP;  Instead , the processor looks for a32-bit operand in a USE32 segment and a 16-bit operand in a USE16 segment;but the code generated is just the same.andP;  How then, can a 32-bit operand beused in a USE16 segment?andP;  The answer is the size override byte, which has nosymbolic name but happens to be 66H.andP;  We have to define big;andM;and insert the override in the code stream ourselves.andP;  (Of couse, you canjust putandM;in the middle of your proram if you insist).andM;System servicesandM;You cannot use int 21H instructions in the 32-bit part of your program andyou cannot link with library routines that contains such instructions.andO;Interrupt 21H in protected mode is a 286 trap gate, which means that when itreturns it will pop a 16-bit offset off the stack, and therefore, probably,return somewhere stange, say in the middle of an instruction.andM;System services must be provided within the 16-bit part of the application.andO;It is, therefore, necessary to allow the 32-bit code to call the 16-bit code(probably you need to call the Windows library too, and every so often yieldcontrol to other applications).andM;It isn't possible to link the USE32 segment directly with the loader program,for obvious reasons.andP;  Instead the USE32 routine should be replaced by a stubthat calls across to the 16-bit using a jump table.andP;  Thus, suppose that wehave a routine openf (char*) that opens a named file.andP;  Instead of opening thefile directly the USE32 routine may say something like the code;andM;All that this does is to look in a jump table to find the address of the16-bit open routine and transfer control there: OPENF is a suitable literal.andO;The jump table must be initialised at the start of the USE32 code based on atable passed by the 16-bit code.andM;A pointer to the name of the file to be opened is passed on the stack.andO;Provided that the USE32 program keeps its stack below offset 10000H, the twoprograms can use the same stack, and I would strongly recommend doing this ispossible.andP;  If use of a high level language forces you to put the stack higherthan this then every call to USE16 code will have to switch to the 16-bitstack and copy the approriate number of arguments from the USE32 stacks; andafterwards, switch back.andM;Another proble will arise if the name of the file is above offset 10000H;this is hard to avoid.andP;  In that case you can either copy the name lower (butthis gets very tedious in some cases, such as buffered I/O) or you can take a16-bit alias of the address as we did in reading the load image.andP;  Providedyou write a general purpose table based interface rather than generating eachpiecd of code separately, this is the beter approach.andM;ConclusionandM;It is hard to estimate the work involved in converting any application.andP;  Itis a great advantage that you need only convert calls used by yourapplication; you don't have to produce a general purpose interface.andP;  I willonly say that it tool me much less time to convert Prolog-2 than I hadexpected.andM;I suppose it would be fair to say that 32-bit programming under Windows 3 isnot for the timid.andP;  Later releases will make it easier.andP;  For the programmerwho needs to deliver 32-bit applications of the PC, the Windows 32-bit DLLhas unique advantages: it's available now, it works, and you can give it awaywith your application.andM;PSandM;Microsoft has announced that there will beandM;32-bit version of the Windows API, called Win 32.andP;  This will make all thecontortions described in this article unnecessary, and it will be possible tolink 32-bit code directly with the Windows libraries.andP;  Moreover, the nextrelease of Microsoft C will come in two forms: 16-bit or 32-bit.andP;  Thedeveloper's tools for Win 3 are due to be shipped in version based on DOSuntil 1992; moreover, it is expected that many users will stay with 16-bitWindows.andM;More immediately, the WLO libracies allow Windows applications to run underOS/2.andP;  OS/21.x will not support WINMEM32.DLL, but OS/22.x together with WLO1.0, which will be part of the SDK for Windows 3.1, will allow WINMEM32calls.andP;  So anyone developing a 32-bit application in the way described inthis article should be able to supply a common .EXE file that will work bothwith Windows and with OS/2.andP;  (We will be printing an in-depth article on WLOin the near future-Ed.)andO;</TEXT></DOC>