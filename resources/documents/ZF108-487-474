<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-487-474  </DOCNO><DOCID>08 487 474.andM;</DOCID><JOURNAL>Communications of the ACM  March 1990 v33 n3 p281(13)* Full Text COPYRIGHT Association for Computing Machinery 1990.andM;</JOURNAL><TITLE>Scaling up: a research agenda for software engineering. (excerptsfrom a report on the software development by the Computer Scienceand Technology Board)andM;</TITLE><SUMMARY>The National Research Council's Computer Science and TechnologyBoard (CSTB) issues a report on long range planning and objectivesfor software engineering.andP;  Software engineering, especially forlarge-scale systems, is often ad hoc and forced.andP;  There is also alack of communication between researchers and practitioners.andP;  Inaddition, software engineering is the least developed andformalized of engineering fields.andP;  The CSTB suggests a three-partmodel based on realistic perspectives about software developmentand management, developments in software engineering practices andclarification of how research is done.andP;  These should be approachedwith short- and long-term perspectives to produce accurateanalyses of present conditions and effective models for futuresoftware development systems.andP;  The overall goal is to improve thequality and lower the cost of software engineering.andM;</SUMMARY><DESCRIPT>Topic:     National Research Council. Computer Science and Technology BoardReportsSoftware engineeringGoals and ObjectivesLarge-Scale Systems.andO;Feature:   illustrationtablechart.andO;Caption:   Observations on complex systems. (table)Agenda for software engineering research. (table)A unifying model for software system design. (chart)andM;</DESCRIPT><NOTE>Only Text is presented here; see printed issues for graphics.andO;</NOTE><TEXT>Scaling Up:  A Research Agenda for Software Engineering Business, government,and technical endeavors ranging from financial transactions to space missionsincreasingly require complex software systems to function.andP;  The complexity ofthe software arises from stringent requirements (e.g., for reliability inperformance and integrity of the data used), the need to support a range ofinteractions with the environment in real time, and/or certain structuralfeatures (see Table I).andP;  These attributes make software difficult to produceand often require large-scale projects involving the efforts of severalhundred -- even a few thousand -- programmers, software engineers,applications experts, and others working for one year or more.andP;  Thedifficulty of developing complex software systems tends to force delays inthe implementation of new applications, compromises in what thoseapplications can do, and uncertainties about their reliability.andP;  As a result,there is a perception in the field, especially in industry, that opportunitycosts are large and growing.andM;How can this situation be improved?andP;  The problem has resisted the efforts ofmany talented individuals over many years.andP;  Some degree of resistance tochange is inevitable, reflecting the inertia that comes from the large andcumulative investment that companies have made in their software developmentprocesses.andP;  However, the Computer Science Technology Board (CSTB) workshopparticipants expressed a widely shared frustration that options circulatingwithin the software engineering community fall short of what is needed (orfall on deaf ears).andP;  In the past suggested solutions have ranged from ways toimprove tools used by software developers to ways to improve the managementof software development teams; they have often been couched as options forimproving productivity in software development, itself a slippery andmany-sided concept.andM;AGENDA RESEARCHandM;Directions for ChangeandM;Acknowledging those suggestions and accepting that there may be no &quot;silverbullet&quot; in this area [13], CSTB workshop participants reached the consensusthat progress will be made if the vast array of existing and emergingknowledge can be codified, unified, distributed, and extended moresystematically.andP;  Software requirements for large and complex systems havebeen outrunning understanding of their fundamental principles, and softwaredevelopment practices have not filled that gap.andP;  Further, the sharedframework of existing knowledge has not grown commensurately with advancesmade by individual practitioners.andP;  Codification of existing knowledge wouldhelp to make the process of developing routine software (which is what mostsoftware is) more routine, thereby saving time and money.andP;  It is essentialfor progress in the reuse of knowledge.andP;  A strategy for dissemination ofcodified knowledge should build on the concept of software engineeringhandbooks.andM;CSTB workshop participants agreed that software engineering research cancontribute to the improvement of practice if the research community broadensits view of what constitutes good research (and amends its reward structureaccordingly).andP;  In particular, researchers need to look to practice to findgood research problems, validating results against the needs of practice aswell as against more abstract standards.andP;  The problems experienced bypractitioners are serious and pressing, and they call for innovativesolutions.andP;  The promise of fruitful interactions between researchers andpractitioners should not have to founder because of cultural differencesbetween the two groups.andM;The CSTB workshop underscored the need for both software engineeringresearchers and practitioners to accept a more realistic view of the problem.andO;Many of the problems experienced today reflect implicit assumptions that theflow from software system concept to implementation is smoother and moreorderly than it is, as well as implicit assumptions that a developmentprocess involving project teams is subject to the degree and kind of controlthat might be found if a single individual were responsible for the software.andO;A clearer understanding of the realities of software development can lead toimprovements in any of several ways.andP;  For example, it may facilitate theidentification of valuable tools that do not now exist, or it may facilitatethe identification of fundamental flaws in the software development processitself.andP;  A more realistic view will also make clear the extent to whichproblems are technical or are amenable to technical solutions.andM;Specific Short-and Long-Term ActionsandM;Improving the development of complex software systems requires a series oflong-term (5 to 10 years or more) and short-term (1 to 5 years) measures.andO;The CSTB workshop reached consensus on several directions for change insoftware engineering research, which fall into three interconnected areas:(1) perspective, (2) engineering practice, and (3) modes of research (seeTable II).andP;  These improvements are outlined and discussed in greater detailin the body of the report.andP;  Carried out together, they will bring to softwareengineering strengths found in traditional engineering disciplines, notablythe effective reuse of shared knowledge and a working distinction betweenroutine and innovative design.andP;  Some of these directions have been advancedbefore; others are more novel.andP;  CSTB workshop participants shared the hopethat this new presentation and the consensus it represents will help tocatalyze much-needed changes.andM;The remainder of this report examines each research agenda item in turn.andO;Determining the details of implementing the measures outlined here was beyondthe scope of the CSTB workshop.andP;  It is clear, however, that implementation ofthe recommended measures will hinge on funding for corresponding researchprojects and other incentives.andM;PERSPECTIVEandM;The software research community has not kept up with the development ofcomplex software systems in industry and government, while in the field,managers concerned with procuring software systems often evince idealized andunrealistic views of how software is developed.andP;  A critical reality in thefield that is insufficiently appreciated by academic researchers and systemspurchasers is the extent to which existing systems tie up resources.andO;So-called system maintenance may constitute up to 75 percent of a system'scost over its lifetime.andP;  The high cost of maintenance diminishes the amountof money available to replace existing systems, and it lengthens the paybackperiod for investment in new system development.andP;  It makes designing for asystem's entire life cycle imperative, but such design is rarely if everachieved.andP;  CSTB workshop participants agreed that to progress in systemdevelopment, it is time to portray systems realistically.andP;  They also agreedthat a more rigorous use of mathematical techniques can help researchers tomanage and diminish complexity.andM;SHORT-TERM ACTIONSandM;Portray Systems RealisticallyandM;View Systems as Systems, not as Collections of Parts.andP;  While the computerfield has helped to popularize the word &quot;systems&quot; and the concept of systems,it is ironic that information systems developers have not developed formalmechanisms to understand systems and the interrelationships among systemcomponents.andP;  Software engineering researchers have been unable to provideeffective guidance to practitioners regarding the process of systemdefinition and the concomitant implementation of functional elements.andO;Progress in developing software systems requires a fundamental appreciationthat those systems are more than just a collection of parts and that softwareis embedded in larger systems with a variety of physical components; designof such systems must deal with both of these issues.andP;  Design of softwaresystems must also take into account the fact that the whole system includespeople as well as hardware, software, and a wide variety of materialelements.andM;Recognize Change as Intrinsic in Large Systems.andP;  Software projects areincreasingly likely to be built on top of an existing, installed base of coderather than built anew.andP;  As that installed base of software grows over time,software systems that might or might not have been designed to endure havebeen patched, modified, and &quot;maintained,&quot; transforming them greatly fromtheir original designs and functions [5].andP;  Two factors are at work here: Thefirst is that systems are often not designed well-enough to begin with, andthe second is that user needs change over time -- new requirements arise, andexisting systems must be adapted to accommodate them.andP;  But commonly usedconceptualizations, such as the waterfall model or even the spiral model,assume a more sure-footed progression from requirement specification todesign to coding to testing and to delivery of software than is realistic[10], [30].andP;  Given that 40 to 60 percent or more of the effort in thedevelopment of complex software systems goes into maintaining -- i.e.,andO;changing -- such systems [9], the design and development processes could bemade more efficient if the reality of change were accepted explicitly.andM;Sustaining the usefulness of software systems differs from the care of otherassets because it entails two distinct activities: (1) corrective andpreventive maintenance, which includes the repair of latent defects andtechnological wear and tear, and (2) enhancement, which normally introducesmajor transformations not only in the form but also in the functions andobjectives of the software.andP;  Enhancement activities have been observed toconstitute perhaps 75 percent of the total maintenance effort.andP;  (2)andM;The degree and impact of change is analogous to the evolution of an urbanneighborhood: Over time, old and obsolete buildings are torn down, the supplyof utilities changes in both quality and delivery aspects, and transportationroutes and media change.andP;  As new needs, wants, and capabilities emerge, thestructure and function of the neighborhood evolve.andP;  The neighborhood is notthrown out wholesale and replaced because doing so would be far too costly.andO;As with changes in neighborhoods, changes in software are not alwaysimprovements; software systems suffer from the tension between providing forfunctional flexibility and assuring structural integrity of the system.andM;Software developers in industry and government are increasingly aware thatchange occurs from the earliest design stages as initial expressions ofcustomer requirements are refined.andP;  Managing this change involves managing amix of old code (typically with inadequate documentation of originalspecifications as well as modifications made over time), new programmers, andnew technology.andP;  The process is ad hoc, and the problem grows over time; thelarger the installed base of code, the more formidable the problem.andP;  Theproblem is aggravated where management decisions, including contractingdecisions, keep developers and maintainers separate.andM;Ideally, system designers leave hooks for the changes they can anticipate,but problems arise from major changes that result from changed circumstancesor goals.andP;  Also, schedule and process pressures often militate againstproviding for functional flexibility and future changes.andP;  Further, thecurrent generation of computer-aided tools for software engineersconcentrates on development activities and generally neglects maintenance.andO;As a result, supporting information for new code and the tools to exploit itare not carried forward from development to maintenance.andP;  More seriously,these tools do not accommodate large bodies of code developed without usingthe tools, although some progress is being made in the necessaryrestructuring of programs to accommodate computer-aided tools.andM;Just as change should be accepted as a basic factor in most large, complexsystems, designing for change should become a fundamental body of knowledgeand skill.andP;  The very notion of maintenance as an activity separate from thecreation process seems to legitimize high costs, poor support, and poorlymanaged redesign.andP;  Eliminating this notion via a move toward designing andbuilding systems in anticipation of change would help to increase theengineering control over post-release modification.andP;  Since software reflectsboth system specifications and design decisions, changing either element willindirectly produce changes in the code.andP;  One possibility is to strive fordesigning systems that are more modular or easier to replace as needs change.andM;It should be noted that the issue of determining what the software shall do(the &quot;requirements definition&quot;) is much broader than software engineeringpractices today would suggest.andP;  This perceptual difference contributes to themaintenance problem.andP;  What is needed is a thorough investigation, analysis,and synthesis of what the combined functions will, or should, be of theautomated and non-automated (human, business, or physical) elements of thesystem, including all &quot;think flows,&quot; work flows, information flows, and otherfunctionalities.andP;  A total systems approach would be involved with a heavyemphasis on the conceptualization of the functional role of both theautomated parts and the fully combined systems, allowing for reengineering toaccommodate or exploit the changes that are made possible by introduction ofthe automated system.andM;Understanding the reasons for change and the costs, impacts, and methods ofchange could lead to more control of a major part of software developmentcosts.andP;  Creating mechanisms that allow for change and that make systemsrobust while undergoing change will help to reduce opportunity costs insystem development and deployment.andP;  Part of what is needed is a change inattitude.andP;  But for the long term, a theory of software systems is needed thatwill build on empirical study of software system applications.andM;Study and Preserve Software ArtifactsandM;Although systems developers work with an evolving set of goals andtechnologies, they can still learn valuable lessons from existing systems --lessons about what led to success or failure and what triggered incrementalor major advances.andP;  The history of computing is replete with instances inwhich identifying the intellectual origins of key developments is difficultor impossible because most advances, in their time, were not thought of asintellectual issues but instead were treated as particular solutions to theproblems of the day.andP;  Most software specialists would be hard put to name&quot;seven wonders of the software systems world&quot; or to state why those wondersare noteworthy.andP;  (3)  Meanwhile, the artifacts of such systems aredisappearing every day as older equipment and systems are replaced with newerones, as projects end, and as new applications emerge.andP;  Because almost alllarge software systems have been built in corporate or government settingswhere obsolete systems are eventually replaced, and because those systemshave received little academic attention, useful information may be vanishing.andM;A concerted effort is needed to study (and in some cases preserve) systemsand to develop a process for the systematic examination of contemporary andnew systems as they arise.andP;  Immediate archival of major software artifacts,together with the software tools needed to examine them, or even toexperiment with them, would enable both contemporary and future study.andO;Systematic study of those systems would facilitate understanding of theontology of architecture and system components, provide a basis for measuringwhat goes on in software development, and support the construction of betterprogram generators.andM;Studies of contemporary systems would provide an understanding of thecharacteristics of software developed under present techniques.andP;  Such aneffort would examine software entities such as requirements documentation,design representation, and testing and support tools, in addition to theactual source code itself, which has traditionally been the focus ofmeasurement.andP;  Better mechanisms that provide quantifiable measures ofrequirements, design, and testing aspects must be developed in order tounderstand the quality baseline that exists today.andP;  Existing mechanisms formeasuring source code must be put to more widespread use to better assesstheir utility and to refine them [12], [23].andP;  In addition, variations inquality need to be traced to their sources to understand how to control andimprove the process.andP;  Thus this effort should encompass less successful aswell as exemplary artifacts, if only to show how poor design affectsmaintainability.andP;  The examination of artifacts should be combined withdirected interviews of the practitioners (and system users) and observationof the process to correlate development practices with resulting productquality.andM;Having quantifiable measurements would enable new, innovative developmentmethods and practices to be evaluated for their impact on product quality.andO;However, as the software industry evolves, so too must the measurementtechniques.andP;  For example, if new means of representing requirements anddesign are put into practice, the measurement techniques must be updated toaccommodate these new representations.andP;  In addition, efforts to automatemeasurement can be improved if researchers consider measurability as anobjective when developing new development methods and design representations.andM;Such measurement and research cannot take place in the laboratory due to thesize of the actual systems being developed (the costs of experiments at thisscale are prohibitive).andP;  Moreover, it is unlikely that small experiments canbe extrapolated to apply to large-scale projects.andP;  A cooperative effortbetween government, industry, and academia could provide necessary funding,access to real-world artifacts and practitioners, and the academic researchtalent required for such an effort.andP;  Such a combined effort also wouldprovide an excellent platform for greater collaboration in softwareengineering research between members of these communities.andP;  Designation andfunding of one or more responsible entities are needed, and candidatesinclude federal agencies (e.g., the National Science Foundation and theNational Institute of Standards and Technology), federally funded researchand development centers, or private institutions.andM;Finally, active discussion of artifacts should be encouraged.andP;  A vehicle likethe on-line RISKS forum sponsored by the ACM, which provides a periodicdigest and exchange of views among researchers and practitioners on risksassociated with computer-based technology, should be established.andP;  Also,completed case studies would provide excellent teaching materials.andM;LONG-TERM ACTIONSandM;Build a Unifying ModelandM;for Software System DevelopmentandM;Shortcomings in software systems often reflect an imperfect fit to the needsof particular users, and in this situation lie the seeds for useful research.andO;The imperfect fit results from the nature of the design and developmentprocess: Developers of complex software systems seek to translate the needsof end-users, conveyed in everyday language, into instructions for computersystems.andP;  They accomplish this translation by designing systems that can bedescribed at different conceptual levels ranging from language comprehensibleto the intended user (e.g., &quot;plain English&quot; or formal models of theapplication domain) to machine language, which actually drives the computer.andO;Different spheres of activity, referred to by the profession as end-userdomains, include the following: * scientific computation; * engineeringdesign; * modeling and visualization; * transaction processing; and *embedded command and control systems.andM;These domains tend to have different types of abstraction and differentlanguage requirements arising from differences in the representations ofapplication information and associated computations.andP;  As a result, softwaredevelopers work with a variety of domain-specific models.andP;  During the designprocess in any domain, key pieces of information or insights tend to be lostor misinterpreted.andM;How can the process of moving from a domain-specific model to a working pieceof software be improved?andP;  One approach would be to develop a unifying view ofthe software design process and the process of abstraction, a view that woulddefine a framework for the task of the complex software system developer.andO;CSTB workshop participants did not reach a consensus on this complicatedissue, but to illustrate the point, they began to sketch out the parametersfor such a framework (Figure 1).andP;  For example, a system design can be thoughtof as a sequence of models, one [(M.sub.i, j] at each level.andP;  Different sortsof details and design decisions are dealt with at each level.andP;  The model ateach level is expressed in a language [(L.sub.i, j)].andP;  Languages are notnecessarily textual or symbolic; they may use graphics or even gestures.andO;Also, languages are not always formally defined.andP;  (4)  Just as the domains ofdiscourse at each level are different, so are the languages.andP;  Finally, theunifying view would distinguish domain-specific models, a multilevel set ofappropriate languages (although it is possible that languages may be shared-- or largely shared -- across domins), abstractions, and interlevelconversion mechanisms.andM;Useful Outcomes.andP;  The concept of a unifying model and the associated issuesare emblematic of the larger problem of achieving more complementaritybetween software engineering research and practice.andP;  A unifying model wouldnot necessarily be of immediate use to a system builder.andP;  But it would be atool for academic analysis that could, in turn, yield structures and toolsuseful to a practitioner.andP;  In particular, it could help a researcher toanalyze the software development process and forge improvements that mightmake that process more efficient in practice.andM;For example, a unifying view could help the software engineering researchersee the relation among existing mechanisms, or what mechanisms are missing,or devise ways to facilitate transitions from one major conceptual level toanother (since it is necessary to be able to convert a system description atone level to a system description at an adjacent level).andP;  (5)  By showing howparts are related, unification may facilitate the collapse of domain-specificmodels to include fewer levels than at present.andP;  (6)  Eventually, it may bepossible to move automatically from a description of requirements to aworking product, bypassing intermediate levels.andP;  The modeling process canfacilitate this progress much as the modeling of production processes inmanufacturing has facilitated the reduction of the number of tasks inmanufacturing processes and the application of manufacturing automation.andP;  Asnoted, better coordination technology, which would support both the modelingand the development processes would also be useful.andM;Research Implications.andP;  While the theory and nature of program transformationfunctions, drawing on a body of knowledge about language that crosses levels(sometimes called wide-spectrum language), have already been developed ([3],[28] [33]), the proposed kind of unifying view would also motivate new stylesof research independent from those noted previously.andP;  Relevant currentresearch addresses traditional programming language (although some of thisresearch is in eclipse), computer-supported cooperative work (beyond the meremechanical aspects -- see Nurture Collaboration), and efforts to raise thelevel at which automation can be applied.andP;  Also needed are the following:andM;* Research that would support the development of domain-specific models andcorresponding program generators -- it is critical to recognize thelegitimacy of specialization to the domain at the expense of expressivegenerality.andP;  * Research to identify domains, levels, and commonalities acrossdomains, since languages are needed for each level and domain.andP;  * Researchinto the architectural level, which cuts across individual domain models.andO;This level deals with the gross function of modules and the ways they are puttogether (for procedure call, data flow, messages, data sharing, and codemingling).andP;  The aggregates defined at this level include &quot;state machine,&quot;&quot;object-oriented system,&quot; and &quot;pipe/filter system.&quot;andP;  Contrast this with theprogramming level, where the issues are algorithms and data structures andthe defined entities are procedures and types.andM;* Research into whether it is possible to implement a concept found in themechanical engineering environment, the quarter-scale model, and if so, how.andO;A quarter-scale model, which would provide a more precise and detailedcorrespondence to the desired system than does a conventional prototype,would help to convey the complexity and various design attributes of asoftware system.andP;  It would allow practitioners to better comprehend how wella design works.andP;  It would also allow managers to control risk by helping themto understand where problems exist and to better estimate the resourcesrequired to solve those problems.andP;  In essence, it would make a seeminglyintangible product, software, more real.andM;* Investigation of the mechanisms for making the transition between and amongthe various levels of abstraction.andP;  This research would involve explorationof automation aspects (e.g., compilers and generators) and computer-aided andmanually directed steps.andP;  It would also involve exploration of the order ofdevelopment of the models of a system:  Whereas the conventional waterfalllife cycle calls for completing each model before translating to the next,other approaches such as rapid prototyping or the spiral model allow forsimultaneous development of several models.andM;* Reformulation of expressions of rigor and technical precision (sometimesreferred to as &quot;correctness&quot;), performance given resources, traceability,cost, reliability, and integrity.andM;Strengthen the FoundationsandM;In the absence of a stronger scientific and engineering foundation, complexsoftware systems are often produced by brute force, with managers assigningmore and more people to the development effort and taking more and more time.andO;As software engineers begin to envision systems that require many thousandsof person-years, current pragmatic or heuristic approaches begin to appearless adequate to meet application needs.andP;  In this environment, softwareengineering leaders are beginning to call for more systematic approaches: More mathematics, science, and engineering are needed [25].andM;Workshop participants focused on application of such approaches to softwareanalysis.andP;  They also affirmed the value of mathematical foundations forbetter modeling and translation of real-world problems to the abstractions ofsoftware systems.andP;  Software analysis, which seeks to assure that softwareworks as specified and as designed, is both a significant and a critical partof the implementation of large software systems.andP;  Unfortunately analysisactivities have received too little focused attention, and what attentionthey have received has been largely limited to today's main analyticalapproach -- testing.andP;  Testing techniques, moreover, are constantly beingdiscovered and rediscovered.andM;A more rigorous and comprehensive approach to analysis is needed, one thatrenders techniques explicit, teaches about them, and develops its ownliterature and authority.andP;  In addition to testing, such techniques asproving, modeling, and simulation should be further developed and targeted tomore properties (e.g., safety and functional correctness).andP;  Work is needed inperforming measurements, establishing metrics, and finding a way to validatethem.andP;  The understanding of what constitutes a defect and how to verify thatdesigns or code are defect-free is today very limited.andM;It should be noted that the ability to find defects earlier in the life cycleof a product or to prevent them from being introduced reduces test cost andreduces the number of defects in products delivered to end-users.andP;  Thisability involves quality assessment and quality assurance.andP;  Researchquestions center on how to specify and measure the attributes (functional,behavioral, and performance) a system must possess in a manner that permitscorrect generation or proof.andP;  What aspects of a product can be assuredsatisfactorily only by testing as opposed to experimentation?andP;  What are theeconomic trade-offs between developing mathematical proofs and conductingtesting?andP;  How to design for testability and verifiability is also an issuehere.andM;Promising directions include the application of formal methods (which involvemathematical proofs), exploration of the mechanical and civil engineeringconcept of a quarter-scale model for previewing a design, application of the&quot;cleanroom concept&quot; (featuring walkthroughs of software with proofs of claimsabout features rather than checklists of flaws; [25]), and statisticalquality control analogous to that used in manufacturing.andP;  A handbook oftesting and/or quality assessment is desirable and will be possible withfurther development of the field of analysis.andM;ENGINEERING PRACTICEandM;The phrase &quot;software engineering&quot; was coined in 1968 as an expression ofaspiration.andP;  (7)  It remains today more an aspiration than a description.andO;(8)  The field of software engineering lacks the strengths and structure ofother engineering disciplines, which have a more highly developed theory andfirmer methodological foundations, as well as widely shared tools andtechniques.andP;  Engineering disciplines are rooted in craftsmanship and evolvethrough a commercial stage (with emphasis on production and management)before becoming engineering as we generally know it (see Table III).andP;  What isneeded is a way to define and discuss the &quot;parts&quot; of software engineering,the specifications for each, and a conceptual framework within which to placethem.andP;  Organizing known techniques and information to identify and describethe parts of the software enterprise and how they fit together would go along way toward enabling cleaner, more flexible design and developmentprocesses [8].andM;SHORT-TERM ACTIONSandM;Codify KnowledgeandM;for Dissemination and ReuseandM;ooCodifying existing software engineering knowledge and disseminating itthrough handbooks would help achieve several desirable ends: increasing theamount of software that can be created routinely, contributing to knowledgereuse, and ultimately, it is hoped, helping to reduce the size of programs,the time required to develop them, the risk of unacceptable errors, and thetendency to reinvent solutions to the same problems.andM;For software engineering to progress as a discipline, far more routinesoftware development must be produced routinely.andP;  At a time when our needsfor software are beginning to outstrip our ability to produce it, efforts toreduce the number of tasks requiring human effort are one obvious way toimprove the situation.andP;  Practice in traditional engineering disciplinesincludes opportunities for both innovative design (creating things that havenot been done before) and routine design (creating yet another example of aclass of things that is well understood).andP;  Current software practice tends totreat most designs as innovative, even when knowledge exists that shouldrender them routine.andP;  There is a need to make the reuse of knowledge routine,something many observers lament is far from happening.andM;Indeed, if builders built buildings the way many programmers wrote programs,then most of us would still be homeless, because builders, like too manyprogrammers, would be busy reinventing their technology every time they builtsomething new.andP;  Continually having to rediscover carpentry, metallurgy, andproject management, as well as having to write new building codes, wouldclearly be enormous disincentives to productivity.... [11]andM;Codifying knowledge and making it more accessible could be an important stepin moving toward a situation in which machines can do some of the routinetasks, leaving those more complex and creative tasks to humans.andP;  (9)  This isone potent way to improve software development productivity.andP;  Toward thisend, academic researchers can help practitioners by developing a conceptualframework for software elements, routine designs, and standard components,much as chemical engineers have developed a framework for the reuse of designelements at a large scale [29].andM;Reuse of code, a less flexible concept than is reuse of knowledge, is theavenue for minimizing programming effort that has been most widely discussedin the software research and development community [8].andP;  Althoughtheoretically attractive, there are many barriers -- both technical andsociological -- to significantly improving the amount of reuse actuallyachieved.andP;  Achieving reuse involves more than building libraries of programs,and it requires research on what kinds of reuse are feasible, how to index,how to represent reusable elements, and how to deal with variations in thelanguage in which a piece of reusable code is stated or even in the wordingof the specification.andP;  But so-called code libraries serve as precursors tothe broader concept of handbooks; current work in that area provides a usefulstarting point.andM;Develop HandbooksandM;Software engineering should follow the lead of other engineering fields,which codify basic knowledge and use handbooks as carriers of commonknowledge, thereby reducing the tendency for dispersed practitioners toindependently develop solutions to common problems, duplicating effort whilediluting progress.andP;  Handbooks for such disciplines as mechanical and chemicalengineering allow a broad sharing of general and specific technicalknowledge, which provides a base for further progress.andP;  Software engineeringneeds such products; references during the CSTB workshop to heavily usedcopies of Don Knuth's multivolume work, The Art of Computer Programming [21],illustrate that a demand exists but remains unmet except in selected, narrowinstances.andM;The structure and contents for software engineering handbooks cannot bedetermined without progress in accomplishing the codification discussedearlier.andP;  What is clear, however, is that there is a need for substantive aswell as process knowledge to be conveyed in these handbooks, and it is thatsubstantive component that distinguishes these handbooks from the manualsthat individual organizations use to standardize the software developmentprocedures followed by their employees.andP;  Thus handbooks should contain acompendium of algorithms (for example, see [15]), test methods, and itemspertaining to design and programming style.andP;  Also, to help practitioners workwithin the practical constraints they face, handbooks must vary for differentdomains; the languages, knowledge, and processes associated with, say,transaction processing systems differ from those used for large-scalescientific processing or other types of systems.andM;Given the dynamic nature of the field, a software engineering handbook shouldbe one that can use computer technology to deliver its contents -- anelectronic handbook.andP;  The goal is to have a repository of information thatcreates a uniform organization for current knowledge, presents theinformation accesibly, and provides a means for updating its contents easily.andM;LONG-TERM ACTIONSandM;Automate Handbook KnowledgeandM;To maximize the effectiveness of an electronic handbook, advances in severalareas to make such products easy and attractive to use will be necessary.andP;  Aresearch initiative aimed at the development of an electronically accessible,interactive software handbook should be inaugurated to develop the following:andM;* concepts and notations for describing designs and components;andM;* techniques for organizing and cataloging designs and components;andM;* techniques and representations for storing, searching, and retrievingdesigns and components;andM;* codification of routine designs and components for a large variety of typesof software and applications;andM;* techniques for evaluating designs and components in terms of engineeringtrade-offs;andM;* techniques for modeling and simulating systems based on routine designs andcomponents;andM;* criteria for evaluating and accepting or rejecting handbook entries; andandM;* technology to make the handbook easily usable and easily accessible.andM;If the technology and the electronic handbooks can be developed, it will beimportant to educate software engineers about appropriate methodologies andtechniques for using the information they contain.andP;  The handbooks themselveswill facilitate the teaching of routine design as part of softwareengineering -- itself an important step toward increased productivity.andO;Finally, the handbooks should not only be electronically &quot;recorded,&quot; but theyshould also be built into the standard tools of software engineers, makingfor a truly activist incarnation.andM;Nurture CollaborationandM;Complex software systems are created by the efforts of many people --sometimes as many as a few thousand organized into multiple teams -- andfrequently no one person has a thorough understanding of the interaction ofthe entire system.andP;  Further, the software developers must communicate withend-users and others to understand the application, the issues, and therequirements.andP;  System development is an exercise in collaboration, and it isnecessary to maximize the effectiveness of that collaboration.andP;  Although theteam management problem has captured much attention and concern -- muchcurrent software engineering consists of ad hoc measures or what could becalled &quot;crowd control&quot; -- today's measures do not go far enough [2], [6],[24].andM;Methodologies for iterative design are necessary.andP;  Specifications will alwaysbe idealized and simplified, and neither users nor designers are able toenvision the full functionality of the resulting system during thetraditional design stages.andP;  Consequently, system requirements are not so muchanalytically specified (contrary to appearances) as they are collaborativelyevolved through an iterative process of consultation between end-users andsoftware developers.andP;  Too many projects or designs have been completed thatdo not accomplish the desired end because substantive information was notwell conveyed or understood in the design or implementation process [17].andM;Better linkage of knowledge about application areas or domains with softwareengineering expertise is essential; it is an important direction forexploration.andP;  Another involves developing and sustaining a common world viewof systems under development.andP;  And a third is gaining understanding about howskilled designers make architectural trade-offs in the designs of systems[20], [32].andM;Better tools to support and enhance cooperative work are necessary in orderto provide productivity enhancements; the more time that programmers canspend designing and programming pieces of systems that uniquely require theirattention, as opposed to investing their time to overcome communicationsdifficulties, the more likely it is that systems can be built in less time.andO;Various forms of groupware, or tools for computer-supported cooperative work,may prove well suited to the collaborative process of system development.andO;Also, the development of high-speed, ubiquitous computer networks, coupledwith sophisticated and easy-to-use resources available through networkaccess, may provide software engineers with valuable research and developmenttools [6].andP;  For example, the growth of the information services business hasillustrated the market potential of data base searching, and handbookimplementation will depend critically on network access to data basefacilities.andM;The call for improved collaboration is not new, nor are discussions aboutcomputer support for collaboration.andP;  But it may be particularly timely, sincethe motivation in this area is high and new tools are appearing and becomingmore economical to use.andM;RESEARCH MODESandM;To complement existing directions in software engineering research and tobetter address the problem of developing software for large systems, CSTBworkshop participants identified a need for cross-fertilization betweenacademic software engineering researchers and practitioners as well asbetween software engineers and specialists in the behavioral and managerialsciences.andP;  CSTB workshop participants also urged universities to encourageadditional topics and styles of software engineering research and to seekcommensurate funding.andM;SHORT-TERM ACTIONandM;Foster Practitioner andandM;Researcher InteractionsandM;There is little academic investigation of the practices, techniques, orproblems out in the field today.andP;  To rectify this situation, greaterinteraction among researchers and practitioners is needed as a first step.andO;Such interaction has proved a boon in, for example, manufacturingengineering.andP;  Industry and university collaboration in that field hasprovided researchers and students access to real-world problems andconstraints, while providing practitioners with access to creativeproblem-solving talent and new techniques.andM;The interaction of academia, industry, and government in software engineeringhas been inhibited by culture and tradition [7].andP;  Although much is knownabout how complex software systems are built, there are few connections amongthe various repositories of practical knowledge.andP;  Much of the expertise incomplex software systems resides in corporations, government researchcenters, and other nonacademic institutions.andP;  It is largely inaccessible tothe academic community because of considerations of product delivery,proprietary knowledge, and cultural differences between the corporate andacademic communities involved in software research.andM;That academic computer scientists do not often study large software systemsand the process of developing them is one reason that practitioners oftenfeel that the issues studied by academia do not adequately address theproblems and challenges faced by builders of large systems -- despite anapparently large body of systems analysis, systems design, and otheruniversity courses that do address systems issues.andP;  This is particularly so,for example, for complex systems involving software embedded in otherproducts or systems (ranging from spacecraft to medical technology) and thosesystems that involve distributed processes in multiple non-homogeneouscomputing and storage elements.andM;There are a number of reasons that information generated in our universitiesflows slowly only into the commercial sector: Academics do not study largesystems because they do not have them or have access to them, and commercialand academic software specialists tend to read and have their work publishedin different journals.andP;  On the other hand, many topflight corporateresearchers and developers, to the extent that they publish at all, do notpublish in archival computer science journals because their topics --problems of practice -- are not deemed scholarly.andM;The disparity in perspective and exposure existing between the academicsoftware engineering research community and the practitioners of thecorporate world hinders U.S.andP;  progress in developing complex softwaresystems.andP;  Reducing that disparity is imperative, and it will require agreater degree of interaction between the two groups.andP;  Special meetings likethe CSTB workshop are but a beginning to this process; implementing aninitiative to preserve and study major artifacts and legitimizing academicexploration of large software systems are other vehicles for interaction.andM;LONG-TERM ACTIONSandM;Legitimize Academic ExplorationandM;of Large Software SystemsandM;Academic investigation of research topics based on problems encountered inthe real world by software developers could help industrial and otherpractitioners in both the short and long terms.andP;  For this to happen, newattitudes and incentives must be adopted.andM;As currently structured, most academic departments are not conducive tolarge-system research.andP;  The tendency of universities to encourage and rewardnarrow specializations compounds the problem of a lack of opportunity orfunding for access to large, complex systems by academic softwareresearchers.andP;  Another side of this problem is the focus of the academic worldon individual actions, whereas the corporate world is more team oriented.andO;The realities of academic life -- funding, tenure tracks, and other careerconcerns -- militate against an individual academic researcher making astrong commitment to large-system research without consideration from thesurrounding environment.andM;Further, whereas industry tends to focus on a problem as it appears inproduction, researchers (whether corporate or academic) need to find theunderlying conceptual problems that are amenable to the development ofknowledge that transcends a particular system manifesting a problem.andO;Identification of good research problems based on production problems is anontrivial problem that itself requires focused efforts.andP;  And to pursue thatresearch requires analytical advances inasmuch as abstract formal models arelacking, language design issues are in eclipse, and testing and measurementhave not been formalized.andM;Funding is a major consideration.andP;  Funding of some considerable magnitude isneeded if large systems are to be built -- which is necessary to determinefeasibility -- and studied in academic settings, because the artifacts beingstudied are large.andP;  Also, while some universities have state-of-the-arthardware resources (although many do not), universities seldom invest insoftware tools and tend to lag behind industry in that area.andP;  This is aproblem because there must be a fit between hardware and software acrossacademic and industrial environments if large artifacts are to beexperimented with other than as text (code).andP;  Thus it is difficult to studylarge systems cost effectively.andP;  Solving this problem requires innovations infunding, the details of which were beyond the scope of the workshop but whichwould clearly involve actions by government research funders, universities,and companies (including product development as well as research entities).andO;Another direction for improvement and relief may come from enhancednetworking, such as through the proposed national research network, whichwould allow dispersed researchers to share access to artifacts, otherresearchers, and practitioners [16].andM;If software systems are to be studied in corporate settings, a number ofother difficulties will need to be overcome on the industry side.andP;  Resolvingthese difficulties will take much thought and concerted action; the CSTBworkshop identified key directions for change.andP;  The insights and enhancementsthat software engineering managers and practitioners seek will come at aprice: Industry must be willing to provide support -- financial and humanresources, and computer resources for experimentation -- as well as access tothe records of the proprietary system.andP;  Mechanisms would be needed tocompensate industry for its efforts to produce data in a form useful toresearchers or for bearing the risk of experimenting with novel developmentactivities.andM;Perhaps the biggest concern is protecting the proprietary interests ofcorporations, for whom large systems are often a source of competitiveadvantage.andP;  Although the academic culture is devoted to openness andinformation exchange, universities are actively grappling with the problemsof protecting corporate proprietary information that are presented byincreasing corporate interest in research on practical problems.andP;  Businessschools appear to have solved this problem some time ago.andP;  It should bepossible to extend such efforts to apply to academic research into corporatesoftware systems.andM;Finally, one way to get around some of the difficulties of studying largesystems in corporate settings would be to facilitate the study of largesystems in government settings.andP;  The federal government has been the impetusfor the development of large-scale integrated systems, interaction withacademic researchers is a long-time tradition for many governmentorganizations, and government entities are more obligated to respond togovernment programs or mandates.andP;  However, inasmuch as federal systems aredeveloped and/or managed by private organizations, limitations on access todesign and development processes and personnel may have to be overcome, as inpurely corporate settings.andP;  Also, some peculiarities of federal systemsdevelopment are not generalizable to commercial systems.andP;  For example, thefederal procurement process is associated with specifications that are muchmore detailed than those typically generated by commercial buyers.andP;  Study offederal systems may therefore be an option that is second best.andM;Glean Insights from BehavioralandM;and Managerial SciencesandM;There is a need to better understand how groups of people collaborate inlarge projects involving a variety of participants sharing a rich but unevendistribution of knowledge and imagination among them.andP;  Software engineeringresearch would be enhanced by greater inter-action with behavioral,managerial, and other scientists that could lead to increasingly effectivecontributions to software engineering practice, in part by accelerating thetransfer of technology into and through the software engineering community.andO;The field has benefited in the past from technology transfer; for example,configuration management practices and change-control techniques developed inthe aircraft industry were adopted in the 1950s and 1960s.andM;There may be particular value in augmenting the insights of computer scienceand electrical engineering with the insights of behavioral and managerialsciences.andP;  Since large software systems will continue to be produced by teamsfor the foreseeable future, insights gained in other team contexts may beuseful for software engineering.andP;  To get those insights it may be necessaryfor software engineers to actually team up with specialists from otherdisciplines; the benefits of such cross-disciplinary teams have beendemonstrated, for example, in the area of ergonomics, where cognitive andmanagement science specialists have been brought in to determine how best tocomplement human skills with automation.andP;  Even within computer science, someareas other than software engineering have aging software platforms that needto be reimplemented to make them less brittle and more easily changed or toimprove the user interface to take advantage of workstation technologyadvances.andP;  In such areas software engineers could collaborate with othertypes of computer scientists and engineers in new developments that bothproduce new tools and serve as the objects of study.andP;  The CSTB workshoppointed to a need for software engineers to glean insight from people withcomplementary expertise but did not develop the concept.andM;Develop Additional DirectionsandM;Software engineering research today follows a variety of patterns, includingthe following:andM;* building systems with certain properties to show their feasibility;andM;* measuring properties of one or several systems;andM;* improving the performance of systems along particular dimensions;andM;* developing abstract formal models for certain domains;andM;* showing how to describe phenomena by designing languages; andandM;* making incremental improvements on prior work.andM;All of these activities are relevant to complex software systems.andP;  But giventhe nature of those systems and the problems we face today, some newapproaches to research may also be productive.andM;CSTB workshop participants recommended that the academic research communityexpand its notion of good research to accept review or synthesis studies,case studies, comparative analyses, and development of unifying models forindividual or multiple domains.andP;  In particular, review or synthesis studies,which are common in a number of other fields, would support a greater andongoing codification of software engineering knowledge and help to minimizethe reinvention of techniques and processes.andP;  Finally, if effective handbooksare to be developed, as recommended above, research that supports suchhandbooks must be encouraged and rewarded.andM;CONCLUSIONSandM;Modern society is increasingly dependent on large, complex computer-basedsystems and therefore on the software that drives them.andP;  In many cases,systems designed 20 years ago still provide a foundation for large businesses-- and such systems are becoming unmaintainable.andP;  As the ability tomanipulate, analyze, and grasp information has been magnified by informationsystems, so also has the appetite to process more and more information.andP;  Eachnew application has generated ever more complex sets of software systems.andP;  Inthe past few years, problems with such systems have cost millions of dollars,time, and even lives in applications ranging from aviation to controls formedical devices.andP;  Improving the quality and the trustworthiness of softwaresystems is a national priority, but it is also a problem that seems foreverto receive less attention than it deserves because software systems seeminvisible, are poorly understood by laymen, and are not even adequatelyaddressed in universities.andP;  Managers are consistently surprised by theinability of software engineers to deliver software on time, within budget,and with expected functionality.andP;  The nation should not have to wait for acatastrophe before it tries to enhance this critical resource.andM;The software research community has ridden the waves of several advances;expert systems and object-oriented programming have been among the topicalfoci of researchers during this decade.andP;  Although large-system developersbenefit from these and other advances, the software systems challenge isfundamental and is not amenable to solution through single categories ofadvances.andM;As discussed in this report, a necessary first step is for the softwareengineering community and managers who procure and use large software systemsto adopt a more realistic vision of the complex software system developmentprocess.andP;  Following on, the direction and conduct of software engineeringresearch should be both broadened (in particular, by fostering interactionswith practitioners) and made more systematic, through codification anddissemination of knowledge as well as an infusion of more mathematics,science, and engineering.andP;  Good problems make good science and engineering --and good problems in the software development community are being bypassedbecause software engineering researchers are unable to deal with them in astructured, rigorous manner.andM;The Chinese pictograph for &quot;crisis&quot; is composed of the characters for&quot;danger&quot; and &quot;opportunity.&quot;andP;  The wisdom this represents is worth noting as wegrapple with the looming crisis in our ability to create and maintain largeand complex software systems.andP;  The danger is that soon we might not be ableto create the software our business and government applications need.andP;  Theopportunity is there for the software engineering research community to findnew and fruitful directions in the problems faced by practitioners.andM;(1) These conclusions are consonant with those of the Defense Science BoardTask Force, [18] which focused on management aspects because attitudes,policies, and practices were a major factor in defense software systemacquisition.andM;(2) The National Bureau of Standards (now the National Institute of Standardsand Technology) drew on several studies to decompose maintenance intocorrective maintenance (20 percent), including diagnosis and fixing design,logic, or coding errors; adaptive maintenance (25 percent), which providesfor responses to changes in the external environment; perfective maintenance(50 percent or more), which incorporates enhancements; and preventivemaintenance (5 percent), which improves future maintainability andreliability [22], [34].andP;  Similarly, experience with U.S.andP;  Air Force weaponssystems suggests that while 15 to 35 percent of software maintenance correctsdesign errors, 25 to 50 percent adds new capability, 20 to 40 percentresponds to changes in the threat, 10 to 25 percent provides new systeminterfaces, 10 to 20 percent improves efficiency, 5 to 15 percent improveshuman factors, and 5 to 10 percent deletes unneeded capability [26].andM;(3) An informal query addressed to a community of several hundred softwareengineering specialists suggested the following candidates: the SAGE missiledefense system, the Sabre interactive system for airline reservations, theYacc compiler tool for UNIX, ARPANET communications software, and theVisiCalc spreadsheet package, among others.andM;(4) To serve this model-definition role, a language must provide fiveessential capabilities: (1) component suitability -- module-level elements,not necessarily compilation units, with function shared by many applications;(2) operators for combining design elements; (3) abstraction -- ability togive names to elements for further use; (4) closure -- named element can beused like primitives; and (5) specification -- more properties thancomputational functionality, with specifications of composites derivable fromspecifications of elements.andM;(5) This process of transition is sometimes accomplished manually andsometimes mechanically.andP;  Mechanical transitions (e.g., using programgenerators or compilers) can enhance productivity, but they depend on moreprecision and understanding than are often available.andM;(6) Overall, the number of levels has grown and shrunk with technology overtime.andP;  For example, today few people actually code in machine language, andrelatively few program in assembly code.andM;(7) The classic reference is to the software engineering workshop sponsoredby the NATO Science Committee in Garmisch, West Germany, Oct. 7-11, 1968.andM;(8) In gross terms, software engineering is concerned with the practicalaspects of developing software, such as design under various constraints andeconomic delivery of software products.andP;  It overlaps all of the variousspecialties of software research, including programming languages, operatingsystems, algorithms, data structures, data bases, and file systems, and italso addresses such cross-cutting qualities as reliability, security, andefficiency.andM;(9) Thus it could provide a foundation for exploration of user-programmableapplication generators, which may be appropriate for smaller systems.andM;REFERENCESandM;[1.] Ad Hoc Committee on the High Cost and Risk of Mission-Critical Software.andO;Report of the USAF Scientific Advisory Board Ad Hoc Committee on the HighCost and Risk of Mission-Critical Software, US Air Force Scientific AdvisoryBoard, Dec. 1983.andM;[2.] Association for Computing Machinery.andP;  Proceedings of Conference onComputer-Supported Cooperative Work (Sept.andP;  26-28, 1988, Portland, Ore.).andO;ACM, N.Y.andM;[3.] Balzer, R. A 15 Year Perspective on Automatic Programming.andP;  IEEETransactions on Software Engineering 11, 11 (1985), 1257-1268.andM;[4.] Belady, L. Software is the glue in large systems.andP;  IEEE CommunicationsMagazine, Aug. 1989.andM;[5.] Belady, L., and Lehman, M. Program Evolution Processes of SoftwareChange.andP;  1985.andP;  Academic Press Ltd., London, UK.andM;[6.] Bernstein, L., and Yuhas, C.andP;  The chain of command.andP;  UNIX Review, Nov.andO;1987.andM;[7.] Besemer, D.J., et al.andP;  A Synergy of Industrial and Academic Education.andO;Technical Information Series, General Electric Corporate Research andDevelopment, Schenectady, N.Y., (Aug.andP;  1986).andM;[8.] Biggerstaff, T., and Perlis, A.andP;  Software Reusability: Concepts andModels 1 and Software Reusability: Applications and Experience 2.andP;  AddisonWesley/ACM Press Frontiers in Science, N.Y.andM;[9.] Boehm, B.W.andP;  Software Engineering Economics.andP;  1981.andP;  Prentice-Hall,Englewood Cliffs, N.J.andM;[10.] Boehm, B.W.andP;  A spiral model of software development and maintenance.andO;IEEE Computer 21, 5 (May 1988), 61-72.andM;[11.] Booch, G.andP;  Software Components with Ada.andP;  1987.andP;  Benjamin/CummingsPublishing, Menlo Park, Calif., 571.andM;[12.] Bowen, T., Wigle, G., and Tsai, J.andP;  Specification of Software QualityAttributes.andP;  RADC-TR-85-37, 1, Rome Air Development Center, 1985.andM;[13.] Brooks, F.P.andP;  No silver bullet -- Essence and accidents of softwareengineering.andP;  IFIP's Information Processing 86, H.J.andP;  Kugler (ed.), 1986Elsevier Science Publishers B.V.andP;  (North-Holland).andM;[14.] Cleaveland, J.C.andP;  Building application generators.andP;  IEEE Software, July25, 33, 1988.andM;[15.] Cody, W.J., and Waite, W.M.andP;  Software Manual for the ElementaryFunctions.andP;  Prentice-Hall, Englewood Cliffs, N.J., 1980, 269.andM;[16.] Computer Science and Technology Board, National Research Council.andO;Toward a National Research Network.andP;  National Academy Press, Washington,D.C., 1988.andM;[17.] Curtis, B., Krasner, H., and Iscoe, N.andP;  A Field Study of the SoftwareDesign Process.andP;  Commun.andP;  ACM 31 11 (Nov.andP;  1988), 1268-1287.andM;[18.] Defense Science Board Task Force on Military Software.andP;  Report of theDefense Science Board Task Force on Military Software, Office of the UnderSecretary of Defense for Acquisition, Sept. 1987.andM;[19.] Freeman, P.andP;  A conceptual analysis of the draco approach toconstructing software systems.andP;  IEEE Transactions on Software Engineering(July 1987), 830-844.andM;[20.] Guindon, R. (ed.).andP;  Cognitive Science and Its Applications forHuman-Computer Interaction.andP;  Lawrence Erlbaum Assoc., Hillsdale, N.J., 1988.andM;[21.] Knuth, D. The Art of Computer Programming.andP;  Addison-Wesley Series inComputer Science and Information Processing 2 (1973).andP;  Addison-Wesley,Reading, Mass.andM;[22.] Martin, R.J., and Osborne, W.M.andP;  Guidance on software maintenance.andP;  NBSSpecial Publication 500-106.andP;  Computer Science and Technology, U.S.andP;  Dept.andO;of Commerce, National Bureau of Standards, Washington, D.C., Dec. 1983, p. 6.andM;[23.] McCabe, T.andP;  Complexity Measure.andP;  IEEE Trans.andP;  on Software Eng., 2, 4,308-320.andM;[24.] Microelectronics and Computer Technology Corporation, ConferenceCommittee for CSCW '86.andP;  Proceedings of Conference on Computer-SupportedCooperative Work (December 3-5, 1986, Austin, Tex.).andP;  MCC.andM;[25.] Mills, H.D.andP;  Benefits of Rigorous Methods of Software Engineering inDoD Software Acquisitions, Feb. 1989.andM;[26.] Mosemann, L.K.andP;  Software Engineering and Beyond: The People Problem.andO;Keynote address at the SEI Affiliates Symposium, Software EngineeringInstitute, Carnegie Mellon Univ., (May 2-4, 1989, Pittsburgh, Pa.).andM;[27.] Neighbors, J.M.andP;  The draco approach to constructing software fromreusable components.&quot;andP;  IEEE Trans.andP;  on Software Engineering 10, 5 (1984),564-573.andM;[28.] Partsch, H. and Steinbruggen, R.andP;  Program transformation systems.andP;  ACMComputing Surveys 15, 3 (1983), 199-236.andM;[29.] Perry, R.H., et al.andP;  Perry's Chemical Engineers' Handbook, (1984).andO;McGraw Hill, N.Y., 1984.andM;[30.] Royce, W.andP;  Managing the development of large software systems.andO;Proceedings WESCON, (August 1970).andM;[31.] Shaw, M.andP;  Beyond programming-in-the-large: The next challenges forsoftware engineering.andP;  Technical Memorandum SEI-86-TM-6, Software EngineeringInstitute, Carnegie Mellon Univ., Pittsburgh, Pa., May 1986.andM;[32.] Shaw, M.andP;  Larger scale systems require higher-level abstractions.andO;Proceedings of the Fifth International Workshop on Software Specification andDesign, (May 19-20, 1989, Pittsburgh, Pa.).andP;  ACM, N.Y.andM;[33.] Smith, D., Kotik, G., and Westfold, S.andP;  Research on knowledge-basedsoftware environments at Kestrel Institute.andP;  IEEE Trans.andP;  on SoftwareEngineering 11, 11 (1985), 1278-1295.andM;[34.] Swanson, E.B., and Lientz, B.andP;  Software Maintenance Management: A Studyof the Maintenance of Computer Application Software in 487 Data ProcessingOrganizations.andP;  1980.andP;  Addison-Wesley, Reading, Mass.andM;[35.] Williams, B.G., Mui, C.K., Johnson, B.B., and Alagappan, V. Softwaredesign issues: A very large information systems perspective.andP;  Center forStrategic Technology Research, Arthur Andersen andamp; Co., Chicago, Sept. 28,1988.andO;</TEXT></DOC>