<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-060-792  </DOCNO><DOCID>07 060 792.andM;</DOCID><JOURNAL>Data Based Advisor  Jan 1989 v7 n1 p12(3)* Full Text COPYRIGHT Data Based Solutions 1989.andM;</JOURNAL><TITLE>Too much of a good thing: exploring SQL.andO;</TITLE><AUTHOR>Finkelstein, Rich.andM;</AUTHOR><SUMMARY>SQL enables users and programmers to formulate a query in severaldifferent ways, but chances of making an error increase because ofall the alternatives.andP;  Examples of common mistakes are presented.andO;SQL's built-in redundancy is the cause of many problems: itperforms differently in different vendors' products.andP;  Performanceresults of SQL statements vary among hardware platforms and amongnatural language interfaces.andM;</SUMMARY><DESCRIPT>Topic:     Structured Query LanguagePerformanceRedundancyEnd UsersProgramming.andM;</DESCRIPT><TEXT>Too Much of a Good ThingandM;Let's use November's article on relational intersection and difference as anexample.andP;  In the article I gave several variations of the same query.andP;  Somevariations are easier to understand than others.andP;  Some perform better thanothers.andP;  Some are easier to verify than others.andP;  If you want to use theintersection and difference operations, not only must you understand theirpuposes, but you also must build the right query.andP;  The chances of making anerror increase when you have many choices.andP;  For example, you might choose touse a subquery for the intersection or to use an equijoin instead.andP;  Or youmight be bold enugh to use the correlated subquery using the EXISTS operator.andM;Where the trouble beginsandM;As it turns out, I made some errors in my last article.andP;  I received severalcalls pointing out problems with my SQL statements, and I want to thankeveryone who called.andP;  You can easily catch these errors in practice, butthey're good examples of what happens when using unfamiliar SQL formulationswithout verifying them.andP;  In one example, I used the following SQL equijoinstatement to perform an intersection: SELECT EMP_NAME FROM EMPLOYEE, SKILLSWHERE EMPLOYEE.EMP_NO = SKILLS.EMP_NO;andM;This query correctly finds all the employees that exist in both the EMPLOYEEand SKILLS tables.andP;  Since there are probably many skills for a particularemployee, the result will include multiple occurrences of EMP_NAME.andP;  A betterquery would be: SELECT DISTINCT EMP_NAME FROM EMPLOYEE, SKILLS WHEREEMPLOYEE.EMP_NO = SKILLS.EMP_NO;andM;DISTINCT eliminates all duplicates in the result table.andP;  You then get thesamre results as the following query: SELECT EMP_NO FROM EMPLOYEE WHEREEMP_NO IN (SELECT EMP_NO FROM SKILLS);andM;This query is much easier to understand, and the one I would normally use forintersection.andM;Then I used an unequal join to demonstrate a different way of executing thedifference operation.andP;  This was entirely wrong.andP;  Had I inspected or testedthe query, I wuold have realized that an unequal join between the EMPLOYEEand SKILLs tables returns a cross product of unequal rows and not therelational difference.andP;  You can get the difference correctly by using thefollowing subquery: SELECT EMP_NO FROM EMPLOYEE WHERE EMP_NO NOT IN (SELECTEMP_NO FROM SKILLS);andM;Again, this is easy to understand and verify (and the way I typically expressthe relational difference).andM;Finally, I used a correlated subquery using EXISTS to represent theintersection: SELECT EMP_NAME FROM EMPLOYEE WHERE EMP_NO EXISTS (SELECTEMP_NO FROM SKILLS WHERE SKILLS.EMP_NO = EMPLOYEE.EMP_NO);andM;The WHERE clause in the third line has EMP_NO before EXISTS.andP;  SQL doesn'tallow this, and it makes no logical sense.andP;  EXISTS tests whether the subqueryreturns a row (true or false condition).andP;  If it does, SQL executes the queryassociated with the EXISTS.andP;  The SQL syntax checker detects this error andrejects the query.andP;  In this case it was my error.andP;  Curiosly I find that manySQL users commonly make this mistake.andP;  People just beginning to use SQL havea difficult time distiguishing EXISTS from In and NOT EXISTS from NOT IN.andP;  Mystudent often get confused, especially since it's not easy to come up withgood examples for EXISTS.andP;  The correct intersection query is: SELECT EMP_NAMEFROM EMPLOYEE WHERE EXISTS (SELECT EMP_NO FROM SKILLS WHERE SKILLS.EMP_NO =EMPLOYEE.EMP_NO);andM;The simplest way to formualte the relational intersection and differenceoperations is with subqueries using the IN and NOT IN operators.andP;  IBM iscoming to the rescue with the INTERSECTION and EXCEPT operators (in the nextversion of OS/i Extended Edition).andP;  INTERSECTION and EXCEPT are non-standard,and therefore missing in other SQL implementations.andP;  But they don't eliminatethe inherent confusion surrounding SQL constructs such as joins, subqueriresand correlated subqueries.andM;Other problemsandM;SQL redundancy causes other problems.andP;  You'll find that one formulation mightperform better than another.andP;  In my intersection examples, you can use anequijoin or a subquery.andP;  Many SQL products optimize various subqueries.andP;  Forexample, IBM's mainframe SQL products DB2 and SQL/DS use different optimizersthat yield different performance depending on the query.andP;  At one time, IBMrecommended using equijoins on DB2 and subqueries on SQL/DS.andP;  Each newversion of DB2 and SQL/DS brings new optimizers with it, changing applicationperformance.andP;  This forces programmers and users to learn different techniquesand to charge SQL statements depending on the RDBMS they're using.andM;Other SQL implementations have the same problems.andP;  Some are highly tuned forequijoins while others work nicely on subqueries.andP;  Vendors strive to achieveconsistent performance for all cases but it's difficult.andP;  Ingres in oneproduct that does an admirable job of treating all forms of a query equally.andM;When you write queries for a particular optimizer, you lose dataindependence.andP;  You should not have to know what the intricacies of anoptimizer are, but SQL redundancy forces you to.andP;  You not only have to spendmore time understanding the optimizer, but you have to maintain  yourknowledge as the optimizer changes.andP;  If you work with several SQL products,you have to understand the strengths and weaknesses of them all.andP;  In oneproduct the subquery may work better and in another product the equijoin maywork better.andP;  This can change over time.andP;  To maximize performance, you mayhave to write your queries differently for each product.andM;The portability questionandM;What about portability?andP;  You have write an SQL statement for one hardwareplatform, then execute it on another and get completely different performanceresults.andP;  End users and programmers aren't the only ones who have problemswith this.andP;  It also aggravates vendors who want to support multiple databaseservers.andM;Database servers are becoming more popular, and vendors are buildingsophisticated user tools for them.andP;  Tools for database servers run the gamutfrom spreadsheets to highly productive object oriented development programs.andO;Each may generate SQL statements that retrieve and update databaseinformation on the server.andM;Products such as Paradox and DataEase will act as front end tools forMicrosoft's SQL Server and IBM's OS/2 Extended Edition.andP;  Both products havevisual query interfaces that let users retrieve information by example.andP;  Eachproduct will translate the query-by-example into equivalent SQL commands.andO;But there's a hitch.andP;  What SQL command should they generate?andP;  When you haveredundancy, any given query-by-example can be translted into different SQLstatements.andP;   The results will be the same, but one may perform much betterthan the others.andM;Vendors must choose between tuning their translator for each database serveror simplifying the interface process by generating one common SQL command forall servers.andP;  Borland and DataEase will not only want to access microdatabase servers but also mini and mainframe servers-making the problem evenmore complex.andP;  This directly affects users, since greater complexity requiresmore time to get the products to market.andP;  Users are also dependent on vendorsfor finding the optimal queries on each server.andP;  Without redundancy, frontend vendors such as Borland and DataEase would only have to consider onepossibility, and database server vendors would only have to optimize one formof the query.andP;  As it stands, the possibilities are almost endless.andM;Natural languageandM;Natural language interfaces are also becoming more popular.andP;  NaturalLanguage, Inc. has a product called Natural Language that allows users to useEnglish commands to access a variety of SQL databases including Ingres,Sybase and Oracle.andP;  Every English command must be translated to SQL.andP;  EachSQL product supports its own SQL dialect.andP;  Sybase doesn't support the UNIONoperatow while Ingres does.andP;  Sybase supports NULL values while Ingresdoesn't.andP;  In order for the natural language front end to work, it must knowthe differences in the dialects.andP;  For it to work very well, it must alsounderstand the SQL optimizer for each product.andP;  It must know when to generatea subquery or when to generate a join.andP;  This varies with each product.andP;  Usershave no control over which variation is generated, so its particularlyimportant for natural language products to be aware of the optimizer'sidiosyncrasies.andM;IBM helps out its mainframe programmers by including an EXPLAIN operator inDB2 and SQL/DS.andP;  EXPLAIN tells the programmers which indexes DB2 will use foreach SQL statement and how DB2 will retrieve the data.andP;  Programmers can useEXPLAIN to determine which SQL query will perform best when there's more thanone choice.andP;  This defeats the purpose of the optimizer, since programmersshould be insulated from the physical and logical structure of the database.andO;Queries should not be dependent on the quality of the optimizer but, as I'vementioned, they're very dependent.andP;   Currently, no micro SQL product offersan EXPLAIN facility, but I suspect future releases of SQL database serverswill include some feedback mechanism.andP;  In the meantime we'll have to rely onexperimentation and vendors for information on choosing the right form of SQLquery.andM;Dr.andP;  Codd, the mastermind behind relational database theory, has, for manyyears, fought against SQL's built-in redundancy.andP;  He realized that redundancywould cause users and vendors endless problems that would come back to hauntthem.andP;  His warnings went unheeded.andP;  Now we have to learn to live with thisproblem, since it's inherent in SQL.andP;  In time, vendors will get better atoptimizing queries, and SQL's redundancy will become less significant.andO;</TEXT></DOC>