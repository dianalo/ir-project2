<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF109-424-157  </DOCNO><DOCID>09 424 157.andM;</DOCID><JOURNAL>UNIX Review  Sept 1990 v8 n9 p58(6)* Full Text COPYRIGHT Miller Freeman Publications 1990.andM;</JOURNAL><TITLE>Applications in time and space. (real-time Unix)</TITLE><AUTHOR>Tomayko, James.andM;</AUTHOR><SUMMARY>Spacecraft operated by real-time systems are examined for thelessons learned in regard to real-time application-software designproblems.andP;  Key problems in designing real-time software includetime constraints, data loss caused by sampling delay, and the needto ensure reliability with redundant code and back-up systems.andO;Operating-system and language solutions range from asynchronousparity interrupts to rate-monotonic scheduling, which is based onthe theory that a set of independent tasks will always meetdeadlines if the proper conditions are met at execution time andspecific scheduling order is achieved.andM;</SUMMARY><DESCRIPT>Topic:     UNIXReal-Time SystemsSpace CraftApplications ProgrammingProgramming InstructionSpace Exploration.andO;Feature:   illustrationchart.andO;Caption:   The space-shuttle orbiter's data-processing system. (chart)The software architecture of the Galileo spacecraft. (chart)andM;</DESCRIPT><TEXT>Real-time application-software design is beset by problems over and abovethose found in conventional aPPlication design.andP;  To examine these problemsand some approaches to addressing them, we turn our sights to the skies,where spacecraft operated by real-time systems have taught us many lessons.andM;As the NASA space shuttle thunders into orbit with solid-propellant boostersand liquid-propellant main engines firing away, a complex series ofactivities is taking place inside the vehicle.andP;  Sensors measure and reportacceleration and changes in attitude.andP;  The main-engine controllers monitorand adjust fuel flow.andP;  The flight-control software orders engine nozzles togimbal and control surfaces to move.andM;So much is happening in the aero-spacecraft so quickly that humans ormechanical devices alone would find it very difficult to control; the job canbe accomplished only with the use of digital computers, operating in realtime.andP;  However, the use of machines itself presents a number ofcomputer-hardware and -software problems-the same ones faced by any real-timesystem, be it the banking software that controls automatic teller machines, anavigation system used in commercial aircraft, or the controllers on yourautomobile's engine.andP;  What distinguishes these systems is the response timeand reliability required of each; these two characteristics are the mainforces behind application-software design for real-time systems.andM;Key Problems in Designing Real-Time Software.andP;  The operative word in thephrase &quot;real time&quot; is &quot;time&quot;.andP;  With the processing power available today,most computers have less demanding performance requirements, relative toreal-time systems.andP;  I would be annoyed, for example, if my word processortook a &quot;noticeable&quot; amount of time to echo a typed character; but forreal-time systems, performance requirements are the true measure of thesoftware.andP;  If the software cannot do what is needed i the time available, itis useless.andP;  Software engineers building real-time systems must make certainthat the software is able to run at the same frequency the job requires.andM;For example, digital controllers are in use on the space shuttle's mainengines, on newer turbojet engines, and on standard automobile engines.andP;  Allof these engine types depend on the combustion of volatile fuels to generateenergy.andP;  The shuttle engines have the most powerful fuels and the leastresistance to failure.andP;  While a bad air-fuel mixture in aninternal-combustion engine will most likely cause combustion to choke off, asimilar error in the shuttle is likely to cause catastrophic destruction ofthe engine and the remainder of the spacecraft.andM;The shuttle engines can be run at a seemingly ridiculous 109 percent of ratedthrust.andP;  They operate as close to the point of self-destruction as possiblein order to obtain this enhanced level of performance.andP;  Consequently, thesampling interval and processing time of the engine-controller software mustbe kept short; sensor data can never be ignored until a later software cycle.andM;Toleration of loss of data due to sampling delay is another consideration forreal-time programmers.andP;  For a ground-based radar that tracks airliners movingat a relatively slow 500 knots, a few seconds between data samples is notcritical; when a jet fighter's radar tracks an enemy missile whose closingspeed-combined with the speed of the fighter-is five or six times the speedof sound, such increments of time can be of life-and-death significance.andO;However, configuring a system to accept this data as input withoutoverloading the capability of the processor is difficult.andP;  In some cases,data can be placed directly into memory, eliminating the need for the CPU topass it through.andP;  In other cases, it will cause an interrupt that will needservicing.andM;One example of the latter case is the real-time system that controlled theApollo lunar landers.andP;  During the spacecraft's descent to the moon's surface,a processor that was part of the primary guidance and navigation system ranseveral programs in a 20-millisecond cycle.andP;  Servicing certaincounter-interrupts-some of which were sent by the rendezvous radar helpingthe lander rejoin the command module-had a very high priority.andP;  When such aninterrupt was signaled to the executive software, it would suspend thecurrent job, handle the counter-increment, and resume the suspended program.andM;However, as Apollo 11 was making its first attempt to land on the moon,interrupts from the rendezvous radar caused so many pauses in the processingthat some of the programs due to execute within the 20-millisecond cycle werenot completed.andP;  The executive program would re-start the entire system, andthe situation would soon repeat.andP;  This caused several tense moments both inthe spacecraft and at mission control, but fortunately some of the missioncontrollers specializing in the computer system had seen a similar situationin simulations and allowed the descent to continue.andM;Clearly, obtaining and retaining much-needed data while completing processingtasks in time requires a balancing act.andP;  Application programmers ensuringthat their software completes processing within a specified interval musttake into account the structure of the executive and its schedulingalgorithms.andP;  They must also know how much data loss is tolerable in caseswhere there simply isn't time to look at everything that comes in.andM;Standing equal with the need to process data in time is the requirement thatthe system not fail.andP;  If the shuttle's orbiter loses its digital systemsduring descent, the spacecraft reverts to the status of any other oddlyshaped meteor.andP;  There is simply no mechanical backup system.andP;  There are,though, two common methods of ensuring reliability: redundancy that retainsfull capability, and the use of alternate backups, usually of lessercapability than the primary system.andM;The shuttle's data-processing system, for example, must be fault-tolerantthrough multiple failures.andP;  The redundant part of the system consists of fouridentical processors running identical software.andP;  The loss of any individualprocessor is tolerated because any one processor can do the entire job.andP;  Inaddition, a fifth processor, originally intended to be part of the redundantset, contains backup flight-system software.andP;  This software can only fly thespacecraft to orbit and return it to earth; it cannot do any in-orbitoperations or complete a mission.andP;  The Apollo's lunar landers also had asmall processor dedicated to aborting a mission to lunar orbit.andP;  Unlike theshuttle backup, which only has different software, this processor wascompletely different in construction.andM;These deep layers of redundancy are not always necessary.andP;  Most earth-basedsystems operating in real time follow the single-redundancy rule, primarilybecause anything more elaborate is prohibitively expensive.andP;  Nowadays,hardware fails relatively infrequently.andP;  However, software failures in trulyredundant systems have one potentially dangerous characteristic: if they aretruly generic errors, then switching to the backup redundant system solvesnothing, as it, too, can fail for the same reason.andM;Fortunately, this does not happen often.andP;  The combination of incoming data isoften unpredictable, changing drastically from millisecond to millisecond.andO;Therefore, we can apply the basis of chaos theory&quot;sensitive dependence oninitial conditions&quot;-and see that it is highly unlikely that the set ofcircumstances that cause a given software error to appear will ever berepeated.andP;  This is what causes fits in people responsible for real-timequality assurance, and is a reason why magnetic tapes full of telemetereddata are collected from space flights, so that failures can be simulated andanalyzed after the fact.andM;A preemptive method of preventing generic errors is often called  &quot;n-versionprogramming&quot;.andP;  The theory is that if n different programming teams producesoftware from the same set of requirements, the n software packages will bedifferent, in that no two programming teams will make the same mistakes.andO;There is still an expectation that each will make some mistakes, but if thebackup processor is made the primary processor, it should recover from thecausative error.andP;  Recently this theory has been challenged, as research showsthat different teams make more of the same errors than intuition would leadone to believe.andP;  Apparently, equally ambiguous requirements documents lead toequally buggy software !andP;  Regardless of whether a system's reliability isensured by backups or redundancy, there remains the task of synchronizing theprocessors so that a smooth transition to secondary subsystems can be made incase of failure.andP;  Also, synchronization is required to detect failures ofredundant processors in the first place.andM;Figure 1 shows the shuttle's five general-purpose computers, four of whichform a &quot;redundant set&quot; of processors, with the backup completing the &quot;commonset&quot;.andP;  The shuttle-system designers thought that by comparing a cheeksum ofthe central processors' registers in the redundant set every fewmilliseconds, a failing processor could be detected by its &quot;answers&quot;differing from the other &quot;good&quot; processors.andP;  Anyone who knows anything aboutoscillators would not be surprised to learn that the checksums quickly becameout of sync with one another because the computers were operating at slightlydifferent speeds.andP;  There was no way to ensure that the clocks would remainperfectly aligned.andM;The solution was to cause a software pause after every input, output, andcontext switch.andP;  When one of these three actions is executed, a three-bitmessage is sent along the intercomputer communication bus by each computer tothe other computers.andP;  If one computer detects a miscompare, or if 4milliseconds have gone by without a message, the computer that has been wrongor late is revealed to the crew, and the detecting computer refuses to acceptany more data from it.andM;The idea is that the crew, seeing three computers in the redundant setpointing to the failed computer, and the failed computer pointing to theother three, will manually disengage the failed computer.andP;  If multiplefailures occur or the situation becomes confusing, the crew can disengage theentire redundant set.andP;  The backup, which has been receiving data all along,is able to take over without a hitch, flying the spacecraft either into orbitor to the ground.andM;The use of redundancy, backups, and the associated redundancy-management andsynchronization software is costly.andP;  Reliability in most real-time systemsstill has to be &quot;bought&quot;.andP;  There is considerable work in progress, especiallyin the avionics world, to achieve fault tolerance through dynamicreconfiguration of software on multiple distributed processors.andP;  This isprimarily a software-based solution, which brings attendant space, power, andweight benefits.andP;  On the other hand, it incurs its own set of problems onwhich we won't elaborate here.andP;  Rather, we will discuss some solutions toreal-time application design.andM;Operating-System and Language Solutions for Real-Time Systems.andP;  It is nearlyimpossible to write application programs for real-time systems without someknowledge of the attendant executive and the scheduling algorithms in place.andO;Scheduling models are discussed in detail in another article in this issue ofUNIX REVIEW (see &quot;Scheduling in Real Time&quot;, page 48), but it will be usefulhere to summarize the advantages and disadvantages of cyclic andpriority-driven executives.andM;The cyclic executive is dependent on hard-timer interrupts at frequent andregular intervals such as 20 milliseconds (a favorite time among developersof simulators and flight controllers).andP;  Proponents of the cyclic executivepoint to the fact that key processes are rarely starved and that it is easierto set up fault-tolerance and redundancy management, given the predictabilityof the cycle length.andP;  Highly reliable real-time systems with cyclicexecutives run self-test diagnostics at the beginning of each cycle, thenproceed to clusters of high priority or high frequency, and later tolow-priority or low-frequency tasks.andP;  Cyclic executives may be nested toproduce multiple cycles.andP;  The chief tasks for the application programmer in acyclic environment are to make certain that mistakes, but if the backupprocessor is made the primary processor, it should recover from the causativeerror.andP;  Recently this theory has been challenged, as research shows thatdifferent teams make more of the same errors than intuition would lead one tobelieve.andP;  Apparently, equally ambiguous requirements documents lead toequally buggy software !andP;  Regardless of whether a system's reliability isensured by backups or redundancy, there remains the task of synchronizing theprocessors so that a smooth transition to secondary subsystems can be made incase of failure.andP;  Also, synchronization is required to detect failures ofredundant processors in the first place.andM;Figure 1 shows the shuttle's five general-purpose computers, four of whichform a &quot;redundant set&quot; of processors, with the backup completing the &quot;commonset&quot;.andP;  The shuttle-system designers thought that by comparing a checksum ofthe central processors' registers in the redundant set every fewmilliseconds, a failing processor could be detected by its &quot;answers&quot;differing from the other &quot;good&quot; processors.andP;  Anyone who knows anything aboutoscillators would not be surprised to learn that the checksums quickly becameout of sync with one another because the computers were operating at slightlydifferent speeds.andP;  There was no way to ensure that the clocks would remainperfectly aligned.andM;The solution was to cause a software pause after every input, output, andcontext switch.andP;  When one of these three actions is executed, a three-bitmessage is sent along the intercomputer communication bus by each computer tothe other computers.andP;  If one computer detects a miscompare, or if 4milliseconds have gone by without a message, the computer that has been wrongor late is revealed to the crew, and the detecting computer refuses to acceptany more data from it.andM;The idea is that the crew, seeing three computers in the redundant setpointing to the failed computer, and the failed computer pointing to theother three, will manually disengage the failed computer.andP;  If multiplefailures occur or the situation becomes confusing, the crew can disengage theentire redundant set.andP;  The backup, which has been receiving data all along,is able to take over without a hitch, flying the spacecraft either into orbitor to the ground.andM;The use of redundancy, backups, and the associated redundancy-management andsynchronization software is costly.andP;  Reliability in most real-time systemsstill has to be &quot;bought&quot;.andP;  There is considerable work in progress, especiallyin the avionics world, to achieve fault tolerance through dynamicreconfiguration of software on multiple distributed processors.andP;  This isprimarily a software-based solution, which brings attendant space, power, andweight benefits.andP;  On the other hand, it incurs its own set of problems onwhich we won't elaborate here.andP;  Rather, we will discuss some solutions toreal-time application design.andM;Operating-System and Language Solutions for Real-Time System.andP;  It is nearlyimpossible to write application programs for real-time systems without someknowledge of the attendant executive and the scheduling algorithms in place.andO;Scheduling models are discussed in detail in another article in this issue ofUNIX REVIEW (see &quot;Scheduling in Real Time&quot;, page 48), but it will be usefulhere to summarize the advantages and disadvantages of cyclic andpriority-driven executives.andM;The cyclic executive is dependent on hard-timer interrupts at frequent andregular intervals such as 20 milliseconds (a favorite time among developersof simulators and flight controllers).andP;  Proponents of the cyclic executivepoint to the fact that key processes are rarely starved and that it is easierto set up fault-tolerance and redundancy management, given the predictabilityof the cycle length.andP;  Highly reliable real-time systems with cyclicexecutives run self-test diagnostics at the beginning of each cycle, thenproceed to clusters of high priority or high frequency, and later tolow-priority or low-frequency tasks.andP;  Cyclic executives may be nested toproduce multiple cycles.andP;  The chief tasks for the application programmer in acyclic environment are to make certain that accumulated critical tasks willnever exceed the time interval, and to make provision for non-critical tasks.andM;As an example of these concepts, on the Galileo spacecraft now flying toJupiter, the Command and Data Subsystem uses a two-layer cyclic scheme: a&quot;foreground&quot; cycle running self tests, operating the bus controller, andreading the system clock 15 times per second; and a &quot;background cycle&quot;running every 2/3 of a second (see Figure 2).andP;  The background cycle containsboth &quot;privileged&quot; and &quot;non-privileged&quot; jobs.andP;  The major difference betweenthe two is that privileged jobs are always allowed to complete, whereasnon-privileged jobs can be canceled if they are not completed within the2/3-of-a-second interval.andM;The fault-protection and executive software dominates the privileged joblist, while the spacecraft command-sequences are non-privileged.andP;  One of thereasons for this separation is that the privileged software will generallyrun unchanged throughout the many years of the mission, and has already beensubject to extensive pre-flight testing.andP;  Therefore, there is some confidencethat it will complete processing in each cycle, leaving sufficient time forthe system to run the non-privileged software.andP;  Since that software isconstantly being updated and uploaded to the spacecraft as the differentmission phases unfold, it is subject to less overall verification and mightgo off into infinite loops in the ether.andP;  It can be thrown out of the systemat the conclusion of 2/3 of a second, so that essential processes will notstarve.andM;The other form of executive is the asynchronous priority-interrupt system,under which the most &quot;needy&quot; job is always the one running.andP;  If several jobsare contending for central processor time, the one with the highest priorityruns until it is done or is blocked while waiting for a resource or somedata.andP;  The good news is that key processes are rarely starved or evendelayed.andP;  The bad news is that it is quite possible that some low-priorityjobs never run.andP;  This latter situation is usually attributable to failure onthe part of the application programmer to anticipate properly the balance ofprocessor loading and execution speed.andP;  Given the current state of the art(kindly speaking) of software-development tools for real-time systems, it isdifficult to accomplish proper loading without extensive simulation andtrial-and-error.andM;The shuttle orbiter's primary data-processing system handles asynchronousinterrupts within a cyclic outer shell.andP;  The active flight-control softwareruns on a 40-millisecond cycle, system-management tasks on a much longer960-millisecond cycle.andP;  If at the end of a cycle a process is still runningbecause of excessive I/O or frequent interrupts, it cancels the start of thenext cycle and finishes up.andP;  The principle is that all tasks will completeand that some idleness will be present in each cycle.andP;  However, when somecritical activities occur, the system will complete them, thus averting thesituation that happened during the firstandM;Apollo lunar landing.andM;As the number of real-time systems grew during the 1960s and  70s, languagetools appeared to assist application programmers in solving some of theproblems of real-time programming, and to take advantage of the schedulingschemes described above.andP;  Two of these languages are HAL/S and Ada.andM;HAL/S was specified by NASA late in the 1960s and adopted for use on theshuttle and in the Galileo attitude-control system computers.andP;  Referred toirreverently by some engineers as  flight PL/1&quot;, it has some cute&quot; features,such as the automatic listing of vector equations using superscripts andsubscripts (no mean feat on a line printer), and essential real-timestatements such as WAIT, SCHEDULE, PRIORITY, and TERMINATE.andP;  A block within aHAL program can contain a set of tasks that can be set up as a group.andP;  Forinstance, the Galileo attitude-control system has three frequency cycles,referred to as &quot;rate groups&quot;.andP;  Consider the following HAL/S fragment:andM;SCHEDULE R61 PRIORITY (12), REPEAT EVERY 6./90.;andM;SCHEDULE R62 PRIORITY (11), REPEAT EVERY 12./90.;andM;SCHEDULE RG3 PRIORITY (8), REPEAT EVERY 2./3.;andM;Rate Group 1  RG1) has the highest priority and the highest frequency,followed by RG2, and so on.andP;  A task block can be halted conditionally usingthe TERMINATE statement to watch for a designated interrupt or time.andP;  In thisway the cyclic principle can be implemented.andP;  In addition, the SCHEDULEstatement can be used to specify asynchronous interrup handling:andM;SCHEDULE ERRORO ON RUPTO PRIORITY (22)andM;This statement tells the executive to instantiate the ERRORO routine whenRUPTO occurs.andP;  Since priority 22 is higher than that of any other task in thethree cycles specified above, RUPTO will definitely result in ERRORO takingover the processing resources.andM;In contrast to the rather straightforward implementation of &quot;traditional&quot;real-time concepts in HAL/S, the Ada language is based on a different modelnot easily accepted by veteran real-time programmers.andP;  The model is builtaround communicating, sequential processes.andP;  Each Ada task executes until itis blocked while waiting for data from another task or until it is explicitlyterminated.andM;One gets the feeling that the original idea behind this language concept wasthat each task would have its own processor, thus preventing a situation inwhich a task could continue to be blocked even though one of its partners wasready for a rendezvous to exchange data.andP;  If multiple tasks were running on asingle processor, such a situation could occur.andP;  Ada has a pragma PRIORITYthat allows a primitive form of priority specification.andP;  Each task can begiven a priority.andP;  When several pairs of tasks are trying to rendezvous, thepair with the highest priority is the one in which one of the tasks has thehighest priority.andP;  This means that if a task of priority 10 is trying torendezvous with a task of priority 1, that particular rendezvous willdisplace a rendezvous of two tasks each with priority 5.andP;  This sort of&quot;priority inversion&quot;, in which a very low-rated task gets processingresources due to its association with a high-rated task, is particularlyunnerving to application programmers accustomed to more restrictive measures.andM;One way of avoiding the potential problems of pragma PRIORITY is simply notto use it, using Ada statements-such as SELECT-instead to implementsemaphores, measuring execution times carefully to ensure that all tasks willbe serviced in the selected interval.andP;  Certain key tasks can be programmed toaccept timer or other data interrupts and thus structure the network of thetasks in such a way that the resulting execution resembles the modelsdescribed here.andM;The use of rate-monotonic scheduling is also gaining support.andP;  This theorypostulates that a set of independent tasks will always meet deadlines ifcertain conditions of execution time and specific scheduling order are met.andM;The reason real-time application design remains difficult is that engineersare forced to pay attention to a multitude of factors not specific to thepiece of the system they are implementing individually.andP;  This violates theprinciples associated with modularization, such as information hiding.andP;  Theengineer has to consider the scheduling philosophy of the system and theinteractions with other modules in order to determine the time impact on theparticular application under construction.andM;It is keeping this &quot;big picture&quot; in mind that causes problems, for the samereason that trying to build a non-real-time application by taking themonolithic view has been discredited in software-engineering circles.andP;  Untiltools exist that integrate new applications into a system automatically, oruntil different scheduling paradigms are accepted, real-time applicationdesign will be one of the biggest programming challenges in computing.andM;Dr.andP;  James E. Tomayko is a senior computer scientist at the SoftwareEngineering Institute of Carnegie Mellon University.andP;  He teaches in theMaster of Software Engineering Program in the School of Computer Science atCMU.andP;  Prior to joining the SEI, he was an associate professor and director ofthe Software Engineering Program at Wichita State University, a program whichhe originated, designed, and implemented.andP;  He previously worked for NCR, andhas had consulting or contract-research affiliations with Mycro-Tek, KelthleyInstruments, Boeing Military Airplanes, General Electric, and NASA.andP;  He is anassociate editor of the Annals of the History of Computing and aDistinguished National Lecturer for the ACM.andP;  Tomayko received his doctoratefrom CMU in 1980.andO;</TEXT></DOC>