<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-238-554  </DOCNO><DOCID>08 238 554.andM;</DOCID><JOURNAL>Computer Language  March 1990 v7 n3 p53(9)* Full Text COPYRIGHT Miller Freeman Publications 1990.andM;</JOURNAL><TITLE>Recursive design. (bridging the gap between analysis and design)(tutorial)</TITLE><AUTHOR>Shlaer, Sally; Mellor, Stephen J.andM;</AUTHOR><SUMMARY>Recursive design is a method for handling the transition fromsystem analysis to system design in which the emphasis is based onproducing mappings that are uniformly and systematicallyapplicable to all elements of a problem.andP;  Mapping can be definedin terms of enumeration, which requires the listing of allcorrespondece between set members, or in terms of rules.andO;Recursive design can be broken down into six steps: identificationof domains and bridges, specification of application and servicedomains, specification of the architectural domain, specificationof the implementation domain, definition of the mappings for eachbridge, and application of the mappings.andP;  Advantages of recursivedesign include uniform quality and ease of system integration.andO;The differences between recursive design and structured design arediscussed.andM;</SUMMARY><DESCRIPT>Topic:     Programming InstructionTutorialRecursionProgram Development Techniques.andO;Feature:   illustrationtablechart.andO;Caption:   Design mapping by enumeration. (table)Design mapping by rules. (table)Domain chart for typical real-time system. (chart)andM;</DESCRIPT><TEXT>Recursive Design While systematic approaches to analysis (includingfunctional decomposition methods, [1,2] event-response techniques, [3,4] andobject-oriented analysis [5,6]) are well established, software developersstill face a major problem: how do you convert a set of analysis models intoa solid, uniform, coherent design?andM;Modern approaches to systems analysis focus largely on the particularapplication problem, as expressed by the system's eventual users.andP;  Theanalysis is expressed in terms of real-world entities such as trains,passenger stations, switches, and cargo shipments.andP;  However, to develop asoftware system design, the designer must also contend with computer scienceentities such as messages, mailboxes, tasks, and files -- the conceptualentities of the implementation language and operating system.andP;  To bridge thedistance between the application and the implementation, experienceddesigners often speak loosely of &quot;making a mapping&quot; between these veryseparate and distant worlds.andM;Recursive design is a method for handling the transition between analysis anddesign.andP;  In recursive design, the emphasis is on producing mappings that canbe applied to all the elements of the problem in a uniform and systematicmanner.andM;MappingsandM;Mathematically, a mapping between sets can be defined in two ways.andP;  Thefirst, enumeration, requires listing all correspondences between the setmembers.andP;  This is the idea behind a design mapping (Table 1).andM;Enumerated mappings provide the greatest flexibility since they supportirregular as well as regular mappings.andP;  However, making an enumerated mappingis a time-consuming and error-prone activity that grows with the problemsize.andP;  In addition, it can lead to a nonuniform design.andM;An alternative is to provide mapping rules, as in the mathematical mappingf(x) = sin 3x.andP;  Table 2 is an example of a design mapping done by rules.andM;Specifying a mapping by rules allows the mapping to be expressed veryeconomically and leads to uniform design.andP;  Often such mapping rules can beapplied mechanically and may therefore be suitable for automation.andM;To make any mapping, the source and target sets must be well-defined.andO;Because object-oriented analysis emphasizes strong definition of conceptualentities, we will use this method to define the elements participating indesign mappings.andM;Recursive design summaryandM;Recursive design is most readily understood in terms of six steps:andM;* Step 1: Identify domains and bridges.andP;  Separate subject matters (domains)that will make up the system are identified.andP;  A domain chart (Figure 1) isdeveloped to declare the domains and show where mappings must be developed.andM;* Step 2: Specify the application and service domains.andP;  Conceptual entitiesof the application and service domains are identified and their dynamicbehavior specified in some appropriate formalism.andP;  We will assume thatobject-oriented analysis is the formalism chosen.andM;* Step 3: Specify the architectural domain.andP;  Declare the policies that willbe used systemwide for managing data and control.andP;  Object-oriented analysisis also used for this step.andM;* Step 4: Specify implementation domains.andP;  The elements of the language andoperating system to be used must be specified, usually by supplyingappropriate reference manuals.andM;* Step 5: Define the mappings for each bridge.andP;  Develop mappings that specifyhow the application entities (such as trains and schedules) are to beconverted into service and architectural entities (tables, design objects,servers, and so on).andP;  Additional mappings are developed to convert thearchitectural entities into entities in the implementation domains (such astasks, procedures, and variables).andP;  Mappings are defined to bridge all thedomains as required on the domain chart.andM;* Step 6: Apply the mappings.andP;  The mappings are applied successively to thevarious domains.andP;  As a result of this step, the application design isexpressed in terms of the service and architectural entities (analysisobjects) and the design of the service and architecture is expressed inimplementation terms.andM;Domains and bridgesandM;A domain is a specific and separate subject that can be described in detail.andO;Current literature uses the phrase &quot;domain analysis&quot; and defines a domain asa subject matter [7] to be analyzed.andM;For the purposes of recursive design, think of each domain as an independentreal or abstract world populated by a separate set of conceptual entities orobjects.andP;  For example, a system used to control the operation of trains mighthave the domains shown in Table 3.andM;The output of the first step of recursive design is a domain chart (Figure1).andP;  Each domain is depicted as an oval, labeled with an appropriate name forthe domain and annotated with a few of the most prominent objects of thedomain.andP;  Directed connections between the domains (bridges) indicate that amapping should be constructed between the domains at a subsequent step andthat the higher (source) domain requires some kind of mechanism or supportfrom the lower (target) domain.andM;Domains don't know much about one another.andP;  Knowledge is usually asymmetricalin that the higher domain will probably know the lower domain exists and alittle about its subject matter.andP;  The application will know an alarm domainexists, and that alarm specification (the text used to tell the operatorabout a certain kind of problem whenever it occurs) and alarm incident (thespecific occurrence of a problem at a specific time) are part of that domain.andM;However, the lower domain won't know the subject matter of the higher domain.andO;The Alrm domain knows how to manage alarm incidents and specifications butdoesn't need to know what kind of application is using it; it can work for achemical plant as well as for a train system.andP;  This domain has nounderstanding of the meaning of the alarms it manages.andM;Recursive design distinguishes between four kinds of domains:andM;* Application -- the specific subject matter that concerns the user.andO;Typically only one application domain (in our example, Train Control) exists,but it may be very large.andM;* Service -- service domains provide generic functions needed throughout theapplication.andP;  Examples are the Screen Management, Process Input/Output, andAlarm domains.andM;* Architecture -- the Architecture domain is concerned with systemwidepolicies for managing data and control.andP;  It provides support in these areasfor the application and service domains.andP;  The Architecture domain mightcontain a real-time database, an event manager, and a universal state machineprocessor.andM;* Implementation -- the implementation domains are the languages andoperating systems to be used for implementation.andM;This classification scheme establishes the general sequencing of the workthrough subsequent steps of the method.andM;Application and service domainsandM;The second step of recursive design is to specify the application and servicedomains.andP;  This step has standard analysis purposes: to understand the domainand how it works and to formalize and communicate that understanding in a waythat is useful for system building.andP;  In the context of recursive design, asecond purpose exists: to provide well-defined elements for the mappings.andM;The important questions about a domain are: What kind of conceptual entitiesinhabit the domain?andP;  How are those conceptual entities related to oneanother, both statically and dynamically?andP;  Answers are provided in the formof object-oriented analysis information models, state models, and processmodels.andP;  [5,6]andM;Although we use object-oriented analysis to specify the application andservice domains, we use this method with a different mindset depending on thecharacteristics of the domain.andP;  The application and Process Input/Outputdomains are analyzed by stating what the real world is like.andP;  The emphasis ison fact-finding and research.andM;Service domains to be implemented by purchased packages are also investigatedin a fact-finding mode, usually by studying the reference manuals for thesepackages.andP;  The goal is to identify the objects to which we can map.andM;Service domains to be built require a different approach.andP;  Here analyst stillhave to state what the objects are and how they relate to one another, butalso invent the objects.andP;  No fact-finding is involved.andP;  The emphasis is ondeveloping a consistent model that is appropriate and useful to the higherdomains.andM;Architectural domainandM;The architectural domain serves several purposes:andM;* It provides a statement about how data and control are to be organizedwithout referring to language- or operating system-dependent constructs andfeatures.andM;* It raises the level of the operating system and language, creatinghigher-order structures (such as tables, packets, and design objects) towhich the application and service domains may be more directly mapped.andM;* It provides a set of well-defined entities midway between the applicationand implementation domains, facilitating the mappings.andM;The third step of recursive design is to specify the architectural domain.andO;This is done using object-oriented analysis models describing the objects ofthe architecture and their dynamic behavior.andP;  The models should becomprehensive and answer the following questions about how the system is tobe constructed:andM;* How should the data be organized (logical organization)?andM;* How should the data be accessed?andM;* Will the data be encapsulated or de-encapsulated?andP;  If encapsulated, on whatbasis (with objects, with a single data server, with data servers based ongeographical distribution, and so on)?andM;* What are the major units of processing and how are they organized?andM;* How does a unit of processing know when to run?andM;* How is data consistency ensured?andM;The stronger and more complete the architectural rules, the easier the systemwill be to maintain and automate.andM;The most interesting aspect of this step involves the choice of architecture.andO;The following examples indicate the diversity of reasonable solutions (theobjects of each architecture are indicated by boldface type):andM;* Object-oriented design -- the major unit of processing is the object, whichis made up of methods (functions whose existence is known outside theobject).andP;  Data is encapsulated within the object and not directly accessiblefrom the outside.andP;  Objects are permitted to send messages to other objects;all objects are presumed to operate concurrently and asynchronously.andP;  In atypical object-oriented architecture, little is said about how the processingor data inside the object is to be organized; however, some strongerobject-oriented architectures prescribe such matters.andP;  [8]  Data consistencywithin the object is the responsibility of the object, across many objects,it is the responsibility of the analysis.andM;* State machines with de-encapsulated tabular data -- in this architecture,the major unit of processing is the state machine.andP;  Numerous asynchronouslyoperating state machines are allowed, and they communicate via eventmessages, as in object-oriented analysis.andP;  The data is arranged in tables andplaced in a run-time database that is directly accessed by all state machinesas required.andP;  Data consistency is assured by the analysis.andM;* Fully synchronous de-encapsulated architecture -- this is a classicprocess-control architecture usually chosen for performance reasons.andP;  Thedata may be arranged in tables for convenience but is typically thought ofonly as data elements.andP;  The data elements are placed in a run-time data areathat can be directly accessed by kernel processes.andM;A few fundamental kernel processes are identified, typically a series likeRead Sensor Data, Convert Sensor Data to Engineering Units, Develop DerivedData, Check for Data Out of Range, and Output Corrections to Actuators.andP;  Eachkernel process incorporates a number of recipes appropriate to its purpose;for example, in the Convert Sensor Data to Engineering Units process, you'llprobably find a mask and shift recipe for extracting bit fields as well as afloat and do aX + b recipe for scaling analog values.andP;  The kernel processesare supplied with a task list consisting of recipe names, data elements toact as input to that recipe, and data elements to receive the output of therecipe.andP;  Upon receipt of a master trigger (either a clock or an externalsignal), the first kernel process is run to completion.andP;  Each subsequentkernel process is activated when the preceding process is complete.andM;To facilitate the work of architectural domain specification, we areformalizing a repertoire of known architectural solutions and guidelines forappropriate architecture selection.andP;  [9]andM;Implementation domainsandM;The purpose of the fourth step of recursive design is to identify theconceptual entities of both the operating system and language(s) to be usedin the implementation.andP;  These are usually satisfactorily defined throughexisting reference manuals; however, if you are building your ownimplementation software -- say a special-purpose operating system --object-oriented analysis provides a way to formalize the objects of thisdomain.andM;Defining the mappingsandM;Having defined all the analysis objects in the pertinent domains, we nowreturn to the domain chart.andP;  A mapping must be constructed for each bridge onthe chart.andM;A mapping tells which instances of which objects in the source domaincorrespond to which instances of which objects in the target domain.andP;  Interms of object-oriented analysis, to define a mapping you must construct newrelationships that bridge the domains and then explain how the instances inthe target domain will be generated from instances in the source domain.andM;This step of recursive design has two parts.andP;  The first is an informationmodel that shows the pertinent objects of both domains with the newrelationships required to bridge the domains.andP;  These relationships may beconstructed directly between the source and target domains or via anauxiliary domain -- that of the object-oriented analysis formalism itself.andM;The second output of this step prescribes how attribute values will bedeveloped in the target domain.andP;  The first output shows the structure of themapping, while the second provides the actual values.andM;While some bridges can be mapped simply by inserting correlation tablesbetween objects on the information models for the separate domains, othersare more problematic.andP;  Two kinds of construction may be required:andM;* The construction is likely to refer to elements of the object-orientedanalysis formalism (Event, Object, or Attribute objects) rather than toelements of the source domain.andM;* The types of some attributes in the target domain will be defined in amanner so general as to lose the types of the attributes in the correspondingsource domain.andP;  These constructions are characteristic of the semantic shiftthat occurs when you map between two domains.andM;Data values and mapping rulesandM;Suppose you have an architectural domain with objects Table, Column, and DataType (Figure 2).andP;  You want to map the information model structure of theapplication domain to these constructs.andP;  The structural aspect of the mappingis given by relationships Rw, Rx, Ry, and R.andP;  The required values can begenerated by the mapping rule in Listing 1.andM;A software developer can use the application information model and the rulein Listing 1 to generate the tables in the design.andP;  Alternatively, the rulecould be cast in a programming language to extract the object, attribute, anddomain names from the database of the CASE tool used to build the informationmodel.andM;Enumerated mappingandM;In application domains where emergency conditions are detected, an event willbe generated to signal the emergency condition.andP;  We would like to map theseevents as the appear on the object-oriented analysis  models to instances ofan alarm  specification object in an Alarm domain.andM;The required information model constructions that give the structural aspectof the mapping are shown in Figure 3.andP;  The required values are suppliedsimply by enumeration (Tables 4 and 5).andM;Code and mapping rulesandM;In Ada Letters, [8] Rick Hill produced mapping rules for bridging anobject-oriented design architectural domain and the Ada implementationdomain.andP;  These mapping rules produce the structure of the required objectcode and all of the common code associated with event queueing, selectedtransitions, reading and writing instance data, and so on.andP;  As a result ofHill's mappings, only the individual action routines need to be coded byhand.andM;Applying the mappingsandM;The purpose of the last step of recursive design is to generate the design ofeach domain in terms of the conceptual entities of lower domains.andP;  We firstget the application design expressed in the objects of the architecture andservice domains.andP;  This can be thought of as a preliminary design.andM;When the architecture is mapped to the implementation domain, its analysisobjects are expressed again in language- and operating system-dependententities.andP;  This continued pattern, in which the design (structure) of onedomain is expressed in terms of the analysis objects of the lower domains,leads to the name &quot;recursive design.&quot;andM;When all mappings are combined, we have the application and all other higherdomains mapped into the implementation units in a very uniform and systematicmanner.andP;  This corresponds to what is generally called detailed design.andM;ImplicationsandM;A number of advantages have been observed in projects using recursive designtechniques:andM;* The design has a very uniform quality because emphasis is placed onsystemwide rules via the architectural domain.andP;  This makes the system mucheasier to understand and maintain in a manner consistent with the originaldesign.andM;* System integration can be relatively trouble-free.andP;  In one recursive designproject--a real-time control system--exactly five bugs were found duringintegration; only two of these took as much as a day to repair.andP;  In anotherproject, performance problems were found during integration.andP;  It took lessthan a week to rework the design to incorporate auxiliary processors andobtain satisfactory performance.andM;* Much of the design process can be automated by clever use of readilyavailable toolsets such as UNIX.andM;* The method has special appeal for large projects in their it takes aboutthe same amount of effort to construct mappings for large or small systems.andO;Recursive design offers economy of scale and avoids the problem ofhandcrafting dozens or hundreds of objects, programs, or data structures.andM;However, some significant disadvantage exist:andM;* Because recursive design reduces the amount of production code that needsto be written by hand, it may not be easy to use in organizations that rewardprogrammers according to the  number of lines of code they produce.andM;* Recursive design is a very disciplined approach and may not fit well inorganizations that equate creativity and contribution with individualdecisions and lack of coordination.andM;Both problems can be partially offset by directing attention away fromproduction code and toward the code required to do the mappings.andM;Other design approachesandM;Recursive design is a method for producing the design and, in the best case,the code for a system in an orderly, automatable fashion.andP;  This approachemphasizes the system as a whole rather than the design of a single task orobject.andP;  Recursive design does not offer a single design notation but assertsthat specific design notations are required.andP;  For a notation to be useful, itmust represent the conceptual entities of a particular architectural,implementation, or other target domain.andM;By contrast, structured design [10] was developed to express the design of asingle program as opposed to a whole system.andP;  The conceptual entities ofstructural design are the module, the shared data area, and the couple.andO;While these entities are defined independently of any computer language, theyare easily mapped to implementation elements of languages like FORTRAN andCOBOL.andM;Structured design offers guidelines for translating certain kinds ofconnected data-flow diagrams to a design.andP;  This approach does not supportoperating system entities such as tasks (multitasking), event flags,mailboxes, messages, or language-specific ideas like rendezvous or data type.andO;In the context of recursive design, structured design can be used to show themapping from the architecture to the implementation domain of a traditionallanguage.andM;Ada structure graphs, also known as Buhr diagrams, [11] offer notation tosupport the conceptual entities of the Ada language.andP;  It is quite easy to mapfrom Ada structure graphs to the Ada language, but no guidance is offered onmapping or converting analysis models into appropriate Ada structure graphs,which work efficiently to represent design.andP;  We have used them in recursivedesign to make the mapping from the architecture domain to the Ada domain.andM;Object-oriented structured design [12] features a language-independentnotation using object-oriented concepts.andP;  Like structured design and Adastructure graphs, object-oriented structured design is oriented to thedetails in the implementation domain.andP;  Guidelines have not yet appeared forconverting analysis models into object-oriented structured design or mappingobject-oriented structured design constructs to particular implementationdomains.andP;  The latter appears to have a far easier solution; we would expectmost object-oriented developers to find it a straightforward task.andM;Booch diagrams [13] provide a language-independent notation for depictingcommunication and visibility between objects at a system level.andP;  We have useda close derivative of Booch diagrams in recursive design to make the mappingfrom the application domain to the domain of an object-oriented.andO;architecture.andM;ReferencesandM;[1] DeMarco, Tom.andP;  Structured Analysis and System Specification.andP;  New York,N.Y.: Yourdon Press, 1978.andM;[2] Hatley, Derek, and Imtiaz Pirbhai.andP;  Strategies for Real-Time SystemSpecification.andP;  New York, N.Y.: Dorset House, 1988.andM;[3] McMenamin, Stephen, and John Palmer.andP;  Essential Systems Analysis.andP;  NewYork, N.Y.: Yourdon Press, 1984.andM;[4] Ward, Paul, and Stephen J. Mellor.andP;  Structured Development for Real-TimeSystems, Vol.andP;  1.andP;  Englewood Cliffs, N.J.: Prentice-Hall, 1985.andM;[5] Shlaer, Sally, and Stephen J. Mellor.andP;  Object-Oriented Systems Analysis:Modeling the World in Data.andP;  Englewood Cliffs, N.J.: Prentice-Hall, 1988.andM;[6] Shlaer, Sally, and Stephen J. Mellor.andP;  &quot;An Object-Oriented Approach toDomain Analysis,&quot; Software Engineering Notes 14(1): July 1989.andM;[7] Bailin, Sidney C.andP;  &quot;An Object-Oriented Requirements SpecificationMethod,&quot; Communications of the ACM 32(5): May 1989.andM;[8] Hill, Rick.andP;  &quot;Object-Oriented Design in Ada: A Transformational ApproachBased on Object-Oriented Analysis,&quot; Ada Letters, ACM Press, 1990 (in press).andM;[9] Project Technology Inc. Real-Time Recursive Design (training course).andO;Berkeley, Calif., 1990 (in preparation).andM;[10] Page-Jones, Meilir.andP;  The Practical Guide to Structured Systems Design.andO;New York, N.Y.: Yourdon Press, 1980.andM;[11] Buhr, Raymond J.A.andP;  Systems Design with Ada.andP;  Englewood Cliffs, N.J.:andO;Prentice-Hall Software Series, 1984.andM;[12] Wasserman, Anthony, Peter Pircher, and Robert Muller.andP;  &quot;AnObject-Oriented Structured Design Method for Code Generation,&quot; SoftwareEngineering Notes 14(1): Jan. 1989.andM;[13] Booch, Grady.andP;  Software Engineering with Ada (second ed.).andP;  Menlo Park,Calif.: Benjamin/Cummings Publishing, 1987.andM;Sally Shlaer is president of Project Technology Inc., a Berkeley,Calif.-based company that provides methods, training, and consultingservices.andM;Stephen J. Mellor is vice president of Project Technology Inc.andO;</TEXT></DOC>