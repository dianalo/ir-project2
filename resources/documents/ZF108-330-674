<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-330-674  </DOCNO><DOCID>08 330 674.andM;</DOCID><JOURNAL>Communications of the ACM  April 1990 v33 n4 p439(10)* Full Text COPYRIGHT Association for Computing Machinery 1990.andM;</JOURNAL><TITLE>Retrospective on DACNOS. (prototype Distributed Academic ComputingNetwork Operating System)</TITLE><AUTHOR>Geihs, Kurt; Hollberg, Ulf.andM;</AUTHOR><SUMMARY>The Distributed Academic Computing Network Operating System(DACNOS), a prototype network operating system designed tofacilitate distributed computing in heterogeneous environments, isdescribed.andP;  DACNOS initially targeted the computer sciencedepartment in West Germany's University of Karlsruhe, whichincludes IBM/370 mainframes, DEC VAX minicomputers and IBM PCmicrocomputers.andP;  These systems offered some file transfer but noresource sharing between applications running on differentmachines.andP;  DACNOS does not replace individual operating systems orreduce the autonomy of systems involved.andP;  It uses a Remote ServiceCall (RSC) programming interface and a 'remote like local' designprinciple.andP;  DACNOS' kernel provides communication andsynchronization for low-level application to applicationcooperation.andP;  RSC provides a functionally complete interface for'enabling' applications.andM;</SUMMARY><DESCRIPT>Topic:     Multivendor SystemsDistributed ProcessingNetwork Operating SystemsPrototypeLocal Area NetworksEducation.andM;</DESCRIPT><NOTE>Only Text is presented here; see printed issues for graphics.andO;</NOTE><TEXT>Retrospective on DACNOS In DACNOS (Distributed Academic Computing NetworkOperating System) we have addressed two characteristic aspects of today'scomputing environments: distribution and heterogeneity.andP;  While the formeraspect is willingly accepted as a move to more power and flexibility for theuser, the latter is in many environments a--sometimes unwanted, mostlyfunctionally required--fact of life.andP;  Many people have studied distributedsystems for the special case of a homogeneous environment.andP;  DACNOS has aimedat providing efficient and convenient support for the cooperation ofheterogeneous computing systems.andM;Heterogeneity in systems is primarily because there is no single hardware andsoftware architecture that serves all computing purposes equally well.andO;Heterogeneity is apparent in different machine hardware architectures,operating systems, networking facilities, and user access control, to namethose who were considered for the DACNOS design.andP;  Other types ofheterogeneity are conceivable, (e.g., user interfaces, applicationsubsystems, or even multiple information media).andP;  These were not consideredfor the current prototype; however, they seem to make interesting areas forfurther research.andM;Our initial target environment was the computing infrastructure of theComputer Science department of the University of Karlsruhe in West Germany.andO;[1]  There we found, among others, IBM/370 computers running VM/CMS, DEC/VAXcomputers under VMS, [2] and IBM PCs running PC-DOS.andP;  These operating systemsand machine architectures differ greatly in their hardware, software, andinterface concepts.andP;  There was file transfer between the host computers, andsome PCs were linked to the IBM hosts supporting terminal emulation, butthere was no resource sharing between applications running on differentmachines.andP;  Data generated on one machine had to be shipped in a separate stepto another machine in order to process it there in an application--not tomention services such as directories or transparent file access across thedistributed computers.andP;  (Even today, this situation still is very typical formany data processing environments of large organizations.)andM;The DACNOS prototype was first implemented on VM/CMS, VMS, and PC DOS.andP;  Thisprototype has been studied extensively and used to build various distributedapplications.andP;  It has also been ported to two more operating systems, i.e.,andO;AIX on IBM PC RT and IBM PS/2 and OS/2 on IBM PS/2.andP;  In this article wediscuss the fundamental design assumptions of DACNOS that reflect oursystematic approach to solve the heterogenity problem as well as ourexperiences with implementing a prototype on top of five operating systems.andO;For obvious reasons we cannot elaborate on all aspects and components ofDACNOS in appropriate detail.andP;  The cited references should provide moreinformation on a particular DACNOS subject.andP;  The section on &quot;Goals andImplications&quot; describes our design goals and constraints.andP;  The section on&quot;Architecture&quot; shows how the DACNOS architecture reflects these goals.andP;  Thesection on &quot;Application Experiences&quot; contains some examples for real-lifeapplications that were built on top of DACNOS.andP;  In the section on&quot;Implementation&quot; we discuss what it takes to implement DACNOS on a system andhow easy or hard the portation was for the above-mentioned operating systems.andO;We also provide performance data for some scenarios.andP;  In the section on&quot;Discussion of Related Work&quot; we compare DACNOS to related work onheterogenous distributed systems.andP;  The last section contains our mainconclusions and looks toward future extensions.andM;GOALS AND IMPLICATIONSandM;Resource sharing between heterogeneous autonomous computers has been thefocus of our research.andP;  Fast networking hardware and low-level communicationsoftware was available to the academic community on the campus, but it wasstill a very cumbersome and often replicated task to write an applicationthat integrated services from several computing devices, although the needfor such applications seemed to increase steadily.andP;  Our intention was toprovide the programmer of a distributed application with convenient systemsupport to facilitate the controlled access and distributed computingresources--basically the same support he or she is used to when writing alocal application.andP;  This local-system paradigm was our guideline for manydesign decisions.andM;Two as-much-as-possible goals stood at the beginning of our designconsiderations:andM;(1) the application programmer should not have to deal with low-level detailsof operating systems and communication protocols andandM;(2) heterogeneity should be handled by the network operating system and behidden from the application programmer.andM;In other words, we wanted to provide a high degree of insulation from bothdistribution and heterogeneity.andP;  These two goals led to the design of anapplication platform for programmers of distributed applications.andP;  Thisplatform is called &quot;Remote Service Call (RSC).&quot;andP;  It is the key component inthe NOS kernel that provides an application-oriented (as opposed to acommunication-oriented) interface to the cooperation of heterogeneouscomputers.andP;  How the &quot;application orientation&quot; is reflected in the RSCinterface will be shown in the next section.andM;Since the interconnected computing systems are part of many ratherindependent organizational university structures having individualapplication requirements and solution, (e.g., research institutes, libraryservices, and student workstation pools), the following two design contraintswere significant for the NOS design:andM;* do not replace the individual operating systems andandM;* retain the autonomy of the involved systems.andM;We could not and did not want to (and many commercial users would agree)enforce a single operating system, e.g., UNIX, [3] on all machines.andP;  (SeveralUNIX-based distributed systems can handle heterogeneous hardwarearchitectures [3, 17, 20].)andP;  Such a step would have made a large base ofapplications and investments worthless.andP;  Consequently, our NOS is an add-onto the different operating systems that does not interface with existingapplications, but makes if feasible to have access to remote resources informerly only-local applications.andP;  In many cases this remote access istransparent to the application software.andP;  (See the section on &quot;ApplicationExperiences.&quot;)andM;When cooperating with remote partners, a DACNOS node does not give up itsright to decide autonomously about the access and the management of itsresources.andP;  For example, access to a resource has to be granted explicitly;it can be revoked at any time; and the allocation of resources to requestorsis completely up to the provider of the service.andP;  This property distinguishesthe DAC Network Operating System from many distributed operating systemswhere the nodes relinquish some of their control autonomy to become part of aglobal &quot;whole.&quot;andP;  The emphasis on autonomy does not preclude a DACNOS-widemanagement support that helps to allocate and control available resources ina desired manner [7].andP;  It requires mechanisms for access control andprotection across distributed computers.andM;When discussing software add-ons to heterogeneous systems: portability mustbe a design goal--not just for applications but also for the NOS software.andO;Besides being good software engineering practice, portability is essentialfor a system that is to be ported to many heterogeneous computers.andP;  In ouropinion we could otherwise not claim to have a systematic approach toovercome heterogeneity.andP;  To achieve portability one has to define a softwaremodule structure that clearly isolates system dependent and independentcomponents.andP;  In so doing, the portation effort is reduced to the modificationand adaptation of only a few components.andP;  A good modular structure willobviously also support the manageability and extensibility of such a ratherlarge software complex.andM;ARCHITECTUREandM;Cooperation in DACNOS is conceived as client-server interactions.andP;  Clientsand servers reside in logical nodes, which are mapped onto the (physically)nodes of the underlying communication network.andP;  A logical node has a networktransport address and is typically associated with an operating systemprocess or process group having a single address space.andP;  In VCM/CMS eachvirtual machine would be a logical node, while a single-user PC is considereda single logical node.andP;  In general, a logical node corresponds to a userprocess on a computer.andP;  It is the smallest addressable unit in the transportsystem.andM;Figure 1 shows the structure of a system with a DACNOS extension.andO;Applications make use of the host operating system services as before and cannow access remote resources through calls to the NOs System Services.andO;Applications may also directly call operations offered by the NOS kernel'sinterface, i.e., the Remote Service Call interface.andP;  This is the lowest NOSaccess level.andP;  The components drawn below RSC in Figure 1 are not visible tothe &quot;outside.&quot;andM;Remote Service CallandM;RSC is the platform for distributed cooperation.andP;  It is coherently accessibleon all logical nodes.andP;  The RSC interface is based on a set of objects thatrepresent typical operating system primitives, i.e., requests, ports,storage, and accounts.andP;  RSC itself does not provide higher level objects likefiles or a directory, but provides the &quot;building blocks&quot; for making suchobjects accessible and manageable in the heterogeneous distributedenvironment.andP;  The RSC programming interface is a set of operations, i.e.,andO;high-level language library functions, defined for the RSC objects.andP;  Alloperations are performed by a RSC worker that resides in the logical node andmanages the RSC objects of this node as well as all communication required toaccess objects on another node.andM;Object sharing is the paradigm for distributed cooperation using RSC objects.andO;To share an object (local or remote), access rights to the object are passedto the recipient who may then use the object in a way that is completelylocation, naming, and presentation transparent, i.e., just like a sharedresource in a local system.andP;  Again, the local-system paradigm is theguideline behind the choice of RSC primitives and the object sharing.andP;  Thesystem, i.e., the interacting RSC entities of DACNOS, provides the illusionof a single shared global object space.andM;As an example, consider a typical client-server interaction.andP;  The serverprogram creates a port for its service and offers this port to certainclients.andP;  (Create and offer are RSC operations defined for the port objects.)andO;The port is typed in the same sense possible requests and request dataformats are specified by the server programmer and attached to the port.andP;  Itis thus the handle for an abstract service object.andP;  The actual dataconversion is performed transparently by the presentation component when thedata is sent across the network.andM;In order to bind to the service represented by a port a client will have toexplicitly issue a RSC share operation.andP;  To send a service request to theserver the client creates an object called carrier that specifies the requestand also contains value and reference parameters.andP;  Reference parameters inRSC are passed as access rights to RSC objects.andP;  For example, access to adata buffer at the client side could be granted with the Carrier for theduration of the request.andP;  (Data buffers are described by windows.)andP;  TheDACNOS data presentation syntax notation comprises mechanisms to specifyreference parameters as part of an interface description [6].andP;  The type ofuser data contained in RSC objects, e.G., carrier and window, is defined byan attached type description string.andP;  This is used by RSC to perform thenecessary conversions.andP;  The programmer specifies the data types in a languagethat is an extension of ASN.1 [10].andP;  This notation is compiled into a moreefficient internal description string.andM;It is important to note here that the programmer of an application will onlyhave to think in terms of application-related operations, e.g., create port,share port, call service, read data, while RSC transparently performs all therequired communication, error handling, access checks, data segmentation,data conversion, and even account management [7].andP;  Shared objects makedistributed programming &quot;look and feel&quot; like local programming.andP;  Moreinformation on RSC including a detailed description of its objects andimplementation can be found in [6].andM;Global Transport and Kernel Service CallandM;Global Transport (GT) and Kernel Service Call (KSC) are those components thatserve the portability of RSC.andP;  The portation of RSC is basically theportation of GT and KSC to the target machine.andM;GT is the coherent interface for the data transport need of RSC.andP;  The networkis conceived as a set of interconnected islands of homogeneity withproprietary internal transport mechanisms.andP;  We did not impose a lessefficient heavy-weight protocol where a specialized protocol performs muchbetter.andP;  Thus, we use standardized protocols (OSI/TP-4, TCP/IP) only when acommunication path crosses island boundaries.andM;GT basically is a reliable datagram interface to data transport betweenDACNOS logical nodes with a global OSI-style addressing scheme.andP;  RSC sees asimple &quot;send-receive&quot; interface where, for example, sequencing andduplication control are not required separately from the general errorhandling mechanisms in RSC.andP;  Internally, GT might very well use--depending onthe transport protocol and network--connection-oriented services to send thedatagrams between the network nodes.andP;  RSC, however, does not see connectionson the transport level.andM;While GT handles diverse communication environments, KSC covers diverse hostoperating systems.andP;  Layered communication software typically deals withindependent asynchronous events and, therefore, requires appropriateoperating system support.andP;  With KSC we created an operating-systemindependent interface that offers communication-software-oriented servicessuch as multiple light-weight processes, communication within shared memory,synchronization primitives for disjunctive multiple event handling, and timerservices.andP;  Popular operating systems differ significantly in how much of thissupport is available and how it is offered to the applications.andO;Consequently, the implementation efforts for KSC have ranged from &quot;simplemapping of services&quot; to &quot;implementation of a coexistent multitasking system.&quot;andO;(See the section on &quot;Implementation.&quot;)andM;It is interesting to note that KSC is based on the same cooperationphilosophy as RSC: KSC process cooperate through objects in shared localmemory, and RSC processes cooperate through objects in a (virtually) sharedglobal object space.andM;System Management ServicesandM;The DACNOS kernel provides communication, synchronization, and low-levelaccess management support for application-to-application cooperation across aheterogeneous network.andP;  The DACNOS system management services complementthese facilities with user-and resource-level services that help to organizeand control the user access and resource allocation.andP;  These services areanalogous to services in host operating systems and have to reside on nodesthat are trustworthy.andM;The Directory Service maintains, distributes, and protects information aboutnetwork resources and services.andP;  It also contains a name service thatcontrols the naming of resources in the network.andP;  The DACNOS directory is notspecifically tailored for a specific application scenario, e.g., for messagehandling or file stores, but aimes to be a universal directory capable ofsupporting a wide range of applications.andP;  An entry in the directory databaseis simply a tuple consisting of object name, entry owner, and a set of typespecific attributes.andP;  Access control is performed on a per attribute basis byowner-controlled access lists [15].andP;  The name space is divided into domainsof unique names.andP;  A server would register its service at the directoryspecifying some name string.andP;  The name service part of the directory ensuresthe uniqueness of the name within the server's domain.andP;  Clients find outabout a service by asking the directory for a particular service name.andP;  Thedirectory's response contains the network address of a server that offers thedesired service.andP;  Using the service name and network address the clientestablishes a binder to share the server port (share operation).andP;  After theshare has succeeded the client will in subsequent operations only use theport handle that is a result parameter of the Share Port operation [15].andM;The Authentication and Authorization Service (AAS) provides for mutualidentification of interacting partners and is a means for servers to controlaccess to their services.andP;  It is the key component needed to cope with theproblem of non-secure, freely accessible workstations in the network.andP;  Theauthentication is based on a password scheme, and it is assumed that a usercannot forge his or her transport address.andP;  Users have to log-in with theirAAS before using DACNOS services.andP;  Thus a &quot;DACNOS user-id&quot; is then correlatedwith a transport address.andP;  To check the authorization of a client, serverspresent to the AAS the network address and user-id as given in the clientrequest in order to decide about the validity of the purported identity [14].andM;The DACNOS Account Service is analogous to the accounting facilities of alocal system.andP;  Resource consumption data is collected within the RSC kerneland shipped to the Account Server.andP;  RSC has a special account object tosupport these functions.andP;  The data provides valuable information on theutilization of network services and can be used in billing for a providedservice.andP;  For example, there are many ways to limit the consumption ofresources by certain users to user groups.andP;  A broad discussion of theproblems of accounting and billing in heterogeneous environments and theDACNOS Account Server can be found in [7].andM;All DACNOS system services described here are distributed in a sense thatmore than one server may be involved in order to serve a service request.andO;The reader should refer to the cited references to get more information onserver interaction and protocols.andP;  On top of the management services thereare applications that are also considered DACNOS system services.andP;  Theseservices, e.g., Remote File Access and Remote Execution, provides access toshared resources.andP;  They are discussed in the following section.andM;In a distributed system, more and new types of failures are possible than inthe local case.andP;  DACNOS tries to assist the application programmer--as far aspossible--in the handling of unexpected events.andP;  The representation of aninvocation as a carrier make the relations between remote cooperatingcomponents explicit to the RSC kernel.andP;  A watchdog process inside the RSCkernel periodically checks the availability of the remote partners by sendingprobe messages.andP;  Loss of connection to a node and loss of a service will thusbe detected.andP;  Failures are reported to the waiters on a carrier or a port byterminating their wait-state with a special return code.andP;  It is then theresponsibility of the application to react reasonably within its context.andO;Mechanisms for the coordination of distributed transactions are known andcould be integrated into RSC.andP;  Nevertheless, the applications would have tobe written to support a transactional behavior.andM;APPLICATION EXPERIENCESandM;Two operating-system related services were developed partly in parallel withthe DACNOS kernel: Remote File Access and Remote Execution.andP;  Both providedfeedback on the design of RSC and its interface.andP;  This feedback helped toimprove its functionality and interface style.andM;Remote File AccessandM;Remote File Access (RFA) is a global, homogeneous file system forheterogenous networks that provides transparent access to remote files [8].andO;According to our autonomy and transparency objectives, we do not replace anylocal file system, but accommodate the global RFA file system in the diverselocal file systems.andP;  The RFA file system is partitioned into multiple RFAfile servers, each being responsible for a subset of RFA files and RFAclients that mediate the user access to RFA.andP;  The running prototype supportssequential record-oriented files.andM;RFA servers use the local file systems of the host operating systems.andP;  Thistechniques minimizes the effort needed to port RFA servers to differentoperating systems.andP;  It also allows existing local files to be made availableglobally without copying (&quot;publish&quot;), thus allowing easy exchange of filesbetween RFA and the local file system.andP;  Published local files should not bemodified without RFA: otherwise their global consistency can not beguaranteed.andP;  The RFA client software is an extension and in some cases amodification of the local operating system.andP;  The extension offers access tothe global RFA files through procedure and command interfaces.andP;  Themodification opens the local file system interfaces for the global RFA files.andO;It intercepts calls to the file system and re-routes them if necessary.andP;  Setsof global files can be bound (&quot;mounted&quot;) inot the local file system as&quot;virtual volumes.&quot;andP;  Global files can be accessed transparently via theirlocal aliases in the same ways as local files, and existing applicationprograms may use global files without any change in the application code.andO;This again is in line with our local-system paradigm.andM;The file naming structure of the global file system is hierarchical.andO;Publication of a file at a file server includes assigning a global name tothe published file.andP;  Similarly, binding a file into a local file systeminvolves naming the file according to the local naming structure.andP;  Namemapping is assisted by user selectable default rules that can cover the mostfrequently used translations.andM;RFA uses RSC for cooperation between distributed RFA clients and servers.andO;For example, an RFA file server offers a main port for &quot;Open File&quot; andmaintenance-related requests.andP;  A prviate port together with a private serverprocess is then created for each opened file.andP;  This port is shared with theclient who uses it to access the file contents.andP;  These two reports differ intheir visibility.andP;  The file server port is accessible to the public accordingto the defined access rights, yet an open file is a private matter betweenthe client and the server.andP;  File data is exchanged between client and serverusing a shared RSC window object with the appropriate data descriptionattached.andP;  Client and server only &quot;read&quot; or &quot;write&quot; to the arbitrarily sizedwindow, while RSC handles the segmentation access control and thecommunication and conversion.andM;The mapping of open files to a port and a separate process has severaladvantages.andP;  The file server need not be concerned with dispatching.andP;  Ifmultiple requests queue up.andP;  RSC contains the mechanisms to ensure a fairdistribution of the file service among the clients.andP;  Authorization checkingtakes place during open time.andP;  For subsequent calls to the private port, theserver can rely on the authorization of the caller.andP;  It is easy to add fileservice specific accounting to a server.andP;  Since the service providing processruns under the account of the client, this process can be charged for anydesired account units.andP;  RSC and the accounting server collect the bills forthe client process.andM;As to the implementation of RFA it is obvious that portability can only belimited since RFA client and server software anchor deep in the differenthost file systems--though they do not hinder the local functionality.andO;Nevertheless, many RFA modules are portable based on the common programminglanguage C and the RSC support.andP;  RFA clients with transparent remote fileaccess are available for VM/CMS, VMS, and PC DOS.andP;  Designs for AIX and OS/2have been done, but not yet implemented.andM;As mentioned before, RFA had influence on the RSC design.andP;  For example, awindow's data format description originally was statistically defined wherethe window was created.andP;  This was insufficient in cases where the clientcreates a data window in his virtual memory without knowing the actual recordstructure of the window that the server would use to write the file data.andO;The server did not have means to specify data formats for the retrieved datawhose structure was not known a priori to the client.andP;  This was changed in away that one side can create a window with a wild-card data formatdescription, which allows a sharer of the window to provide the structureinformation.andM;RSC has matured to become a powerful and convenient base for complexapplications like RFA.andP;  Some of the advantages of using RSC for RFA are asfollows.andP;  There is no need to design protocol elements for authorization,accounting, node failures, time out, or any other aspect of remotecommunication.andP;  This makes the interface design much easier and increases itsstability.andP;  The data presentation functions of rSC are flexible enough tohandle headers or trailers of variable length records transparent to RFA,i.e., without the need to reformat or mark retrieved data.andP;  Furthermore, theRSC window object is not only convenient, but also allows for transparentdata transfer optimizations, e.g., a bulk transfer protocol is appliedwhenever it seems to be appropriate.andP;  This is transparent to the applicationthat uses only Read window and Write window operations.andM;Remote ExecutionandM;The DACNOS Remote Execution Service (RES) [19] enables the sharing ofprograms located on remote computers.andP;  The aim was to build a natural andrather transparent extension to the invocation of local programs.andP;  Totaltransparency for remote execution is almost impossible to achieve in such aninherently heterogenous environment, and we did not try to push thetransparency limits.andP;  Rather, we wanted to provide a remote execution servicethat looks very familiar to the user.andM;Commonly, programs are designed by names.andP;  The user interface for starting aprogram has been extended such that the user can optionally append a servername to the program name where the program is to be executed.andP;  If no locationis given with a program name the RES client part inquires at the directoryservice where this program is offered.andP;  The directories contain informationabout which programs are available on which computers.andP;  The user can specifya directory search scope in order to limit the search to certain nodes ordomains.andP;  If a potential location was found, the execution request is sent tothe given RES server.andM;Executing programs will require additional input and will output results.andO;File access of a remote program is handled by the DACNOS RFA component.andO;Thus, the remote program runs with the current working file directory of theuser that requested the execution.andP;  All terminal I/O is intercepted andforwarded to the client and server side, respectively.andM;RES places only simple requirements on the data presentation since terminalI/O contains characters only, and other data access is handled by RFA.andO;During the developments of RES, it was evident that the design andimplementation of interactions between clients and servers based on the RSCplatform (plus RFA was almost trivial compared to the mastering ofinterceptions for terminal I/O and commands.andP;  These interception routines areobviously system dependent and not portable.andP;  Most of the rest of RES isportable.andP;  It has been implemented for VM/CMS, VMS, and PC-DOS (client only).andM;Database and Computation ServerandM;To learn about the &quot;ergonomics&quot; of RSC and for demonstration purposes, remoteaccess to an SQL database [23h and a high-precision numerical subroutinelibrary were developed by summer students.andP;  In both cases, most of the designand all of the implementation was done by the students who had someprogramming experience but no DACNOS knowledge.andM;Within a few weeks after they had gained sufficient knowledge about thesub-systems to be accessed, they completed the implementation of a frameworkfor the remote access using RSC objects with character data only andsimulated access to the database or library.andP;  Without RSC this certainlywould have required much more time in order to learn about the variousinterfaces, to develop the application and to debug it.andP;  Adding support forother data types took a matter of days.andP;  In both cases the client componentswere ported to all DACNOS systems.andP;  This was no effort at all, since theclients did not call any machine specific functions (only common Cfunctions); and distributed cooperation was based on RSC.andM;IMPLEMENTATIONandM;The design and implementation of DACNOS was a joint effort of researchers atthe University of Karlsruhe and IBM.andP;  The project duration was limited tofour years.andP;  All together it took an estimated 40 person-years to build theprototype as it is today.andM;All of our code has been written in the programming language C, except forsome low-level KSC routines, which were better done in assembly language.andO;Although tho various implementations of C on heterogeneous machines havetheir compatibility problems, e.g., order of bit fields, alignment ofstructures and unions, default types, sign extension for shift operations, itwas certainly the best available choice.andP;  It made our software highlyportable, as long as certain conventions and rules were obeyed.andP;  A fewnumbers on the amount of code produced for the NOS kernel (excluding theDACNOS System Services) shall illustrate the development work: the KSCcomponent (for VM/CMS) has about 7,000 lines of code, half C and halfassembly language.andP;  The GT for VM/CMS consists of 6,500 lines of C code.andO;Both figures vary depending on the host operating system.andP;  The NOS kernel,i.e., RSC including the data presentation, has roughly 55,000 lines of codeand occupies 160K bytes of memory under VM/CMS.andP;  Host system dependencies ofthe RSC code are all completely separated into a collection of files, whichhave to be adapted when porting RSC.andM;KSC ImplementationandM;As outlined in the section on &quot;Architecture&quot; KSC provides a coherent,communication-software-oriented surface on top of the host operating systems.andO;It offers, among other facilities, light-weight processes sharing an addressspace.andP;  The portation of RSC is basically the portation/implementation ofKSC.andP;  The amount of work varies depending on what is available in the hostoperating system.andM;For DACNOS on VM/CMS, each virtual machine (VM) is a &quot;logical node&quot; andrepresents an independent RSC entity with several internal and potentiallymany user-defined processes.andP;  We therefore had to add a transparent,coexistent, light-weight multitasking system to a VM, which originally didnot offer support for multiple processes.andP;  It is important to note that KSCmust not interfere with existing applications.andP;  Before KSC is added, the &quot;CMSuser process&quot; is the only active thread in the VM.andP;  With KSC this view of themachine is still supported, but it is possible to create additional threadsand thus multiplex the VM.andM;For VAX/VMS a logical node corresponds to a VMS process.andP;  With KSC thisprocess can be split up into light-weight processes that share its addressspace.andP;  This implementation is analogous to the VM/CMS version, i.e., a VM inVM/CMS corresponds to a VMS process.andP;  The AIX version of KSC is also alongthis guideline [16] whereas OS/2 offers suitable facilities (light-weightmultitasking with shared memory) that make the implementation of KSCbasically a functional mapping.andM;PC DOS was important for us as a widely available low-cost system.andP;  A PC wasconsidered a single logical node in DACNOS.andP;  KSC was implemented by mappingthe KSC process constructs onto a multitasking system that was internallyavailable in IBM for the PC.andP;  Although this was relatively easy, the PCeventually gave us a hard time because of memory size restrictions and lackof memory protection.andP;  Though we succeeded to port DACNOS to PC DOS andimplemented the transparent Remote File Access client in the PC file system,the applicability of DACNOS on a PC is rather limited due to the severe lackof memory.andP;  DACNOS plus the RFA client leave free less than 70K of the 640Kmain memory of a fully equipped PC.andP;  We did not investigate the use ofextended memory under DOS, which might give some relief from the storageproblem, but still does not cure the lack of protection.andP;  Since OS/2 and AIXbecame available and better exploits the increased power of workstations, wedid not further invest into the PC DOS version of DACNOS.andM;PerformanceandM;Performance has always been a high priority design goal for DACNOS.andP;  (Highestpriority was to find a systematical and general solution for heterogeneity indistributed systems.)andP;  Given the DACNOS constraints and network environmentour design could not exploit some of the mechanisms and techniques that havefrequently been used in other projects on distributed operating systems.andP;  Forexample, the DACNOS network may consist of a variety of interconnected localarea networks and point-to-point lines with very diverse performance andreliability characteristics.andP;  The &quot;cost&quot; of a message is quite high.andO;Therefore, extensive use of multicast or broadcast was impossible, and wetried to minimize the number of protocol messages without sacrificingfunctionality.andP;  Another example is the KSC, which is added on top of the hostoperating system.andP;  This obviously limits the KSC performance to theperformance of the underlying general purpose system and is hardly comparableto an approach that builds a kernel directly on the bare hardware.andP;  Theseapproaches make different assumptions and aim at different goals than DACNOS.andM;We measured the performance of selected RSC interactions involving variousmachines and communication links.andP;  The host measurements were taken duringregular daytime use with light to medium load on the hosts.andP;  Some examples:andM;* The measured round trip time of an empty request between two VMs on an IBM4361 was 50 milliseconds (msec).andP;  About the same time was observed on a VAX8600.andM;* The same request between two VMs on two separate IBM/370 machines (4361 and3083) connected by a 64K bits-per-second link using a proprietary protocoltook approximately 125 msec, yet it took 210 msec on two VAXs (8600 and 8300)with VMS connected by an Ethernet and DECnet protocols.andM;* For two PC/AT personal computers on a token ring the empty request took 165msec to complete, and PC to IBM 4361 host via token ring and gateway took 345msec.andM;When more user data is sent with the request the execution time is the sum ofthe above-fixed amount for the empty request plus an increase proportional tothe speed of the communication link.andM;We were also very much interested in the overhead introduced by the DACNOSkernel compared to the basic, unenhanced inter-process communicationfacilities of the host system.andP;  This is best expressed in the approximatenumber of machine instructions.andP;  For a round trip request the RSC clientperforms 6,000, the server side 8,000 instructions.andP;  GT (including KSC, butexcluding the transport protocol itself) adds another 1,500 instructions fora send operation and 6,000 for receive.andP;  For the above-mentioned scenariowith the client on an IBM 4361 (1.5 million instructions per second (Mips))and a server on an IBM 3083 (5 Mips), this amounts to roughly 12 millisecondsfor RSC and GT, a number we were quite satisfied with.andP;  If both client andserver are located on the 4361 and only VM/CMS internal communication isused, the processing for RSC and GT takes roughly 20 msec and processswitches, interrupt handling, and data copy operations, take the rest, i.e.,andO;30 msec.andM;DISCUSSION OF RELATED WORKandM;In this section we restrict our discussion to related work that concentrateslike DACNOS on adding solutions for heterogeneity and distribution toexisting computing environments.andP;  We do not discuss distributed operatingsystems like March [1] or Locus [20], which can also work on heterogeneoushardware, but are built on the bare hardware.andP;  They are not meant to coexistwith a local host operating system.andP;  Here we will discuss systems that areextensions to existing host operating systems.andM;Cooperation in heterogeneous distributed environments is facilitated byintroducing a unified view onto the heterogeneity that is an abstraction fromthe given dissimilarities.andP;  Several locations for such an abstraction layerare conceivable.andP;  For the application programmer using DACNOS thisabstraction is given at the RSC interface.andP;  (Other internal abstractionlevels are the KSC and GT interfaces.andP;  These facilitate the portation ofDACNOS, but are not seen by the &quot;RSC programmer.&quot;)  The RSC cooperationfacilities, i.e., the RSC objects and operations, are coherently supported byall DACNOS nodes and were designed analogous to the facilities of a localoperating system.andM;Another approach is to move the unification layer into certain &quot;key&quot;applications.andP;  In HCS [18] &quot;key facilities,&quot; i.e., remote procedure call(RPC), naming and binding, are made compatible (or newly created, if notavailable) across the various types of systems.andP;  On top of these facilitiescommon services are implemented that are considered most important: filestore, mail, printing, and remote computation.andP;  In HCS, heterogeneity is&quot;accommodated&quot; into certain services, but it is &quot;abstracted&quot; in DACNOS at theoperating system level.andM;A project that shares the emphasis on heterogeneity and the need for acomprehensive solution with DACNOS is Cronus [21].andP;  Object orientation, theintegration of access protection into the kernel, a network independenttransport interface, software portability, and operating system add-on ratherthan replacement are common properties for both systems.andP;  Though the designobjectives are very similar, there are a number of differences in theapproach and the implementation.andP;  For example, the Cronus object is onanother level than the basic &quot;building block&quot; objects of RSC.andP;  There areobject managers for each type of Cronus object while there is only one RSCentity that manages the objects of an RSC node.andP;  Cronus objects can bereplicated and can migrate, which requires extensive use of group--andmulticast search operations.andP;  Therefore, it is practically essential to haveadequate communication support, i.e., a fast LAN with broadcast capabilities.andO;RSC objects cannot be moved or replicated.andP;  The RSC protocol does not usebroadcast or multicast facilities, although the DACNOS Directory andOrientation Service occasionally will have to issue search operations.andO;Cooperation under RSC is based on the object sharing paradigm: the programmerthinks in terms of sharing objects just as in the local case, and messagepassing is the implicit mechanism used to implement such an &quot;illusion&quot; in thedistributed environment.andP;  In Cronus, cooperation is achieved using explicitmessage-passing primitives and the interaction style is much morecommunication-oriented.andM;Sun RPC [24] and Apollo NCS [2] are representatives of Unix-based RPCpackages.andP;  Both use the services of the underlying host operating system andtransport service and support heterogeneity.andP;  In NCS, client and server stubsare generated automatically by a compiler from interface descriptions writtenin a &quot;Network Interface Description Language.&quot;andP;  The Sun RPC only provides anextensible set of library routines for the marshalling and demarshalling ofparameters.andP;  It is the responsibility of the application programmer to makethe appropriate calls.andP;  In DACNOS, the invocation of remote operations isdone by sending an RSC carrier.andP;  RSC, however, supports a different, moreflexible and powerful interaction model.andP;  Requests are associated withcarrier objects that may contain data values and object references asparameters (see the section on &quot;Architecture&quot;).andP;  Sending a carrier is anasynchronous operation.andP;  Therefore, clients may have several carriersoutstanding and may selectively wait for their completion.andP;  Servers mayreceive and work on multiple requests simultaneously.andP;  The carrier alsocontains automatically appended information for system management purposes,e.g., authorization, accounting, and dispatching priorities [7].andP;  In allthree systems various services are built on top of these communicationkernels.andP;  Their differences are not discussed here, because the major focusof this article is on the kernel of DACNOS.andM;There are also language-based approaches to conquer heterogeneity.andP;  In DAPHNE[13] coherence is achieved at the programming language level.andP;  Components ofa program can easily be distributed for execution on different nodes of aheterogeneous network.andP;  The means for cooperation between the distributedcomponents is a Remote Procedure Call (RPC) that is adapted to handle theheterogeneity.andP;  It is supported by a stub generator and appropriatelymodified run-time environment.andP;  In [5] a programming language (NetworkCommand Language (NCL)) was defined for the description of remote servicerequests.andP;  Using pre-defined function libraries and additional serverspecific functions NCL expressions are created and shipped to a server.andP;  (Acanonical data representation solves the data incompatibility problem.)andP;  Withcommand language expressions, a client can &quot;program&quot; the server to perform asequence of functions in a single request avoiding the overhead of multipleremote procedure calls.andM;We would also like to mention two other very prominent attempts at masteringheterogeneity: Open Systems Interconnection (OSI) and IBM's SystemsApplication Architecture (SAA).andP;  OSI defines standards for the communicationbetween heterogeneous computer systems [9].andP;  The set of standards is stillevolving.andP;  Only lately, efforts have been started to define a platform fordistributed applications that goes beyond the mere communication aspects ofdistributed processing [11].andP;  DACNOS is considered one of the prototypes fora support environment for ODP, which is being developed by the EuropeanComputer Manufacturers Association (ECMA) [4].andP;  The ODP activities willproduce a reference model about how to integrate and describe the variousaspects of distributed computing like communication, directories, securityand management.andP;  Such a framework, however, will not provide specificationsfor the implementation on a real system or portability considerations, i.e.,andO;problems that were solved in DACNOS and related research projects.andM;SAA is a software architecture for the development of consistent applicationsacross the major IBM computing architectures [25].andP;  SAA specifies commoninterfaces and conventions for user access, communication, and programming ondissimilar operating systems.andP;  Benefits of such an architecture will be easymigration between systems, the portability of software, and the eliminationof redundant development efforts.andP;  DACNOS has tackled the subset of the SAAobjectives, which are related to distributed processing in a slightlydifferent, historically grown, mixed vendor computing environment.andO;Nevertheless, the DACNOS prototype demonstrates not only the feasibility butalso the potential benefits of SAA [22].andM;CONCLUSIONS AND OUTLOOKandM;The motivation for DACNOS stemmed from the demand for resource sharing inhistorically grown heterogeneous computer networks and the fundamental lackof appropriate support for such applications.andP;  Our main goal was to providesystem level support that takes most of the burden of distribution andheterogeneity away from the programmer of a distributed application.andP;  TheDACNOS prototype demonstrates the feasibility of such an approach.andM;Feedback from applications on DACNOS has provided us with valuable insightsinto our design decisions.andP;  The more general observations are: First, we havefound that the &quot;remote-like local&quot; design principle makes the interfaces easyto comprehend for application programmers.andP;  This familiarity speeds up thedevelopment process and increases the productivity.andP;  Second, the integrationof access and access management into the kernel relieves the programmer fromexplicitly dealing with much of the (in one way or another) required accessmanagement.andP;  Separating management functions and shifting them into the NOSkernel avoids costly &quot;reinventions of the wheel.&quot;andP;  Third, the RSC objectinterface has proven to be a functionally complete &quot;application-enabling&quot;interface.andP;  This style of interface is not necessarily tied to the currentimplementation of DACNOS.andM;We could well imagine having such an enabler for distributed applications ontop of other data transport environments, possibly implemented on a kind ofhost operating system support other than KSC.andP;  We claim that transport levelprimitives are too low-level for application programmers while the remoteprocedure call unnecessarily imposes a certain programming style that isoften inadequate and sometimes cumbersome for the cooperation of independentnetworked processors.andP;  RSC is located somewhere in between the two offeringan application-oriented abstraction that integrates communication as well asmanagement functions.andP;  Finally, on a platformlike DACNOS application programsare potentially portable whether or not their scope is only local or remote.andO;This clearly goes beyond the mere ability to communicate with otherheterogeneous systems by using standardized communication protocols.andP;  DACNOShas most of the functionality that is being discussed in OSI standardizationactivities; plus, it presents a solution for system integration and softwareengineering problems.andM;Such a comprehensive support is not free.andP;  The complexity of the NOS kernel'sdesign and implementation is higher than for approaches that run under the&quot;keep it simple&quot; mode.andP;  Less functionality in the kernel, however, tends tolead to replication of development efforts, less coherency betweencomponents, and thus, potentially reduced interoperability.andP;  Enforcingmechanisms in the kernel is the canonical approach with a higher complexityfor the system designer whereas the noncanonical approach shifts some of thecomplexity to the application programmer with all the potential pitfalls--andsome potential performance and optimization benefits.andP;  The DACNOS prototype,however, demonstrates that a functionally complete, more complex kernel canstill perform very well.andM;The DACNOS development has taught us that in order to manage the complexityof a design effort it was extremely helpful to have a clear initial designguideline, i.e., in our case the local-system paradigm.andP;  This broughtorientation in the early stages of the design process.andP;  It also broughtconsistency as we went along with the system design.andP;  And it helped tostructure the initially huge problem space.andP;  No one does it completely rightthe first time.andP;  So it is almost needless to say that we would make severaltechnical modifications and extensions if we had to do it again.andP;  None ofthese, however is related to our overall approach and design philosophy.andM;For example, we underestimated the problems of coordinating softwaredevelopment, versions, and maintenance on different computers by severalpeople at different places.andP;  Usage of a software control system from thebeginning of the project would have helped to eliminate severalmisunderstandings, incompatibilities and duplicated efforts caused byversion-handling errors.andP;  We now think that CASE tools should be integratedinto the development and implementation process.andP;  The implementation work ofthe DACNOS kernel was structured vertically, i.e., responsibilities weredivided by the type of the computer system.andP;  Thus, the developers had to knowinternals of all kernel components.andP;  A horizontal structure would assignresponsibility by component.andP;  This requires the developer to know severalsystems, but system interfaces are stable compared to the internals ofsoftware components under development.andP;  Therefore, a horizontal structure ispotentially more efficient.andP;  KSC was designed to isolate local operatingsystem dependencies from the rest of the DACNOS software.andP;  Full screen inputand output to the user's terminal were not included.andP;  We underestimated itsimpact on the structure and portability of reapplications.andP;  Today, we wouldconsider the integration of an existing window-oriented interface into KSC.andM;The development of DACNOS is basically finished.andP;  The prototype is in use atvarious locations outside of the IBM ENC.andP;  It was selected as a developmentbasis for distributed applications because of its unique functionality andflexibility.andP;  Among the external users are two European universities and anEuropean RACE project.andP;  So far, user reaction is very positive.andM;Our experiences with usability and performance were confirmed.andP;  Currently,there are not enough users to publish statements on the scalability of ourdesign.andP;  We intend to provide such data in a future report.andP;  There are stillsome activities going on to complete the portation of DACNOS System Servicesto the operating systems AIX and OS/2.andP;  We see opportunities for furtherextensions to DACNOS-like transactions, fault-tolerance, support fordistributed debugging, and support for distributed applications thatincorporate multiple information media like data, voice, and video.andP;  It isunclear to us what kind of system support suits the programming of theseapplications and whether DACNOS can be useful as a starting point for such asystem support.andP;  These questions will be the focus of our future research.andM;Acknowledgments.andP;  Many people, too numerous to mention, have contributed tothe DACNOS project.andP;  Special thanks go to Hermann Schmutz for designcontributions and management guidance and to Herbert Eberle for his designand invaluable implementation contributions.andP;  The following persons havecontributed significant parts of the code of the DACNOS prototype: P.Brecht,H. V. Drachenfels, C. Foerster, G. Harter, A. Kaemmer, B. Kieser, E. Kraemer,B. Mattes, S. Mengler, H. Moons, M. Philippsen, R. Oechsle, M. Salmony, B.andO;Schoener, A. Schill, M. Seifert, P. Silberbusch, R. Staroste, M. Wasmund, G.andO;Wild, H. Zoeller.andP;  We are grateful to all of them.andM;(*1) The DACNOS effort was part of a cooperation project of the University ofKarlsruhe and IBM Germany.andP;  The project's goal was to study the applicationof computers for the support of academic teacing and research [12].andM;(*2) DEC, VAX and VMS are registered trademarks of Digital EquipmentCorporation.andM;(*3) UNIX is a registered trademark of ATandamp;T Bell Laboratories.andM;REFERENCESandM;[1] Acetta, M., et al., Mach: A new Kernel Foundation for UNIX development.andO;In Proceedings of Summer Usenix Conference (Atlanta, Ga., June 9-13).andP;  USENIXAssoc., Berkeley, Calif., pp.andP;  93-112.andM;[2] Apollo Computer Inc. Network Computing System Reference Manual.andO;Chelmsford, Mass., 1987.andM;[3] Balkovich, E., Lerman, S., and Parmelee, R. P. Computing in highereducation: The Athena Experience.andP;  Commun.andP;  ACM 28, 11 (Nov.andP;  1985),1214-1224.andM;[4] ECMA Support Environment for Open Distributed Processing (SE-ODP).andP;  ECMATech.andP;  Rep., No.andP;  49, Geneva, Switzerland, 1990.andM;[5] Falcone, J. R.andP;  A programmable interface language for heterogeneousdistributed systems.andP;  ACM Trans.andP;  Comput.andP;  Syst.andP;  5, 4 (Nov.andP;  1987), 330-351.andM;[6] Geihs, K., et al.andP;  An architecture for the cooperation of heterogeneousoperating systems.andP;  In Proceedings of IEEE Computer Networking Symposium(Washington, D.C., Apr. 11-13).andP;  IEEE, New York, 1988, pp.andP;  300-312.andM;[7] Harter G., and Geish, K.andP;  An accounting service for heterogeneousdistributed environments.andP;  In Proceedings of the Eighth InternationalConference on Distributed Computing Systems (San Jose, Calif., June 13-17).andO;IEEE, Net York, 1988, pp.andP;  207-214.andM;[8] Hollberg, U., Schmutz, H., and Silberbusch, P. Remote File Access: Adistributed file system for heterogeneous networks.andP;  In Proceedings of theGI/NTG Conference on Communication in Distributed Systems (Aachen, WestGermany, Feb. 16-20).andP;  Springer Verlag, New York, 1987, pp.andP;  293-310.andM;[9] ISO OSI: Open Systems Interconnections Basic Reference Model.andO;International Standard 7498, Geneva, Switzerland, 1984.andM;[10] ISO Specification of Abstract Syntax Notation 1 (ASN.1).andP;  InternationalStandard 8824, Geneva, Switzerland, 1987.andM;[11] ISO ODP: Open Distributed Processing, Reference Model.andP;  In preparationat working group ISO/IEC-JTC1-SC21-WG7, Geneva, Switzerland.andM;[12] Krueger G., and Mueller, G., (Eds.) HECTOR.andP;  Vol.andP;  I and II, SpringerVerlag, New York, 1988.andM;[13] Loehr, K. P., Mueller, J., and Nentwig, L. DAPHNE: Support fordistributed applications programming in heterogeneous networks.andP;  InProceedings of Eighth International Conference on Distributed ComputingSystems (San Jose, Calif., June 13-17).andP;  IEEE, New York, 1988, pp.andP;  63-71.andM;[14] Mattes, B.andP;  Authentication in resource sharing networks.andP;  In HECTOR, G.andO;Krueger and G. Mueller, Eds.andP;  Vol.andP;  II, Basic Projects.andP;  Springer Verlag, NewYork, 1988, pp.andP;  126-139.andM;[15] Mattes B., and Drachenfels, H. V.andP;  Directory and orientation inheterogeneous networks.andP;  In HECTOR, G. Krueger and G. Mueller, Eds.andP;  Vol.andO;II, Basic Projects.andP;  Springer Verlag, NEw York, 1988, pp.andP;  110-125.andM;[16] Moons, H., Verbaeten, P., and Hollberg, U.andP;  Distributed computing inheterogeneous environments.andP;  In Proceedings of European Unix Users Group(EUUG) Spring '90 Conference (Munich, West Germany, April 23-27) 1990.andM;[17] Morris, J. H., et al.andP;  Andrew: A distributed personal computingenvironment.andP;  Commun.andP;  ACM 29, 3 (Mar.andP;  1986), 184-201.andM;[18' Notkin, D., et al.andP;  Interconnecting heterogeneous computer systems.andO;Commun.andP;  ACM 31, 3 (Mar.andP;  1988), 258-273.andM;[19] Oechsle, R.andP;  A remote execution service in a heterogeneous network.andP;  InHECTOR, G. Krueger and G. Nueller, Eds.andP;  Vol.andP;  II, Basic Projects.andP;  SpringerVerlag, New York, 1988, pp.andP;  169-182.andM;[20] Popek, G. J., and Walker, B. J. (Eds.)andP;  The LOCUS Distributed SystemArchitecture.andP;  MIT Press, Cambridge Mass., 1985.andM;[21] Schantz, R. E., Thomas, R. H., and Bono, G.andP;  The architecture of theCronus Distributed Operating System.andP;  In Proceedings of the SixthInternational Conference on Distributed Computing Systems (Cambridge, Mass.,andO;Feb. 22-24).andP;  IEEE, New York, 1986, pp.andP;  250-259.andM;[22] Scheer, A. L.andP;  SAA Distributed Processing.andP;  IBM Syst.andP;  J. 27, 3 (1988),370-383.andM;[23] Schoener, B., and Kieser, B.andP;  TRansparent database access in a networkof heterogeneous systems.andP;  In Proceedings of the GI/NTG Conference onCommunication in Distributed Sysems (Stuttgart, West Germany, Feb. 22-24).andO;Springer Verlag, New York, 1989, pp.andP;  415-429.andM;[24] Sun Microsystems External Data Representation Reference Manual.andO;Mountain View, Calif., 1985.andM;[25] Wheeler, E. F., and Ganek, A. G.andP;  Introduction to Systems ApplicationArchitecture.andP;  IBM Syst.andP;  J. 27, 3 (1988), 250-263.andM;KURT GEISH is currently a research staff member in the Operating SystemsResearch Group of the IBM European Networking Center, Heidelberg, Germany.andO;His current research interest include heterogeneous distributed systems, opendistributed processing (ODP), and application for highspeed networks.andM;ULF HOLLBERG is currently a research staff member in the Operating SystemsResearch Group of the IBM European Networking Center.andP;  His current researchinterests include heterogeneous distributed systems, distributed filesystems, and application programming interfaces.andP;  Authors' Present Address:IBM European Networking Center, Tiergartenstrasse 8, D-6900 Heidelberg,Germany, GEIHS@HDIBM1.BITNET and HOLLBERG@DHDIBM1.BITNET.andO;</TEXT></DOC>