<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO> ZF32-042-027 </DOCNO><DOCID>11 470 224</DOCID><JOURNAL>Communications of the ACM  Oct 1991 v34 n10 p64(14)* Full Text COPYRIGHT Association for Computing Machinery 1991.andM;</JOURNAL><TITLE>The GemStone object database management system. (Servio's GemStoneobject-oriented database management system; one of six articles onnext-generation database systems)</TITLE><AUTHOR>Butterworth, Paul; Otis, Allen; Stein, Jacob.andM;</AUTHOR><SUMMARY>Servio's GemStone object-oriented data base management system(OODBMS) is designed for commercial, engineering and MIS markets.andO;The OODBMS emphasizes robustness, including low bug rate and theability to recover from system failures; active objects, whichallow a system to store, execute and manipulate behavior withobjects; multiple language support, including alternatives to C++;and tools that allow a faster return on investment.andP;  GemStoneevolved through a series of releases.andP;  The first release providedthe foundation for later releases.andP;  It ran on DEC VAXes under VMSand allowed automatic maintenance of to six replicates of thedatabase on the network.andP;  Release 2.0 supported heterogeneousnetworks of workstations.andP;  The third release includes multivolumedisk support.andP;  The GemStone Smalltalk Interface, Visual SchemaDesigner and performance measurements are also examined.andM;</SUMMARY><DESCRIPT>Company:   Servio (Products).andO;Topic:     Data Base DesignC Programming LanguageAnalysisData base management systemsObject-oriented data bases.andO;Feature:   illustrationchart.andO;Caption:   GemStone release 1.0. (chart)Replicate distribution. (chart)GemStone releases 2.0 and 2.5. (chart)andM;</DESCRIPT><NOTE>Only Text is presented here; see printed issues for graphics.andO;</NOTE><TEXT>GemStone, a commercially available object database management system (ODBMS),was developed to satisfy the needs of the commercial and MIS markets as wellas the engineering market.andP;  Therefore, several distinct areas are emphasized:andM;1)  Robustness which includes a low bug rate; the ability to easily recoverfrom media, process and processor failure while maintaining highavailability; and being able to support large amounts of data.andM;2)  Active objects, the ability to store, manipulate, and execute behavior(methods or procedures that operate on objects) within the database.andP;  Webelieve this to be critical in order to bring the full advantages of objecttechnology to database users.andM;3)  Multiple language support.andP;  While C++ is becoming the object-orientedsystems programming language of choice, we believe there must be alternativesfor the commercial and MIS marketplaces.andM;4)  Tools to allow a much faster return on investment.andP;  While theproductivity, shareablity and maintenance benefits of object technology arelarge, the time-frames in which they have been realized to date are often toogreat to justify in today's business environment.andM;In order to achieve these goals, in particular robustness, GemStone hasevolved through several releases.andP;  By examining the considerable evolution ofthe architecture of GemStone through three of its releases, we hope to showhow such an evolutionary approach is preferable to a &quot;shotgun&quot; approach.andP;  Ourdevelopment philosophy is to build upon our previous implementationexperience in order to bring robust functionality to the marketplace.andM;Distribution, high availability and scalability may well be the mostdifficult aspects of a database management system with regard to developmentand successful deployment.andM;Distribution is perhaps the most difficult of the three.andP;  On a fundamentallevel, there are many definitions of distribution.andP;  In addition, distributionis a solution--not a problem.andP;  It is our experience that many potential usersof object database management systems, and relational systems for thatmatter, often lose sight of this fact.andP;  Among the problems for whichdistribution is a solution are managing large amounts of data, and severalcomponents of high availability.andP;  These components are media failure, machinefailure and network partitioning.andM;It is interesting to note that distribution and replication of a singlelogical database are sufficient to address these issues.andP;  One valid scenariojustifying federated distribution (cooperation among several logicallyindependent databases) is when it becomes necessary to treat pieces of adatabase as independent components.andP;  For example, federated distribution isuseful in wide area networks and when parts of a database must be takenoff-line and physically transported.andP;  It is also useful when severalapplications have very little overlap in the data they access.andP;  With afederated database, each application can have its own database andoccasionally accesses the databases of other applications.andM;As the experience of the relational vendors has shown, implementing robustfederated database management systems is extremely difficult.andP;  On the otherhand, market pressures push vendors toward attempting to implement federateddistribution all at once.andP;  Our development philosophy at Servio Corporationhas led us to an evolutionary approach to federated distribution, highavailability and scalability.andP;  This is not to say that GemStone was notdesigned for federated distribution, high availability and scalability.andP;  Butrather that we have decided to implement these features in an evolutionarymanner.andM;We believe this will become apparent in the presentation of the evolution ofGemStone's architecture.andP;  Servio has also paid considerable attention toproviding the ability to distribute data server computation across a networkof heterogeneous machines.andP;  Following the presentation of the evolution ofGemStone's architecture, GemStone's various language interfaces and toolswill be described in this article.andM;ArchitectureandM;The basic components of the GemStone architecture that have remainedconsistent throughout are the Gem server process and the Stone monitor.andP;  TheGem server is where object behavior specified in GemStone's data manipulationlanguage (DML) is executed.andP;  Within the server are both object and pagecaches.andP;  Query evaluation occurs within the server.andP;  The Stone monitor hasalways been the process that allocates new object identifiers (which areallocated in blocks to prevent the monitor from becoming a bottleneck).andP;  TheStone monitor has also always coordinated commit activity.andP;  Each Gem serverautonomously performs all actions necessary to commit a transaction.andP;  Themonitor coordinates such activity by multiple Gems.andM;First ReleaseandM;This release of GemStone provided the cornerstone functionality of the systemupon which subsequent releases were based [6].andP;  Release 1.0 ran on DEC Vaxmachines under VMS and made use of the Vax VMS cluster distributed filesystem to allow automatic maintenance of up to six replicates of the databaseacross the network.andP;  The ability to distribute replicates across the networkaided in recovery from processor failure, enabling the machine on which areplicate resides to assume the functionality that resided on the failedprocessor.andP;  This ability also allowed data processing to resume in the eventthat the machine on which the database resided should become inaccessiblefrom the network.andP;  Client applications could be run on IBM PCs in addition toVax machines.andM;In this release, collection of garbage in the committed database wasperformed off-line using a mark-sweep algorithm, requiring that the monitorand all server processes be stopped.andP;  Likewise, database backup required thatthe system be stopped.andP;  The release fully supported referential integritychecks that prevented dangling references (references to nonexistentobjects).andM;Release 1.0 contained both object- and page-level caches within the Gemserver.andP;  Reachability information was used for garbage prevention.andP;  Objectsthat have been created during the current transaction and cannot be accessedtransitively from the current state of some object in the database aretemporary.andP;  In Release 1.0, reference counting was used to identify thesetemporary objects in the object cache and ensure that they did not migrate todisk.andP;  Reference counting suffers from its inability to identify cycles oftemporary objects.andM;Concurrency control was optimistic and implemented via shadowing.andP;  Withoptimistic concurrency control, objects need not be locked.andP;  At commit,read/write conflict detection with other Gems that have committed since thelast commit by the Gem process is performed (a new Gem process is treated asthough it had completed a transaction at startup).andP;  If no conflict isdetected, then the updates performed by the Gem are committed to thedatabase.andP;  Otherwise, the commit fails and the Gem has the option of abortingand beginning a new transaction.andM;In shadowing, data pages in the database are not directly written by servers.andO;Instead when a page is to be modified, a copy of the page, not the original,is updated.andP;  At transaction commit, dirty (written) data pages in the serverare replaced by their modified copies.andP;  The original data pages are notdisposed of until all transactions that have read them have either committedor aborted.andP;  In this manner, every Gem has a consistent view of the databasefor the duration of every transaction.andP;  In the event of an abort, themodified copies are thrown away.andM;In order to ensure the all-or-nothing behavior expected of commit protocols,the object table (used to maintain the mapping between object IDs andobjects) is organized into a tree.andP;  Thus, the only action required at committo replace dirty data pages is to replace the old object table root with thenew object table root.andP;  To mitigate against process, processor and mediafailure at commit, two copies of the object table root are maintained in thedatabase.andP;  In the event of failure, if the two copies are different, then theolder of the two is used at database restart, and the unsuccessfullycommitted data pages can be reclaimed using the newer of the two roots.andM;In summary, the use of optimistic concurrency control and shadowing providesthree key advantages.andP;  One, the use of optimism does not require the lockingof either objects or pages, and deadlocks cannot occur.andP;  Two, the use ofshadowing provides each transaction with a consistent view of the database:updates performed by a transaction are not available to other transactionsuntil transaction commit, and updates performed by other transactions are notvisible until transaction commit or transaction abort.andP;  Three, the use ofshadowing also provides protection against process, processor and mediafailure.andM;Release 1.0 provided facilities for indexing, queries, clustering, andmanaging large objects.andP;  GemStone provides path indexes [7] where forexample, an employee's department's size can be indexed directly from acollection of employees.andP;  These indexes are used to speed the evaluation ofqueries.andP;  Clustering is the placement of objects next to each other withinthe same page, or within contiguous pages.andP;  Objects that are clusteredtogether can be efficiently retrieved from the database with a minimum numberof disk accesses.andP;  GemStone provides a flexible fine-grain mechanism forclustering together groups of objects that are frequently accessed together.andO;Objects that are larger than a page are decomposed into several pieces.andP;  Inthis manner a portion of a large object can be accessed without the need toretrieve the entire object.andM;The GemStone data description language (DDL) and data manipulation language(DML) are object languages supporting message passing, encapsulation ofbehavior, a class hierarchy, inheritance and object identity.andP;  The definitionof classes, the class hierarchy, and the code that defines behavior arestored within the database.andP;  This information is available at run time, andconstitutes what is often referred to as an &quot;active data dictionary.&quot;andP;  TheDML is computationally complete in the sense of a programming language and incontrast to SQL (which for example lacks iterators and recursion).andP;  Theability to store, manage and execute behavior within the database itselfprovides a strong basis for an object-oriented application development anddeployment environment.andP;  The GemStone DML is described in greater detaillater in this article.andM;Figure 1 shows a possible running configuration of Release 1.0.andP;  In thisconfiguration, two Gem servers and a Stone monitor are running on a Vax,while a Windows Programming Environment is running on a PC.andP;  There is onereplicate of the database on the Vax.andP;  In this configuration, a C applicationprogram and the Gem server to which it is connected are executing on the Vax.andO;In this release all disk accesses were routed through Stone to the VMS filesystem.andP;  The Windows Programming Environment and the Gem server to which itis connected are running on different machines.andM;Figure 2 shows another possible running configuration of Release 1.0.andP;  Inthis configuration, a replicate is maintained on a different Vax than the oneon which the database resides, and a C application program running on thesecond Vax is connected to a Gem server on the first Vax.andM;Second ReleaseandM;By Release 2.0, GemStone supported heterogeneous networks of workstations.andO;Gem servers had been ported to Sun 3, Sun 4, Sony NEWS, DECstation and RS6000 machines.andP;  GemStone client interfaces, which now included C++ andSmalltalk (Smalltalk-80 and Smalltalk/V), were ported to Macintosh machines.andM;As expected, funneling all disk I/O through the Stone monitor had proved tobe a bottleneck in Release 1.0.andP;  By Release 2.0, Gem servers running on themachine on which the database resided performed I/O directly through the hostfile system.andP;  Gem servers could be run within a heterogeneous network onmachines other than the one on which the database resided.andP;  This abilityallows database operations that are logically performed within the server tobe distributed across a network.andM;In order to support replicates and remote servers across a heterogeneousnetwork of machines, a page server process had been introduced.andP;  The pageserver implements a subset of Network File System (NFS) functionality withbetter performance and correct handling of multiple writers.andP;  Gem serversmitigate between different disk storage formats on different machines uponreceipts of pages from the page server process.andM;C application programs were able to link directly to their Gem server.andP;  Theability to link client applications to the server improves performance byreducing process switching overhead.andP;  Client application programs need not beaware of whether or not they are linked to their Gem server.andP;  While relinkingmay be required, there is no need to alter source code or recompile to movefrom one configuration to the other.andM;Release 2.0 introduced several performance and availability features to thesystem.andP;  In previous releases, Gem servers accessed database pages on themachine the database was located on, even if there was a replicate on thesame machine as the Gem was running on.andP;  Beginning with Release 2.0, Gemservers could access the local replicate to retrieve database pages.andM;The garbage prevention algorithm was improved to make use of a generationscavenging algorithm, which in addition to preventing garbage, aided inmaintaining a good working set within the object cache (in the sense thatobjects in older generations have been frequently accessed over a long periodof time).andM;The mark sweep, full backup and incremental backup mechanisms were modifiedto allow them to run on-line.andP;  These modifications made GemStone a highlyavailable system in that the system could be used in situations that required24-hour uptime.andM;While optimistic concurrency control initially proved adequate, it was clearthat optimistic concurrency control alone would not suffice.andP;  The advantageof transparency to the application has to be weighed against the amount ofwasted processing and resource consumption caused by failed commits.andO;Therefore, an object-locking protocol was introduced in Release 2.0 andlsqb;9andrsqb;.andO;While the details of this mechanism are beyond the scope of this article, thelocking mechanism essentially guarantees an application that there will be noconcurrency conflict on objects by presenting a locked object to othertransactions as though it had been read or written at the time the lock wasacquired.andP;  The combination of optimistic concurrency control and lockingprovides tremendous flexibility in that objects that are temporary andobjects that are unlikely to be accessed by other transactions can beaccessed optimistically, while objects that are likely to cause conflict canbe accessed pessimistically (via locking).andM;Figure 3 shows a possible running configuration of Release 2.0.andP;  Note thatthe Gem on the DECstation had direct access to the database replicateresiding on the machine.andP;  The figure shows a C++ application running linkedto a Gem server, a Visual Schema Designer running as a process separate fromits Gem server, and a Smalltalk application running as a process separatefrom its Gem server.andP;  Note that in this configuration, both the Smalltalkapplication and the C++ application have access to the same data storedwithin the database.andM;Third ReleaseandM;In previous releases the requirement that the entire database fit on a singledisk volume placed a practical limitation of approximately one gigabyte onthe size of a GemStone database.andP;  As several of our customers wereapproaching this limit, multivolume support was added to Release 2.5.andP;  Werefer to the piece of each database stored on a single volume as an extent.andO;The combination of multiple extents; on-line garbage collection and backup;and replicates allowed GemStone to be used in applications that require largeamounts of highly available data.andP;  Both database extents and replicates couldbe stored on raw file partitions, thus avoiding the overhead of the host filesystem.andM;In this release, serializability criteria could be relaxed by allowing fordirty reads (the reading of objects written by transactions that havecommitted since the transaction began).andP;  This option is selectable to thesystem administrator.andP;  The addition of this feature was done in part toprovide serializability semantics similar to those expected by many users ofrelational systems.andM;Cache management was altered in Release 2.5 to improve performance.andO;Previously, objects retrieved from the database were often present twice inthe caches: once in the page cache and once in the object cache.andP;  Now,objects retrieved from the database are present only in the page cache.andP;  Theobject cache is used for objects created by the transaction.andP;  Garbageprevention is applied to these objects, preventing temporary objects frommigrating to the database.andM;A versioning mechanism was introduced with Release 2.5.andP;  A full descriptionof this mechanism is beyond the scope of this article.andP;  In brief, amechanism, not a policy, is provided for versioning.andP;  While we additionallyprovide support for the policies of linear versioning and parallel versions(multiple, nonserializable versions), other versioning policies, such as ahierarchy of versions (where for example, intermediate versions betweenreleases are lower in the hierarchy than released versions) can be supportedusing this mechanism.andM;Figure 4 shows a possible running configuration of Release 2.5.andP;  In thisconfiguration, the database consists of two extents, one residing on an IBMRS600 and the other on a DECstation.andP;  Replicates of both extents aremaintained on a Sun 4.andM;Note that the Smalltalk application on the Sun machine is linked directly toits Gem server.andP;  The ability to link Smalltalk applications to Gem serversgreatly improves the performance of Smalltalk applications and was introducedin Release 2.5.andP;  The Smalltalk application reads all of its data from thereplicates present on the Sun machine.andM;The architecture of Release 2.5 is illustrative of our evolutionary approachto large amounts of data, distribution and high availability.andP;  Thecombination of on-line garbage collection, on-line database backup, extentsand replicates provides for high performance, large databases, and highavailability.andP;  As noted previously, these are often the criteria used tojustify the need for data distribution.andP;  Inasmuch as these features were anincremental, evolutionary addition to functionality already in the product,we were able to introduce them with minimal disruption to our existingcustomer base.andP;  In particular, we believe that our evolutionary approachresulted in a very low bug rate.andM;To evolve this architecture to one that is fully distributed requires threeenhancements.andP;  One, parts of the class hierarchy must be reproduced on eachextent so that the class of every object in an extent is also present in theextent.andP;  Two, application programmers must be given the means to control theplacement of objects within multiple databases (in Release 2.5, the systemadministrator controls the placement of objects across multiple extents).andO;Three, a mechanism for handling references to objects in extents that are notcurrently available must be provided.andM;Our intent with Release 2.5 was to have all of the underlying mechanisms forfederated distribution in place.andP;  In this way, we could be certain of therobustness of these mechanisms prior to implementing federated distributionon top of them.andP;  As noted earlier, another reason for this approach is thatdistribution is a solution, and not a problem.andP;  Different scenarios willrequire different solutions.andP;  If a scenario does not require federateddistribution, there is no inherent reason why the overhead of federateddistribution should be present.andP;  As another example, in some scenariostransparent distribution (where an application is not aware of the locationof an object) is required.andP;  In other scenarios this is not a requirement.andO;Our goal is to be able to provide multiple distribution models on top ofthese underlying mechanisms.andM;InterfacesandM;As noted at the beginning of this article, Servio has chosen not to focus ona single language, but rather to support multiple languages and tools for thecommercial as well as the engineering communities.andP;  In the followingsubsections GemStone's language interfaces are described.andP;  GemStone's toolsare described in the section &quot;Tools.&quot;andM;CandM;The GemStone C Interface is a library of C functions that provide a bridgebetween an application's C code and the GemStone database, allowing access tothe database either structurally (the C mode) or by sending messages (theGemStone DML model).andP;  The GemStone object server contains the database schema(class definitions) and database objects (instances of those classes), whilethe C program contains the nondatabase-related functions (e.g., thoseinvolving user interface definition and control).andM;Because the C language contains no concept of object, all objects that areimported from the GemStone database into an application program must bebroken into elements that C can handle, such as pointers, strings, orintegers.andP;  The interface thus provides functions for the following structuralaccess operations.andM;* Transfer object &quot;reports&quot; of complex structure.andP;  An object report providesinformation about an object's identity, class size, segment, implementation,and instance variable values.andM;* Translate between the host independent representation of primitive dataused in the database and the host-dependent representation used in theapplication.andM;* Create new database objects.andM;* Access and modify the internal contents of database objects.andM;The C interface also supports a second, more object-oriented, mode of accessto the database.andP;  In this mode, the application uses the DDL/DML capabilitiesof GemStone to create new classes and define new methods, to executeexpressions, or to send messages to objects in the database.andM;Finally, computationally intensive functions may be written in C or C++ andadded to the DML.andP;  These functions are called user actions in GemStone, andare similar to user-defined primitives in other systems.andP;  Functions areprovided to install user actions in GemStone, to verify that they have beeninstalled, and to execute them from the DML.andM;Developing a C application involves defining the application's externalinterface, deciding whether to import the representation of objects into theC program or to send messages that invoke DML methods; implementing theC-based functions; and linking and testing the application.andM;C++andM;The GemStone C++ interface provides both persistent storage for C++applications and access to persistent objects stored in GemStone byapplications written in other languages.andP;  C++ objects stored in GemStone takeon identity and exist independently of the program that created them and canlikewise be used by other database applications, including those written inother programming languages.andM;The interface is implemented as a preprocessor based on standard C++ syntax,and is provided in both remote procedure call (RPC) and linkable versions.andO;(Note that switching between RPC and linkable configurations does not requireany changes to the source code.)andP;  In addition, a class library is provided,giving the programmer a standard set of definitions for commonly used datastructures (e.g., sets, arrays, bags, etc.) as well as functions for managingand manipulating GemStone data with C + + code.andP;  For the most part, classesin this library correspond to classes in GemStone.andM;New persistent C++ classes are defined by declaring them in a header fileusing standard C + + syntax.andP;  Then, to make the new class known to GemStone,the header file is submitted to a utility called the Registrar.andP;  TheRegistrar logs into GemStone, stores the new class definition, and thengenerates code that maps between the C + + class and its correspondingGemStone class.andP;  The Registrar provides a bridge between the C++ code and theGemStone database by producing two files: a file that contains the mappingcode and a file that contains some initialization constants and additionalclass definitions.andM;The C + + interface maintains a hash table of the location within virtualmemory of C + + objects managed by GemStone.andP;  The table is indexed by objectidentifier.andP;  The size of the hash table is user-configurable.andP;  A modifiedleast recently used (LRU) algorithm is applied to the hash table to managethe swapping of C + + objects.andP;  In this manner a reasonable working set ofmanaged objects is maintained and disk I/O activity at database commit isreduced.andM;In the memory management scheme provided by the C + + interface, objects arecached transparently and are fetched from the database on demand (i.e., theyare dynamically faulted into the program cache from the database if notalready present in the application when a pointer is dereferenced).andP;  Underthis memory management scheme, the programmer can code normally without theneed to pay undue attention to the fact that C++ objects are being managed byGemStone.andM;Instances of classes registered with GemStone may be referrenced by twodistinct types of pointers.andP;  GPointers are object identifiers and aretransparently dereferenced via the hash table.andP;  DPointers (direct pointers)point directly to the virtual memory location of objects.andP;  When a GPointer isconverted to a DPointer, the object's location within virtual memory ispinned, thus assuring the validity of the DPointer.andM;Transient (temporary) objects that are not maintained in the hash table canbe created using DPointers.andP;  Objects so created can later be converted topersistent database objects.andP;  In this manner, method functions need not becoded twice (once for persistent objects and once for transient objects),managed objects may refer to transient objects with a C + + program, andtransient objects may refer to managed objects.andP;  Thus, persistence isorthogonal to type within the C + + interface.andM;SmalltalkandM;The GemStone Smalltalk Interface is a set of classes installed in a Smalltalkimage that permits a user to access and modify objects in the GemStonedatabase.andP;  These classes include GSSession, GSObject, GSObjectTraversal andGSObjectReport.andP;  The Smalltalk interface was introduced with Release 1.5 ofGemStone.andM;Each instance of GSSession represents a GemStone database session.andP;  Itsmethods provide control over the connection to the GemStone database,transactions, and cooperative session management.andP;  GSObject is a class whoseinstances represent GemStone database objects in the Smalltalk object space.andO;These &quot;proxy&quot; objects are creted automatically any time an object is fetchedfrom a GemStone database.andP;  GSObjectTraversal is a class whose instances arebuffers containing descriptions of objects, obtained by invoking one ofGSObject's object traversal methods.andP;  Each instance of GSObjectReportdescribes an entry in a GSObjectTraversal and holds information about aGemStone object and its values.andM;A Smalltalk program gains access to named GemStone objects by sending amessage to a GSSession to return a proxy for the database object.andP;  Throughthese proxies, Smalltalk objects can send messages to GemStone objects,replicate the state of GemStone objects in the Smalltalk environment and viceversa and obtain structural access (that is, access without DML messagepassing) to GemStone objects.andM;Release 3.0 of the Smalltalk interface provided major  enhancements.andP;  Theseenhancements are focused on the transparency of the interface and support ofprocessing distributed between a Smalltalk application and its Gem server.andO;In the earlier versions of the interface, application programmers needed tobe intimately involved in the process of translating Smalltalk classes andmethods to their GemStone representations and vice versa.andP;  Applicationprogrammers also needed to be conscious of the possibility that a copy of aGemStone object and the GemStone object in the server may not besynchronized.andP;  For example, if a GemStone object were copied into a Smalltalkapplication and modified, then a subsequent execution of behavior in theserver that accessed that object would see a different value of the objectthan the value in the Smalltalk application.andP;  Often this resulted inapplication that either used Gem solely as a structure server, or that usedSmalltalk only for data display and input.andM;Release 3.0 of the Smalltalk interface addresses both of these issues.andP;  Inaddition to more robust automatic translation between Smalltalk and GemStoneobjects and methods, tools are provided to allow the application programmerto specify custom translation policies.andP;  GemStone objects that have beencopied into a Smalltalk application and modified can optionally be flushed tothe server.andP;  This flushing can be performed explicitly or a switch can be setto perform the flush automatically at the invocation of server behavior.andO;Upon completion of the execution of server behavior, the server can be askedto return a list of the objects IDs of objects cached in the Smalltalkapplication that have been modified by the server.andP;  We anticipate adding moresophisticated mechanisms for maintaining consistency between the values ofobjects and their replicates in a Smalltalk application.andP;  For example,instead of flushing the values of modified objects to the server, a list ofobject IDs modified by the Smalltalk application might be sent.andP;  In thismanner, the server could lazily fetch the modified values of these objectswhen and if they are accessed in the server.andM;Gemstone Data DescriptionandM;Language/Data ManipulationandM;Language (DDL/DML)andM;GemStone's DDL/DML is a Smalltalk variant that runs in the database's object(or address) space.andP;  It is a computationally complete language and runs onServio's proprietary multiuser virtual machine (part of the Gem serverprocess which is written in C).andP;  Its three main components are object,message, and method (corresponding loosely to record or struct, procedurecall, and procedure for languages such as Pascal or C).andP;  Objects have a stateand an interface and communicate with each other by sending messages.andP;  Theset of messages to which an object responds defines its interface and iscollectively called its protocol.andM;Objects are grouped together into classes based on common structure andprotocol.andP;  Classes are organized into an &quot;Isa&quot; hierarchy, rooted at theObject class.andP;  The GemStone class hierarchy is similar to that found inSmalltalk with the following differences: classes for file access,communication, screen manipulation, and the Smalltalk programming environmenthave been removed, while classes for transaction control, accounting,ownership, authorization, replication, user profiles, and index control havebeen added.andP;  The class hierarchy is extensible, and new classes may be addedas required to model an application.andM;Relational GatewaysandM;GemStone's relational gateways were motivated by customer demand for SQLsupport within GemStone.andP;  When asked whether SQL access to objects stored inGemStone, or SQL access to external databases was of greater importance, thenear universal response was thtat the latter was of greater importance.andP;  Thefirst gateway to Sybase was available with Release 2.0 of GemStone.andP;  As ofRelease 3.0, additional gateways to Ingres, Oracle and Informix areavailable.andP;  The primary purpose of the gateway is to provide interoperabilitywith relational databases by allowing the results of SQL queries to be viewedas objects.andM;When an SQL command executed through a relational gateway is one that returnsrows, GemStone translates the resulting rows into objects.andP;  The translationis complete in that the attributes corresponding to the columns in thereturned rows also appear as objects within GemStone.andM;The gateways provide the flexibility of allowing the result rows of an SQLcommand to be viewed either through a relation object or, using thetraditional mechanism of a cursor that iterates over the result rows, asindividual objects.andP;  When accessed as a relation, GemStone's set manipulationfacilities can be further applied to the result.andP;  For example, a resultrelation object can be sorted and indexed.andM;In order to be useful in a wide variety of applications, anobject-to-relational gateway must also manage the translation of relationalschemes to object classes.andP;  A gateway that can only present the result of aquery as an instance of a generic row or relation class makes it difficult todevelop methods that operate on query results.andP;  GemStone's gateway providegeneric row and relation classes, and allow the user to define specializedsubclasses of these row and relation classes.andP;  Generic row and relationclasses are especially well suited for ad hoc queries.andP;  Specialized row andrelation classes allow substantial applications to be built using thegateway.andM;ToolsandM;Visual Schema DesignerandM;The GemStone Visual Schema Designer (GS Designer) allows the user to create,modify and delete GemStone class definitions using a mouse and keyboardinterface and bitmapped graphics in a windowing environment [1, 2].andP;  GSDesigner utilizes state-of-the-art user interface primitives, includingicons, scroll bars, pulldown and popup menus, buttons, and graphicalinteraction for an easy-to-use, intuitive interface to operations.andP;  The usercreates classes interactively and may define instance variables andrelationships either by filling out a template form or by graphically drawingrelationship arcs between rectangles that represent classes.andP;  The user canmove the class rectangles around for an aesthetic layout, and relationshiparcs rubberband correspondingly.andP;  One can also selectively display or hiderelationships between objects.andP;  In addition, the tool provides browsing ofexisting GemStone classes and the ability to import them into the new schema.andM;The main organizing principle of GS Designer is the class graph.andP;  A classgraph is a named collection of classes related to one another by variouskinds of relationships.andP;  These relationships include generalization (realizedby the superclass/subclass hierarchy), aggregation, and association.andP;  Allclasses are part of a single superclass/subclass hierarchy, rooted at classObject, so any class graph that the user creates or manipulates is a subgraphconnected to the class hierarchy, although these connections may not bedisplayed.andP;  Class graphs are used to partition all the classes of anapplication schema into logical subdivisions.andP;  Within a class graph,relationships between classes may selectively be displayed or hidden.andP;  Thus,a class graph is an unusually versatile mechanism for viewing the meta-dataof an application.andM;Figure 5 shows the three windows available in GS Designer.andP;  The lower-leftwindow is the schema window.andP;  It contains icons for every class graph in theschema, including four class graphs containing the GemStone base classes(these are labeled Collections, Magnitudes, Objects, and Streams).andP;  The threeicons labeled all, bom, and partDetail are class graphs representing views ofthe entire parts example schema.andP;  The lower-right window shows the bom classgraph in its open state.andP;  In this window, each rectangle represents a class,and arrows between the rectangles represent relationships (generalization,constrained collection, and single and multivalued instance variables forclass).andP;  The top-left window is a class form for a BasePart class.andP;  It allowsthe user to define or browse information about a class textually.andP;  Note thatchanges in one of these GS Designer windows is dynamically updated in allother windows.andM;Classes may appear in more than one class graph in GS Designer, and changesto a class definition in one graph may have effects in other class graphs,depending on which aspects of the class definition are being shown in theseother class graphs.andM;Tool SuiteandM;Introduced with release 3.0, the tool suite integrates a high-levelapplication development environment with a visual programming environment.andO;The suite supports OSF/Motif and Sun's OpenLook, with support for MicrosoftWindows under development.andM;The application environment supports the construction of sophisticatedgraphical forms connected automatically to objects in the database.andP;  Byreading the class definitions and attached data dictionary information fordatabase objects, the application environment can create default forms ofconsiderable complexity.andP;  The default forms contain enough runtime logic tobe able to provide basic data-entry capabilities without making any changes.andO;A default form on a collection of employees is shown in Figure 6.andM;Starting from this base, the user can customizee the forms, assemble formsinto applications, add additional program logic in a number of ways, andaugment or alter the form's attachments to the database.andP;  Graphical tools areprovided to support all of these activities.andP;  Application folders are used toassemble the classes, instances, and forms to be used in an application.andP;  Anapplication browser allows for an overview of the sequencing of forms in anapplication.andP;  A form designer allows for structural and cosmetic arrangementof object fields and other user interface elements on a form, for bringingadditional objects up onto a form, and for attaching behavior to pieces ofthe form.andP;  A visual program designer allows for graphical programming offorms and form components.andP;  Other tools support and augment the capabilitiesof these tools.andM;The visual program designer allows applications to be developed withoutwriting code.andP;  Processing logic or behavior is represented visually on adesign canvas.andP;  Program blocks are connected together graphically toconstruct multidirectional dataflow networks.andP;  These can be very simple orvery complex.andP;  A network that computes average salaries and creates a bargraph of salaries is shown in Figure 7.andM;The base product includes a number of progam-building blocks that encapsulatespecific kinds of processing and behavior, including collection interation,field display and update, form traversal, simple computations, and basicbusiness graphics.andP;  These can be further specialized by subclassing them, byaccessing external databridges, or by making composites.andP;  A composite is acollapsed representation of a previously constructed program unit.andP;  Thisallows easy reuse of complex program elements, which have themselves beencreated visually.andM;We anticipate that within a given organization, a small group of databaseprogrammers will develop additional program-building blocks, and that mostprogrammers in an organization will program directly in the visual programdesigner.andM;The most powerful aspect of this tool suite is its complete integration withthe database.andP;  By taking advantage of GemStone's ability to store databasebehavior within the database itself, we are able to store all applications,forms, code and visual programs directly in the database.andP;  This provides anumber of features not readily available in other architectures:andM;1) Default forms can be built from existing objects or class definitions.andM;2) The forms designer can show live databse objects in the forms while theyare being developed, making it easier to visualize the forms in use.andM;3) At any point in the construction of an application, any piece of theapplication can be run and tested against live data.andP;  It is not necessary toconstruct a test shell first, or to complete the application.andP;  This allowsfor fast verification of application components.andP;  There is no compilation orlinking involved--the tools provide instant testing services.andM;4) When running, forms have direct connections to the database--expensivetransfers in and out of the database are not necessary.andM;5) Application developers do not need to port their applications.andO;Applications are built against a portable, environment-independent layer ofclasses, and thus are self-porting.andP;  This independence applies to bothwindowing environments and machineandM;TABLE 1.andM;Results of Running Cattell/Skeen Benchmark [5] against GemStone 2.5 on a Sun4/60.andM;Measure      Small Local Database   Small Remote DatabaseandM;Lookup Cold             6.3                     9.3andM;Traverse Cold           5.5                    10.5andM;Insert Cold             3.3                     7.3andM;Lookup Warm             0.12                    0.12andM;Traverse Warm           0.10                    0.10andM;Insert Warm             2.2                     2.7andM;types: an application will run with a native look and feel on any machine towhich the GemStone client interface has been ported.andM;Performance MeasuresandM;Object database management systems challenge traditional benchmarkingmethodologies in several ways.andP;  For example, a true ODBMS includes acomputationally complete DML.andP;  Traditional database benchmarks do not stressor test the completeness of the DML.andP;  When a computationally complete DML ispresent, measuring low-level structural access is not a valid indicator ofthe run-time performance of applications built using the system.andP;  What is ofgreater interest is the performance of complete application-level operations.andO;Additionally, low-level structural access will not distinguish betweenstructure servers that often need to ship vast amounts of data across thenetwork to an application in order to perform an operation, from ODMBSscapable of executing operations within the server itself and thus drasticallyreducing the volume of remote disk access required to complete an operation.andO;Running the same low-level structural access benchmark using a remote serverover an unloaded network will also fail to distinguish ODBMSs from structureservers.andM;Considering the above, the Cattell/Skeen benchmark [5], is the only benchmarkto date that has been run against several ODBMSs.andP;  The benchmark was intendedto compare object database management systems with relational databasemanagement systems in engineering applications.andP;  Table 1 contains the resultsof running the benchmark against GemStone 2.5 running on a Sun 4/60.andP;  Alltimes are in seconds.andM;ConclusionandM;The needs of commercial and MIS markets often differ dramatically from thoseof the engineering market.andP;  For example, engineering applications are oftenmigrated from proprietary file systems when object database managementsystems are adopted.andP;  Accordingly, many of the amenities that relationaldatabase users have come to expect are not immediately expected.andP;  Also,engineering groups tend to do systems programming, and can often wait untilexpected deployment of the application under development for databasefunctionality to be robust.andP;  The application development time is often on theorder of a year or two.andM;On the other hand, commercial applications, such as order entry systems,often need to be developed and deployed within a much shorter time frame.andO;Therefore, commercial organizations need robust database management systemswithin a much shorter time frame.andP;  Similarly, commercial organizations needhigher programmer productivity than engineering organizations.andP;  Coding in asystems programming language is usually not adequate for these organizations.andM;We have attempted to show that Servio Corporation's GemStone, through itsattention to multiple languages, active objects, and tool support, and itsevolutionary development strategy, has addressed these needs of commercialorganizations.andP;  We expect that in the future these will also be the needs ofengineering organizations.andM;ReferencesandM;andlsqb;1andrsqb; Almarode, J.andP;  Issues in graphical user interfaces for schema design.andO;Submitted for publication, 1990.andM;andlsqb;2andrsqb;  Almarode, J. and Anderson, T.L.andP;  GemStone visual schema designer: A toolfor object-oriented database design  IFIP TC 2.6 Working Conference on ObjectOriented Databases: Analysis, Design, and Construction, Windemere, UnitedKingdom, July 1990.andM;andlsqb;3andrsqb; Atkinson, M.P.andP;  and Buneman, O.P.andP;  Types and persistence in databaseprogramming languages.andP;  ACM Comput.andP;  Surv.andP;  19, 2 (June 1987).andM;andlsqb;4andrsqb;  Bretl, B., Otis, A., Penny, J., Schuchardt, B., Stein, J., Williams,E.H., and Williams, M.andP;  The GemStone Data Management System, Object-OrientedConcepts, Applications, and Databases.andP;  W. Kim and F. Lochovsky Eds.,andO;Addison-Wesley, 1989.andM;andlsqb;5andrsqb; Cattell, R.G.G.andP;  and Skeen, J.andP;  Object operations benchmark.andP;  ACM Trans.andO;Database Syst.andP;  To be published.andM;andlsqb;6andrsqb;  Maier, D., Stein, J., Otis, A. and Purdy, A.andP;  Development of anobject-oriented DBMS.andP;  In Proceedings of OOPSLA '86 (Portland, Ore., Sept.andO;1986).andM;andlsqb;7andrsqb; Maier, D. and Stein, J.andP;  Indexing in an object-oriented DMBS.andP;  InProceedings of the International Workshop on Object-Oriented Database Systems(Pacific Grove, Calif., Sept. 1986).andM;andlsqb;8andrsqb; Maier, D. and Stein, J.andP;  Development and implementation of anobject-oriented DMBS.andP;  Research Directions in Object-Oriented Programming.andO;B. Shriver and P. Wegner Eds., MIT Press, 1987, and in: Readings inObject-Oriented Database Systems.andP;  S.B.andP;  Zdonik and D. Maier Eds., MorganKaufmann Publishers, 1990.andM;andlsqb;9andrsqb; Penney, D.J.andP;  and Stein, J.andP;  Class modification in the GemStoneobject-oriented DBMS.andP;  In Proceedings of OOPSLA '87 (Orlando, Fla., Oct.andO;1987).andM;andlsqb;10andrsqb; Penney, D.J., Stein, J. and Maier, D.andP;  Is the disk half full or halfempty?andP;  Combining optimistic and pessimistic concurrency control mechanismsin a shared, persistent object base.andP;  In Proceedings of the Workshop onPersistent Object Stores (Appin, Scotland, Aug. 1987).andM;andlsqb;11andrsqb; Purdy, A., Maier, D. and Schuchardt, B.andP;  Integrating an object serverwith other worlds.andP;  ACM Trans.andP;  Off.andP;  Inf.andP;  Syst.andP;  5, 1 (Jan.andP;  1987).andM;PAUL BUTTERWORTH is consultant to Servio Corporation.andP;  His research interestsinclude distributed object management and on-line transaction processingdevelopment environments.andM;ALLEN OTIS is a senior member of Technical Staff at Servio Corporation.andP;  Hisresearch intersts include concurrency control, storage management and schemamodification for ODBMSs.andM;JACOB STEIN is chief technologist at Servio Corporation.andP;  His researchinterests include data models, transaction management and associative accessfor ODBMSs.andO;</TEXT></DOC>