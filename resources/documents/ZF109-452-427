<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF109-452-427  </DOCNO><DOCID>09 452 427.andM;</DOCID><JOURNAL>Microsoft Systems Journal  Sept 1990 v5 n5 p75(16)* Full Text COPYRIGHT The Microsoft Corporation 1990.andM;</JOURNAL><TITLE>Learning Windows part II: resources and the menuing system.andO;(tutorial)</TITLE><AUTHOR>Adler, Marc.andO;AttFile:   MSJ\V05N05\WINTRO2.EXE;2 Program:  WINTRO2.EXE  Self extracting archive.andM;</AUTHOR><SUMMARY>A previous article in the series demonstrated the message-basedarchitecture for Windows and how the program uses a message loopto maintain cooperative processing among various tasks running ina session.andP;  Here the main window is created and a menu systemadded to it.andP;  Creating a complete pull-down menu system requiresonly that the menu be defined in the application's resource file;also discussed are menuing systems and the application programminginterface (API) functions and messages associated with them.andO;Shortcut keys, called accelerators, are also described that allowany command in an application to be invoked.andM;</SUMMARY><DESCRIPT>Product:   Microsoft Windows 3.0 (Graphical user interface) (usage).andO;Topic:     Programming InstructionProgram Development TechniquesMenusSoftware DesignGraphical User InterfaceTutorialWindowing.andO;Feature:   illustrationprogram.andO;Caption:   STOCK.RC. (program)Menu definition syntax. (program)Using CreateWindow. (program)andM;</DESCRIPT><TEXT>Learning Windows[TM] Part II: Resources and the Menuing SystemandM;The first article in this series introduced the concepts behind programmingan application for the Microsoft Windows[TM] graphical environment.andP;  Itdemonstrated the message-based architecture of Windows [1] and showed howWindows uses a message loop to maintain cooperative processing among thevarious tasks running in a session.andP;  I defined a window as not only a visualobject in which data is displayed, but also as an object that receives andprocesses messages.andP;  Each window has a message handler, called a windowprocedure, that processes the messages sent to it.andM;While the first article contained some initialization code, I really did notbegin writing the sample stock-charting application.andP;  In this issue, I willcreate the main window and add a menu system to it.andP;  The user will choose acommand from the menu, the command will be sent to the main window, and themain window will respond in some way.andM;All that you need to do to create a complete pull-down menu system is definethe menu in the application's resource file.andP;  Resource files are thereforethe first items I'll discuss.andP;  Next, menuing systems and the API functionsand messages associated with them are described.andP;  Finally, I'll discussshortcut keys, called accelerators, that permit the user to invoke anycommand in your application.andM;ResourcesandM;A resource is a binary description of a Windows object.andP;  Windows resourcesinclude dialog boxes, menus, strings, accelerators, fonts, icons, bitmaps,cursors, and user-defined binary data.andM;A resource file is an ASCII text file that contains an English-likedescription of the resources used by an application.andP;  This file contains theactual definitions of some of the resources such as menus, strings,accelerators, and dialog boxes.andP;  Other resources, such as icons, fonts, andbitmaps, cannot be defined in ASCII.andP;  Therefore, the ASCII resource filecontains the names of files in which these resources are stored in binaryform.andM;The non-ASCII resources must be created with special tools.andP;  For a bitmapimage, for example, you can use the SDKPAINT program in the Windows 3.0Software Development Kit (SDK).andP;  After you have created the bitmap image, youcan use a good old text editor to modify the resource file yourself, adding areference to the bitmap file you've just created.andP;  The resource file usuallyhas the same name as the application but has an RC extension.andM;After an RC file is made, it must be &quot;compiled&quot; into a binary resource file.andO;Binary images of resources are much faster to load into an application thanASCII resource descriptions because the application doesn't have to interpretthem.andP;  The resource compiler generates binary images from the resourcesdefined in ASCII format and combines these with the binary images stored inexternal files.andP;  The result is a file with a RES extension.andP;  To compile theRC file into a RES, invoke the Windows Resource Compiler (RC.EXE) on theresource file using the -r option.andM;rc -r app.rcandM;The last step in compiling and linking any Windows application is mergingtogether the binary resource file (RES) and the application's EXE file.andP;  Totack the RES file on to the EXE file, invoke the resource compiler a secondtime without the -r option:andM;rc appandM;This is the last command you invoke when building a Windows program.andM;There are several good reasons to use resources.andP;  First, a resource is notinitially loaded into memory when its application is.andP;  A resource can beloaded explicitly at the request of the application programmer, or loadedimplicitly by Windows when Windows needs the resource.andP;  This means that thememory taken up by the program is less than it would be if the resource werestored statically within the data segment.andM;Second, compiling a resource file is extremely fast.andP;  If you need to change,for example, the the layout of controls in a dialog box, all you need to dois change the RC file, recompile it with the resource compiler, tack it on tothe application's EXE file, and rerun the application.andP;  There is no need foryou to change your program's source code and then have to recompile andrelink the program.andM;Third, by isolating all of the text strings your program uses in a resourcefile, your program is much easier to adapt to a foreign language.andP;  Forinstance, if you wanted to create a Swedish version of an application, allyou would have to do is to edit the strings, menus, and dialog boxes in theresource file and recompile the resource file.andM;Now that you know what a resource file is, I will create one from scratch anddefine the pull-down menu system in it.andM;MenusandM;Most Windows applications rely on a pull-down menu system for their top-leveluser interface.andP;  Windows 3.0 improves on te standard pull-down menus.andP;  Oneaddition is hierarchical pull-down menus.andP;  Using this menu style, individualpull-down menus can be attached not only to items on the menu bar, but alsoto items on other menus (see Figure 1).andP;  This facility permits an applicationto granularize its command set better and lets the user find the propercommand more easily.andP;  It also cases the command overcrowding thatcharacterizes the pull-down menus of large, complex applications.andM;Another nice addition to the pull-down menu system is the floating pop-upmenu.andP;  These menus are not attached to a menu bar.andP;  Windows gives you theability to create or load a predefined pop-up menu and place it anywherewithin a window.andP;  For example, the user can click on a button and have a menuof choices appear over that button.andM;A menu can be activated in a variety of ways.andP;  You can click a menu bar itemwith the mouse; you can press the Alt key with the key that corresponds tothe underlined letter of a menu bar item.andP;  This combination is called ahotkey.andP;  Or you can press Alt without presing any other keys.andP;  This activatesthe menu bar, highlighting the first entry without activating an attchedpull-down menu.andP;  You can use the cursor keys to move along the menu bar,pressing Enter when you reach an item whose pull-down menu you want toinvoke.andM;The other type of menu supported by Windows is the system menu, which isusually attached to each top-level or pop-up window.andP;  It is represented by anicon in the upper-left corner of the window.andP;  Certain predefined items appearon the system menu across each class of windows.andP;  For example, everytop-level application window has a system menu with the entries Restore,Move, Size, Minimize, Maximize, Close, and Switch To.andP;  Almost all dialogboxes have a system menu with only two entries, Move and Close.andP;  Most Windowsapplications do not alter the system menu, although the Windows API providesthat option.andP;  Users expect to find certain entries in the system menu, soit's best to keep these standard throughout Windows applications.andM;Menus and Resource FilesandM;The first step in defining a menu system in the sample stock-chartingapplication is to create the resource file.andP;  I used a text editor to create afile called STOCK.RC (see Figure 2).andP;  The first line in any resource fileshould be the following:andM;#include andless;windows .andP;  handgt;andM;WINDOWS.H, the main include file used by Microsoft Windows programs, is alarge file that defines most of the constants, messages, data structures, andfunction prototypes in Windows.andP;  As far as resource files are concerned,WINDOWS.H contain the # defines of the keys used in the definitions of theaccelerator keys and the constants for the style bits used by controlwindows.andM;Now it is time to define the application's menu system.andP;  The syntax of a menudefinition is shown in Figure 3.andM;The POPUP keyword defines a pop-up menu that is activated when the userselects the associated string from a lower-level menu.andP;  The string followingthe POPUP keyword is actually placed on the pop-up menu's parent menu.andP;  Infact, most menu bars are defined as a series of pop-up menus, with eachstring associated with the pop-up menu placed in sequence in the menu bar.andM;The MENUITEM keyword defines an atomic menu item, meaning that selecting thisitem does not invoke another pop-up.andP;  The MENUITEM definition contains thetext string associated with that item, a command identifier used todistinguish a command from others in the application, and a list of menuattributes.andP;  A menu item can have several attributes associated with it thatserve as visual cues for the end user.andM;An ampersand in a menu item string indicates to Windows that the characterfollowing the ampersand will be the hotkey for that item at run time.andP;  Theampersand itself is invisible.andP;  On a menu bar, you invoke the menu bypressing Alt-character.andP;  In a pull-down menu, pressing the hotkey will movethe selection bar to that menu item.andM;One thing to note in Figure 2 is a multilevel pop-up menu.andP;  The Graphpull-down menu has an entry called &quot;andamp;Grid.&quot;andP;  Pressing Enter at this menu itemreveals a higher-level pull-down menu that prompts the user to draw thehorizontal or vertical grid lines.andP;  Windows 2.x programmers had to add twomenu items to the Graph menu, &quot;Horizontal Grid&quot; and &quot;Vertical Grid.&quot;andP;  InWindows 3.0, you need only one generalized entry for the grid, simply addinga lower-level submenu.andM;Also note that the &quot;Help&quot; menu bar item has the characters &quot;\a&quot; prefixed tothe string.andP;  A menu item with this prefix will be right-justified in the menubar.andP;  This style is usually reserved for the menu that invokes theapplication's help facility.andM;After the menu system is defined, you can run it through the resourcecompiler with the following command:andM;rc -r stockandM;Loading Menus Into and ApplicationandM;When an application starts up, a binary description of the menu system sitswithin the executable file on disk.andP;  One way to get it into memory and attachit to a window is to associate the menu with a window class.andP;  In theinitialization code presented in the previous article, you saw how toregister a window class by filling it with the elements of a WNDCLASSstructure and calling the RegisterClass function.andP;  One of the members of theWNDCLASS structure is:andM;LPSTR lpszMenuName;andM;By assigning the name of the menu to lpszMenuName before callingRegisterClass, you tell Windows that every time a window of that class iscreated, the specified menu should be loaded into memory and attached to thatwindow automatically.andP;  Recall that one of the arguments in the CreateWindowfunction was the handle of the menu that should be attached to the createdwindow.andP;  If you specify NULL for the hMenu parameter when callingCreateWindow, the class menu (if any) will be attached to that window (seeFigure 4).andM;Another way to load a menu from a resource file is to call LoadMenu.andP;  Thesyntax for LoadMenu is:andM;HMENU LoadMenu (HINST hInstance.andP;  LPSTR ipszMenuName)andM;The first argument to LoadMenu is the instance handle of the isntance of yourWindows application; the second parameter is the name of the menu in theresource file.andP;  The name of the menu, or any resource, can be either a textname or a numeric identifier.andP;  If it is a numeric value, you must use theMAKEINTRESOURCE macro in order to cast the numeric value to an LPSTR.andP;  Forexample.andM;hMenu = LoadMenu(hInst, &quot;MyMenu&quot;);andM;orandM;hMenu = LoadMenu(hInst, MAKEINTRESOURCE(ID MYMENU);andM;LoadMenu returns the handle of the loaded menu, which can then be used as thehMenu parameter in the CreateWindow call.andP;  This is how you would attach amenu other than-the class menu to a window.andM;You can also create a menu on the fly using CreateMenu.andP;  This functioncreates an empty menu and returns its handle to the application.andP;  You canthen use InsertMenu or AppendMenu to add both atomic items and pop-ups tothis menu.andM;HMENU hMenu;andM;hMenu = CreateMenu(); AppendMenu(hMenu, MF_STRING, ID_OPEN, &quot;andamp;Open...&quot;);andO;AppendMenu(hMenu, MF_STRING, ID_CLOSE, &quot;andamp;Close&quot;);andM;The WM_COMMAND MessageandM;When defining a menu system in a resource file, you saw that each MENUITEMhad a command identifier associated with it.andP;  For instance, in the menu itemdefined by the following line, the constant ID_GRAPH_VOLUME is the commandidentifier associated with the &quot;Volume&quot; menu item.andM;MENUITEM &quot;andamp;Volume&quot;,  ID GRAPH VOLUMEandM;This command identifier should be a unique number that distinguishes thecommand from any other command in the application.andM;Fortunately, Windows makes menu handling automatic, so that programmerdoesn't have to worry about polling the menu system to determine whether theuser has selected an item from a menu.andP;  When the user selects a menu item,Window simply posts a WM_COMMAND message to the window procedure of thewindow that owns the menu.andP;  If the user selects an itme from a window'ssystem menu, Windows posts the similar WM_SYSCOMMAND message to that window.andM;The previous article stated that when a message is sent to a windowprocedure, two other data elements are also passed to the window procedure.andO;These two pieces of data, wParam and lPARAM, provide the window procedurewith additional information concerning the message.andM;When the WM_COMMAND message is sent to a window, the wParam field containsthe command identifier of the command invoked.andP;  This command identifier isthe same value specified for a menu item in the resource file.andP;  By examiningthe wParam field, you can tell which menu item the user selected.andP;  And,because you know which command was sent, you can call one of your ownroutines to handle that command.andP;  A piece of skeleton code for handlingWM_COMMAND messages is shown in Figure 5.andM;WM_SYSCOMMAND MessageandM;The WM_SYSCOMMAND message is sent to a window when the user selects an itemfrom that window's system menu.andP;  Windows uses the low-order 4 bits of wParaminternally, so to determine which command was chosen, you need to logical-ANDwParam with FFF0H to mask off the low-order nibble.andP;  Some of the messages andoperations the system menu allows for a standard window are shown in Figure6.andM;Most of the time, you would let the DefWindowProc handle the processing ofthe WM_SYSCOMMAND message.andP;  However, there might be special cases in whichyou want to prevent the user from maximizing or minimizing a window.andP;  You cando this by handling the WM_SYSCOMMAND message yourself, not passing it on tothe DefWindowProc.andM;Other Menu MessagesandM;When the user selects an item from the top-level menu bar, the WM_INITMENUmessage is sent to the window that owns the menu.andP;  This permits theapplication to alter the appearance of the menu bar if necessary, but most ofthe time this message will be simply passed on to DefWindowProc.andM;Windows convention dictates that the appearance of the menu bar should remainconstant, and that you should only change the appearance of the lower-levelitems appearing on the pop-up menus.andP;  To this end, Windows sends theWM_INITMENUPOPUP message to the window that owns the menu bar just before apop-up is displayed.andP;  This gives you the opportunity to change the appearanceof one or more of the pop-up's menu items.andP;  You can disable, enable, check,or uncheck certain items at this point.andP;  For example, many Windowsapplications with an Edit pop-up menu use the WM_INITMENUPOPUP message todisable the &quot;Paste&quot; menu item if the clipboard is empty.andM;WM_INITMENUPOPUP contains the handle of the pop-up menu in wParam and theindex of the pop-up item in the low word of lParam.andP;  To use this message tohandle the &quot;Paste&quot; menu item, the following code could be used:andM;case WM_initmenupopup: bTextToPaste - (AppClipboard.iLength andgt; 0);EnableMenuItem(wParam, ID_PASTE, bTextToPaste); break;andM;When the user moves the selection bar over a menu item, whether it's in themenu bar or in a pop-up list, Windows sends the WM_MENUSELECT message to thewindow that owns the menu bar.andP;  For atomic menu items, wParam contains thecommand identifier associated with that menu item.andP;  If a pop-up menu isattached to that menu item, wParam contains the handle of the menu.andP;  In bothcases, lParam contains the current state of the menu item.andP;  Its state can bea combination of MF_BITMAP, MF_CHECKED, MF_DISABLED, MF_GRAYED, MF_HELP,MF_MOUSESELECT, MF_POPUP, and MF_SYSMENU.andP;  These state flags are discussedlater.andM;If you want to display some help text in a status window when the highlightedselection bar moves across a menu, use the WM_MENUSELECT message.andP;  An exampleis shown in Figure 7.andP;  People wonder how certain Windows applications, suchas Microsoft Excel, Manage to print the help text at the bottom of the mainwindow as you move the highlight bar over a new selection.andP;  It is done in thefollowing way.andP;  The WM_MENUSELECT message is sent to the window procedure ofthe main window for to the window that owns the menu bar), with a Param setto the identifier of the currently highlighted menu item.andP;  You define astructure that maps each menu identifier to a string of help text andimplement a small routine to scan the list identifiers sequentially uponreceipt of the WM_MENUSELECT message.andP;  The returned string is then displayedin a hypothetical status window, which is probably located at the bottom ofthe main windows.andM;The last menu message that you need to known about is the WM_MENUCHARmessage.andP;  This message is sent by Windows to the owner of the menu bar whenthe user presses a hotkey character that does not correspond to an item onthe menu.andP;  If the menu is composed solely of text strings, this message canbe ignored and passed onto DefWindow Proc.andP;  This message is more useful whena menu is composed of bitmaps or user-drawn items.andP;  Using the WM_MENUCHARmessage, you can associate a hotkey with a bitmap on the menu.andP;  For example,assume that you have a pull-down menu in which each menu item is a colorstrip; you can associate each color with a hotkey corresponding to the firstletter of the name of that color.andP;  If the user types &quot;B,&quot; the menu selectionwould be the Blue color strip (see Figure 8).andM;The Menu APIandM;The Windows menu system has a complete API that allows you to manipulate amenu in many ways.andP;  Functions exist that set and retrieve the text or stateof a menu item; add, insert, remove, and change the text or state of an item;and create, destroy, and draw a menu.andP;  For a demonstration of thesecapabilities, examine the MENU program included with the Window 3.0 SDK.andM;Besides loading a menu from a resource file, you can also create a completemenu system on the fly.andP;  CreateMenu creates an empty menu bar, returning thehandle to your application.andP;  You can then append items to this menu barhandle.andP;  A menu can be destroyed by calling the DestroyMenu function.andO;DestroyMenu will free the memory occupied by the menu.andM;Marc Adler is president of Magma Systems, a firm specializing in softwaretools, Windows, and workstations.andP;  He is the author of MEWEL, a text-basedwindowing system, and is a frequent contributor to MSJ.andM;If you programmed earlier versions of Windows, you probably relied on theChangeMenu function as an all-purpose function to manipulate menus.andP;  Windows3.0 augments the ChangeMenu function with several functions, each of whichperforms one of the tasks that ChangeMenu used to perform (see Figure 9).andM;For the functions that have the nPosition parameter, you can refer to a menuitem by either its zero-based position within the menu or its associatedcommand identifier.andP;  You would logically OR the value MF_BYPOSITION with theother flags in the wFlags argument if you wanted to refer to the menu item byits position, and you would use the MF_BYCOMMAND flag if you wanted to referto an item by its command identifier.andM;/* Get rid of the first menu item */ DeleteMenu(hMenu, 1, MF_BYPOSITION); /*Attach a new pop-up menu to the ID_EDIT menu item */ InsertMenu(hMenu,ID_EDIT, MF_BYCOMMAND | MF_POPUP, hSubMenu, 0);andM;Figure 10 lists the possible values for the wFlags argument.andM;You can enable or disable a menu item by calling EnableMenuItem.andP;  A disableditem does not generate a WM_COMMAND message when selected.andM;You can place or remove a check mark next to a menu item by callingCheckMenuItem.andP;  Check marks should be placed next to items whose states canbe toggled.andM;Windows 3.0 permits you to define a custom bitmap to check or uncheck a menuitem.andP;  To create these bitmaps, you must first determine what its size shouldbe to fit on a row of the menu.andP;  Starting with Windows 3.0 theGetMenuCheckMarkDimensions function is provided, which returns the height andwidth in pixels that the bitmap should be.andP;  StretchBlt can be used to shrinkor expand a bitmap to a desired size, but more on this in a later article.andM;Once you have the handles for the two bitmaps, call SetMenuItemBitmaps toassociate them with the menu item.andM;SetMenuitemBitmaps(hMenu, nPosition, wFlags, hBitMapCheckOff,hBitMapCheckOn);andM;If either bitmap is NULL, nothing will be displayed next to the menu itemwhen the item has a corresponding check state.andP;  For instance,ifhBitMapCheckOffisNULL, nothing will be displayed next to the item when itis not checked.andM;Owner Draw ItemsandM;One nice feature of Windows 3.0 is the ability to draw custom menu items.andO;For instance, imagine a Change Font pop-up menu in a word processor in whicheach item in the menu is drawn in a different font.andP;  Windows 3.0 lets you dothis.andM;One of the state flags associated with a menu item can be MF_OWNERDRAW.andP;  Thisflag tells Windows that the application will take care of drawing the menuitem.andP;  When you create an owner-draw menu item, you can attach a 32-bit valueto the item, which will assist you in the drawing of the item.andP;  For example,in the following call, the last parameter is the special 32-bit value.andM;AppendMenu(hMenu, MF_OWNERDRAW | MF_BYCOMMAND, ID_HELVETICA, (LPSTR)u132bitValue);andM;This will take the place of the menu item's text string.andM;When the owner-draw item needs to be drawn, Windows sends two messages to thewindow procedure of the window that owns the menu bar.andP;  The first message isWM_MEASUREITEM.andP;  The wParam is not used in this message; thelParam points toa MEASUREITEMSTRUCT data structure (see Figure 11).andP;  The window proceduremust fill in both the itemWidth and the itemHeight fields of this structurein response to the WM_MEASUREITEM message.andM;The second message sent is WM_DRAWITEM.andP;  In this message, thelParam fieldpoints to a DRAWITEMSTRUCT data structure (see Figure 12).andP;  This menu itemcan be drawn using any Windows graphics function.andM;Floating Pop-up MenusandM;As mentioned, Windows 3.0 allows you to create floating pop-up menus.andP;  A newfunction, CreatePopupMenu, has been added so you can create an empty pop-upmenu.andP;  This function is analogous to the CreateMenu function that lets youcreate an empty menu bar.andP;  CreatePopupMenu returns the handle of an emptypop-up.andP;  Once you have this handle, you can then add menu items by callingAppendMenu or InsertMenu.andP;  Any function that operates on the menu bar willalso operate on a pop-up menu.andM;Once a pop-up menu has been created, you can position it anywhere on thescreen.andP;  To do this, Windows 3.0 adds a new function called TrackPopupMenu.andM;TrackPopupMenu(HWND hMenu, WORD wFlags, int x, int y, int cx, HWND hWnd,LPRECT lprect)andM;The upper-left corner of the menu will be displayed at screen coordinatesx,y.andP;  If you want to position the menu in a window at a certain point, youmust use the ClientToScreen function to translate the window coordinates intoscreen coordinates.andP;  hWnd is the handle of the window that the menunotification messages will be sent to.andM;You can create and use a floating pop-up menu with the following codefragment.andM;hMenu = CreatePopup; AppendMenu(hMenu, ....); /* add menu items here */ .andP;  . andO;.  ClientToScreen(hWnd, (LPPOINT) andamp;pt); TrackPopupMenu(hMenu, 0, pt.x, pt.y,0, hWnd, NULL); DestroyMenu(hMenu);andM;CreatePopup is called to create an empty pop-up menu, and then AppendMenu iscalled repeatedly to add menu items to it.andP;  Once all of the items have beenadded to the menu, you need to determine the absolute screen coordinateswhere the pop-up should be displayed.andP;  Suppose you want to have theupper-left corner of the menu 10 units from the top of the window hWnd and 20units from the left border.andP;  Call ClientToScreen to derive the absolutescreen coordinates from a set of window coordinates.andM;Then you call TrackPopupMenu to display the menu.andP;  At this point, the second,fifth, and seventh parameters of TrackPopupMenu are reserved by Windows andmust be set to zero.andP;  After the user makes a selection from the menu, youcall Destroy Menu to get rid of the pop-up.andM;AcceleratorsandM;Another way for the end user to choose a command, besides picking an itemfrom a menu, is to press a key combination known as an accelerator.andP;  Anaccelerator is a pairing of a keystroke and a command identifier.andP;  When theuser presses an accelerator key, Windows sends a WM_COMMAND message to awindow.andM;You can define one or more tables of accelerators in your resource file.andP;  Thesyntax of an accelerator table definition is shown below.andM;AccelName ACCELERATORS BEGIN event, idvalue, [type] [NOINVERT] [ALT] [SHIFT][CONTROL] ENDandM;The event field can be one of the following:andM;* A single ASCII character enclosed in double quotes.andP;  If the character ispreceded by a caret(andless;), the character is assumed to be a control character.andM;* An integer representing an ASCII character.andM;* An integer or double-quoted single character representing a virtual key.andO;The type field must be VIRTKEY.andP;  A list of virtual key codes can be found inthe WINDOWS.H file.andP;  Virtual key codes usually begin with the prefix VK_; forexample, the virtual key code for the F1 key is VK_F1.andM;The idvalue field contains the unique command identifier that will be sent aspart of the WM_COMMAND message.andP;  The type field can either be VIRTKEY if youare using a virtual key combination, or ASCII if you are using an ASCII key.andM;As you can see, the keystroke can contain any combination of the Control.andO;Alt, or Shift shift states.andM;To use accelerators, you must load the accelerator table from the resourcefile.andP;  This can be done by using the LoadAccelerators function:andM;HANDLE LoadAccelerators(HINST hInstance, LPSTR lpszAccelerator)andM;The first parameter is the instance handle for this instance of yourapplication.andP;  The second parameter is the name of the accelerator table asdefined in the resource file.andP;  LoadAccelerators returns a handle to theloaded accelerator table.andM;Once the accelerator table is loaded, you must tell Windows to check thekeyboard events to determine whether the user pressed an accelerator key.andP;  Todo this, you must add the TranslateAccelerator function to the basic Windowsmessage loop.andP;  The TranslateAccelerator function tries to translateWM_KEYDOWN and WM_KEYUP events into accelerators.andP;  The message loop now lookslike this:andM;while (GetMessage(andamp;msg, hWnd, 0, 0)) { if (!TranslateAccelerator(hWnd,hAccel, andamp;msg)) { TranslateMessage(andamp;msg); DispatchMessage(andamp;msg); } }andM;If the msg structure contains a keyboard event, TranslateAccelerator willsearch all of the accelerators in the accelerator table hAccel.andP;  If thekeystroke corresponds to an accelerator, TranslateAccelerator puts the windowhandle hWnd into the msg.hWnd and sends a WM_COMMAND message to window hWnd.andO;Since you do not have to call TranslateMessage and DispatchMessage (it hasalready been done), the program loops back to read another message.andM;If you need to find out whether a WM_COMMAND message was sent by anaccelerator key rather than a menu selection, you can examine the high wordof lParam.andP;  If it is 1, the WM_COMMAND message was generated by anaccelerator key; if 0, it was generated by a menu item.andM;Putting It All TogetherandM;Now that you have seen code to put up a window, created a resource file withmenu and accelerator definitions, and created an icon for the application touse when a window is minimized, let's see how to combine everything into oneglorious executable file and run the program.andP;  Included with the source codeis a make file that you can submit to the Microsoft MAKE utility to automatethe compile and link cycle.andM;The files that are needed to develop a Windows application are listed inFigure 13, and the processes that each file must go through to create thefinal executable file are shown in Figure 14.andP;  First, the icon is createdusing SDKPAINT and written into a binary icon file.andP;  This file is referred tothe ASCII resource file.andP;  The resource file is compiled with the &quot;-r&quot; optionto create a binary resource file.andM;The C source code is then compile into an object file.andP;  To compile anapplication for Windows, you must include the following switches:andM;cl c Gsw -Zp -AS fileopen.candM;The -c switch tells the compiler to compile the code without linking it.andP;  The-Gsw switch disables stack checking and tells the compiler to emit specialWindows code before and after each function that you have declared as FAR.andO;The -Zp switch packs all structures.andP;  Since all structures in Windows arepacked, you must use this switch when writing any Windows application.andO;The-AS switch indicates that the small memory model is to be used.andM;Now that the object file has been created, link it with the Windows run-timelibraries create an executable file.andP;  In the past, had to use a special linercalled LINK4, but if you use Microsoft C Version 6.0, you use the linker thatcomes with the C compiler.andP;  The Windows 3.0 SDK includes libraries thatcompletely replace the C run-time libraries that came with your C compiler.andO;These new libraries provide Windows-aware versions of very C function.andM;A special user-written file called a definition file provides additionalinformation about the linking process to the linker.andP;  The DEF file isrequired for every Windows application; in it is the name of your applicationand a description of it.andP;  It may also contain the name of a stub file, whichis normal DOS executable program that will be run if the user tries to runthe Windows program from a DOS prompt.andP;  The SDK includes a sample stubprogram called WINSTUB.EXE, which merely displays the message &quot;This programrequires Microsoft Windows.&quot;andP;  You can also create your own stub file to dosomething more elaborate.andP;  The linker puts the stub file into the executablefile, so there are really two programs contained in one EXE file--a Windowsversion and a non-Windows version.andP;  Another requirement of a DEF file is thespecification of the executable header type.andP;  For Windows programs, you mustspecify &quot;WINDOWS.&quot;andP;  So far, the definition file looks like this:andM;NAME  STOCK DESCRIPTION  'MSJ Stock Application' EXETYPE  WINDOWS STUB 'WINSTUB.EXE'andM;You can specify the size of the application's local heap and stack by usingthe HEAPSIZE and STACKSIZE statements.andP;  Windows gives your application adefault heap size of zero, so if you need to do any kind of local memoryallocation, you should specify some size for the heap.andP;  Add the following twolines to the DEF file:andM;HEAPSIZE  2048 STACKSIZE  8192andM;Now you need to tell Windows about the code and data segments in yourapplication.andP;  If memory space is at a premium in your system, Windows willtry to move code and data segments around in memory to reduce memoryfragmentation, and if necessary, discard code and data segments to free upmemory.andP;  If Windows discards a segment, it will try to reread it from anapplication's EXE file on disk when it needs the segment again.andP;  Carefulplanning can reduce Windows swapping.andP;  Below is what you should use in thisversion of the application.andM;CODE  MOVEABLE  DISCARDABLE  PRELOAD DATA  MOVEABLE  MULTIPLEandM;This tells the linker that the standard code segments is movable in memoryand can be discarded if Windows runs low on memory.andP;  The code segment isloaded when the application is loaded, instead of being loaded on demand.andO;You also tell the linker that each instance of the application has its owndata segment, and that this data segment can be relocated in memory byWindows.andM;You can also tailor the characteristics of each segment in the program byusing the following statement:andM;SEGMENTS  segment  name  [CLASS classname]   [minalloc]andM;[FIXED|MOVEABLE]  [DISCARDABLE]  [SHARED|NONSHARED] [PRELOAD|LOADONCALL]andM;In the last part of the DEF file, you usually define the functions that youwant to export to Windows and the functions that you want to import fromdynamic-link libraries.andP;  You generally need to export any functions that willbe called directly by Windows, including the window procedures and callbackfunctions for dialog boxes and timer messages.andP;  This is the export sectionfor the stock application:andM;EXPORTS  MainWndProc StatusWndProcandM;The linker then uses the DEF file to create an EXE file.andP;  Finally, use theresource compiler again to combine the binary resource file with the EXE fileto form a new executable file with the binary resources tacked on.andP;  Once thisis done, you have an executable file.andP;  To run the program, just enter thefollowing command:andM;WIN STOCKandM;Finishing UpandM;There are no fancy features in this stock-charting application yet, but atleast created some generic skeleton code that you can use in all of yourfuture Windows programming.andP;  This version of the program doesn't really dovery much except display menu help items in response to a command beingchosen.andM;You should now understand resource files, menus, and accelerators.andP;  You sawhow menus and accelerators generate WM_COMMAND messages, which inform theapplication that the user chose a command.andP;  The next article will discusschild windows and control windows.andO;</TEXT></DOC>