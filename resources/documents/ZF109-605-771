<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF109-605-771  </DOCNO><DOCID>09 605 771.andM;</DOCID><JOURNAL>UNIX Review  Nov 1990 v8 n11 p48(7)* Full Text COPYRIGHT Miller Freeman Publications 1990.andM;</JOURNAL><TITLE>International UNIX. (overcoming UNIX's American English bias)(Developing Software)</TITLE><AUTHOR>Taylor, Dave.andM;</AUTHOR><SUMMARY>The UNIX operating system is based on American English, but thegrowth of foreign markets requires international software thatprovides straightforward interaction with speakers of foreignlanguages.andP;  UNIX's spellings, word order, time and date output,and monetary symbols use American standards, so majormodifications must be incorporated to make UNIX functional forusers who are not familiar with the American language.andO;Internationalization performed during compilation adds routines tothe source code to handle foreign languages.andP;  Compile-timemodification provides performance and distribution advantages, butincreases development time and complexity.andP;  Link-timeinternationalization still requires the programmer to act as atranslator, but it retains the software's basic logic andperformance.andP;  Run-time internationalization is most confusing fornew programmers, but it is best because it allows the user toselect the operating language from a single program.andM;</SUMMARY><DESCRIPT>Topic:     UNIXWorld MarketForeign LanguagesInternationalSoftware DesignUser InterfaceProgrammingSoftware Modification.andO;Feature:   illustrationprogram.andO;Caption:   How to print various monetary values based on target country.andO;(program)Values are assigned mnemonic names, then used without moreoverhead. (program)andM;</DESCRIPT><TEXT>INTERNATIONAL UNIXandM;As UNIX enters its third decade as a commercial operating system, one of theareas of significant growth is that of creating versions of the system andsoftware applications that interact gracefully in the language of the user,be it Japanese, Hebrew, French, or Greek.andP;  Each language and culture has itsown set of expectations regarding the form and format of information, andsuccessful international software should be able to move from one culture toanother without problems.andM;While it may seem to many that UNIX is a reasonably straightforward system,closer inspection reveals that there are quite a number of built-in biasestoward the culture and language in which it was originally created.andM;The Americanization of UNIX.andP;  The most obvious example is that the languageof the interface and system is American English.andP;  The X Window System doesn'tindicate, for example, that colour is required for a particular application,and the date command doesn't output Day/Month/Year like one would expectelsewhere in the English-speaking portions of the world.andP;  Further, withinapplications like the FTP file transfer program the commands are onlystraightforward and easy to remember if you happen to be reasonably fluent inEnglish.andM;Even software that seems to have avoided the problems of word-basedinterfaces are plagued by this Americanization; the commands in the vi editorare quite mnemonic if you know the words insert, append, and delete.andP;  Eventhe names of the various applications and programs found within UNIX areexamples of this; wc is a typical UNIX abbreviation, for a command thatgenerates word counts.andM;When the time program indicates how much CPU time was taken up by a process,it indicates it in American time-display format.andP;  The total cost of theprocess, if accounting is enabled, is displayed in American dollars, using anAmerican notation for monetary values.andM;The sort program sorts information using ASCII as a collating sequence.andO;ASCII, where A is less than B is less than a.andP;  That works fine for English,but what of, for example, Spanish where chico should collate between curacionand dano?andM;A more subtle but interesting example of the American bias is that many ofthe services implemented on top of the TCP/IP network, notably the SMTP(simple mail transfer protocol), only deal with seven-bit ASCII characters.andO;This means that essential foreign characters like n or c cannot be containedwithin electronic mail sent via traditional UNIX mail systems.andP;  Moving intoricher languages like Japanese or Chinese, where it takes considerably morethan just eight bits per character to uniquely represent a word, we find analmost complete inability for UNIX to properly deal with the addedcomplexities.andM;Suffice to say, there is a considerable amount of language- andculture-dependent information contained within the design and implementationof the UNIX operating system.andP;  Let's try to gain a better understanding ofjust what kinds of things change as we move into a new language or culture,then examine different ways to programmatically cope with these newchallenges.andM;Culture and Language Elements.andP;  Just as we've seen that English has a numberof elements that are as much a part of the language as the actual words andsentences we use, so do other languages.andP;  Fortunately, these differences canbe categorized in a straightforward manner: character sets, word ordering,local notational conventions, collation, and transliteration.andM;As we hinted earlier in the discussion of the shortcomings of the seven-bitmail transfer protocol, not all characters can be represented in the same wayor in the same number of bits.andP;  ASCII, the basic character set the UNIX isbuilt on, offers in seven binary bits the ability to uniquely encode mostEnglish alphanumerics as well as a considerable number of punctuationcharacters.andP;  In addition, the ASCII code contains values understood as thespace pseudo-character and the tab pseudo-character, as well as carriagereturns, line feeds, form feeds, and many other control of flow-controlcharacters.andM;Moving into another language often results in a different set of charactersbeing required, a set that cannot easily overlay in the 127-character spaceavailable.andP;  And if they did, it isn't at all obvious that we want to lose thefunctionality of the standard seven-bit ASCII when we add new languagesupport anyway.andM;A typical solution to this is to expand the representation values from sevento eight data bits, which expands our possible character set from 94printable characters to almost 200.andP;  This suffices for almost all of theEuropean languages including Spanish, French, German, and Italian, as well asadding the less common English characters like i as in naive, ae as inencyclopaedia, or even the common delimeter of hundredths of a dollar c.andP;  Thestandard values for eight-bit ASCII are discussed in the internationalstandard ISO 8859, which actually specifies at least nine different eight-bitASCII character sets.andM;Moving from seven-bit to eight-bit ASCII isn't really that traumatic for anapplication since UNIX systems define a character as eight bits, but when wemove into languages that require further bits of information to identifywhich character is which, then we start getting into some major difficulties.andO;Native language UNIX support for the Asian marketplace has come very slowlyfor just this reason; 16-bit software is almost completely different from itseigth-bit cousin despite the fact that most 16-bit character sets includesupport fot the basic 127 characters of seven-bit ASCII.andM;Another particularly English part of UNIX is the ordering of the verb-nounpairs in commands.andP;  For example, while in English it is perfectly normal andreasonable to type print file, in German the verb-noun ordering is reversed,and file print is the logical ordering of the phrase.andP;  This proves to be, asyou may guess, a particularly tough problem because so much of UNIX has thisordering as the basis for the functionality and the interface itself.andP;  Justthink about how the code for a command shell would need to be changed to lookfor the name of the command as the last word of each command sequence.andP;  Nowimagine what happens when we apply pipes: a command like grep pat file :print -Plp might well become something akin to file pat grep : -Plp print orsome further contortion.andP;  The complexity also increases further when we workwith languages that do not use left-to-right top-to-bottom presentationorder.andM;The most visually stimulating portion of internationalization is the changesthat suddenly have your system displaying monetary values with a leadingpound or with the decimal point as the monetary symbol as in 145$30 (atypical notation in Portugal and some countries in South America).andP;  Thespecific local conventions that must be followed include the format for thedisplay of monetary values, both positive and negative, the display of realnumbers, the format for dates and times, the method of calculating dates, andeven the size and orientation of the printed page.andP;  These changes must beavailable for input too: a program that displays the value of [pi] as 3,1415in Italian should also allow the user to enter the value of the constant e as2,7183.andM;Another tricky portion of internationalizing software is how to sort data.andO;Although not immediately apparent, the UNIX system uses sorting algorithmsquite a bit: even the order that files are displayed to you from the lscommand is a function of the order in which the filenames were sorted by thesort built-in subroutine.andP;  As you might suspect, the order in which lettersare ordered or collated is quite language specific.andP;  For example, in German,does the word Ro[beta]haar sort before or after Rock?andM;The collation algorithms must also deal appropriately with words that haveaccented characters, as in solo in Spanish.andP;  Further, when dealing with the16-bit character sets, the rules for which words are sorted before others isyet more complex.andM;Finally, in English it is relatively straightforward to translate a characterfrom lower case to upper case.andP;  Programmatically it is also quite simple, inASCII one needs to merely change the value of a specific bit to flip betweenthe two cases.andP;  In foreign languages, however, things become more difficult.andO;Sometimes when a letter is capitalized, for example, it might lose itsaccent, yet other times it may retain it.andP;  An example is found in thedifference between Canadian French and that spoken and written in France: inCanada e would be capitalized as E, but in France it is correctly capitalizedas E without any accent.andM;As can be seen, there is actually quite a bit of language- andculture-sensitive information that goes along with the change from English,or what we should perhaps called &quot;native UNIX,&quot; to any of the many otherlanguages spoken and written throughout the world.andM;Strategies for Creating International Software.andP;  There are three mainapproaches to the creation of international software systems, and thedifference is related to where in the software process the languagetranslation is done.andP;  A typical program has three separate and distinctenvironments on the way to becoming something that a customer can use:compilation, where the program is translated from readable source into anintermediate machine language or object code; linking, where the appropriatesystems utilities are added to the object code to create a single executablebinary; and execution, where resources are allocated and used as needed bythe currently running program.andM;Paralleling this, the three approaches for internationalization are based oncompile time, link time, and run time.andP;  As you might expect, each hasstrengths and weaknesses, and there are examples of each approach currentlydistributed in the UNIX marketplace, as well as utilities to aid in thecreation of international software using any of these schemes.andM;Compile-time internationalization is done by the programmer, explicitlyadding routines to the software that are language and culture knowledgeable.andO;For example consider the code (Figure 1) to print various monetary valuesbased on a target country.andM;The advantage of source code-based internationalization is that it lets thevendor distribute a complete object file to third parties and value addedresellers (or VARs) for inclusion in their own packages as appropriate.andP;  Likelink-time internationalization, the compile time methods suffers littleperformance degradation when switching from one language to another.andP;  Thedisadvantages, however, are many, not the least of which is the significantlygreater amount of work that the developers must do.andP;  Another disadvantage isthat the programmer must also serve as the translator, or work directly withthe translator, which is often very difficult to arrange.andP;  Finally,supporting multiple languages on a single hardware platform means managingduplicate copies of the software package.andM;Link-time internationalization is somewhere in the middle.andP;  It presumes theexistence of available libraries that can be added to the existing objectcode to create an executable binary.andP;  This approach is quite common.andP;  Oftensoftware is designed with a separate source file that contains only themessages output by the program, command words accepted, and other codedinformation for the appropriate modification demanded by language andculture.andM;With link-time internationalization, developers are able to distributeversions of their system that can be linked to create executables thatunderstand the appropriate language, but without the problems associated withdistribution of the source itself.andP;  This scheme also has the same lack ofnoticeable performance degradation when running in any of the variouslanguages.andP;  Also, modifications to the separate message sources do not changethe logic or algorithms used in the program, accidentally or otherwise, andtherefore reduce the chances of spurious bugs being introduced into thesoftware.andM;The link-time method still poses a significant amount of programming, or atleast of programming savvy, associated with the localization, or modificationto fit a specific language or culture, of an individaul package.andP;  Also, theprogramming language's compiler must be able to understand and deal with theforeign character sets, and possibly 16-bit characters, being used.andP;  Thisleaves the end-user with an application that is specific to one language,rather than more generally usable by whatever people are around.andP;  To avoidthat problem the vendor can ship the binary and let the end-user createmultiple language versions of the software through relinking with differentlanguages specified.andP;  This result in, at best, an awkward solution, andcertainly not one that the customer is going to be enthused about.andM;The third approach, one that is the most common approach taken by large UNIXhouses that offer international systems, in run-time language binding.andP;  Atrun time, the user specifies, typically through setting a particularenvironment variable, that they're using a particular language.andP;  The packageinvoked then checks the value of that variable to identify the language, thenuses message catalogs and various system calls to properly interact in thespecified language.andM;The single greatest advantage of run-time internationalization, one thatmakes it a tremendous win for almost all environments, is that a singleversion of the software can then speak an arbitrary number of languages.andP;  Inaddition, support for new languages can be created as easily as adding newmessage catalogs.andP;  The most significant disadvantage to this is that there isperformance degradation due to the run-time penalty of having to look up in aseparate file information for all data input or output, and how to format thevarious types of data.andM;Is simultaneous support for multiple languages commonly needed?andP;  Don't mostpeople in a single country speak the same language?andP;  Close examination of thepeoples in various parts of the world quickly dispels that misconception.andP;  Afine example of the polygot tendencies of countries is to count the number oflanguages that could foreseeably be used in a company with an office inZurich, Switzerland; English, French, German, and Italian come to mindimmediately.andP;  Indeed, in California, it is easy to find people speakingSpanish, Chinese, and Vietnamese and not being able to communicate in Englishat all.andP;  To have a system that simultaneously supported just these fourlanguages through either compile-time or link-time internationalization wouldresult in four separate executables being stored on disk.andP;  This isunacceptable to the customer, and the alternative of run-timeinternationalization, even with the degradation of performance, is an obvioussignificant win in these situations.andM;Of the three approaches to writing international software, the run-timescheme is the overall best, but it's also the often confusing and difficultfor new programmers to work with, so before we end this discussion let's takea brief foray into how run-time international software is structured.andM;Run-Time Language Binding.andP;  The premier group for the standardization ofinternational UNIX interfaces and systems is the X/Open consortium.andP;  X/Openproduces a set of documents known collectively as the X/Open PortabilityGuide, or XPG, and the latest release of the documents included a lengthysection on software internationalization through run-time language binding.andO;This recommended standard approach is based on that pioneered byHewlett-Packard with its Native Language System and Native Language InputOutput package as well as significant extensions from ATandamp;T and many otherorganizations throughout the world.andP;  Let's look at the X/Open system, asdefined in XPG Version 3, in further detail for a real-life example of how tointernationalize software.andM;The basic idea of the X/Open system is that the application software existsunder a layer that performs all the language- or culture-specific tasks.andP;  Theprogram is not able to directly output to the screen, nor does the programdirectly receive input from the user.andP;  The X/Open input/output bufferingsystem is used predominantly to allow 16-bit character input and output,thought it also can serve as an on-the-fly translator from one character setto another.andM;The implementation details of the X/Open system are fairly straightforward:the textual information is contained in a separate file called a messagecatalog, with the rest of the relevant language- or culture-specificinformation predefined in the system.andP;  Message catalogs are organized bysection and specific message number, so a common organization is to have onesection for error messages, a second section for input strings to compareuser input against, a third for output messages, and so on.andP;  A sample messagecatalog follows.andM;$ This is a sample NLS message catalog $ organized with section one for error$ messages, section two for possible commands $ that the user may enter, andsection three $ for output messages.andP;  Note that this is an $ OS independentformat that can be transported $ to any operating system that supports NLS.andO;$ $set 1 Error MessagesandM;1  no such file 2  file not found 3  permission denied 4  can't write outputfileandM;$set 2 Possible Input MessagesandM;1  get 2  copy 3  delete 4  removeandM;$set 3 Regular Output MessagesandM;1  Welcome to the sample NLS program 2  Enter your command 3  File copied 4 byte 5  bytes 6  copied 7  saved 8  deletedandM;$ and so on.andP;  .  .andM;The programmatic overhead for using this catalog-based scheme is actuallyfairly minimal, once you get used to the idea of having all your textualinformation stored in a separate place.andP;  Figure 2 shows a sample programfragment that could utilize the previous X/Open message catalog.andP;  Notice inthe sample code that instead of constantly accessing the data in the catalog,the various values are assigned mnemonic names and then used without anyfurther overhead.andP;  With more complex software the message catalog can getquite large and one would expect this particular approach to begin to have aprohibitive performance penalty on startup.andM;To demonstrate how easy it is to have our program fragment work in anothereight-bit language, consider the following code, with the same messagecatalog, but this time with the messages in French rather than English.andM;$ This is a sample NLS message catalog $ organized with section one for error$ messages, section two for possible commands $ that the user may enter, andsection three $ for output messages.andP;  This contains FRENCH $ information.andP;  $andM;1  le fichier n'existe pas 2  fichier pas trouve 3  permission refusee 4  nepeut pas ecrire le fichier de sortieandM;$set 2 Possible Input MessagesandM;1  prendre 2  copier 3  effacer 4  detruireandM;$set 3 Regular Output MessagesandM;1  Bienvenue dans le programe NLS 2  Entrez votre comande 3  fichier copie 4 caractere 5  caracteres 6  copie 7  sauve 8  effaceandM;$ and so on.andP;  .  .andM;The program in Figure 2 can work identically given this catalog, and thenproduce output, and correctly parse input, written in French.andM;There are many subtleties and pitfalls involved in internationalizingsoftware, however.andP;  In the original catalog code sample, for example, theprogram would fail if the language translated a single word command into amultiword sequence (such as get into obtain via).andP;  It would fail again in alanguage where the verb-noun ordering were reversed.andM;As UNIX continues to mature as both an operating system and development andapplication platform of choice, it is natural that more and more demand willbe placed on software running in multiple languages, whether it be throughone of the mechanisms detailed here or something completely different.andP;  Thenon-English-speaking market is massive, and is an area of significant futuregrowth, and companies that are prepared with international software willenjoy major sales growth in the next few years.andM;Nonetheless, any attempt to modify a package or create a new system intendedto be international is fraught with pitfalls and difficulties along the way.andO;Before you actually change or add a single line of code, it is highlyrecommended that you read through at least one of the references listed.andP;  TheX/Open guide is particularly useful.andM;Dave Taylor is founder of Intuitive Systems, a Mountain View, CA consultingfirm specializing in internationalization, user interface design, softwaremarketability, and the UNIX marketplace.andP;  He is also Editor at Large for SunTech Journal, as well as Macintosh Editor of Computer Language.andP;  Hisaddresses: taylor@limbo.intuitive.com or {decwrl,apple}!limbo!taylor.andO;</TEXT></DOC>