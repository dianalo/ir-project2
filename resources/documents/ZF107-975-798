<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF107-975-798  </DOCNO><DOCID>07 975 798.andM;</DOCID><JOURNAL>Communications of the ACM  Dec 1989 v32 n12 p1397(18)* Full Text COPYRIGHT Association for Computing Machinery 1989.andM;</JOURNAL><TITLE>A debate on teaching computing science. (talk by Dr. EdsgerDijkstra and responses by colleagues) (technical)</TITLE><AUTHOR>Denning, Peter J.; Dijkstra, Edsger W.; Parnas, David L.;andO;Scherlis, W.L.; Ven Emden, M.H.; COhen, Jacques; Hamming, R.W.;andO;Karp, Richard M.; Winograd, Terry.andM;</AUTHOR><SUMMARY>A transcript of a talk by Dr. Edsger Dijkstra is presented, alongwith several written responses from colleagues.andP;  Dijkstra arguesthat the current educational system fails to prepare young peoplefor 'radical novelties' produced by technology and that the goalsof college-level computer science curricula contradict themselves.andO;Programmers call themselves 'software engineers' to disguise thefact that they have no concrete understanding of it as adiscipline.andP;  Computers are capable only of manipulating symbolsand producing the results.andP;  Universities should teach formalmethods instead of relying on intuitive logic.andP;  Others agree withDijkstra's statement that computers have created a newintellectual challenge, but deny that engineers are poorprogrammers.andM;</SUMMARY><DESCRIPT>Topic:     Computer scienceCurriculumProgrammingTechnologySoftware Engineering.andO;Feature:   illustrationportrait.andO;Caption:   Edsger W. Djikstra. (portrait)andM;</DESCRIPT><NOTE>Only Text is presented here; see printed issues for graphics.andO;</NOTE><TEXT>A DABATE ON Teaching Computing ScienceandM;At the ACM Computer Science Conference last February, Edsger Dijkstra gave aninvited talk called &quot;On the Cruelty of Really Teaching Computing Science.&quot;andO;He challenged some of the basic assumptions on which our curricula are basedand provoked a lot of discussion.andP;  The editors of Communications receivedseveral recommendations to publish his talk in these pages.andP;  His commentsbrought into the foreground some of the background of controversy thatsurrounds the issue of what belongs in the core of a computer sciencecurriculum.andM;To give full airing to the controversy, we invited Dijkstra to engage in adebate with selected colleagues, each of whom would contribute a shortcritique of his position, with Dijkstra himself making a closing statement.andO;He graciously accepted this offer.andM;We invited people from a variety of specialties, backgrounds, andinterpretations to provide their comments.andP;  David Parnas is a noted softwareengineer who was outspoken in his crticism of the proposed Strategic DefenseInitiative.andP;  William Scherlis is known for his articulate advocacy of formalmethods in computer science.andP;  M.H.andP;  van Emden is known for his contributionsin programming languages and philosophical insights into science.andP;  JacquesCohen is known for his work with programming languages and logic programmingand is a member of the Editorial Panel of this magazine.andP;  Richard Hammingreceived the Turing Award in 1968 and is well known for his workincommunications and coding theory.andP;  Richard M. Karp received the TuringAward in 1985 and is known for his contributions in the design of algorithms.andO;Terry Winograd is well known for his early work in artificial intelligenceand recent work in the principles of design.andM;I am grateful to these people for participating in this debate and toProfessor Dijkstra for creating the opening.andM;Peter D. Denning Editor-in-ChiefandM;Edsger W. Dijkstra was born in 1930 in Rotterdam, The Netherlands, where helived until 1948.andP;  He studied mathematics and theoretical physics at theUniversity of Leiden, from which he graduated in 1956.andP;  During that period,in September 1951, he was introduced to programming in Cambridge, England,and in March, 1952, he was appointed to the Mathematical Centre as TheNetherlands' first professional programmer.andP;  In 1959 he earned his Ph.D.andP;  inComputing Science from the University of Amsterdam.andP;  In 1962 he was appointedFull Professor of Mathematics at the Eindhoven University of Technology.andP;  In1973, while retaining links with the University, he became Research Fellow ofthe Burroughs Corporation, a position he enjoyed until 1984, when he receivedthe Schlumberger Centennial Chair in Computer Sciences at the University ofTexas at Austin.andM;Dijkstra, recipient of the 1972 ACM Turing Award, is known for earlygraph-theoretical algorithms, the first implementation of ALGOL 60, and thefirst operating system composed of explicitly synchronized sequentialprocesses.andP;  He is also credited with the invention of guarded commands and ofpredicate transformers as a means for defining semantics, and programmingmethodology in the broadest sense of the term.andM;His current interests focus on the formal derivation of programs and thestreamlining of the mathematical argument.andP;  His publications represent only aminor fraction of his writings--he writes, in fact, so much that he cannotafford the use of time-saving devices such as word processors.andP;  He owns,however, several fountain pens, three of which are Mont Blancs, for which hemixes his own ink.andM;ON THE CRUELTY OF REALLY TEACHING COMPUTING SCIENCEandM;The underlying assumption of this talk is that computers represent a radicalnovelty in our history.andP;  The first part of this talk will make much moeprecise what we mean in this context by the adjective &quot;radical&quot; and will thensupply ample evidence in support of our assumption.andP;  The second half pursuessome of the scientific and educational consequences of the radical noveltythe computers embody.andM;The usual way in which we plan today for tomorrow is in yesterday'svocabulary.andP;  We do so because we try to get away with the use of conceptsthat we are familiar with and that have acquired their meanings in our pastexperience.andP;  Of course, the words and the concepts do not quite fit becauseour future differs from our past, but then we stretch them a little bit.andP;  Itis the most common way of trying to cope with novelty.andP;  Linguists are quitefamiliar with the phenomenon that the meanings of words evolve over time, butalso know that this is a slow and gradual process.andM;By means of metaphors and analogies, we try to link the new to the old, thenovel to the familiar.andP;  Under sufficiently slow and gradual change, it worksreasonably well; in the case of a sharp discontinuity, however, the methodbreaks down.andP;  Though we may glorify it with the name &quot;common sense,&quot; our pastexperience is no longer relevant; the analogies become too shallow; and, themetaphors become more misleading than illuminating.andP;  This is the situationthat is characteristic of the &quot;radical&quot; novelty.andM;Coping with radical novelty requires an orthogonal method.andP;  One must considerone's own past, the experiences collected, and the habits formed in it as anunfortunate accident of history, and one has to approach the radical noveltywith a blank mind, consciously refusing to try to link history with what isalready familiar, because the familiar is hopelessly inadequate.andP;  One has,with initially a kind of split personality, to come to grips with a radicalnovelty as a dissociated topic in its own right.andP;  Coming to grips with aradical novelty amounts to creating and learning a new foreign language thatcannot be translated into one's own mother tongue.andP;  (Anyone who has learnedquantum mechanics knows what I am talking about.)andP;  Needless to say, adjustingto radical novelties is not a very popular activity for it requires hardwork.andP;  For the same reason, the radical novelties, themselves, are unwelcome.andM;By now, you may well ask why I have paid so much attention to and have spentso much eloquence on such a simple and obvious notion as the radical novelty.andO;My reason is very simple: radical novelties ar so disturbing that they tendto be suppressed or ignored to the extent that even the possibility of theirexistence, in general, is more often denied than admitted.andM;On the historical evidence I shall be short.andP;  Carl Friedrich Gauss, thePrince of Mathematicians but also somewhat of a coward, was certainly awareof the fate of Galileo--and could probably have predicted the calumniation ofEinstein--when he decided to suppress Galileo's discovery of non-Euclideangeometry, thus leaving it to Bolyai and Lobatchewsky to receive the flak.andM;It is probably more illuminating to go a little bit further back: to theMiddle Ages.andP;  One of its characteristics was that &quot;reasoning by analogy&quot; wasrampant; another characteristic was almost total intellectual stagnation, andwe now see why the two go together.andP;  A reason for mentioning this is to pointout that by developing a keen ear for unwarranted analogies, one can detect alot of medieval thinking today.andM;The other thing I cannot stres enough is that the fraction of the populationfor which gradual change seems to be all but the only paradigm of history isvery large, probably much larger than one would expect.andP;  Certainly, when Istarted to observe it, their number turned out to be much larger than I hadexpected.andM;For instance, the vast majority of the mathematical community has neverchallenged its tacit assumption that doing mathematics will remain very muchthe same type of mental activity it has always been.andP;  New topics will come,flourish, and go as they have done in the past, but with the human brainbeing what it is, our ways of teaching, learning, and understandingmathematics, of problem solving, and of mathematical discovery will remainpretty much the same.andP;  Herbert Robbins clearly states why he rules out aquantum leap in mathematical ability:andM;&quot;Nobody is going to run 100 meters in five seconds, no matter how much isinvested in training and machines.andP;  The same can be said about using thebrain.andP;  The human mind is no different now from what it was five thousandyears ago.andP;  And when it comes to mathematics, you must realize that this isthe human mind at an extreme limit of its capacity.&quot;andM;My comment in the margin was &quot;so reduce the use of the brain and calculate!&quot;andO;Using Robbins's own analogy, one could remark that for going from A to Bfast, there could now exist alternatives to running that are orders ofmagnitude more effective.andP;  Robbins flatly refuses to honor any alternative totime-honored brain usage with the name of &quot;doing mathematics,&quot; thus,exorcizing the danger of radical novelty by the simple device of adjustinghis definitions tohis needs.andP;  Simply, by definition, mathematics willcontinue to be what it used to be.andP;  Enough said about the mathematicians.andM;Let me give you just one more example of the widespread disbelief in theexistence of radical novelties and, hence, in the need to learn how to copewith them.andP;  It is the prevailing educational practice for which gradual,almost imperceptible, change seems to be the exclusive paradigm.andP;  How manyeducational texts are not recommended for their appeal to the student'sintuition!andP;  They constantly try to present everything that could be anexciting novelty as something as familiar as possible.andP;  They consciously tryto link the new material to what is supposed to be the student's familiarworld.andM;It already starts with the teaching of arithmetic.andP;  Instead of teaching 2 + 3= 5, the hideous arithmetic operator &quot;plus&quot; is carefully disguised by callingit &quot;and,&quot; and the little kids are given lots of familiar example, first, withclearly visible objects such as apples and pears, which are in, in contrastto equally countable objects such as percentages and electrons, which areout.andP;  The same, silly tradition is reflected at the university level indifferent introductory calculus courses for the future physicist, architect,or business major, each course adorned with examples from the respectivefields.andP;  The educational dogma seems to be that everything is fine as long asthe student does not notice that he is learning something really new; moreoften than not, the student's impression is indeed correct.andM;I consider the failure of an educational practice to prepare the nextgeneration for the phenomenon of radical novelties a serious shortcoming.andO;(When King Ferdinand visited the conservative University of Cervera, theRector proudly reassured the monarch with the words: &quot;Far be from us, Sire,the dangerous novelty of thinking.&quot;andP;  Spain's problems in the century thatfollowed justify my characterization of the shortcoming as &quot;serious.&quot;)  Thiswas to show the extent to which education has adopted the paradigm of gradualchange.andM;The concept of radical novelties is of contemporary significance because,while we are ill-prepared to cope with them, science and technology have nowshown themselves expert at inflicting them upon us.andP;  Earlier scientificexamples are the theory of relativity and quantum mechanics; latertechnological examples are the atom bomb and the pill.andP;  For decades, theformer two gave rise to a torrent of religious, philosophical, or, otherwise,quasi-scientific tracts.andP;  We can daily observe the profound inadequacy withwhich the latter two are approached, be it by our statesmen and religiousleaders or by the public at large.andP;  This illustrates the damage done to ourpeace of mind by radical novelties.andM;I raised all this because of my contention that automatic computers representa radical novelty, and that only by identifying them as such can we identifyall the nonsense, the misconception, and the mythology that surround them.andO;Closer inspection will reveal that it is even worse, viz., that automaticcomputers embody not only one radical novelty but two of them.andM;The first radical novelty is a direct consequence of the raw power of today'scomputing equipment.andP;  We all know how we cope with something big and complex:divide and rule, i.e., we view the whole as a compositum of parts and dealwith the parts separately.andP;  And if a part is too big, we repeat theprocedure.andP;  The town is made up from neighborhoods that are structured bystreets, that contain buildings, that are made from walls and floors, thatare built from bricks, etc., eventually down to the elementary particles.andO;And we have all our specialist along the line, from the town planner via thearchitect to the solid state physicist, and further.andP;  Because, in a sense,the whole is &quot;bigger&quot; than its parts, the depth of a hierarchicaldecomposition is some sort of logarithm of the ratio of the &quot;sizes&quot; of thewhole and the ultimate smallest parts.andP;  From a bit to a few hundredmegabytes, from a microsecond to half an hour of computing, it confronts uswith the completely baffling ratio of [10.sup.9]!andM;The programmer is in the unique position that his is the only discipline andprofession in which such a gigantic ratio, which totally baffles ourimagination, has to be bridged by a single technology.andP;  He has to be able tothink in terms of conceptual hierarchies that are much deeper than a singlemind ever needed to face before.andP;  Compared to that number of semantic levels,the average mathematical theory is almost flat.andP;  By evoking the need for deepconceptual hierarchies, the automatic computer confronts us with a radicallynew intellectual challenge that has no precedent in our history.andM;Again, I have to stress this raical novelty because the true believer ingradual change and incremental improvements is unable to see it.andP;  For him, anautomatic computer is something like the familiar cash register, onlysomewhat bigger, faster, and more flexible.andP;  But the analogy is ridiculouslyshallow.andP;  It is orders of magnitude worse than comparing, as a means oftransportation, the supersonic jet plane with a crawling baby, for that speedratio is only a thousand.andM;The second radical novelty is that the automatic computer is our firstlarge-scale digital device.andP;  We had a few with a noticeable discretecomponent.andP;  I just mentioned the cash register and can add the typewriter,with its individual keys.andP;  With a single stroke you can type either a Q or aW but, though their keys are next to each other, not a mixture of those twoletters.andP;  But such mechanisms are the exception, and the vast majority of ourmechanisms are viewed as analogue devices whose behavior is, over a largerange, a continuous function of all parameters involved.andP;  If we press thepoint of the pencit a little bit harder, we get a slightly thicker line; ifthe violinist slightly misplaces his finger, he plays slightly out of tune.andO;To this I should add that, to the extent that we view ourselves asmechanisms, we view ourselves, primarily, as analogue devices.andP;  If we push alittle harder we expect to do a little better.andP;  Very often, the behavior isnot only a continuous but even a monotonic function.andP;  To test whether ahammer suits us over a certain range of nails, we try it out on the smallestand largest nails of the range, and if the outcomes of those two experimentsare positive, we are perfectly willing to believe that the hammer will suitus for all nails in between.andM;It is possible, and even tempting, to view a program as an abstractmechanism, as a device of some sort.andP;  To do so, however, is highly dangerous.andO;The analogy is too shallow because a program is, as a mechanism, totallydifferent from all the familiar analogue devices we grew up with.andP;  Like alldigitally encoded information, it has, unavoidably, the uncomfortableproperty that the smallest possible perturbations--i.e., changes of a singlebit--can have the most drastic consequences.andP;  (For the sake of completeness,I add that the picture is not essentially changed by the introduction ofredundancy or error correction.)andP;  In the discrete world of computing, thereis no meaningful metric in which &quot;small&quot; changes and &quot;small&quot; effects go handin hand, and there never will be.andM;This second radical novelty shares the usual fate of all radical novelties:it is denied because its truth would be too discomforting.andP;  It is hard toestimate the damage done by this denial, but with million programmers in theworld, a cost of millions of dollars per day seems a very modest guess.andM;Having described--admittedly in the broadest possible terms--the nature ofcomputing's novelties, I shall now provide the evidence that these noveltiesare, indeed, radical.andP;  I shall do so by explaining a number of otherwisestrange phenomena as frantic--but, as we now know, doomed--efforts at hidingor denying the frighteningly unfamiliar.andM;A number of these phenomena have been bundled under the name &quot;SoftwareEngineering.&quot;andP;  As economics is known as &quot;The Miserable Science,&quot; softwareengineering should be known as &quot;The Doomed Discipline&quot;: doomed because itcannot even approach its goal since its goal is self-contradictory.andP;  Softwareengineering, of course, presents itself as another worthy cause, but that iseyewash.andP;  If you carefully read its literature and analyze what its devoteesactually do, you will discover that software engineering has accepted as itscharter, &quot;How to program if you cannot.&quot;andM;The popularity of its name is enough to make it suspect.andP;  In what we denoteas &quot;primitive societies,&quot; the superstition that knowing someone's true namegives you magic power over him is not unusual.andP;  We are hardly less primitive.andO;Why do we persist here in answering the telephone with the most unhelpful&quot;hello&quot; instead of our name?andP;  Nor are we above the equally primitivesuperstition that we can gain some control over some unknown, malicious demonby calling it by a safe, familiar, and innocent name, such as &quot;engineering.&quot;andO;But it is totally symbolic, as one of the U.S.andP;  computer manufacturers proveda few years ago when it hired, one night, hundreds of nw &quot;software engineers&quot;via the simple device of elevating all its programmers to that exalted rank.andO;So much for that term.andM;The practice is pervaded by the reassuring illusion that programs are justdevices like any others, the only difference admitted being that theirmanufacture might require a new type of craftsmen, viz., programmers.andP;  Fromthere, it is only a small step to measuring &quot;programmer productivity&quot; interms of &quot;number of lines of code produced per month.&quot;andP;  This is a very costlymeasuring unit because it encourages the writing of insipid code, but, today,I am less interested in how foolish a unit it is from even a pure businesspoint of view.andP;  My point, today, is that if we wish to count lines of code,we should not regard them as &quot;lines produced&quot; but as &quot;lines spent.&quot;andP;  Thecurrent conventional wisdom is so foolish as to book that count on the wrongside of the ledger.andM;Besides the notion of productivity, quality control continues to be distortedby the reassuring illusion that what works with other devices works withprograms as well.andP;  It is now two decades since it was pointed out thatprogram testing may convincingly demonstrate the presence of bugs but cannever demonstrate their absence.andP;  After quoting this well-publicized remarkdevoutly, the software engineer returns to the order of the day and continuesto refine his testing strategies, just like the alchemist of yore whocontinued to refine his chrysocosmic purifications.andM;Unfathomed misunderstanding is further revealed by the term &quot;softwaremaintenance,&quot; of which many people continue to believe that programs--andeven programming languages themselves--are subject to wear and tear.andP;  Yourcar needs maintenance too, does it not?andP;  Famous is the story of the oilcompany that believed that its Pascal programs did not last as long as itsFortran programs &quot;because Pascal was not maintained.&quot;andM;In the same vein, I must draw attntion to the astonishing readiness withwhich the suggestion has been accepted that the pains of software productionare largely due to a lack of appropriate &quot;programming tools.&quot;andP;  (The telling&quot;programmer's workbench&quot; was soon to follow.)andP;  Again, the shallowness of theunderlying analogy is worthy of the Middle Ages.andP;  Confrontations with insipid&quot;tools&quot; of the &quot;algorithm-animation&quot; variety has not mellowed my judgement;on the contrary, it has confirmed by initial suspicion that we are primarilydealing with yet another dimension of the snake-oil business.andM;Finally, to correct the possible impression that the inability to face radialnovelty is confined to the industrial world, let me offer you an explanationof the continuing popularity of artificial intelligence.andP;  You would expectpeople to feel threatened by the &quot;giant brains or machines that think.&quot;andP;  Infact, the frightening computer becomes less frightening if it is used only tosimulate a familiar noncomputer.andP;  I am sure that this explanation will remaincontroversial for quite some time for artificial intelligence, as a mimickingof the human mind, prefers to view itself as being at the front line, whereasmy explanation relegates it to the rear-guard.andP;  (The effort of using machinesto mimic the human mind has always struck me as rather silly.andP;  I would ratheruse them to mimic something better.)andM;So much for the evidence that the computer's novelties are, indeed, radical.andM;And now comes the second--and hardest--part of my talk: the scientific andeducational consequences of the above.andP;  The educational consequences are, ofcourse, the hairier ones, so let us postpone their discussion and stay for awhile with computing science itself.andP;  What is computing?andP;  And what is ascience of computing about?andM;Well, when all is said and done, the only thing computers can do for us is tomanipulate symbols and produce results of such manipulations.andP;  From ourprevious observations, we should recall that this is a discrete world and,moreover, that both the number of symbols involved and the amount ofmanipulation performed is many orders of magnitude larger than we canenvisage.andP;  They totally baffle our imagination, and we must, therefore, nottry to imagine them.andP;  But before a computer is ready to perorm a class ofmeaningful manipulations--or calculations, if you prefer--we must write aprogram.andM;What is a program?andP;  Several answers are possible.andP;  We can view the program aswhat turns the general-purpose computer into a special-purpose symbolmanipulator, and it does so without the need to change a single wire.andP;  (Thiswas an enormous improvement over machines with problem-dependent wiringpanels.)andP;  I prefer to describe it the other way round.andP;  The program is anabstract symbol manipulator which can be turned into a concrete one bysupplying a computer to it.andP;  After all, it is no longer the purpose ofprograms to instruct our machines; these days, it is the purpose of machinesto execute our programs.andM;So, we have to design abstract symbol manipulators.andP;  We all know what theylook like.andP;  They look like programs or--to use somewhat more generalterminology--usually rather elaborate formulae from some formal system.andP;  Itreally helps to view a program as a formula.andP;  First, it puts the programmer'stask in the proper perspective: he has to derive that formula.andP;  Second, itexplains why the world of mathematics all but ignored the programmingchallenge: programs were so much longer formulae than it was used to that itdid not even recognize them as such.andP;  Now back to the programmer's job.andP;  Hehas to derive that formula; he has to derive that program.andP;  We know ofonlyone reliable way of doing that, viz., by means of symbol manipulation.andO;And now the circle is closed.andP;  We construct our mechanical symbolmanipulators by means of human symbol manipulation.andM;Hence, computing science is--and will always be--concerned with the interplaybetween mechanized and human symbol manipulation usually referred to as&quot;computing&quot; and &quot;programming,&quot; respectively.andP;  An immediate benefit of thisinsight is that it reveals &quot;automatic programming&quot; as a contradiction interms.andP;  A further benefit is that it gives us a clear indication where tolocate computing science on the world map of intellectual disciplines: in thedirection of formal mathematics and applied logic, but, ultimately, farbeyond where those are now for computing science is interested in effectiveuse of formal methods and on a much, much larger scale than we have witnessedso far.andP;  Because, these days, no computing endeavor is respectable without anacronym, I propose that we adopt for computing science VLSAL (Very LargeScale Application of Logic), and, to be on the safe side, we had betterfollow the shining examples of our leaders and make a trademark of it.andM;In the long run, I expect computing science to transcend its parentdisciplines, mathematics and logic, by effectively realizing a significantpart of Leibniz's Dream of providing symbolic calculation as an alternativeto human reasoning.andP;  (Please note the difference between &quot;mimicking&quot; and&quot;providing an alternative to.&quot;andP;  Alternatives are allowed to be better.)andM;Needless to say, this vision of what computin science is about is notuniversally applauded.andP;  On the contrary, it has met widespread--and sometimeseven violent--opposition from all sorts of directions.andP;  I mention asexamples.andM;0.andP;  the mathematical guild, which would rather continue to believe that theDream of Leibniz is an unrealistic illusionandM;1.andP;  the business community, which, having been sold the idea that computerswould make life easier, is mentally unprepared to accept that they only solvethe easier problems at the price of creating much harder ones.andM;2.andP;  the subculture of the compulsive programmer, whose ethics prescribe thatone silly idea and a month of frantic coding should suffice to make him alife-long millionaireandM;3.andP;  computer engineering, which would rather continue to act as if it is allonly a matter of higher bit rates and more flops per secondandM;4.andP;  the military, which is now totally absorbed in the business of usingcomputers to mutate billion-dollar budgets into the illusion of automaticsafetyandM;5.andP;  all soft sciences for which computing now acts as some sort ofinterdisciplinary havenandM;6.andP;  the educational business that feels that if it has to teach formalmathematics to CS students, it may as well close its schools.andM;And, with this last example, I have reached, imperceptibly but alasunavoidably, the most hairy part of this talk: educational consequences.andM;The problem wit educational policy is that it is hardly influenced byscientific considerations derived from the topics taught and is almostentirely determined by extra-scientific circumstances such as the combinedexpectations of the students, their parents, and their future employers, andthe prevailing view of the role of th university is the stress on trainingits graduates for today's entry-level jobs or on providing its alumni withthe intellectual baggage and attitudes that will last them another fiftyyears?andP;  Do we grudgingly grant the abstract sciences only a far-away corneron campus, or do we recognize them as the indispensable motor f thehigh-technology industry?andP;  Even if we do the latter, do we recognize ahigh-technology industry as such if its technology primarily belongs toformal mathematics?andP;  Do the universities provide society the intellectualleadership it needs or only the training it asks for?andM;Traditional academic rhetoric is perfectly willing to give to these questionsthe reassuring answers, but I do not believe them.andP;  By way of illustratio ofmy doubts, in a recent article on &quot;Who Rules Canada?,&quot; David H. Flahertybluntly states:andM;&quot;Moreover, the business elite dismisses traditional academics andintellectuals as largely irrelevant and powerless.&quot;andM;So, if I look into my foggy crystal ball at the future of computing scienceeducation, I overwhelmingly see the depressing picture of &quot;business asusual.&quot;andP;  The universities will continue to lak the courage to teach hardscience; they will continue to misguide the students, and each next stage ofinfantilization of the curriculum will be hailed as educational progress.andM;I now have had my foggy crystal ball for quite a long time.andP;  Its predictionsare invariably gloomy and usually correct.andP;  However, I am quite used to that,and they will not keep me from giving you a few suggestions, even if it ismerely an exercise infutility whose only effect is to make you feel guilty.andM;We could, for instance, begin with cleaning up our language by no longercalling a bug &quot;a bug&quot; but by calling it an eror.andP;  It is much more honestbecause it squarely puts the blame where it belongs, viz., with theprogrammer who made the error.andP;  The animistic metaphor of the bug thatmaliciously sneaked in while the programmer was not looking is intellectuallydishonest as it is a disguise that the error is the programmer's owncreation.andP;  The nice thing of this simple change of vocabulary is that it hassuch a profound effect.andP;  While, before, a program with only one bug used tobe &quot;almost correct,&quot; afterwards a program with an error is just &quot;wrong&quot;(because in error).andM;My next linguistical suggestion is more rigorous.andP;  It is to fight the&quot;if-this-guy-wants-to-talk-to-that-guy&quot; syndrome.andP;  Never refer to parts ofprograms or pieces of equipment in an anthropomorphic terminology, nor allowyour students to do so.andP;  This linguistical improvement is much harder toimplement than you might think, and your department might consider theintroduction of fines for violations, say a quarter for undergraduates, twoquarters for graduate students, and five dollars for faculty members; by theend of the first semester of the new regime, you will have collected enoughmoney for two scholarships.andM;The reason for this last suggestion is that the anthropomorphic metaphor--forwhose introduction we can blame John von Neumann--is an enrmous handicap forevery computing community that has adopted it.andP;  I have now encounteredprograms wanting things, knowing things, expecting things, believing things,etc., and each time that gave rise to avoidable confusions.andP;  The analogy thatunderlies this personification is so shallow that it is not only misleadingbut also paralyzing.andM;It is misleading in the sense that it suggests that we can adequately copewith the unfamiliar discrete in terms of the familiar continuous, i.e.,andO;ourselves, quod non.andP;  It is paralyzing in the sense that because personsexist and act in time, its adoption effectively prevents a departure fromoperational semantics and, thus, forces people to think about programs interms of computational behaviors, based on an underlying computational model.andO;This is bad because operational reasoning is a tremendous waste of mentaleffort.andM;Let me explain to you the nature of that tremendous waste, and allow me totry to convince you that the term &quot;tremendous waste of mental effort&quot; is notan exaggeration.andP;  For a short while I shall get highly technical, but do notget frightened.andP;  It is the type of mathematics that one can do with one'shands in one's pockets.andP;  The point to get across is that if we have todemonstrate something about all the elements of a large set, it is hopelesslyinefficient to deal with all the elements of the set individually.andP;  Theefficient argument does not refer to individual elements at all and iscarried out in terms of the set's definition.andM;Consider the plane figure Q, defined as the 8 by 8 square from which, at twoopposite corners, two 1 by 1 squares have been removed.andP;  The area of Q is 62,which equals the combined area of 31 dominos of 1 by 2.andP;  The theorem is thatthe figure Q cannot be covered by 31 such dominos.andM;Another way of stating the theorem is that if you start with squared paperand begin covering this by placing each next domino on two new adjacentsquares, no placement of 31 dominos will yield the figure Q.andM;So, a possible way of proving the theorem is by generating all possibleplacements of dominos and verifying for each placement that it does not yieldthe figure Q: a tremendously laborious job.andM;The simple argument, however, is as follows.andP;  Color the squares of thesquared paper as on a chess board.andP;  Each domino, covering two adjacentsquares, covers 1 white and 1 black square, and, hence, each placement coversas many white squares as it covers black squares.andP;  In the figure Q, however,the number of white squares and the number of black squares differ by2--opposite corners lying on the same diagonal--and, hence, no placement ofdominos yields figure Q.andM;Not only is the above simple argument many orders of magnitude shorter thanthe exhaustive investigation of the possible placements of 31 dominos, it isalso essentially more powerful for it covers the generalization of Q byreplacing the original 8 by 8 square with any rectangle with sides of evenlength.andP;  The number of such rectangles being infinite, the former method ofexhaustive exploration is essentially inadequate for proving our generalizedtheorem.andM;And this concludes my example.andP;  It has been presented because it illustrates,in a nutshell, the power of down-to-earth mathematics; needless to say,refusal to exploit this power of down-to-earth mathematics amounts tointellectual and technological suicide.andP;  The moral of the story is: deal withall elements of a set by ignoring them and working with the set's definition.andM;Back to programming, the statement that a given program meets a certainspecification amounts to a statement about all computations that could takeplace under control of that given program.andP;  And since this set ofcomputations is defined by the given program, our recent moral says: dealwith all computations possible under control of a given program by ignoringthem and working with the program.andP;  We must learn to work with program textswhile (temporarily) ignoring that they admit the interpretation of executablecode.andM;Another way of saying the same thing is the following one.andP;  A programminglanguage, with its formal syntax and with the proof rules that define itssemantics, is a formal system for which program execution provides only amodel.andP;  It is well-known that formal systems should be dealt with in theirown right and not in terms of a specific model.andP;  And, again, the corollary isthat we should reason about programs without even mentioning their possible&quot;behaviors.&quot;andM;And this concludes my technical excursion into the reason why operationalreasoning about programming is &quot;a tremendous waste of mental effort&quot; and why,therefore, in computing science the anthropomorphic metaphor should bebanned.andP;  Not everybody understands this sufficiently well.andM;I was recently exposed to a demonstration of what was pretended to beeducational software for an introductory programming course.andP;  With its&quot;visualizations&quot; on the screen, it was such an obvious case of curriculuminfantilization that its author should be cited for &quot;contempt of the studentbody,&quot; but this was only a minor offense compared with what thevisualizations were used for.andP;  They were used to display all sorts offeatures of computations evolving under control of the student's proram!andP;  Thesystem highlighted precisely what the student has to learn to ignore; itreinforced precisely what the student has to unlearn.andP;  Since breaking out ofbad habits, rather than acquiring new ones, is the toughest part of learning,we must expect from that system permanent mental damage for most studentsexposed to it.andM;Needless to say, that system completely hid the fact that, all by itself, aprogram is no more than half a conjecture.andP;  The other half of the conjectureis the functional specification the program is supposed to satisfy.andP;  Theprogrammer's task is to present such complete conjectures as proven theorems.andM;Before we part, I would like to invite you to consider the following way ofdoing justice to computing's radical novelty in an introductory programmingcourse.andM;On the one hand, we teach what looks like the predicate calculus, but we doit very differently from the philosophers.andP;  In order to train the noviceprogrammer in the manipulation of uninterpreted formulae, we teach it more asboolean algebra, familiarizing the student with all algebraic properties ofthe logical connectives.andP;  To further sever the links to intuition, we renamethe values {true, false} of the boolean domain as {black, white}.andM;On the other hand, we teach a simple, clean, imperative programming language,with a skip and a multiple assignment as basic statements, with a blockstructure for local variables, the semicolon as operator for statementcomposition, a nice alternative construct, a nice repetition, and, if sodesired, a procedure call.andP;  To this, we add a minimum of data types, saybooleans, integers, characters, and strings.andP;  The essential thing is that forwhatever we introduce, the corresponding semantics are defined by the proofrules that go with it.andM;Right from the beginning and all through the course, we stress that theprogrammer's task is not just to write down a program, but that his main taskis to give a formal proof that the program he proposes meets the equallyformal functional specification.andP;  While designing proofs and programs hand inhand, the student gets ample opportunity to perfect his manipulative agilitywith the predicate calculus.andP;  Finally, in order to drive home the messagethat this introductory programming course is primarily a course in formalmathematics, we see to it that the programming language in question has notbeen implemented on campus so that students are protected from the temptationto test their programs.andP;  And this concludes the sketch of my proposal for anintroductory programming course for freshmen.andM;This is a serious proposal and utterly sensible.andP;  Its only disadvantge isthat it is too radical for many, who, being unable to accept it, are forcedto invent a quick reason for dismissing it, no matter how invalid.andP;  I willgive you a few quick reasons.andM;You do not need to take my proposal seriously because it is so ridiculousthat I am obviously completely out of touch with the real world.andP;  But thatkite will not fly for I know the real world only too well.andP;  The problems ofthe real world are primarily those you are left with when you refuse to applytheir effective solutions.andP;  So, let us try again.andM;You do not need to take my proposalseriously because it is utterlyunrealistic to try to teach such material to college freshmen.andP;  Would notthat be an easy way out?andP;  You just postulate that this would be far toodifficult.andP;  But that kite will not fly either for the postulate has beenproven wrong.andP;  Since the early80s, such an introductory programming coursehas successfully been given to hundredsof college freshmen each year.andO;(Because, in my experience, saying this once does not suffice, the previoussentence should be repeated at least another two times.)andP;  So, let us tryagain.andM;Reluctantly admitting that it could, perhap, be taught to sufficiently docilestudents, yet you reject my proposal because such a course would deviate somuch from what 18-year-old students are used to and expect that inflicting itupon them would be an act of educational irresponsibility.andP;  It would onlyfrustrate the students.andP;  Needless to say, that kite will not fly either.andP;  Itis true that the student that has never manipulated uninterpreted formulaequickly realizes that he is confronted with something totally unlike anythinghe has ever seen before.andP;  But fortunately, the rules of manipulation are, inthis case, so few and simple that very soon, thereafter, he makes theexciting discovery that he is beginning to master the use of a tool that, inall its simplicity, gives him a power that far surpasses his wildest dreams.andM;Teaching to unsuspecting youngsters the effective use of formal methods isone of the joys of life because it is so extremely rewarding.andP;  Within a fewmonths, they find their way in a new world with a justified degree ofconfidence that is radically novel for them; within a few months, theirconcept of intellectual culture has acquired a radically novel dimension.andP;  Tomy taste and style that is what education is about.andP;  Universities should notbe afraid of teaching radical novelties; on the contrary, it is their callingto welcome the opportunity to do so.andP;  Their willingness to do so is our mainsafeguard against dictatorships, be they of the proletariat, of thescientific establishment, or of the corporate elite.andM;Edsger W. Dijkstra Dept.andP;  of Computer Sciences The University of TexasAustin, TX 78712-1188andM;Colleagues Respond to Dijkstra's CommentsandM;There is much in Dijkstra's statement with which I can agree.andP;  Sinceagreement results in dull commentary, I shall focus on his virgorousdismissal of the term &quot;software engineering&quot; and his denunciation of softwaretesting.andM;Most intorductory engineering texts define an engineer as one who usesscience and mathematics to produce useful products.andP;  That definition clearlyallows programmers to be considered engineers, but professional societiesand/or government licensing agencies add educational requirements and mayrequire an examination before one is permitted to use the title &quot;ProfessionalEngineer.&quot;andP;  In fact, there is much better control of the word &quot;engineer&quot; thanof the word &quot;mathematician.&quot;andP;  Just as some physicists claim to bemathematicians, other people use the word &quot;engineer&quot; quite loosely.andP;  The factthat some people write poor papers and textbooks under the title &quot;softwareengineering&quot; does not justify abandonment of the hope that, some day,programs will be produced by properly educated professional engineers.andM;Those with training in mathematics or one of the physical sciences often havethe impression that engineering involves the use of sloppy, heuristic methodsand undefined notations.andP;  Nothing could be further from the truth!andP;  Goodengineering programs emphasize the use of formal methods in exactly the waysuggested by Dijkstra.andM;My own engineering education included more courses in the MathematicsDepartment (taken side-by-side with mathematics students) than coursesoffered by the Electrical Engineering Department.andP;  Further, each of theengineering courses emphasised the use of mathematical methods for design anddesign verification.andP;  In exams and homework, we were often deliberately giventhe opportunity to apply formulae in situations where they were notapplicable; in this way, we were taught to appreciate the importance ofunderstanding the derivation of all equations and being certain that theassumptions made in the derivation were valid for the case at hand.andP;  We wretaught to understand mathematics, its development, and its use in solvingengineering problems.andP;  Great emphasis was placed on theuse of mathematics todefine precisely what we were trying to achieve with a particular design andits further use to confirm that our design met those requirements.andM;Our engineering instructors repeatedly showed us the folly of usinganthropomorphic analogies.andP;  No engineer talks about &quot;how much the electronswant to get to the other side of a capacitor.&quot;andP;  Instead, he uses mathematicalmodels to determine the intensity of field at all points between thecapacitor's plates, to look for points of maximum field intensity, etc.andM;Those who graduated from such programs were solidly grounded inthe use offormal methods.andP;  They would wonder why comments such as Dijkstra's need to bemade.andP;  They need to be made because the majority of those in our professiondo not have the beneit of an engineering education.andM;I am just as criticalof much of the work done at software engineeringinstitutes and presented at software engineering conferences as Dijkstra.andO;Most of us who use the term &quot;software engineering&quot; do so, not because wethink that programming is currently an engineering profession, but because wethink it should become one.andP;  The ability to use formal methods to derive andvalidate designs is one of the essential characteristics of an engineer.andO;However, an engineering education also teaches students to understand thelimits of mathematical methods.andP;  We were taught methods of dealing withproblems where exact mathematical models were intractable.andP;  More important,we were taught the importance of testing to (a) provide check on ourmathematical analysis and (b) verify that our mathematical model was anadequate model of the actual devices with which we worked.andP;  Anyone can errwhen using mathematics, and it is not uncommon to find that devices havecharacteristics that were not reflected in our mathematical models.andM;The situation is no different in software engineering.andP;  Errors in formalproofs are not uncommon.andP;  Further, the computers and programs that we mustuse may not have the characteristics implied by the mathematical axioms thatwe use.andP;  Testing can reveal both of those problems.andP;  While careful review canreveal mathematical errors, only testing can reveal the failure of acomponent, software or hardware, to conform to a mathematical model.andM;It is certainly true that, in most practical circumstances, testing cannotshow the absence of errors; however, properly designed statistical testingcan provide information about the probability of an error remaining in thecode or the probability of a failure occurring in use.andP;  In the imperfectworld in which we live such data can be very important.andM;There is no engineering profession in which testing and mathematicalvalidation are viewed as alternatives.andP;  It is universally accepted that theyare complementary and that both are required.andM;Dijkstra states that the &quot;computer confronts us with a radical newintellectual challenge that has no precedent in our history.&quot;andP;  He bases thison two factors: (1) the sensitivity of program behavior to minor changes and(2) the drastic increase in the &quot;size&quot; of the problems.andP;  The first of theseis not confined to digital technologies and it may be possible, in time, toovercome the second.andP;  The sensitivity to minor changes can also be present inolder technologies where resonance can lead to very steep gradients whenfrequency is varied.andP;  Such resonances can cause unexpected structuralcollapse or component &quot;burnout.&quot;andP;  Dijkstra has led the way in showing us howto master drastic increase in complexity by application of adivide-and-conquer approach.andP;  That approach has been used with great sucessin other engineering disciplines.andM;Those who are participating in a major upheaval in society rarely have theperspective to judge its historical importance.andP;  Only the passage of timewill reveal whether we need a radical new way of thinking or just a return tothe more careful and disciplined approaches used by good engineers in thepast.andM;David L. Parnas Queen's University Kingston, Ontario K7L 3N6 CanadaandM;Dijkstra recommends two principal actions concerning computer scienceeducation which are (1) that imperative and anthropomorphic thinking beeschewed by all programmers and (2) that formal methods, specifically thosebased on imperative programming languages with semantics grounded infirst-order predicate logic, be the basis for introductory programmingcourses.andP;  To motivate these recommendations, he makes several observationsabout the nature of computing and software which I summarize roughly asfollows:andM;1.andP;  computing is a &quot;radical novelty&quot; due to the immense scaling range itencompasses and due to its discontinuous nature; radical novelties, likegreat tragedies, tend to be denied.andM;2.andP;  software engineering as worthy cause is eyewash, and the very notion of a&quot;programming tool&quot; is corrupt.andM;3.andP;  computer science concerns the interplay of symbol manipulation activityby human and by machine.andM;The extensive and forceful arguments Dijkstra makes in support of thesefindings are very interesting and bear examination.andP;  I was surprised thatafter developing these arguments, the overall thrust of Dijkstra's conclusionwas so benign:andM;If we are to have a high level of confidence in the software systems wedevelop, then formal methods will have a central role in their development,and our teaching of programming should support this view from the start.andM;While I agree with the overall thrust of Dijkstra's conclusion, I do notfully concur with the particulars of Dijkstra's recommendation.andP;  There are,of course, nits to pick.andP;  For example, if scaling is one of the two &quot;radicalnovelties&quot; in computing, why propose teaching the use of a programminglanguage that does not provide the principal linguistic means for scalingup--namely, composite data types, date abstraction mechanisms, and othermeans to explicitly represents system interfaces and abstraction boundaries.andO;Edinburgh ML demonstrates how very simnple these language structures can be.andO;Also, if operational thinking is to be eschewed, why insist on an imperativeprogramming language?andM;More significantly, I am troubled by the suggestion of the firstrecommendation that certain modes of thinking be avoided in problem solving.andO;A successful problem solver will have a broad array of means at hand totackle problems (many of which are enumerated by Polya in his books) togetherwith the maturity to make choices of which means are appropriate tocircumstances.andP;  For the programmer, one of the means available is the use ofinformal operational intuition.andP;  Of course, this does not excuse failurestothink intensionally when appropriate (as in the case of the checker-boardexample, which, indeed, is often used in AI courses, too, for the samepurpose).andP;  It also does not excuse failure to come to grips with underlyingcomputational models, as in parallel systems.andP;  Even visualization has arole--mathematicians make use of visualization, for example, in theillustration of solutions for fluid flow equations.andM;But, let us set aside Dijkstra's recommendations for the moment and considerhis motivating observations, an analysis of which suggests to me that bolderrecommendations are called for.andM;Concerning the first observation: I agree with Dijkstra that, while largescaling ranges and discontinous behavior do exist in other human-engineeredsystems, few have the uniformity of structure over a broad range of scalethat exists in computing technology.andP;  I do take exception, however, toDijkstra's implication that software systems re unremittingly discontinuousand should be managed as such.andP;  While this statement is obviously true inprinciple, designers of large systems (such as a workstation applicationenvironment) deliberately seek a kind of continuity property at the higherlevels of scale.andP;  The idea is to lower risks for both customers anddevelopers by making it possible to obtain incremental improvements incapability for incremental investments.andP;  This amounts to a notion of &quot;coarsecontinuity,&quot; which has been well approximated in many clever softwareengineering designs (such as UNIX and GNU Emacs).andP;  Of course, the appearanceof continuity at one level of abstraction may, in fact, be obtained onlythrough gross redesign of a subcomponent.andP;  There is, nonetheless, a kind ofcontinuity at the higher level of abstraction.andP;  &quot;Software maintenance&quot; is,thus, the (attmpted) incremental adaptationof large systems in response tosmall changes in requirements for which this &quot;coarse continuity&quot; propertyholds.andM;Concerning Dijkstra's second observation: most large software problemsinvolve comlexity and detail that exceeds the capacity of one person todevelop solutions.andP;  In these cases, major decisions must be made undercircumstances where all the details cannot be presented to all partiesinvolved since there are too many details.andP;  The numbers of people involvedand the lack of perfect knowledge create the software engineering challengesof estimation of costs and risks, the implementation of procedures to enablemanagement of the process, the development of automation to assist, the needto design systems that can be readily adapted, and so on.andP;  Basic automationsupport can include object management, version and configuration management,process and administrative support, and consistency support for both formaland informal documentation.andP;  These needs are real, even if many products areindeed &quot;snake oil.&quot;andM;Concerning the third observation: one of the greatest difficulties insoftware development is formalization--capturing in symbolic representation aworldly computational problem so that the statements obtained by followingrules of symbol manipulation are useful statements once translated back intothe language of the world.andP;  The formalization problems is the essence ofrequirements engineering, an area left largely untouched in Dijkstra'sposition statement.andP;  Concerning symbol manipulation, at the level both ofspecific problem domains and of programming itself, it is important to havefluidity in shifting various aspects of the symbol manipulation task betweenhumans and machine and to have linguistic means to organize large problems tofacilitate this.andM;Mor can be said about Dijkstra's observations and the arguments supportingthem, but the above remarks are enough, I believe, to suggest a set ofconclusions concerning formal methods that more effectively addressedDijkstra's observations, particularly concerning the &quot;radical novelties&quot; ofscaling and non-continuity.andM;My first conclusion is that we should distinguish the necessary qualities ofthe result of the programming process from the means by which the results areobtained.andP;  The software practitioner should be able to bring all intellectualand mechanical tools to bear on devising a software system as long as certainconstraints concerning the structure and presentation of the result aresatisfied.andP;  The &quot;theorem&quot; Dijkstra refers to is, thus, really part of alarger result, which is more likely a documentation record that linkstogether implementation, specification, design and interface decisions,informal rationale, and formal proof, all in their several versions andconfigurations.andP;  The intent is that this documentation-record supportsadaptation, reuse (of appropriate assets), and analysis by capturinginformation ordinarily lost (or, worse, never present) during conventionalsoftware development, including the means, formal and informal, by whichconfidence is raised concerning consistency of specification andimplementation.andM;The second conclusion is that an appropriate means must be found toincorproate formal-methods techniques into software engineering practice andtools in order to provide a &quot;scalable&quot; approach to applying formal methods tolarger systems.andP;  Specifications and documentation can involve formal andinformal components.andP;  Formal methods can, thus, be used to establish certainkey properties while informal (and less reliable) means are used to increaseconfidence with respect to other system properties.andP;  The effect is of provingsmall theorems about large systems rather than large theorems about(inevitably) small systems.andP;  This &quot;scalable&quot; approach has the advantage ofdrastically moderating adoption risks for software managers.andM;The final conclusion concerns education.andP;  In many curricula, as Dijkstra hasnoted, we are already teaching formal methods at the earliest levels.andP;  Myexperience is that the principal difficulties in teaching formal methods donot have to do with symbol manipulation skills, but rather, withformalization issues--representing symbolically and providing structure foractual computational problems from the world--and with metatheoreticissues--understanding, from example, what sorts of assurance can be providedby proofs in a given formal deductive system.andP;  It is even more challenging tocreate an appreciation for the extent of the scaling range of computing (asDijkstra has noted) along with techniques for addressing scaling problems,particularly abstraction mechanisms for programs and specifications.andM;W.L.andP;  Scherlis Carnegie Mellon University Dept.andP;  of Computer SciencePittsburgh, PA 15213-3890 scherlis@vax.darpa.milandM;I agree that the proposed program derivation course is more valuable than theother courses in a typical computer science curriculum.andP;  In the following, Iexplain that such a course should not be taught purely as exercises in symbolmanipulation and that the ability to derive a program from a formalderivation only solves a minor part ofthe problems we are having withsoftware.andM;People who know neither programming nor mathematics (i.e., almost everyone)take for granted that programming is like mathematics.andP;  Yet, it turns outthat English majors are as likely to be as successful at programming asmathematics gradautes are.andP;  In practice, the worlds of mathematics andprogramming are just about disjoint.andP;  Dijkstra argues that this should not bethe case, that mathematics is a formal game of symbol manipulation and thatprogramming should become one.andP;  I must confess that the role of symbolmanipulation in mathematics has me thoroughly confused.andM;On the one hand, it is clear that symbolism is extremely powerful in apositive way.andP;  To see that, try to do something simple, say long division, inEnglish.andP;  The most pwerful, single experience I had in my universityeducation was getting a grip on ghostly things like gravitational orelectromagnetic fields with formulas using div, grad, curl, and, possibly,other operators long forgotten.andM;On the other hand, what makes allthis so appealing is that there is anintuition behind it.andP;  Axiomatization and formalization, by themselves, do notmake a theory into mathematics; they only mark its maturity.andP;  To bemathematics, the theory has to be significant, to appeal to the intuition.andO;The experts do not agree: one mathematician may denounce another's paper asempty formalism, devoid of mathematical content.andP;  This sounds fuzzy, and itis.andM;Hilbert is famous for viewing mathematics as a game with symbols, devoid ofmeaning.andP;  What he must have meant (and probably also said) is that themeaning is irrelevant to the validity of a formal argument.andP;  But to make theformal game worth playing, it better have meaning.andP;  Even games have meaning,at least the ones, like chess, that get played.andP;  It is easy to make up asystem that formally is a two-person game.andP;  It is hard to make it such thatpeople will want to play it.andP;  Successful games have a menaing to theirplayers.andM;Why am I saying all this?andP;  I think the course described by Dijkstra, wherestudents derive programs from logic specifications into an unimplementedlanguage, is a great idea.andP;  However, it will only work if the symbolsmanipulated have meaning for the players.andP;  And I do not see where thatmeaning can come from other than having messed around with programs that runor fail to.andP;  But, perhaps that should be another, earlier course so that theprogram derivation course can be kept pure.andM;I agree with Dijkstra that great improvements can be made by using a formalspecification and by proving that the program conforms to it.andP;  Should suchproofs be formal, i.e., valid deductionsin a sound formal system?andP;  I suggestnot to wait till this is technically possible for interesting programs.andP;  Theanalogy with mathematics is valid: theorems worth believing are not believedbecause of formal proofs which probably do not even exist.andP;  Because this isthe current state of affairs, it does not follow that things will always bethis way.andP;  It may be that the enterprise started with Automath ultimatelycontinues to success.andP;  If so, formal derivations of interesting programs willalso be possible.andP;  In this way, programming may become like mathematics, eventhough it is different from both programming and from mathematics in theirpresent form.andM;Suppose we reach the stage of always formally specifying our programs andproving them correct.andP;  Then we will only have eliminated the minor part ofthe problems we are having with software.andP;  The big problem is that it is hardto say precisely what we want.andP;  It is hard to do so in C; it is not hard todo so in predicate calculus, but it is still hard.andM;The reason why it is so hard to say what we want is that we do not reallyknow what we want (at least not in a complex system, which is where theproblems are).andP;  One way of discovering what we want is to draw up a formalspecification, derive a program conforming to it, and run it.andP;  Often, we willdiscover that the specification is wrong, or, rather, we discover that wewant something different than what we thought we did.andP;  I would like to teachthat also to the students.andP;  I would also like to teach students that it isnecessary to run the programs, not to debug the programs, but to debug thespecifications.andP;  But, perhaps, that should be another, later course so thatthe program derivation course can be kept pure.andM;M.andP;  H. van Emden Dept.andP;  of Comptuer Science University of Victoria Victoria,B.C.andP;  V8W 2Y2 CanadaandM;The early papers of Dijkstra are gems polished by the hand of an expertlapidary.andP;  I first became acquainted with his work in the early 1960s.andP;  Hehad then published a paper on a stack machine model for the interpretation ofAlgol 60: a landmark in the design and implementation of block-structuredlanguages.andP;  Following that work, there were two major contributions byDijkstra which appeared in Communications.andP;  A short article (&quot;Go-To'sConsidered Harmful&quot;) gave us ample food for thought about writing readableprograms.andP;  The third, a concise article on synchronization of parallelprocesses, introduced the concept of semaphores and paved the way for thecurrent work on programming parallel computers.andM;These early articles and papers have made an implicit revolution in computerscience.andP;  The statement appearing in this issue explicitly advocates arevolution and, in my view, presents a somber, often sarcastic view of ourfield; it offers disappointingly few constructive suggestions.andM;First, let me attempt to summarize Dijkstra's statement to bring out its truepurpose (without the embellishments and inconsistencies of the author).andP;  Thescientific community is unprepared to understand the &quot;radical novelty&quot;brought up by computers because of (1) the sheer speed of these machines andtheir vast range of computing and storing power and (2) the fact that theyare digital, which implies that a minuscule change in a program may elicitthe most unexpected of responses.andP;  Remedy: (1) teach the new generation ofscientists one way of dealing with this problem and (2) choose the simples(imperative) language and use logic (predicate calculus) to ascertain that aprogram really works for all its intended data.andP;  Dijkstra presented thismessage in detail in the book A Discipline of Programming which providesconvincing arguments for this approach.andM;My initial comments about the statement have to do with inconsistencies.andP;  Forexample, economics is referred to as &quot;the miserable science&quot;; yet, the authorproceeds to guess the enormous daily economic costs of introducing redundancyor error correction into computer hardware and software.andP;  In anotherinstance, he claims that the problems that computer scientists have to facemake the application of &quot;the average mathematicial theory [look] almostflat.&quot;andP;  Yet, he later argues in favor of &quot;the power of down-to-earthmathematics.&quot;andM;Unfortunately, the tone of the statement is uniformly negative.andP;  Thequotations include a view from one mathematician about the limitations of thebrain, a remark by the rector of a university reassuring the King of Spain ofits faculty's conservativeness, the statement of a technocrat from an oilcompany comparing the virtues of Fortran and Pascal, and so forth.andP;  Thesequotations may render the statement colorful, but they do not provideevidence for its message.andP;  It is hard to imagine that these specific viewsare espoused by a majority.andP;  The same holds true when all practitioners ofartificial intelligence and software engineering are lumped together as evilgroups.andP;  There is no doubt in my mind that there is high-quality work beingdone in these areas!andP;  Hackers are also unfairly treated in Dijkstra'sstatement.andP;  In my view, we owe them a great deal for their creativity and forthe interesting new paths they have suggested.andM;Dijkstra feels that analogue models (i.e., those with gradual changes) areinadequate to cope with the existence of digital machinery.andP;  In a way, hewishes that the scientific community and society would react digitally (i.e.,andO;by step functions) to face the problems posed by digital machines.andP;  As I seeit, gradual changes are inherent to human nature and human societis, and eventhe revolutions we have had in history actually took place at a relativelygradual pace, the definition of &quot;gradual&quot; being necessarily vague (e.g.,andO;consider the current views about the French revolution.)andP;  Dijkstra'sstatement also conveys the message that the dictum &quot;to err is human&quot; ishardly acceptable.andM;The example on covering a given chessboard with dominos and the argumentsused by Dijkstra in favor of simple proofs instead of exhaustive searches areto be taken with a grain of salt.andP;  There are many instances in which suchsearches are unavoidable and constitute the only hope of finding solutions tointeresting problems.andP;  For example, the proof of the four-color conjetureusing a large search space is definitely a valid approach, even if somemathematicians may yearn for a simpler proof (just in case it exists).andM;I agree with Dijkstra that computer programs should be considered as symbolicformulas.andP;  What is not yet established and is constantly evolving is the kindof formulas (i.e., the level of languages) which will allow us to performconvenient manipulations, minimize the possibilities of errors, and yieldefficient code.andP;  As computers become more powerful, it is likely thatvery-high-level languages will play an important role in expressing programsas increasingly more concise formulas.andP;  This situation parallels the onewhich occurred 30 years ago when the first programming languages replacedassembly languages.andP;  After all, as believers in computer science, we shouldbe among the first to exploit the advantaes of computers.andM;This response gives me an opportunity to express my own views as an educatorin computer science.andP;  Our goal should be to provide not one but severalapproaches in teaching our students how to reason about programs.andP;  Dijkstra'sapproach is one of them.andP;  Among the others are the funcitonal and logicprogramming paradigms.andP;  They all share a common denominator: urge the studentto have a healthy respect for the craft of programming.andP;  By offering a menuof approaches, the students will be better prepared to face whatever &quot;radicalnovelties&quot; may appear in the future.andP;  I also feel that learning thefoundations for writing sound programs ought to be fun and there should be agenuine sense of accomplishment when a student actually runs a program, findsunexpected errors, and corrects them.andP;  This, of course, requires inspired,broad-minded teachers; forming them is a problem for any field of endeavor,not only computer science.andM;To summarize: on one hand, it is distressing to see the lack of realisticconstructiveness in a statement by a pioneer in our field; on the other hand,the airing of the issues stemming from Dijkstra's statement should makecomputer science a better, more mature discipline.andM;Jacques Cohen Zayre/Feldberg Professor Department of Computer Science FordHall Brandeis University Waltham, MA 02254andM;Perhaps it is best to begin by recalling that long ago Dijkstra led a crusadefor the total abolition of the GOTO instruction.andP;  Currently, it is widelybelieved that the GOTO instruction is used much too often but that it alsohas its place in programming.andP;  The present statement by Dijkstra is anotherexample of Moses laying down the law to us sinners in programming.andP;  As beforeit is both very right and very wrong.andM;Unfortunately, in this statement, there is much &quot;sound and fury&quot; and nonsequiturs, the extensive use of color words, a gratuitous swipe at themilitary, and, often, little content beyond his assertions; you can detectthe extent of this if you try to rewrite his statement, as I did, in simplelanguage and clear reasoning.andM;Just as in the GOTO article, there is much truth in this statement.andP;  I agreewholeheartedly that we should replace the word &quot;bug&quot; with the word &quot;error&quot;and suppress all anthropomorphic words as being misleading to the beginners.andM;The major trouble is, I think, that Dijkstra believes that programming shouldresemble mathematics and believes that mathematics is what one is taught a laEuclid.andP;  One first lays down postulates, makes a few appropriate definitions,states theorems, and then proves them--after all, that i how mathematics istypically taught.andP;  He refuses to recognize that often the postulates followfrom the theorems, as do many of the definitions, and often the theoremsfollow from the proofs we are able to generate--they are then called &quot;proofdriven theorems.&quot;andP;  Furthermore, Dijkstra, in his sober moments, well knowsthat human proofs in mathematics are unreliable, that many famous proofs havebeen repeatedly &quot;patched up&quot; by subsequent generations; hence, even if wetried to use his idea that programs should be &quot;proved&quot; by humans before theyare run, the proofs are falliable, and, in any case, are merely paperproblems run on a paper machine.andP;  It is this that I believe is behind much ofthe statement.andM;One of Dijkstra's major points is that the rapid growth of computersrepresents a unique change of magnitude so large that no one can comprehendit; but large changes are more common than he thinks, for example, thebandwidth available for signalling.andP;  The unique features he attributes tocomputer science occur in other fields of human activity:andM;1.andP;  particle accelerators have similarly increased in size and powerconsumptionandM;2.andP;  the complexity of the telephone system of interconneted central officeswas around long before the first of the electronic computers and is stillprobably more complex than any computerandM;3.andP;  the claim of unique vulnerability to a single error is certainly sharedby our common languages.andM;Dijkstra excoriates &quot;software engineering&quot; by deliberately comparing it tohis conception of mathematics rather than to, say, &quot;effective writing&quot; whichI feel is a far better analogy.andP;  I also doubt that it is always wise toequate a program to a mathematical formula as he does.andM;Dijkstra uses the well-known example of trying to cover with dominos achecker board, without the diagonal corners, to illustrate the value of themathematical, analytical approach and concludes immediately that all programwill similarly benefit--the reasoning is fallacious and, from him, shcoking!andM;Dijkstra flatly asserts that he knows &quot;reality&quot; and his opponents do not, butI put about as much faith in this as in the statement, &quot;I am Napoleon.&quot;andO;Indeed, in my opinion he comes to grief simply because his &quot;reality&quot; is sofar from most other people's, which he admits.andM;Dijkstra objeccts to measuring programming by lines of code, convenientlyforgetting that authors are often paid by the word.andP;  In both cases, it isrdiculous at times to do so, but he offers no other practical measure ofprogramming (or writin) effort.andM;Dijkstra willfully misunderstands &quot;software maintenance,&quot; pretending that itmeans repairing parts that have failed rather than what everyone elseunderstands, mainly, altering the current software to meet changing needs andenvironments; hence, contrary to his sneer, software that is not maintainedis apt to be of much less value to the user than software that is.andM;Dijkstra seems to identify programming languages with &quot;imperative languages&quot;and deigns not to notice &quot;object-oriented&quot; and &quot;functional programming, tomention two other approaches--after all, he is Moses, and he knows whatprogramming is.andM;Returning to the main theme of this reply, his desire to map software ontohis conception of mathematics is foolish.andP;  His idea that a program be&quot;proved&quot; to be correct before running it applies, as noted before, to a paperprogram on a paper machine and not to reality.andP;  When you have to make acompiler for a new mathematically defined language, this approach is bothvery reasonable and valuable, but in many, if not most, engineering caseswhere the design criteria arise from what you are able to do this approachsimply does not work very well (as can be seen from the governmentprocurement policy in action).andP;  Even more than in mathematics, inengineering, there is a &quot;give and take&quot; between the design proposal and whatcan be done in current practice; hence, his desire to start with an exactdescription for the program that is to be written works mainly in his&quot;reality.&quot;andM;Anyone who reads the above objections to mean that what Dijkstra writes canbe safety ignored is a fool.andP;  I have documented some of the errors that hisextremism has produced, but there is much truth in his statement.andO;Apparently, reformers must often be extreme in what they say and do if theyare to achieve a reformation.andP;  Read with charity, Dijkstra's statement is avaluable contribution; Moses has indeed led us a bit further out of ourwilderness.andM;R.andP;  W. Hamming Naval Postgraduate School Monterey, CA 93943andM;In the space available it would be impossible to comment on all theprovocative suggestions in Dijkstra's statement.andP;  Instead, I shall confinemyself to challenging two of his basic premises: that computing science canbe equated with the very large scale application of logic and that theprogrammer's main task should be to give a formal proof that the program heproposes meets the equally formal functional specification.andP;  I will also takeissue with his proposal that the introductory programming course shouldprimarily be a course in formal mathematics and that students should beprotected from the temptation to test their programs.andP;  I believe that thewide acceptance of these ideas would be damaging to the field of computerscience.andM;Dijkstra's dangerous recommendations stem from a misunderstanding of the roleof formal logic in mathematical reasoning.andP;  It is, indeed, a fundamentalinsight that, in principle, a mathematical proof can be reduced to themanipulation of uninterpreted strings of symbols according to formalsyntactic rules.andP;  But, as important as this insight may be for thefoundations of mathematics, it has little bearing on the way mathematicaltruths are discovered or communicated in practice.andM;The discovery of mathematical truth is invariably an unsystematic,trial-and-error process that leans on models, pictures, analogies, examples,counterexamples, and intuitions about time, space, and number that havelittle relation to the rearrangement of symbols according to formal rules.andO;Once a mathematical truth is discovered, the &quot;proofs&quot; used to communicate itfrom one human to another are never formalized completely, if only becausesuch formalization is a hideously tedious process and because the resultingformal proofs would be opaque to human readers.andP;  The proofs that arecommunicated between humans are best viewed as persuasive arguments which,although not entirely complete or airtight, are often remarkably effective intransmitting mathetmatical insights from the mind of their discover to theminds of their readers.andM;One might argue that inasmuch as computer programs are nothing more thanformal expressions and their execution is nothing more than the applicationof formal transformation rules, computer scientists must inveitably work inthe arena of formal methods.andP;  Indeed, it seems to me that formal proof canplay an indispensable role in certain special situations such as thevalidation of short, logically intricate programs involving the coordinatedaction of several processors.andP;  But I am convinced that, for the greatmajority of programming problems, the modalities of thought and expressionthat are most useful are very similar to those that prevail in other areas ofmathematical work.andP;  The mass of tedious detail that is involved in a formalcorrectness proof of even a moderately complex algorithm is beyond the limitsof human toleration; and, alas, at the present state of the art of automatictheorem proving, the prospects of obtaining correctness proofs automaticallyor semi-automatically are rather bleak.andM;Of course, it is p ossible to reject formal correctness proofs and stillembrace the use of formal program specifications.andP;  However, a majorimpediment to the use of formal specifications is the inevitable intertwiningof software development with specification.andP;  This point has been well made bytwo of my colleagues who have extensive experience in the design of largesoftware systems:andM;&quot;I do not view the process of programming, especially programming in thelarge, as that of discovering an algorithm to a prespecified and unalterbalelogic.andP;  It is more often a process of discovery and adaptation, as variousrelevant components of a problem are examined in turn, and a goal, initiallyspecified incompletely, is reached.&quot;andP;  [Richard Fateman]andM;&quot;In my view, large computer programs tend to be inherently unspecifiable, inthe sense that there is not even a clear notion of how the programs &quot;should&quot;behave.andP;  In such systems, many of the most subtle bugs occur because our viewof how the system &quot;should&quot; behave turned out to be wrong (we've spent a lotof time over the last couple of years fixing bugs like this in Srpite).andP;  Insuch an environment, it seems to me that formal logic is unlikely to root outthe problems ...andP;  Dijkstra would probably claim that we have to businessbuilding a system until we understand exactly how it should behave, but Ithink this is impossible in any new engineering domain.&quot;andP;  [John Ousterhout]andM;I am led to the conclusion that formal proof and formal specification are notamong the most promising avenues toward getting useful and dependable resultsfrom computers.andP;  Instead, I would advocate increased research on debuggingmethods, on the use of modern programming environmentals including workstations, revision control aids, editors, and high-level programminglanguages, and on the development of special-purpose software packages, suchas database systems and spreadsheet programs, that enable evennon-programmers to use computers productivity.andM;Computers are becoming indispensable in nearly all fields of endeavor.andP;  Forexample, despite Dijkstra's claims to the contrary, they plan an increasinglyimportant role in mathematical research, where they are used to simplifyalgebraic expressions, to explore examples, and to generate graphicalrepresentations of complex geometric objects.andP;  In view of this trend, itwould be ironic if Dijkstra's prescriptions for introductory computer scienceeducation were to gain acceptance and the next generation of students were tobe denied the thrill of seeing their programs come to life on the CRT screen.andO;The result would be a fiasco unmatched since the introduction of the NewMath.andM;Nevertheless, many of the concepts behind Dijkstra's approach, if leavenedwith a bit of common sense, are well worth conveying.andP;  It is important forour students to gain facility withthe elegant notation of set theory and thepredicate calculus since these notations are useful in informal proof as wellas formal proof.andP;  Our students should certainly be taught to give reasonablyprecise informal specifications of what their programs are intended to do anywhat their data structures are intended to represent before plunging intowriting code.andP;  And the discipline of maintaining loop invariants andsatisfying preconditions and postconditions for subroutines (even if theseconditions are not stated in a formal language) is highly valuable to anyprogrammer.andP;  But, it is even more important that the next generation ofcomputer science students be exposed, as early as possible, to the practicalart of constructing large programs, with its intertwined processes ofspecification, programming, testing, and documentation.andM;Richard M. Karp Dept.andP;  of Computer Science 571 Evans Hall Univ.andP;  ofCalifornia Berkeley, CA 94720andM;Behind Dijkstra's bravado and invective there lurks a coherent argument aboutthe nature of computer science education.andP;  Coherent and interesting, butwrong, because it is based on faulty premises.andP;  To start out with, Dijkstrais wrong about what computers do, wrong about what programmers do, and wrongabout what engineers do.andM;The problem begins with his definition of computers: &quot;When all is said anddone, the only thing computers can do for us is to manipulate symbols andproduce results of such manipulations.&quot;andP;  In my vicinity of the &quot;real world,&quot;I see computers doing lots of other things.andP;  They issue payroll checks,control the motions of metalworking machines, format and print architecturaldrawings and newsletters, and keep my car's brakes from locking.andP;  In doingall this, they may manipulate symbols (and also manipulate electrical andmagnetic fields), but that is instrumental--the means to an end.andM;Now Dijkstra may object that computers are not doing all those things--I amtalking about devices that employ computers in their functioning.andP;  Fine, letus not quibble over terms.andP;  Let us call this thing on my desktop a &quot;computingdevice&quot; which employs a computer in helping me with editing, formatting, andprinting this response.andP;  As a profession, we are concerned with the overalleducation of people who will be responsible for specifying and implementingsuch devices (the software and hardware) in such a way that they will workeffectively--not just perform symbol manipulations validly, but actuallyprint a paycheck with the legal deductions, put the specified headings at thetop of newsletter pages, and produce the desired machine part.andM;The second error is in his vision of what programmers do: &quot;The programmer'stask is ...andP;  to give a formal proof that the program he proposes meets theequally formal functional specification.&quot;andP;  This is a noble goal, but itpresupposes that someone else has done all the hard work by managing tocreate a formal functional specification that is appropriate to the task athand.andP;  Dijkstra must face the unpleasant truth that it is the job of someone(again to avoid quibbling, let us call this person a &quot;computing professional&quot;rather than a &quot;programmer&quot;) to produce a collection of instructions thatallow the computing device to function apprporiately in practice.andP;  In somecases, this might be best done by producing a full formal specification andthen converting that into code, but that methodology is debatable, at best,and far from universally applicable.andM;Dijkstra's idealized view of programming shows its inadequacy immediatelywhen I try to imagine a formal functional specification of the drawingprogram I use.andP;  He says, &quot;deal with all the elements of a set by ignoringthem and working with the set's definition.&quot;andP;  Consider the set of differentways in which the motions of the mouse and its buttons are used to create andmodify images on the screen.andP;  He says, &quot;we should reason about programswithout even mentioning their possible 'behavior'.&quot;andP;  How can we do this andconsider what is to happen if I drag the cursor outside of the window whilein the process of specifying a rectangle?andP;  In other words, once we recongizethat we are engaged in the design of operational computing devices, we musttrain people to think well in operational terms.andM;The third error is in his peculiar view of &quot;software engineering&quot; and hispronouncement that its goal is self-contradictory.andP;  Engineering disciplinesare concerned with the construction of devices that can be relied upon toperform a function.andP;  The success of such disciplines derives from the factthat past experience can help us avoid future breakdowns.andP;  By drawing on theaccumulated experience of the profession, an engineer approaches a designtask with a collection of techniques, tools, and previous designs which makeit possible to create reasonably reliable devices at reasonable cost with areasonable amount of effort.andP;  The key word in this is &quot;reasonable,&quot; not&quot;optimal&quot; or &quot;perfect.&quot;andP;  There are indeed failures.andP;  Sound engineering is notthe work of the everyday practitioner.andM;In all of his carping aabout the used sad state of computer education,Dijkstra seems not to have noticed that a huge number of complex programs DOwork, not always, and not necessarily in the most elegant way, but in anincredible variety of circumstances and without the benefit of formal proof.andO;Furthermore, we are able to make more and more complex programs work, as welearn from the experience of past successes and failures.andP;  The goal ofsystematizing the knowledge gained from this experience is hardlyself-contradictory, unless one has unrealstic or idealized expectations.andM;There are, indeed, important differences between computing devices and otherkinds of devices, for the reasons that Dijkstra points out.andP;  It would befoolish to expect the methods of other engineering disciplines to applywithout change.andP;  On the other hand--despite Dijkstra's grandiose statementsabout &quot;a radically new intellectual challenge that has no precedent in ourhistory&quot; and his questionable analogies with quantum physics andnon-euclidean geometry--the alleged &quot;radical novelty&quot; of computers is not soearth-shattering as to justify throwing away past experience in order to gainthe pristine virtue of the &quot;bank mind.&quot;andM;This is not to say that everything done under the banner of &quot;softwareengineering&quot; is good or that all of Dijkstra's criticisms are wrong.andO;Occasionally, one of his errant fusillades hits a deserving target, and Ifind myself agreeing with the content of one of his remarks, if not with theill-tempered style.andP;  But it would be just as wrong to condemn softwareengineering for the occasional stupidities of people who claim to be doing itas it would be to condemn all of mathematics for the occasional stupiditiesof mathematicians.andM;From the fact that Dijkstra's premises are false, it doesnot logically followthat his conclusions are false, so let use examine them separately.andP;  He mixestwo arguments, one of which is appealing and the other of which is misguided.andM;The primary subtext of his diatribe is a complaint about the lack of rigor incomputer science education.andP;  I fully support his pleas that as educators wedemand rigorous thinking, teach the beauty of mathematics, and encourage thevirtue of facing uncomfortable truths.andP;  But, he confuses this with the claimthat the essential part of computing education lies in the ability tomanipulate formal abstractions, detached from considerations of operationaldevices, their behaviors, or their embedding in a world of people andactivities.andP;  If he deludes his students into thinking this, they are in for arude awakening when they try to function as computing professionals.andM;If he is talking about the education of &quot;computer scientists&quot; in the narrowsense of theoreticians of formal computation, there is a bit of sense to hisclaim.andP;  Much of what he says may be applicable, for example, to the trainingof theoretical physicists who at times need to engage in purely formalmanipulations without preconceptions in orde to allow for radical novelty.andO;But, it does not apply to the people who apply physical principles todesigning bridges, airplanes, or disk-drives.andP;  Although they should certainlybe proficient in mathematics, they would fail miserably at their tasks ifthey did not have a substantial knowledge of a very different kind.andP;  I takeDijkstra's argument not to be just about the training of the small elitecadre of theoreticians, but, rather, about his hundreds of freshmen--thebroad population of people who work with computing devices.andM;Their education should include a solid grounding in formal methods, but thisis just one piece of the preparatory background.andP;  To be educated, they need agrounding in the experience of the professional--the examples, methods, andpractices.andP;  They need more than just a description of these.andP;  Effectivelearning comes from the experience of developing the skills they will beemploying in their work, with observation and coaching from those who haveexpertise.andP;  This experience should go beyond the building and testing ofsmall programming exercises to include working with larger-scale systems andthe design considerations that come from their embedding in situations ofuse.andM;In this last question--the relation between mechanism and use--the currentvision of &quot;software engineering&quot; is too narrow and needs to be expanded intoa vision of design.andP;  A building is created by a combination of peopleincluding both engineers and architects.andP;  The architect's skill includesknowledge of materials and building techniques, but has a primary focus onfunction.andP;  The key questions go beyond construction to &quot;What will make thebuilding be appropriate to its uses?andP;  What will function as a good designwhen people move in?&quot;andP;  We need to develop effective (and rigorous) trainingthat builds the skills to answer these questions in designing computingsystems.andM;It may well be that in the future there will be specialized professionswithin computing, and that there will be different kinds of training for itsarchitects, engineers, and theoreticians.andP;  It would be foolish to ignore thevalue of the abstract mathematical skills Dijkstra advocates, but it would beeven more foolish to indulge the fantasy that they offer some magic thatallows students to escape the hard work of learning about real computing.andM;Terry Winograd Dept.andP;  of Computer Science Univ.andP;  of California at StanfordStanford, CA 93439andM;Dijkstra's Reply To CommentsandM;Dear Colleagues,andM;Since your comments are not dispoint, allow me to address you collectively inprinciple.andM;Of course, there is more to digital system design than the formal derivationof program from their equally formal specifications; accordingly, I expect afull-blown computer science curriculum to comprise more than &quot;an introductoryprogramming course for freshman.&quot;andP;  Please remember that my modest proposalonly pertained to the latter.andM;The choice of functional specifications--and of the notation to write themdown in--may be far from obvious, but their role is clear: it is to act as alogical firewall between two different concerns.andP;  The one is the&quot;pleasantness problem,&quot; i.e., the question of whether an engine meeting thespecification is the engine we would like to have; the other one is the&quot;correctness problem,&quot; i.e., question of how to design an engine meeting thespecification.andP;  I firmly believe that whenever we succeed in erecting such afirewall, the effort will pay off handsomely.andP;  The reason for this belief ofmine is that the two concerns deserve separation because the two problems aremost effectively tackled by totally different techniques.andP;  (They arecurrently psychology and experimentation for the pleasantness problem andsymbol manipulation for the correctness problem.)andM;Several of you have voiced a wider concern, viz., serious doubts about theviability of a much more formalized mathematics.andP;  I can understand yourconcern because, for many years, I shared your doubts.andP;  Over the last decade,however, those doubts have largely evaporated, to the extent that I expect,say 50 years from now, the mathematical informality of today definitely to bea thing of the past.andP;  (I realize that this is a somewhat gratuitous statementbecause, if my expectation will not be fulfilled, I will not be there to beconfronted with my mistake.andP;  But, I cannot help having expectations beyond mylifetime.)andP;  The expectations are based on the experiences and observationscollected since I started to explore the extent to which the experiencegathered in programming methodology could be transferred to mathematicalmethodology in general.andP;  I shall indicate them briefly.andM;1.andP;  The presumed dogma that calulational proofs are an order of magnitude toolong to be practical has not been confirmed by my experience.andP;  On thecontrary, well-chosen formalisms provide a shortland with which no verbalrendering can compete.andM;2.andP;  Through most of this century, mathematical logic has primarily been usedfor soul-searching.andP;  As a tool for daily, practical proof design it hashardly been given a fair chance.andP;  To realize its potential, it seemsessential to view the purpose of logic not as mimicking human reasoning butas providing a calculational alternative to it.andM;3.andP;  In proof design, strong heuristic guidance can be extracted from asyntactic analysis of the theorem and from (baby) proof theory.andP;  Bothpossibilities require formalization of the proof structure for theirexploitation.andM;4.andP;  While informal mathematics, with its ties to elusive entites such as&quot;intuition&quot; and &quot;the human mind,&quot; is a hard topic to teach explicity, symbolmanipulation is tangible.andP;  The effective techniques of symbol manipulationare well within the teachable domain, hence my estimate of 50 years.andM;The possible future of mathematics that I envisage is very different fromwhat the dyed-in-the-wool member of the mathematical guild of today is usedand probably attached to.andP;  My dream could very well be his nightmare.andP;  So beit.andP;  I cannot consider such discrepancy my fault.andP;  If you have a technicalargument--why my expectation of the future of mathematics cannot cometrue--please let me know, for it would save me a lot of work and a lot ofanimosity.andM;Finally, allow me to express my appreciation for the care with which youphrased your comments.andP;  I end with my greetings and best wishes to you all.andO;</TEXT></DOC>