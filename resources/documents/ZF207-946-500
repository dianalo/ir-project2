<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-946-500  </DOCNO><DOCID>07 946 500.andM;</DOCID><JOURNAL>Dr. Dobb's Journal  Nov 1989 v14 n11 p28(11)* Full Text COPYRIGHT Mandamp;T Publishing 1989.andM;</JOURNAL><TITLE>A parallel make with DESQview: dvmake can easily run four tasks atonce. (make is a Unix tool)(includes related articles on theDESQview toolset and what the make tool does)</TITLE><AUTHOR>Streich, Mark.andM;</AUTHOR><SUMMARY>The main purpose of 'make,' a Unix tool, is to determine whichfiles of an application need to be recompiled and then to issuethe necessary commands to do so.andP;  The writer presents a parallel'make' developed with the aid of DESQview called dvmake, whichwill run on original to 386-based PCs.andP;  The program requiresDESQview in order to run.andP;  The full C code for the program isgiven.andP;  Running dvmake is very simple; dvmake can be run in a DOSwindow with as few as 64Kbytes available.andM;</SUMMARY><DESCRIPT>Product:   Desqview (Operating system enhancement) (computer programs)IBM PC (Microcomputer) (computer programs).andO;Topic:     UNIXProgram Development ToolsMultitaskingParallel ProcessingCompilersSoftware DesignUtility Programs.andO;Feature:   illustrationcharttableprogram.andO;Caption:   Control-flow diagram showing parallel tasks. (chart)dvmake comparison with make. (table)Full dvmake program in C. (program)andM;</DESCRIPT><TEXT>A Parallel make With DESQviewandM;The make utility started out as a Unix tool for creating executableapplications from a large number of program files.andP;  Its main purpose is todetermine which files of an application need to be recompiled and issuewhatever commands are necessary to do so.andM;As computers with multiple processors became available, some developerscreated make utilities capable of executing the various make commands onseparate processors.andP;  This allowed each processor to make a separate target,which resulted in faster make times, although the speedup was not as great asexpected.andM;Unfortunately, parallel computers have not yet reached the masses, althoughmultitasking environments and operating systems for single-CPU computershave; such operating systems, Unix and OS/2 among them, are great -- if youhave several megabytes of memory, a fast hard disk, a 386, and the money tobuy the toolkits.andM;With this in mind, I decided to develop a parallel make that DDJ readers canboth use and afford.andP;  After surveying the available development environments,I turned to Quarterdeck Office System's (QOS, Santa Monica, Calif.) DESQview,which can juggle programs running on everything from the original to fast386-based PCs, to create a parallel make I call dvmake (short for &quot;DESQviewmake&quot;).andP;  Listing One, page 86, lists the C code for the program.andM;dvmake requires DESQview in order to run.andP;  DESQview-specific applicationslike dvmake make extensive use of DESQview's API and usually take advantageof DESQview's ability to spawn new tasks, display menus, and communicate withother applications.andP;  (Other types of DESQview applications include those thatact differently running under DESQview than they do running under DOS alone,as well as those that don't take advantage of any of DESQview'scapabilities.)andM;What Is Tehre to Gain?andM;The idea behind parallel computers, and supposedly behind multitaskingsoftware, is that a computer can get more done in the same amount of time ifit's doing two or more things simultaneously.andM;make often needs to do several things, and until now it had to do them oneafter another.andP;  For example, make may have to compile three C source filesone after another, then link the object files together to create andexecutable program.andP;  Let's assume that it takes 1 minute for each compilationand 1 for the linking step for a total of 4 minutes.andM;dvmake, on the other hand, can easily run four tasks at once, sotheoretically, you can remake the entire program in 1 minute.andP;  Wrong.andP;  Thebest that you could hope for is 2 minutes because the linking step can't evenstart until all of the object files have been created (meaning the sourcefiles have been completely compiled).andM;Let's assume it takes 2 minutes to compile a program called farm.c, and thatyou only have enough memory to run two tasks at a time.andP;  If you compile botha program called pig.c and another called cow.c in parallel (taking 1minute), and then compile farm.c, you spend 3 minutes compiling.andP;  If yourearrange the scheduling, you could compile farm.c and pig.c in parallel, andafter pig.c completes, then compile cow.c.andP;  This ordering would take only 2minutes.andM;Now that you know how to schedule parallel tasks, you should know that dvmakedoes nothing to optimize the scheduling because no matter what you do, asingle-CPU computer requires (at least) the same amount of time to runseveral tasks in parallel as it does to run the same tasks sequentially.andO;After all, it can only execute one instruction at a time.andM;Who's on First?andM;Although dvmake does not optimize the scheduling, it does have to guaranteethat a target file's dependents are available before the target can be made.andO;This means: All object files must be created before they can be linkedtogether to create the executable program.andM;dvmake uses a three-step process to determine what needs to be made and then,using a &quot;greedy&quot; algorithm, schedules those items to be made.andP;  (For adescription of the greedy algorithm, see &quot;Simulated Annealing&quot; by MichaelMcLaughlin, DDJ, September 1989.)andM;The first step is similar to the original mk program written by Allen Holub(DDJ, August 1985).andP;  A binary tree, sorted on the target file name(being_made), is created by reading the mkfile.andP;  Each node in the treecontains the target, its dependents, its time and date stamp, and thecommands to remake the target.andP;  The dependencies( ) function creates thisbinary tree.andM;The binary tree is traversed recursively in make_queue( ), starting at First,which is either the first target listed in the mkfile or at the target nameyou add to the command line when running dvmake.andP;  Rather than traversing thebinary tree depth-first, left-to-right, the recursion is based on thedependents of the target.andP;  For a particular target file to be made, it mustbe either a director or indirect dependent of First.andM;If a target file has dependents that have time stamps more recent than itsown, the target file is added to a queue of items to be made (MkQueue).andP;  Thetarget's time stamp (in the binary tree, not on disk) is changed to fool anyparents of the target file into thinking that they too must be made.andM;You may wonder why I put the item to make in a queue, when I could just aseasily make the item once I known it has to be made.andP;  (In fact, this isexactly how the mk program works.)andP;  The answer is scheduling.andM;By placing the targets to make in a queue, we can easily find any targetswhose dependents have all been made and start making them in parallel.andP;  We'renot stuck with the order provided to us by recursively searching the binarytree.andP;  If some intrepid reader decides to add a smarter scheduling algorithm,it is much easier to do so with a queue.andM;dvmake is a sequential program up through the execution of make_queue( ).andP;  Bykeeping most of the program sequential, it can be debugged using availabletools.andP;  Once multiple tasks are created, neither CodeView nor Turbo Debuggercan help, and the QOS API Debugger only tracks the API calls our programmakes, not where our program is executing.andM;Once make_queue( ) has completed, MkQueue is either empty or contains a listof target files to make.andP;  If there is something to make, we start the thirdpart of the make process.andP;  To help you understand what is about to beexplained, Figure 1 shows when parallel tasks are started and stopped.andM;The startup( ) function creates two new, concurrently executing tasks.andP;  AsFigure 2 illustrates, one task executes the dvmenu( ) function that displaysa small menu that allows you to stop the program.andP;  The other task runs themake( ) function that determines which target files can be made.andM;Both of the new tasks run in parallel with the &quot;main line&quot; program that callsthe output( ) function.andP;  output( ) manages the output from the variousprograms that are specified in the command blocks of the mkfile.andM;The make( ) function constantly checks to see if there is a target file inMkQueue that has all of its dependents available, as noted by the made flagsin their nodes.andP;  If it finds one, it attempts to start an application windowcapable of running the commands listed below the target in the mkfile.andO;(Starting an application window is identical to using DESQview's Open Windowcommand.)andM;Once the application window has been created, another task is started thatexecutes the dispatch( ) function.andP;  dispatch( ) sends commands to theapplication window to create the target file, and when all of the commandshave been sent, it sends an Exit command for the window to close itself.andM;Although I've glossed over many of the details so far, you probably haverealized that there are alweays three tasks executing concurrently, plus twotasks for each target file being made.andP;  It may seem like overkill, but thedivision of labor among the tasks keeps intertask communication (andinterruptions) to a minimum.andP;  And there is little housekeeping on our part.andO;Each task does its work and stops.andP;  DESQview gets rid of completed tasks.andM;The DESQview APIandM;Before we get into the details of the program, you should have a basicunderstanding of the DESQview API.andP;  The API allows you to access numerous&quot;objects&quot; such as windows, keyboards, and mouse pointers.andP;  As I've alreadymentioned, you can start or stop separate threads of control known as&quot;tasks.&quot;andP;  The API also provides mailboxes for intertask communication or, aswe use them, for semaphores.andM;Semaphores are extremely important in parallel programs because theyguarantee that only one task can access a device or data structure at a time.andO;dvmake uses them to ensure that only one task accesses a given queue at anytime.andP;  If several tasks attempted to get an item from a queue at the sametime, they might all get the same item, rather than separate items that theyreally want.andM;Mailboxes are treated as semaphores by using two API mailbox functions,mal_lock( ) and mal_unlock( ).andP;  If a mailbox is currently locked, any tasksthat attempt to lock it are suspended until it becomes unlocked, at whichtime the first task that tried to lock it succeeds.andM;All API objects are known by their handle, an unsigned long integer.andP;  Eachobject is accessed using that object's functions.andP;  Window function namesstart with win_, task functions with tsk_, mailbox functions with mal_,application functions with app_, and so on.andP;  API functions that do not fitone of the object categories start with api_.andM;Meet Your MakerandM;The make( ) function is only concerned with finding the target files inMkQueue that have all of their dependents available.andP;  It removes a targetfrom the queue, runs through the target's dependent list (depends_on), andeither puts the target back in MkQueue (if the target has unmade dependents)or gets ready to start making the target.andM;Making a target requires an application window capable of executing thecommands listed in the mkfile and another task to issue all of the commandsto the application window.andP;  The application window is simply a DOS shell thatwaits for commands to be entered through the keyboard.andM;The API function, app_start( ), takes as an argument a pointer to a programinformation file (PIF) that has been either loaded into memory from disk orcreated in memory, which pif_init( ) does.andP;  The PIF structure has the samelayout as the DVP files that DESQview creates for applications in the OpenWindow menu.andM;The app_start( ) function has several problems that need to be addressed.andO;DESQview can only start as many programs as can fit in RAM.andP;  When it attemptsto start a program when there is not enough RAM, DESQview swaps otherprograms to disk to make room, causing those programs to stop whatever theywere doing.andM;You should set System Swapping in the Rearrange-Tune Performance menu to Noto avoid the performance penalty of swapping.andP;  Or you can simply set theSwapping option to No for the window in which you run dvmake.andP;  If you don't,dvmake may get swapped to disk, leaving the open application windows idle.andM;Another problem with app_start( ) is that whenever it is called, any DESQviewmenus that are being displayed are removed from the screen as if you hadescaped out of them.andP;  Because make( ) sits in a loop while attempting tostart applications, you are essentially forbidden access to any of DESQview'smenus, including resizing or moving windows.andM;To access DESQview menus, you must first enter DESQview with &quot;Exdev&quot; via themenu that is put on the screen by dvmenu( ).andP;  When you select the menuoption, the make( ) function stops calling app_start( ) until you either quitor deselect the option.andP;  This does not stop the other tasks from running, itmerely keeps any new tasks from starting.andM;The final problem I had with app_start( ) is that the application window itcreates always becomes the foreground window.andP;  This can be partially overcomeby forcing the application to the background with the app_go-back( ) APIcall.andP;  Even with the small time delay between the two calls, the newapplication window can &quot;eat&quot; some keystrokes, including dvmake, that you mayhave typed into the foreground window.andM;After the application window is open, another task is created that runs thedispatch( ) function.andP;  dispatch( ) sends commands to the application byplacing the keystrokes directly into the application's keyboard buffer.andP;  Itaccomplishes this by using the key write( ) API call.andM;dispatch( ) also plays a key role in how you see the output from the variouscommands that are running concurrently.andP;  Rather than forcing you to makesense of output being displayed in each of the application windows,dispatch() attempts to redirect each command's output to a temporary file.andO;The output() function is responsible for displaying the temporary files inthe main window.andP;  The output is displayed in a reasonable order, and you canthen redirect it to any file you choose.andM;Making SomethingandM;Running dvmake is extremely simple, although there are many cautionary notes.andO;You can run dvmake in a DOS window with 64K or more RAM available to it.andP;  Thewindow must be nonswappable, have about 15K of system memory (setable on theAdvanced Options screen from Change a Program), be able to run in thebackground, not write directly to the screen, and share the CPU when in theforeground.andM;Because dispatch() sends commands to application windows through thekeyboard, any programs you use cannot intercept keyboard input.andP;  If they do,the commands that dispatch() sends may be received by your program ratherthan the application window, and will therefore not be executed as DOScommands.andM;Most development tools allow you to specify all needed parameters on thecommand line, which you must do.andP;  There is little reason to run severalprograms at the same time if all of them are expecting input from you,because you can only type into one of them at a time.andM;The command to run the program is: dvmake [-w] [-k nnn] [target], and allthree parameters are optional.andP;  The -w switch allows you to see theapplication windows rather than the default of hiding them.andP;  The -k nnnswitch allows you to specify the amount of memory to give to each applicationwindow if the default of 256K is either not enough or too much.andP;  You canspecify which target file to make by adding its name to the command line.andM;You must have the DESQview API C Library to compile the program, although Ihave included a runnable version on this month's source code disk.andP;  Be sureto compile the program with byte-alignment ON, or else the PIF structure willnot be correct.andM;Th Bad NewsandM;I Forewarned that running multiple tasks on a single-CPU computer wasinefficient; I must slightly modify Jerry Pournelle's Law from &quot;One user perCPU&quot; to &quot;One task per CPU.&quot;andM;To test dvmake, I had it make the Small C compiler using the Small C compilerand Borland International's Turbo Assembler and linker.andP;  I ran the programusing DESQview, Version 2.24, on my Dell Model 310 (20MHz 386) with 2 Mbytesof memory and Quarterdeck's QEMM memory manager.andP;  I also compared dvmake'stime with Borland's make program running under DOS alone and as the only taskunder DESQview.andP;  Table 1 shows the results.andP;  Comparing the times forBorland's make shows how much overhead is involved to simply have DESQviewavailable.andP;  There was not much additional overhead to run multiple tasksunder dvmake.andP;  For those of you who are interested, I was able to get allfour parts of Small C compiling at once.andM;Extending the ProgramandM;You can improve dvmake in any number of ways, many of which I considereddoing, but rejected because the program would have ended up all make andlittle DESQview.andM;You may consider adding the aforementioned optimized scheduling algorithm,although as I mentioned, you will get little more than the satisfaction ofknowing that the program is not wasting its time.andM;A more useful addition would be some type of parameter for each target filethat specifies the amount of RAM to allocate for its application window.andP;  Youcould then tailor each window to the programs that make the target, and getmore tasks running concurrently.andM;Final ImpressionsandM;dvmake should satisfy everyone's desire to put their computer through itspaces.andP;  Those of you with 33MHz 386s and 8 Mbytes of RAM should be able toslow it down to about half the speed of the original PC, creating moreleisurely development cycles.andM;Overall, I was impressed with how the DESQview API performed.andP;  As the sourcecode shows, it's fairly simple to create multitasking programs.andP;  This is afar cry from the two-page &quot;Hello, World&quot; programs using OS/2, but then again,you still have to shoehorn your programs into 640K.andM;ReferencesandM;Baalbergen, Erik H. &quot;Design and Implementation of Parallel Make,&quot; ComputingSystems, Vol.andP;  1, No, 2, Spring 1988.andM;Holub, Allen.andP;  &quot;C Chest,&quot; Dr. Dobb's Journal, August 1985.andM;Davis, Stephen R. DESQview, A Guide to Programming the DEWQview MultitaskingEnvironment, (Redwood City, CA: Mandamp;T Books, 1989).andM;Almasi, George S. and Gottlieb, Allan.andP;  Highly Parallel Computing, (RedwoodCity, CA: Benjamin/Cummings, 1989).andM;AvailabilityandM;All source code for articles in this issue is available on a single disk.andP;  Toorder, send $14.95 (Calif.andP;  residents add sales tax) to Dr. Dobb's Journal,501 Galveston Dr., Redwood City, CA 94063, or call 800-356-2002 (from insideCalif.) or 800-533-4372 (from outside Calif.).andP;  Please specify the issuenumber and format (MS-DOS, Macintosh, Kaypro).andM;Mark is currently a graduate student at the University of Colorado inBoulder, specializing in compilers and parallel computers.andP;  He may becontacted through the DDJ office.andO;</TEXT></DOC>