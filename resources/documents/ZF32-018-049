<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO> ZF32-018-049 </DOCNO><DOCID>11 489 922</DOCID><JOURNAL>AI Expert  Nov 1991 v6 n11 p13(5)* Full Text COPYRIGHT Miller Freeman Publications 1991.andM;</JOURNAL><TITLE>More on recursion and recursion and recursion and .... (AIApprentice)(column) (Tutorial)</TITLE><AUTHOR>Minasi, Mark.andM;</AUTHOR><SUMMARY>Performing iterative tasks under Prolog requires the use ofrecursion techniques, which do not contain any looping commands.andO;Several examples of using recursion techniques, including bothinfinite recursion and tail recursion, are presented.andP;  Theexamples include the definition of the first and second rules,known collectively as the 'member' rule.andP;  The 'member' rule isused in a transitivity example where it is determined thatwhenever transitivity is needed, programmers should use the factsto start a search and consequentially use the recursive rule; thistechnique prevents infinite recursing.andM;</SUMMARY><DESCRIPT>Topic:     RecursionProgram Development TechniquesArtificial IntelligenceTutorialExpert SystemsRule-Based SystemsProgramming Instruction.andO;Feature:   illustrationchart.andO;Caption:   (chart)andM;</DESCRIPT><TEXT>Last month, we saw how recursion is used in Prolog, and I made the point thatrecursion is the only way to perform iterative tasks under Prolog: it has nolooping commands.andP;  This month, we'll look at some other examples, discuss thedreaded Infinite Recursion, and get warmed up writing small Prolog programs.andM;I created a Prolog &quot;member&quot; rule last month, a rule that lets you testwhether or not a particular atom is in a list.andP;  It looked like this:andM;member(X, [Xl-andrsqb;).andM;/* Rule 1 - the anchorandM;member(X,[_ |Y]) :- member(X,Y).andM;/* Rule 2 - iteration rule */andM;To continue our examination ofandM;recursion, let's see how Prolog answersandM;the query:andM;member(a,[b])?andM;It tries the first rule, shown in ListingandM;1.andP;  It fails, so backtrack and tryandM;the second rule (Listing 2).andP;  To answerandM;this section, try to answer theandM;subgoal member((i,[ ] (Listing 3).andP;  AsandM;both possibilities for member(a,[ ])andM;fail, member(a[]) fails.andP;  Both possibilitiesandM;for member(a, [b]) are thenandM;proven to fail, so member(a,[b])andM;fails.andM;INFINITE RECURSIONandM;Recursion can, however, be a largeandM;pain to work with.andP;  Suppose we haveandM;facts about ownership:andM;andgt;owns(paul,maserati).andM;But suppose I want to express theandM;following notion: if A owns B, andandM;Browns C, then A owns C. This exandM;-pression would be &quot;transitivity ofandM;ownership.&quot; How would I renderandM;this expression in Prolog? Simple,andM;you may say:  Just add the followingandM;rule&quot;:andM;andgt;owns(X,Y) :- owns(X,Z), owns(Z,Y)andM;As this rule refers to itself, it fallsandM;within our definition of a recursiveandM;procedure.andP;  (Some people say thatandM;recursive&quot; comes from &quot;re&quot; (toandM;repeat something) and &quot;curse&quot; (toandM;utter profanity), leading to &quot;reandM;-cursive&quot;: to curse again, which youandM;do a lot of when doing recursiveandM;programming.)andM;But this rule won't work.andP;  If youandM;ask owns(XY)?, Prolog just thinksandM;for a while, finally announcingandM;something like STACK OVERFLOW.andM;Here's why: for owns(XY) to be satisfied,andM;you either must have a factandM;that satisfies it, or you must have aandM;rule letting us derive a new fact.andM;For now, however, set aside theandM;facts and look at how rules are satisfied.andM;In this case, Prolog sets up aandM;kind of 'things to do&quot; list, an AND/andM;OR tree (Listing 4).andP;  Here, Z is aandM;&quot;temporary&quot; variable that PrologandM;will use for the moment.andP;  As we'veandM;seen before, Prolog uses variablesandM;with names like _0 or _24, (an unandM;-followed by a number).andM;Having set up the tree, it seesandM;what it can do.andP;  owns(paul, maserati)andM;is known and can be reported andandM;used to try to fill out the tree  ListingandM;5).andP;  Now, Prolog asks, how canandM;owns(maserati,Y) be satisfied? LikeandM;before, owns(maserati,Y) can eitherandM;be satisfied by a fact in the databaseandM;or by satisfying the two conditionsandM;in the owns rule.andP;  To see thisandM;process, we must expand the tree,andM;expanding the &quot;things to do&quot; listandM;(Listing 6).andP;  Thus, Prolog's &quot;thingsandM;to do&quot; list now looks like:andM;1.andP;  Satisfy owns(maserati,A)andM;2.andP;  Use A to bind owns(A,Y)andM;3.andP;  Find a Y which will let me satisfyandM;owns(A,Y)andM;4.andP;  That will satisfy owns(maserati,Y)andM;for the YandM;5.andP;  Once that process is done, IandM;will have satisfied owns(paul,Y) forandM;the Y.andM;To you and me, it is obvious thatandM;things aren't getting better, andandM;having to satisfy owns(maserati,A) isandM;no easier than satisfying owns(maandM;-serati,Z) was.andP;  Prolog, however, is byandM;nature optimistic, trying every possibleandM;trick to satisfy this goal.andP;  ItandM;then says, &quot;Let's dig into satisfyingandM;owns(maserat?,A),&quot; leading to ListingandM;7.andM;Again, Prolog's &quot;things to do&quot;andM;list now looks:andM;1.andP;  Satisfy owns(maserati,B)andM;2.andP;  Use B to bind and then satisfyandM;ownss(B,A) for some AandM;3.andP;  Once A is bound, owns(maseraandM;-ti,A) is satisfiedandM;4.andP;  Use A to bind and satisfyandM;owns(A,Y)andM;5.andP;  That process will satisfy ownsandM;(maserati,Y) for the YandM;6.andP;  Once that process is done, IandM;will have satisfied owns(paul,Y) forandM;the Y.andM;This process will continue untilandM;the space used for the &quot;things toandM;do&quot; list-the stack-fills up.andP;  ThisandM;process is infinite recursion.andP;  InfiniteandM;recursion is a lot like standardandM;infinite loops, but a little harder toandM;detect and correct.andM;TAIL RECURSIONandM;In the case of creating a transitiveandM;&quot;owns,&quot; the answer is (as it oftenandM;will be) a technique called &quot;tail reandM;-cursion.&quot; First, create a predicateandM;with a name like owns:andM;possesses(X,Y) :- owns(X,Y).andM;/* Rule 1 */andM;This predicate handles the easyandM;rule: if data indicates that X ownsandM;Y, then X possesses Y. Now for theandM;transitive rule:andM;possesses(X, Z) :-     /* Rule 2 */andM;owns(X, Y),andM;possesses(Y, Z).andM;Assume the following database exists:andM;owns(paul,maserati).andM;Rooting the rule in a fact first,andM;then allowing possible recursion,andM;keeps the infinite recursion fromandM;happening.andP;  Putting the recursiveandM;term at the end is called &quot;tail recursion.&quot;andM;Let's see what happens.andM;The initial rule is seen andandM;satisfied first, so the &quot;owns&quot; clauses areandM;parroted back.andP;  Then the recursiveandM;rule, Rule 2, is activated:andM;possesses(X,Y) if:andM;Rule 1:      OR    Rule 2:andM;owns(X,Y)          owns(X,Z)andM;ANDandM;possesses(Z,Y)andM;Rule 1 has been used up: PrologandM;reports X=paul, Y=maserati.andP;  BackandM;-tracking, Prolog tries out Rule 2andM;(Listing 8).andP;  Notice that this processandM;is an AND tree.andP;  owns and possesandM;-ses(Z,Y) are not independent rulesandM;but separate goals in Rule 2.andM;Owns() is the first clause, so it succeedsandM;with owns(paul,maserati) (ListingandM;9).andM;Now we seek to satisfy the goalandM;possesses(maserati,Z).andP;  As before, twoandM;methods can satisfy this goal: eitherandM;owns(Maserati,Z) (Rule 1) orandM;possesses (maseratl,Z) (Rule 2).andP;  ListingandM;10 continues the process.andP;  RuleandM;2 is then expanded and testedandM;(Listing 11).andP;  Note that I am usingandM;A as an internal Prolog variable.andM;Notice, however, that beforeandM;even trying to satisfy possesses(A,Z),andM;owns(maserati,A) must be satisfied.andM;As nothing comes up in the search,andM;the Rule 2 question Possesses (inaserandM;-ati, Z)? fails and the search ends.andM;Nothing here is difficult.andP;  TheandM;basic idea is that whenever transitivityandM;is required, use facts to startandM;the search and they? use the recursionandM;rule.andP;  That way, if you don'tandM;get past the facts you can't start inandM;-finitely recursing.andM;A &quot;LENGTH&quot; RULEandM;You can only talk about it for soandM;long: eventually, you've got to doandM;it.andP;  Through the end of this monthandM;and for the next few months, we'llandM;take some simple list rules and defineandM;them recursively (since weandM;have no other choice).andP;  Recall theandM;discussion of the rule member(XY).andM;Suppose we would like to knowandM;the length of a list-the numberandM;of elements in the list.andP;  Basically,andM;the length of a list can be thoughtandM;of recursively as equal to 1 +andM;length(tail(list)).andP;  Let's startandM;notion:andM;length(X,L) is a good start:andM;X will be the list,andM;and L will hold the length.andM;As a first cut,andM;length(X,L) :andM;-tail(X,Y) , length(Y,L1)andM;L is L1 + 1.andM;The i's, recall, is Prolog's assignmentandM;operator (except in the caseandM;of Turbo Prolog, which simplyandM;uses &quot;=&quot;).andP;  This operator needsandM;the tail function.andP;  We can define itandM;as tail(_\ Y],Y).andP;  Alternatively (andandM;less clearly to the human reader),andM;the two rules could be combined:andM;length([_|Y],L) :andM;-  length(Y,L1) , L is L1 + 1.andM;This combination is the way mostandM;Prolog texts express it.andP;  The firstandM;way is a little easier for humans toandM;read.andP;  The second way runs faster.andM;With a little practice, human readersandM;come to see the two waysandM;equally clearly.andM;andgt;length([a,b,c],R)?andM;R = 3andM;andgt;length([a],N)?andM;N = 1andM;andgt;length([],N)?andM;NOandM;Oops-what to do? Recognize thatandM;the empty list is always an importantandM;boundary condition.andP;  We needandM;two rules (in addition to the tailandM;rule):andM;tail  [- i Y ], Y).andM;length([ ],O).andM;length(X,L) :andM;-  tail(X,Y) , length(Y,L1)andM;L is L1 + 1.andM;Now it'll work fine.andP;  Tune up your Prolog skills: more programs coming nextmonth.andM;WHY DON'T YOU WRITE?andM;Before I go: remember any comments or correspondence for me can either go toAI Expert directly (if you still use paper to send mail), orelectronic-mailed at MCI Mail (MMINASI), BIX (mjminasi), or CompuServe(71571,264).andP;  1 check with varying amounts of promptness, so if I don't getback to you immediately, be patient.andO;</TEXT></DOC>