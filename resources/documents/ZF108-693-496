<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-693-496  </DOCNO><DOCID>08 693 496.andM;</DOCID><JOURNAL>IBM Systems Journal  June 1990 v29 n2 p209(19)* Full Text COPYRIGHT International Business Machines Corp. 1990.andM;</JOURNAL><TITLE>Repository Manager technology. (IBM's specifications managementsystem)</TITLE><AUTHOR>Sagawa, J.M.andM;</AUTHOR><SUMMARY>IBM's Repository Manager enables specifications involved in theprogram application development process to be managed.andP;  On thebasis of the technology, the Repository Manager/MVS was developedas a product.andP;  The primary concepts and services of the technologyare introduced, and specific aspects of the product and itsoperation are discussed.andP;  A discussion of what is involved indesigning and implementing a tool is also included.andP;  (Reprinted bypermission of the publisher.)andM;</SUMMARY><DESCRIPT>Company:   International Business Machines Corp. (products).andO;Product:   Repository Manager/MVS (CASE software) (usage).andO;Topic:     Software EngineeringApplications ProgrammingSystem DevelopmentData Management.andO;Feature:   illustrationgraphchart.andO;Caption:   Repository Manager function and data model. (graph)Object control, conceptual view (CV). (chart)Tool development steps. (graph)andM;</DESCRIPT><TEXT>Repository Manager technology IBM's Repository Manager[TM] enablesspecifications involved in the program application development process to bemanaged.andP;  On the basis of the technology, the Repository Manager/MVS[TM] wasdeveloped as a product.andP;  The primary concepts and services of the technologyare introduced, and specific aspects of the product and its operation arediscussed.andP;  A discussion of what is involved in designing and implementing atool is also included.andM;Repository Manager[TM] (RM) provides a system approach to managingspecifications.andP;  In IBM'S Systems Application Architecture[TM] (SAA[TM])strategy, Repository Manager is a system to support the development andexecution of software engineering tools for application development, [1]computer and network system management, and other application families.andP;  Ituses an extended three-schema approach to enable the specification,transformation, and execution of tool systems, while enforcing specifiedcorporate standards.andM;In the first four sections of this paper, the primary concepts and servicescomprising Repository Manager technology in Repository Manager/MVS[TM]Release 1 (RM/MVS) are introduced.andP;  In the next two sections, the conceptsand facilities that are provided for tool development productivity areexplained.andP;  Next, the relationship between the RM/MVS product and theRepository Manager portion of the SAA Common Programming Interface(repository CPI) is shown.andP;  Finally, some implementation-specificcharacteristics of the RM/MVS product are mentioned and current and futurework is outlined.andM;The concepts and facilities described in this paper are introduced in themanual, Repository Manager/MVS: General Information, [2] where the emphasisis on the RM/MVS product.andP;  The intent of this paper is to emphasize the basictechnology of Repository Manager.andM;The architecture of Repository ManagerandM;The Repository Manager architecture has two major domains: (1) specificationand (2) run-time services.andP;  The specification domain encompasses the conceptssupporting machine-readable specifications of tool structure and behavior, aswell as end-user tools and program-callable functions for creating andmaintaining these specifications.andP;  The role of run-time services is to enableexecution of the specifications and to enforce global standards stated in thespecifications.andM;Specification domain.andP;  RM manages specification by grouping assertions intorelated models of data and function.andP;  These models are further grouped intothree categories called views: [3] (1) the conceptual view (CV), which isglobal, or common, across all tools and systems, (2) the storage view (SV),which models dependencies on system environments and services, and (3) thelogical view (LV), which is specific to a tool.andP;  The views are depicted inFigure 1.andM;The conceptual view data model.andP;  Data are modeled in the conceptual view asentities, attributes, and relationships.andP;  These data representations arebased on the work of Peter Chen.andP;  [4,5]  Data value constraints, calledintegrity policies, are included in the model.andP;  entities and relationshipscan be grouped together and modeled as entity aggregations.andP;  Entityaggregations are similar to the IBM Database/Data Communications (DB/DC) DataDictionary &quot;structure&quot; [6] and the aggregation concepts of John and DianeSmith [7] and Dennis McLeod.andP;  [8,9]  More abstract groups can be modeled as&quot;objects.&quot;andP;  RM objects are similar to objects of OOPS (object-orientedprogramming system) [2,10] but with some important differences.andP;  RM objectscan be abstractions for managing data in entity-relationship (ER) form and infiles or other external forms.andP;  RM objects are managed with composite datalocks, which persist across system restarts, whereas typical OOPS systems donot have such multiuser locks.andP;  The RM-managed data that are locked canreside in multiple database management system (DBMS) table rows in multipletables.andM;All entities, relationships, entity aggregations, and objects are classifiedby &quot;type,&quot; and are known to RM as instances of a specific type.andM;The conceptual view function model.andP;  Function is modeled in the conceptualview as policies on entities and relationships, and as methods for objects.andM;Four types of specifications, called policies, can be specified on constructsin the conceptual view.andP;  Integrity policies, introduced in the previoussubsection, are part of the data model, whereas the other three types ofpolicies are part of the function model.andP;  Security policies are rules forauthorized access to entities, attributes, and relationships.andP;  Triggerpolicies specify execution of processes on the basis of the states of entityattributes and relationships.andP;  derivation policies specify algorithms forcreating entity attribute values.andP;  Policies are written as expressions in theIBM procedures language (REXX).andP;  conceptual view policies are specified forenforcement when data are read from the repository or written to it.andM;In the function model there are object-type dependent operators calledmethods.andP;  The role of the method is to encapsulate the object.andP;  The name,parameters, and description of a method are globally specified.andP;  However, thedetailed semantics of a method are determined by the object type thatincludes it.andM;The storage view data model.andP;  Data are modeled in the storage view asconstructs that are dependent on the underlying system.andP;  For example, theseconstructs differ slightly between DATABASE 2[TM] (DB2[TM]) in the MultipleVirtual Storage (MVS) operating system and Structured Query Language/DataSystem (SQL/DS) in the virtual machine (VM) operating system.andP;  They areconcerned with tables and columns for storing instances of entities,attributes, and relationships.andP;  Performance-oriented constructs are alsomodeled, as for example, indexes on combinations of table columns.andM;The dependencies between the CV constructs and SV constructs are known andmanaged by RM.andP;  an example might be instances of the entity type PROGRAMstored in the DB2 table, Table Y.andM;The storage view function model.andP;  Function also is modeled in the storageview as constructs that are dependent on the underlying system.andP;  For example,transactions making up the implementation of a tool are functions that wouldbe modeled in the storage view.andP;  [11]andM;The logical view RM function.andP;  The logical view should be regarded as adatabase of tool functional specifications, and in the logical view, thebasic construct is the RM function.andP;  The RM function is a package ofspecification, comprising the tool-specific data model and function model.andM;The logical view data model.andP;  The RM function data model is specified as alogical data view with its dependencies on the conceptual view, panels, andprocessing.andP;  The logical data view is composed of logical records, calledtemplates, which are structures of fields.andP;  Template fields are used forparameters, views of entity attributes, views of Dialog Manager panel fields,and tool local storage.andP;  templates are combined in hierarchic structures toview relationships, providing a general and powerful form of name &quot;scoping.&quot;andO;Integrity policies may be specified on a template field.andM;The logical view function model.andP;  Function is modeled in the logical view byRM function policies, which are nonprocedural, and by RM function procedurallogic, which may be coded in a traditional programming language, such as C orCOBOL.andP;  Security policies specify the authority by which a user can call theRM function or use a template field.andP;  Trigger policies specify template-fieldvalue-dependent conditions for automatically calling other RM functions.andO;Derivation policies are algorithms for creating template-field values.andP;  Justas in the conceptual view, policies in the logical view are written asexpressions in REXX.andP;  They are specified for enforcement at RM functioninitiation or termination, reading or writing RM-managed data, or readingfrom or writing to a display panel.andM;The tool group.andP;  The logical view includes the tool group construct.andP;  It is apackaging concept that allows specifications in the conceptual view, storageview, and logical view to be aggregated into a single group.andP;  Therefore, thetool group is the construct representing a complete tool system.andP;  The toolgroup is used to establish the scope of names during specification and tofacilitate export and import of all the specifications for a tool.andP;  Byutilizing the aggregation concept, the RM functions that support tool groupsprovide a methodology for tool installation.andM;The elements making up the data and function models in the specificationdomain are depicted in Figure 2.andM;RM provides program-callable functions and interactive tools to performquery, update, and reporting on all specifications in the conceptual view,logical view, and storage view.andM;Run-time services domain.andP;  Run-time services are invoked by tools for accessto RM-managed data (data services), dialog management (user services), andsystem facilities (system services).andP;  [2,12]  As shown in Figure 1, run-timeservices can be regarded as being vertical slices through specifications.andP;  RMrun-time services executes and enforces the data and function specificationsin the conceptual view, storage view, and logical view.andM;Run-time services can be implemented in a number of ways, ranging from fullyinterpretive to fully compiled.andP;  The current implementation in RM/MVS is asemicompilation approach, where some functions are in executable form andother units require tool procedures to call run-time services.andM;Data services.andP;  Data services supports actions such as the reading andwriting of entities, entity attributes, and relationships through the toollogical data view.andP;  Also provided are built-in functions that support thereading and writing of entities and relationships through template trees orgroups of template trees, with a single call.andP;  Data services supports lockingof entity aggregations on a long-term basis on behalf of a user, where thelock is persistent across system restarts.andP;  Entity aggregations can also beexported and imported between instances of RM.andP;  Commitment and restoration ofRM-managed data are supported by internal use of SQL commit and rollbackmechanisms.andP;  Data services enforces policies specified in the conceptual viewand logical view for reading and writing RM-managed data.andP;  Enforcementincludes checking the authority of users and tools to access RM-managed data,as well as executing derivation, trigger, and integrity policies on the basisof the values of entity attributes and relationships.andM;User services.andP;  User services supports automatic mapping from template fieldsto Dialog Manager panel fields.andP;  Automatic mapping greatly improves theproductivity for development of tools that use the IBM Dialog Manager(Interactive System Productivity Facility, or ISPF, on System/370).andP;  It alsoprovides message management and diagnostic log services, with substitution ofRM variables.andP;  User services enforces security, integrity, derivation, andtrigger policies specified in the logical view for Dialog Manager I/Ooperations.andM;System services.andP;  System services provides such services as the open andclose of RM function, call of integrated RM function, method RM function, andbuilt-in RM function.andP;  It also supports dynamic binding of templates toentity sets and relationship sets, tracing and timing services, query ofsystem-specific information such as the version and release numbers of the RMsystem, and system-specific support for services that may not be available ina particular tool development language.andP;  An example is the service thatallows a REXX program to call a third-generation language program, passingparameters to it.andP;  System services enforces policies specified in the logicalview for the invocation of RM functions of all types.andP;  This includes checkingthe authority of users and tools to execute an RM function, as well asexecuting derivation, trigger, and integrity policies on parameters.andM;Entity-relationship concepts in RMandM;Entities are representations of persons, places, things, events, and conceptsin general.andP;  [4]  Entities are often nouns.andP;  Entity attributes arerepresentations of properties of entities and are often adjectives.andO;Relationships are associations of entities and are often verbs or roledescriptions.andP;  In RM, relationships can also be associations ofrelationships.andP;  Such relationships are often gerunds.andP;  In RM, entities andrelationships may be categorized into higher-level groups, called entityaggregations.andP;  [7,8]  These aggregations often are more abstract nouns orrole descriptions.andP;  Persistent locks can be applied on those entities whichare instances of entity aggregations.andP;  Extended composite object managementis provided by utilizing entity aggregations and is explained in the nextmajor section of this paper.andM;In RM, generalized constraints can be specified for entities, entityattributes, and relationships.andP;  These constraints are the RM policies, whichwere introduced earlier.andM;Entities and their attributes.andP;  Entities are instances of an entity type.andO;The entity type defines characteristics common to all of the instances,including their attributes and policies.andP;  Groups of instances of an entitytype are called an entity set.andP;  The set may be all instances of the type, ormay be ad hoc groupings based on selection clauses or scoping specified intool-specific logical data views.andP;  In the example in Figure 3, the entity setis those PERSONs whose last name is &quot;Doe.&quot;andP;  Logical data views are explainedlater in the section on the RM function.andM;An entity type has a name and a description.andP;  It has a set of attributes,where one attribute, the &quot;entity key,&quot; uniquely identifies the entityinstances.andP;  RM supports &quot;nonkeyed&quot; entities, where data servicesautomatically generates a surrogate key for each entity instance.andP;  It can bespecified that the entity instances must be locked before they can bewritten.andP;  Trigger policies can be specified for the entity type, which causeRM functions to be scheduled for execution.andP;  The triggering conditions arechecked at the time the entity is read or written.andP;  [13]  These RM functionsare executed when the tool issues an RM commit request, and RM restoreprocessing will discard them.andP;  Security policies can be specified for read orwrite authority to the entities and attributes.andM;An entity attribute type has a name and description.andP;  It has defaultcharacteristics, such as data type and maximum length, which are used bygenerators of reports, panels, and tools, but are not necessarily the formatof data stored in the RM-managed data store.andP;  The DBMS data format isspecified in the storage view.andP;  Security, integrity, and derivation policiesmay be specified for entity attributes.andM;Relationships.andP;  In RM, relationships are &quot;binary and directed.&quot;andP;  A binaryrelationship associates exactly two things, which can be entities orrelationships.andP;  These relationships are depicted in Figure 4, where the boxesare entities, and the arrows are relationships.andP;  &quot;Directed&quot; means that eachdirection is given a name.andP;  Queries can be made using just the name in theright direction, and RM determines the characteristics of the relationshipsource and target.andP;  Relationship integrity is dynamically maintained: Theexistence of the source and target instances are automatically verified atrelationship instantiation, and relationship instances are automaticallydeleted when their source or target instances are deleted.andM;A relationship has a description and two type names, one for each direction.andO;One direction is called the primary, the other the inverse.andP;  No preference isgiven to one direction over the other.andP;  These terms are used to provideconcreteness to the specification of the &quot;source&quot; and &quot;target&quot; of the primarydirection (which are respectively the &quot;target&quot; and &quot;source&quot; of the inversedirection).andP;  The source and target may be entities or relationships.andP;  Thereare four kinds of semantic constraints on instances of the relationship type:cardinality, mandatory, controlling, and ordered set.andM;Cardinality--Cardinality semantics specifies that sources and targets can berelated many-to-many, one-to-one, one-to-many, and many-to-one.andP;  For example,one-to-many allows one source instance to be related to multiple targetinstances via the subject relationship type, whereas any one of those targetscan only be related to a single source instance.andP;  Specification ofcardinality for one direction implies that the inverse direction takes on theinverse cardinality.andP;  This means that the inverse of one-to-many ismany-to-one.andM;Mandatory--The mandatory semantic means that when a target instance iscreated, the relationship instance must also be created.andP;  This rule isenforced at RM commit time.andP;  Each direction can independently be mandatoryfor its target.andM;Controlling--The controlling semantic means that when the relationshipinstance is delected, the target instance is also deleted.andP;  These automaticdeletions are performed recursively, when relationship integrity is beingmaintained.andP;  Each direction can independently be controlling for its target.andM;Ordered set--The ordered set semantic means that the tools or users thatinstantiate the relationships can control the order in which instances aredelivered at later read requests.andP;  Either the primary or inverse directioncan be an ordered set, but they cannot both be ordered sets.andP;  The dataservices ER data manipulation language (DML) of RM allows the tool tomanipulate the relationship order through use of the commands ADD BEFORE ANDADD AFTER.andP;  Multiple relationship types may be defined with a common target,where some or all of the relationship types are independently ordered.andM;Security and integrity policies can be defined for instances of therelationship type.andP;  Security policies are enforced at read or write, wherewrite is relationship instantiation or deletion.andP;  Relationships are notupdated.andP;  Integrity policies are enforced at instantiation.andM;In RM, relationships do not have data attributes.andP;  Although there are caseswhere data attributes on relationships are useful--and we are doing work inthis area--our focus has been on semantic control, where this is not vital.andO;The function of relationship data attributes is modeled by dependent entitieswhose owner's source is the subject relationship.andP;  Dependent entities areexplained in the next subsection.andM;The modeling of events or other concepts which require the association ofmore than two entities, commonly called n-ary relationships, is done byrelationships between relationships, or by modeling the association itself byan entity.andP;  The reduction of all interdependencies to binary relationshipsallows specification of semantics at a fine level of granularity.andM;In the example shown in Figure 5, the entity PERSON is related to the entityPERSON by the relationship WORKS__FOR.andP;  The inverse of WORKA__FOR is MANAGES.andO;One PERSON WORKS__FOR, at most, one PERSON, but one PERSON MANAGESpotentially many PERSONs.andP;  The entity PERSON is also related to the entityPROGRAM by the relationship CODES.andP;  The inverse of CODES is CODED__BY.andP;  OnePERSON CODES potentially many PROGRAMs, and one PROGRAM is CODED__BY at mostone PERSON.andM;Dependent entities.andP;  Entities that occur in natural hierarchies can bedesignated as dependent entities.andP;  A dependent entity is similar to a normalentity but with the following differences.andP;  It is specified to be dependenton one, and only one, relationship type, for which it is the target.andP;  Thatrelationship is called the owning relationship.andP;  The relationship source iscalled the owner.andP;  A dependent entity may be part of a chain, where thesource of the owning relationship is itself a dependent entity.andP;  Thedependent entity can occur in the chain only onceandgt; that is, it cannot be itsown owner.andP;  The &quot;backward chain&quot; must eventually terminate in an owner whichis not a dependent entity.andP;  For a dependent entity, instances of its entitykey need only be unique in the context of the owner keys.andP;  Thus, dependententities are a hierarchic form of name scoping.andP;  Access to the dependententity instance can only be done in the context of the owner keys.andP;  Selectionclauses in templates can refer to owner keys, so queries can be composed todiscover the owners of a dependent entity instance.andP;  The owning relationshipautomatically has semantics of mandatory and controlling.andP;  It can havecardinality semantics of either one-to-one or one-tomany but can be neithermany-to-one nor many-to-many.andP;  It can also be an ordered set, but only withordering on the target (the dependent entity).andM;In the example shown in Figure 6, a PROGRAM may CONTAIN internalSUB__PROCEDURESs.andP;  The names of the SUB__PROCEDUREs are only unique in thecontext of the PROGRAMandgt; therefore, they are modeled as dependent oin CONTAIN.andO;The graphic notation &quot;D&quot; at the upper left corner of the box forSUB__PROCEDURE indicates that it is a dependent entity.andM;Entity aggregations.andP;  Entity aggregation is a grouping concept, allowingentities of different types to be dealt with as a unit.andP;  An entityaggregation is hierarchic, with a root entity and a set of relationshipsarranged as branches in a tree structure.andP;  The hierarchy may be of any depthand any width.andM;An entity aggregation type has a name and description.andP;  It has a specifiedroot entity type and optional relationship types with their positions in thehierarchy.andP;  RM functions can be specified to be executed before or after theexport, import, lock, or unlock of entity aggregations.andP;  An example could be:For the TOOL SPECIFICATION aggregation type, after successful import, executethe TOOL INSTALL NOTIFICATION function.andP;  Entity aggregations can overlap, inthat more than one entity aggregation type can contain the same entity orrelationship type.andM;Data services provides a callable RM function to do persistent lockmanagement on entity instances which constitute an entity aggregation.andP;  Locklevels supported are no-update, update, add, and delete.andP;  No-update, alsoknown as stable read, can concurrently be held by multiple users, but theymust all be requesters of the no-update lock level.andP;  This is a nonexclusivelock, but it cannot be shared with holders of the higher-level locks (update,add, delete).andP;  The higher-level locks are exclusiveandgt; there cannot be anyother user holding any lock on the instance.andP;  At lock request, data serviceschecks that the requester has the authority to operate on the underlyingentity instances at the requested level.andP;  These entity aggregation locks areenforced by data services when any user or tool attempts an operation on theunderlying entities.andP;  Data services entity aggregation lock managementcooperates with system services object method routing such that run-timereduction of object method call overhead is possible.andP;  See the next sectionfor an explanation of object control.andM;In the example shown in Figure 7, PROGRAM__CODER is an entity aggregationtype, which is used for showing which person codes a given program.andM;RM object conceptsandM;My experience has been that it is relatively easy to explain RMentity-relationship (ER) concepts and establish some level of understandingwith most audiences.andP;  It is less straightforward with RM object services.andP;  Inthis section, I will attempt to establish the motivation for RM objectservices, and at the same time introduce the concepts and facilities.andM;The object concept in RM provides for a common set of management facilitiesfor RM-managed data that represent real-world items with a complex structurethat often have information stored in nonhomogeneous media.andP;  For example,complex work products that are shared by multiple users are good candidatesfor management as RM objects.andP;  The object can be composite in nature.andP;  Thatis, it can span many database tables and media and can be very large.andP;  Theobject can have its data encapsulated by methods, which are object-typedependent functions.andM;The object can be a subtype or a supertype of other objects, where thesubtype inherits the methods of the supertype.andP;  Object method support is thebasis for providing a single interface to multiple products performing thesame function.andP;  The relationships of an object to entities, otherrelationships, and other objects are managed through use of data servicesrelationship management.andP;  The object is the means by which RM providesconsistent authorization support for composite data of mixed media.andP;  Theobject is the basis for managing versions of composite data.andP;  The objectprovides common attributes that tools can query and update to keep track ofdata movement between the host and the programmer workstations.andM;Composite data.andP;  If the data of an object are totally in entities andrelationships, the object is said to have an &quot;internal body.&quot;andP;  If its dataare totally in some form not in entities and relationships, it is said tohave an &quot;external body.&quot;andP;  An example is a document composed of BookMastersource files, in a partitioned data set library.andP;  A mixture is said to have a&quot;mixed body.&quot;andP;  See Figure 8 for examples of mixed media object data bodies.andM;In all cases, the control information about an object is in entities andrelationships.andP;  The conceptual view for the object control information isshown later in Figure 10.andM;Type-dependent encapsulation.andP;  The definition of an object (the &quot;objecttype&quot;) can include a list of names of &quot;object methods.&quot;andP;  An object method isan RM functionandgt; therefore, it has a globally unique name, description, andinput and output parameters with policies.andP;  Every RM function which is anobject method has at least the object name as an input parameter.andP;  [14] Regardless of which object type includes an object method, that method alwayshas the same set of parameters.andP;  A method can have a different implementationfor each object type where it is used.andP;  The method semantics are dependent onthe method implementations (MIS), but, to be most useful, the MIS for aparticular method should provide similar semantics.andP;  As an (admittedlyextreme) example, it would be confusing for one implementation of the createmethod to do instantiation and another to erase files.andP;  See Figure 9 for anexample of scheduling an MI for a method call.andP;  The object can be a subtypeor a supertype of other objects, where the subtype inherits the methods ofthe supertype.andP;  See relationship SUPERTYPE in Figure 10.andP;  Also see Figure 8for an example of method inheritance.andP;  Object support is the basis forproviding a single interface to multiple products performing the samefunction.andM;Object relationships.andP;  The object instance is represented by the instance ofthe object edition entity type.andP;  The relationships of an object to entities,relationships, and other objects are defined as relationships from the objectedition (Figure 10).andP;  These relationships are instantiated through use of thenormal data services ER DML.andM;Object access authorization.andP;  RM object services provides consistentauthorization support for composite data.andP;  Every object type must have anentity aggregation type defined for it to be used for locking and methodaccess purposes.andP;  Such an entity aggregation always has object edition as theroot entity.andP;  Object lock-level requirements are defined for each objectmethod.andP;  The levels are those lock states supported for entity aggregationlocks.andP;  If the object is locked at the level required for the method (or at ahigher level) for the requesting user, the method may be called.andP;  Otherwisethe object method call is rejected.andM;Version control.andP;  The object provides the base for common version controlservices (Figure 10).andP;  Object instances with the same collection, type, andpart name can have different object editiion key values, thus being different&quot;versions&quot; of the &quot;same thing.&quot;andP;  Object editions, and collections of objecteditions, can be made into different verions relative to each other by use ofthe relationships COLLECTION BASED ON COLLECTION and EDITION BASED ONEDITION.andP;  This is sometimes referred to as &quot;heritage versioning,&quot; since ifthe tools properly maintain instances of the ...andP;  BASED ON ...andO;relationships, it is possible to query where the object &quot;came from.&quot;andM;Object data location.andP;  The object is the basis for data movement between thehost repository and the host-connected workstation.andP;  Method implementationsdo the actual data movement, but the common attributes in the object editioncan be used to hold information such as identifying which workstation andwhich file at that workstation holds a copy of the object data body.andM;The RM functionandM;It is importatnt to understand the RM function construct because it is thebasic unit of tool functional specification.andP;  It is similar to the Ada[R]package specification, in that it is intended to be used as an interfacedescription, which describes the outside of a black box.andP;  [10,15]  RMfunctions are &quot;understood&quot; by the RM system.andP;  Tools are made up of a networkof RM functions.andM;Four types of RM function.andP;  An RM function has a name and description.andP;  It isclassified into one of the following four types.andM;Open/close.andP;  An open/close RM function is just a package of templates.andP;  TheRM function is openedandgt; the templates are used to access RM-managed data andservicesandgt; and then the RM function is closed.andP;  The RM function has noprocedural logic, but it can have any type of logical view policy.andP;  Forexample, security policies prevent unauthorized users and tools from openingan RM function.andM;Integrated.andP;  The integrated RM function, in contrast, does have procedurallogic.andP;  It need not be associated with any object type, and no object-typedependent implementations can be specified.andP;  It can be called by tools (otherRM functions) and policies, with parameters passed through its parametertemplate fields.andP;  It can have any type of logical view policy.andP;  For example,any violation of integrity policies on input parameters will cause the RMfunction call request to be rejected.andP;  Its procedural logic is executed atthe time it is called an can be coded in third-generation language or REXXprograms.andP;  It accesses ER data through its own tailored view, which isspecified by templates.andP;  See the followings subsection on the logical dataview for more detail about templates.andP;  The integrated RM function can haveoptional dialog display panels, with automatic mapping between panel I/Ofields and template fields.andM;Method.andP;  The method RM function can be called, but it has no procedurallogic.andP;  It is the interface from a tool to the MI (method implementation).andO;Its parameter template must have at least the fields for the object name.andP;  Itcan have any type of logical view policy.andP;  This type of RM function can becalled, with object lock control enforcement and with routing to theobject-type dependent implementation (MI).andP;  The example of method-to-MIrouting is shown in Figure 9.andM;Integrated and method RM functions can be called by conceptual view policies,logical view policies, procedural logic, and end-user command.andM;Method implementation.andP;  The MI RM function has procedural logic, but itcannot be called directly by tools.andP;  It can only be invoked via method-MIrouting.andP;  It can have any type of logical view policy.andP;  For example, an inputparameter could be synthesized by a derivation policy which includes thecalling of an integrated RM function that solicits additional input from theend user.andP;  In most respects, the MI RM function is the same as an integratedRM function, except that its parameter template must have fields for theobject name.andM;RM function logical data view.andP;  The logical data view in an RM function iscomprised of templates.andP;  The template is a group of fieldsandgt; it is a logicalrecord.andP;  A template field is a view of one or more of the following: entityattribute, paramter, interactive panel field, and local storage.andP;  The fieldsin a template may view a subset of the attributes of an entity.andP;  Thetemplate-field data type, precision, and length can differ from the ER datastored in the DBMS.andP;  If they differ, the field value is converted at runtime.andM;Templates can be arranged in trees, where a template tree is a hierarchicview of the entity-relationship network of the conceptual view.andP;  A branch ofthe template tree maps to a relationship in the conceptual view.andP;  A templatemapping to a dependent entity has a field for each owner's key attribute.andM;Retrieval selection clauses can be specified on a template.andP;  For the examplein Figure 3, a template for reading PERSONs based on last name would have aselection clause similar to PERSON.LASTNAM = LLST, where LLAST is assignedthe value of the last name, &quot;Doe.&quot;andM;A template can be arrayed so that a large set of entity and relationshipinstances can be read or written in a single operation.andP;  A template array isa table in main storageandgt; it can have any number of rows, and retrievals canbe under the control of a selection clause.andM;A field in a template can be synthesized by derivation policies, so thefields in a template can be a superset of the attributes of an entity.andM;Logical view policies are subordinate to conceptual view policies, in thatconceptual view policies are always enforced before ER data are changed.andM;ER data reads and writes can be issued on a template, or the data ccess canbe done in fewer calls by using RM built-in functions.andP;  Built-in functionsoperate on template trees or groups of trees in a single operation.andP;  The RMlogical data view provides a simple but powerful form of data access.andP;  Therun-time syntax is very simple, but the semantics in the specification arecomprehensive.andP;  It provides a form of hierarchic name scoping on data whichcan be overlapping sets.andP;  It supports a means of nonprocedural processingthat is driven by the occurrence of events and changes in the data state.andO;Defined events are ER read, ER write, RM function initiation, RM functiontermination, display read, and display write.andM;Display specification.andP;  Interactive display panel specifications are held inRM as part of the RM function specification.andP;  For example, included arelogical field display coordinates and default highlight control.andP;  The displayand the logical data view are related, but are separate components of the RMfunction specification.andP;  [16]andM;RM tool development and execution methodandM;The intent of this section is to give an intuitive understanding of what isinvolved in designing and implementing a tool, and to provide an integratedview of the concepts and facilities described so far.andM;A tool designer will usually perform the following steps (illustrated inFigure 11):andM;1.andP;  Define a conceptual view--This step is optional, in that the existingconceptual view may be complete enough for the purposes of the new tool.andO;This step is &quot;data modeling,&quot; that is, design of the ER model.andP;  Usually,design consists of extensions to the IBM-supplied ER model.andP;  New object typesand their object methods can be defined.andM;2.andP;  Define tailored storage view for the conceptual view--This step isoptional, since it obviously is only necessary if the conceptual view waschanged.andP;  Also, a default storage view will be provided by RM.andP;  This defaultis suitable for prototyping the tool, and the conceptual view changes.andM;3.andP;  Define one or more RM functions in the logical view--A mapping of thelogical view to the storage view may be done, depending on the RMimplementation and the user's needs.andP;  The RM function can be a simple dataview (open/close), an integrated RM function, a method, or a methodimplementation.andM;4.andP;  For each RM function, write one or more programs--RM providesproductivity facilities for the PL/AS, PL/X-86, PL/I, COBOL, C, and REXXprogramming languages, [17] including generation of source code, such as theprocedure parameter list, declaration structures, return code constants, andinvocation macros.andM;5.andP;  Execute the tool RM function--The third-generation language logicaccesses RM-managed data and services via the logical data view in its RMfunction.andP;  These accesses are under the control of the logical view policiesin the RM function and the global conceptual view policies.andP;  The policies anddata semantics are enforced by RM run-time services.andM;Repository Manager in relational DBMSandM;RM uses the services of the IBM SAA DMBS, through its implementations in DB2and SQL/DS.andP;  Interactive dialogs are provided for database specification andfor mapping the conceptual view to the storage view.andP;  SQL DDL (datadescription language) is generated from the RM-managed data, includingautomatic generation of useful idexes.andP;  Static SQL application source code isgenerated to improve performance of common execution paths.andP;  Dynamic SQL isused where appropriate.andP;  RM provides extensive instrumentation for system andtool diagnostics and tuning.andM;A simplified example illustrating the roles of the three parts of thespecification domain is shown in Figure 12, with a DB2 storage view.andM;Repository Manager within SAAandM;The main concepts and facilities in the Repository Manager/MVS Version 1Release 1 product are depicted in Figure 13.andP;  This is a superset of the SAArepository CPI, which is shown in Figure 14.andP;  Some specific non-CPIfacilities available are reliability, availability, and serviceability (RAS)services for tracing and logging, interactive dialogs for specificationmaintenance and prototyping, and utility tools for product installation andcustomization.andM;SAA repository CPI.andP;  The functions that ultimately will be supported by theRepository manager portion of the SAA CPI (repository CPI) are shown inFigure 14.andP;  The first level of the CPI only supports the syntax of ER datamanipulation language (DML).andP;  The specification domain is an extendedtwo-schema architecture, which includes the conceptual view and logical view,but not the storage view, which is specific to System/370.andM;The CPI conceptual view includes entity and relationship with integrity,derivation, and trigger policy types.andP;  Security policy capability is notincluded, pending definition of SAA security.andP;  The CPI includes aggregation,object with method, and supertype for method inheritance.andM;The CPI logical view includes RM function, with logical data view andintegrity, derivation, and trigger policies.andP;  The RM function types ofopen/close, integrated, method, and method implementation are supported.andO;Logical view security policies have been excluded.andP;  Tool group (to groupdefinitions of objects, entities, relationship, aggregations, and RMfunctions) is included.andM;Run-time services in the repository CPI are data services and a subset ofsystem services but not user services.andP;  Data services includes ER logicaldata view management and data access (DML), including built-in functions, ERand object specification (DDL), and object instance access (DML).andP;  systemservices included arethe open/close RM function, call RM function with methodcall routing to object-type dependent implementations, and DDL verbs for allRM function types.andP;  Also included ar bind, unbind, and system informationquery.andP;  Not included in the CPI are system services for timing and diagnostictracing.andM;RM implementationandM;RM is implemented in RM means that important elements of RM/MVS are specifiedin RM-managed data via a conceptual view of RM itself.andP;  Examples of systemelements modeled in RM-managed data are tool groups, entities, [18]relationships, entity aggregations, objects, RM functions, system controlblocks, buffers and data areas, system commands, system return codes, andsystem messages.andP;  Some benefits observed for this approach have been:Interactive maintenance tools are quickly implemented and easily maintainedandgt;documentation is to a large extent automatically generatedandgt; and source codefor constant and data structure declarations are automatically generated.andM;Since RM function specifications are held in RM-managed data, it isstraightforward to generate source code fragments in the language the tooldeveloper chooses.andP;  Such support has been implemented for PL/AS, PL/X, PL/I,COBOL, and C.andM;A Repository Manager data load facility (RM loader) is part of the RMproduct.andP;  It populates the RM-managed data stores from files created byprograms or users outside RM.andP;  An example of this is the Dictionary ModelTransformer (DMT) product offering.andP;  DMT reads data from the IBM DB/DC DataDictionary and writes it to a file, which can be read by the RM loader.andM;RM provides integrated support for the Query Management Facility (QMF[TM])for reports and queries on ER data.andM;Future directionsandM;The repository CPI will be extended in functional scope as well as in supportof other host and cooperative environments.andP;  We continue to work on extendingthe conceptual view data modeling constructs to be semantically richer, whilenot neglecting opportunities for fully utilizing the underlying operatingsystems and DBMS by extending the storage view architecture.andP;  The concepts ofentity, entity aggregation, and object will continue to converge, witheventual integration with the general concepts of entity generalization.andP;  [7]andM;Further research needs to be done on structural aspects of the RMarchitecture, such as peer-connected Repository Managers and hierarchicallyconnected Repository Managers, which are aware of each other and cooperate insolving the problems of distributed semantic management, with acceptableperformance.andM;SummaryandM;Repository Manager is a system for managing specifications.andP;  In the IBM SAAstrategy, it is also a system to support the development and execution ofsoftware engineering tools for application development and other strategicrequirements.andP;  It enables tools to be specified through an extendedthree-schema architecture which models data and function.andP;  It transformsthese specifications into systems of tools and executes the tools whileenforcing corporate standards.andP;  Repository CPI is an additional component inthe IBM Systems Application Architecture Common Programming Interface.andO;Repository Manager /MVS is implemented using its own technology.andM;AcknowledgmentsandM;Significant and fundamental early contributions were made to the architectureby Claude Miller, Christoper Wood, Vern Watts, Carlos Goti, and Jerome Fox.andO;In the application of Repository Manager technology to the IBM internalsoftware engineering strategy, William Beregi and Gene Hoffnagle were keycontributors.andP;  Peter Hein shared a vision of what is possible and provided anearly demonstration of the value of RM with the MIRAGE system.andP;  [19]  Veryearly on, Raymond Berman implemented the first production of RM tool(OCTOPUS), and it is still in daily use.andP;  [20]  The product and technologyefforts may not have survived without the vision and unflagging support ofIBM management, especially Donald Hyde, who started the research effort,Robert Tabory, who was instrumental in obtaining funding at critical times,and Norman Pass, who kept the effort alive and took it into the productdevelopment organization.andP;  William Hallahan and Claudia Gardner-Treiber werethe key people with the experience and perspective on how to apply theadvanced technology prototypes to the application development problems of IBMcustomers.andP;  Many more people have been collaborators and supporters over theyears.andP;  My thanks to all these people.andM;Many suggestions by Fran Beason, Karen Roberts, and the patiently anonymousreferees were crucial in making this paper as readable as it is.andP;  Any errorsin fact or style are solely mine.andM;Repository Manager, Repository Manager/MVS, Systems Application Architecture,SAA, DATABASE 2, DB2, and QMF are trademarks of International BusinessMachines Corporation.andM;Ada is a registered trademark of U.S.andP;  Department of Defense.andM;Cited references and notesandM;[1.] Systems Application Architecture: AD/Cycle Concepts, GC26-4531-0, IBMCorporation (1989)andgt; available through IBM branch offices.andM;[2.] Repository Manager/MVS: General Information, GC26-4608-0, IBMCorporation (1989)andgt; available through IBM branch offices.andM;[3.] The Term view is somewhat limiting, in that some people might interpretit as meaning only data as opposed to both data and function, but it is usedfor primarily historical reasons.andM;[4.] P. P. S. Chen, &quot;the Entity-Relationship Model--Toward a Unified View ofData,&quot; ACM Transactions on Database Systems 1, No.andP;  1, 9-36 (March 1976).andM;[5.] E. F. Codd, &quot;Extending the Database Relational Model to Capture MoreMeaning,&quot; ACM Transactions on Database Systems 4, No.andP;  4, 397-434 (December1979).andM;[6.] OS/VS DB/DC Data Dictionary Administration and Customization Guide,SH20-9174, IBM Corporation (1979, 1984, 1986)andgt; available through IBM branchoffices.andM;[7.] J. M. SMith and D. C. Smith, &quot;Database Abstractions: Aggregation andGeneralization,&quot; ACM Transactions on Database Systems 2, No.andP;  2, 105-133(June 1977).andM;[8.] D. Mcleod, &quot;A Semantic Data Base Model and its Associated StructuredUser Interface,&quot; MIT/LCS/TR-214, Massachusetts Institute of Technology,Cambridge, MA (August 1978).andM;[9.] M. Hammer and D. McLeod, SDM: A Semantic Data Model, USC TR 80-3,University of Southern California, Los Angeles (February 1980).andM;[10.] G. Booch, Software Engineering with Ada, The Benjamin/CummingsPublishing Co., Menlo Park, CA (1983).andM;[11.] This is not done in the RM Release 1 product, but the architectureenables it to be done in the future, for example, for performance or controlreasons.andM;[12.] G. F. Hoffnagle and W. E. Beregi, &quot;Automating the Software DevelopmentProcess,&quot; IBM Systems Journal 24, No.andP;  2, 102-120 (1985).andP;  RM is described inthis paper as &quot;common tool services.&quot;andM;[13.] Policies for read are separately specified and enforced from policiesfor write.andM;[14.] Actually, it is four parameters for the four parts of the object name:collection, object type, part, and object edition.andM;[15.] Common APSE Interface Set (CAIS), Proposed Military Standard, Version1.3, Report AD-A134825/9, Office of the Secretary of Defense, Ada JointProgram Office, Washington, DC (August 1984).andM;[16.] The display specification acts as a storage view for the interactive RMfunction.andP;  Perhaps we should recast the architecture to make that explicit.andM;[17.] PL/AS and PL/X-86 are IBM product development languages for theSystem/370 and the Personal System/2[R].andM;[18.] J. M. Fox, J. C. Goti, C. R. Miller, and J. M. Sagawa, &quot;Implementing aSelf-Defining Entity/Relationship Model to Hold Conceptual view Information,&quot;Proceedings of the Second International Conference on Entity-RelationshipApproach to Information Modeling and Analysis, ER Institute (October 1981),pp.andP;  569-581.andM;[19.] MIRAGE (MInispec and Repository based Application GEnerator) was theadvanced technology prototype for DevelopMate[TM].andP;  It was a fully functionaltool for Yourdon-DeMarco-based requirements and application analysis andprototype generation.andM;[20.] OCTOPUS (Old Code TO Properly Understood Software) is an interactivetool to allow queries on the component structure of products with multipleversions under concurrent development.andP;  It allows unlimited bidirectional andrecursive queries of a &quot;bill of material,&quot; including macros, modules, andprogram symbol usage.andM;James M. Sagawa  IBM Programming Systems, santa Teresa Laboratory, P.O. Box49023, San jose, California 95161-9023.andP;  Mr. Sagawa received a B.S.andP;  inelectrical engineering from the California Institute of Technology in 1963.andO;He joined IBM at the Burbank branch office where from 1963 to 1969 he was asystems engineer specializing in engineering and scientific applications,operating systems, time sharing, and graphics.andP;  As a member of the CADAM[R]implementation team at the Lockheed California Company, he wrote the graphicattention handler and various performance prediction tools.andP;  From 1969 to1971 he was on assignment as a consultant to IBM United Kingdom for marketingand implementing engineering graphics, scientific applications, and operatingsystems.andP;  In 1971 and 1972 he was on assignment at the IBM World TradeManufacturing Industry Marketing Center in Munich, Germany, where he providedguidance to European country-level marketing for engineering and scientificapplications.andP;  From 1972 to 1977 he was a member of the InformationManagement System development team in Palo Alto, California, and served aschief programmer for IMS/VS 1.0.1.andP;  In 1977 he helped start the Sundanceadvanced technology project, which evolved into the Repository Manager (RM).andO;As architect and chief designer, he led the effort to apply RM (in itsimplementation as Common Tool Services) to the development and execution ofIBM internal system development tools as the base for the SoftwareEngineering Support Facility (SESF) architecture.andP;  Later, he led the effortto apply it to the development and execution of application development toolsas the base for AD/Cycle[TM].andP;  Mr. Sagawa is a past member of the SESFArchitecture Review Board and ADE System Design Council.andP;  He currently is amember of the Santa Teresa Laboratory Technical Review Council and theAD/Cycle System Architecture Board.andO;</TEXT></DOC>