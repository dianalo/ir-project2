<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-169-162  </DOCNO><DOCID>07 169 162.andM;</DOCID><JOURNAL>Computer Language  April 1989 v6 n4 p17(6)* Full Text COPYRIGHT Miller-Freeman 1989.andM;</JOURNAL><TITLE>The (almost) right stuff. (Programming on Purpose) (column)</TITLE><AUTHOR>Plauger, P.J.andM;</AUTHOR><SUMMARY>The International System of Units prefixes commonly used indescribing computer memory, such as K for kilo- and M for mega-,have percentage errors ranging fr 2.4 percent with K, which isactually 1,024 bytes, to 15.3 percent with E for exa-.andP;  Othernumbers which are slightly in error are also discussed.andO;Standards-setting bodies should take responsibility for settingfinite limits on a language's identifier or name length.andO;Block-structured languages which use hierarchical constructionhave shortcomings but provide a fundamentally sound way oforganizing and constructing programs.andP;  The same is true ofobject-oriented languages.andM;</SUMMARY><DESCRIPT>Topic:     CritiqueObject-Oriented LanguagesProgramming LanguagesErrorsStandardsProgram Development Techniques.andO;Feature:   illustrationtable.andO;Caption:   Table of SI prefixes and their percentage of error. (table)andM;</DESCRIPT><TEXT>The (almost) right stuff We all strive for perfection.andP;  It's the elegantalgorithm that wins our hearts, the super performer who wins our admiration.andO;In our culture, it sometimes seems like no credit can be earned for nearperfection, no glory for being second best.andM;Yet much of the world must be less than perfect, almost by definition.andP;  Wemuddle through with approximate theories.andP;  We win many a ball game with thesecond string.andP;  It's nice to have the right stuff, like Tom Wolfe'scharacterization of the original seven Mercury astronauts.andP;  But most of thetime we get the job done with almost the right stuff.andM;By long-standing tradition (this is the third year in a row), I havecelebrated the month of April by criticizing the shortcomings of otherpeople's designs.andP;  What better way to honor April Fool's Day, said I, than toshine a harsh light on the follies that haunt the most successful designersof computer software and hardware?andM;In the process of gathering also-rans for this year's column, however, Ifound myself drawn to more abstract themes; I will name no names this time.andO;I also found myself being more tolerant of ideas that have proved to be lessthan perfect.andP;  Perhaps I am mellowing in my old age.andM;For whatever reason, I'd like to share with you several approximations toperfection that have demonstrated redeeming social value over the years.andP;  Youcan look on it as my contribution to a kinder and gentler April Fool's Day.andM;Let's start with a few numbers that are almost right.andP;  The one you'redoubtless the most familiar with is the number hiding behind that uppercase Kyou see in all those ads for computer memory.andP;  When computer types talk about640K of memory, you and I know that they really mean 640 X 1,024 bytes or655,360 bytes of memory.andM;The &quot;K&quot; is cribbed from the table of standard prefixes of the InternationalSystem of Units (SI).andP;  It indicates a multiplier of 10.sup.3 or 1,000.andO;That's not exactly 1,024, but it seems to be close enough to satisfy most ofus.andP;  We must consider it an amusing accident of nature that 2.sup.10 is soclose to 10.sup.3..andM;It doesn't hurt that you get an extra 24 bytes with every K you buy.andP;  I'llbet if the actual number were less than 1,000, all those ads would have tocarry tiny footnotes warning unsuspecting consumers of the shortfall.andP;  (Howabout something like, &quot;Memory is sold by weight; contents may settle afterpacking&quot;?)andP;  I have no idea who first commandeered the K.andP;  As far back as Ican remember, it has been in common usage among computer types.andM;What I find interesting is that the error builds as you piggyback onever-higher SI prefixes.andP;  A 2.4% error around a thousand grows to 4.8% arounda million.andP;  Yes, we cribbed the &quot;M&quot; for &quot;mega&quot; from the same source as &quot;K&quot;for &quot;kilo.&quot;andP;  We are all happy to get a 5% bonus in disk space or even memoryspace with today's megabyte desktops.andP;  We are even happier to get a 7.4%bonus on a gigabyte of storage, cribbing the &quot;G&quot; for &quot;giga&quot; to represent10.sup.30 as almost the same value as 10.sup.9..andM;I wonder at what level the purveyors of huge storage devices will feelcompelled to emphasize the bonus.andP;  Here is the current table of SI prefixesand the associated errors in approximating powers of two:andM;Perhaps it will not be a problem.andP;  By the time you see exabyte add-on drivesadvertised in the back pages of COMPUTER LANGUAGE for a mere $5,000, none ofus will be in a mood to sweat an extra sixth of a billion billion bytes.andO;It's close enough.andM;I can't help but drift away from computers a bit while on the subject ofalmost-right numbers.andP;  One of my favorites is the remarkable coincidence that2.sup.7/12 is very close to 3/2.andP;  That coincidence is why every octave on apiano keyboard has 12 different notes.andM;Here's why.andP;  The simplest harmony you can make with a musical note is todouble it.andP;  That harmony is so basic that we assign the same letter name toall notes obtained by doubling a given frequency.andP;  Middle C is 256Hz, thenext C up is 512Hz, and so on.andP;  The next simplest harmony is the frequencythat is 3/2 that of your starting note.andP;  In the scale starting at C, G meetsthis requirement.andP;  You will find that many of the simple, happy melodies ofWestern music are rooted deeply in C/G-type harmonies.andM;But what if you want to start with G and make a simple harmony? Then you needa note at 3/2 the frequency of G, which happens to be D.andP;  Start at D and youneed to add an A.andP;  In principle, you would need an infinite number of notesto complete this sequence.andP;  In practice, however, you can do an adequate jobwith a very finite set.andM;If, instead of making G 1.5 times the frequency of C, you set it at2.sup.7/12 and introduce just a tiny error, the error is about one part in athousand, which is hard for even a trained ear to detect.andP;  It certainly doesnot jar.andP;  Continue adding notes at this ratio (halving frequencies from timeto time to stay in the same octave) and the series closes on itself.andP;  Sinceseven and 12 are relatively prime, the series closes after you have produced12 distinct notes.andM;Each of the notes lies at a frequency 2.sup.1/12 above its lower neighbor,about 5.95% higher.andP;  Among the 12 notes you will find reasonableapproximations to the seven notes of the traditional Western harmonic scale(CDEFGAB).andP;  None are perfect, but all are close enough not to jar the ear.andM;This scheme of tuning an instrument is known as &quot;well tempering.&quot; It lets youplay music written in any key without having to retune the instrument whenyou shift keys.andP;  It has been known since the time of Bach, who wrote The WellTempered Klavier as a sort of promotion for the scheme with 12 preludes andfugues, each pair written in a different key.andP;  Perhaps this explanation ofwell tempering will help you see why music has such an appeal to themathematically inclined, including many good computer types I know.andM;Still one more diversion, this time from the world of astronomy: it is wellknown that the sky contains a North Star, a.k.a.andP;  Polaris, but no South Star.andO;It is less well known that Polaris is not exactly due north.andP;  My copy ofNorton's Star Atlas puts it at declination 89 degrees, two minutes, almost afull degree off due north.andP;  Nevertheless, it is close enough to true norththat we are happy to call it the North Star, even though it moves in a circleabout the pole whose diameter is about four times the width of the full moon.andM;The interesting exercise is to use this data to estimate the number ofvisible stars in the sky.andP;  We have as samples two circles, each about onedegree in radius.andP;  Each circle covers about 1/10,000 of the sky's area.andO;Within these two circles lies a grand total of one star.andP;  Ergo, we wouldexpect to see about 5,000 visible stars spread over the entire sky.andP;  Andindeed, that is approximately the generally stated figure.andP;  (It's not easy tobe exact, what with the tremendous variation in viewing conditions.)andM;So once again we have a number (the number of pole stars) that tells us asmuch about the people who use it as it does about the universe beingobserved.andP;  Humans can't feel a 2.4% counting error well enough to sweat thedifference.andP;  They can't hear frequency errors well enough to complain aboutthe compromises made by piano tuners.andP;  And they can't see a one-degree errorwell enough to dethrone Polaris.andP;  All three numbers are arguably closeenough.andM;Now let's get closer to home.andP;  A pet peeve of mine in language design is thelength of identifiers (names) that a language should support.andP;  Implementorshave been known to pick rather small upper bounds, ranging from an obscenelow of one character (BASIC) to a miserly sixish (FORTRAN, early C) to afairly generous 30-ish (COBOL, PL/I).andP;  Purists repeatedly insist that thereshould be no limit whatsoever on the length of identifiers.andP;  The question is,how do you pick a reasonable number as a compromise when one of the valuesyou must weigh is infinite?andM;When X3J11 was standardizing C, I argued repeatedly (and successfully) forpicking a finite limit for name length.andP;  Implementors are, of course, free tosupport names longer than the limit, but users are cautioned that someimplementations may support names no longer than the limit.andP;  (This is anotherone of those treaty points that make up much of a language standard.andP;  It isthe meeting place between producers and consumers.)andM;The limit X3J11 agreed upon was 31 characters for internal names.andP;  (Wereluctantly retained the long-standing caveat that existing assemblers andlinkers may impose a six-character, one-case limit on external identifiers,but that's another story.)andP;  We felt that 31 characters was long enough toencompass nearly all sensible names created by human beings in the course ofwriting computer programs.andP;  The idea was to pick a limit that was essentiallyinfinite yet still finite enough to protect implementors from thetroublemakers.andM;Troublemakers come in two guises--in the world of programming languages, atleast.andP;  Amateurs literally stay up nights looking for gotchas so they canwrite arrogant letters to standards committees.andP;  This tribe delights inkeeping responsible adults busy sifting through trivia.andP;  (They also keep ushonest and make sure we dot the i's and cross the t's.)andM;Professional troublemakers write verification and validation suites forlanguages.andP;  Serious customers buy these suites and insist that vendors passall their tests before they shell out good money for the languageimplementations.andP;  It doesn't matter how beautiful a job you do asimplementor: if you happen to fail three esoteric tests in a validationsuite, you will be stigmatized for those three failures, your successesforgotten.andP;  Professional implementors quickly learn to tune their productsfor the extant validation suites at whatever cost, just to stay in the ballgame.andM;So what happens when a language imposes no limit on the length ofidentifiers?andP;  The answer is simple.andP;  The author of the validation suite picksa comfortably large length (or uncomfortably large length, from theimplementor's viewpoint) and writes a test to see if identifiers of thatlength are accepted.andP;  Where the standard is silent, the only voice heard isthat of the validator.andP;  The net effect is that the most popular validationsuite becomes the de facto standard in this area.andP;  All custmers look for thetested name lenght and all smart vendors work to that specification.andM;The Pascal and Ada standards took the route of requiring arbitrary lengthnames.andP;  Their respective validation suites defined the finite enforced limit.andO;I have seen repeated references in the literature to those finite limits asbeing the defined limits for identifiers in these languages.andP;  Nobody bothersto point out that either of these limits is literally one person's opinion asto how long is long enough.andM;So while it seems like the right idea to insist on arbitrary-lengthidentifiers in designing a language, in practice the ideal doesn't hold up.andO;The standards-forming body may as well take responsibility for determining afinite limit.andP;  If they don't, someone will finish the job for them.andO;Arbitrary-length identifiers are almost a good idea.andM;Another one of those almost-good ideas is block-structured languages.andP;  I haveread numerous paeans, particularly in introductory computer texts, to thevirtues of using block structure to control access to identifiers on anas-needed basis.andP;  If you write your programs top-down (as all right-thinkingprogrammers are supposed to do), you will naturally form a hierarchy offunctions and working data.andP;  Block structure gives you just the scope andvisibility you need for functions and data shared in a hierarchy.andM;The ointment contains one or two flies, however.andP;  The first is that a purehierarchy almost never proves adequate for nontrivial programs.andP;  You willprobably use a function library.andP;  The same work-horse function will likely becalled from several places in the hierarchy.andP;  You are faced with anuncomfortable choice: either you replicate the function at each point in thehierarchy that you use it or you push the function up the hierarchy until itis high enough to be visible from all points that need it.andP;  The firstsolution forces you to replicate the code in the interest of doctrinalpurity; the second weakens the information-hiding properties of yourhierarchy.andM;Even if you don't make use of an existing library (a rare and dubious featamong large programs), you will probably end up inventing your own.andP;  Theprocess of abstraction and information-hiding pushes you inexorably in thedirection of making common access functions that are callable from manyplaces within a hierarchy.andP;  And if you have to share static data amongfunctions, the problem is even worse.andP;  I have seen many a Pascal program withpages of data declarations at the outermost block, yielding all themaintenance problems of a 1960s COBOL program.andP;  All that beautifulhierarchical scoping goes out the window when performance is on the line.andM;Even if you stubbornly hold onto a pure hierarchy, you can't avoid theforward-referencing problem.andP;  Sooner or later, you will want to declare twofunctions that call each other.andP;  Worse, you are going to want to declare twodata objects that refer to each other.andM;Every block-structured language I know must face the forward-referencingproblem in at least one guise.andP;  And every block-structured language I knowindulges in its worst design kludges in this area.andP;  The Pascal rules fordeclaring pointers to other types, for instance, contain some realeyebrow-raisers.andP;  They impose scoping limitations on the type names designedto give you a fighting chance at writing mutually referencing data types.andO;But the cost is considerable head-scratching in situations where mutualreferencing is far from your central focus.andM;The X3J11 committee indulged in one lulu of a kludge in this area.andP;  Theychose to address the problem of two structures that refer to each other, asin: struct x [ struct y *py; .....andP;  ]; struct y [ struct x *px; .....andP;  ];andM;This is mostly straightforward stuff, except when you wish to drop such apair of declarations blindly into the middle of a nested block of code.andP;  (Thedeclarations may be part of a generic macro that is expanded, for instance.)andO;Now you have a potential problem.andM;Should the containing environment happen to have a declaration for struct y,the first structure will point to an instance of the existing structuredefinition, not forward to the (as yet undefined) following declaration.andP;  Ifyou knew that was a possibility, you could reverse the declarations.andP;  Butwhat if the containing environment happens to have a declaration for structx?andP;  You're in trouble again.andP;  And if both structures might be defined at thestart of the block, you have no way to write the mutual reference safely.andM;So X3J11 introduced an artifice.andP;  When you write the declarations: struct y;struct x [ struct y *py; .....andP;  ]; -struct y [ struc x *px; .....andP;  ]; you areguaranteed the behavior you want, because the first declarationunconditionally introduces a new instance of struct y within the currentblock.andP;  It cauterizes any references to the containing environment.andP;  It's akludge, pure and simple, but it does rescue an almost-right ideas from anasty little black hole.andM;The fact remains that hierarchical decomposition is a good way to constructmany programs.andP;  And block structuring is a good way to control most of thename scoping in those and other programs.andP;  Because block structuring isalmost the right stuff, we should not be quick to ignore it just because ithas a few annoying shortcomings.andM;I can make a similar harangue about object-oriented programming.andP;  It lookslike a great organizing principle to first identify all the data types you'regoing to need and define all the operations you're going to perform on them.andO;You end up with a program at least as tightly structured as one built by purehierarchical decomposition.andP;  And you avoid a number of the design andmaintenance issues I have touched on briefly.andM;You also acquire a fresh set of headaches.andP;  I have been reading withamusement the new breed of publications that have picked up the torch ofBetter Program Design.andP;  There's the Journal of Object-Oriented Programming;Journal of C, Ada, and Modula-2; and the newly arrived C+ + Report.andP;  All weworth reading, but all indulge in the same excuses that every otherrevolutionary design method tried on for size:andM;* You don't really want to do that anyway.andP;  That's the old-fashionedapproach.andM;* Existing programmers have trouble understanding this stuff, but newcomerstake to it naturally.andM;* The first few projects have a high learning cost, but then yourproductivity goes up fivefold.andM;The simple fact is that object-oriented programming has something to offer,but is also gets in the way sometimes, just like every other method fororganizing programs.andP;  Since I'm one of those unreconstructed oldsters (and aC expert at that), I'll sidestep any detailed criticism of object-orientedprogramming.andP;  When I get a little more experience under my belt, and when thereligious fervoer dies down a bit, I'll be back.andO;</TEXT></DOC>