<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-753-194  </DOCNO><DOCID>08 753 194.andM;</DOCID><JOURNAL>Communications of the ACM  August 1990 v33 n8 p120(12)* Full Text COPYRIGHT Association for Computing Machinery 1990.andM;</JOURNAL><TITLE>Physical design equivalencies in database conversion. (convertingfrom navigational to relational databases) (technical)</TITLE><AUTHOR>Gillenson, Mark L.andM;</AUTHOR><SUMMARY>More and more data processing organizations are converting largenavigational databases to relational databases.andP;  Issues involvedin recognizing and converting modifications in the navigationaldatabases into equivalent relational terms are discussed.andP;  Logicaldatabase design involves taking a group of fields and designing adatabase that conforms to structural rules based on theassociations among the fields.andP;  This process disregardsperformance considerations and converts hierarchical DBMS segmentsinto tables, each of which has fields added to establishone-to-many relationships.andP;  Physical database design modifies andenhances the results of logical database design to improveperformance.andP;  A five-step process for physical conversion ofnavigational databases to relational databases is proposed.andO;Hashing is a powerful DBMS conversion technique, but designersmust also cope with long twin chains and many to manyrelationships.andM;</SUMMARY><DESCRIPT>Topic:     Data base management systemsSystem ConversionRelational DBMSData Base DesignManagement of EDPTechnology.andO;Feature:   illustrationchart.andO;Caption:   Miami Beach Convention Bureau IMS Database. (chart)Miami Beach Convention Bureau relational database. (chart)An occurrence (database record) of the organization hierarchy.andO;(chart)andM;</DESCRIPT><NOTE>Only Text is presented here; see printed issues for graphics.andO;</NOTE><TEXT>PHYSICAL DESIGN EQUIVALENCIES IN DATABASE CONVERSIONandM;The field of database management began in the late 1960s as response to theneed for a practical way of controlling the increasingly voluminous amount ofdata that organizations were generating.andP;  The early database managementsystems (DBMSs) were based on the graphically oriented hierarchical andnetwork models of data storage.andP;  These, as a class, came to be known asnavigational systems because of the way programmers would move through thedata structures in search of their target data.andP;  The relational databaseconcept, with its tabular orientation, was introduced in the early 1970s, butcommercially viable relational DBMSs were not available until the early1980s.andM;Among the reasons for the delayed viability of the relational systems wasperformance.andP;  Indeed, performance has always been a serious consideration inapplication development involving navigational DBMSs.andP;  While navigationalDBMSs offer tremendous benefits of data integration, reduction of dataredundancy, and improved data integrity, they tent to introduce a largeamount of overhead, which tends to slow response time.andP;  In fact, over thelast 20 years, a geat deal of tme and effort has been invested in the designof navigational databases that maximize the performance of the applicationsthat use them.andM;In spite of the wide interest shown in relational databases during the decadeof the 1980s, the vast majority of today's mainframe database applicationsstill run on navigational DBMSs.andP;  There has been some effort toward designingrelational language interfaces that can use the data in existing navigationaldatabases.andP;  But it stands to reason that, over time, an important task formany organizations will be to convert their navigational database structuresto relational structres.andP;  The logical database design aspects of theconversion are straightforward.andP;  But what about the physical design orperformance aspects of the converion?andM;We will first review the steps needed for database conversion irrespective ofperformance implications.andP;  Then we shall discus the equivalencies between thephysical design options for modifications or enhancements in the naviationaldatabases and in the relational databases.andP;  Rather than attempt to treat thissubject in a theoretical way or consider a large number of different DBMSs,which would be impractical for navigational databases, we will concentrate onthe very widely used IBM hierarchical DBMS, Information Management System(IMS) [6, 12, 16, 19, 28].andP;  We will supplement our discussion with commentsabout the CODASYL network model [13, 22].andP;  For relational databases we willdiscuss the relational model in general, with specific comments for emphasisat appropriate points about Relational Technology's INGRES [1, 25] and IBM'sData Base 2 (DB2) [3 11, 14, 15, 17, 29].andP;  The overall result will be ablueprint for performing the conversion and a better understanding of some ofthe performance issues in the field of database management.andP;  For a review ofdatabase models and technology in general see the examples in [2], [7], and[26].andM;Logical Dababase ConversionandM;Logical database design is the process of taking a group of fields and, basedon the associations among them, designing a database for them that conformsto the structural rules of a particular database management system.andP;  Thereare several, well-known logical database design approaches, including thosebased on the data normalization technique, the entity-relationship approach,and the Date-Wilson methodology [', 8-10, 18, 27].andP;  Logical database designas a process disregards performance considerations.andP;  We shall begin with arelatively simple navigational database that has not been modified forperformance reasons and then discuss ways to convert it to a relationaldatabase.andP;  With that foundaton, we can move on to the discussion of physicaldesign or performance considerations in the conversion process.andM;The ExampleandM;Our example is the (fictitious) Miami Beach Convention Bureau, funded byhotels, restaurants, and tourist attractions in Miami BEach, which aids inattracting conventions to the city.andP;  To do this it must maintain data onMiami Beach's hotels and on organizations that are known to hold largeconventions.andP;  It also maintains data on conventions that have been held inMiami Beach in the past.andM;Specifically, for every hotel it maintains the hotel name (HNAME), address(HADDR), manager's name (HMANAGER), and number of rooms (HNUMRMS).andP;  For eachroom in a hotel it maintains the room number (RNUMBER), the daily price(RPRICE), the size in square feet (RSIZE), and the serial number (FSERIAL),type (FTYPE), and color (FCOLOR) of each ot its pieces of furniture andappliances.andP;  For every organization it maintains the organization name(ONAME), address (OADDR), number of members (ONUMMEMS), and the name (XNAME)and title (XTITLE) of each ot its officers.andP;  For every convention that one ofthe organizations has held in Miami Beach in the past it maintains the yearthat it was held (CYEAR), its duration in days (CNUMDAYS), and the number ofpeople who attended (CATTEND).andM;Additionally, it maintains a list of the hotels that a particular conventionused and a list of the conventions that have used a particular hotel over theyears.andP;  Included in that convention information is whether or not the hotelwas the convention's headquarters (HQ) and the number of rooms of the hotelthat the convention used (RMSTAKEN).andM;The HNAME and ONAME fields are assumed to have unique values.andP;  RNUMBER isonly unique within each hotel; FSERIAL is only unique within each hotel;CYEAR is only unique within each organization (each organization is assumedto hold one annual convention); XNAME is assumed to be unique within anorganization.andM;Figure 1 shows the Bureau's data arranged for an IMS database.andP;  In the IMSstyle, the database consists of two hierarchies, the Hotel hierarchy with theHotel segment as its root and the Organization hierarchy with theOrganization segment as its root, interconnected by a bidirectional, logicalrelationship.andP;  Remember that in an IMS hierarchy each branch points downwardunless shown otherwise and, as in any navigational database structure,represents a one-to-many relationship.andM;Thus, a hotel has a number of rooms, and a room has a number of pieces offurniture, as shown in the Hotel hierarchy.andP;  An organization has a number ofofficers and has held a number of (annual) conventions, as shown in theOrganization hierarchy.andP;  Notice, for example, that the Room segment does notinclude the HNAME field even though the RNUMBER field is obviously not uniqueacross all of the hotels; te physical linkage between the Hotel and Roomsegment occurrences indicates which room occurrences belong to which hoteloccurrences.andP;  The many-to-many relationship between the conventions and thehotels is supported by the bidirectional, logical relationship shown.andP;  The HQand RMSTAKEN fields, which serve as the intersection data, reside in thepentagonally shaped, logical child segments, H-C and C-H.andM;Figure 2 shows a CODASYL network database that represents the Bureau's data.andO;The direction of each one-to-many relationship is represented by the arrow oneach branch.andP;  The many-to-many relationship between hotels and conventions isaccomplished with a juncture record, H-C.andP;  This is the member record type ofthe set consisting of both it and the hotel record as well of the setconsisting of it and the convention record.andM;Logical Conversion from Navigational to Relational StructuresandM;The conversion of the sample databases in Figures 1 and 2 to a relationaldatabase is straightforward and follows a few basic rules (for a discussionof the conversion of more complex structures see [23]).andM;(1)  Each IMS segment or CODASYL record that represents a real-world entitywill be converted into a table in the relational database.andM;(2)  Each of the tables created in Step 1 will have fields added to establishthe one-to-many relationships that were represented as branches in thenavigational structures and, as needed, to complete their unique identifiers.andO;These foreign keys are the key fields of the superior segments or records inthe hierarchies and networks.andM;(3)  Each IMS logical chld pair or CODASYL juncture record that accomplishesa many-to-many relationship will be converted into a table in the relationaldatabase.andM;(4)  Each of the tables created in Step 3 will have fields added to uniquelyindicate which two entities the many-to-many relationship is between.andP;  Thesefields, which are also referred to as foreign keys, will again be the keyfields of the superior segments or records in the branches of thenavigational structures.andM;Beginning with the IMS database in Figure 1 (the steps for the CODASYLnetwork database in Figure 2 are similar), the conversion to the relationaldatabase in Figure 3 proceeds in the following manner.andP;  The two rootsegments, Hotel and Organization, become tables in the relational databasewith no additional fields.andP;  The Room segment becomes a relational table, butmust have the HNAME field added as a foreign key to establish the one-to-manyrelationship between it and the Hotel segment and to fully identify the room,since room number is unique only within each hotel.andP;  Similarly, the Furnituresegment becomes a relational table with both the HNAME and RNUMBER fieldsadded; since furniture serial numbers are unique within a hotel (not within aroom), only HNAME is needed for uniqueness.andP;  The Convention and Officersegments each become a relational table with the ONAME field added to each toidentify which organization a particular convention and a particular officerbelongs to.andM;The single many-to-many relationship in the example is between hotels  andconventions; it is implemented with a logical relationship using the H-C andC-H logical child segments.andP;  The table added to the relational database inFigure 3 to represent the many-to-many relationship is labeled &quot;Bookings.&quot;andO;Note that its fields include the unique identifier for hotels (HNAME), theunique identifier for conventions (ONAME, CYEAR), and the intersection data(HQ, RMSTAKEN).andP;  Further information about the logicial level of databaseconversion can be found in [20], [21], and [24].andM;Physical DatabaseandM;ConversionandM;Physical database design is the process of modifying or enhancing the resultsof logical database design for performance purposes.andP;  There are no formalmethodologies for physical database design in the same sense that datanormalization is a methodology for logical database design.andP;  As a generalrule, the database designer must determine the response time requirements ofthe application and then modify and enhance the database structure to obtainacceptable performance without introducing unacceptable levels of databaseredundancy in the process.andP;  For product/model specific treatments of physicaldatabase design see [4], [6], [12], and [18] for IMS, [11], [17], and [29]for DB2, and [5] for relational databases in general.andM;We propose a five-step process for converting a navigational database to arelational databases:andM;(1) Recognize if and how the navigational dat abase was modified forperformance purposes at the time that it was designed.andM;(2) Determine which critical application performance factors were consideredin making those modifications.andP;  Both Steps 1 and 2 are particularly importantif, as is so often the case, adequate documentation does not exist.andM;(3) Reverse the performance modification process in the navigationalstructures to obtain the kind of simplified structure that would have comefrom only the logical database design process.andM;(4) Convert the simplified structure obtained in Step 3 into a relationaldatabase using the logical conversion process described earlier.andM;(5) Modify or enhance the relational database obtained in Step 4 to maximizeperformance in terms of those application performance factors consideredimportant in Step 2.andM;Both the kinds of structural modifications and the kinds of enhancements thatcan be made in a database structure depend on the data model and on the DBMSin use.andP;  As we delve into specific physical database design conversionissues, we will try to strike a reasonable balance between referring tospecific DBMSs as examples and describing the conversion in broad terms.andP;  Aknowledge of IMS, DB2, and the other systems mentioned would be helpful tothe reader; however, it will not be essential.andP;  The performance modificationsand enhancements described here are not quirks of a single DBMS, but are ofgeneral interest in terms of such generic topics as indexes, linked lists,physically clustered storage, and so on.andP;  Of course, there is no claim thatthe cases discussed represent a complete set, merely that they represent asignificant, thought-provoking collection of design modifications andenhancements that are of important, practical value.andM;Access Method DecisionsandM;The first topic is a comparison of performance-related design decisionsregarding access methods and record storage.andP;  In addition to being animportant topic in its own right, it will set the stage for some of theconversion decisions to come later.andM;In the initial design of an IMS heirarchy, the two major file organizationand access method decisions to be made are:andM;(1) what kind of access should there be to the root segment through its(unique) key andandM;(2) how should the segment occurences subordinate to the root be stored.andM;Selected with so-called IMS Access Methods, the choices for root access aresequential, indexed, and hashed while the choices for subordinate segmentaccess are sequential and pointer based.andP;  The more interesting, high-speed,online applications use (1) IMS databases that provide either indexed orhashed access to the root and (2) pointer-based (child and twin pointer)access to the subordinate segments.andP;  Figure 4 shows an arrangement of thechild and twin pointers in a portion of a hierarchical occurrence or databaserecord.andP;  In addition, secondary indexes can be created to provide directaccess to any segment through any of its fields (which need not be unique),but still, only the key of the root can be hashed.andM;In CODASYL network databases, immediately superior and subordinate recordtypes (known as a set when combined) are connected to each other withcircular chains of next pointers.andP;  The occurrences of any particular recordtype can be retrieved through the occurrences of their superior recordoccurrences via next pointers, or they can be stored and retrieved viahashing (any number of record types in a CODASYL network can be hashed).andO;Some implementations also allow secondary indexing.andM;In navigational databases, the physical design decision regarding segment orrecord storage and retrieval are based on the requirements of theapplications that will use them.andP;  In IMS, hashed access to the root isconsidered to be faster than indexed access, but the indexed sequentialnature of the VSAM-KSDS index also provides relatively fast sequential accessto the root via its key.andP;  In a CODASYL network database, direct access viahashing to any record type of one's choosing is tempting, but the absence ofhashing provides faster access when an ordered subset of the occurences of arecord type have to be retrieved from an occurrence of the superior or ownerrecord type of the set they are in.andM;Secondary indexes in any system have the advantage of providing additionaldirect access paths to the data, but have the disadvantage of slowing downthe system during heavy updating since the system must stop to update anysecondary index affected by the update.andP;  In fact, secondary indexes aregenerally avoided in performance-sensitive applications that have volatiledatabases.andM;The tables of relational databases are characterized by having no pointersthat connect records and by the heavy use of indexes.andP;  In addition, somerelational systems, such as INGRES, permit the storage and retrieval of therecords of a table by hashing.andM;After the logical aspects of the conversion are accomplished, one of theprimary physical aspects is to insure that the fast, direct access providedin the navigational database is also provided in the relational.andP;  To beginwith, every relational table that was directly derived from the root segmentof an IMS hierarchy or a hashed CODASYL network record must be indexed orhashed on the equivalent key fields (e.g., the HNAME field of the Hotelsegment of the Hotel hierarchy of Figure 1 and the HNAME field of the Hoteltable of Figure 3).andM;Every secondary index in the navigational database must be rebuilt as anindex into the appropriate relational table.andP;  But note the followingequivalency in the conversion from an IMS database:  An IMS secondary indexcan be based on a field in a subordinate source segment to retrieve asuperior target segment.andM;For example, a secondary index can be based on the FSERIAL field of theFurniture segment of the Hotel hierarchy of Figure 1 to retrieve the roomoccurrences of the rooms that particular pieces of furniture are in.andP;  It isinteresting to note that the Furniture table of Figure 3 already has theHNAME and RNUMBER fields indentifying the hotel room that has furniture.andP;  Ifall that is required of the secondary index is to find a room identifier,then the furniture table is the only table required in the access.andP;  If otherattribute data about a room or hotel is required, then the equivalent of theIMS secondary index described above will be an index into the FSERIAL fieldof the Furniture table plus an eventual join of that table with the roomand/or Hotel tables.andM;Finally, what if the decision was made to provide indexed sequential access(i.e., B-tree-type access) to the root occurrences for the purpose ofefficiently retrieving an ordered subset of the occurrences?andP;  The equivalentin the relational database is to cluster the table on its key field.andP;  Forexample, if the Hotel segment of the Hotel hierarchy in Figure 1 was arrangedin an indexed sequential manner using its HNAME field, then a clustered indexshould be built over the HNAME field of the Hotel table of Figure 3, not onlyto index the records on that field, but to physically order the records ofthe table according to that field's values.andM;Segment/RecordandM;Placement and DesignandM;Accessing data or retrieving it in an integrated fashion in navigationalsystems means navigating through the hierarchical or network storagestructure and retrieving related record occurrences.andP;  In terms ofperformance, these systems are sensitive to the distance on the disk fromwhich the sought data is to the point of entry (e.g., the IMS root) into thestructure.andP;  The retrieval is more efficient if the data is in the same blockor at least the same cylinder as the entry point.andM;IMS segment occurrences within a database record can be stored in either asequential or a pointer-based fashion (the latter is assumed for directaccess performance purposes).andP;  In either case, however, the physical storageof the segment occurrences will be in the form of a preorder sequentiallisting: top-to-bottom, left-to-right, and front-to-back (the latter meaningmoving through the twin chain of occurrences of a given segment type).andP;  Inthe Organization hierarchy, this means that all of the convention and C-Hsegment occurrences of a particular organization will be stored after theorganization root occurrence and before any of the officer occurrences.andP;  As ageneral rule, in this kinds of situation, one would assume that the officeroccurrences will not reside in the same physically addressable are on thedisk as the organization occurrence because of all of the convention and C-Hoccurrences that must be stored in between them.andM;Therefore, in IMS hierarchies, the rule-of-thumb is to place frequentlyaccessed segments as high up and as far to the left in the hierarchy aspossible.andP;  for example, the Organization hierarchy of Figure 1 has theConvention segment to the left of the Officer segment.andP;  In the logical designprocess, that might just as well have been reversed.andP;  From a performancepoint of view, however, if convention data is to be accessed more frequentlythan officer data, physical design dictates that the Convention segment be tothe left of the Officer segment.andM;The only thing that could be considered to be the practical equivalent tothis issue in the relational case is not a fundamental aspect of therelational model.andP;  Rather, it is a matter of grouping related tables togetherwithin broader storage areas (e.g., DB2 tablespace) for the purpose ofincreasing the efficiency of join operations.andP;  Under user control, it mayeven be possible to interleave related records of two different tables in thephysical disk storage.andM;Another possible problem in an IMS database in having a subordiante segmenttype, which has only one occurrence relative to its parent segmentoccurrence.andP;  imagine if in the organization hierarchy in Figure 1, theofficer segment was replaced with a President segment.andP;  Since there is onlyone president of an organization there would only be one occurrence of thePresident segment for each occurrence of the organization segment.andP;  Ratherthan have the additional overhead for the President segment, the data aboutthe president could be incorporated into the Organization segment with noloss in data integrity.andP;  The equivalent situation in a relational databasewould be two tables that have a one-to-one pairing between their rows; one ofwhich has a foreign key field that relates it to the other.andP;  The two tablescould, in effect, be permanently joined to produce the same result as in theIMS case.andM;Another practice in IMS physical design is to take the result of the logicaldesign process and reduce the number of segment types by combining segmentstogether or increase the number of segment types by splitting segment apart.andO;The same can be done for CODASYL network record types.andP;  Combining IMSsegments (i.e., parent and child segments) together may reduce the amount ofnavigation needed to retrieve the data, but introduces data redundancy,assuming that the logical design was done properly in the first place.andO;Splitting segments up may be done to improve security and data independence,but also results in a more complex structure.andM;In coverting to a relational database, the splitting of IMS segments can berecognized by there being two segments with the same key field at the samelevel in the hierarchy.andP;  For example, splitting the Room segment of the Hotelhierarchy into two segments would result in one segment that consists of theRNUMBER and RPRICE fields and another that consists of the RNUMBER and RSIZEfields.andP;  These can either be recombined for conversion to the relationaldatabase (with security being handled by views) or converted as they are withthe HNAME field added to each resultant table as a foreign key.andM;The combining of IMS segments can be recognized by performing a normalizationanalysis of its fields or by noting the redundancy in the actual stored data.andO;It is interesting to note the recent interest in the topic ofdenormalization, which means combining related tables of a relationaldatabase together to reduce the number of join operations necessary inquerying them.andP;  Again, this introduces data redundancy, but from a physicaldesign viewpoint, what is discussed as denormalization in relationaldatabases is the same as combining linked segments together in an IMSdatabase or collapsing sets into records in a CODASYL network database.andM;As a final note here, there are a variety of optional pointers that can beintroduced into IMS and CODASYL network database to improve performance.andO;Examples are the twin backward pointers in IMS databases and the ownerpointers in CODASYL network databases.andP;  If the purpose of the optical pointeris to speed an operation of the DBMS without having any logical applicationuse (as the IMS twin backward pointers improve the speed of deletions on twinchains), then there is no relational equivalent.andP;  On the other hand, as anexample, CODASYL owner pointer provides a faster way of finding the superioror owner occurrence of a record.andP;  The equivalent in a relational database isthat the identifier of the superior entity is already in the record as aforeign key as a result of the logical design process.andP;  If more than the keyvalue is needed then a join must be performed with the table representing thesuperior entity.andM;The Power of HashingandM;Storing and retrieving records based on calculations of their key values(&quot;hashing&quot;) is generally considered to be the fastest means of performingdirect storage-and-retrieval operations, as the case has always been in IMS(excluding the case of synonyms).andP;  IMS permits direct access to a rootsegment using a choice of hashing or an index.andP;  Nonroot segments can bereached directly using secondary indexes, but not by hashing.andM;As we have ssen, the design of the Organization hierarchy in Figure 1 isperfectly reasonable, in terms of logical design and, again, Figure 4 shows aportion of the occurrence (database record) of the Organization hierarchy forthe XYZ Assocation.andP;  Suppose a critical application requires very fast,direct access to the Officer segmetns? There are a few ways that a particularofficer can be reached on a more or less direct basis.andP;  Since an officer nameis only unique within an organization, the full identifier of an officer ishis or her name and organization.andP;  The system could find the organizationoccurrence directly with an index or a hashing routine (depending on whichone the data was stored with) and then navigate along the pointers to thesought officer occurrence.andP;  Based on the discussion in the previousparagraph, this procedure could require an additional I/O operation and, fora more complex hierarchical structure, could require more than one.andM;An alternative would be to have a secondary index built over the XNAME fieldof the Officer segment and use that index to access the officers directly.andO;But, if more than one organization has an officer of the same name,additional I/Os will be incurred in following another kind of pointer (aparent pointer) back to the root occurrences to distinguish the rightorganization.andP;  As another alternative, a copy of the ONAME field could beadded to the Officer segment and the secondary index built on the combinationof the ONAME and XNAME fields, but that wastes space, creates a form of dataredundancy, and is still utlimately dependent on an index for direct access,as opposed to a faster hashing routine.andM;Figure 5 shows an alternative solution to this IMS performance problem.andO;Officer, with the ONAME field added, has been split off as the root of a newhierarchy.andP;  Officer segment occurrences can still be reached throughorganization occurrences via the unidirectional logical relationship that hasbeen introduced to connect them.andP;  Clearly, a significant amount of complexityhas been added.andP;  The advantage is that, as the root of a hierarchy, officersegment occurrences, using the combined ONAME and XNAME fields as a key, canbe stored and retrieved via a hashing routine.andP;  This will provide for thefaster posible direct access.andP;  Note that in a CODASYL network database, anyrecord type can be stored with a hashing routine.andP;  (The decision of whichrecord types to has and which to store only with pointers from other recordsalso leads to questions of how related occurrences get physically spread outover a disk device.)andP;  Thus, in the CODASYL network in Figure 2, a copy of theONAME field could be added to the Officer record, which could then be storedvia hashing with the ONAME and XNAME fields as the key in a way similar tothe IMS case.andM;When happens if the original decision was made to modify the Organizationhierarchy in Figure 1 into the heirarchies in Figure 5 for performancereasons, and now the latter are to be converted into a relational databse?andO;Unless explicit documentation exists, the first step is to recognize that thestructures were designed with this particular performance enhancement inmind.andP;  The separate database, the unidirectional logical relationship, andthe repetition of the ONAME field are the obvious clues to that.andP;  The resultis the recognition of the one-to-many relationship between organizations andofficers and, from a strictly logical IMS or CODASYL point of view, therepetition of the ONAME field in the Officer segment.andP;  With that established,the conversion is straightforward, resulting in the Organization, officer,Convertion, and Bookings tables in Figure 3.andM;The addition of the ONAME field in the Officer Segment in Figure 5, which wasdone for performance reasons, is a logical necessity in the relationaldatabase in Figure 3, where the ONAME field was placed in the officerrelation as a foreign key required for logical connectivity reasons.andP;  Inorder to have fast, direct accesss to officers in the relational database,the combined ONAME and XNAME fields in the Officer table can be used as thekey of an index (as in DB2, which does not permit hashing) or as the key of ahashing routine (as in INGRES).andP;  We should refer back to the discussion thatused Figure 4 to show how the segment occurrences of the Organizationhierarchy would be spread out on the disk.andP;  In Figure 3, the relatedorganization and officer records of the relational database are not likely tobe near each other on the disk unless the relational system offers physicalinterleaving of record occurrences from different tables.andP;  That would havesome affect on the performance of a relational join operation just as thephysical spread in the hierarchical diagram in Figure 4 would have someaffect on the speed of navigating through the hierarchy.andM;Long Twin ChainsandM;Related to the situation in the section on the power of hashing is theproblem of long twin chains.andP;  Figure 6 shows a portion of a Hotelhierarchical occurrence.andP;  Typically, there will be a large number of rooms ina hotel and therefore a large number of Room segment occurrences attached toa single Hotel segment occurrence.andP;  As shown in the root segment in Figure 6,the Acme Hotel has 300 rooms, and so there are 300 occurrences of the Roomsegment, connected by twin pointers in a twin chain.andP;  Each Room occurrencecan have several Furniture segment occurrences under it, making the overallhierarchical structure rather large and spread out (a situation that wouldobviously be that much worse in a more complex structure).andM;An application that requires access to all of the rooms in a particular hotelcan efficiently follow the room's twin chains to retrieve all of the hotel'sroom occurrences (although complexity below the Room segment can spread theRoom occurrences out on the disk).andP;  But what about an application thatrequires direct access to a single room of a particular hotel?andP;  Theapplication can reach the hotel root occurrence quickly enough, but then mustplow through the twin chain, which may be spread over several blocks, in asequential fashion until it finds the one room that it is looking for.andP;  In acomplex structure or one with large record sizes, that could incure anunacceptable number of I/Os.andP;  The situation would be similar in the CODASYLnetwork database in Figure 2 if the Room record type is stored via set,relative to the Hotel record type, rather than being stored via cale with ahashing routine.andM;Some of the remedies to this problem are the same as in the situation in theprevious section.andP;  A secondary index can be applied to the Room segment, butbecause many hotels have the same room numbers, the Hotel segment will haveto be accessed too, with a price in I/Os.andP;  Alternatively, the HNAME field canbe added to the room segment and to the secondary index at the price ofduplication.andP;  In another method, the Room segment can be promoted and becomethe root of its own hierarchy, in a way similar to the structure in Figure 5.andO;A third technique is to create a new, intermediate-level segment between thesegment with the long twin chains (Room) and its parent segment (Hotel).andO;Figure 7 shows the Hotel hierarchy with a new segment type, Floor, insertedbetween Hotel and Room.andP;  With this structure, an application can move fromthe hotel to the floor to the rooms on that floor without encountering therooms on any of the other floors.andM;In converting from an IMS database to a relational database, the structuralmodification shown in Figure 7 must be recognized and dealt with.andP;  The Floorsegment must be removed before the conversion to the relational databasetakes place.andP;  After the conversion to the relational database, the Roomtable, as shown in Figure 3, must include the HNAME field as a foreign key.andO;Depending on the capabilities of the relational system in use, the Room tablecan be hashed or indexed on the combination of the HNAME and RNUMBER fieldsfor fast, direct access a particular room.andP;  If there is a requirement, assuggested above, for sequentially finding all or some of the rooms of ahotel, then the index on the Room table's HNAME/RNUMBER fields combinationcan be clustered.andM;Many-to-Many RelationshipsandM;The type of structure designed to handle many-to-many relationships in IMS issomewhat complex and is open to a number of performance-related decisions inthe database design process.andP;  While many-to-many relationships are handled inCODASYL network database in a fundamentally similar method to IMS, it tendsto be somewhat simpler in the design stage but more complicated for theapplication programmer to use.andP;  In relational database, each many-to-manyrelationship requires the creation of an additional table in astraightforward manner.andP;  We shall review the IMS structures and performancedecisions for many-to-many relationships and compare them to the relationalsituation.andM;The many-to-many relationship in our example is between conventions andhotels: each convention used several hotels, and each hotel, over the years,has been used by a number of different conventions.andP;  That situation isreflected in the IMS database in Figure 1 by the connections between theHotel segment of the Hotel hierarchy and the Convention segment of theOrganization hierarchy, using the pentagonally shaped logical child segmentsH-C and C-H.andP;  In the CODASYL network database in Figure 2, a single juncturerecord between the Hotel and Conventions records, H-C, serves the samepurpose.andP;  Figure 8 shows a portion of an occurrence of the Hotel hierarchy ofFigure 1, along with portions of the Organization hierarchy occurrences thatit points to through its logical child (H-C) segments.andP;  Notice that eachConvention segment occurrence points to its Organization segment parent sothat both the organization and the convention for the particular year can beidentified.andP;  A similar picture would be drawn for the other half of thebidirectional logical relationship from the Convention segment side,completing the implementation of the many-to-many relationship.andP;  Theequivalent structure in the relational database of Figure 3 is the Bookingtable, which ties together the Hotel and Convention tables.andP;  It consists ofthe full identifiers of hotels (HNAME) and of conventions (ONAME, CYEAR),plus the intersection data (HQ, RMSTAKEN).andM;Functionally, relational and the navigational structures can provide the sameresults.andP;  The IMS database is capable of producing a list of all of thehotels that a particular convention used, together with all of the data aboutthe hotels and the conventions and, in the many-to-many style, vice versa.andO;The relational database can do that too by joining an appropriate combinationof the Hotel, Bookings, Convention, and Organization tables.andM;To understand the salient points of converting from the IMS to the relationalstructure, we must examine the various performance concerns in the IMSstructure.andM;One decision in IMS is whether the logical relationship is to be physicallypaired or virtually paired.andP;  In physical pairing, the logical child segments,like H-C and C-H in Figure 1, are both legitimate, physical segmentscontaining pointers and intersection data (which the system maintains induplicate on both sides of the relationship).andP;  In virtual pairing, the reallogical child exists physically on only one side of the relationship whilethe other side of the relationship contains a virtual logical child.andP;  Thelatter is simply a convenience to represent the fact that in addition to thenormal physical twin chain that connects the logical child occurrences underits physical parent (e.g., the H-C occurrences under the Hotel occurrence inFigure 8), and additional logical twin chain will be constructed in thosesame logical child occurrences to represent the other side of themany-to-many relationship.andP;  Actually, if one examines how a many-to-manyrelationship is implemented in a CODASYL network database, one will findsimilar, multiple twin chains going through the juncture records.andM;There are performance advantages and disadvantages between physical andvirtual-pairing.andP;  Generally, if there is a large amount of equally importantaccess activity from both sides of the logical relationship, then physicalpairing is better.andP;  If most of the activity is from one side, thenvirtual-pairing is preferred, with the real logical child residing on themore active side and/or the side with the longer twin chains.andP;  (A moredetailed study of the structure will show that long logical twin chains in avirtual pairing situation can be performance disasters.andP;  Also, sequencing oflogical twin chains, which the system does handle, is costly in time oninsertion and deletion operations.)andM;In the conversion to a relational database, all forms of navigationalmany-to-many relationship structures, including the two IMS forms and theCODASYL network juncture record form, will convert to an additionalrelational table of the form of the Bookings table in Figure 3 that we havealready described.andP;  The physical design choices to be made in the relationalcase are considerably simpler in this situation than in the navigationalones.andM;In the choice of indexes for the many-to-many relational table (Booking inFigure 3), the functional equivalent of an IMS logical child segment is anindex on the field that identifies the physical parent in the IMS database,combined with the rest of the many-to-many table's key structure.andP;  That is,the point of the HC segment in Figure 1 is to collect all of the conventionsthat involved a particular hotel (which, in this context, during a retrieval,assumes that you have reached the root occurrence of that particular hotel inthe first place) and to cross over to the Convention segment, as needed.andP;  Theequivalent in the many-to-many relational table is to index the HNAME fieldand then join the Bookings table to the Convention and Organization tables,as needed.andP;  On a retrieval, the index on the HNAME field allows you toquickly find the identifiers of the conventions that have been involved witha particular hotel, and then the join operation allows you to get moredetailed data about the conventions and organizations, much as crossing thelogical relationship to the Convention segment would in IMS.andP;  Similarly, thefunctional equivalent of the C-H segment in Figure 1 would be an index on thecombination of the ONAME and CYEAR fields in the Bookings table.andP;  Since, inthe relational database of Figure 3, the Bookings table is a crucial tablethat links together much of the other data in the database, those two indexeswould be suggested in any case.andM;There is a rather interesting performance comparison between the IMS andrelational cases.andP;  This involves the real logical child versus virtuallogical child segments in the IMS virtually paired bidirectional logicalrelationship case and the concept of clustering in the relational database.andO;Both have serious performance consequences in their respective systems.andO;Performance in moving across an IMS logical relationship depends on how closetogether various components of the logical relationship are on the disk.andO;Assume that we are trying to find all of the conventions that have takenplace at a particular hotel.andP;  Since Hotl is a root segment, we should be ableto find the specific root occurrence directly.andP;  Following the diagram inFigure 8, we can reach the first H-C logical child occurrence quickly with adirect pointer from the hotel occurrence to the first of the H-C occurrences.andO;With no subordinate segments under H-C occurrences for that hotel should beclose together on the disk.andP;  But the Convention occurrences in theOrganization hierarchy are likely to be widely scattered, causing significantperformance delays.andP;  The situation with a virtual logical child is worsebecause the logical child occurrences along the logical twin chain are likelyto be widely scattered.andM;In the relational database, assume that the search for the particular hotelin question will be via an index on the HNNAME field in the Bookings table.andO;Clustering the table on that fields will bring all of the records with thesame HNAME values physically close together.andP;  (Hashing the table would not beappropriate for this purpose.)andP;  Then those records can be joined to theConvention table on the ONAME, CYEAR fields.andP;  Having the ONAME/CYEARcombination indexed in the Convention table will, of course, help, althoughthe records themselves will be scattered through that table.andP;  Also, rememberthat a relational table can only be clustered one way.andP;  The Bookings table inFigure 3 can be clustered on HNAME or on the ONAME/CYEAR combination, but notboth, which is analogous to the IMS virtually paired bidirectional logicalrelationship.andM;A final note here concerns the difference between direct and symbolicpointers.andP;  In IMS, the pointer from the logical child to its logical parent(the pointers coming from the pentagonally shaped boxes in Figure 8) can beeither symbolic (the fully concatenated key value of the segment beingpointed to, meaning CYEAR and ONANE in this example), direct (the physicaladdress of the segment being pointed to), or both.andP;  Direct pointers areuseful for quickly crossing the logical relationship boundary in a query.andO;symbolic pointers are useful in speeding reorganization and in those querysituations where the key value of the logical parent is the only part of thelogical parent needed.andP;  The equivalent situation in the relational databaseis that what would be the symbolic pointer in the IMS logical child is thekey of the &quot;other&quot; entity in the many-to-many table, the combination of theONAME and CYEAR fields in the Bookings table in Figure 3.andP;  That is, therelational situation always looks like the symbolic pointer case in IMS.andP;  Ifonly the organization name and the year of the convention are needed tosatisfy the query when looking for all of the convention that a hotel hasbeen involved with, then only the Bookings table is needed.andP;  Of moreinformation about the convention or the organization is needed then a joinmust be performed.andP;  It is the join operation that is the functionalequivalent of crossing the logical relationship boundary in IMS, whether thepointers there are symbolic or direct.andM;Storage subdivisionsandM;Beyond the types of physical design modifications that we have discussed thusfar is a level involving the division of portions of the database structuresinto different storage areas.andP;  While this is quite product specific we shallbriefly discuss this aspect of two DBMS as examples of this kind ofperformance-related decision.andM;IMS permits the occurrences of different segment types of a hierarchy to bestored in different data set groups.andP;  Consider the Hotel hierarchy of Figure1 and the sample occurrence of it in Figure 6.andP;  The structure makes perfectsense from a logical point of view, and some applications may have tonavigate from Hotel to Room to Furniture segments.andP;  What if there is also aparticularly important application that requires the retrieval of all roomsin a particular hotel very quickly? Since the Room occurrences are going tobe widely spread out on the disk because of the intervening subordinateFurniture occurrences, a large number of I/Os will take place when retrievingthe Room occurrences, and performance will suffer.andM;On the other hand, if the Furniture segment type is segregated in a separatedata set group, then the Room occurrences, with no subordinate segments intheir own data set group, will be stored in a tightly packed fashion on thedisk.andP;  Logically, the database remains the same, and the concept of theconnecting pointers remains the same, except that now the child pointers inthe Room occurrences point to a different data set group.andP;  Of course, withthis arrangement, an application that requires the retrieval of each roomwith its furniture data will suffer in performance as compared to having thestructure entirely within one data set goup.andP;  Other reasons for specifyingmultiple data set groups in IMS, based on the way the system works, includegrouping segments that are similar in length and segregating segment typesthat are subject to requent insertions and deletions from those that are not.andM;IBM's DB2 relational DBMS has several storage area options calledtablespaces, database, and storage groups.andP;  A tablespace can contain one ormore tables.andP;  A database can contain several tablespaces (and indexspaces forindexes).andP;  The significance of a database is that from an operational andsecurity point of view, all of the tables in a database can be restricted ormade available.andP;  The significance of a tablespace is that it is the unit ofreorganization and recovery.andP;  Furthermore, if two tables are in the samesimple tablespace, then, under user control, related records of the twodifferent tables can be physically interleaved, which may improve performanceunder some circumstances.andP;  The one table that can reside in a partitionedtablespace can be partitioned so that is records can be stored in differentpartitions, based on the value of one of its fields.andP;  In this case, thepartition becomes the unit of reorganization and recovery, and each partitioncan be stored in different storage groups.andP;  Storage groups are the means ofassigning data to actual physical storage devices.andP;  Databases can be splitacross different storage groups and vice versa.andP;  Storage groups, therefore,provide the ability to physically group data close together on a disk.andM;What are the conversion implications when trying to convert an IMS databasethat has been split into multiple data set groups into a relational databasesuch as DB2, which allows the kinds of table and storage groupings that wejust described?andP;  Assume that an IMS hierarchy was split into wto or more dataset groups for the purpose of storing certain data close together on thedisk.andP;  In the scenario that we described above, the goal was to have the Roomoccurremces stored close together, and for that purpose that Room segment wasmade a terminal node of the hierarchy in one of the data set groups.andP;  In arelational system, since a particular IMS segment like Room will bestructured as a table, all of the data about rooms will naturally be storedtogether.andP;  If, as in this particular scenario, it is important to store allof the records for the rooms in each particular hotel near each other, thenthe Room table in Figure 3 can have a clustered index built over the HNAME,RNUMBER combination of fields.andM;ConclusionandM;Database technology was created to solve a group of pressing problems in dataprocessing.andP;  Today, a tremendous amount of the world's commerce runs onnavigational database management systems.andP;  The ever-increasing interest inrelational DBMSs means that a tremendous new path for application developmentusing database technology is growing and widening.andP;  Soon, we may see widecommercial use of object-oriented and expert database products, which willlikely be based on the relational model.andP;  It is most important that we studyand manage the conversions that must take place as we continually progress tonewer concepts in database.andM;ReferencesandM;[1] Date, C. J. a Guide to INGRES.andP;  Addison-Wesley, Reading, Mass., 1987.andM;[2] Date, C. J. An Introduction to Database Systems.andP;  Vol.andP;  1, 4th ed.andO;Addison-Wesley, Reading, Mass., 1986.andM;[3] Date, C. J., and White, C.J.andP;  A Guide to DB2.andP;  2nd ed.andP;  Addison-wesley,Reading, Mass., 19898.andM;[4] Dechow, E.L., and Lundberg, D.C.andP;  The IMS DataBase/Application Review.andO;Bulletin No.andP;  G320-6009, IBM Palo Alto systems Center, 1977.andM;[5] Fleming, C.C., and von Halle, B. Handbook of Relational Database Design.andO;Addison-Wesley, Reading, Mass., 1989.andM;[6] Geller, J.R.andP;  IMS Administration, Programming, and Data Base Design.andO;John Wiley andamp; sons, New York, 1989.andM;[7] Gillenson, M.L.andP;  Database Step-by-ste.andP;  2nd ed.andP;  John Wiley andamp; Sons, NewYork, 1990.andM;[8] Gillenson, M.L.andP;  The duality of Database structures and designtechniques.andP;  Commun.andP;  ACM 30, 12 (Dec.andP;  1987), 1056-1065.andM;[9] Gillenson, M.L., and goldberg, R. Strategic Planning Systems Analysis,and Database Design.andP;  John Wiley andamp; Sons, New York, 1984.andM;[10] Hawryzkiewycz, I.T.andP;  Database Analysis and Design.andP;  Science ResearchAssociates, Chicago, Ill., 1984.andM;[11] Heydt, R., and Heydt, D. DB2 Database Design and Administration, Version2.andP;  John Wiley andamp; Sons, New york, 1989.andM;[12] Hubbard, G.U.andP;  IMS (DL/I) Data-base Organization and Performance.andP;  VanNostrand Reinhold, New York, 1986.andM;[13] Husband, R.W.andP;  Mchenry, T.J., and Wooten, J.C.andP;  ODMS/R System Reference.andO;John Wiley andamp; Sons, New York, 1987.andM;[14] IBM Corp. DB2 Version 2 System and Data Base Administration Guide.andP;  FormNo.andP;  SC26-4374, IBM, 1988.andM;[15] IBM Corp. DB2 Application Design and Tuning Guide.andP;  Form No.andP;  GG24-3004,IBM, 1986.andM;[16] IBM Corp. IMS/VS Version 1 Data Base Administration Guide.andP;  11Th ed.andO;1986.andM;[17] Inmon, W.H.andP;  Optimizing Performance in DB2 Software.andP;  Prentice-Hall,Englewood Cliffs, N.J., 1988.andM;[18] Inmon, W.H.andP;  Effective Data Base Design.andP;  Prentice-Hall, EnglewoodCliffs, D.J., 1981.andM;[19] Kapp, D., and Leben, J. IMS Programming Techniques.andP;  2nd ed.andP;  VanNostrand Reinhold, New York, 1986.andM;[20] Larson, J.A.andP;  Bridging the gap between network and relational DatabaseManagement Systems.andP;  Comput.andP;  16, 9 (Sept.andP;  1983), 82-92.andM;[21] Manola, F.A.andP;  Model-model mappings and conversion in a family of datamodel specifications.andP;  Report No.andP;  NBS-GCR-84-464, National Bureau ofStandards, Washington, D.C.andP;  1984.andM;[22] Olle, T.W.andP;  The CODASYL Approach to Data Base Management.andP;  John Wiley andamp;Sons, New York, 1978.andM;[23] Pasley, R. Physical design for difficult data structures.andP;  DatabaseProgram.andP;  Des.andP;  2, 5 (May 1989), 46-59.andM;[24] Sockut, G.H.andP;  A framework for logical-level changes within databasesystems.andP;  Comput.andP;  18, 5 (May 1985), 9-27.andM;[25] Stonebraker,M., (Ed.) The INGRES Papers.andP;  Addison-Wesley, Reading,Mass., 1986.andM;[26] Tsichritzis, D.C., and Lochovsky, F.H.andP;  Data Models.andP;  Prentice-Hall,Englewood Cliffs, N.J., 1982.andM;[27] Vetter, M., and Maddison, R.N.andP;  Database Design Methodology,Prentice-Hall, Englewood Cliffs, N.J., 1981.andM;[28] Walsh, M.E.andP;  Information Management Systems/Virtual Storage.andP;  Reston,Reston, VA., 1979.andM;[29] Wiorkowski, G., and Kull, D. DB2 Design and Development Guide.andO;Addison-Wesley, Reading, Mass., 1988.andM;MARK L. GILLENSON is an associate professor of computer Information Systemsat the University of Miami, School of Business Administration, Coral Gables,Florida.andP;  His current research interests include database design and databasemanagement  Author's Present Address: Department of Computer Informationsystems, School of business Administration, University of Miami, 423 JenkinsBuilding, P.O. Box 248818, Coral Gables, FL 33124andM;Permission to copy without fee all or part of this materials is grantedprovided that the copies are not made or distributed for direct commericaladvantage, the ACM copyright notice and the title of the publication and itsdate appear, and notice is given that copying is by permission of theAssociation for Computing Machinery.andP;  To copy otherwise, or to republish,requires a fee and/or specific permission.andO;</TEXT></DOC>