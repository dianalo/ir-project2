<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-173-918  </DOCNO><DOCID>08 173 918.andM;</DOCID><JOURNAL>Dr. Dobb's Journal  March 1990 v15 n3 p16(8)* Full Text COPYRIGHT Mandamp;T Publishing 1990.andM;</JOURNAL><TITLE>Assembly language lives!: more speed, less filling. (tutorial)</TITLE><AUTHOR>Abrash, Michael.andM;</AUTHOR><SUMMARY>The assembly program language still creates some of the fastestprograms around, despite the predictions of its demise.andP;  Assemblylanguage is harder to use and harder to maintain, which explainssome of the feeling against it.andP;  One of the reasons it survives isbecause it produces the best code of any language.andP;  A sample ofassembly language in action is a C subroutine, CopyUppercase, thatcopies the contents of one far zero-terminated string to anotherfar zero-terminated string, converting all lowercase characters touppercase in the process.andP;  The source code is available on disk oronline.andM;</SUMMARY><DESCRIPT>Topic:     TutorialAssembly LanguageType-In ProgramsProgramming InstructionCode Generation.andO;Feature:   illustrationtableprogram.andO;Caption:   Sample execution times of CopyUppercase. (table)Sample codes generated for CopyUppercase. (table)Sample program listings. (program)andM;</DESCRIPT><TEXT>(Listings not included)andM;There's an old joke that goes something like this: Person #1: Help! Mybrother thinks he's a chicken, and I don't know what I should do.andP;  Person #2:Have you told him the truth? Person #1: I would, but I need the eggs.andO;Updated for the modem age of structured languages and object-orientedprogramming, that joke would read:andM;Manager #1: Help! My programmers think assembly language is a viableprogramming language, and I don't know what I should do.andM;Manager #2: Have you told them the truth?andM;Manager #1: I would, but I need the speed.andM;Assembly language beats everything else hands down when it comes toperformance - especially when programming for the 8Ox86, where assemblylanguage is wild, woolly, and wondrous - yet it gets no respect.andP;  When youflat-out need performance, there simply are no substitutes for assemblylanguage - so why doesn't anyone seem to love it?andM;Assembly Language isn't CheapandM;Experts, pundits, and management types have been beating the drums for thedemise of assembly language for years.andP;  There are many good reasons forwishing it dead.andP;  Compared to compiled code, good assembly-language code isharder to write, is more bug prone, takes more time to create, is harder tomaintain, is harder to port to other platforms, and is more difficult to usefor complex, multi-programmer projects.andP;  That makes assembly language anexpensive, demanding, and time-consuming development language.andP;  Given therealities of time to market, the relative costs of good assembly language andhigh-level language programmers, programmer turnover and ever-increasingsoftware complexity, it's neither surprising nor unreasonable that most ofthe industry wishes assembly language would go away.andM;Assembly language lives, though, for one simple reason: Properly applied, itproduces the best code of any language.andP;  By far.andM;Assembly Language LivesandM;Don't believe me? Consider this.andP;  if the carbon-based computer between yourears were programmed with as good a compiler as Microsoft's, then you'dgenerate much better code in assembly language than does Microsoft C, becauseyou know vastly more about what you want your program to do and aremarvelously effective at integrating that knowledge into a working whole.andO;High-level languages are artificially constrained programming environments,able to pass relatively little of what you know along to the ultimate machinecode.andP;  There are good reasons for that: High-level languages have to becompilable and comprehensible by humans.andP;  Nonetheless, there's no way for ahigh-level language to know where to focus its efforts, or which way to biascode.andM;For example, how can a Pascal compiler know that one loop repeats twice, onaverage, while another repeats 32,767 times? How can a C compiler know thatone subroutine is time critical, deserving of all possible optimization,while another subroutine executes in the background while waiting for thenext key to be pressed, so speed matters not at all? The answer is: No way.andO;(Actually, #pragma can do a little of that, but it's no more than a tiny stepin the right direction.)andM;just as significantly, no compiler can globally organize your data structuresand the code that manipulates those structures to maximum advantage, nor takeadvantage of the vast number of potential optimizations as flexibly as youcan.andP;  (Space forbids even a partial listing of optimization techniques forthe 8Ox86 family: The list is astonishingly long and varied.andP;  See TimPaterson's article in this issue for a small but potent sample.) When itcomes to integrating all the information about a particular aspect of aprogram and implementing the code as efficiently as possible given thecapabilities of a particular processor, it's not even close: Humans are muchbetter optimizers than compilers are.andM;Almost any processor can benefit from hand-tuned assembly language, butassembly language lives most vibrantly in the 80x86 family.andP;  The 80x86instruction set is irregular; the register set is small, with most registersdedicated to specific purposes; segments complicate everything; and theprefetching nature of the 8Ox86 renders actual execution timenon-quantifiable - and optimization at best an art and at worst black magic -making the 80x86 family a nightmare for optimizing-compiler writers.andP;  Thequirky (and highly assembly language amenable) instructions of the 8086 liveon in the latest 80x86-family processors, the 80386 and 80486, and willundoubtedly do the same for many generations to come.andP;  Other processors maylend themselves better to compilers, but the 8Ox86 family is and always willbe a wonderland for assembly language.andM;Consider this: Well-written assembly language provides a 50 to 300 percentboost in performance over compiled code (more sometimes, less others, butthat's a conservative range).andP;  An 8-MHz AT is about three times faster than aPC, a 16-MHz 80386 machine is about twice as fast as an AT, and a 25-MHz80386 is about three times as fast as an AT.andP;  There are a lot of PCs and ATsout there - 20 to 30 million, I'd guess - and there is a horde of userscontemplating the expenditure of thousands of dollars to upgrade.andM;Now consider this.andP;  Those users don't have to upgrade they just need to buybetter-written software.andP;  The performance boost good assembly languageprovides is about the same as stepping up to the next hardware platform, butthe assembly language route is one heck of a lot cheaper.andM;In other words, better software can eliminate the need for expensivehardware, giving the developer the opportunity to realize a healthy profitfor his extra development efforts.andP;  just as important is the fact that goodassembly language runs perfectly well on slower computers, making the marketfor such software considerably larger than the market for average software.andO;if you make your software snappy on an 8088, your potential market doublesinstantly and the competition thins.andM;Finally, it's on the slower computers - the PC and AT -that assembly languageoptimization has the most effect (see the example later in this article), andthat's precisely where improved performance is most needed.andM;Enter the UserandM;So assembly language produces the best code.andP;  What of it? If high-levellanguages make it easier and faster to create programs, who cares if thoseprograms are slower?andM;The user, that's who.andP;  Users care about perceived performance - how well aprogram seems to run.andP;  Perceived performance includes lack of bugs, ease ofuse, and, right at the top of the list, responsiveness.andP;  Hand users awhizbang program that makes them wait at frequent intervals, and they'llleave it on the shelf after trying it once.andP;  Give users a program that nevergets in their way, and they may love it without ever knowing quite why.andP;  Inthese days of all-too-sluggish graphical interfaces, the performance issue iscentral to the usability of almost every program.andM;What users don't care about is how a program was made.andP;  Do you care how yourcar was designed? You care that it's safe, that it's reliable, and that itperforms adequately, but you certainly don't care whether the manufacturerused just-in-time manufacturing, or whether mainframe or microcomputer CADwas used in the design process.andP;  Likewise, users don't care whether aprogrammer used OOP or C or Pascal, or COBOL, for that matter; they care thata program does what they need and performs responsively.andP;  That's not purely amatter of speed, but without speed the user will never be fully satisfied.andO;And when it comes to speed, assembly language is king.andM;Use Only as DirectedandM;When you need it, there's no substitute for assembly language, but it can bea drag when you don't need it - so know when to use it.andP;  Humans are betterlarge-scale designers and small-scale optimizers than compilers, but they'renot very good at the grunt work of compiling, such as setting up stackframes, handling 32-bit values, allocating and accessing automatic variables,and the like.andP;  Moreover, humans are much slower at generating code, so it's agood idea to avoid being a &quot;human compiler.&quot; Some people create complexmacros and assembly language programming conventions and do all theirprogramming in assembly language.andP;  That works - but what those macros andconventions do is make assembly language function much like a high-levellanguage, so there's no great benefit, especially given that you can dropinto assembly language from a high-level language at any time just by callingan assembly language subroutine (or, better yet, by using in-line assemblylanguage in a compiler that offers that feature, such as Turbo C).andP;  Unlessyou're a masochist, let your favorite compiler do what it's best at -compiling - and save assembly language for those small, well-defined portionsof your software where your efforts and unique skills pay off handsomely.andM;A relevant point is that assembly language alone is not the path toperformance.andP;  If you have a program that takes as long as a second to updatethe screen, you have problems that assembly language alone won't solve:Proper overall design and algorithm selection are also essential.andP;  However,most software designers consider the job done when the design and algorithmphases are complete, leaving the low-level optimization to the compiler.andP;  Irepeat: No compiler can match a good assembly language programmer atlow-level optimization.andP;  Given the irregular nature of the 8Ox86 family andthe huge PC software market, it's well worth the time required tohand-optimize the few critical portions that control perceived performance.andO;Only in assembly language can you take full responsibility for theperformance of your code.andM;Don't Spit into the WindandM;While I can't offer a cut-and-dried dictum on when to use assembly language,the practice of using it when the user would notice if you didn't is a goodrule of thumb.andP;  While some programmers would take this rule too far and useassembly language too often, the vast majority of programmers will lean overbackwards the other way, in the face of all evidence to the contrary.andP;  HalHardenberg's late, lamented DTACK Grounded reveled in the folly of the ATandamp;Tprogrammers who implemented the floating-point routines for a super-micro inC rather than assembly language with the result that the computer performedfloating-point arithmetic not quite so fast as a Commodore VIC-20 !andO;Likewise, I once wrote an article in which I measured the performance of anassembly-language line-drawing implementation at four to five times that ofan equivalent C implementation.andP;  One reader rewrote the C code for greaterefficiency, ran it through Microsoft C rather than Turbo C, and wrote toinform me that I had shortchanged C; assembly language was actually &quot;only&quot; 70percent faster than C. As it happens, the assembly-language code wasn't fullyoptimized, but that's not the important point: What really matters is thatwhen programmers go out of their way to produce code that's nearly twice asslow (and in an important user-interface component, no less) in order to usea high-level language rather than assembly language, it's the user who'sgetting shortchanged.andP;  Commercial developers in particular can't afford toignore this, and I suspect that most such developers are DDJ readers.andP;  Ifyou're aiming to sell hundreds of thousands of copies of a program, you'reguaranteed to have stiff competition.andP;  If you don't go the extra mile toprovide snappy response, someone else will -and you'll be left out in thecold.andM;On the other hand, assembly language code is harder and slower to write, andpays off only in the few most critical portions of any program.andP;  There arelimits to the levels of complexity humans can handle in assembly language,and limits to the development time that can be taken before a product mustcome to market.andP;  identify the parts of your programs that significantlyaffect the performance perceived by the user (a code profiler can helpgreatly here), and focus your efforts on that code, with especially closeattention to oft-repeated loops.andM;80x86 Assembly Language in ActionandM;Enough talk.andP;  Let's look at an example of assembly language in action.andO;Listing One, page 94, shows a C subroutine, CopyUppercase, that copies thecontents of one far zero-terminated string to another far zero-terminatedstring, converting all lowercase characters to uppercase in the process.andP;  Thesubroutine consists of a single, extremely compact loop that should be idealfor compiler optimization.andP;  In fact, I organized the loop for the bestresults with Microsoft C 5.0, the test compiler, and used the intermediatevariable UpperSourceTemp in order to allow for more efficient compiled code.andO;There may be a more efficient way to code this subroutine, but if you'regoing to go to the trouble of being compiler-specific and knowing compilercode generation that intimately, why not use assembly language, whichprovides direct control and gives you the freedom to create the best possiblecode? Microsoft C 5.0 generates the code shown in Figure I from the versionof CopyUppercase in Listing One when maximum optimization is selected withthe /Ox switch.andP;  It's not bad code, but neither is it great.andP;  The farpointers are stored in memory and must be loaded each time through the loop,and a considerable amount of work is expended on determining whether eachcharacter is uppercase, although the case check is done with a table look-up,which is generally one of the most desirable 80x86 programming techniques.andP;  Aserious failing is that none of the 8Ox86 family's best instructions - thestring instructions are used.andP;  The upshot is that Listing One runs in thetimes listed in Figure 2 on various PC-compatible computers.andP;  (All timesdiscussed in this article were measured with the Zen timer described in mybook Zen of Assembly Language, from Scott, Foresman andamp; Company, modifiedslightly to work with Microsoft C.)andM;Can we do better in assembly language? indeed we can, as Listing Two, whichreplaces the C version of CopyUppercase in Listing One with an assemblylanguage version, illustrates.andP;  Listing Two simply keeps both far pointers inregisters and uses string instructions to access both strings; the return forthe 21 assembly-language instructions that do that is a performanceimprovement ranging from two to three-plus times, as shown in Figure 2.andP;  Ifthis code happens to be in a performance-sensitive portion of a program,that's quite a return for a little assembly language.andM;Now, you may well think that the above example is biased in favor of assemblylanguage, what with the far pointers, which assembly language tends to handlemuch better than do compilers.andP;  I would disagree: Almost every PC program nowtakes advantage of the full 640K of memory, and most of that memory must beaccessed via far pointers, so access to far data is a most important issue toPC developers, and the ability of assembly language to handle far data justabout as fast as near data is a substantial point in favor of assemblylanguage.andP;  In fact, this example is representative of a large class ofproblems developers face, involving data copying, data transformation, datachecking, pointers, and segments.andP;  Nonetheless, let's see what happens if wealter CopyUppercase to use near pointers.andM;Listing Three (page 94) shows Listing One changed to use near pointers.andO;Listing Three, which generates the code shown in Figure 3, is indeed muchfaster than Listing One; it still takes at least half again as long asListing Two, but it's closing the gap.andP;  By contrast, Listing Two wouldn'tmuch benefit from near pointers, because it already keeps the pointers in theregisters.andP;  Does that mean that for near data C almost matches assemblylanguage?andM;Not a chance.andP;  We haven't optimized the assembly language implementation yet;Listing Two is just a straight port of Listing One from C to assemblylanguage.andP;  Listing Four shows Listing Two converted to use near pointers,plus a couple of twists.andP;  First, two bytes are loaded, converted touppercase, and stored at once, cutting the number of memory-accessinginstructions in half.andP;  Second, the value used to convert characters touppercase and the upper- and lowercase bounds are stored in registers outsidethe loop, so that they can be used more efficiently inside the loop.andP;  Theseare simple optimizations, but ones that I doubt you'll find a compiler using- and they're highly effective.andP;  As Figure 2 indicates, Listing Four isapproximately 20 percent faster than Listing Two and about two times fasterthan the near C implementation of Listing Three.andM;We're not done optimizing yet, though.andP;  We've focused so far on relativelysimple, linear optimization.andP;  Let's pull out all the stops, throw someunorthodox techniques at the problem, and see what comes of it.andM;On most PC compatibles, the key is this: The processor is slow at fetchinginstruction bytes and branching (in fact, all 80x86 processors are relativelyslow at branching).andP;  if we can keep one or the other of those aspects fromdragging the processor down, we can often improve performance considerably.andO;As it happens, we can attack both bottlenecks.andP;  Look-up tables shrink codesize, thereby easing the instruction fetching problem, and avoid branches aswell.andP;  Well then, why not simply look up the uppercase version of eachcharacter? While we're at it, why not look it up with the remarkably compactand efficient xlat instruction? In this way we can convert the fiveinstructions used to convert to uppercase in Listing Four to a single xlat.andO;We can also improve performance by repeating multiple instances of thecontents of the loop in-line, one after the other; doing this allowsvirtually all of the conditional jumps to fall through, eliminating branchingalmost entirely.andP;  Both changes appear in Listing Five, page 94.andP;  As Figure 2indicates, those two changes improve performance by 8 to 40 percent - and theimprovement is greatest on the slower 8088 and 80286 machines, which issurely where speed matters most.andP;  (Nor is this code maxed out even yet; Isimply had to draw the line somewhere in the interests of keeping the codereadily comprehensible and this article to a reasonable length.andP;  For example,we could use lodsw to speed up Listing Five much as we did in Listing Four.andO;Never assume that your code is fully optimized!)andM;Bear in mind, too, that the code in Listing Five can handle far pointers aseasily as near if the look-up table is moved into the code or stack segmentand accessed with a segment override, a change that would scarcely affectperformance at all.andP;  When it comes to handling far strings, then, we'veimproved performance by three to five and one-half times.andP;  To put that inperspective, the performance improvement gained by running the original Ccode on a 20-MHz zero-wait-state 32K-cache 80386 computer rather than arun-of-the-mill 10-MHz one-wait-state 80286 computer was only a little overthree times.andP;  I think it's obvious which is the cheaper solution to improvingperformance.andM;(It's worth noting that carefully crafted assembly language was required toproduce the massive performance improvement measured earlier.andP;  Assemblylanguage by itself guarantees nothing, and bad assembly language, which iseasy to write, brings new meaning to the word bad.)andM;Don't think I've picked an example that stacks the deck in favor of assemblylanguage.andP;  in fact, assembly language would do considerably better if weworked with arrays or fixed-length Pascal-style strings, and would do betterthan compiled code in cases where there were more variables to keep in theregisters.andP;  We also weren't able to use repeated string instructions in theearlier example; when such instructions can be used, as is often the casewhen an entire program's data structures are organized with efficientassembly language code in mind, the performance advantage of assemblylanguage can approach an order of magnitude.andP;  in short, we looked at asimple, limited example (and actually one that lends itself relatively wellto compiler optimization), and in optimizing it we've scarcely begun to tapthe treasure trove of assembly-language tools and techniques.andM;Yes, compiler library functions can use string instructions and otherassembly-language tricks as readily as your own assembly language code can,but there's a great deal that library functions can't do.andP;  Don't assume thatlibrary functions are well written, either - some are, but many aren't.andP;  Andremember that the author of the library knows no more than the author of thecompiler about when you most need performance, and so must design code foradequate performance under all circumstances.andP;  You, on the other hand, canprecision-craft your code for best performance exactly when and where youneed it.andP;  Also, keep in mind that library functions can work only within thecurrent model.andP;  When you're working with data on the far heap in a programcompiled with the small model  ;tn efficient arrangement for programs thatmust handle a great deal of data), library functions can't help you.andM;Finally, Microsoft C is a very good optimizing compiler, considerably betterthan most of the compilers out there.andP;  There are a few compilers thatgenerate somewhat better code than Microsoft C, but I'm willing to bet thatmost of the C programmers reading this use either Microsoft or Turbo C.andO;(Turbo C did not match Microsoft C on this particular example, so I usedMicrosoft C in order to give C every advantage.) The C code was written toallow for maximum optimization (the loop is only four lines long, forgoodness' sake) and uses a macro - not a function call - that expands to atable look up.andP;  In other words, the cream of the C crop, given readilyoptimized code and using a look-up table, went head-to-head with a few dozenhand-optimized assembly-language lines - and proved to be about two to fivetimes slower.andM;Size Matters TooandM;I've focused on performance so far because the primary use of assemblylanguage lies in making software faster.andP;  Assembly language can make for farmore compact programs as well, although that's less often important becausethe PC has a large amount of memory available relative to processing powerand because saving space is a diffuse effort, requiring attention throughoutthe program, while enhancing performance is a localized phenomenon, and sooffers a better return on programming time.andM;There are cases where program size is crucial - memory-resident programs,device drivers, utilities, for example and assembly language can workwonders.andP;  of course, good assembly language code is very tight, and hencevery small, but there's more to it than that.andP;  It's easy to drive programswith compact data strings in assembly language (see &quot;Roll your OwnMinilanguages with Mini-Interpreters&quot; which I co-authored with Dan Illowsky,DDJ, September 1989).andP;  It's also easy to map in code sections from disk asneeded; assembly language can be far more flexible than any overlay manager.andO;Finally, assembly language eliminates the need for non-essential start-up andlibrary code.andP;  Co-workers tell me of the time they needed to distribute aprogram to accept a keypress from the user and return a corresponding errorlevel to a batch file.andP;  Written in C, the program was 8K in size;unfortunately, the distribution disk didn't have that much free space.andO;Rewritten in assembly language, the same program was a mere 50 bytes long.andM;When you absolutely, positively need to keep program size to a minimum,assembly language is the way to go.andP;  Can Live with It, Can't Live without itAssembly language isn't the be-all and end-all of PC programming, but it isthe only game in town when either performance or program size is paramount.andO;Assembly language should be used only when needed and, used wisely, offersunparalleled code quality and an excellent return for programming timeinvested.andM;For all the drawbacks of assembly language,  eight-plus years of PC softwaredevelopment have proven that developers can live with it; programs containingassembly language have been written in an expeditious manner and work verywell, indeed.andP;  Those same years have shown that developers can't afford tolive without assembly language.andP;  I suspect you'd be hard pressed to find anyimportant PC software that contains no assembly language  It all, and I canassure you that any application with a graphical user interface eithercontains assembly language or is a dog.andP;  (Sure, Windows applications andapplications that link in third-party libraries may not contain assemblylanguage, but that's because they've passed that responsibility off to otherdevelopers.andP;  And just who are those developers? DDJ readers, that's who.andO;Somebody has to create the good code that top-notch software requires.)andM;For all the wishing, 8Ox86 assembly language isn't going away soon; in fact,it's not going to go away at all.andP;  The 8ox86 architecture lends itselfbeautifully to assembly language, and performance will always be at apremium, no matter how fast processors get.andP;  Back, when I used a PC, Ithought if I had a computer that was ten times faster, all my software wouldrun so fast that I'd never have to wait.andP;  Well, now I use just such acomputer, and much of the software I use is faster as well  (MASM, forexample, is about ten times faster than it used to be, and TASM is evenfaster) - and still I spend a lot of time waiting.andP;  Software is never fastenough, and better software is one heck of a lot cheaper than betterhardware.andM;AvailabilityandM;All source code is available on a single disk and online.andP;  To order the disk,send $14.95 (Calif.andP;  residents add sales tax) to Dr. Dobb's journal, 501Galveston Dr., Redwood City, CA 94063, or call 800-356-2002 (from insideCalif.) or 800-5334372 (from outside Calif.).andP;  Please specify the issuenumber and format (MS-DOS, Macintosh, Kaypro).andP;  Source code is also availableonline through the DDJ Forum on CompuServ (type GO DDJ).andP;  The DDJ ListingService (603-8821599) supports 300/1200/2400 baud, 8-data bits, no parity,1-stop bit.andP;  Press SPACEBAR when the system answers, type: listings(lowercase) at the log-in prompt.andM;Figure 1: The code generated for CopyUppercase by Microsoft C5.0 when ListingOne is compiled with the /OX switch (maximum optimization)andM;_CopyUppercase                     proc              nearandM;push                     bpandM;mov                      bp,spandM;sub                      sp,0002andM;Label1:andM;les                      bx,[bp+08]andM;mov                      cl,es:[bx]andM;inc                      word ptr [bp+08]andM;mov                      ax,cxandM;cbwandM;mov                      bx,axandM;test                     byte ptr [bx+0115],02andM;je                       Label2andM;mov                      ax,cxandM;sub                      al,20andM;imp                      Label3andM;Label2:andM;mov                      ax,cxandM;Label3:andM;les                      bx,[bp+04]andM;mov                      es:[bx],a]andM;inc                      word ptr [bp+04]andM;or                       cl,clandM;jne                      Label1andM;mov                      [bp-02],clandM;mov                      sp,bpandM;POP                      bpandM;retandM;_CopyUppercase                     proc              nearandM;Figure 2.andP;  The execution times of the various C and assembly languageimplementations of CopyUppercase shown in Listings One through Five.andP;  For agiven listing running on a given processor, the number in parenthesesrepresents the performance of that listing relative to the performance ofListing One on that processor; the higher the value, the better theperformance, 8088 timings were performed on a n IBM XT; 80286 timings wereperformed on a 10-MHZ one-wait-state AT clone; and 80386 timings wereperformed on a 20-MHz zero-wait-state 32K-cache Toshiba T5200andM;(Figure/Table not included)andM;Figure3.- The code generated for CopyUppercase by Microsoft C5.0 when Listingthree is compiled with the /OX switch (maximum optimization)andM;_CopyUppercase                        proc               nearandM;push                       bpandM;mov                        bp,spandM;sub                        sp,0002andM;push                       diandM;push                       siandM;mov                        di,[bp+04]andM;mov                        si,[bp+06]andM;Label1:andM;mov                        cl,[si]andM;inc                        siandM;mov                        ax,cxandM;cbwandM;mov                        bx,axandM;test                       byte ptr [bx+0115],02andM;je                         Label2andM;mov                        ax,cxandM;sub                        al,20andM;imp                        Label3andM;nopandM;Label2:andM;mov                        ax,cxandM;Label3:andM;mov                        [di],alandM;inc                        diandM;or                         cl,clandM;jne                        Label4andM;mov                        [bp+04],diandM;mov                        [bp+06],siandM;mov                        [bp-02],clandM;POP                        siandM;POP                        diandM;mov                        sp,bpandM;POP                        bpandM;retandM;_CopyUppercase                        proc               near</TEXT></DOC>