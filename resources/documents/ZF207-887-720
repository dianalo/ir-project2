<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-887-720  </DOCNO><DOCID>07 887 720.andM;</DOCID><JOURNAL>Government Computer News  Nov 13 1989 v8 n23 p59(3)* Full Text COPYRIGHT Ziff-Davis Pub. Co. 1989.andM;</JOURNAL><TITLE>SQL on micros: charting new paths through the wilderness of data.andO;(buyers guide)</TITLE><AUTHOR>Stephenson, Peter.andM;</AUTHOR><SUMMARY>Structured Query Language (SQL), originally developed for databasemanagement systems (DBMS) on IBM mainframes, is not a programminglanguage but rather a procedural language used in applications.andO;In a procedural environment, there are three main approaches toSQL: embedded SQL, invisible or seamless SQL and function-levelSQL.andP;  Embedded SQL may be static or dynamic.andP;  Static SQL isembedded in a procedural language and dynamic is not.andP;  SeamlessSQL, used in Ashton-Tate's dBase IV SQL/Server and Oracle Corp'sOracle dBXL, translates a host-language command into a near-SQLcommand.andP;  Seamless SQL is simple, but suffers from degradedperformance and limited compliance with the complete SQL commandset.andP;  The best approach, function-level SQL, is only available ina combination of Gupta Technologies Inc's SQLBase, PlanetSoftware's Library for Clipper and Nantucket Corp's Clipper dBasecompiler.andM;</SUMMARY><DESCRIPT>Product:   SQLBase (Data base management system) (usage)The Library for Clipper (Program development software) (usage)Clipper (Program development software) (usage)Oracle DBXL (Data base management system) (design andconstruction)dBASE IV (Data base management system) (design and construction)SQL Server (Data base management system) (design andconstruction).andO;Topic:     Structured Query LanguageDirectoriesData Base Management SystemsSoftware ModificationSoftware DesignMicrocomputersCompatible Software.andO;Feature:   illustrationtable.andO;Caption:   SQL products for MS-DOS, UNIX, OS/2. (table)andM;</DESCRIPT><TEXT>SQL on MicrosandM;The course of database management history began to change in the late 1980swith the spread of PC networks and Structured Query Language.andM;At first, PC database managers for networks were little more than single-usersystems modified to keep multiple users from colliding.andP;  Such databasemanagement system file servers still constitute most of the network products.andM;As new software companies like Microrim Inc. and Ashton-Tate Corp. struggledto bring their products into the multiuser world, companies that already hadsolved the multiuser puzzle on larger platforms rushed to port their DBMSsoftware to PCs.andM;Some bypassed MS-DOS altogether and stayed with the larger platforms.andP;  OracleCorp., for example, moved directly into Xenix and OS/2.andP;  Others, like GuptaTechnologies Inc., introduced an early MS-DOS version.andM;The one thing they all had in common was SQL, borrowed from the IBM Corp.andO;mainframe world.andM;Building on older distributed processing techniques, several companiesevolved a client-server technology that let the database server back endmanipulate the database while the front end application handled userinteractions.andP;  That development drew a distinct line between file-server anddatabase-server DBMS.andM;The older-generation DBMS such as dBase III Plus are file server products, inwhich the file server acts like an extension of the hard drive in asingle-user system.andP;  It does no processing but merely holds data andapplication files.andM;Duelling UpdatesandM;When the user invokes such a DBMS, the server downloads the executableprogram to the network station's memory.andP;  The program gets data files orindexes from the server disk just as it would if the disk were local to theworkstation.andM;But this is a poor approach on a network, for three reasons.andP;  The firstreason is data integrity, the second is concurrency control and the third isperformance.andM;Databases get contaminated too easily when the data resides away from thenetwork station and several users can access it at the same time.andM;For example, suppose a database allows duplicates of individual data files orportions of files.andP;  That means data in one file can be updated withoutaffecting the duplicates.andP;  Also, a power failure at some but not all of theterminals can easily scramble records.andM;Data integrity problems also arise when an index does not undergo updatingalong with the database file to which it is attached.andP;  In fact, suchnon-matching of indexes and databases is the definition of data integrityloss.andM;Many true SQL DBMS and most file server systems do not support referentialintegrity, which means the ability to preserve data integrity when an indexrefers to a data table based on a common, but foreign, key.andP;  Lack of supportfor referential integrity can cause serious trouble during complex queries.andM;Problems with the second category, concurrency control, arguably are theworst of the three.andM;Concurrency control means one user can access the same record at the sametime as other users without getting in anyone's way.andM;Multiuser DBMS software encounters three types of concurrency controlproblems when several people attempt to use the same data at the same time.andM;The first and most common situation is two users trying to update the samerecord simultaneously.andP;  The first person retrieves the record and reads orbrowses it.andP;  A short time later, the second person retrieves the same record,which the first person has not yet returned.andP;  Now the first user, unawarethat someone else also has the record, updates and returns it to thedatabase.andP;  Then the second person does the same thing, overwriting the firstupdate.andM;Obviously, the DBMS should not accept the second update.andP;  It should recognizemultiple updates to the same record and reject all but the first untilsubsequent users have had a chance to view that updated record.andM;The next two concurrency control problems arise partly from a distributedtechnique called commit and rollback.andM;All updates essentially are individual transactions.andP;  Each transactionprogresses to a point where it alters a record in a table.andP;  At that point, ifeither the application or the user proceeds with the update, the transactionis said to have been committed.andP;  If for some reason the user or applicationdoes not commit the transaction, it can be backed out, or rolled back.andM;Commit and rollback lead to concurrency problems in this way: If atransaction retrieves a record that has been updated but not yet committed,the transaction will not be current even though users may think it is.andM;This actually is a variation on the first problem, the difference being thatthe second case is under control of the program, not the user.andP;  But it issomewhat worse than the first case, because users have no way of knowingabout or controlling the events that corrupted the data.andM;The solution here obviously borrows from the solution to the first case.andP;  TheDBMS must not accept subsequent updates until after a commit or rollback hasoccurred and users are aware of the record's status.andM;The last type of concurrency control problem occurs when someone reads arecord or performs an operation on several records while they are beingupdated, although the changes have not yet been committed.andM;Tables TurnandM;For example, a user performs a relational operation on several tables thatwill be a temporary result table.andP;  Then, without the user's knowledge, one ofthe tables being used is updated.andM;The results naturally are incorrect because the changes should have causednew data to appear.andP;  The solution here is not to accept any operation while arecord is being updated.andM;Because file server databases use file and record locking to prevent suchanomalies, they encounter the third problem of networked DBMS -- performancedegradation.andP;  File and record locking avoid concurrency problems by takingthe ambiguous records out of circulation during a questionable update orquery.andP;  Unfortunately, this brute-force locking slows things down.andM;Consider a situation in which a networked user locks a record to update it.andO;As he types in the new data, the phone rings or some other interruptioncauses him to forget the record is waiting.andM;It might remain locked, unavailable to all other network users, for minutesor even hours.andM;Avoidance techniques to prevent this will slow down performance, partlybecause of bottlenecks at the network drives and partly because users have tokeep trying to access temporarily locked records and files.andM;Database server systems, on the other hand, have several ways to prevent dataintegrity and concurrency control problems without degrading performance toomuch.andM;The server, not the network station, controls database manipulations.andO;Although such control is under the direction of the front-end application,actual control is a back-end function.andM;Furthermore, the individual user need not know where data is stored.andP;  As longas the server knows where the data is, there will be no integrity problemsfrom wrong indexes, duplicate data or other errors that occur with multipledata locations on a file-server DBMS.andM;In order for networked DBMS products to access a variety of data, there mustbe some standardization.andP;  If DBMS product A is to access data in a tablecreated by DBMS product B, the two tables had better be consistent.andM;Consistency comes from two sources.andP;  The first is consistent use of therelational model; the second is SQL as a query language.andP;  The two go togetherbecause SQL originally began as a query language to support the relationalmodel.andM;Wholesome to the CoreandM;SQL consists of a core of American National Standards Institute commands orstatements along with the additions of developers who have created their ownSQL dialects.andP;  A good SQL DBMS should support at least the ANSI corestatements and clauses.andM;Although many file-server databases claim to use SQL, most do not takeadvantage of the query language's full power.andP;  They cannot connect SQL withthe relational database model and the client-server architecture.andM;Simply being able to issue an SQL command does not mean very much.andP;  Forexample, applying the SQL portion of dBase IV to non-SQL tables gains littleover using standard dBase IV commands.andP;  The reason, besides the fact thatdBase IV's SQL has bugs in Release 1.0, is that the system must translatebetween dBase and SQL.andM;SQL is not a programming language but rather a procedural language useful inapplications.andP;  Because there are several dialects of SQL, users have to becareful about putting SQL in an application.andM;There are three main approaches to SQL in a procedural environment.andP;  Thefirst is embedded SQL.andP;  The second is so-called invisible or seamless SQL.andO;The third is function-level SQL.andM;Embedded SQL may be either static or dynamic.andP;  Static SQL is embedded in theprocedural language; dynamic SQL is not.andP;  Dynamic SQL usually results whenthe user writes an SQL statement.andM;Many of today's SQL DBMS products use dynamic SQL or something like it intheir query-by-example interfaces.andP;  They feature a menu selection ofEnglish-like phrases, which in turn build up an SQL command line forcompilation and execution.andP;  Thus the user need not know much about SQLcommands to create a query.andM;Embedded static SQL is a bit more difficult.andP;  A programmer puts an actual SQLcommand in a procedural language such as C or COBOL.andP;  The command executes asif it were a dynamic query entered from the command line.andP;  In some cases, theprocedural program must add its 2 cents' worth before the data can beretrieved.andM;Some languages cannot handle such record-level queries.andP;  So there must be away for SQL to grab data from a single table instead of at the file level.andO;This mechanism is called a cursor, or pointer, within a data file.andP;  It letsthe SQL query pick out a particular row of data within a table and return itfor the host program to process.andM;The second way of executing SQL queries from an application, called invisibleor seamless SQL, appears in Oracle dBXL and Ashton-Tate dBase IV/SQL Server.andO;It translates a host-language command into a near-SQL command.andP;  Although SQLcommands can be embedded in dBase IV procedures, the seamless approach ispopular for its simplicity.andM;Costly SimplicityandM;Of course, simplicity comes at a price.andP;  The price in this case is reducedperformance and limited compliance with the complete SQL command set.andP;  DBasecommands, for example, do not translate directly into SQL commands.andP;  So adBase procedure simulates an SQL command, but takes long to execute than itwould if the actual SQL command were embedded in the procedure.andM;The best approach by many accounts is the function call.andP;  The only example ofit combines Gupta Technologies' SQLBase with Library for Clipper from PlanetSoftware and Nantucket Corp.'s Clipper dBase compiler.andP;  Here is how it works.andM;A programmer builds the front-end application in the Clipper dialect ofdBase, using a Library function for SQL queries.andP;  The function then addressesthe application programming interface of SQLBase and performans the queries.andM;There is no translation as in seamless SQL, and no need to optimize the SQLqueries as with embedded SQL.andP;  Experienced Clipper programmers find theprocedure fast, direct and easy.andM;It produces a dBase front end to a true client-server back end.andP;  That means auser with a library of Clipper-compiled dBase applications could, with alittle effort, translate them into dBase language front ends for a powerfuldistributed system.andM;Why do that?andP;  First, although SQL itself does not achieve too much, theclient-server model can do a lot.andP;  Performance is excellent due tocooperative processing -- the front end does application work while the backend does database work.andP;  And dBase data handling is less efficient on anetwork than with this client-server system.andM;The second reason is data integrity.andP;  In a large system, the client-servermodel handles data and indexes much better than the file server model.andM;Still another reason to consider a client-server systems is the need to storedata in more than one location.andM;How can buyers decide which breed of database is right for them?andP;  Once theydecide, how should they make the transition?andP;  Not everyone wants to scrap anold DBMS and run out to buy the latest.andP;  Like virtually every other computingproduct, database managers stand a good chance of becoming obsolete almost assoon as they are introduced.andM;Some factors that strongly imply the need for a client-server SQL systeminclude a large local area network, large databases and data in severallocations.andP;  Under those circumstances, performance will improve dramaticallywith client-server SQL.andM;Those who need to access data on mainframes or minicomputers may want to goto a true distributed system instead.andM;Skirting MinisandM;Most micro DBMS cannot get a data on a mini without translating the data intosomething the micro understands.andP;  The usual way is to download the data as anASCII file -- no trivial task with large databases.andP;  And no matter what,there will have to be a series of intermediate steps to get the data into themicro DBMS.andP;  This all takes time and limits performance.andM;With the right SQL DBMS, however, users may be able to access data on largerplatforms directly.andP;  Oracle and SQLBase, for example, access minicomputer DB2data directly.andM;Making the transition to the new DBMS can be tricky.andP;  The datea is the easypart; most SQL products have utilities to translate data into SQL tables.andO;Then applications must be modified to use the data.andM;Remember, SQL by itself does not necessarily improve performance.andP;  Thebenefits actually come from the system architecture of many SQL systems.andO;There are three choices today and a few more to come in the future.andM;Today's choices are dBase IV, Oracle Quicksilver or the previously mentionedcombination of Gupta's SQLBase with Nantucket's Clipper and Planet's Libraryfor Clipper.andM;DBase IV Release 1.0, although an easy choice, is not really a good one.andO;Older dBase applications will run virtually as is, with minor modificationsfor SQL tables instead of DBF files.andM;But this is file server technology.andP;  Small or widely distributed databasesmay actually show poorer performance.andM;Oracle Quicksilver is a good choice if an OS/2 or Xenix machine is availableas a database server.andP;  Oracle Quicksilver will compile dBase applications,again with little or no alteration, and translate DBF files into Oracletables.andM;Although Oracle does not have a true client-server architecture, it bringsthe benefits of distributed database technology.andP;  Performance will be betterthan with dBase IV.andP;  Translating applications is simple if not effortless,and performance is quite good.andM;However, the best choice at present may be the Gupta/Clipper/Planet combo.andO;It is a bit more work to use but has some distinct advantages.andP;  First, unlikethe situation with Oracle, the SQLBase database server can be an MS-DOSmachine.andM;Gupta's SQLBase does not require upgrading the network operating systemmerely to accommodate a database server.andP;  For those who want to upgradelater, the switch is virtually seamless; SQLBase is portable across MS-DOSand OS/2.andM;The second benefit comes in performance.andP;  SQLBase is a real client-serversystem with cooperative rather than distributed processing.andP;  Performance farexceeds any other method because the Clipper/Planet combination lets thedBase front-end application address the SQLBase database engine at theapplication programming interface, instead of translating dBase commands intoSQL statements as in the Oracle product.andM;The downside of the SQLBase approach is that dBase applications must bealtered to use the Planet functions.andP;  That is not particularly difficult forClipper programmers, but it does take time and effort.andP;  The results, however,are worth it because the final product takes full advantage of theclient-server technology as well as SQL.andP;  SQLBase also can access externaldatabases such as DB2.andM;Of course, dBase users will have more options in the future.andP;  The comingrelease of dBase IV for SQL Server promises direct conversion between the oldand the new.andP;  Other database companies are developing ways to make theirapplications into front ends for SQL Server.andM;Why have database giants like Ashton-Tate had such a difficult time makingthe transition from the old to the new?andP;  Obviously there is much more to theSQL database than simply storing and retrieving data in a different way.andM;The distributed, cooperative and client-server models are quite complex.andM;Manipulating large distributed databases both safely and efficiently is agargantuan task compared with data handling on a single PC.andM;Another problem is upward compatibility.andP;  Large groups of users insist upon areasonable migration path for their applications and data.andP;  Because ofdifferences in system architecture, this may be the greatest challenge ofall.andM;The real issues are in database management, not in applications.andP;  DBasearguably is the most-used programming language in the world and, for the nearterm, promises to stay that way.andP;  The smart money today is on makingyesterday's applications talk to tomorrow's data on tomorrow's networks.andM;In the longer term, it will be a free-for-all as developers strive for newways to handle data in an ever-expanding network environment.andM;Peter Stephenson is a free-lance writer for computer publications.andO;</TEXT></DOC>