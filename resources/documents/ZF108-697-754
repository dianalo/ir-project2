<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-697-754  </DOCNO><DOCID>08 697 754.andM;</DOCID><JOURNAL>Dr. Dobb's Journal  August 1990 v15 n8 p149(8)* Full Text COPYRIGHT Mandamp;T Publishing 1990.andM;</JOURNAL><TITLE>The past, the future, and multi-mania. (trends in C programminglanguage development and utilization; the use of the NetWare CInterface-DOS package) (column)</TITLE><AUTHOR>Stevens, Al.andM;</AUTHOR><SUMMARY>An overview of major recent events and trends in the C programminglanguage, projected trends in C programming and the functioning ofthe NetWare C Interface-DOS software package are discussed.andP;  Majorrecent events in the advancement of C was the advent of a standardANSI C specification and the explosion of interest in theobject-oriented C++ programming language.andP;  The programming of Capplications for MS-DOS-based workstations on NetWare-based localarea networks will be a major focus of C programmers for the nextseveral years.andP;  This requires understanding the multiuser andmultitasking aspects of the network environment and tools thatsupport it.andP;  One such tool is the NetWare C Interface-DOS package,which offers a library of C functions to make extended MS-DOScalls to enable an application to manipulate the functions of aNetWare network.andP;  NetWare programming is discussed at length.andM;</SUMMARY><DESCRIPT>Company:   Novell Inc. (products).andO;Ticker:    NOVL.andO;Product:   NetWare (Network operating system) (design and construction)NetWare C Interface for DOS (Program development software)(usage).andO;Topic:     C Programming LanguageTrendsProduct DevelopmentNetwork Operating SystemsInterfaceOutlookMS-DOSSpecificationsUtilization.andM;</DESCRIPT><TEXT>The Past, the Future, and Multi-maniaandM;The annual C issue is a special one to me.andP;  Besides being devoted to C, theissue is also my anniversary with DDJ as the C columnist.andP;  August 1990 startsmy third year, and marks the time for a retrospective view of the past twoyears.andP;  A lot has happened.andP;  In that time we watched C strengthen itsposition as the preeminent software development language.andP;  The majormilestone in the advancement of C was the approval by ANSI of the standarddefinition early this year.andP;  It was a long time coming.andP;  Second place goes tothe gradual swell and then sudden explosion of interest in and use of C++.andM;Other milestones.andP;  The Integrated Development Environment established itselfas the preferred way to write and test C code.andP;  Source-level debuggers gotbigger and better.andP;  Developers of operating environments began producingApplications Program Interface libraries so that C programmers could writecode into those environments more easily.andM;None of these developments actually started in the last two years.andP;  They haveall been around for a while.andP;  But each of them really took hold in the veryrecent past.andM;Several important new compiler versions came out in the first half of 1990.andO;Borland announced Turbo C++ in May.andP;  Microsoft released Version 6.0 of theMicrosoft C compiler.andP;  Watcom released Version 7.0 with 8.0 coming soon.andO;Zortech released their C++ Version 2.0.andP;  It is important to consider as wellwhat did not happen in that period.andP;  Neither Unix nor OS/2 took over the PCmarketplace.andP;  Graphics user interfaces did not replace text-basedapplications.andP;  Every workstation does not have CD-ROM.andP;  Programmers have notbeen replaced by application generators or so-called fourth-generationlanguages.andM;The FutureandM;You do not need tarot cards to guess what C programmers are going to be doingin the next several years.andP;  A prevalent platform target for programmers willbe, I believe, workstations operating in a network.andP;  For the foreseeablefuture, at least, the workstations will be MS-DOS machines, and the networkswill be NetWare.andP;  There is nothing bold about that prediction except that itmight raise the dander of those wo believe or who would prefer that it isinaccurate.andM;The position of the DOS machine is secure.andP;  The acceptance of the NetWareenvironment is growing.andP;  They are a natural fit because a NetWare system canreadily accommodate software that runs as well on a single-user PC.andP;  Log intothe network, and your DOS application takes on the properties of a multiusersystem.andP;  Usually.andP;  Many of us will be writing DOS applications that can sensethe presence of a network and deal appropriately with it.andP;  To prepare we needto understand the environment and look at some of the tools that support it.andM;MultiuserandM;Multiuser systems in the past had multiple terminals connected to a singlecomputer with a multiuser operating system.andP;  Unix is such a system.andP;  Eachuser has a terminal.andP;  One processor executed the programs for each user.andP;  Theprocessor jumped from user to user by giving slices of CPU time to eachterminal.andM;Today the terminals are computers themselves.andP;  They run their own programs.andO;A network architecture takes advantage of that fact by off-loading to theworkstations the work that is done specifically for the user and letting thehost machine, the &quot;file server,&quot; perform the common and shared tasks.andP;  Themultiuser aspects of the system are managed by the file server.andM;A network file server maintains and stores the system's shared resources,including common data files, software, and printers.andP;  The file server canalso perform services that are common to all users.andP;  One example of suchcommon services is electronic mail.andP;  Another is printer sharing.andM;An advantage to the network architecture is that network or the server goesfrom the network or the server goes down, the users are still in businessbecause their workstations are stand-alone computers.andP;  If you write anetwork-cognizant program that can run in the network or by itself, then youhave made good use of that advantage.andP;  Besides supporting network users, yourprogram can be run by other users who do not have networks.andM;MultitaskingandM;Multitasking is when a user can run more than one program from the sameworkstation.andP;  In the old days a user started a program from the command lineat the terminal.andP;  The operating system in the distant computer started it up.andO;If the program was interactive (communicated with the user via the console),the user could call up the operating system command line with a specialhotkey.andP;  If the program ran in the background, the OS returned the terminalto the commandline prompt as soon as the program was underway.andP;  In eithercase the user could start a second program and the two ran together intandem.andM;Some personal computers have multitasking operating systems.andP;  The Amiga hasAmigaDOS.andP;  The Tandy Color Computer uses OS-9.andP;  The PC's DOS is not amultitasker, which is why TSRs were invented.andP;  But a DOS user has a choice.andO;If the PC has enough extended or expanded memory, a DOS user can add amultitasking shell to DOS and have all the benefits of the multitaskingenvironment.andP;  DesqView is one such shell.andP;  I am writing this column withXyWrite and DesqView 386.andP;  At the same time I am compiling a large C systemand exchanging electronic mail messages with kindred souls on CompuServe.andP;  Donot let anyone tell you that you cannot multitask a DOS PC.andM;If you write programs to run in a multitasking environment, you can takeadvantage of that environment by writing parallel processes that are aware ofone another.andP;  For example, a data-base program can spawn a search process asa separate task and return to the query composition program.andP;  The user can bewriting another query while the first one is being processed.andP;  You can usethe facilities of the multitasker to synchronize processes.andM;Mix and MatchandM;Assume that you target your next application for workstations with DesqViewrunning on a NetWare network.andP;  You can ignore those environments and write aDOS application and it will probably run OK.andP;  It will, that is, unless youcompletely ignore the fact that more than one user could be running thatprogram.andM;There are things to concern you when you run a program on a network.andP;  Supposethe program has one configuration file with a fixed name is a fixed place.andO;All your users are stuck with using the same configuration of options becauseeach of them cannot have his or her own copy of the file.andP;  A network-awareprogram does not build in such restrictions.andM;There are things to consider about a program that runs in a multitaskingenvironment.andP;  The closer the program gets to the hardware, the less likely itis to peacefully coexist with other programs.andP;  Do not confuse TSRs withmultitasking.andP;  A TSR takes over the whole machine by tricking DOS intothinking the TSR is the only program running.andP;  It changes the environment tosuit itself and puts things back the way it found them when it is done.andP;  Amultitasked program runs in a virtual DOS machine within the context of themultitasking shell.andP;  Other programs run in that context concurrently.andP;  Ifyour program reprograms the keyboard, reads and writes the mouse portsdirectly, and writes into video RAM indiscriminately, it can mangle theenvironment for the other programs running in the same physical machine.andM;Writing an application that is well-behaved in these environments and thatwill work as well in a vanilla DOS PC is no easy feat.andP;  You'd be nuts totackle it without help.andP;  Quarterdeck Office Systems, the vendor of DesqView,and Novell, the vendor of NetWare, both provide C programmer's API packagesto allow you to integrate the functions of those environments with those ofyour C programs.andP;  This month we discuss the NetWare C Interface-DOS package.andM;The NetWare EnvironmentandM;A NetWare network consists of a file server and a number of DOS workstations.andO;The file server is usually a PC dedicated to its server functions, and itruns unattended.andP;  The workstations each have a network card that is cabled tothe file server.andP;  There are different electronic standards for the connectionand different cabling conventions.andM;The main purpose for the file server is to permit users to share the server'sdisk space and to share files.andP;  A secondary purpose allows users to shareprinters.andP;  You can, therefore, build a network where most of the disk spaceand all of the printers are on the server.andP;  The workstations have the minimumhardware needed to run the programs.andP;  All the software and most of the datafiles are on the server.andM;Once the server is running, each workstation runs a TSR program called the&quot;network shell.&quot;andP;  Its purpose is to communicate between the server and theworkstation.andP;  The shell observes how many disk drives the workstation has andmaps higher-drive letters to the volumes on the file server.andP;  Then itintercepts DOS calls.andP;  If a program is opening, closing, reading, or writinga file on one of the server drives, the shell exchanges packets with theserver.andP;  Otherwise it passes the calls through to DOS on the workstation.andO;The program usually does not need to know the difference.andP;  Sounds simpleenough.andP;  In fact, the environment is much more complex than that.andM;Ideally, a user would be unaware that the network is operating.andP;  Except forsome additional commands, the user interface is the same as DOS.andP;  But thereare some internal things that can muddy up the process and that a programmerneeds to know about.andP;  A high-level user called the &quot;network administrator&quot;assigns passwords and grants privileges to users to restrict access to serverfile subdirectories.andP;  The shell can intercept printer output and redirect itto a network queue for spooling.andM;Users log on with &quot;userids.&quot;andP;  Your user can &quot;shell out&quot; to DOS from insideyour application and log off of the network, perhaps logging on under anotheruserid with different access privileges.andP;  Files that were available a momentago, now seem -- to your program -- to not exist.andP;  Programs need to be awarethat such things can happen.andM;The NetWare C InterfaceandM;If you are going to write a program that runs in a network, you need to knowhow to make the extended DOS calls that manipulate the network itself.andP;  TheNetWare C Interface is a library of C functions that provide that interface.andO;I am not going to try to discuss the entire API here.andP;  That would be a bigbook all by itself.andP;  Instead, I will address a few small areas to give you ataste of how the platform works and how well the API is implemented anddocumented.andM;Programs that run in a NetWare network will be one of three types.andP;  First isthe program that knows nothing about NetWare.andP;  Programs in this category areDOS programs written for the single-user PC.andP;  Most of them run OK on thenetwork.andP;  Sometimes you will find a program that opens a file in a fixedplace -- usually the subdirectory where the EXE exists -- and keeps it open.andO;A second user on the network cannot run the program until the first user'scopy terminates, because NetWare will not allow two users to have the samefile open at the same time.andP;  Some installations simply run such programs fromthe workstation's local disk and bypass the network altogether.andP;  Others useutility TSR programs such as Net-Aware to intercept DOS open calls andsubstitute user-defined paths and names.andM;The second category of program is one that will run in a network or as a DOSprogram in a stand-alone PC.andP;  WordPerfect is an example.andP;  The program takesadvantage of the facilities of the network when they are available and getsalong without them when they are not.andP;  Printer selection is one suchfacility.andP;  If the program senses that no network is running, the programsimply uses the facilities of DOS.andM;The third category of program is the one that runs only in a NetWare network.andO;It uses network facilities that DOS does not support.andP;  A user-to-user messageand chat system would be such a program.andM;You don't need any help writing the first category of program.andP;  But to writeone of the others, you need to use the NetWare API.andP;  Before the NetWare CInterface was available, the API consisted of a document that explained theAPI calls at the assembly language level.andP;  NetWare API calls consist of anextended set of INT 0x21 functions that the shell intercepts and processes.andO;Most of my NetWare programs in the past used C language interrupt calls toinvoke the API functions.andM;You can still take that approach, but it is one intensive pain in the netherquarters.andP;  Every call has its own unique format for request and responsepackets and you will code a zillion different structures to deal with them.andO;If you get the slightest element wrong, either in format or content, the APIeither returns a meaningless error code or freezes the machine.andP;  You do notwant to work that way.andP;  The C Interface functions take care of the details byhiding the packet formats and providing parameter lists and return values toinvoke each API function.andM;There are, of course, some problems.andP;  The API documentation is sprinkled witherrors of commission and omission, ones that will trip you up from time totime.andP;  A CompuServe subscription and membership in the NOVA forum is a must.andO;There are always knowledgeable folks there who can answer your questions.andM;Using the API requires that you understand the internal architecture of theNetWare operating environment.andP;  The API libraries are divided into 17categories ranging from Accounting Services to Workstation Services.andP;  Thereis a data base called the &quot;Bindery.&quot;andP;  There are transaction trackingfunctions, a queue management subsystem, and soon, a print server API.andP;  Tofigure out what all these categories are you need to read the &quot;SystemInterface Technical Overview&quot; document and then experiment some.andP;  It is notalways clear from the descriptions of the functions what their purposesreally are.andP;  Further, if you want to do something that does not have acorresponding API function, you need to piece together the logic for theseries of functions that will support your requirement.andP;  There is not a lotof help in the API documentation for these kinds of analyses.andM;Suppose, for example, that your program wants to display the userid of theuser who is logged onto the work station.andP;  (I had just such a requirement foran e-mail program.)andP;  A search through the various API services reveals noapparent function that returns that piece of information.andP;  Keep digging.andO;What you eventually find is a function among the Connection Services calledGetConnectionInformation.andP;  One of the data elements you pass it is a pointerto a null-terminated string to receive the &quot;name of the Bindery object loggedin at the connection number.&quot;andP;  Bindery object?andP;  Connection number?andP;  A carefulreading of the Bindery Services documentation reveals that the Bindery is adatabase of objects, one of which can be a User.andP;  What's the connectionnumber?andP;  That's the first argument to the GetConnectionInformation function.andO;Where does it come from?andP;  Nothing says, so we go searching.andP;  Nearby we findthe GetConnectionNumber function, which returns the connection number thatthe file server assigns to a workstation.andP;  From this bit of secondarydeduction we conclude that a function to return the current userid would looklike Listing One (page 168), getuser.c.andM;As an experiment, I wrote the same program by using the assembly language APIand the intdosx function that has become a de facto standard among PC Ccompilers.andP;  Listing Two, page 168, is getuser1.c, and it offers aninteresting contrast to the C API.andP;  Even this small example shows how muchmore readable the C version is.andP;  On the other hand, the version of theprogram compiled with the C API takes almost 4K more than the one with itsown interface.andP;  Everything costs something.andM;Are these excursions through the oblique world of the NetWare architecturetypical?andP;  In my experience, they are.andP;  For example, the documentation for theGetConnectionInformation function says that the shell uses this function tosee if it is already loaded, and that other programs should, too.andP;  But thefunction needs a connection number, and no connection number exists withoutthe shell already being loaded.andP;  Apparently you use any old connection numberbetween 1 and 100, and if the function does not put something in thearguments, the caller can assume that the shell is not there.andP;  Thedocumentation does not spell that out, however.andM;The BinderyandM;NetWare programmers should be familiar with the Bindery, a general-purposedatabase that NetWare uses and for which it provides support for applicationsuse.andP;  The Bindery is the home for definitions of users, user groups, queues,servers, gateways, and so on.andP;  A Bindery entry is an &quot;object.&quot;andP;  Each objecthas an object &quot;type&quot; and can contain one or more &quot;properties.&quot;andP;  A propertycan be an &quot;item,&quot; which can contain one &quot;value&quot; or it can be a &quot;set,&quot; whichcontains a list of values.andP;  Apparently Novell is rewriting the databaselexicon.andM;NetWare defines certain object types for the things it keeps in the Bindery.andO;Application programs can add their own object types.andP;  As an experiment, let'slook at the OT_USER Bindery object type.andP;  You can scan the Bindery forobjects of a certain type, all objects, objects that match a specified name,and objects with a given object identification number.andP;  Listing Three, page168, is showusrs.c, a program that scans the Bindery for all registered usersand displays their userids on the console.andP;  To scan the Bindery, you pass aninitial objectid of -1 and a name with a wild card (*) to theScanBinderyObject function.andP;  The function returns the object's name andobjectid.andP;  Subsequent calls to the same function accept the objectid filledin by the previous call.andP;  This scan continues as long as the function returnsthe SUCCESSFUL return code.andP;  The documentation is vague about what stops thescan, but I figured it out by experimenting.andM;Incidentally, the SUCCESSFUL return code is zero, the same value that thefunction returns if the shell is not loaded.andP;  Try the program withoutNetWare, and you go into a loop displaying garbage.andP;  So, you see, you do needa way to tell if the shell is loaded and the network is operating.andP;  I fooledaround for a while with the GetConnectionInformation function attempting tofind a reliable way for it to tell a program that the shell was or was notloaded.andP;  No luck.andP;  Some time ago I found a different technique, which you cansee in Listing Four, page 170, nwloaded.c.andP;  It calls the shell at the lowerlevel by using the System Calls API to set the NetWare lock level.andP;  Theeffect and meaning of the calls are unclear, particularly when viewed in thelight of what those API functions are supposed to do, but the function workswith no apparent ill effects.andM;QueuesandM;NetWare includes a queue management system (QMS).andP;  Queues are lists that thequeue manager maintains and they exist as Bindery objects.andP;  Users can bedefined as being queue users, queue operators, and queue servers.andP;  A queueuser can add an entry to a queue and observe the status of queues.andP;  A queueoperator can modify queue entries.andP;  A queue server can retrieve entries fromqueues and service them.andM;A queue entry is a job.andP;  The job is whatever you want it to be.andP;  The queueserver will perform the job based on the presence of the entry in the queue.andM;NetWare uses QMS to manage spooling to network printers.andP;  The API provides anumber of functions that allow an application to control how that printingwill occur.andP;  A future API will permit you to write print server applicationsso that you can print from NetWare print queues at workstations.andP;  By studyingthe API interface between print queues and QMS, you can see how you might useQMS in your own applications.andM;VAPsandM;A Value-Added Process is a program that runs in the file server.andP;  The VAP isfor use on NetWare 286.andP;  This is a weighty subject, far beyond the scope ofthis column, and it makes the brave quiver because VAPs are difficult towrite and downright thorny to test.andP;  NetWare 386 has an improvement on theVAP called the &quot;NLM.&quot;andP;  The C API provides functions that you use in VAPdevelopment, but does not mention the NLM.andM;A VAP executes when the file server starts up.andP;  You have to bring the serverdown to reload a new VAP.andP;  VAPs run in 286 protected mode, which means thatyou cannot test them with the usual debugger techniques.andM;Other API ServicesandM;The C API includes functions that account for the use of different servicesin the network.andP;  You can write an accounting package that will distributecosts across users.andP;  There are API functions to support exchange of datafiles between DOS and Apple workstations.andP;  There are communications andmessage services for inter-user and inter-network data packets.andP;  There areconnection, workstation, file and directory services, and on and on.andM;SummaryandM;I have barely touched the surface of the NetWare programming environment.andP;  Ofcourse, it is not possible to cover all bases in the space of a column.andP;  Thepurpose of this coverage is to expose you to the environment, show you thetools, and suggest that this might be the coming thing.andM;On the whole, I prefer using the C API to the alternative method of codingthe low-level API calls into my C programs.andP;  The problems I addressed in thiscolumn are not problems with the API software itself, but with the level ofinformation imparted by the documentation.andP;  Like any other complex softwaredevelopment platform, the NetWare environment takes a while to learn.andO;Programmers who have experience with these functions would intuitively knowthe answers to the questions I pose.andP;  But it takes a while to reach thatlevel of knowledge.andM;Probably my severest criticism is of the packaging.andP;  Novell uses double slipcovers with two ring binders in a cover.andP;  Even my slender pianist's fingersare not deft enough to easily pull a manual out of its box.andP;  Usually when Ifinally get it out, the rings have popped open, and the pages fall on thefloor.andP;  Yet the binders are that lay-flat kind with the rings offset on oneside, and they cannot be stored outside the slip covers.andP;  Doesn't anyone evertry these things out for a while before they commit a big budget to usingthem?andM;When the demand for better NetWare tools reaches a level that justifies aninvestment in their development, software houses who cater to programmerswill respond.andP;  Then you will see third-party function libraries that providea higher level of access to the NetWare innards, providing an easierinterface for programmers.andP;  Perhaps someday there will be C++ class librarieswith classes for objects in the Bindery, queues, the communications packets,and the rest.andM;In the meantime, if you will be writing NetWare-savvy programs, you will wantto get the NetWare C Interface-DOS libraries from Novell.andP;  If you want tostudy or use the underlying assembly language calls, get the NetWare SystemCalls-DOS package.andO;</TEXT></DOC>