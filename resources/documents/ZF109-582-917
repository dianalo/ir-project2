<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF109-582-917  </DOCNO><DOCID>09 582 917.andM;</DOCID><JOURNAL>Hewlett-Packard Journal  Oct 1990 v41 n5 p62(11)* Full Text COPYRIGHT Hewlett Packard 1990.andM;</JOURNAL><TITLE>HP DIS: a development tool for factory-floor device interfaces.andO;(HP Device Interface System; includes a related article on thefinite state machine, one on HP DIS' matching process, and on oneHP DIS' action routine)</TITLE><AUTHOR>Garliepp, Kent L.; Skupniewicz, Irene; Frolich, John U.; Fulton,Kathleen A.andM;</AUTHOR><SUMMARY>The HP Device Interface System (DIS) is a toolset that aids indeveloping communication links between computers and factory-floordevices.andP;  The interfaces run in an HP-UX environment on HP 9000Series 300 or 800 computers.andP;  There are three facilities in HPDIS: a development facility that supplies a high-level ProtocolSpecification Language to define the communications logic; atesting facility that supplies a test generator, a test exercise,and a device simulator; and a run-time facility to execute theprotocol in real time.andP;  It is easier to construct an HP DIS systemthan it is to construct a similar application in C code, but thereis some loss of performance when compared with C. HP DIS isflexible, which permits device interface modules to be configuredand combined in a variety of ways.andP;  HP DIS improves productivityand reliability while reducing development and support costs.andM;</SUMMARY><DESCRIPT>Product:   HP 9000 (Workstation) (Computer programs)HP 9000 300 (Workstation) (Computer programs)HP 9000 800 (Workstation) (Computer programs).andO;Topic:     Factory ManagementInterfaceAutomationProgram Development Tools.andO;Feature:   illustrationchart.andO;Caption:   The process of creating a device interface. (chart)HP DIS facilities. (chart)HP DIS testing facility. (chart)andM;</DESCRIPT><TEXT>HP DIS: A Development Tool for Factory-Floor Device InterfacesandM;EFFICIENT DEVELOPMENT OF INTERFACES between computers and factory-floordevices can be a serious challenge in factory automation projects.andP;  [1] These factory-floor devices consist of programmable logic controllers (PLCs),robots, numerically controlled machines, gauges, scales, and other devices.andO;The problem is that they may come from many manufacturers and may havedifferent, proprietary interfaces.andM;For a few major brands of programmable controllers, there are off-the-shelfcommunications packages that can be purchased.andP;  This solution has limitedapplicability if the needs vary from what is implemented in the package.andM;If flexibility is needed, a customized interface can be written.andP;  At present,development of specific device interfaces is a time-consuming, exacting, andexpensive process requiring a fairly high level of expertise.andP;  The processgenerally consists of characterizing the device's communication protocol andthen writing, changing, or enhancing programs, subroutines, and test suites.andO;This process is well-known to all interface developers and creates a slowresponse to market needs.andM;In the long run, the use of communications standards, such as theManufacturing Automation Protocol [2] (MAP), will eliminate many of thedevice connectivity problems and the response to market needs will improvesignificantly.andP;  In the meantime, many factory-floor devices exist and havelong useful lives remaining.andP;  Many are simple devices, such as gauges withsimple interfaces, that may never conform to a standard.andM;To reduce the cost of developing customized interfaces for devices that needthem and to shorten the time required for such efforts, tools are needed tosimplify the development and testing of the interfaces.andP;  This is theobjective of the HP Device Interface System (HP DIS).andP;  HP DIS is a toolsettha helps developers create and test interfaces between computer applicationsand RS-232-compatible factory-floor devices in less time than before.andP;  Theresulting interfaces run in an HP-UX environment on HP 9000 Series 300 or 800computers.andM;HP DIS offers three facilities to make the development and implementation ofdevice interfaces more efficient.andP;  A development facility provides ahigh-level Protocol Specification [Language.sup.3] for defining thecommunications logic.andP;  A testing facility provides a test generator, a testexerciser, and a device simulator.andP;  A run-time facility executes the protocolin real time.andP;  Fig.andP;  1 shows a typical protocol development cycle and the useof the HP DIS toolset.andM;HP DIS: the Tools ApproachandM;A diagram of the HP DIS system is shown in Fig.andP;  2.andP;  The three bubblescorrespond to the above-mentioned three facilities provided by HP DIS.andP;  Theseallow the system developer to develop, test, and run device interfaces.andM;The development facility is simply a compiler that generates a protocolinterface.andP;  The protocol interface is an executable process that forms thecentral component of an HP DIS system.andP;  The input to the compiler is adescription of the device protocol, written in Protocol SpecificationLanguage (PSL).andP;  PSL allows the user to describe a state graph and itsassociated state table in a high-level format (see &quot;Finite State Machine,&quot;page 65).andM;Other inputs to the developing facility are subroutines that can be linked tothe protocol interface.andP;  In HP DIS these are called action routines (see&quot;Action Routines,&quot; page 69).andM;The run-time facility provides the execution environment for the protocolinterfaces.andP;  When the protocol interface runs, it communicates with ports,other protocol interfaces, and other C programs through HP-UX message queues.andO;Using a description of the protocol interface's associated I/O ports, therun-time facility manages the ports, message queues, process startup, andprocess shutdown.andM;The development and run-time facilities also provide the following features:andM;* A contributed library of example protocol interfaces, tutorial protocolinterfaces, and other helpful toolsandM;* The ability to implement user-defined lookup tablesandM;* Eight-bit native language supportandM;* Access between multiple devices and multiple interfacesandM;* The ability to add and delete protocol interfaces dynamically in a runningsystem.andM;A diagram of the HP DIS testing facility is shown in Fig.andP;  3.andP;  This facilityconsists of a test generator and a test exerciser.andM;The test generator takes the state table and creates test cases.andP;  The testcases are fed to the test exerciser, which executes each test case by sendingmessages to the protocol interface under test.andP;  The test exerciser attemptsto achieve each state listed in the state table, for up to 100% coverage.andM;Optional inputs to the test exerciser are user-written test cases.andP;  The testexerciser executes a sequence of test cases and compares expected results tothe results of the protocol interface under test.andP;  Actual devices or I/Oports are not necessary for testing; factory-floor devices can be simulatedby describing their messages.andM;The output of the testing facility includes test case documentation and testresults.andP;  The testing facility also provides the following features:andM;* Full or partial data tracingandM;* Either menu-driven execution or script execution of test casesandM;* Protocol filters to simulate garbled messages, time-outs, and expressionmatchingandM;*Notification of percentage covered.andM;An HP DIS ExampleandM;There are three steps in developing an interface (see Fig.andP;  4).andP;  The firststep is to describe the interaction between the application and thefactory-floor device interface.andP;  The second step is to specify the deviceprotocol in a language that HP DIS can compile.andP;  The third step aftersuccessful compilation is to generate the test scripts and test the logic ofthe developed interface.andP;  These steps are illustrated by the followingexample.andM;Describing the Interface.andP;  A block diagram of the system interfaces for itsexample is shown in Fig.andP;  5.andP;  The interface between the application and thedevice interface is an HP-UX message queue.andP;  Read and write subroutines areavailable for the application program developer to send buffers to the deviceinterface and receive buffers from it.andP;  These subroutines allow referencingeither the HP-US message queue name or the device application name.andP;  Thelinks between the HP-UX message queues and the device interface areestablished by the run-time facility through a configuration file (Fig.andP;  6).andO;The configuration file is used by the run-time facility to establish thequeues, start the defined interfaces, create the links, and configure theports from the port definitions.andP;  The configuration process eliminates theneed for a detailed understanding of HP-UX interprocess communication andRS-232 serial port initialization.andM;The buffers passed through the queues must be designed to carry theinformation needed by the device interface.andP;  The device interface can requirethe application to pass device-specific data directly or can translategeneric functions into device-specific data.andP;  Device interfaces can rangefrom very device dependent to completely device independent.andP;  In the lattercase more logic will be required in the device interface.andM;For the sake of simplicity, this example uses the device dependent approach.andO;The application outbound buffer contains a six-byte header and avariable-length data string.andP;  The application inbound buffer contains astatus byte and a variable-length data string.andM;Specifying the Protocol.andP;  One of the methods of specifying the protocol is atransition diagram translated into a state diagram.andP;  This is particularlyconvenient for translating the protocol into a language HP DIS can compile.andO;Figs.andP;  7a and 7b describe a transition diagram and a state diagram for anontrivial protocol.andP;  This example protocol is based on the Allen-BradleyData Highway I protocol, but only exemplifies the major features.andP;  Thisexample assumes synchronous communication.andP;  No new request is sent from thecomputer to the factory-floor device until a previous request is satisfied.andM;The computer sends a message (MSG) to the device (Fig.andP;  7a) and waits for anacknowledgement from the device (ACK).andP;  The computer then waits for a replymessage (Fig.andP;  7b).andP;  Each message consists of block control characters, aheader, and data.andP;  In the case of a read request, the data field from thecomputer contains the address and the length of the request.andP;  The reply datafrom the device consists of the values requested.andP;  In the case of a writerequest, the data field from the computer contains the address and the valuesfor the request.andP;  The reply data from the device consists of an internalstatus for the request.andM;In the event of a communication failure, either the computer or the devicecan reply with a failure message (NAK).andP;  The protocol interface must alsorecognize that no response (TO) is a failure.andP;  Other failure mechanisms arenot taken into account in this example.andM;Figs.andP;  7a and 7b show state diagrams derived from the transition diagrams.andO;The states and events form the logic of the protocol interface.andP;  Actions (orfunctions) are performed at each state-even pair.andP;  Fig.andP;  7a also shows anevent (retry exceeded) that is not supported by the transition diagram.andP;  Thisevent is added to prevent endless looping.andM;A message from the device to the computer (Fig.andP;  7b) will cause a replymessage event, whcih would normally return directly to the IDLE state.andP;  Thisexample will check the integrity of the byte stream by checking the BCC(block control character) count and branching to an extra state (CHECK).andP;  Ifthe BCC count was incorrect, the original message will be sent back to thedevice.andP;  If the BCC count was correct the message from the device will bereturned to the application.andP;  The combination of the IDLE state and the replymessage event is included in case the device sends a message after time-outprocessing.andP;  If this were not included, the wrong message would be extractedfrom the HP-UX message queue during the next transaction.andP;  The message fromthe device is simply acknowledged and ignored.andM;The state diagrams of Figs.andP;  7a and 7b are combined into one state diagram inFig.andP;  8.andM;The actions to be performed at each state transition are listed in Table I.andO;With some additional declarations this table can be transformed into aProtocol Specification Language (PSL) program that can be compiled.andP;  Previousdecisions about the form of the messages from the application can beincorporated into the data structures.andM;Fig.andP;  9 shows the PSL program ready for compiling and testing.andP;  The compilernot only checks the program syntax, but also tests the reachability of allstates from/to the home (IDLE) state.andP;  This check ensures that there are noincomplete paths.andM;Testing.andP;  The tests, test scripts, and results files can be generatedautomatically at compile time with a PSL compiler option.andP;  The tests areexecuted from a test script and the results appear in several data files:andM;* The action command file contains the test actions to be performed.andM;* The comparison file contains a summary of the test paths.andM;* The trace data output file contains detailed test flows and variables.andM;The test generator walks the state table and generates the actions commandfile (Fig.andP;  10).andP;  The test generator starts with the first state-event pairin the PSL program and generates commands to trigger the event.andP;  The testterminates at the state and event in the ECASE statement (last state, nextstate, event of last state).andP;  The data following the WURA (write toupper-level read area) statement is the equivalent of a message from theapplication.andP;  The data following the WLRA (write to lower-level read area)statement is the equivalent of a message from the device.andP;  A test case isgenerated for each subsequent state-event pair.andP;  The test cases (CASE 1; andCASE 2;) marked Good and commented out in Fig.andP;  10 were already successfullyexecuted.andP;  Test cases three and four were created by a second pass of thetest generator based on the previous tests.andM;The test generator generates cases to trigger external events (messages fromthe application or device) by creating a message from the valued involved.andO;State-event pairs WAIT-ACK and WAIT-NAK (Fig.andP;  9) were successfully generatedbecause the test generator was able to use the structures ReplyAck andReplyNak as the basis for triggering the events.andM;The test generator generates cases for internal events based on theassociated values of the constants or variables involved.andP;  If the values willsatisfy the event, the case is generated.andP;  If not, the case cannot begenerated.andP;  Each case is rechecked on every pass to see if the variablesinvolved have been changed in previous test runs.andP;  For more completeautomatic test coverage, the PSL program variables can be set to valuesfavorable for test case generation.andP;  In some cases, the contents of themessages in the actions command file must be altered to affect subsequentcases.andM;The test exerciser (Fig.andP;  11) starts the interface under control of therun-time facility usint the test configuration file (Fig.andP;  12) and executesthe test actions.andP;  At the conclusion of the test, the interface is terminatedand the results are stored for examination.andM;Fig.andP;  13 shows the comparison results file.andP;   The expectedandM;state-event pairs for the expected results and the actual results are alwaysshown.andM;If the actual results differ from the expected results, the trace data outputfile (Fig.andP;  14) can be examined to determine the cause.andP;  The trace dataoutput file contains a detailed description of the data flow through thestate table for each case executed by the test exerciser.andP;  It shows allincoming messages, state-event pairs, and values of all variables after everyaction associated with each state-event pair.andP;  The variable values are usefulfor checking the results of actions even when the correct path is executed.andM;This example has shown that by using tools and a subsystem approach, afactory-floor device protocol can be modeled and produced.andM;ConfigurationsandM;Fig.andP;  15 shows various configurations for HP DIS-built interfaces.andP;  Interfaceschemes can use a single protocol interface or multiple protocol interfaces.andO;These protocol interfaces can be stacked in series or configured in parallel.andO;When multiple devices are serviced, even more choices can be made: eachdevice can be serviced by its own dedicated protocol interface, or multipledevices can be serviced by a generalized protocol interface.andM;Fig.andP;  15a shows the simplest configuration.andP;  Here, one protocol interfacehandles one port and one device.andM;Fig.andP;  15b shows three protocol interfaces that work together.andP;  Messageprocessing that is common to all ports isandM;done in the lower-level PI1.andP;   The message is passed to theandM;upper-level PI2 and PI3 for device-specific processing.andP;  For example, PI1 cancollect all messages from multiple devices, perform checksums, and pass themto the next level.andP;  This ensures that all messages are acknowledged promptlyby a dedicated protocol interface, while less time-critical functions arehandled by separate protocol interfaces.andM;Fig.andP;  15c shows three protocol interfaces, each dedicated to a port.andO;Device-specific message processing is done for each port.andP;  The upper-levelPI4 directs and organizes messages before passing them up to the application.andM;A developer can choose where to put common functions.andP;  The performance willbe slightly better when the number of protocol interfaces in serial issmaller, since fewer messages are passed between processes.andP;  On the otherhand, a centralized function may be desirable because it simplifies thesystem design.andM;PerformanceandM;An HP DIS system is easier to construct than a similar application in C code,but this is achieved with some loss of performance compared to C code.andP;  In anHP DIS system, functionality is split across five (or more) separate HP-UXprocesses.andP;  In C code, all the functionality could reside in a singleprocess.andP;  For example, HP DIS port management is handled by separate read andwrite port processes with connected HP-UX message queues.andP;  HP DIS handles themessage buffering.andP;  This decreases development time since port configurationand buffer management code does not have to be written.andP;  However, theperformance of this port interface will fall short of a similar interfacewith integrated port management functions.andM;It is also relevant that HP DIS is an HP-UX application.andP;  An HP-UX cellcontroller, whether written in HP DIS or in C, is subject to normal HP-UXtimesharing policies, and will have nondeterministic response times.andP;  WithHP-UX on HP 9000 Series 800 computers, processes can be run under a real-timepriority to decrase the chance that a process will be preempted.andP;  HP DIS usesthis HP-UX extension.andP;  With real-time HP DIS processes, response timevariability can be decreased.andM;Performance Test ResultsandM;HP DIS performance studies were conducted to answer these questions:andM;* What is the performance on HP 9000 Series 300 and Series 800 computers?andM;* What is the throughput of an HP DIS interface?andM;The flexibility of HP DIS allows device interface modules to be configuredand combined in an infinite number of ways.andP;  A simple model was chosen thatgives representative data involving the major items contributing toperformance.andP;  Fig.andP;  16 depicts a typical configuration.andP;  An application(PModel) is connected to a device interface module (PI1), which is connectedto an HP-UX RS-232 multiplexer port.andP;  The port has a physical loopbackconnection and all data written to the port is immediately read back from theport.andP;  Each port has one PModel.andP;  A fixed-length message is sent to the portby a PModel and returned unchanged.andP;  Because the application program waitsfor each message to return before sending another, only one message is in theloop at a time per PModel.andP;  Throughput data is averaged over 20 transmissionsfor various message lengths using one, then two PModels.andM;Fig.andP;  17 shows the data throughput of an HP 9000 Model 375 and an HP 9000Model 832, both with 16M bytes of memory, under the HP-UX 7.0 operatingsystem.andP;  The throughput in Fig.andP;  17 reflects the transfer of data one-way.andO;The curves show the data throughput for one PModel and the sum of the datathroughputs for two PModels.andM;The throughput decreases with message sizes above 1000 to 15000 bytes becauseHP DIS is performing message matching (see &quot;Matching Messages,&quot; page 67).andP;  HPDIS matches raw byte streams to the user's definition to the message.andM;SummaryandM;The Hewlett-Packard Device Interface System, HP DIS, is a tool that eases thedevelopment of communication links between computers and factory-floordevices.andP;  Interfaces can be developed more quickly than with conventionalcode.andP;  Devices can be simulated, and testing is mostly automated.andO;Communication links can be scaled, using only the routines needed for theapplication at hand.andP;  Through the use of this tool, factory-floor devicesfrom many vendors can be mixed and matched.andM;HP DIS can improve productivity, reliability, development costs, and marketresponse and reduce support costs for device interfaces.andM;ReferencesandM;[1] F. Litman, &quot;Software Tools for Plant-Floor Connectivity,&quot; Automation,Vol.andP;  35, no.andP;  4, April 1988, p. 28.andM;[2] Hewlett-Packard Journal, August 1990, pp.andP;  6-60.andM;[3] C. Jue, &quot;A System to Develop Factory Floor Device Interfaces,&quot;Proceedings of the Third International IMS Conference, Vol.andP;  3, part 1,September 1987, pp.andP;  134-146.andM;Kent L. GarlieppandM;Specializing in computer-aided manufacturing Kent Garliepp worked on design,development, and testing of HP DIS software for HP 9000 computers as amemberof HP's Industrial Applications Center in Sunnyvale, California.andP;  Afterjoining HP in 1959, he provided computer support for the solid-statelaboratory of HP Laboratories, and IC manufacturing software support at HP'sCupertino Integrated Circuits Operation.andP;  More recently, he helped designsoftware for truck manufacturing at HP's Advanced Manufacturing SystemsOperation.andP;  Born in Palo Alto, California, Kent is married, has fourchildren, and lives in Capitola, California.andP;  His interests includebicycling, radio-controlled models, and water-color painting.andM;Irene SkupniewiczandM;For the past four years at HP, Irene Skupniewicz has worked as an Randamp;Dsoftware engineer in the development of manufacturing applications.andO;Currently, she is in the Manufacturing Applications Group working on theDevice Interface System and Software Integration Sockets, two products thatare part of HP's industrial precision tools for HP 9000 computers.andP;  Ireneearned a BS degree (1981) in industrial engineering from the University ofWisconsin, and an MS degree (1987) in electrical engineering fromCarnegie-Mellon University in Pittsburgh.andP;  Before joining HP, she worked withUnimation/Westinghouse in Pittsburgh to develop robotic systems.andP;  Born inRacine, Wisconsin, Irene lives in Cupertino, California.andP;  For many years, shehas been a &quot;diehard&quot; runner and enjoys meeting other HP people through hermembership in the HP Running Club.andM;John U. FrohlichandM;As a member of the software development team at HP's industrial ApplicationsCenter, John Frohlich helped develop the HP DIS product.andP;  He joined HP in1976 at the company's Optoelectronics Division, and helped develop machinelanguage programs for calculator-based systems to test LED display devices.andO;He also has worked on several versions of the RTE operating system for HP1000 computers and on ATS/1000 software.andP;  John received his BSEE degree in1963 at the Lucerne State College of Technology in  Switzerland.andP;  He is amember of the IEEE.andP;  Born in Switzerland, he lives in Cupertino, California,and enjoys mountain hiking, biking, and listening to old jazz recordings.andM;Kathleen A. FultonandM;After joining HP's Engineering Productivity Division in 1984, softwareengineer Kathy Fulton helped develop the equipment control portion of HP'sSemiconductor Productivity Network.andP;  She also designed and coded theconfiguration, initialization, and run-time portions of the HP DIS product,and is now testing and maintaining HP Sockets software at HP's IndustrialApplications Center.andP;  Before joining HP, Kathy was a semiconductorfabrication engineer at Burroughs Corp. and a software development engineerat Trilogy Corp. and Amdahl Corp.andP;  A member of the IEEE, she received her BAdegree in 1975 in applied physics and information science with aspecialization in computer science from the University of California at SanDiego.andP;  Born in Reno, Nevada, Kathy is married and lives in Cupertino,California.andP;  Her interests include traveling to unusual locations, readingscience fiction, and quilting.andO;</TEXT></DOC>