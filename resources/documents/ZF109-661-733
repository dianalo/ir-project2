<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF109-661-733  </DOCNO><DOCID>09 661 733.andM;</DOCID><JOURNAL>AI Expert  Dec 1990 v5 n12 p46(6)* Full Text COPYRIGHT Miller Freeman Publications 1990.andM;</JOURNAL><TITLE>Using the Rete algorithm. (includes a related article on the OPSprogramming language)</TITLE><AUTHOR>Graham, Paul.andM;</AUTHOR><SUMMARY>The Rete algorithm, developed by C.L.andP;  Forgy in the mid-1970s, isa useful tool for many pattern-matching applications.andP;  A typicalapplication of the algorithm is in the OPS83 and OPS5 programminglanguages.andP;  The product is used as a general-purpose tool forvarious expert-system pattern-matching tasks.andP;  Included areexamples of the way Rete works using the OPS5 code.andP;  Thefoundation of the Rete algorithm involves a structure called aRete network, a data-flow graph with specified output and inputnodes.andP;  Drawbacks to Rete include its slow speed.andP;  The greater thechange in the working memory with each cycle, the less improvementthe algorithm will have.andM;</SUMMARY><DESCRIPT>Topic:     AlgorithmsAlgorithm AnalysisPattern MatchingSoftware DesignProgram Development ToolsArtificial IntelligenceExpert Systems.andO;Feature:   illustrationchart.andO;Caption:   Rete network for rules r1a and r1b. (chart)Rete network for rule r1. (chart)andM;</DESCRIPT><TEXT>USING TheandM;The Rete algorithm, developed by C. L. Forgy in the mid-1970s, is anefficient way of performing repeated pattern matches.andP;  The most commonimplementation of Rete (pronounced &quot;ree-tee&quot;) is in the OPS5 and OPS83programming languages.andP;  Rete is a good general-purpose tool for manyexpert-system pattern-matching applications.andM;I'm going to use OPS5 code as examples of how Rete works.andP;  An OPS5 programconsists of facts, called working memory elements (WMEs), and rules, calledproductions.andP;  The complete set of rules is sometimes called a productionsystem.andM;At run time, the facts are stored in a database called the working memory.andP;  AWME is best viewed as a vector of symbols.andP;  A typical one might berepresented as:andM;(object block-2 block red)andM;For the user, this WME could represent the fact that block-2 was an object,of type block and color red.andM;An OPS5 production has two main parts, patterns and actions.andP;  Patterns aretemplates intended to match the facts stored in working memory, and actionsare commands.andP;  Here's a simple example of an OPS5 production, mapped inFigure 1:andM;(p r1 (object andless;bandgt; block andless;candgt;) (object andless;pandgt; pyramid andless;candgt;) (on andless;pandgt; andless;bandgt;) [rightarrow] (write andless;bandgt;and andless;pandgt; form a andless;candgt; tower))andM;This expression defines a production called r1.andP;  The three lines before thearrow are the patterns, and the following line is the action.andP;  In English,the content of this rule might be expressed: &quot;If there are a block and apyramid of the same color, and the pyramid is on the block, then announcethat they form a tower of that color.&quot;andM;OPS5 users call patterns LHSs because they occur on the left-hand side of thearrow; actions are similarly called RHSs.andP;  Rule r1 has the LHS:andM;(object andless;bandgt; block andless;candgt;) (object andless;pandgt; pyramid andless;candgt;) (on andless;pandgt;)andM;Each line of the LJS is called a condition element, or CE.andP;  All the CEs inthis LHS contains pattern variables, symbols like andless;xandgt; that begin and end withangle brackets.andP;  A CE matches a fact if values can be assigned to itsvariables, which makes the CE equal to the fact.andP;  For example, the CE:andM;(object andless;bandgt; block andless;candgt;)andM;matches the factandM;(object block-2 block red)andM;when andless;bandgt; = block-2 and andless;candgt; = red.andP;  However, the CE:andM;(object andless;xandgt; andless;yandgt; andless;yandgt;)andM;could never match the previous fact, because it will only match facts inwhich the last two elements are identical.andM;A combination of facts matching the whole LHS of a rule is called aninstantiation of that rule.andP;  A rule with one or more instantiations is saidto be instantiated.andP;  The rule r1 could be instantiated, for example, by thethree facts:andM;(object block-2 block red) (object pyramid-8 pyramid red) (on pyramid-8block-2)andM;which would match the whole LHS with andless;bandgt; = block-2, andless;pandgt; = pyramid-8, and andless;candgt;= red.andM;At run time, OPS5 chooses one of the instantiated rules and executes thecommands in that rule's RHS, with the pattern variables bound appropriately.andO;The process of choosing an instantiation is called conflict resolution; theconflict-resolution strategy typically used in OPS5 is to choose theinstantiation that uses the most recently created facts.andP;  Executing the RHSof a rule is called firing the rule.andP;  r1 has an RHS consisting of a singlecommand:andM;(write andless;bandgt; and andless;pandgt; form a andless;candgt; tower)andM;so the result of firing r1 if instantiated with these facts would be to printout:andM;BLOCK-2 AND PYRAMID-8 FORM A RED TOWERandM;Once a rule has fired, that instantiation becomes ineligible to fire again(although the same rule can fire if instantiated with different facts).andP;  Thecycle of matching, conflict-resolution, and firing continues until no moreinstantiations exist, or the program halts explicitly.andM;The commands in the RHS of a rule can do more than print out messages; rulescan also add, delete, and modify facts.andP;  This rule will assert that eachblock is a solid:andM;(p r2 (object andless;bandgt; block andless;candgt;) [right arrow] (make solid andless;bandgt;))andM;If instantiated with the fact:andM;(object block-2 block red)andM;it will add to the working memory the fact:andM;(solid block-2)andM;which could in turn be used to instantiate other rules.andM;OPS5's syntax is richer than suggested by these examples.andP;  Patterns in theLHS of a rule may be negated, perform arithmetic tests, or refer to fields ofthe facts by name.andP;  Commands in the RHS of a rule can do arithmetic, callexternal functions, open and close files, and so on.andM;MATCHING PROBLEMSandM;To understand why Rete networks are a good idea, we should consider how anOPS5 implementation would work without one.andP;  The set of all currentinstantiations is called the conflict set.andP;  Because the firing of a rule canadd and delete facts, the conflict set changes from cycle to cycle.andP;  Supposea fact is used in the instantiation of some rule r1, but that the firing ofanother rule r2 deletes the fact.andP;  Now the instantiation of r1 will no longerbe valid and shouldn't appear in the conflict set.andM;In the absence of any other method, we would have to recreate the conflictset on every cycle--examine the rules and for each one make a list of allpossible instantiations based on the contents of working memory.andP;  Thisapproach is inefficient in maintaining the conflict set because, as Forgyexplains in his thesis (&quot;On the Efficient Implementation of ProductionSystems,&quot; Ph.D.andP;  thesis, Carnegie-Mellon University, 1979): &quot;In mostproduction systems, working memory changes rather slowly from cycle to cycle.andO;Working memory sizes typically fall in the range of 50-500 elements.andP;  Firinga production will typically chagne two to five of these elements.andP;  Mostproductions will neither gain nor lose any instantiations.andP;  Furthermore, anyproduction that becomes instantiated was probably close to being instantiatedon the previous cycle--perhaps having instantiations for all but one of itscondition elements.&quot;andM;As Forgy claims, a program that recreates the conflict set on each cycle willmostly be doing the same work repeatedly.andP;  What we need is a way to save thematching done on one cycle so that it isn't duplicated in the next.andP;  Thisgoal is precisely the intent of a Rete network: &quot;The match routine can takeadvantage of (the low rate of change), incrementally updating the informationto reflect the changed state of working memory.&quot;andM;The key word here is &quot;incrementally.&quot;andP;  The Rete algorithm, instead ofgenerating the whole conflict set, generates changes to it.andP;  You give Rete alist of the changes to the working memory--the facts that have been added,deleted, or changed--and it will give you a list of conflict-set changes.andM;RETE NETWORKSandM;The basis of the Rete match algorithm is a structure called a Rete network, adata-flow graph with designated input and output nodes.andP;  Tokens representingchanges to the working memory are sent into the input nodes, and from theoutput nodes emerge tokens describing changes to the conflict set.andP;  A Retenetwork has saved state (sometimes very large) that reflects all the tokensthat have passed through it.andP;  The state of the Rete network represents allthe instantiations and partial instantiations according to the current stateof working memory.andP;  After building such a network, you can use its output putto update the conflict set incrementally.andM;A Rete network is made from the LHSs of all the productions.andP;  It contains twokinds of nodes, alpha and beta.andP;  Both node types act as filters, performingtests on incoming tokens, and sending on only those tokens that pass thetest.andP;  The alpha nodes occur at the beginning of the network and performtests on individual facts.andP;  Suppose you have the rule:andM;(p r1 (object andless;bandgt; block andless;candgt; (object andless;pandgt; pyramid andless;candgt; (on andless;pandgt; andless;bandgt; [right arrow](write andless;bandgt; and andless;pandgt; form a andless;candgt; tower))andM;and you want to discover whether a new fact will be part of an instantiationfor it.andP;  Some of the tests you must perform apply only to individual factsand others to sets of facts.andM;For example, for a fact to match the first pattern, its first element willhave to be object and its third element block.andP;  These tests can be performedlooking at the facts alone.andP;  But additional tests can look at more than onefact at a time.andP;  In this case, for a pair of facts to instantiate the firsttwo lines of the LHS, they both must have the same fourth element, becausethe same variable andless;candgt; occurs in both patterns.andM;Alpha nodes perform the first type of test.andP;  The previous LHS would yieldfour alpha nodes--two root nodes [a.sub.1] and [a.sub.2], and twodescendants, [a.sub.3] and [a.sub.4].andP;  The root node [a.sub.1] would take anew candidate fact and check whether its first element was object.andP;  If so, itwould pass the token on to both of its descendant nodes.andP;  [a.sub.3] wouldcheck that the third element was block, and [a.sub.4] would check that thethird element was pyramid.andP;  The other root node, [a.sub.2], would check ifthe first element was on.andM;The final alpha nodes in the tree send their output to beta nodes, whichperform the interfact tests.andP;  Beta nodes have two inputs, so each one canperform tests on two sets of facts simultaneously.andP;  For LHSs comprising threeor more patterns, the Rete network will have a string of beta nodes--one thattakes the tokens matching the first two patterns and another that takes theoutput of the first and tokens matching the third pattern, and so on.andM;With the previous LHS, we need only two beta nodes, [b.sub.1] and [b.sub.2].andO;Beta node [b.sub.1] takes the output of alpha nodes [a.sub.3] and [a.sub.4],and passes only those pairs of facts andless;f,gandgt; that have the same fourth element.andO;Beta node [b.sub.2] takes the output of [b.sub.1] and [a.sub.2] and passes ononly those triples of facts andless;f, g, handgt; in which the second element of h (andless;pandgt;)is the same as the second element of g, and the third element of h (andless;bandgt;) isthe same as the second element of f.andM;Rete networks have one more very important property: beta nodes save state.andO;They save a record of all the tokens that have come into each of its inputs.andO;Thus, when a new fact comes down one input, the beta node can match itagainst facts that have already come down others.andM;Let's follow the course of some tokens through the path of our tiny Retenetwork.andP;  Suppose three new facts are asserted:andM;(object block-2 block red) (object pyramid-8 pyramid red) (on pyramid-8block-2)andM;Tokens representing the new assertions, call them [T.sub.+b], [T.sub.+p], and[T.sub.+o], are inserted into the network.andP;  [T.sub.+b] and [T.sub.+p] pass[a.sub.1] and are sent on to [a.sub.3] and [a.sub.4].andP;  [T.sub.+o] passes[a.sub.2] and is sent on to the right input of [b.sub.2] and stored there.andO;Only [T.sub.+b] passes node [a.sub.3]; it's forwarded to the left input of[b.sub.1], where it is stored.andP;  Only [T.sub.+p] passes node [a.sub.4], afterwhich it gets sent to the right input of [b.sub.1] and stored there.andP;  Thebeta node discovers that the new token [T.sub.+p] matches [T.sub.+b], whichwas stored in the left input, and passes on a new combined token[T.sub.+andless;b,pandgt;] to the left input of [b.sub.2], in which it is stored.andP;  Thenew token [T.sub.+andless;b,pandgt;] matches [T.sub.+o], which was stored in the rightinput, so the beta node creates a new token [T.sub.+andless;b,p,oandgt;], and passes iton.andP;  Since [b.sub.2] has no further destination, [T.sub.+andless;b,p,oandgt;] is the Retenetwork's output, and represents a new instantiation.andM;Rete networks for whole production systems operate on the same principle.andP;  Ifmore productions exist, we just add more nodes to the graph.andP;  Among thesubtle economies offered by the Rete network is the sharing of alpha nodes.andO;In our example, the two CEs share the same first test--that the first elementbe object--and so they can share the same alpha node.andM;This sharing of nodes is possible even between CEs that occur in differentrules.andP;  For example, the usual way to get the effect of an or in an OPS5program is to write two rules.andP;  If you want to change r1 to say that a blockand a sphere also form a tower, then the original rule splits like this:andM;(p r1bandM;(object andless;bandgt; block andless;candgt;) (object andless;sandgt; sphere andless;candgt;) (on andless;sandgt; andless;bandgt;)andM;[right arrow]andM;(write andless;bandgt; and andless;pandgt; form a andless;candgt; tower)andM;(p r1b (object andless;bandgt; block andless;candgt;) (object andless;sandgt; sphere andless;candgt;) (on andless;sandgt; andless;bandgt;andM;[right arrow]andM;(write andless;bandgt; and andless;sandgt; form a andless;candgt; tower)andM;Notice that the two rules have nearly identical LHSs.andP;  Among other things, afact that passes the alpha-node tests for the first pattern of r1a would alsopass for the first pattern of r1b.andP;  In principle, performing such tests on anew fact more than once is unnecessary; in the Rete network, the two patternswill share the string of alpha nodes, branching afterwards to distinct betanodes.andP;  Figure 2 shows the Rete network for r1a and r12b.andM;The Rete algorithm's elegance is evident in its treatment of deleted facts.andO;The network handles tokens representing the assertions.andP;  When a fact isdeleted, two things must be done: instantiations that use the fact must beremoved from the conflict set, and tokens that contain the fact must beremoved from whatever beta nodes in which they are stored.andM;A token representing the deletion of a fact is handled much like an assertiontoken.andP;  The alpha nodes behave just as they do with assertions--the onlydifference is the beta nodes.andP;  When a fact arrives in one of the inputs,instead of being stored there, any identical stored tokens are removed fromstorage.andP;  Then, as with an assertion token, the beta node matches it againstthe tokens in the other input and emits new compound tokens.andP;  The compoundtokens, however, still represent deletions.andP;  When tokens finally emerge fromthe network, they will represent exactly the instantiations that must beremoved from the conflict set.andP;  In fact, the deletion tokens will havefollowed the very same paths.andM;ANALYSISandM;Although the Rete algorithm is extremely elegant, it does have drawbacks.andO;After all, what you want from a match algorithm is speed, not elegance.andO;Elegant algorithms look as if they should be fast, but the opposite is moreoften true--speed comes from special-purpose hacks.andM;What sort of problems, then, does Rete run fast?andP;  The algorithm was motivatedby the observation that working memory changes only slightly on each cycle.andO;In such cases, it can be expected to yield a great speed improvement.andM;However, the greater the change in working memory on eah cycle, the lessimprovement Rete will bring.andP;  In extreme cases--for example, a productionsystem language for particle animation in which every particle moves on everycycle--it would be a bad idea to use the Rete algorithm.andP;  Rete was neverintended for such applications.andM;A Rete network does have its own computational burdens--in the storage andretrieval of tokens in beta nodes, for example--and the greater the change inworking memory, the more onerous these burdens will become.andP;  If a largeproportion of working memory changes on each cycle, the program might as wellreconstitute the conflict set each time.andM;The Rete algorithm also makes deletion expensive.andP;  In a Rete network, adeletion takes as much time as an assertion.andP;  In 1987, D.P.andP;  Mirankerdescribed an alternative to Rete called TREAT that was intended in part tofix this problem: &quot;The primary disadvantage of Rete is that when a WME isremoved, the stored state must be unwound, often requiring the repetition ofthe precise sequence of operations that were performed upon its addition.&quot;andM;Essentially, TREAT works like Rete in the alpha nodes, but from the output ofthe alpha nodes the conflict set is reconstituted on each cycle.andP;  For typicalproduction systems, the better of the two algorithms is still unapparent.andO;One reason is that it's difficult to tell, from so few examples, what atypical production system is.andP;  However, in an application with a very highratio of deletions to assertions, using the TREAT algorithm would probably bea good idea.andM;The Rete algorithm is best suited to problems in which few changes anddeletions occur in each cycle.andP;  It would be ideal for programs such asgrammar-based generators that produce their results gradually andmontonically.andM;Rete isn't just a means of making fast OPS5 systems.andP;  Although Rete was firstdeveloped for the language, it can be used for a range of applications.andP;  Retenetworks are suitable for representing any database that changes, but changesslowly, and will be subject to the same queries repeatedly.andM;A great many problems meet these criteria.andP;  As a programming language, OPS5is neither beautiful nor widely useful; the Rete algorithm is both.andP;  Simplyput, Rete provides a way of storing a database in a form determined by thequeries to be made upon it.andM;Paul Graham is a former Ph.D.andP;  candidate in computer science at HarvardUniversity, Cambridge, Mass.andP;  He now lives in Italy.andM;All About OPSandM;If you found the information in this article useful, circle 77 on your readerservice card.andM;All About OPSandM;Two main versions of the OPS programming language are available.andP;  Both arebased on C. L. Forgy's work at Pittsburgh's Carnegie-Mellon University.andM;The first, and oldest, is OPS5, which Forgy placed in the public domain inthe late 1970s.andP;  It's been extended and reprogrammed by Digital EquipmentCorp., which offers it under the VAX/VMS operating system and DEC Windowsenvironment.andP;  The lowest-priced license for DEC's OPS5 is $6,000 for aVAXstation II.andP;  For more information, contact DEC's AI Marketing Group, 290Donald Lynch Blvd., Marlboro, Mass.andP;  01752, (508) 490-8344.andM;A later, but incompatible, version called OPS83 is available from ProductionSystems Technologies (PST).andP;  OPS83 has been ported to many hardwareplatforms, including Sun-3 and -4, HP/Apollo, VAX, and PC-compatibles.andP;  Thecompany plans to offer a Macintosh version in the near future.andP;  The leastexpensive way to get started with OPS83 is to obtain a $2,000 license for theIBM PC running under MS-DOS.andM;According to Forgy, PST's president and chief scientist, OPS83 uses a newervariant on the Rete algorithm called Rete II.andP;  It also supports not onlyrule-based programming but also procedural functions.andP;  More information aboutthe language is available from PST, 5001 Baum Blvd., Pittsburgh, Pa.andP;  15213,(412) 683-4000.andO;</TEXT></DOC>