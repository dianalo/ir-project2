<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-156-514  </DOCNO><DOCID>08 156 514.andM;</DOCID><JOURNAL>Dr. Dobb's Journal  Feb 1990 v15 n2 p76(11)* Full Text COPYRIGHT Mandamp;T Publishing 1990.andM;</JOURNAL><TITLE>Stalking GP faults: part II. (general-protection; includes relatedarticle on IBM mainframe error handling) (tutorial)</TITLE><AUTHOR>Schulman, Andrew.andM;</AUTHOR><SUMMARY>General protection (GP) faults caused by user code in a largeclass of programs can be caught when the programs are ported tothe protected mode of a MSDOS extender or the OS/2 operatingsystem.andP;  The protected mode enables GP fault handling to be ableto react to and recover from errors as they happen.andP;  A 32-bit GPfault interpreter is compiled with the Watcom C 7.0/386 Cprogramming language compiler and run under Phar Lap Software's32-bit386/DOS-Extender.andP;  A MetaWare High C 1.5 version of the GPfault interpreter is also developed.andP;  Code for both are presented.andO;OS/2 includes a kernel function, DosPTrace(), that enables anyOS/2 program to catch GP faults.andP;  The function is used in acontrol/event loop to detect GP faults.andM;</SUMMARY><DESCRIPT>Topic:     TutorialProgramming InstructionError HandlingInterrupt Handling32-BitOS-2MS-DOS.andO;Feature:   illustrationprogram.andO;Caption:   A sample session with a 32-bit version of the GP faultinterpreter. (program)An OS/2 message, different from a normal GP fault dump. (program)Detecting INT OC under OS/2. (program)andM;</DESCRIPT><TEXT>Stalking GP Faults: Part IIandM;Conventional wisdom says that when a protected-mode program commits ageneral-protection (GP fault) violation, it is &quot;evidence that the program'slogic is incorrect, and therefore it cannot be expected to fix itself ortrusted to notify the user o its ill health.&quot;andP;  This is a quote from OS/2'sprincipal architect, Gordon Letwin.andP;  In Part I of this article I tried toshow that this statement is false.andP;  For a large class of programs, whichexecute some form of &quot;user code&quot; or script (a programmable data base or aBasic interpreter with PEEK and POKE commands, for example), GP faults arecaused by the user code, not the program itself.andP;  An extra module should bewritten to catch GP faults when such programs are ported to protected mode(either through a DOS extender or OS/2).andM;In Part of this article, I showed how to catch GP faults under a 286-basedDOS extender such as Rational System's DOS016M.andP;  I used a rather silly &quot;GPfault interpreter,&quot; a program that allows the user to commit GP faults.andP;  Inthis article, I will show how to do the same thing using 32-bit C compilersand 386|DOS-Extender.andP;  Then I will show how GP faults can be caught under theOS/2 operating system on 16-bit machines.andP;  It is often said that GP faultscan't be caught under OS/2, but they can (and must!).andM;32-bit MS-DOSandM;Like a 16-bit DOS extender, Phar Lap Software's 386|DOS-Extender runs code inprotected mode, occasionally switching back to real mode to call MS-DOS orsome other real-mode service.andP;  In many ways, programming for this 32-bitenvironment is similar to 16-bit protected-mode programming.andM;There are important differences, however.andP;  In a 32-bit C compiler, such asMetaWare High C v. 1.5 for MS-DOS 386 or Watcom C 7.0/386, an int is a 4-bytequantity.andP;  A near pointer is also a 4-byte quantity.andP;  This means theprogrammer almost never have to deal with far pointers.andP;  When a segment takesa 4-byte offset, a program only needs one segment for all its data, andanother segment for code.andP;  Once loaded, DS and CS stay constant.andP;  In effect,this is a linear address space.andM;Though it is no longer needed for data and code, segmentation is stillessential for sharing and to enforce protection.andP;  In a DOS extender,segmentation is also needed for communicating with real-mode services.andP;  Onthose occasions, when both a segment and an offset are needed, a far pointeris a 6-byte quantity (an FWORD).andM;The basic difference between working in 32-bit versus 16-bit mode is thatthere are fewer restrictions.andP;  It takes longer for an int to overflow, theregisters (EAX, EBX, and so on) are twice as wide, there are more registers(FS, GS), and offsets can be so large that they are full-fledged addresses.andO;All these quantitative differences add up to a major qualitative change.andO;Some of the flavor of 386 protected-mode programming appears in a samplesession with a 32-bit version of the GP fault interpreter, compiled withWatcom C 7.0/386, and running under 386 | DOS-Extender, as shown in Figure 1.andM;Except for the extra 386 registers, Figure 1 resembles the DOS/16M GP Faultinterpreter shown in Part I.andP;  As in the 16-bit version, trying to poke atsegment 1234 failed, though this time the faulting instruction (EIP=00000111)was:andM;mov fs, dxandM;Trying to write into the program's code space also failed.andP;  The faultinginstruction at EIP=00000127 was:andM;mov fs:[ebx], esiandM;The last POKE command in Figure 1 succeeded, though.andP;  In 386|DOS-Extender,0x34 is a writeable data segment that maps the entire first megabyte ofmemory.andP;  The entire MS-DOS address space occupies a tiny portion of one 386protected-mode segment!andP;  Thus, 0034:000B80A0 is equivalent to the real-modeaddress B8000:00A0, and points into video display memory.andP;  Poking the integer0x70217021 into this address, after GPF386.EXP scrolls the screen, leaves tworeverse video (attribute 0x70) exclamation marks (char 0x21) in theupper-left corner of the screen.andM;Listing Four, page 112, is te Watcom C version of GPF386.C.andP;  Listing Five,page 112, is the MetaWare High C version.andP;  The object file produced by thecompiler is passed to Phar Lap's 386LINK.andP;  As the example shows, theresulting file, GPF386.EXP, runs under RUN386.andP;  Those who purchase aredistribution package from Phar Lap can bind RUN386 into a protected-modeapplication, thus producing the standaone executable file GPF386.EXE.andP;  Theprocess is similar in DOS/16M.andM;386|DOS-Extender requires Set Vector to handle 32-bit offsets; placing theaddress of a protected-mode interrupt handler in DS:EDX, or using EBX to holdthe entire address of a real-mode handler.andP;  MS-DOS INT 21 function 25 won'twork here, so Phar Lap provides its own.andM;Phar Lap makes INT 21 function 25, the gateway for all 386|DOS-Extendersystem calls.andP;  For example, AX=2504 is used to set a protected-mode interruptvector and AX=2505 is used to set a real-mode interrupt vector.andP;  Other386|DOS-Extender system calls let the programmer call a real-mode procedure,issue a real-mode interrupt, alias a segment, change the attributes for asegment, and so on.andM;Phar Lap provides several different system calls for setting interrupthandlers.andP;  The most useful one for catching GP faults is the &quot;Set Interruptto Always Gain Control in Protected Mode&quot; call (AX=2506).andP;  Because this callexpects the address of a protected-mode handler in DS:EDX, this is one ofthose times that DS has to temporarily change.andP;  The function setvect(), shownin Listings Four and Five, demonstrates this process.andM;High C provides a C interface file, msdos.cf, with declarations for calldos()and for a global Registers structure.andP;  This is similar to using intdosx() andunion REGS *r when accessing DOS from a Microsoft C or Turbo C program.andM;Watcom C7./386 goes further.andP;  Watcom C is a 32-bit compiler that is highlycompatible with the Microsoft C 16-bit standard.andP;  Watcom C's dos.' #includefile contains functions such as _dos_getvect() and _dos_setvect().andP;  Thesefunctions invoke Phar Lap system calls for protected-mode handlers.andP;  Such astheir Microsoft C equivalents, they use far pointers, except that a farpointer in Watcom C is 48 bits.andP;  Like the standard C library MS-DOSinterfaces, Watcom C7.0/386 includes the intdosx() function and union REGS*declaration, but these manipulate the 32-bit registers expected by386|DOS-Extender.andM;I didn't use these functions for the program shown in Listing Four.andP;  Instead,I used Watcom's #pragma aux, a high-level facility for inline machine code.andO;It is different from other machine-code.andP;  It is differnet from othermachine-code facilities, such as Turbo Pascal's dreaded inline(), whichreturns programmers to the days before there were even assemblers.andP;  One way#prama aux can be used is to specify how a function takes its parameters, andhow it returns a value to its caller.andP;  John Dlugosz discusses this facilityin his September 1989 DDJ review of Watcom C7.0.andP;  I will be discussing itsome more in a forthcoming DDJ review of Watcom's 7.0/386 compiler.andP;  ListingFour gives an extender example.andM;For the GP Fault interpreter, a segment and an offset must be merged into afar pointer.andP;  Because C does not have any built-in FWORD data types, it istrickly to write a 386 version of the MK_FP() macro.andP;  In High C, I set thesegment and offset portions of the far pointer separately, using the FP_SEG()and FP_OFF() macros in GPFAULT.H (see Listing Two in Part I).andP;  Watcom C7.0386 uses the #pragma aux facility to provide a 48-bit MD_FP() that isanalogous to the 32-bit MK_FP() macro provided in Turbo C.andM;there is one more area where Watcom C madeit a lot easier to port the GPFault interpreter to the 386 than did High C.andP;  While both Watcom C and High Chave facilities to write interrupt handlers, Watcom C pushes FS and GS ontothe stack of a 386 interrupt handler.andM;Catching OS/2 Faults with DosPTraceandM;Beause it runs in protected mode, OS/2 has ome resemblances to 16-bit DOSextenders.andP;  Except for system calls, code that runs in a DOS extender such asDOS/16M also runs under OS/2.andP;  Many features of OS/2 have nothing to do withMicrosoft, IBM, or OS/2 per se.andP;  They are features of Intel's 286.andP;  OS/2 isvery much a 286 operating system, even when running on a 386 machine.andO;Programming for OS/2 has more in common with programming for DOS/16M thandoes programming for 386|DOS-Extender.andM;There are, however, crucial differences between OS/2 and a DOS extender.andP;  ADOS extender is only a front-end to MS-DOS, whereas OS/2 is a full-fledgedoperating system.andP;  Because they made a clean break from DOS, rather thanextending it, OS/2's designers were able to junk the INT 21 interface.andP;  OS/2system calls are invoked by putting arguments on the stack, and doing a farCALL.andP;  No more stuffing registers.andM;With DOS extenders, INT 0D handlers are installed with INT 21, function 25.andO;In OS/2, interrupt handlers are installed by calling the DosSetVec()function.andP;  There is a problem, however: DosSetVec() only allows certainexceptions, and the GP fault isn't one of them.andP;  Another function,DosSetSigHandler(), might be expected to work or SIGSEGV, but it doesn't.andO;Even though Microsoft C for OS/2 includes SIGSEGV in andless;signal.handgt;, it doesn'tdo anything.andM;This is not an OS/2 but or oversight, but a conscious design decision and,some feel, an important design flaw.andP;  In his book Inside OS/2, Gordon Letwin,Microsoft's chief architect for system software, flatly states, &quot;Applicationscannot intercept general protection fault errors.andP;  ...  The OS/2 design doesallow almost any other error on the part of an application to be detected andhandled by that application.andP;  For example, 'Illegal filename' is an errorcaused by user input, not by the application.&quot;andM;This overlooks applications in which illegal memory accessis as easy for theuser as illegal file access.andP;  This is particularly ironic because, in otherrespects, OS/2 invites one to write such programming-on-the-fly environments.andO;I have heard that in the 386 version of OS/2 (OS/3?), DosSetVect() will allowinstallation of a normal interrupt handler for INT 0D.andP;  This is just a rumorand, in any case, OS/3 won't be available for some time.andM;In the meantime, there must be some mechanism in OS/2 to catch GP faults.andP;  Infact, there i such a mechanism and, if you've ever used protected-modeCode-View (CVP), you've probably seen it in operation.andP;  Take a buggyapplication such as the one at the beginning of this article and run it underCVP.andP;  Instead of OS/2 displaying its familiar GP fault register dump, CVPdisplays the message &quot;Segmentation violation.&quot;andP;  You can reassemble thefaulting instruction, or move different values into the registers, and resumeexecution.andM;If CodeView can catch GP faults, why can't we?andP;  I asked this question onCompuServe about a year and a half ago, when I was porting David Betz's XLISPto OS/2.andP;  Ray Duncan and Charles Petzold supplied the answer: Anything thatCVP can do, including catching GP faults, other OS/2 applications can alsodo.andP;  CVP is built on top of an OS/2 kernel function, DosPTrace(), and thisfunction -- the CodeView engine -- is available to all OS/2 programs.andP;  Thereare better OS/2debuggers than CVP, but these too are undoubtedly writtenusing DosPTrace.andM;Unix programmers will recognize that DosPTrace is process trace (ptrace()),used to implement breakpoint debuggers such ad sdb.andP;  In the &quot;bad old days&quot; ofthe $3000 OS/2 SDK, when developers asked for information on DosPTrace,Microsoft referred them to ptrace() in the Unix manual.andP;  Evan today, whileDosPTrace does appear in the OS/2 programmer's reference, the best source ofinformation about it is an untitled Microsoft document, PTRACE.DOC, which isavailable on a number of bulletin boards.andM;A process (usually a debugger) uses DosPTrace to trace another process.andP;  Towrite a program that can catch its own GP faults, though, I will useDosPTrace in a control/event loop.andP;  Using a technique devised by Ray Duncan,the GP Fault interpreter will run itself under DosPTrace.andP;  Unfortunately, onethread of a process running DosPTrace cannot trace another thread in the sameprocess, so the program is split into two processes.andP;  OS2TRACE.C appear inListing Six, page 114.andM;DosPTrace takes one parameter, a pointer to a PTRACEBUF.andP;  This structure isdeclared in n OS/2 header file, and is available if INCL_DOSTRACE appears ina #define directive before the #incude os2.h statement.andP;  A PTRACEBUF containsfields for all the 286 registers, fields to specify the process ID and threadID and, most importantly, a field used to issue DosPTrace commands and getback DosPTrace event notifications.andP;  Symbolic names for these commands andevents are in PTRACE.H (Listing Seven, page 115).andM;There are many DosPTrace commands, including SINGLE_STEP, WRITE_I_SPACE(write instruction space, that is, make code), WRITE_D_SPACE (write dataspace), and so on; the one used here, GO, simply runs the child process.andP;  Allthreads of the child process run until something &quot;interesting&quot; hapens.andP;  Atthat point, DosPTrace returns and the caller can see what event took place.andO;In Listing Six, naturally, I am mainly interested in EVENT_GP_FAULT.andM;There is very little performance overhead when a program is run underDosPTrace using the GO command (using SINGLE_STEP, the debugger would run asslowly as molasses).andP;  A GP fault, though, is a very expensive operation.andP;  Inone test under OS/2, I could only commit about 200 GP faults per second.andO;This is acceptable, because GP faults should take place infrequently.andM;When a user runs OS2TRACE, the program execs another instance of itself underDosPTrace and, using a command-line argument, tells this second process thatit is the second OS2TRACE process and therefore should run the GP faultinterpreter rather than the DosPTrace loop.andP;  If the user causes theinterpreter to fault, DosPTrace returns EVENT_GP_FAULT, and the processrunning DosPTrace detects that the interpreter process has GP faulted.andM;The DosPTrace process must communicate this fault back to the interpreterprocess, s that the interpreter can resume execution at a different CS:IP.andO;When the trace process detects a GP fault, it uses the DosPTraceWRITE_REGISTERS command to alter the CS:IP of the interpreter process.andP;  Whenthe tracer next tells the interpreter to GO, the interpreter resumes at a newlocation.andM;Where should the interpreter jump?andP;  In C, it is difficult to get the addressof an arbitrary line of code.andP;  Because there is no equivalent to the $location counter used in MASM and other assemblers, OS2TRACE.C uses theaddress of a parameterless function.andP;  This one-liner longjmps to theinterprter's top-level input loop.andP;  The trace process does not call thisfunction in the interpreter process.andP;  The tracer tels the interpreter to call(goto) this function.andM;Even though the two processes share the same code, they are differentprocesses.andP;  The tracer knows the address of this function in theinterpreter'saddress space because of OS/2's &quot;disjoint LDT space&quot; -- the code segmentcontaining this function is mapped to the same slot in each process's LocalDescriptor Table.andM;Despite this, in the program shown in Listing Six I decided to use stillanother DosPTrace command, SEG_NUM_TO_SELECTOR.andP;  Given a logical segmentnumber (such as that found in a .MAP file) and a process ID, this operationreturns the actual segment selector for the process.andP;  I know that thefunction catch_sig_segv() is in segment #1.andP;  In the trace process, thefunction send_sig_segv() first calls selector_from_segment() to get the newCS for the interpreter process, and then calls set_csip() to change theinterpreter's registers.andM;Being able to catch GP faults under OS/2 is still important even fordeveloping applications that do not run user code.andP;  Even for normalapplications where a GP fault is the sign of an internal bug, OS/2's GP faultregister dump is unattractive, makes little sense to most users, and can't beredirected to a file.andP;  The code in Listing Six can be modified to have the GPfault handler dump the register state to a file instead of attemptingrecovery.andP;  The DosPTrace READ_I_SPACE command can be used to disassemble thefaulting instruction at CS:IP.andP;  Then, if the program ever GP faults, it couldask the user to please send you this &quot;core dump&quot; file.andM;Faulting Inside OS/2 DLLsandM;Because OS/2 is a far richer and more complicated environment than a DOSextender, simple peeks and pokes are not an adequate test for catching GPfaults.andP;  What happens if the user of an OS/2 interpreter uses an illegaladdress while calling a routine in a dynamic link library (DLL), or whilemaking a DosXxx() call to the OS/2 kernel?andP;  Lugaru's Epsilon EMACS editor,OS2XLISP, UR/Forth, and the mini-interpreter I built in the November 1989 DDJ(&quot;Linking While the Program Is Running&quot;), are all OS/2 programs that let theuser call DLL routines at run time, and all can fall prey to theprotected-mode interpreter problem.andM;In the OS/2 GP fault interpreter in Listing Six, instead of poking ataddresses, the user types in a number from 0 to 7.andP;  Each corresponds to adifferent line of bad code.andP;  Figure 2 shows a sample session, with the linesof code appended as comments.andM;The first two pieces of bad code hold few surprises.andP;  In the first case, theNIL pointer (int far*) OL) was loaded into ES:BX, but trying to dereferenceit caused a GP fault.andP;  In the second case, trying to peek at ((int far*) -1L)faulted earlier: The processor refused to load ES with FFFF.andP;  The error codeis FFFC, not FFFF, because while one of these processor error codes lookslike a segment selector, the bottom two bits are used for other purposes.andM;The next piece of bad code does not cause a GP fault.andP;  I wanted this code toillustrate an attempt to poke the code segment.andP;  However, I coded the exampleincorrectly so that instead of faulting, it succesfully pokes an &quot;x&quot;somewhere in the data space.andP;  Strings that go first, and for the rest of thissession, the word &quot;violation&quot; is printed out as &quot;vxolation&quot; This illustratesthe limits of protection.andP;  The Intel processor was powerless to stop this&quot;vxolation&quot; of data space.andM;In the next example, a bad pointer is pased to VioWrtTTY().andP;  OS2TRACE detectsthat the fault took place inside DLL code.andP;  DLL code uses its own datasegment, but uses its caller's stack.andP;  Looking at the function set_csip() inListing Six.andP;  If, at the time of a GP fault, the interpreter process' doesnot equal SS, it means this small program was using someone else's DS.andP;  Thismeans DS must be reset to a proper value before resuming execution of theinterpreter.andP;  longjmp() can't be relied on to restore DS, because the jmp_bufitself resides in the process's data segment.andP;  Before the interpreter can runagain, DS must be pointed back to the correct data segment.andP;  This smallprogram did this by using SS, but in a larger program with multiple datasegments, the trace process probably would have to keep a list of valid datasegments.andM;In the final example, bad pointers are passed to an OS/2 kernel routine,DosGetInfoSeg().andP;  A GP fault is generated, but in this case OS2TRACE is notable to catch it.andP;  This is a limitation of DosPTrace(), not OS2TRACE.andP;  Ifthis same code is run under CVP, CVP won't catch the fault either.andP;  Instead,OS/2 displays a somewhat different message than its normal GP fault dump, asshown in Figure 3.andP;  All CVP can do is display the message &quot;Thread terminatednormally (13).&quot;andP;  The thread returns 0x0D to indicate that it has GP faulted.andO;It's a shame that OS2TRACE can't catch this fault, but it si somewhatconsoling that CVP can't either.andP;  This is a limitation of DosPTrace.andP;  AnyOS/2 debugger (such as Logitech's MultiScope) will undoubtedly have the samelimitation.andM;One line of bad code in OS2TRACE was not executed in the sample session.andO;VioWrtTTY(OL), in which I accidentally left off the last two arguments toVioWrtTTY, doesn't GP fault.andP;  Instead, it hangs OS/2!andP;  I have only found oneway to make this fault inside VioWrtTTY without hanging the machine, and thatis to single-step through the code in CVP.andP;  In that case, OS/2 detects INT0C, the stack exception, as shown in Figure 4.andP;  CodeView prints out &quot;Threadterminated normally (12).&quot;andM;ON ERROR and ESTAEandM;Having figured out how to use DosPTrace to catch most GP faults in OS/2, itbecomes clear that DosPTrace is a powerful part of OS/2 and could probably beused for all sorts of tricky programming.andP;  On the other hand, why is it somuch more difficult to catch GP faults in OS/2 than when using a DOSextender?andP;  Part of the reason is that OS/2 is a far more ambitiousundertaking than a DOS extender.andP;  A DOS extender doesn't have to worry aboutGP faulting inside a dynamic-link library, because DOS extenders don'tprovide dynamic linking.andM;The major reason for the difficulty, however, is that OS/2 does not providemuch support for exception handling by applications.andP;  This is surprising fortwo reasons.andP;  First, with Microsoft's predilection for Basic, one might haveexpected the company to at least provide OS/2 with something such as one ofBasic's most powerful features, ON ERROR (from the ON statement in PL/I).andO;Second, and more important, if anything from IBM was going to rub off onMicrosoft and OS/2, it should have been the strong emphasis on errorhandling, exception handling, and fault recovery found in large IBM operatingsystems.andP;  (See the sidebar, &quot;Lessons from History,&quot; for a brief discussion ofthe ESTAE and FRR error-handling facilities in IBM's MVS.)andM;In ConclusionandM;Having spent so much time talking about interrupts, errors, faults, traps,and exceptions, by now the reader must feel that protected mode is &quot;ThePromised Land of Error&quot; (the subtitle of a book that has nothing to do withIntel processors).andP;  Nonetheless, this discussion of catching GP faults hasonly scratched the surface of protected-mode interrupt handling.andP;  Forexample, this article never explained the difference between an exception andan interrupt.andP;  In addition to the standard Intel literature, three good booksfor more information on protected-mode programming are John H. Crawford andPatrick P. Gelsinger's Programming the 80386(Sybex, 1987), Edmund Strauss'sInside the 80286(Prentice-Hall, 1986), and Phillip Robinson's Dr. Dobb'sToolbook of 80286/80386 Programming(Mandamp;T Publishing, 1988).andM;Erros, exceptions, and faults are an extremely important part of programming.andO;One author distinguished between &quot;good&quot; exceptions and &quot;bad&quot; exceptions,saying that with good exceptions, &quot;the corrective actions you perform are anintegral part of your system&quot; and that good exceptions &quot;are the ones youexpect to occur,&quot; whereas bad exceptions indicate a program bug (Strauss,Inside the 80286).andP;  Using this definition, I hope I have shown that the GPfault can be a &quot;good&quot; exception, that many systems should expect it to occur,and that catching and recovering from it should be an integral part of many(but by no means all) systems.andM;Flexible, extensible systems don't need more error checking.andP;  They need errorhandling.andP;  The more flexible the system, the less it knows about the types itoperates on, and the less upfront checking it can do.andP;  Extensible systemsneed to be able to react to, and recover from errors after they happen, orafter some underlying system has detected them.andP;  Protected mode is such anunderlying system, and we should take advantage of it.andM;AvailabilityandM;All source code is available on a single disk and online.andP;  To order the disk,send $14.95 (Calif.andP;  residents add sales tax) to Dr. Dobb's Journal, 501Galveston Dr., Redwood City, CA 94063, or call 800-356-2002 (from insideCalif.) or 800-533-4372 (from outside Calif.).andP;  Please specify the issuenumber and format (MS-DOS, Macintosh, Kaypro).andP;  Source code is also availableonline through the DDJ Forum on CompuServe (type GO DDJ).andP;  The DDJ ListingService (603-882-1599) supports 300/1200/2400 baud, 8-data bits, no parity,1-stop bit.andP;  Press SPACEBAR when the system answers, type: listings(lowercase) at the log-in prompt.andM;Andrew is a software engineer in Cambridge, Mass., where he is writing anetwork CD-ROM server.andP;  Andrew can be reached at 32 Andrew St., Cambridge, MA02139.andO;</TEXT></DOC>