<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO> ZF32-165-103 </DOCNO><DOCID>10 649 410</DOCID><JOURNAL>Microsoft Systems Journal  May 1991 v6 n3 p115(17)* Full Text COPYRIGHT The Microsoft Corporation 1991.andM;</JOURNAL><TITLE>Learning Windows part VI: fonts, bitmaps, and printing. (MicrosoftCorp.'s Windows graphical user interface) (includes relatedarticles on Windows programming functions) (tutorial)</TITLE><AUTHOR>Adler, Marc.andO;AttFile:   MSJ\V06N03\WINTRO6.EXE;2 Program:  WINTRO6.EXE  Self extracting archive.andM;</AUTHOR><SUMMARY>Microsoft Corp's Windows 3.0 graphical user interface supportsdevice-dependent and device-independent bitmaps.andO;Device-independent bitmaps (DIBs) define the shape of an imageinstead of the physical organization of that image in thehardware.andP;  Windows uses the DIB format for all bitmap functionsincluding the mouse cursors and icons.andP;  Windows 2.X versions'bitmaps can be converted to the DIB format using Microsoft'sWindows Software Development Kit 3.0 (SDK).andP;  Users can createblank bitmaps as output devices that can be painted on using theWindows Graphics Device Interface (GDI).andP;  In addition to the fontsthat Windows supports, users can design their own fonts using theWindows SDK font editor.andP;  Windows supports most printers andfeatures a printer management facility called Spooler thatprevents more than one program from trying to access the printerat the same time.andM;</SUMMARY><DESCRIPT>Product:   Microsoft Windows 3.0 (Graphical user interface) (Programming)Microsoft Windows Software Development Kit 3.0 (Programdevelopment software) (Usage).andO;Topic:     Bit MappingFontsProgram Development TechniquesProgrammingTutorialComputer Graphics.andO;Feature:   illustrationprogram.andO;Caption:   Displaying a device-independent bitmap. (program)Two ways to request a font. (program)Enumerating fonts. (program)andM;</DESCRIPT><TEXT>Before Windows 3.0, all bitmaps were device-dependent.andP;  The internalrepresentation of the bits within the bitmap were closely tied to the outputde vice it was to be rendered on.andP;  Windows 3.o introduced device-independentbitmaps, which describe the appearance of an image rather than itsorganization in hardware.andM;This is the last article in the &quot;Learning Windows&quot;&quot; series.andP;  This installmentcompletes the discussion of the Microsoft(R) Windows Graphics DeviceInterface with bitmaps and fonts, explores the concepts involved in printing,and enhances the stock-charting application to take advantage of the Windows'print spooler.andM;If a Windows application needs to display any kind of pictorial information,you will most likely be dealing with bitmaps.andP;  A bitmap is simply a sequenceof bits that, rendered on an output device, represents a picture.andM;Bitmaps are either device-dependent or device-independent.andP;  Before WindowsVersion 3.0 was introduced, all bitmaps were device-dependent.andP;  The internalrepresentation of the bits within the bitmap were closely tied to thephysical output device it was to be rendered on.andP;  For instance, if an outputdevice used bit planes to represent color images, the bits in the bitmap hadto be organized in a series of planes.andM;Windows 3.0 (which still supports device-dependent bitmaps) introduceddevice-independent bitmaps (DIB).andP;  This kind of bitmap describes theappearance of an image rather than the physical organization of the image inhardware.andP;  The DIB format is used in Windows for all its own bitmapresources.andP;  This includes icons and mouse cursors.andP;  In fact, a specialconversion utility that comes with the Microsoft Windows Software DevelopmentKit Version 3.0 (SDK) converts Windows 2.x bitmaps to the device-independentformat.andM;You can create bitmaps (and icons and mouse cursors) with the SDKPaintprogram.andP;  Once you have made a bitmap, you can save it in a file with a BMPextension.andP;  A reference to this bitmap is then placed in an application'sresource file by using a statement such as this:andM;Clock BITMAP clock.bmpandM;When the resource file is compiled, a copy of the bitmap, along with all ofthe other resources, is put into the EXE file.andP;  The bitmap can then be usedby the application using the LoadBitmap function.andM;HBITMAP hbitmap;andM;hBitmap = LoadBitmap(hInstance, (LPSTR)  Clock&quot;):andM;The Windows GDI also allows you to create bitmaps on-the-fly.andP;  You can createa bitmap structure and actually hard-code the individual bits, but this istedious for anything other than very small bitmaps.andP;  You can also create ablank bitmap and use GDI functions to draw on it.andP;  In other words, you canmake the blank bitmap an output device that you can paint on.andM;Several functions allow you to create a blank bitmap.andP;  They return a handleto abitmap, just like the LoadBitmap function.andP;  CreateBitmap andCreateBitmapIndirect create device-dependent bitmaps.andP;  These functions shouldonly be used for monochrome bitmaps, since color bitmaps are at the mercy ofthe output device.andP;  The formats of these two functions are as follows:andM;hB!tmap = CreateB!tmap(nWidth, nHeight.andP;  nPlanes,andM;nBitCount, lpBits)andM;andandM;hBitmap = CreateBitmapIndirect(BITMAP FAR llpbitmap)andM;For example, to create an 8-by-8 bitmap of an arrow, you can use thefollowing code:andM;BYTE szArrow[] =andM;0x18      //   00011000andM;0x3C.andP;     //   00111100andM;0x7E,     //   01111110andM;0xFF,     //   11111111andM;0x18,     //   00011000andM;0x18,     //   00011000andM;0x18,     //   00011000andM;0x18      //   00011000andM;}HBITMAP hBitmap;andM;hBitmap = CreateBitmap(8, 8, 1.andP;  1, (LPSTR) szArrow):andM;Monochrome bitmaps are relatively device-independent.andP;  Most output devicessupport the concept that when a bit is on, the corresponding pixel isrendered in the default foreground color; and a bit that is off is renderedin the default background color.andM;A more popular way of creating an empty bitmap is to use theCreateCompatibleBitmap function.andP;  This function creates a bitmap whoseinternal format is compatible with a device associated with a device context.andO;To use this function, a device context must be obtained for the currentoutput device.andM;HDC hDC, hMemOC;andM;hDC = GetDC(hWnd);andM;Then a memory device context should be retrieved, so you can draw on thebitmap.andP;  This memory device context should be compatible with the outputdevice.andM;hMemDC = CreateCompatibleDC(hDC);andM;Next, an empty bitmap should be created that is compatible with the outputdevice.andP;  Assume that you want this bitmap to be 32-by-32 pixels.andM;HBITMAP hBitmap;andM;hBitmap = CreateCompatibleBitmap(hDC, 32, 32);andM;The first argument to CreateCompatibleBitmap is the device context that is tobe associated with the bitmap.andP;  Since this bitmap will be eventually renderedin a window, it should have the same format as the device on which the windowis displayed.andP;  The next two arguments are the width and the height of thebitmap.andP;  Both of these arguments expect the number of pixels, not bits.andP;  (Formonochrome bitmaps, the number of bits is equivalent to the number of pixels,but for color bitmaps, the numbers are different.)andM;The blank bitmap must then be associated with the memory device context.andO;When this is done, the bitmap becomes the drawing surface of the memorydevice context.andP;  Any output to the memory device context is reflected in thebitmap.andM;HBITMAP hOldBitmap;andM;hOldBitmap = SelectObject(hMemDC, hBitmap);andM;Since the bitmap is uninitialized, you must first set all the pixels to white(or some other color) before drawing on it.andM;PatBlt(hMemDC, 0,  0, 32, 32, WHITENESS);andM;The PatBlt function blasts a bit pattern to the device associated with thedevice context in the first argument.andP;  The arguments to PatBlt are thestarting coordinates, the width, and the height of the area to be drawn on.andO;The last argument is a raster operation code or ROP code for short.andO;WHITENESS tells PatBlt that white pixels should be copied to the outputdevice, overwriting any pixels that were previously in those positions.andO;Other ROP codes that can be used for this function are BLACKNESS (copy blackpixels to the destination bitmap), PATCOPY (copy the currently selected brushto the destination bitmap), PATINVERT (combine the current brush with thedestination bitmap using a logical XOR), and DSTINVERT (invert thedestination bitmap).andM;Now you can draw on the blank bitmap.andP;  Let's draw a large X.andM;MoveTo(hMemDC, 0, 0):andM;LineTo(hMemDC, 31, 31);  // two diagonal linesandM;MoveTo(hMemDC, 0, 31);andM;LineTo(hMemDC, 31, 0);   // make an XandM;A picture has been drawn on the bitmap, and the bitmap is in memory.andP;  Next,you need to transfer the bitmap from memory to the output device.andP;  The BitBltfunction does this.andM;All graphics engines have a function that moves bits from one area of memoryto another.andP;  The source bits can be combined with the bits already in thedestination in a number of ways.andP;  The ROP codes that were mentioned abovecontrol this combination.andP;  BitBlt is the Windows function that transfers abitmap from one device to another.andP;  In this case, the source device is achunk of memory and the destination device is the window where the bitmapwill eventually be rendered.andP;  The code to do this is below.andM;BitBlt(hDC, 0, 0, 32, 32, hMemDC, 0, 0, SRCCOPY); The first five arguments ofBitBlt consist of the handle of the destination device followed by thestarting coordinates and the size of the target.andP;  The next four arguments arethe handle of the source bitmap, its starting coordinates, and the ROP to beused.andP;  After the bitmap has been rendered, you must perform some cleanup.andO;You need to destroy the memory device context and release the window'sdisplay context back to the display context cache.andP;  Before you destroy thememory device context, you need to reassociate the old bitmap with it.andM;SelectObject(hMemDC,andM;hOldBitmap);andM;DeleteDC(hMemDC):andM;ReleaseDC(hWnd, hDC);andM;If you examine the arguments to BitBlt, you will notice that only one area isspecified.andP;  In other words, you specify a single rectangular area of bits tomove, and the bits within that area are transferred one-to-one from thesource bitmap to the destination bitmap.andM;Windows also allows you to move a rectangular area of bits from the sourcebitmap to a different-size area in the destination bitmap.andP;  For example, youcan display the 32by-32 bitmap, stored in the memory device context, in a256-by-256 area in the destination device.andP;  To do this, the bits in thesource bitmap must be stretched before the bitmap is splayed into thedestination area.andP;  The function that performs this expanding or shrinking isStretchBlt.andP;  This function is very similar to BitBlt, except that it has twoadditional parameters, the height and width of the source bitmap to transfer.andO;The following copies a 32by-32 bitmap to a 256-by-area.andP;  256andM;StretchBlt(hDC, 0, 0, 256.andP;  256, hMemDC, 0, 0, 32, 32,andM;SRCCOPY);andM;Part of the operation of StretchBlt is controlled by a member of the devicecontext structure, the stretching mode.andP;  If you stop to think about it,you'll realize that the stretching and shrinking operations must be performedvery carefully to preserve the appearance of the original bitmap.andP;  Thestretching mode helps StretchBlt determine which pixels to combine when abitmap is shrunk, and can be set by an application using theSetStretchBltMode function.andP;  The stretching mode can have three values, twoof which are important only for monochrome bitmaps.andP;  BLACKONWHITE, thedefault stretching mode, will logically AND together the bits of the bitmapthat are discarded with the retained bits.andP;  This preserves black pixels atthe expense of white pixels.andP;  The WHITEONBLACK mode preserves white pixels atthe expense of black ones by logically ORing together the eliminated bitswith the retained bits.andP;  If you are dealing with color bitmaps, you may wantto use the COLORONCOLOR mode.andP;  This mode simply deletes eliminated bits.andM;Device-independent BitmapsandM;In Windows 3.0, there are new GDI functions for use with DIBS.andP;  All thesefunctions can be identified by the letters DIB in the function name.andM;CreateDIBitmap and StretchDIBits are the DIB equivalents of CreateBitmap andStretchBlt.andP;  You can retrieve and set the bits in a portion of the bitmapusing the GetDIBits and SetDIBits functions.andP;  To display a DIB directly on anoutput device, call SetDIBitsToDevice.andM;These functions use either the BITMAPINFO structure or the BITMAPINFOHEADERstructure, which is actually part of the BITMAPINFO structure (see Figures 1and 2).andP;  As you can see, the BITMAPINFO structure contains two components, aheader that contains information about the color format and dimensions of thebitmap, and an array of color information.andP;  This array can contain actual RGBvalues for the bitmap or indexes into the palette currently used by theoutput device.andM;Let's say you want to create a function, displayDIBitmap, that will display adevice-independent bitmap in a window.andP;  There are several steps you mustfollow.andP;  You need to pass this function the handle of the window to draw on,a device context for that window, a global handle to the bits defining thebitmap, and the width and height of the bitmap.andP;  Assume that this is a16-color bitmap, meaning that it takes 4 bits to represent a single pixel.andM;DisplayDIBitmap first calls AllocateDefaultBitmap to allocate and initializea BITMAPINFO structure.andP;  This structure is filled with the dimensions and thecolor format information for a 16-color bitmap.andP;  A handle to the structure isreturned to DisplayDIBitmap, which then dereferences the structure.andM;To display the bitmap in the window, you simply call StretchDIBits orSetDIBitsToDevice.andP;  The latter function does not do any stretching orshrinking of the bitmap; it's similar to the BitBlt function in that respect.andO;If you want the bitmap to be displayed in the entire window, useStretchDIBits.andP;  The important thing is that you did not have to create anintermediate memory device context to transfer the bitmap to the outputdevice (see Figure 3).andM;There are certain limitations to be aware of when using DIBs.andP;  They can't beselected into device contexts.andP;  The various GDI graphical operations thattake an hDC as an argument, such as Rectangle, Ellipse, and TextOut, can'twork on DIBS.andP;  You must convert the DIB to a device-dependent bitmap, performthe operations, and convert back.andP;  However, this can result in a loss ofgraphical information.andP;  For instance, a 24-bit DIB loses information ifconverted to a 4-bit device-dependent bitmap and back.andP;  Fonts and Text OutputandM;Like most graphical user interfaces, Windows supports a variety of fonts.andO;Windows itself provides fonts such as Helvetica(R), Courier, Roman, andSymbol.andP;  Windows applications can contribute additional fonts to the existingbase, and if you own the Windows SDK or a compatible font editor, you candesign your own.andM;As previously discussed, the standard function for displaying text in aWindows application is TextOut.andP;  TextOut takes as arguments the handle to adisplay context, the logical coordinates at which the output should start,the string to display, and the string's length.andP;  A sample call to TextOut isshown below.andM;TextOut(hDC, 10, 300, &quot;Hello world&quot;.andP;  11);andM;The display context is important because it dictates the characteristics thatwill be applied to the written text.andP;  These characteristics include theforeground and background color of the text, the background writing mode(opaque or transparent), the intercharacter spacing, and the font to be used.andM;When a device context is obtained by using GetDC, the font associated withthe device context is the System font.andP;  The Windows 3.0 System font is aproportionally spaced (variable-width) font that consists of the ANSIcharacter set.andP;  If you call TextOut directly after a call to GetDC, you willsee an example of the System font.andP;  The default color scheme used by thedevice context is black characters on a white background.andM;HDC hDC;andM;hDC = GetDC(hWnd);andM;TextOut(hDC.andP;  10, 300, &quot;Hello world&quot;, 11);andM;// system font, black chars on whiteandM;ReleaseDC(hWnd, hDC);andM;A character cell in a raster font is really just a tiny bitmap comprised ofones and zeros.andP;  The outline of the character corresponds to the pixels setto 1 and the background of the character is the area where the pixels are setto 0.andM;Say that you are writing a terminal emulator and want to display greencharacters on a black background.andP;  The SetTextColor function lets you alterthe color of the foreground pixels (the pixels in the character that are 1),and the SetBkColor function changes the color of the background pixels (thepixels that are 0).andP;  The second argument to both functions is an RGB colorvalue.andP;  To produce green characters on a black background, you use thefollowing piece of code.andM;HDC hDC;andM;hDC = GetDC(hWnd);andM;SetTextColor(hDC, RGB(0x00, 0XFF, 0x00)); //greenandM;SetBkColor(hDC, RGB(0X00, 0X00, 0X00));   //blackandM;TextOut(hDC, 10, 300, &quot;Hello world&quot;, 11):andM;// system font, green chars on blackandM;ReleaseDC(hWnd, hDC);andM;Of course, the background color is pertinent only when the background mode isOPAQUE, not TRANSPARENT.andP;  OPAQUE is the default background mode of a defaultdisplay context.andP;  When the background mode is changed to TRANSPARENT, thepixels that are 0 inside the character bitmap are not written to the screen.andO;Whatever pixels were on the screen before are retained.andP;  You can set thebackground mode with a call to SetBkMode.andM;SetBkMode(hDC, TRANSPARENT);andM;Many applications only need to use the System font.andP;  But the judicious andcreative use of different proportional type styles and sizes can make yourWindows-based application snazzier, even when the application itself doesn'tspecifically require them (as would, say, a desktop publishing application).andO;Some programs on the other hand (like a terminal emulation program) probablyalways need to use a monospaced font, one where every character in the fontis the same width.andP;  If you need to scale the size of the font to the size ofthe window so that a fixed number of lines and characters per line can bedisplayed at all times regardless of window size, different-size monospacedfonts must be used.andP;  Logical FontsandM;There is a distinction to be made between physical and logical fonts.andP;  Alogical font is sort of a &quot;wish list&quot; of the characteristics that you want afont to have.andP;  For instance, you may want to display text in 24-point, bold,italicized Univers(R) font.andP;  This font is not standard in Windows (althoughit may be available in some third-party packages).andP;  In other words, there isno physical font that corresponds to the logical font you want to use.andM;Does this mean that your Windows program will crash if there is no 24-pointUnivers font installed? No.andP;  Windows attempts to map the request for alogical font into a request for one of the physical fonts installed in thesystem.andM;In order for this automatic mapping to occur, you must fill out a request fora logical font.andP;  Windows stores this request and returns a handle to yourapplication.andP;  When it's time to associate this font request with a devicecontext, Windows attempts to transform the request for a logical font into arequest for an existing physical font, using a mapping algorithm.andP;  It willtry everything it can to satisfy the request, including scaling andtransforming existing fonts to meet your requirements.andP;  The resulting fontmay or may not be exactly what was requested.andM;There are two functions that can be used to request a logical font.andP;  Usingthe CreateFont function, you dictate the properties of the logical font inone huge argument list.andP;  The CreateFontIndirect function requires a LOGFONTstructure as an argument.andP;  This structure contains the same information youpass as arguments to CreateFont.andM;Both functions make use of the data contained in a LOGFONT structure (seeFigure 4).andP;  Some of the fields in this structure are not commonly used (likethe IfEscapement and the IfOrientation fields) and can be set to NULL.andM;Say that you want to request a 10-point, boldfaced, Times&quot; Roman font.andO;Figure s shows two ways you can do it.andP;  Both functions return a handle to afont.andP;  These calls do not load any physical fonts.andP;  Windows initiates thisprocess when your application attempts to associate the hfont with the devicecontext-in other words, when the function SelectObject is called.andM;The following piece of code is the standard way of outputting text in anonsystem font.andM;HDC hDC;andM;HFONT hFont, hOldFont;andM;hDC = GetDC(hWnd);andM;hFont = CreateFontIndirect((LOGFONT FAR *)andM;andamp;lfTimesRomanBold_10x8);andM;hOldFont = SelectObject(hDC, hfont); // loading is doneandM;TextOut(hDC, 10, 300, &quot;Hello world&quot;, 11);andM;SelectObject(hDC, hOldFont);andM;DeleteObject(hFont);andM;ReleaseDC(hWnd, hDC);andM;The SelectObject function returns a handle to the previous object, in thiscase a handle to the system font.andP;  The handle to the Times Roman font isassociated with the handle to the display context, hDC.andP;  Any text output thatuses hDC is displayed in the new font.andM;After the string is written, the display context must be released back toWindows context cache.andP;  First you must disassociate the handle to the TimesRoman font from the display context.andP;  Do this by calling SelectObject again,this time passing it the handle of the old system font.andP;  There are lockcounts associated with the GDI objects that tell Windows whether or not anobject is in use.andP;  To release the resources allocated to a GDI object, youmust select back the original GDI object into the device context.andP;  Windowsthen reduces the object's lock count by one, making the object more eligibleto be freed.andM;Next, delete the logical font by calling DeleteObject.andP;  This is optional.andP;  Ifyou need to change fonts frequently in your application, you can keep thehandle to the logical font around.andM;For more information about font mapping, see the SDK Reference, Volume 1,Section 2.13.7, which contains some interesting information about thefont-mapping algorithm.andP;  It is a fascinating process, based on the idea thata certain number of penalty points are assigned to each font considered bythe mapping algorithm.andP;  Basically, points are assigned for eachcharacteristic of a physical font that doesn't match the characteristic ofthe logical font.andP;  The physical font with the fewest penalty points at theend wins! Obtaining Font informationandM;The Windows GDI contains functions that let an application obtain informationabout a font.andP;  Almost all of these functions are in the format GetText,Xxx.andM;The GetTextFace function returns the name of the current font.andM;char szFace[80];andM;GetTextFace(hDC, sizeof(szFace), (LPSTR) szface);andM;You can query the current colors and the background writing using theGetBkColor, GetTextColor, and GetBkMode functions.andM;COLORREF rgbBack, rgbText;andM;int iBkMode;andM;rgbBack = GetBkColor(hDC);andM;rgbText = GetTextColor(hDC);andM;iBkMode = GetBkMode(hDC);andM;Because applications often deal with proportionally spaced fonts, it's noteasy to compute how many pixels high and wide a given string is.andO;Fortunately, the GetTextExtent function does this for you.andP;  GetTextExtentreturns the dimensions of a given string using the current font.andP;  The heightis returned in the high-order word, and the width is in the low-order word.andM;DWORD dwDim;andM;WORD yheight, xWidth;andM;dwDim = GetTextExtent(hDC, (LPSTR) &quot;Hello World&quot;, 11);andM;yHeight = HIWORD(dwDim);andM;xWidth = LOWORD(dwDim);andM;Perhaps the most important font information function is GetTextMetrics.andP;  Thisfunction is used by almost every Windows application, even if it only usesthe System font during its lifetime.andP;  GetTextMetrics fills a TEXTMETRICstructure with information about the current font.andP;  The information containedin the TEXTMETRIC structure is different than the information contained inthe LOGFONT structure, because it relates to the physical font currently inuse, not the logical font (see Figure 6).andP;  The most important members of thisstructure are the fields pertaining to the width and height of the charactersin the font.andM;The TEXTMETRIC structure is very important because of the graphical nature ofWindows.andP;  Almost all programs write output to the screen, and this outputusually contains more than one line of information.andP;  How is the cursoradvanced to the next physical line of the screen in preparation for a newline of output? Normally, an application needs to output carriage return/newline characters after a line is written.andP;  If the application is using atext-based windowing system, it simply addresses the screen in charactercoordinates, where the width and height of each character is one unit.andP;  Theimportant thing is that in text mode the screen is addressed in characterunits, not pixel units.andP;  The height and width of every character is thesame-one unit.andM;In a graphical user interface, where the screen can be addressed in pixels,things work differently.andP;  Individual characters within a font can bedifferent widths and different heights.andP;  To make matters more complicated, acharacter can be aligned on any pixel.andP;  To prepare for a new line of output,you cannot simply tell the system to advance one unit down.andP;  You must figureout the pixel-based height of the current font, and advance vertically bythat many pixels.andP;  (Things get worse if you are using multiple fonts in asingle line and each font has a different size, but let's not consider thisadded complexity right now.)andM;Character height is one of the pieces of information contained in theTEXTMETRIC structure.andP;  To put font information in a TEXTMETRIC structure, usethe GetTextMetrics function.andM;TEXTMETRIC tm:andM;GetTextMetrics(hDC, (LPTEXTMETRIC)  tm);andM;Once this information has been retrieved, it is very simple to figure outwhere you should start the next line of output.andP;  The tmheight field containsthe height of each character cell.andP;  The tmExternalLeading measurement is thespace that the designer of the font suggests you insert between each row oftext.andP;  To figure out the next pixel position to advance to, you can use thefollowing simple equation:andM;yNextLine =yCurrentLine  tm.tmheight  tm.tmExternalLeadingandM;If you want to write several lines of text, you can use the following pieceof code as a template:andM;int yPos;andM;int yIncrement;andM;int iLine;andM;TEXTMETRIC tm;andM;GetTextmetrics(hDC,  (LPTEXTMETRIC) andamp;tm);andM;yIncrement =  tm.tmheight + tm.tmExternalLeading;andM;for (yPos =  iLine = 0; iline andless; nMaxLines;andM;yPos +=  yIncrement, iLine++)andM;{TextOut(hDC, 0, yPos, szText[iLine],andM;strlen(szText[iLine]));andM;}The variable iLine iterates through the lines of text contained in a buffer.andO;The variable yPos is used to keep track of the vertical pixel position thatthe current line of text should be started on.andP;  After a line of text has beenwritten, yPos is incremented to the next vertical text position.andP;  This loopcan be optimized if yPos is tested against the y coordinate of the bottom ofthe window.andP;  Otherwise, a lot of useless calls to TextOut might be made, asany text that extends past the bottom of the window will be clipped.andM;Enumerating FontsandM;A nice enhancement for any Windows application is the ability to select froma variety of typefaces and sizes.andP;  For example, in the stock-chartingapplication, the user should be able to choose both the typeface and the sizeof the characters in each stock graph's legend.andP;  To do this, you must findsome way of asking Windows for a list of all fonts supported by the outputdevice.andM;Fortunately, there is such a function, EnumFonts.andP;  Like most Windowsenumeration functions, you must give EnumFonts the address of a callbackfunction to call for each enumerated font.andP;  The information passed to thecallback function for each font supported includes a LOGFONT and a TEXTMETRICstructure that you can use to create and use the logical font.andM;The format of EnumFonts is as follows:andM;EnumFonts(hDC, lpFacename, lpFontFunc, lpData)andM;The second argument is a string specifying the name of the font to enumerate.andO;If this argument is NULL, Windows selects a single font for every typefacesupported by the output device, and enumerates that font.andP;  The thirdargument, lpFontFunc,  is  a FARPROC to the enumeration function.andP;  Like allcallback functions, it must be exported in the application's DEF file, andyou must use the MakeProcInstance function to create an instance thunk forthe callback function.andP;  The final argument is a 32-bit value that canrepresent some application-defined data (for example, a handle to a globalmemory block in which all of the font information will be stored).andM;The format of the application-defined enumeration function is as follows:andM;int FAR PASCAL FontFunc(lpLogFont, lpTextMetrics,andM;nFontType, lpdata)andM;The first two arguments are far pointers to the LOGFONT and TEXTMETRICstructures.andP;  The third argument, nFontType, is a bitmask indicating whetherthe font is a vector or a raster font and whether it is device-based orGDI-based.andP;  Finally, lpData is the value that was passed as the finalargument to the EnumFonts function.andM;The code in Figure 7 could be used to enumerate all the available typefacesand sizes.andP;  The trick is to use a single enumeration function with twodifferent functions invoking it-one for the typeface and one for the size.andO;The value in the lpData parameter tells the enumeration function that itshould process either the typeface name or the size data.andP;  The name of eachfont is stored in a mythical FontInfo structure along with a bitmaskrepresenting the point sizes available for that font.andP;  A bit in the bitmaskis set to I to indicate whether the font is available in that size; forexample, if a 10-point typeface is available, then bit 10 in the bitmask isset to 1.andP;  If you assume that a font will be at most 127 points high, you canuse an array of 16 bytes to represent all sizes.andM;Once you have compiled a list of typefaces and sizes, it is easy to put thisinformation in a list box or a multi-level pull-down menu and allow the userto select a certain font at any time.andP;  A mention must be made here of vectorfonts.andP;  Windows can scale a vector font to almost any size.andP;  Even if aspecific size for a vector font might not be listed, you can still create afont of any size that is not in the table.andM;Custom FontsandM;The Windows SDK Font Editor allows you to create customized fonts when youwant a totally new typeface for your application (see Figure 8).andP;  One reasonto create or edit a font is simply that existing fonts may not contain thecharacters needed.andP;  Consider the stock-charting application.andP;  Right  now, theonly way to represent fractional amounts is with a decimal point followed bythe decimal amount.andP;  The fraction five-eighths would be written as .625.andP;  Itwould be more aesthetically pleasing if this fraction were represented as asingle character.andP;  This bitmap would consist of the numeral 5 on top, a slashin the middle, and the numeral 8 beneath it.andM;The Font Editor comes with two FNT files that can be used as a basis for anew font.andP;  ATRM1111.FNT is a monospaced system font and VGASYS.FNT is aproportionally spaced font.andP;  To make the fractional characters, you couldmodify one of these files and replace some of the unused characters withfractions.andP;  In the ANSI character set, the first twenty or so charactersabove 127 are not really used.andP;  You could use the existing three ANSIfractional characters 1/4, 1/2, and 3/4 as a guide.andP;  The modified font shouldof course be saved under a new name.andM;A FNT file is not the same as a FON file.andP;  A Windows application can use aFON file but not a FNT file.andP;  Section 18.12 in the SDK Guide to Programmingoutlines the steps that will transform the font description contained in aFNT file to a FON file.andP;  First, you need to create a very short assemblylanguage file that will be compiled into an object file with no code and nodata.andP;  You also need to create an RC file containing a list of the FNT filesthat comprise the font.andP;  The linker creates a small EYE file from the dummyobject file, and then the resource compiler is used to insert the fontinformation into the EYE file.andP;  Then you rename the EXE file so that it has aFON extension.andP;  Once the new font is created, you can give all Windowsapplications access to it using the FONTS facility in the Windows ControlPanel.andM;If you want the new font to be associated only with your application, you canload the font at run time using the AddFontResource function.andP;  The followingcode loads a new font into the stock-charting application.andM;nFonts = AddFontResource(&quot;STOCK.FON&quot;);andM;SendMessage(0xFFFF, WM_FONTCHANGE, 0, 0L);andM;After the call to AddFontResource is made, a new font is added to the currentpool of fonts available in the Windows session.andP;  It's recommended that when afont is added or removed, your application notify all other applications.andO;You broadcast the WM_FONTCHANGE message to all the top-level windows by usingthe value FFFFH (or -1) as the window handle in the SendMessage call.andM;When your application terminates, it should remove any font resources thatwere loaded.andM;case WM_DESTROY:andM;RemoveFontResource(&quot;STOCK.FON&quot;);andM;SendMessage(0xFFFF.andP;  WM_FONTCHANGE, 0, 0L);andM;The RemoveFontResource function unloads a font resource if there are nooutstanding references to the font.andP;  Again, the WM_FONTCHANGE message shouldbe broadcast to all top-level windows.andM;Printing Under WindowsandM;If you have been programming in the PC environment for any length of time,you should be familiar with the two standard ways of directing output to theprinter.andP;  Printing can be done either at the DOS level or at the BIOS level.andO;At the DOS level, you would most likely use a piece of code like Figure 9.andO;This code is very prone to user error, because it does not check for printererror conditions, such as the printer not being ready, the printer being outof paper, and so on.andP;  If an error condition is detected, a DOS critical erroris generated, and your application will be interrupted by the ubiquitous&quot;Abort, Retry, Fail?&quot; message.andP;  Not a very pretty sight for a professionalprogram.andM;Alternatively, you can use BIOS INT 17H to bypass DOS and send outputdirectly to the printer.andP;  When you use the BIOS to print, your program mustuse extra code to check for printer error conditions.andP;  Most professionalprograms use the BIOS to insulate the user against such errors.andM;All this is fine if the user is running a single program.andP;  But under Windowsyou can run several programs simultaneously.andP;  What happens when two or moreprograms try to access the printer simultaneously? If a program is printing,will the other programs be frozen?andM;Windows provides a printer management facility called the Spooler.andP;  TheSpooler acts like a traffic cop, managing printer access.andP;  It also handlesany error conditions that might occur during the print job.andM;Another big problem for many applications developers is printer support.andO;There are hundreds of printers on the market and many of them use proprietaryescape sequences for control.andP;  It takes a tremendous effort and tremendoussupport costs for the average developer to support this vast array ofprinters.andM;Fortunately, Windows includes support for most printers.andP;  In fact, someprinter manufacturers themselves submit printer drivers to Microsoft forinclusion in the Windows environment.andP;  Once a printer driver has been writtenfor Windows, any Windowsapplication can use that printer with little or noextra programming effort.andM;Most of the grunt work for controlling printers is handled at the level ofthe printer driver.andP;  When an application uses GDI to draw output onto aprinter device context, GDI stores the drawing calls in a metafile on thehard disk.andP;  This metafile will then be &quot;played into&quot; the printer.andP;  Theprinter driver translates the GDI calls into control sequences that directthe printer to render the image.andM;Several steps are involved.andP;  The first is to obtain a device context for theprinter.andP;  This is not as simple as retrieving a device context for a window.andO;The application must determine which printers are installed and which ofthose the user wants to utilize for the print job.andP;  The only way to find outabout the installed printers is to examine the WIN.INI file.andM;In my WIN.INI file, I have the following lines:andM;andlsqb;windows]andM;...device=PCL / HP LaserJet,HPPCL,LPT1:andM;I also have the following lines a little further down:andM;andlsqb;devices]andM;PCL / HP LaserJet=HPPCL.LPT1:andM;PostScript Printer=PSCRIPT,NoneandM;The printer listed under the [windows] section is the currently activeprinter in my Windows environment.andP;  The printers listed under the [devices]heading are printers I can potentially use.andP;  In other words, I have printerdrivers for the HP* LaserJet&quot; and PostScript&quot; printers installed on my harddisk.andP;  I can use the Control Panel to activate any of them, or to add andremove other printers.andM;Assume that your application wants to use only the currently active printer.andO;The application has to go into the WIN.INI file and extract this printerinformation.andP;  A function called GetProfileString allows an application toextract information from the WIN.INI file.andP;  (Windows 3.0 also providesprivate profile functions that allow the user to modify and query arbitrarilynamed profile files.)andM;The three parameters to the  &quot;device=&quot; statement are the three values youneed for the CreateDC call that will be used for the printer device context.andO;You can use the code in Figure 10, which is from the SDK MULTIPAD program, tocreate the device context.andM;Now that you have a handle to the printer device context, you might betempted to start using the GDI to send output to the printer.andP;  Not quite yet!andO;What about the initialization sequence that was sent to the printer in theDOS printing routine in Figure 9? You need some way to initialize theprinter.andP;  Unfortunately, the Windows GDI does not have a function likePrinterInitialize.andM;As mentioned above, most of the interfacing between Windows and the printeris done by the printer device driver.andP;  Windows lets an applicationcommunicate directly to the device driver by means of the Escape functioncall.andM;nResult = Escape(hPrinterDC, nEscapeCode, nCount,andM;lpInData, lpOutData);andM;The nEscapeCode parameter is a numeric value that is passed to the devicedriver, directing it to perform some sort of action.andP;  (The escape codes arelisted in the SDK Reference Vol.andP;  2, Chapter 12.) The nCount parameterspecifies the number of bytes pointed to by the lpInData parameter.andP;  Thefinal two arguments, lpInData and lpOutData, are arbitrary 32-bit valueswhose contents depend on the escape code.andP;  Sometimes they are NULL, sometimesthey are pointers to strings, and sometimes they are pointers to structures.andM;An application must send the STARTDOC escape code to the printer driverbefore any new print job is started.andP;  Besides telling the printer driver toinitialize the printer, it informs the printer driver that all subsequentNEWFRAME escape calls should be spooled under the same job until the ENDDOCescape code is sent.andP;  This prevents documents more that one page long frombeing interspersed with other documents being printed simultaneously.andP;  Thefollowing call to Escape starts the print job on its way.andM;Escape(hPrinterDC, STARTDOC, strlen(szTitleofDoc),andM;(LPSTR) szTitleofDoc, NULL);andM;After the job has been started, you can use the Windows GDI calls to drawoutput on the printer.andP;  For instance, to write a line of text to the printer,the following line of code will suffice:andM;TextOut(hPrinterDC.andP;  col, row, &quot;Hello world&quot;, 11);andM;When a single page of output has been written to the printer, the applicationmust flush the page and start a new page by using the NEWFRAME escape code.andM;Escape(hPrinterDC, NEWFRAME, 0, NULL, NULL):andM;This directs the printer driver to play the accumulated contents of thedisk-based metafile into the printer driver.andM;The printer also advances to a new page.andP;  Calling NEWFRAME has the sideeffect of setting the printer device context back to its default values.andO;This means that if your application was using a different font, it mustselect that font back into the device context.andM;When the print job is finished, the application must use the ENDDOC escapecode to inform the printer driver that the job has terminated.andP;  This willcause any pending print jobs to commence printing.andM;Escape(hPrinterDC, ENDDOC, 0,andM;NULL, NULL);andM;Aborting a Print JobandM;Most Windows-based applications that perform lengthy print jobs (likePageMaker&quot; or Microsoft Word for Windows) let you abort the printjob.Thisisusuall done with some sort of dialog box that lets the user push abutton to abort the job.andP;  Adding an abort selection requires a specialWindows function known as an abort function.andM;An abort function is basically a standard Windows message loop.andP;  As you know,Windows is a nonpreemptive multitasking system.andP;  Other Windows applicationsget a chance to run when your application calls GetMessage or PeekMessage.andM;Say that your application was in a tight loop, printing out the contents ofyour latest novel.andP;  The following code illustrates this:andM;for  (iPage  =  1; iPage andless;= nTotalPages; iPage++)andM;{for  iLine  =  1;andM;i andless;= nTotalLines andamp;andamp; iLine andless;= nLinesPerPage;andM;i Line++)andM;TextOut(hPrinterDC, 0, y, szText[i],andM;strlen(szTextEil));andM;i++;andM;}Escape(hPrinterDC, NEWFRAME, 0, NULL, NULL);andM;}What happens if there is no space left on your hard disk to store theintermediate metafile? The spooler returns an error.andP;  But this does not meanthat the printjob must end--the spooler can still print if there is no diskspace left.andP;  The spooler, however, cannot be informed if you want to cancelthe print job, because it can't receive any messages.andP;  Your program is in atight loop and has not given other applications a chance at the CPU.andP;  It isdesirable, and often necessary, to give the other applications a chance toprocess their messages if you have a long printer operation going.andP;  The abortfunction takes care of this.andM;The abort proc must be exported from your application.andP;  As with any exportedfunction, this involves putting an entry for the function in the EXPORTSsection in the application's DEF file, and using MakeProcInstance to createan instance thunk for it.andP;  A special escape code, SETABORTPROC, is used toinform the printer driver about your abort function.andM;FARPROC lpAbortProc;andM;lpAbortProc = MakeProclnstance(AbortProc, hInstance);andM;Escape(hPrinterDC, SETABORTPROC, 0, lpAbortProc, NULL);andM;..   //  do printingandM;.FreeProcInstance(lpAbortProc);andM;The abort proc can be written like this:andM;int FAR PASCAL AbortProc ( hdc, reservedandM;HDC hdc;andM;WORD reserved;andM;{MSG msg;andM;/* Allow other apps to run, or get abort messages */andM;while (!fAbort andamp;andamp; PeekMessage(andamp;msg,NULL,NULL,NULL,TRUE))andM;if  (!hwndPDlg ||!IsDialogMessage(hwndPDlg,andamp;msg))andM;{TranslateMessage(andamp;msg):andM;DispatchMessage (andamp;msg);andM;}return  !fAbort;andM;}This is a standard message loop with two additional things thrown in.andP;  First,the fAbort variable controls whether the message loop will be run at all.andP;  Itis initially set to FALSE.andP;  The dialog box procedure for the Cancel Printingdialog box sets fAbort to TRUE if it detects that the user clicked on theCancel button.andP;  This is illustrated by the following code fragment:andM;switch (msg)andM;{case WM_COMMAND:andM;fAbort = TRUE;andM;break;andM;}The other thing to notice in the abort function's message loop is thestandard code to process messages for modeless dialog boxes.andP;  You need thisto ensure that a click on the Cancel button is directed to the dialog boxprocedure.andM;The scope of this article does not permit discussion of other printing topicssuch as banding, device modes and capabilities, and the internal devicedriver API.andP;  For information about them, see Programming Windows by CharlesPetzold (Microsoft Press, 1990).andP;  Another comprehensive source is theMicrosoft Windows Device Development Kit (DDK).andP;  You'll need a copy of theDDK if you want to write your own printer drivers.andM;The information given here, combined with the new printer code for thestock-charting application (see Figure 11), should satisfy most of yourprinting needs.andP;  The most important thing is that you do not have to worryabout all the different models of printers existing today.andP;  Because printersupport is handled for you automatically by Windows, it frees up asubstantial amount of your time and code.andM;Enhancements to STOCKandM;The stock-charting application developed in this series is by no means aproduction-quality piece of software.andP;  It merely serves as a guide todeveloping a standard MIS-related Windows application.andP;  Some Windowsfacilities that I haven't discussed could be used to improve thestock-charting application.andP;  I will briefly mention some of them.andM;Dynamic Data Exchange (DDE) is a message-passing protocol that allows two ormore Windows tasks to exchange information.andP;  DDE could be used to set up acommunications path between a spreadsheet supporting DDE and thestock-charting application.andP;  For example, after you enter stock quotes at theend of a day, you might want to do some what-if analysis on the stockportfolio.andP;  The stock-charting application could be used as a server of stockquotes to the spreadsheet acting as a client.andP;  Whenever the spreadsheet needsstock information for a particular stock on a particular day, it couldbroadcast a DDE message to all running Windows-based applications, asking ifthere were an application that could provide the information.andP;  If thestock-charting application were running, it could respond and start feedingquotes to the spreadsheet.andP;  It could even be configured to start a copy ofSTOCK if no other Windows application was able to provide this information.andM;Another modification might be a communications module.andP;  The Windows APIcontains functions to manage asynchronous communications.andP;  These could beadded to the stock-charting application so that on-line services could bedialed up to download stock quote information.andP;  An interesting feature wouldbe a DDE wrapper over the communications module so that another applicationcould direct the program to connect to the on-line service, download stockquotes, and feed the stock quotes into that application.andM;I have also ignored the Windows Clipboard.andP;  The Clipboard is used to passtext or graphical information among Windows-based applications.andP;  For example,if you wanted to insert a stock chart into the middle of a financial reportin PageMaker, you should be able to go into the stock-charting application,select a chart, and copy it into the Clipboard.andP;  Then you would return toPageMaker and paste the chart into your document.andM;The BITMAPINFO structure fully defines the dimensions and color informationfor a Windows 3.0 device-independent bitmap.andM;typedef struct tagBITMAPINFO {andM;BITMAPINFOHEADER  bmiheader;andM;RGBQUAD           bmiColors[1];andM;} BITMAPINFO;andM;The BITMAPINFO structure contains the following fields:andM;Field      DescriptionandM;bmiHeader  Specifies a BITMAPINFOHEADER data structureandM;that contains information about the dimensionsandM;and color format of a device-independent bitmap.andM;bmiColors  Specifies an array of RGBQUAD data structuresandM;that define the colors in the bitmap.andM;A Windows 3.0 device-independent bitmap consists of two distinct parts: aBITMAPINFO data structure that describes the dimensions and colors of thebitmap, and an array of bytes that define the pixels of the bitmap.andP;  The bitsin the array are packed together, but each scan line must be zero-padded toend on a LONG boundary.andP;  Segment boundaries can appear anywhere in thebitmap, however.andP;  The origin of the bitmap is the lower-left comer.andM;The biBitCount field of the BITMAPINFOHEADER structure determines the numberof bits that define each pixel and the maximum number of colors in thebitmap.andP;  This field may be set to any of the following values:andM;Value   MeaningandM;1     The bitmap is monochrome and the bmiColors field mustandM;contain two entries.andP;  Each bit in the bitmap arrayandM;represents a pixel.andP;  If the bit is clear, the pixelandM;is displayed with the color of the first entry inandM;the bmicolors table; if the bit is set, the pixelandM;has the color of the second entry  in the table.andM;4       The bitmap has a maximum of 16 colors, and theandM;bmiColors field contains up to 16 entries.andP;  EachandM;pixel in the bitmap is represented by a 4-bit indexandM;into the color table.andP;  For example, if the firstandM;byte in the bitmap is 1FH, the byte represents twoandM;pixels.andP;  The first pixel contains the color in theandM;second table entry, and the second pixel containsandM;the color in the 16th table entry.andM;8       The bitmap has a maximum of 256 colors, and theandM;bmiColors field contains up to 256 entries.andP;  In thisandM;case, each byte in the array represents a singleandM;pixel.andM;24      The bitmap has a maximum of 2 (24) colors.andP;  TheandM;bmiColors field is NULL, and each three bytes inandM;the bitmap array represents the relative intensitiesandM;of red, green, and blue, respectively, of a pixel.andM;The biClrUsed field of the BITMAPINFOHEADER structure specifies the number ofcolor indexes in the color table actually used by the bitmap.andP;  If thebiClrUsed field is set to 0, the bitmap uses the maximum number of colorscorresponding to the value of the biBitCount field.andP;  The colors in thebmiColors table should appear in order of importance.andM;Alternatively, for functions that use device-independent bitmaps, thebmiColors field can be an array of 16-bit unsigned integers that specify anindex into the currently realized logical palette instead of explicit RGBvalues.andP;  In this case, an application using the bitmap must calldevice-independent bitmap functions with the wUsage parameter set toDIB_PAL_COLORS.andM;The bmiColors field should not contain palette indexes if the bitmap is to bestored in a file or transferred to another application.andP;  Unless theapplication uses the bitmap exclusively and under its complete control, thebitmap color table should contain explicit RGB values.andO;</TEXT></DOC>