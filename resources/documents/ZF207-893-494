<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-893-494  </DOCNO><DOCID>07 893 494.andM;</DOCID><JOURNAL>AI Expert  Nov 1989 v4 n11 p42(8)* Full Text COPYRIGHT Miller Freeman Publications 1989.andM;</JOURNAL><TITLE>A faster embedded inference engine. (large-scale production systemwritten in OPS83)</TITLE><AUTHOR>Skapura, David M.andM;</AUTHOR><SUMMARY>Most expert-system applications are based on the LISP language,but a large-scale production system written in OPS83 is found tobe up to 10 times faster.andP;  The goal of one project was to create aflexible architecture of cooperating production systems thatimproved run-time performance of a large expert-system applicationby running parallel production systems concurrently.andP;  The embeddedinference engine was designed for implementation as a two-tieredhierarchy of cooperating production systems.andP;  The EIE wasdeveloped and coded in OPS83 from Production Systems TechnologiesInc, focusing on concurrent processing within a single-task,uniprocessor computer system.andP;  Benchmark testing found the systemto be faster than LISP-based systems.andM;</SUMMARY><DESCRIPT>Company:   Production Systems Technologies Inc. (products).andO;Product:   OPS83 (Computer program language) (usage).andO;Topic:     Expert SystemsEmbedded SystemsLarge-Scale SystemsParallelismTime Management.andO;Feature:   illustrationcharttable.andO;Caption:   Embedded inference engine architecture. (chart)Measured run-time performance. (table)andM;</DESCRIPT><TEXT>A FASTER EMBEDDED INFERENCE ENGINEandM;Many rule-based production system applications have been developed byuniversities and AI research and development laboratories.andP;  For the mostpart, all available expert-system applications have one thing in common: theLISP language.andP;  There are notable exceptions, including the machine-learningexpert-system applications created with an environment such as Radian Corp.'sRuleMaster.andP;  (1)  However, most production-system research and developmentfocuses on either a LISP machine running commercially availableproduction-system development tools, or a conventional computer systemrequiring a LISP interpreter and compiler on top of the operating system.andO;While this approach to AI applications development is satisfactory as a meansof determining feasibility or for proving new concepts, the overhead imposedon the application by the LISP environment precludes using production systemsin small computers that process information at real-time speeds.andM;Second, many large and complex applications that could utilize aproduction-system approach for information processing are limited by theinherently serial nature of a single inference engine.andP;  For example, amoderately sized production-system application might contain more than 200rules, with many different instantiations of each rule possible at any giventime.andP;  A traditional forward-chaining inference engine will, during everyrecognize/act cycle, examine something analogous to OPS5's conflict set (2)to select only one instantiation of a rule for execution.andP;  This procedurecreates a complex control problem for the real-time application developer:how does one guarantee the processing of high-priority information quicklywithout undermining the desired data-driven control strategy implicit in aproduction-system architecture?andM;Third, as the increasingly popular use of programming languages such as Adaillustrates, large problems must be partitioned into sets of smaller problemsthat can be addressed individually.andP;  Each of the solutions to the smallerproblems can then be written and tested by one of several programmers, withmodules later integrated to form a comprehensive solution.andP;  The successfulintegration of the independent modules is guaranteed as long as aprespecified module interface is not violated.andP;  Using context-sensitive rulesis the current technique of implementing this parallel approach to problemsolving in a production system environment.andP;  Unfortunately, this techniqueintroduces two new problems:andM;* The mechanism for specifying the desired context is performed as part ofthe action of another system rule.andP;  By performing the context switch in thismanner, high-priority data can be neglected due to the time the productionsystem needs to recognize that a context switch is necessary.andM;* There is no good technique for specifying the intercontext communicationinterface to guarantee that the different context-sensitive solutions can belater integrated into a comprehensive system.andM;As an attempt to address these three general problems, a production-systemarchitecture combining the advantages of rule-based inferencing with thecurrently accepted concepts of concurrent processing was designed andimplemented.andP;  The primary goal of this project was to create a versatilearchitecture of cooperating production systems that, among other things,improved the run-time performance of a large expert-system application byallowing the parallel production systems to run concurrently.andP;  While otherresearch has proven that parallel processing techniques implemented insoftware to speed up the pattern-matching process in forward-chainingproduction systems may have limited application, (3) the project's testresults indicate that a set of distributed, concurrent production systemssharing information can be very effective when used in complex andtime-critical data-analysis paradigms.andP;  Additionally, project resultsindicate that, consistent with the findings of still other studies, (4) thefunctional decomposition of large problems has practical value from aproduction system development viewpoint.andM;SYSTEM OVERVIEWandM;The embedded inference engine (EIE) is designed for implementation as atwo-tiered hierarchy of cooperating production systems (Figure 1).andP;  The toplevel expert system, or the system master, regulates the data flow betweenlower-level subsystems or between a second-tier subsystem and the userinterface.andP;  The system master also allocates the computer resources to thedifferent second-level subsystems on a case-by-case basis.andM;The lower-level expert subsystems behave similarly to traditionalexpert-system functions, each utilizing a specialized and domain-specificknowledge base.andP;  However, a significant advantage of the EIE's distributednature is that each of the second-tier systems can use its own,application-specific rule-selection strategy independently of every othersubsystem.andP;  This feature allows the application developer to tailor theinference system to the problem being addressed, rather than forcing theproblem to fit the solution.andM;LANGUAGE OF IMPLEMENTATIONandM;The EIE is designed and coded in OPS83 from Production Systems TechnologiesInc. (PST).andP;  This language provides several unique features critical to theEIE's design and implementation.andP;  These unique features include:andM;* A fully integrated procedural and rule-based syntax.andP;  Traditional codefunctions and procedures may be written by the application developer, using asyntax similar to C's, and then called from either the left hand side (LHS)or the right hand side (RHS) of any rule.andM;* The OPS83 system is a compiler, generating object-linkable code that can becombined with code written in a language other than OPS83, such as C or Ada.andM;* The Rete algorithm (5) for pattern matching is built into the OPS83run-time system, and the application developer can access the Rete networkwith predefined functions and procedures.andP;  This access is useful whenimplementing the recognize/act cycle for an OPS83 application, which unlikemost other commercially available production system tools, is notprespecified.andM;* The run-time performance of a production system written in OPS83 is five to10 times faster than the equivalent LISP-based production system (6) on thesame machine, providing a significant basis for real-time informationprocessing.andM;OPS83's most significant disadvantage is that while an application developedin OPS83 is 100% source code portable between machines for which an OPS83compiler is available, the variety of computers currently supported by PST issomewhat limited compared to the variety of machines that have C compilersavailable.andP;  Also, PST is the only known vendor for the product.andP;  However,these concerns will diminish as OPS83 becomes more popular.andM;CONTEXT DISCRIMINATIONandM;The EIE's design focuses on concurrent processing within a single-task,uniprocessor computer system.andP;  Unlike implementations of context-sensitiveproduction systems, the EIE does not depend on a rule within the knowledgebase to be executed to switch context.andP;  Each of the second-tier expertsystems can access the central processing unit (CPU) on a demand basis.andP;  Byperforming the context switch in this manner, each of the lower-levelproduction systems has the dedicated use of the CPU for a period of timeproportional to the relative priority of the task and the amount of work thesubsystem has to perform.andP;  As shown in Listing 1, the rule-selectionfunctions allow only those rules in the conflict set whose first pattern is acontext declaration matching the desired context name to be considered asvalid rules.andP;  Any rule with only one LHS pattern (the context specification)is always considered valid; rules with more than one LHS pattern areconsidered valid only once per instantiation.andM;With this strategy in mind, consider the operation of the Rete algorithm (7)in a forward-chaining production system.andP;  Designed to improve the efficiency,and therefore the run-time performance of the pattern-matching process thatall rule-based production systems must implement, the Rete algorithm exploitsthe temporal persistence of information occurring in most production systemapplications to create a network of tests that need only be executed whenworking memory changes.andM;Unfortunately, the efficiency provided by this network can be corrupted by anaive knowledge engineer.andP;  For example, if the rules in an expert-systemapplication are coded so that large numbers of working memory elements matchsuccessive LHS patterns, the network's efficiency declines.andP;  This declineresults from the increased CPU time required to discriminate between thesimilar patterns every time a working memory pattern is added or removed.andO;This condition can be corrected by the simple reordering of data patternswithin the rules.andP;  Another situation causing performance degradation is whenthe LHS patterns are ordered so that the earlier occurring patterns match thefrequently changing working memory elements.andP;  This condition is easilycorrected by adding several new types of working memory elements that can beused to discriminate between various conditions.andP;  These changes effectivelycause the network to become wider, shallower, and more stable, reducing thecomputer time required to identify the new conflict set during thepattern-matching process.andM;Therefore, to optimize the run-time performance of any Rete-based productionsystem, the application developer needs to consider the effect of the rulesbeing written on the Rete network.andP;  Unfortunately, this is a very difficulty,if not impossible, aspect of the knowledge engineering process, particularlywhen a large production system is implemented by several knowledge engineers.andM;The distributed EIE's design corrects this deficiency by creating anenvironment that automatically exploits the efficiency of the Rete algorithmfrom two perspectives.andP;  First, each of the second-tier subsystems mustimplement rules with a static pattern as the first LHS condition.andP;  Second,the number of working memory element types utilized by the applicationincreases, simply because each of the second-tier systems will likely use aset of working memory elements particular to the problem domain.andP;  Since eachof these subsystems are subcomponents of a larger production system, theEIE's distributed architecture encourages an application developer to utilizedifferent working memory types to solve the total problem in a structuredfashion, rather than writing complex rules that use only a few generalworking memory types.andP;  For these reasons, the Rete network created by adistributed EIE application is less dynamic and shallower than it mightotherwise be, and therefore more efficient at run-time.andM;Combining the run-time efficiency of the context-sensitive rule selectionfunction described earlier with how the EIE architecture exploits the Retealgorithm's efficiency, it becomes apparent why the distributed EIE designcan increase a large production system's execution speed.andP;  The increase isnot obtained by a more efficient pattern-matching process; rather, thedistributed EIE forces the application programmer to utilize the OPS83 Retenetwork in its most efficient mode.andM;Furthermore, because the context declarations are created in working memoryonly once (and never altered by the application), the context-discriminationprocess is reduced to a sequence of very efficient procedural tests performedby the rule-selection function, as compared to creating a new working memoryelement every time a context switch is necessary.andP;  This technique providesadditional run-time performance for an application; all the subsystems'completely instantiated rules will exist in the OPS83 conflict setsimultaneously.andP;  However, the rule-selection function will consider onlythose rules in the conflict set whose first pattern is instantiated by theworking memory element equivalent to the currently executing subsystem'sname.andM;CONCURRENT INFERENCINGandM;OPS83 offers a comprehensive interface between rules and procedural code.andO;Also, as indicated earlier, the EIE rule-selection strategy's design allows arule with only one LHS pattern to execute infinitely, allowing theapplication developer to specify a default behavior for a subsystem.andO;Combining these two characteristics with a rule selection strategy that, likethe means-end analysis strategy popular in OPS5, gives precedence to rulesinstantiated by more recent data elements and with a more specific LHS, therule-selection function enables the EIE master system to perform the contextswitching for the application while allowing it to perform other housekeepingfunctions for the entire application.andP;  To illustrate this ability, the mastersystem rule that controls the context activation process is in Listing 2.andM;In the distributed EIE design, the Run procedure for the master system is anindefinite loop, selecting and executing rules forever or until a systemerror or user input indicates a halt is necessary.andP;  Any rules applicable tothe master system other than the default rule are required to contain morethan one activation pattern.andP;  (The first pattern is used to allocate them tothe master system; subsequent patterns are used to identify under whatconditions the rules are valid.)andP;  This requirement provides two essentialfeatures to the EIE system: all the rules performing some specialized servicefor the master system take precedence over the default rule, forcing themaster to execute them before returning control to any second-tier subsystem.andO;Furthermore, all the master system rules other than the default rule willexecute only once per instantiation, while the default rule will executeforever when nothing is more urgent.andM;The EIE master system performs the context switch and control vector to thedifferent second-tier subsystems according to the algorithm indicatedpreviously in the RHS of the rule of Listing 2.andP;  From a master systemviewpoint, each of the lower-level subsystems are activated in turn, using aproprietary context-selection strategy via a call to the appropriate Runprocedure from the default master rule's execution of the RHS.andP;  Each of thesecond-tier subsystems must use a Run procedure that is a definite loop; thatis, no single subsystem within the EIE can be allowed to dominate the CPU andmust eventually return control to the master subsystem.andP;  The number of ruleseach subsystem is allowed to execute is passed from the RHS of therun__master rule to the appropriate Run procedure for the subsystem.andP;  Afterthe specified rules have fired or immediately after failing to find anyapplicable rules, the second-tier subsystem returns the CPU to the callingprocedure; in this case, control returns to the right hand side of therun__master rule.andM;After the master system run__master rule executes, the state of theproduction system may have changed due to the second-tier system's execution.andO;If the second-tier system altered the common working memory in a way thatvalidates another master system rule, the master system Run procedure willselect that new rule for execution rather than the default rule.andP;  Ifexecution of the second-tier system did not validate any other master systemrule, the master Run will select the run__master rule again, effectivelyselecting another subsystem for execution.andM;Switching contexts in this fashion provides an efficient means of allocatingthe CPU to higher priority tasks as they require it, while creating amechanism for eliminating data contention problems that typically plaguetruly parallel systems.andP;  The implementation of this context-switchingtechnique also serves to satisfy the second design goal for the EIE: theefficient allocation of computer resources for a production sysstemapplication in a single-processor, single-task operating system environment.andM;APPLICATION DEVELOPMENTandM;Currently accepted practices of large system design and implementation arebased on the concept of functional decomposition as defined by Yourdan andConstantine.andP;  (8)  This fact is illustrated by the emphasis the U.S.andO;government places on software interface specification independent of thesoftware implementation, a feature provided in Ada.andP;  However, mostcontext-sensitive production system implementations do not provide a means ofcreating lower-level software modules that must abide by a higher systemlevel interface specification.andM;This lack of structured production system design is addressed in the EIEsystem.andP;  First, the EIE design is created using OPS83.andP;  Among other things,OPS83 is strongly typed, both in the procedural and rule-based paradigms.andO;Objects manipulated by the OPS83 system must be declared at compile time astype specifications.andP;  The compiler enforces the type restrictions as anapplication is compiled, allowing the programmer to coerce types only in alimited fashion.andP;  This fact alone forces a production system applicationprogrammer to define all the working memory objects that the system will needbefore using them.andM;The implementation of the EIE interface protocol (required for thedistributed architecture) takes this structured approach to production systemdesign a step further.andP;  From an application development viewpoint, each ofthe second-tier expert systems can be developed independently, using onlytheir locally defined object types.andP;  However, a system developer using theEIE will be encouraged to develop and enforce a global set of data types sothat the second-tier subsystems can communicate with other second-tiersystems and the user.andP;  (Although the distributed production system in the EIEis really only one large OPS83 application, the master system contextcontains rules that specify how the second tier subsystems will communicate.)andO;The user interface is serviced only by rules in the master system, so anysecond-tier subsystem communicating with the outside world is required to doso by making a common working memory element for the master system toprocess.andM;The EIE is a software framework constructed in OPS83, and does not alter theOPS83 compiler in any way.andP;  For that reason, the EIE package cannot guaranteethat an application must utilize structured programming techniques.andP;  However,the distributed nature of the EIE provides an incentive for an applicationprogrammer to consider the intercontext data structures required to developthe application.andP;  Together with OPS83's strongly typed nature, this providesa vehicle for a structured approach to the development of large and complexproduction system applications, something that has not been considered in thepast.andM;EIE BENCHMARKING RESULTSandM;To analyze how much faster a large production system could execute using theEIE architecture as compared with more conventional AI techniques, abenchmark program was created in the Ford Aerospace AI laboratory to evaluatethe run-time performance of various production systems.andP;  The benchmark is anadaptation of the Heuristic Error Analyzer for Telemetry (HEAT) demonstrationexpert system developed to monitor space shuttle telemetry received inreal-time at NASA's Johnson Space Center.andP;  (9)andM;The system's baseline, which is the original HEAT system, was developed in1985 by Ford Aerospace using LISP and OPS5 on a Digital Equipment Corp. VAX11/780.andP;  Two other versions of HEAT, one written in OPS83 and one for the EIEdemonstration, were created from the original by translating the rules fromOPS5 to OPS83.andP;  Because the OPS83 environment is more robust than the OPS5one, several HEAT-specific procedural functions originally implemented inLISP to make OPS5 perform algorithmic analysis were discarded and completelyreimplemented.andP;  However, no functional changes were made to the knowledgeincorporated in the different versions of the system.andP;  The OPS83 rules, withonly the context selection pattern required by the EIE system changed, wereported directly to the EIE implementation.andM;Because HEAT's original design implemented a procedural control structurearound the inference engine to select the desired context, this structure waseliminated from EIE implementation.andP;  This deletion should not have had anyeffect on the performance of the different systems, because the control codeeliminated from the HEAT/OPS83 application was compensated for by the controlcode inherent in the EIE system.andM;All the implementations of the benchmark were executed simultaneously on theVAX as different timesharing tasks.andP;  This procedure minimized the variationsin computer performance caused by other timesharing or batch applications.andM;Finally, since the stated goal of this research was to determine a productionsystem architecture suitable for use in a microprocessor-based computersystem, the benchmark test was also performed using an unmodified IBM PC anda PC/AT with an internal CPU clock rate of 10 MHz.andP;  For the benchmarkapplication, 57 seconds of deliberately faulted space shuttle telemetryrecorded from an earlier flight was stored on the host computer in aLISP-compatible text file.andP;  All HEAT implementations were startedsimultaneously, with each system then being responsible for reading the dataas fast as possible while continuing to make inferences about the quality ofthe data simultaneously.andP;  The systems were expected to report errors found inthe data to a video terminal for user inspection, as well as recommendedcorrective action for the errors found.andP;  The results of this test aresummarized in Table 1.andM;NEW TECHNIQUESandM;As a result of the studies conducted and software developed in the course ofthis project, new techniques have been formulated that can be used to developand deliver large production systems for high speed, embedded microprocessorapplications.andP;  To this end, it is apparent that using a non-LISP-basedproduction system compiler such as OPS83 provides a significant advantagetoward increasing the run-time performance of a forward-chaining expertsystem.andM;Although parallel inferencing and cooperating expert systems may have limitedapplication in terms of delivering additional processing performance, theresearch documented in this article illustrates that an efficientimplementation of context switching in a production system environment haspractical value from at least two different perspectives.andP;  First of all, therun-time performance of a large production system application can be improvedat least twofold by combining concurrent processing techniques withcontext-sensitive production systems (with little required memory).andP;  Second,the modularity provided by a distributed production system architecture canbe used as a vehicle for controlling the development and test of large expertsystem applications.andM;REFERENCESandM;[1] Radian Corp. Rule-Master: A Software Tool for Building Expert Systems.andO;Jan. 1985.andM;[2] Brownston, L., E. Kant, R. Farrell, and N. Martin.andP;  Programming ExpertSystems in OPS5: An Introduction to Rule-Based Programming.andP;  Reading, Mass.:andO;Addison-Wesley, 1985.andM;[3] Forgy, C..L., A. Gupta, A. Newell, and R. Wedig.andP;  &quot;Initial Assessment ofArchitectures for Production Systems,&quot; Proceedings of AAAI-84, pp.andP;  116-120.andM;[4] Bender, M.andP;  &quot;Distributed Expert Systems for C3I,&quot; Ford Aerospace andCommunications Corp., Western Development Laboratory, Palo Alto, Calif.,andO;1985.andM;[5] Forgy, C.L.andP;  OPS83 User's Manual and Report.andP;  Production SystemsTechnologies Inc., Pittsburgh, Pa., 1985.andM;[6] Brekke, R.L.andP;  &quot;Benchmarking Expert System Tool Performance,&quot; FordAerospace and Communications Corp., Space Information Systems Operation,Houston, Texas, August 1986.andM;[7] Forgy, C.L.andP;  &quot;Rete: A Fast Algorithm for the Many Pattern/Many ObjectPattern Match Problem.&quot;andP;  Artificial Intelligence 19, September 1982, pp.andO;17-37.andM;[8] Yourdan, E., and L. Constantine.andP;  Structured Design.andP;  Englewood Cliffs,N.J.: Yourdan Press, 1978.andM;[9] Skapura, D.M., and D.R.andP;  Zoch.andP;  &quot;A Real-Time Production System forTelemetry Analysis,&quot; Instrument Society of America, Proceedings of the 1986Robotics and Expert Systems Conference, Houston, Texas, Paper #86-0635, pp.andO;253-260.andM;David M. Skapura works at Ford Aerospace, Houston, Texas, and has contributedto a variety of computer-system design and implementation projects to provideautomatic ground-control systems for Johnson Space Center.andP;  He served as leadtechnical engineer for the design of the distributed EIE in 1987.andO;</TEXT></DOC>