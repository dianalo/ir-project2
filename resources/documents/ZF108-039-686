<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-039-686  </DOCNO><DOCID>08 039 686.andM;</DOCID><JOURNAL>Communications of the ACM  Jan 1990 v33 n1 p54(10)* Full Text COPYRIGHT Association for Computing Machinery 1990.andM;</JOURNAL><TITLE>An incremental constraint solver. (DeltaBlue algorithm)(technical)</TITLE><AUTHOR>Freeman-Benson, Bjorn N.; Maloney, John; Borning, Alan.andM;</AUTHOR><SUMMARY>DeltaBlue, a fast algorithm for satisfying dynamically changingconstraint hierarchies, is discussed.andP;  A constraint hierarchy is aset of relations that should be satisfied that has all of therelations labeled according to strength.andP;  Constraint applicationsinclude geometric layout, simulations, and design and analysisproblems.andP;  They can be used to specify very difficult problems,necessitating increasingly powerful algorithms.andP;  DeltaBlue is anincremental constraint solver; it maintains a 'current solution'to the constraints which evolves as the program executes.andP;  The'walkabout' strength of a constraint is that arrived at byexamining only its immediate operands.andP;  The effects of adding andremoving constraints when using DeltaBlue are described.andO;DeltaBlue can be proved correct by showing that any solution itgenerates is a locally-predicate-better solution.andM;</SUMMARY><DESCRIPT>Topic:     AlgorithmsNew TechniqueTechnologyMathematical LogicHierarchical Organization.andO;Feature:   illustrationchart.andO;Caption:   Removing a constraint. (chart)Walkabout strength. (chart)Adding a constraint. (chart)andM;</DESCRIPT><NOTE>Only Text is presented here; see printed issues for graphics.andO;</NOTE><TEXT>An Incremental Constraint Solver A constraint describes a relation thatshould be satisfied.andP;  Examples of constraints include:andM;* a constraint that a line on a computer display be verticalandM;* a constraint that a resistor in a circuit simulation obey Ohm's LawandM;* a constraint that two views of the same data remain consistent (forexample, bar graph and pie chart views).andM;Constraints are useful in programming languages, user interface toolkits,simulation packages, and other systems because they allow programmers orusers to state declaratively a relation that is to be maintained, rather thanrequiring them to write procedures to maintain the relation themselves.andO;Constraints are normally multidirectional.andP;  For example, a constraint that c= a + b might be used to find a value of one of a, b, or c.andP;  In general theremay be many interrelated constraints in a given application; it is left up tothe system to sort out how they interact and to keep them all satisfied.andM;In many applications, it is useful to be able to state both required andpreferential constraints.andP;  The required constraints must hold.andP;  The systemshould try to satisfy the preferential constraints if possible, but no errorcondition arises if it can not.andP;  In the work presented here, we allow anarbitrary number of levels of preference, each successive level being moreweakly preferred than the previous one.andP;  The set of all constraints, bothrequired and preferred, labeled with their respective strengths, is called aconstraint hierarchy.andM;As one example of using constraint hierarchies, consider the problem oflaying out a table in a document.andP;  We would like the table to fit on a singlepage while still leaving adequate white space between rows.andP;  This can berepresented as the interaction of two constraints: a required constraint thatthe height of the blank space between lines be greater than zero, and apreferred constraint that the entire table fit on one page.andP;  As anotherexample, suppose we are moving a part of a constrained geometric figurearound on the display using the mouse.andP;  While the part moves, other parts mayalso need to move to keep all the constraints satisfied.andP;  However, if thelocations of all parts are not determined, we would prefer that they remainwhere they were, rather than flailing wildly about.andP;  Further, there may bechoices about which parts to move and which to leave fixed; the user may havepreferences in such cases.andP;  Again, constraint hierarchies provide aconvenient way of stating these desires.andM;We have been using the expressive power of constraint hierarchies to definethe behavior of user interfaces [29].andP;  In user interface applications, notonly does the constraint hierarchy change frequently, but the constraintsolver must be capable of finding solutions without reducing the directmanipulation responsiveness.andP;  The incremental constraint solver described inthis article exploits the fact that the user's actions often have only localeffects on the constraint hierarchy.andP;  In this case, it is more expedient tomaintain an evolving solution, making only minor changes to this solution asconstraints are added and removed, than it is to solve the constrainthierarchy from scratch every time.andM;For example, consider the simple music editor in Figure 1.andP;  The location ofeach note is determined by the following constraint hierarchy:andM;Required ConstraintsandM;1.andP;  The vertical position of the note is related to the note's pitch and theclef of the staff on which the note appears.andP;  (The pitch coordinate system isdifferent for the treble and bass clefs.)andM;2.andP;  The vertical position of the note on the staff determines the note's stemdirection.andM;3.andP;  The horizontal position of the note relative to the start of the staff isproportional to its starting time.andM;4.andP;  The starting time of a note is equal to the starting time of the previousnote on the staff plus the previous note's duration.andP;  The starting time ofthe first note on each staff is zero.andM;Default ConstraintsandM;5.andP;  A note's duration, pitch, and position remain the same (when other partsof the score are edited).andM;These are the basic layout constraints for a musical score.andP;  As the usermanipulates the score, constraints are added dynamically in response todragging notes with the mouse.andP;  Two constraints are added for each note beingdragged:andM;Preferred ConstraintsandM;6.andP;  The horizontal position of the note relative to the start of the staff isrelated to the horizontal position of the mouse.andM;7.andP;  The pitch of the note is related to the vertical position of the mouse.andM;As the notes are dragged, the constraint interpreter alternates calls to thesolver to satisfy all satisfiable constraints, and calls to the displayupdate routine.andP;  Because constraints 6 and 7 are stronger than constraint 5,the notes will track the mouse, and because constraints 1-4 are required, thescore graphics will remain consistent with the music produced.andP;  When themouse button is released, the dynamic constraints are removed and the systemis ready for the next user action.andM;Although the actual layout conventions for musical typesetting areconsiderably more involved, this example does illustrate how simpleconstraints can be used to easily determine complex behavior in a userinterface.andM;Related WorkandM;Much of the previous and related work on constraint-based languages andsystems can be grouped into five areas: geometric layout; simulations;design, analysis, and reasoning support; user interface support; andgeneral-purpose programming languages.andM;Geometric layout is a natural application for constraints.andP;  The earliest workhere is Ivan Sutherland's Sketchpad system [40], developed at MIT in theearly 1960s.andP;  Sketchpad allowed the user to build up geometric figures usingprimitive graphical entities and constraints, such as point-on-line,point-on-circle, collinear, and so forth.andP;  When possible, constraints weresolved using one-pass techniques (first satisfy this constraint, thenanother, then another, .andP;  .  .).  When this technique was not applicable,Sketchpad would resort to an iterative numerical technique, relaxation.andO;Sketchpad was a pioneering system in interactive graphics and object-orientedprogramming as well as in constraints.andP;  Its requirements for CPU cycles anddisplay bandwidth were such that the full use of its techniques had to awaitcheaper hardware years later.andP;  ThingLab [2, 3] adopted many of the ideas inSketchpad, and combined them with the extensibility and object-orientedtechniques of the Smalltalk programming language [17].andP;  Later versions ofThingLab incorporated such features as constraint hierarchies (as describedin this article), incremental compilation, and a graphical facility fordefining new kinds of constraints [1, 4, 13, 29].andP;  Other constraint-basedsystems for geometric layout include Juno by Greg Nelson [33], Magritte byJames Gosling [18], and IDEAL by Chris Van Wyk [45, 46].andM;Simulations are another natural application for constraints.andP;  For example, insimulating a physics experiment, the relevant physical laws can berepresented as constraints.andP;  In addition to its geometric applications,Sketchpad was used for simulating mechanical linkages, while ThingLab wasused for simulating electrical circuits, highway bridges, and other physicalobjects.andP;  Animus [9] extended ThingLab to include constraints on time, andthus animations.andP;  With it, a user could construct simulations of suchphenomena as resonance and orbital mechanics.andP;  Qualitative physics, an activearea of artificial intelligence (AI) research, is concerned with qualitativerather than quantitative analysis and simulation of physical systems [43].andO;Most such systems employ some sort of constraint mechanism.andM;Related to simulation systems are ones to help in design and analysisproblems.andP;  Here, constraints can be used to represent design criteria,properties of devices, and physical laws.andP;  Examples of such systems includethe circuit analysis system EL by Stallman and Sussman [37], PRIDE [30], anexpert system for designing paper handling systems, and DOC and WoRM [34] byMark Sapossnek.andP;  In [39] Sussman and Steele consider the use of constraintnetworks for representing multiple views on electrical circuits.andP;  TK!Solver[24] is a commercially available constraint system, with many packages forengineering and financial applications.andP;  Levitt [27] uses constraints in avery different design task, namely jazz composition.andP;  Finally, there has beenconsiderable research in the AI community on solving systems of constraintsover finite domains [28].andP;  Two typical applications of such constraintsatisfaction problems (CSPs) are scene labeling and map interpretation.andM;Constraints also provide a way of stating many user interface designrequirements, such as maintaining consistency between underlying data and agraphical depiction of that data, maintaining consistency among multipleviews, specifying formatting requirements and preferences, and specifyinganimation events and attributes.andP;  Both ThingLab and Animus have been used inuser-interface applications.andP;  Carter and LaLonde [6] use constraints inimplementing a syntax-based program editor.andP;  Myers' Peridot system [32]deduces constraints automatically as the user demonstrates the desiredappearance and behavior of a user interface; a related system is Coral [41],a user-interface toolkit that uses a combination of one-way constraints andactive values.andP;  Vander Zanden [42] combines constraints and graphics withattribute grammars to produce constraint grammars; his system includes anincremental constraint satisfier related to the one described in thisarticle.andP;  Ege [10,11] built a user-interface construction system that used afilter metaphor: source and view objects were related via filters, which wereimplemented as multiway constraints.andP;  Filters could be composed, bothend-to-end and side-by-side, so that more complex  interface descriptionscould be built from simpler ones.andP;  Epstein and LaLonde [12] use constrainthierarchies in controlling the layout of Smalltalk windows.andM;Finally, a number of researchers have investigated general-purpose languagesthat use constraints.andP;  Steele's Ph.D.andP;  dissertation [38] is one of the firstsuch efforts; an important characteristic of his system is the maintenance ofdependency information to support dependency-directed backtracking and to aidin generating explanations.andP;  Leler [26] describes Bertrand, a constraintlanguage based on augmented term rewriting.andP;  Freeman-Benson [14] proposes tocombine constraints with object-oriented, imperative programming.andM;Much of the recent research on general-purpose languages with constraints hasused logic programming as a base.andP;  Jaffar and Lazzer [22] describe a schemeCLPI (D) for Constraint Logic Programming Languages, which is parameterizedby D, the domain of the constraints.andP;  In place of unification, constraintsare accumulated and tested for satisfiability over D, using techniquesappropriate to the domain.andP;  Several such languages have now been implemented,including Prolog III [7], CLP(R) [19,23] and CHIP [8,20].andP;  Most of thesesystems include incremental constraint satisfiers, since constraints areadded and deleted dynamically during program execution.andP;  CLP(R), for example,includes an incremental version of the Simplex algorithm, while CHIP includesan incremental satisfier for constraints over finite domains.andP;  Reference [5]describes a scheme for Hierarchical Constraint Logic Programming languages(HCLP), which integrate CLP(D) with constraint hierarchies, and reference[44] presents an interpreter for HCLP(R).andP;  Saraswat's Ph.D.andP;  dissertation[35] describes a family of concurrent constraint languages, again with rootsin logic programming.andM;TheoryandM;A constraint system consists of a set of constraints C and a set of variablesV.andP;  A constraint is an n-ary relation among a subset of V.andP;  Each constrainthas a set of methods, any of which may be executed to cause the constraint tobe satisfied.andP;  Each method uses some of the constraint's variables as inputsand computes the remainder as outputs.andP;  A method may only be executed whenall of its inputs and none of its outputs have been determined by otherconstraints.andM;The programmer is often willing to relax some constraints if not all of themcan be satisfied.andP;  To represent this, each constraint in C is labeled with astrength.andP;  One of these strengths, the required strength, is special, in thatthe constraints it labels must be satisfied.andP;  The remaining strengths allindicate preferences of varying degrees.andP;  There can be arbitrary number ofdifferent strengths.andP;  We define [C.sub.0] to be the required constraints inC, [C.sub.1] to be the most strongly preferred constraints, [C.sub.2] thenext weaker level, and so forth, through [C.sub.n], where n is the number ofdistinct non-required strengths.andM;A solution to a given constraint hierarchy is a mapping from variables tovalues.andP;  A solution that satisfies all the required constraints in thehierarchy is called admissible.andP;  There may be many admissible solutions to agiven hierarchy.andP;  However, we also want to satisfy the preferred constraintsas well as possible, respecting their strengths.andP;  Intuitively, the bestsolutions to the hierarchy are those that satisfy the required constraints,and also satisfy the preferred constraints such that no other better solutionexists.andP;  (There may be several different best solutions).andM;To define this set of solutions formally, we use a predicate &quot;better,&quot; calledthe comparator, that compares two admissible solutions.andP;  We first define[S.sub.0], the set of admissible solutions, and then the set S of bestsolutions.andM;[S.sub.0] = {x | *c * [C.sub.0] x satisfies c} S = {x | x * [S.sub.0] [and]*y * [S.sub.0] *better(y, x, C)}andM;A number of alternate definitions for comparators are given in [5].andP;  Thesecomparators differ as to whether they measure constraint satisfaction usingan error metric or a simple boolean predicate (satisfied/not satisfied).andO;Orthogonally, they also differ as to whether they compare the admissiblesolutions by considering one constraint at a time, or whether they take someaggregate measure of how well the constraints are satisfied at a given level.andO;Comparators that compare solutions constraint-by-constraint are local; thosethat use an aggregate measure are global.andP;  Examples of aggregate measures arethe weighted sum of the constraint errors, the weight sum of the squares ofthe errors, and the maximum of the weighted errors.andM;The algorithm presented in this article finds solutions based on thelocally-predicate-better comparator.andP;  This is a local comparator that uses asimple satisfied/not satisfied test.andP;  This comparator finds intuitivelyplausible solutions for a reasonable computational cost.andP;  Its definition is:andM;Solution x is locally-predicate-better than solution y for constrainthierarchy C if there exists some level k such that: for every constraint c inlevels [C.sub.1] through [C.sub.k-1], x satisfies c if and only if ysatisfies c, and, at level [C.sub.k], x satisfies every constraint that ydoes, and at least one more.andM;By definition, S will not contain any solutions that are worse than someother solution.andP;  However, because better is not necessarily a total order, Smay contain multiple solutions, none of which is better than the others.andP;  Thealgorithm described here does not enumerate multiple solutions; if severalequally good solutions exist, it returns only one of them, chosenarbitrarily.andP;  Such multiple solutions arise when either the hierarchy allowssome degrees of freedom (the underconstrained case), or when there is aconflict between preferred constraints of the same strength, forcing theconstraint solver to choose among them (the overconstrained case).andP;  Reference[15] discusses these issues in more depth and provides an algorithm forenumerating both types of multiple solutions.andP;  Similarly, the interpreter forthe Hierarchical Constraint Logic Programming language [5] produces alternatesolutions upon backtracking.andM;Constraint SolversandM;Although constraints are a convenient mechanism for specifying relationsamong objects, their power leads to a weakness--one can use constraints tospecify problems that are very difficult to solve.andP;  This motivates thedevelopment of increasingly powerful constraint-solving algorithms.andO;Unfortunately, as the generality of these algorithms increases, so does theirrun time.andP;  Thus, to solve a variety of constraints both efficiently andcorrectly, a broad range of algorithms is necessary.andP;  For some systems, suchas those we use in our userinterface research, a fast, restricted algorithmis desirable.andP;  For other systems, such as general engineering problemsolvers, a slower but more complete algorithm is required.andM;Furthermore, although the ideal algorithm would be tailorable with one of thecomparators discussed in [5], the hard reality is that each algorithm isdesigned around only a few comparators.andP;  Again the slower, more general,algorithms will be more complete and solve for more of the comparators,whereas the faster, more specific, algorithms will be limited to a singlecomparator.andM;As a result, we have designed a &quot;Spectrum of Algorithms&quot; for solvingconstraint hierarchies, each at a different point in the engineeringtrade-off of generality versus efficiency:andM;Red: The Red algorithm uses a generalized graph rewriting system based onBertrand [25] and is capable of solving hierarchies with cycles andsimultaneous equations.andP;  It is more general and slower than most of the otheralgorithms.andM;Orange: The Orange algorithm is based on the Simplex algorithm for solvinglinear programming problems, [31], and is specialized for finding one or allsolutions to hierarchies of linear equality and inequality constraints.andM;Yellow: The Yellow algorithm uses classical relaxation, an iterativehill-climbing technique [40], to produce a least-squares-better solution.andP;  Itis slower than Orange, but it can handle non-linear equations.andM;Green: The Green algorithm solves constraints over finite domains (such asthe ten digits zero to nine, or the three traffic light colors) with acombination of local propagation and generate-and-test tree search.andM;Blue: Blue is a fast local propagation algorithm [2, 18, 39], customized forthe locally-predicate-better comparator.andP;  However, it cannot solve constrainthierarchies involving cycles.andM;DeltaBlue: DeltaBlue is an incremental version of the Blue algorithm.andM;We have implemented Orange, Yellow, Green, Blue, and of course, DeltaBlue.andM;THE DELTABLUE ALGORITHMandM;in interactive applications, the constraint hierarchy often evolvesgradually, a fact that can be exploited by an incremental constraintsatisfier.andP;  An incremental constraint satisfier maintains an evolving&quot;current solution&quot; to the constraints.andP;  As contraints are added to andremoved from the constraint hierarchy, the incremental satisfier modifiesthis current solution to find a solution that satisfies the new constrainthierarchy.andM;The DeltaBlue algorithm is an incremental version of the Blue algorithm.andP;  InBlue and DeltaBlue, each contraint has a set of methods that can be invokedto satisfy the constraint.andP;  For example.andM;c = a + bandM;has three methods:andM;c [left arrow] a + b b [left arrow] c - a a [left arrow] c - bandM;Therefore, the task of the DeltaBlue is to decide which constraints should besatisfied, which method should be used to satisfy each constraini, and inwhat order those methods should be invoked.andM;In the remainder of this section, we present a high-level description of theDeltaBlue algorithm and illustrate its behavior through several examples.andP;  Amore precise pseudo-code description of the algorithm may be found in theappendix of [16].andM;PreludeandM;The DeltaBlue algorithm uses three categories of data: the constraints in thehierarchy C, the constrained variables V, and the current solution P. P, alsoknown as a plan, is a directed cryclic dataflow graph distributed throughoutthe constraint and variable objects: each variable knows which constraintdetermines its value, while each constraint knows if it is currentlysatisfied and, if so, which method it uses.andM;The initial configuration is C = 0 and V = 0 (i.e., no constraints and novariable).andP;  The client program interfaces with the DeltaBlue solver throughfour entry points:andM;add constraint add variable remove constrant remove variableandM;Variables must be added to the graph before constraints using them can bedefined.andP;  Removing a variable removes any extant constraints on that variableas well.andP;  The current solution P is incrementally updated after each addconstraint and remove constraint operation.andM;The DeltaBlue algorithm cannot solve under-constrained hierarchies, so aninvisible very weak stay constraint is attached to each variable as it isadded.andP;  A stay constraint constrains the value of the variable to remainunchanged.andP;  Because this system-supplied stay constraint is weaker than anyconstraint the client program may add, it will only be used if the variableis not otherwise constrained, i.e., if the variable is underconstrained.andM;Walkabout StrengthandM;The key idea behind DeltaBlue is to associate sufficient information witheach variable to allow the algorithm to predict the effect of adding a givenconstraint by examining only the immediate operands of that constraint.andP;  Thisinformation is called the walkabout strength of the variable (the name comesfrom the Australian custom of a long walk to clear the mind), defined asfollows:andM;Variable v is determined by method m of constraint c. v's walkabout strengthis the minimum of c's strength and the walkabout strengths of m's inputs.andM;One can think of the walkabout strength as the strength of the weakest&quot;upstream&quot; constraint, i.e., the weakest ancestor constraint (in the currentsolution P) that can be reached via a reversible sequence of constraint.andO;Thus the walkabout strength represents the strength of the weakest constraintthat could be revoked to allow another constraint to be satisfied.andM;For example, Figure 2 shows a constraint graph with four variables and twoconstraints.andP;  In this and subsequent figures, variables are depicted ascircles, and constraints as arcs.andP;  Constraint arcs are either labeled with anarrow indicating the output variable of the selected method for thatconstraint, or else are shown as dotted lines if their methods are unused.andO;The walkabout strength of D is weak because the constraint between C and D isweak, and could be revoked if necessary to satisfy a stronger constraint onD.andP;  The walkabout strength of C is strong because A is strong and theconstraint between them is required (required being stronger than strong).andO;Remember that the walkabout strength is the weakest constraint that can berevoked, thus weaker walkabout strengths propagate through strongerconstraints.andM;Adding a ConstraintandM;To satisfy a constraint c, DeltaBlue must find a method whose output variablehas a walkabout strength weaker than c's strength.andP;  If such a method cannotbe found, then c cannot be satisfied without revoking a constraint of thesame or stronger strength.andP;  Revoking a constraint of the same strength wouldlead to a different, but not better, locally-predicate-better solution, andso c is left unsatisfied.andP;  Revoking a stronger constraint would lead to aworse solution so, again, c is left unsatisfied.andM;Figure 3 demonstrates the process of adding a constraint.andP;  Figure 3a showsthe initial situation before the constraint is added.andP;  Note that thewalkabout strength of D is weak because of the constraint between A and B.andO;In 3b, the client program adds a strong constraint to D.andP;  DeltaBlue findsthat the strong constraint can be added because strong is stronger than weakand thus this constraint can override whatever constraint caused D'swalkabout strength to be weak.andP;  DeltaBlue satisfies the new constraint andrevokes the constraint that previously flowed into D (i.e.andP;  the constraintbetween C and D), leading to the situation in Figure 3c.andM;Now, because the walkabout strengths of both C and D are weaker than thestrength of the constraint between them, DeltaBlue knows that it canresatisfy that constraint.andP;  The algorithm always chooses to modify thevariable with the weakest walkabout strength, in this case C, thus itresatisfies the constraint in the new direction, as shown in Figure 3d.andM;This causes the constraint flowing into C to be revoked and considered forsatisfaction in a new direction, and in this manner the propagation processcontinues until it eventually reaches the constraint responsible for the weakwalkabout strength of the original variable.andP;  This last constraint is notstrong enough to be resatisfied, as shown in Figure 3e, so the algorithmterminates.andM;If the constraint originally added to D had been very weak, it would not havebeen strong enough to override D's weak walkabout strength, and would haveremained unsatisfied.andM;Removing a ConstraintandM;If the constraint being removed is not satisfied in the current plan P, thenits removal will not change P.andP;  However, if the constraint is satisfied, thesituation is more complex.andP;  Removing the constraint will change the walkaboutstrengths of its &quot;downstream&quot; variables, and perhaps allow one or morepreviously unsatisfied constraints to become satisfied.andP;  An example is shownin Figure 4.andM;Figure 4a shows the initial situation.andP;  The client program wishes to deletethe strong constaint to the right of D.andP;  Note that both the weak constraintbetween A and B and the medium constraint between C and D are initiallyunsatisfied because they cannot override the walkabout strengths of theirvariables.andP;  In Figure 4b, the constraint has been removed and the downstreamwalkabout strengths have been recomputed.andP;  Because there is no constraintflowing into D, its walkabout is due to the invisible very weak stayconstraint.andP;  The invisible very weak walkabout strength also flows throughthe B-D constraint into B.andM;Now the two unsatisfied constraints are both stronger than one of theirvariables, and thus eligible for satisfaction.andP;  DeltaBlue always satisfiesthe strongest constraints first, so the medium constraint is satisfied andnew walkabout strengths are computed for B and D, producing the dataflowshown in Figure 4c.andP;  Finally, the weak constraint between A and B isconsidered for satisfaction, but now it is not stronger than either of itsvariables, so it cannot be satisfied.andP;  Since there are no more constraints toconsider, the algorithm terminates.andM;Code ExtractionandM;In many applications, such as interactive graphics and user interfaces, thesame constraint hierarchy may be solved repeatedly.andP;  For example, when thegrow box of a window is grabbed with the mouse, the system adds a constraintthat attaches the mouse to a corner of the window.andP;  As the user holds downthe button and moves the mouse, the same constraint hierarchy is used torepeatedly recompute the shape of the window.andP;  Later, when the mouse grabs ascroll bar, a different constraint is added and a new hierarchy is formed.andM;A constraint-driven algorithm, such as DeltaBlue, builds its dataflow graphsolely from the hierarchy.andP;  Data-driven algorithms build the dataflow fromboth the hierarchy and the current values in the variables.andP;  Building thedataflow solely from the hierarchy has a performance advantage when the samehierarchy is used repeatedly because the dataflow can be cached and reusedwithout the delay of reinvoking the constraint solver.andM;Extracting a (compiled or interpreted) plan from DeltaBlue is easy becausethe plan is inherent in the directed acyclic dataflow graph P.andP;  A simpleprocedure extract plan traverses P and returns a serialized list ofconstraint methods.andP;  There are two ways to extract the plan: top-down andbottom-up.andP;  Top-down starts at the source variables (those that aredetermined by constraints having no inputs) and works forward.andP;  Bottom-upstarts at the sink variables (those that are not used as inputs by anyconstraints) and works backward.andM;Comparison with BlueandM;It is englightening to contrast the non-incremental Blue algorithm withDeltaBlue.andP;  Where the Blue algorithm is a &quot;batch&quot; algorithm that starts fromscratch each time it is called, the DeltaBlue algorithm uses the currentsolution as a guide to finding the next one.andP;  Thus, Blue must reexamine eachconstraint, even if that constraint has not changed, while DeltaBlue onlyexamines the constraints affected by the most recent change.andP;  If the numberof constraints affected by each change is small compared to the number ofconstraints in the hierarchy, then DeltaBlue is faster than Blue.andP;  However,because DeltaBlue must perform more computation per constraint to maintainits data structures, DeltaBlue is slower than Blue when the number ofconstraints affected by a change approaches the total number of constraints.andM;Other considerations used to choose the appropriate Blue algorithm includehow many changes will be made to the hierarchy before a new solution isrequired, how much memory is available, what sort of error recoveryrobustness is needed, and other engineering issues.andM;Extensions to DeltaBlueandM;To simplify the discussion, the examples in the figures have included onlyconstraints that compute one output per method.andP;  However, DeltaBlue iscapable of handling methods with multiple output variables, as well aslimited-way constraints: those that cannot propagate values in all possibledirections.andP;  An example of a limited-way constraint is a constraint thatrelates the mouse position to the location of cursor on the screen--the mousecan alter the position of the cursor, but the cursor cannot physically movethe mouse!andM;Many of the default constraints in a typical constraint hierarchy are &quot;stay&quot;constraints that prevent a variable from changing [4].andP;  Because the value ofa stay-constrained variable is fixed, there is no need to calculate a newvalue for it.andP;  Furthermore, if all the inputs of a constraint are fixed thenits outputs will also be fixed and need be calculated only once.andP;  Thus, bymaintaining a &quot;stay&quot; flag for each variable, the DeltaBlue algorithm canefficiently perform constant propagation, greatly reducing the size of theplan that extract plan returns.andM;The basic DeltaBlue algorithm can only solve unique constraints--those thatdetermine unique values for their outputs given values for their inputs.andP;  Anon-unique constraint such as &quot;x [is greater than] 5&quot; restricts but does notuniquely fix the value of x.andP;  DeltaBlue has been extended to solve non-uniqueconstraints, but a full discussion of the revised algorithm is beyond thescope of this article.andM;CORRECTNESS PROOFandM;We will show that any solution generated by the DeltaBlue algorithm is alocally-predicate-better solution to the current constraint hierarchy.andP;  Ifthere is a cycle, or if there are conflicting required constraints, thealgorithm will report this fact and halt without generating any solution.andM;We first define the notion of a blocked constraint and present a lemma thatsays that if there are no blocked constraints in a solution, then thatsolution is a locally-predicate-better solution.andP;  We then show that if thecurrent solution has no blocked constraints, then neither will the solutionresulting from a successful call to any of the four entry points of thealgorithm (add constraint, add variable, remove constraint, and removevariable).andP;  By induction, then, we will have demonstrated the correctness ofthe algorithm.andM;The Blocked Constraint LemmaandM;Definition.andP;  A blocked constraint is an unsatisfied constraint whose strengthis stronger than the walkabout strength of one of its potential outputvariables.andM;Lemma.andP;  If there are no blocked constraints, then the set of satisfiedconstraints represents a locally-predicate-better solution to the constrainthierarchy.andM;Proof.andP;  Given a solution Q produced by DeltaBlue, assume for the sake ofcontradiction that there is a solution R better than solution Q.andP;  Then, bythe definition of locally-predicate-better, there is some level k in thehierarchy such that R satisfies every constraint that Q does through level k,and at least one additional constraint c at level k.andP;  Let [v.sub.c] be thevariable of the constraint c with the weakest walkabout strength, and let[v.sub.c] have a walkabout strength of [W.sup.Q.sub.v.sub.c] in Q.andP;  Now,because c is unsatisfied in Q and Q has no blocked constraints, c is notstronger than [w.sup.Q.sub.v.sub.c].andP;  However, because c is satisfied in R, cmust be stronger than [w.sup.Q.sub.v.sub.c].andP;  This is a contradiction, sothere must not be any solution better than Q.andM;Adding a ConstraintandM;DeltaBlue adds a constraint c in four stages:andM;1.andP;  Choose a method m such that the walkabout strength of m's output is nostronger than the walkabout strength of the output of any of c's othermethods.andM;(a) If no such method can be found, c is left unsatisfied.andP;  If c is arequired constraint, halt with an error indicating a conflict betweenrequired constraints (an over-constrained problem).andM;(b) If adding the selected method m would create a cycle in the dataflowgraph of the solution, halt with an error indicating that a cycle has beenencountered (cycles are not handled by DeltaBlue).andM;2.andP;  Insert c in the current solution using method m.andM;3.andP;  Compute the walkabout strength of m's output according to the definitionof walkabout strength, and propagate this walkabout strength through thedataflow graph to all downstream variables.andM;4.andP;  If m's output was previously determined by a constraint d, d is removedfrom the dataflow graph and reconsidered with a recursive call to addconstraint.andM;Observe that the process of adding a constraint may result in one of severalerrors.andP;  In this case, the algorithm halts without producing a solution; itdoes not, however, produce an incorrect solution.andM;If no method for satisfying c can be found in step one, it is because c isnot stronger than any of its possible outputs.andP;  By definition, c is not ablocked constraint.andM;If a method is found in step one (and the method does not produce a cycle),the constraint is satisfied.andP;  A satisfied constraint is not a blockedconstraint.andP;  However, satisfying c changes the walkabout strength of theoutput of m and all downstream variables.andP;  We must show that this will notcause a constraint to become blocked.andM;First, observe that the walkabout strength of m's output cannot go down byadding c.andP;  This is because we chose a method whose output had the minimumwalkabout strength, so all inputs to m must have an equal or strongerwalkabout strength than m's output has.andP;  By the definition, the new walkaobutstrength for m's output is the minimum of c's strength and the walkaboutstrengths of m's inputs.andP;  We have just shown that none of m's inputs has aweaker walkabout strength than its output and c could not have been satisfiedwere it not stronger than m's output strength.andP;  Thus, the new output strengthfor m's output will be no lower than it was in the previous solution.andO;Neither, by induction, will the wakkabout strength of any variable downstreamof m's output.andM;It should be noted that increasing variable walkabout strengths cannot causean unblocked constraint to become blocked.andP;  So, if the previous solution hadno blocked constraint, and we do not lower the walkabout strength of anyvariable, the resulting solution will not have any blocked constraints.andM;What if m's output was previously determined by another constraint?andP;  Thealgorithm removes this constraint from the dataflow graph and reconsiders itusing a recursive call to add constraint.andP;  By induction, this and furtherrecursive calls to add constraint will not leave any blocked constraints.andM;Removing a ConstraintandM;If the constraint to be removed, c is not currently satisfied, it is removedfrom the set of constraint C but has no effect on the dataflow graph.andP;  If cis currently satisfied, the process is slightly more complex.andM;Let m be the method currently used to satisfy c.andP;  The constraint is removedin three steps:andM;1.andP;  Remove c from the dataflow graph.andM;2.andP;  Set the walkabout strength of m's output very weak and propagate thiswalkabout strength through the dataflow graph to all downstream variables.andM;3.andP;  Collect all the unsatisfied constraints on the downstream variables.andO;Attempt to satisfy each of these constraints by calling add constraint.andM;Removing a constraint may cause the walkabout strengths of all downstreamconstraints to go down.andP;  This may cause some currently unsatisfiedconstraints to become blocked.andP;  However, all unsatisfied constraints on thesedownstream variables are reconsidered using add constraint, which we havealready shown does not leave blocked constraints.andP;  Thus, after reconsideringall these constraints, there will be no blocked constraints.andM;Adding and Removing A VariableandM;When a variable is first added, it has no constraints and adding it has noeffect on existing constraints.andP;  Thus, if the current solution has no blockedconstraints then adding a variable to it will not create a blockedconstraint.andM;A variable is removed in two steps.andP;  First, all constriants attached to thatvariable are removed.andP;  By repeatedly using the argument for the case ofremoving a constraint, we see that this process will not create a blockedconstraint.andP;  Second, the now-unconstrained variable is deleted, which clearlycannot create a blocked constraint.andM;The initial solution of no variables and no constraints has no blockedconstraints and we have shown that none of the entry points of DeltaBluecreates a blocked constraint in a solution that does not already have one.andO;By induction, we conclude that no error-free sequence of calls to these entrypoints can lead to a solution with a blocked constraint.andP;  Since we showedthat a solution without blocked constraints is always alocally-predicate-better solution, we have shown that the DeltaBlue algorithmis correct.andM;IMPLEMENTATION AND EXPERIENCEandM;The DeltaBlue algorithm is currently being used in ThingLab II [13, 29], auser-interface construction kit using constraints, and Voyeur [36], aparallel program visualization and debugging project at the University ofWashington.andP;  DeltaBlue is also being considered for use in several commercialprojects.andM;ThingLab II is an object-oriented, interactive constraint programming systemimplemented in Smalltalk-80.andP;  It is, its name suggests, a direct descendentof ThingLab, but with a different emphasis.andP;  The original ThingLab developedand applied constraint programming techniques to interactive physicssimulations whereas ThingLab II applies programming to user-interfaceconstruction.andP;  In keeping with its purpose, ThingLab II offers goodperformance, an object encapsulation mechanism, and a clean interface betweenconstraints and the imperative parts of Smalltalk-80.andP;  Because the constrainthierarchy is changed frequently during both the construction and use of userinterfaces built with ThingLab II, the incremental nature of the DeltaBluealgorithm is an essential element of ThingLab II's good performance.andM;Voyeur is based on building custom animations of the parallel program beingdebugged.andP;  Typically, a graphical view is constructed showing the currentstate of the program either in terms of the program's data sturctures or interms of domain-specific abstractions, such as vectors showing air flowacross a wing.andP;  The user then instruments the program to cause each processto log relevant state changes.andP;  The Voyeur views are updated as long eventsare received.andP;  The user can detect errors or narrow the search for a bug bylooking for aberrant patterns in the views.andM;Because the many processes of a parallel program can generate an overwhelmingamount of log data, one of the keys to effective debugging is to focus ononly a few aspects of the program's behavior at a time.andP;  This is faciltatedby allowing the user to quickly change graphical views to display the statein different ways.andP;  It is sometimes useful to observe several views of thesame state simulataneously.andP;  By defining views and their interconnection withconstraints, the system handles the logistics of keeping views consistentwith the underlying state data structures.andP;  Since views are dynamicallycreated and changed, the incremental nature of the DeltaBlue algorithm isexploited to achieve good performance.andM;CompilationandM;Although Blue and DeltaBlue are efficient enough to solve dozens ofconstraints in seconds, they can be applied to even larger constraintproblems while maintaining good performance by using a module compilationmechanism.andP;  We have developed such a mechanism [13] to allow large userinterfaces to be built with ThingLab II.andM;In ThingLab II, the user-manipulable entities are collections of objectsknown as Things.andP;  ThingLab II provides a large number of primitive Thingsequivalent to their basic operations and data structures of any otherhigh-level language: numerical operations, points, strings, bitmaps,conversions, etc.andP;  Using a construction kit metaphor, new Things can be builtout of primitive Things.andP;  These constructed Things can be used as thecomponent parts of higher-level Things, which can in turn be used to buildstill higher-level Things.andM;At any point in this construction process, a Thing may be compiled to createa Module.andP;  A module retains the external behavior of the Thing it came fromand may be used as a building block like any other Thing, but its internalimplementation is more efficient in both storage space and execution speed.andO;Since its internal details are hidden, a module also provides abstraction andinformation hiding similar to that provided by an Ada package, or a C++ orSmalltalk class.andP;  Modules are appropriate in applications where the behaviorof the Thing will not change, efficiency is an issue, or the implementationis proprietary.andP;  An uncompiled Thing is a better choice in applications wherethe internal structure of the Thing must be visible or when the system isunder rapid development.andP;  In other words, Modules and Things represent thetwo sides of the classical tradeoff between compilation and interpretation.andM;The module compiler replaces the internal variables and constraints of aThing with a set of compiled procedures, or module methods, each of whichencapsulates one solution to the original constraints.andP;  In addition to themodule methods, the module compiler constructs procedures that aid inselecting an appropriate module method for a given set of externalconstraints and procedures that efficiently propagate DeltaBlue walkaboutstrengths through the module.andP;  These procedures are the result of partiallyevaluating the DeltaBlue algorithm over the original constraints.andP;  For a morecomplete discussion of the module compiler, the reader is referred to [13].andM;Modules in ThingLab II were inspired by the components of Ariel and Fabrik[21], and by the Object Definer [1] from the original ThingLab.andP;  Thesesystems, however, could not produce objects for use outside their developmentenvironment whereas a simple modification to ThingLab II allows modules to beused as objects outside of ThingLab II.andM;CONCLUSIONandM;The DeltaBlue algorithm has achieved its goal of being a fast algorithm forsatisfying dynamically changing constraint hierarchies (see [29] forperformance figures).andP;  Our research group at the University of Washingtoncontinues to explore other constraint hierarchy algorithms, and especiallyother incremental constraint hierarchy algorithms.andP;  The DeltaBlue algorithmwas created by a careful study of the data structures and behavior of theBlue algorithm.andP;  We hope that similar study should produce DeltaRed andDeltaOrange algorithms as well.andM;Acknowledgments.andP;  Thanks to Jed Harris for his comments on an earlier draftof this article.andM;REFERENCESandM;[1] Borning, A.andP;  Graphically defining new building blocks in ThingLab.andO;Human-Comput.andP;  Interact.andP;  2, 4 (Apr.andP;  1986), 269-295.andM;[2] Borning, A.H.andP;  The programming language aspects of ThingLab, aconstraint-oriented simulation laboratory.andP;  ACM Trans.andP;  Prog.andP;  Lang.andP;  Syst.andO;3, (Oct.andP;  1981), 353-387.andM;[3] Borning, A. H.andP;  ThingLab--A Constraint-Oriented Simulation Laboratory.andO;Ph.D.andP;  dissertation, Computer Science Department, Stanford, March 1979.andP;  Arevised version is published as Xerox Palo Also Research Center Rep.andO;SSL-79-3 (July 1979).andM;[4] Borning, A., Duisberg, R., Freeman-Benson, B., Kramer, A., and Woolf, M.andO;Constraint hierarchies.andP;  In Proceedings of the 1987 ACM Conference onObject-Oriented Programming Systems, Languages and Applications (Orlando,Fla., October 4-8, 1987), pp.andP;  48-60.andM;[5] Borning, A., Maher, M., Martindale, A., and Wilson, M. Constrainthierarchies and logic programming.andP;  In Proceedings of the Sixth InternationalLogic Programming Conference, (Lisbon, Portugal, June 1989), pp.andP;  149-164.andO;Also published as Tech.andP;  Rep.andP;  88-11-10, Computer Science Department,University of Washington, November 1988.andM;[6] Carter, C.A., and LaLonde, W.R.andP;  The design of a program editor based onconstraints.andP;  Tech.andP;  Rep.andP;  CS TR 50, Carleton University, May 1984.andM;[7] Colmerauer, A.andP;  An introduction to Prolog III.andP;  Draft, GroupeIntelligence Artificielle, Universite Aix-Marseille II, November 1987.andM;[8] Dincbas, M., Van Hentenryck, P., Simonis, H., Aggoun, A., Graf, T., andBertheir, F.andP;  The constraint logic programming language CHIP.andP;  In Proceedingsof International Conference on Fifth Generation Computer Systems, FGCS-88(Tokyo, Japan, 1988).andM;[9] Duisberg, R.andP;  Constraint-based animation: The implementation of temporalconstraints in the animus system.andP;  Ph.D.andP;  dissertation, University ofWashington, 1986.andP;  Published as U.W.andP;  Computer Science Department Tech.andP;  Rep.andO;No.andP;  86-09-01.andM;[10] Ege, R. K. Automatic Generation of Interactive Displays UsingConstraints.andP;  Ph.D.andP;  dissertation, Department of Computer Science andEngineering, Oregon Graduate Center, August 1987.andM;[11] Ege, R., Maier, D., and Borning, A.andP;  The filter browser--defininginterfaces graphically.andP;  In Proceedings of the European Conference onObject-Oriented Programming (Paris, June 1987), pp.andP;  155-165.andM;[12] Epstein, D., and LaLonde, W. A. smalltalk window system based onconstraints.andP;  In Proceedings of the 1988 ACM Conference on Object-OrientedProgramming Systems, Languages and Applications (San diego, Sept. 1988), pp.andO;83-94.andM;[13] Freeman-Benson, B. A module mechanism for constraints in Small-talk.andP;  InProceedings of the 1989 ACM Conference on Object-Oriented ProgrammingSystems, Languages and Applications (New Orleans, Oct. 1989), 389-396.andP;  Alsopublished as Tech.andP;  Rep.andP;  89-05-03, Computer Science Dept., University ofWashington, May 1989.andM;[14] Freeman-Benson, B. Constraint Imperative Programming: A ResearchProposal.andP;  Tech.andP;  Rep.andP;  89-04-06, Computer Science Dept., University ofWashington, 1989.andM;[15] Freeman-Benson, B.N.andP;  Multiple solutions from constraint hierarchies.andO;Tech.andP;  Rep.andP;  88-04-02, University of Washington, April 1988.andM;[16] Freeman-Benson, B., Maloney, J., and Borning, A.andP;  The DeltaBluealgorithm: An incremental constraint hierarchy solver.andP;  Tech.andP;  Rep.andO;89-08-06, Depart, of Computer Science and Engineering, University ofWashington, August 1989.andM;[17] Goldberg, A., and Robson, D. Smalltalk-80: The Language and ItsImplementation.andP;  Addison-Wesley, Reading, Mass., 1983.andM;[18] Gosling, J. Algebraic Constraints.andP;  Ph.D.andP;  Dissertation, Carnegie-MellonUniversity, May 1983.andP;  Published as CMU Computer Science Department Tech.andO;Rep.andP;  CMU-CS-83-132.andM;[19] Heintze, N., Jaffar, J., Michaylov, S., Stuckey, P., and Yap, R.andP;  TheCLP(R) programmer's manual.andP;  Tech.andP;  Rep., Computer Science Dept., MonashUniversity, 1987.andM;[20] van Hentenryck, P. Constraint Satisfaction in Logic Programming.andP;  MITPress, Cambridge, Mass., 1989.andM;[21] Ingalls, D., Wallace, S., Chow, Y.-Y., Ludolph, F., and Doyle, K.andO;Fabrik: A visual programming environment.andP;  In Proceedings of the 1988 ACMConference on Object-Oriented Programming Systems, Languages andApplications, ACM SIGPLAN, Sept. 1988, pp.andP;  176-190.andM;[22] Jaffar, J., and Lassez, J.-L.andP;  Constraint logic programming.andP;  InProceedings of the 14th ACM Principles of Programming Languages Conference(Munich, Jan. 1987), 111-119.andM;[23] Jaffar, J., and Michaylov, S. Methodology and implementation of a CLPsystem.andP;  In Proceedings of the 4th International Conference on LogicProgramming (Melbourne, May 1987), pp.andP;  196-218.andM;[24] Konopasek, M., and Jayaraman, S.andP;  The TK!Solver Book.andO;Osborne/McGraw-Hill, Berkeley, Calif., 1984.andM;[25] Leler, W. Specification and Generation of Constraint SatisfactionSystems Using Augmented Term Rewriting.andP;  Ph.D.andP;  dissertation, University ofNorth Carolina at Chapel Hill, 1986.andM;[26] Leler, W. Constraint Programming Languages: Their Specification andGeneration.andP;  Addison-Wesley, Reading, Mass., 1988.andM;[27] Levitt, D. Machine tongues X: Constraint Languages.andP;  Comput.andP;  Music J.andO;8, 1 (Spring 1984), 9-21.andM;[28] Mackworth, A.K.andP;  Consistency in networks of relations.andP;  Artif.andP;  Intell.andO;8, 1 (1977), 99-118.andM;[29] Maloney, J., Borning, A., and Freeman-Benson, B. Constraint technologyfor user-interface construction in ThingLab II.andP;  In Proceedings of the 1989ACM Conference on Object-Oriented Programming Systems, Languages andApplications (New Orleans, Oct. 1989), 381-388.andP;  Also published as Tech.andO;Rep.andP;  89-05-02, Computer Science Dept., University of Washington, May 1989.andM;[30] Mittal, S., Dym, C.L., and Morjaria, M. PRIDE: An expert system for thedesign of paper handling systems.andP;  IEEE Comput.andP;  (July 1986), 102-114.andM;[31] Murty, K.G.andP;  Linear Programming.andP;  Wiley, New York, 1983.andM;[32] Myers B. Creating user interfaces by Demonstration.andP;  Ph.D.andO;dissertation, Computer Science Department, University of Toronto, 1987.andM;[33] Nelson, G. Juno, a constraint-based graphics system.andP;  In B.A.andP;  Barsky,Ed., SIGGRAPH '85 Conference Proceedings (San Francisco, July 1985), pp.andO;235-243.andM;[34] Sapossnek, M. Research on constraint-based design systems.andP;  InProceedings of the Fourth International Conference on Applications of AI inEngineering, July 1989.andM;[35] Saraswat, V.A.andP;  Concurrent Constraint Programming Languages.andP;  Ph.D.andO;dissertation, Computer Science Department, Carnegie-Mellon University,January 1989.andM;[36] Socha, D., Bailey, M., and Notkin, D. Voyeur: Graphical views ofparallel programs.andP;  In Proceedings of the ACM SIGPLAN and SIGOPS Workshop onParallel and Distributed Debugging, (Madison, Wis., May 1988).andP;  Also SIGPLANNOTICES 24, 1 (Jan.andP;  1989), 206-215.andM;[37] Stallman, R.M., and Sussman, G.J.andP;  Forward reasoning anddependency-directed backtracking in a system for computer-aided circuitanalysis.andP;  Artif.andP;  Intell.andP;  9, 2 (1977), 135-196.andM;[38] Steele, G.L.andP;  The Definition and Implementation of a ComputerProgramming Language Based on Constraints.andP;  Ph.D.andP;  dissertation, ElectricalEngineering and Computer Science Department, MIT, August 1980.andP;  Published asMIT-AL TR 595, August 1980.andM;[39] Sussman, G.J., and Steele, G.L.andP;  CONSTRAINTS--A language for expressingalmost-hierarchical descriptions.andP;  Artif.andP;  Intell.andP;  14 1 (Jan.andP;  1980), 1-39.andM;[40] Sutherland, I. Sketchpad: A man-machine graphical communication system.andO;In Proceedings of the Spring Joint Computer Conference, (IFIPS, 1963), pp.andO;329-345.andM;[41] Szekely, P., and Myers, B. A user-interface toolkit based on graphicalobjects and constraints.andP;  In Proceedings of the 1988 ACM Conference onObject-Oriented Programming Systems, Languages and Applications (San Diego,September 1988), pp.andP;  36-45.andM;[42] vander Zanden, B.T.andP;  An Incremental Planning Algorithm for OrderingEquations in a Multilinear System of Constraints.andP;  Ph.D.andP;  dissertation,Department of Computer Science, Cornell University, April 1988.andM;[43] Weld, D., and de Kleer, J. Readings in Qualitative Reasoning aboutPhysical Systems.andP;  Morgan Kaufmann, Los Altos, California, 1989.andM;[44] Wilson, M., and Borning, A. Extending hierarchical constraint logicprogramming: Nonmonotonicity and inter-hierarchy comparison.andP;  In Proceedingsof the North American Conference on Logic Programming (Cleveland, Ohio, Oct.andO;1989).andM;[45] van Wyk, C.J.andP;  A Language for Typesetting Graphics.andP;  Ph.D.andO;dissertation, Department of Computer Science, Stanford, June 1980.andM;[46] van Wyk, C.J.andP;  A high-level language for specifying pictures.andP;  ACMTrans.andP;  Graph.andP;  1, (Apr.andP;  1982), 163-182.andM;CR Categories and Subject Descriptors: D.2.m [Software Engineering]:Miscellaneous--rapid prototyping; D.3.2 [Programming Languages]: LanguageClassifications--non-procedural languages; 1.2.8 [Artificial Intelligence]:Problem Solving--graph and tree search techniques; I.3.6 [Computer Graphics].andO;Methodology and Techniques--languagesandM;General Terms: Algorithms, LanguagesandM;Additional Key Words and Phrases: Constraints, constraint hierarchies,constraint satisfaction, DeltaBlue, incremental constraint satisfactionandM;ABOUT THE AUTHORS:andM;BJORN N. FREEMAN-BENSON is a Ph.D.andP;  student at the University of Washington.andO;He graduated from the University of Washington in 1985 and in 1988 with B.S.andO;and M.S.andP;  degrees in computer science.andP;  He expects to graduate yet again in1991.andP;  He is currently supported by a National Science Foundation GraduateFellowship.andP;  His research interests include declarative languages,object-oriented programming, human/computer interaction, and computers andsociety.andP;  Author's Present Address: Department of Computer Science andEngineering, FR-35, University of Washington, Seattle, WA 98195; Internet:bnfb@cs.-washington.edu.andM;JOHN MALONEY is a Ph.D.andP;  student at the University of Washington.andP;  Hegraduated from M.I.T.andP;  in 1981 with B.S.andP;  and M.S.andP;  degrees in computerscience.andP;  He spent three years building distributed systems at Xerox beforemoving to Seattle to pursue a Ph.D.andP;  in Computer Science at the University ofWashington.andP;  After years of pursuit, he hopes to finally catch his Ph.D.andP;  in1990.andP;  Maloney's research interests include user interfaces, programminglanguages, and computer applications to music.andP;  Author's Present Address:Department of Computer Science and Engineering, FR-35, University ofWashington, Seattle, WA 98195; Internet: jmaloney@cs.washington.edu.andM;ALAN BORNING is currently an associate professor in the Department ofComputer Science and Engineering at the University of Washington.andP;  Hegraduated in 1971 from Reed College with a B.A.andP;  in mathematics.andP;  Hecompleted his Ph.D.andP;  at Stanford in 1979, and then spent a year as a post-docat the University of Edinburgh.andP;  He joined the faculty at the University ofWashington in 1980.andP;  His research interests include object-oriented and logicprogramming, human/computer interaction, and computers and society.andP;  During1989-90 he is spending a sabbatical year at Rank Xerox EuroPARC in Cambridge,England.andP;  Author's Present Address: Department of Computer Science andEngineering, FR-35, University of Washington, Seattle, WA 98195; Internet:borning@cs.washington.edu.andO;</TEXT></DOC>