<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-290-681  </DOCNO><DOCID>07 290 681.andM;</DOCID><JOURNAL>Communications of the ACM  Jan 1989 v32 n1 p137(4)* Full Text COPYRIGHT Assn. for Computing Machinery, Inc. 1989.andM;</JOURNAL><TITLE>Abstracts from other ACM publications.andM;</TITLE><DESCRIPT/><NOTE>Only Text is presented here; see printed issues for graphics.andO;</NOTE><TEXT>Abstracts from Other ACM PublicationsandM;ACM Transactions on Computer Systems November 1988andM;The Profile Naming Service Larry L. Peterson Profile is a descriptive namingservice used to identify users and organizations.andP;  This paper presents astructural overview of Profile's three major components: a confederation ofattribute-based name servers, a name space abstraction that unifies the nameservers, and a user interface that integrates the name space with existingnaming systems.andP;  Each name server is an independent authority that allowsclients to describe users and organizations with a multiplicity ofattributes; the name space abstraction is a client program that implements adiscipline for searching a sequence of name servers; and the interfaceprovides a tool with which users build customized commands.andP;  Experience withan implementation in the DARPA/NSF Internet demonstrates that Profile is afeasible and effective mechanism for naming users and organizations in alarge internet.andM;For Correspondence: Department of Computer Science, Unviversity of Arizona,Tucson, AZ 85721.andM;Experiments in SR with Different Upcall Program Structures M. Stella AtkinsandM;This paper explores program designs for layered systems such as communicationprotocols and server/client systems that do not exhibit a strict hierarchy intheir control flow.andP;  Clark has proposed structuring such systems, where bothupward and downward control flow are required, to use efficient synchronousprocedure calls between the layers whenever possible.andP;  The term upcall isused by Clark to describe  this synchronous upward communication from serverto client.andM;Several techniques are possible for structuring such programs using upcalls.andO;Comparisons are made by implementing a communication protocol described byClark in three different ways.andP;  The first method implements all the protocolroutines in a single large module.andP;  The second method structures the routinesoccupying vertical slices of the protocol layers, and the third methodstructures the routines into modules corresponding to the protocol layers.andM;Comparisons are made on two fronts: Preservation of modularity, in order todetermine which method shows fault-tolerance and ease of programming, andprogram performance, which is a key motivation for the upcalls programmingstyle.andP;  We conclude that the vertically layered protocol design is to bepreferred unless there are many shared variables between the send-side andreceive-side, as it is very efficient and provides the best protection ofclients from each other.andP;  The horizontally layered design is the leastefficient, but it is the easiest to program.andM;For Correspondence: Computing Science Department, Simon Fraser University,Burnaby, B.C.andP;  V5A 1S6, Canada.andM;Cache Performance of Operating System and MultiprogrammingandM;Workloads Anant Agarwal, John Hennessy, and Mark HorowitzandM;Large caches are necessary in current high-performance computer systems toprovide the required high memory bandwidth.andP;  Because a small decrease incache performance can result in significant system performance degradation,accurately characterizing the performance of large caches is important.andO;Although measurements on actual systems have shown that operating systems andmultiprogramming can affect cache performance, previous studies have notfocused on these effects.andP;  We have developed a program tracing techniquecalled ATUM (Address Tracing Using Microcode) that captures realistic tracesof multitasking workloads including the operating system.andP;  Examining cachebehavior using these traces from a VAX processor shows that both the operating system and multiprogramming activity significantly degrade cacheperformance, with an even greater proportional impact on large caches.andP;  Froma careful analysis of the causes of this degradation, we explore varioustechniques to reduce this loss.andP;  While seemingly little can be done tomitigate the effect of system references, multitasking cache miss activitycan be substantially reduced with small hardware additions.andM;For Correspondence: Computer Systems Laboratory, Stanford, CA 94305.andM;A Digital Multisignature Scheme Using Bijective Public-KeyandM;Cryptosystems Tatsuaki OkamotoandM;A new digital multisignature scheme using bijective public-key cryptosystemsthat overcomes the problems of previous signature schemes used formultisignatures is proposed.andP;  The principal features of  this scheme are (1)the length if a multisignature message is nearly equivalent to that for asinglesignature message; (2) by using a one-way hash function, multisignaturegeneration and verification are processed in an efficient manner; (3) theorder of signing is not restricted; and (4) this scheme can be constructed onany bijective public-key cryptosystem  as well as the RSA scheme.andP;  Inaddition, it is shown that the new scheme is considered as safe as thepublic-key cryptosystem used in this new scheme.andP;  Some variations based onthe scheme are also presented.andM;For Correspondence: 1-2356, Take, Yokosuka-shi, Kanagawa-ken, 238 Japan.andM;ACM Transactions on Office Information Systems April 1988andM;Bureaucracies as Deontic Systems Ronald M. LeeandM;Bureaucratic offices are not only for clerical work, but more important, theyare for officiating in the sense of issuing directives, granting permissions,enforcing prohibitions, waiving obligations, and so forth.andP;  Bureaucracies arethus deontic systems for organizational and social control.andP;  Conventionalinformation processing approaches are inadequate for capturing these aspectsof bureaucratic modeling.andP;  A logic-based  representation that emphasizesdeontic and performance aspects is proposed.andM;For Correspondence: Department of Management and Information Systems,Graduate School of Business, CBA 5.202, University of Texas, Austin, TX78712.andM;Diplans: A New Language for the Study and Implementation ofandM;Coordination Anatol W. HoltandM;In this paper the reader is introduced to coordination in the workplace as anobject of scientific study and computer automation.andP;  Diplans are theexpressions of a new graphical language used to describe plans  of operationin human organizations.andP;  With diplans, systems of constraint, which may ormay not take the form of procedure definitions, can be specified.andP;  Among thespecial strenghts of diplans is their ability to render explicit theinteractive aspects of complex work distributed over many people andplaces--in other words, coordination.andP;  Diplans are central to coordinationtechnology, a new approach to developing support for cooperative work onheterogeneous computer networks.andM;For Correspondence: Coordination Technology, Inc., 35 Corporate Drive,Trumbull, CT 06611.andM;A Speech-Act-Based Office modeling Approach Esa Auramaki, Erkki Lehtinen, andKalle LyytinenandM;In this paper methods and principles that help to analyze offices as systemsof communicative action are explored.andP;  In communicative action, office agentscreate commitments through symbolic means.andP;  A SAMPO (Speech-Act-Based officeModeling aPprOach), which studies office activities as a series of speechacts creating, maintaining, modifying, reporting, and terminatingcommitments, is presented.andP;  The main steps and methods in the office systemspecification are outlined  and their application illustrated through asimple example.andP;  In the final section advantages and disadvantages in theSAMPO are noted and some research directions for the future are suggested.andM;For Correspondence: University of Jyvaskyla, Department of computer Science,Seminaarinkatu 15, SF-40100 Jyvaskyla, Finland.andM;Computer Systems and the Design of Organizational Interaction FernandoFlores, michael Graves, Brad Hartfield, and Terry WinogradandM;The goal of this paper is to relate theory to invention and application inthe design of systems for organizational communication and management.andP;  Wepropose and illustrate a theory of design, technology, and action that webelieve has been missing in the mainstream of work on office systems.andP;  At thecenter of our thinking is a theory of language as social action, whichdiffers from the generally taken-for-granted understandings of what goes onin an organization.andP;  This approach has been presented elsewhere, and our aimhere is to examine its practical implications and assess its effectiveness inthe design of The Coordinator, a workgroup productivity system that is inwidespread commercial use  on personal computers.andM;For correspondence: F. Flores, Action Technologies, 2200 Powell St.,andO;Emeryville, CA 94608; M. Graves, Logonet, Inc., 2200 Powell St., Emeryville,CA 94608; B. Hartfield, 2096 Yale St., Palo Alto, CA 94304; T. Winograd,Department of Computer Science, Stanford University, Stanford, CA 94305.andM;ACM Computing Surveys June 1988andM;Dynamic Hashing Schemes R.J.andP;  Enbody and H.C.andP;  DuandM;A new type of dynamic file access called dynamic hashing has recentlyemerged.andP;  It promises the flexibility of handling dynamic files  whilepreserving the fast access times expected from hashing.andP;  Such a  fast,dynamic file access scheme is needed to support modern database systems.andO;This paper surveys dynamic hashing schemes and examines their critical designissues.andM;For Correspondence: R.J.andP;  Enbody, Department of Computer Science, MichiganState University, East Lansing, Michigan 48823; H.C.andP;  Du, Department ofComputer Science, University of Minnesota, Minneapolis, Minnesota 55455.andM;Computer-Based Systems for Cooperative Work and GroupandM;Decision Making Kenneth L. Kraemer and John Leslie KingandM;Application of computer and communications technology to cooperative work andgroup decision making has grown out of three traditions: computer-basedcommunications, computer-based information service provision, andcomputer-based decision support.andP;  This paper reviews the group decisionsupport systems (GDSSs) that have been configured to meet the needs of groupsat work, and evaluates the experience to date with such systems.andP;  Progresswith GDSSs has proved to be slower than originally anticipated because ofshortcomings with available technology, poor integration of the variouscomponents of the computing &quot;package,&quot; and incomplete understanding of thenature of group decision making.andP;  Nevertheless, the field shows considerablepromise with respect to the creation of tools to aid decision making and thedevelopment of sophisticated means of studying the dynamics of decisionmaking in groups.andM;For Correspondence: University of California, Irvine, California 92717.andM;Journal of the Association for Computing Machinery October 1988andM;Many Hard Examples for Resolution Vasek Chvatal and Endre SzemerediandM;For every choice of positive integers c and k such that k [is greater than or=] 3 and c.sup.2-k [is greater than or =] 0.7, there is a positive number[epsilon] such that, with probability tending to 1 as n tends to [infinity],a randomly chosen family of cn clauses of size k over n variables isunsatisfiable, but every resolution proof of its unsatisfiability mustgenerate at least (1 + [epsilon])&quot; clauses.andM;For Correspondence: V. Chvatal, Department of Computer Science, RutgersUniversity, New Brunswick, NJ 08903; E. Szemeredi, Department of ComputerScience, Rutgers University, New Brunswick, NJ 08903 or MathematicalInstitute, Hungarian Academy of Science, Realtanoda  utca 13-15, Budapest,Hungary.andM;A New Class of Heuristic Alogorithms for Weighted PerfectandM;Matching M. D. Grigoriadis and B. KalantariandM;The minimum-weight perfect matching problem for complete graphs of n verticeswith edge weights satisfying the triangle inequality is considered.andP;  For eachnonnegative integer k [is less than or =] log.sub.3 n, and for any perfectmatching algorithm that runs in t(n) time and has an error bound of f(n)times the optimal weight, an O(max[n.sup.2., t(3.sup.-k.n)])-time heuristicalgorithm with an error bound of (7/3)sup.k.(1 + f(3.sup.-k.n)) - 1 is given.andO;By the selection of k as appropriate functions of n, heuristics that havebetter running times and/or error bounds than existing ones are derived.andM;For Correspondence: Department of Computer Science, Hill Center for theMathematical Sciences, Rutgers University, Busch Campus, New Brunswick, NJ08903.andM;Optimal VLSI Circuits for Sorting Richard Cole and Alan SiegelandM;This work describes a large number of constructions for sorting N integers inthe range [0, M - 1], for N [is less than or =] M [is less than or =]N.sup.2., for the standard VLSI bit model.andP;  Among other results, we attain:--VLSI sorter constructions that are within a constant factor of optimalsize, for all M and almost all running times T. --a fundamentally new mergingnetwork for sorting numbers in a bit model.andP;  --new organizational approachesfor optimal tuning of merging networks and the proper management of dataflow.andM;For Correspondence: Department of Computer Science, New York University, 251Mercer Street, New York, NY 10012.andM;A Linear Time Algorithm for Optimal Routing around a Rectangle Teofilo F.andO;Gonzalez and Sing-Ling LeeandM;The problem of connecting a set of terminals that lie on the sides of arectangle to minimize the total area is discussed.andP;  An O(n) algorithm ispresented to solve this problem when the set of n terminals is initiallysorted.andP;  The strategy in this paper is to reduce the problem to severalproblems such that no matter what instance is started with, at least one ofthese problems can be solved optimally by a greedy method.andM;For Correspondence: T. F. Gonzalez, Department of Computer Science,University of California, Santa Barbara, Santa Barbara, CA 93106; S.-L.andP;  Lee,Department of Computer Science, Penssylvania State University, UniversityPark, PA 16802.andM;Optimal Scheduling Policies for a Class of Queues with CustomerandM;Deadlines to the Beginning of Service Shivendra S. Panwar, Don Towsley, andJack K. WolfandM;Many problems can be modeled as single-server with impatient customers.andP;  Anexample is that of the transmission of voice packets over a packet-switchednetwork.andP;  If the voice packets do not reach their destination within acertain time interval of their transmission, they are useless to the receiverand considered lost.andP;  It is therefore desirable to schedule the customerssuch that the fraction of customers served within their respective deadlinesis maximized.andP;  For this measure of performance, it is shown that the shortesttime to extinction (STE) policy is optimal for a class of continuous anddiscrete time nonpreemptive M/G/1 queues that do not allow unforced idletimes.andP;  When unforced idle times are allowed, the best policies belong to theclass of shortest time to extinction with inserted idle time (STEI) policies.andO;An STEI policy requires that the customer closest to his or her deadline bescheduled whenever it schedules a customer.andP;  It also has the choice ofinserting idle times while the queue is nonempty.andP;  It is also shown that theSTE policy is optimal for the discrete time G/D/1 queue where all customersreceive one unit of service.andP;  The paper concludes with a comparison of theexpected customer loss using an STE policy with that of the first-come,first-served (FCFS) scheduling policy for one specific queue.andM;For Correspondence: S. S. Panwar, Department of Electrical Engineering,Polytechnic University, Brooklyn, NY 11201; D. Towsley, Department  ofComputer and Information Science, University of Massachusetts, Amherst, MA01003; J. K. Wolf, Center for Magnetic Recording Research, University ofCalifornia at San Diego, La Jolla, CA 92093.andM;Computing on an Anonymous Ring Hagit Attiya, Marc Snir, and Manfred K.andO;WarmuthandM;The computational capabilities of a system of n indistinguishable (anonymous)processors arranged on a ring in the synchronous and asynchronous models ofdistributed computation are analyzed.andP;  A precise characterization of thefunctions that can be computed in this setting is given.andP;  It is shown thatany of these functions can be computed in O(n.sup.2.) messages in theasynchronous model.andP;  This is also proved to be a lower bound for suchelementary functions as AND, SUM, and Orientation.andP;   In the synchronous modelany computable fuction can be computed in O(n log n) messages.andP;  A ring can beoriented and start synchronized within the same bounds.andM;The main contribution of this paper is a new technique for proving lowerbounds in the synchronous model.andP;  With this technique tight lower bounds of[theta](n log n) (for particular n) are proved for XOR, SUM, Orientation, andStart Synchronization.andP;  The technique is based on a string-producingmechanism from formal language theory, first introduced by Thue to studysquare-free words.andP;  Two methods for generalizing the synchronous lower boundsto arbitrary ring sizes are presented.andM;For Correspondence: H. Attiya, Department of Computer Science, Tel AvivUniversity, Tel Aviv 69978, Israel; Marc Snir, IBM T. J. Watson ResearchCenter, P.O. Box 218, Yorktown Heights, NY 10598; M. Warmuth, Department ofComputer Science, University of California, Santa Cruz, CA 95064.andM;Parallel Hashing: An Efficient implementation of Shared Memory Anna R. Karlinand Eli UpfalandM;A central issue in the theory of parallel computation is the gap between theideal models that utilize shared memory and the feasible models that consistof a bounded-degree network of processors sharing no common memory.andP;  Thisproblem has been widely studied.andP;  Here a tight bound for the probabilisticcomplexity of this problem is established.andM;The solution in this paper is based on a probabilistic scheme forimplementing shared memory on a bounded-degree network of processors.andP;  Thisscheme, which we term parallel hashing, enables n processors to store andretrieve an arbitrary set of n data items in O(log n) parallel steps.andP;  Theitems' locations are specified by a function chosen randomly from a smallclass of universal hash functions.andP;  A hash function in this class has a smalldescription and can therefore be efficiently distributed among theprocessors.andP;  A deterministic lower bound for the point-to-point communicationmodel is also presented.andM;For Correspondence: A. R. Karlin, Com puter Science Department, PrincetonUniversity, Princeton, NJ 08544; E. Upfal, IBM Almaden Research Center,Almaden, CA 95120.andM;Eliminating go to's while Preserving Program Structure Lyle RamshawandM;Suppose we want to eliminate the local go to statements of a Pascal programby replacing them with multilevel loop exit statements.andP;  The standard groundrules for eliminating go to's require that we preserve the flow graph of theprogram, but they allow us to completely rewrite the control structures thatglue together the program's atomic tests and actions.andP;  The go to's can beeliminated from a program under those ground rules if and only if the graphof that program has the graphtheoretic property named reducibility.andM;This paper considers a stricter set of ground rules, introduced by Peterson,Kasami, and Tokura, which demand that we preserve the program's originalcontrol structures, as well as its flow graph, while we eliminate its goto's.andP;  In particular, we are allowed to delete the go to statements and thelabels that they jump to and to insert various exit statements and labeledrepeat-endloop pairs for them to jump out of.andP;  But we are forbidden to changethe rest of the program text in any way.andP;  The critical issue that determineswhether go to's can be eliminated under these stricter rules turns out to bethe static order of the atomic tests and actions in the program text.andP;  Thisstatic order can be encoded in the program's flow graph by augmenting it withextra edges.andP;  It can then be shown that the reducibility of a program'saugmented flow graph, augmenting edges and all, is a necessary and sufficientcondition for the eliminability of go to's from that program under the stricter rules.andM;For Correspondence: Digital Equipment Corporation Systems Research Center,130 Lytton Ave., Palo Alto, CA 94301.andM;A New Approach to the Maximum-Flow Problem Andrew V. Goldberg and Robert E.andO;TarjanandM;All previously known efficient maximum-flow algorithms work by findingaugmenting paths, either one path at a time (as in the original Ford andFulkerson algorithm) or all shortest-length augmenting paths at once (usingthe layered network approach of Dinic).andP;  An alternative method based on thepreflow concept of Karzanov is introduced.andP;  A preflow is like a flow, exceptthat the total amount flowing into a vertex  is allowed to exceed the totalamount flowing out.andP;  The method  maintains a preflow in the original networkand pushes local flow excess  toward the sink along what are estimated to beshortest paths.andP;  The algorithm and its analysis are simple and intuitive, yetthe algorithm runs as fast as any other known method on dense graphs,achieving an O(N.sup.3.) time bound on an n-vertex graph.andP;  By incorporatingthe dynamic tree data structure of Sleator and Tarjan, we obtain a version ofthe  algorithm running in O(nm log(n.sup.2 / m)) time on an n-vertex, m-edgegraph.andP;  This is as fast as any known method for any graph density and fasteron graphs of moderate density.andP;  The algorithm also admits efficientdistributed and parallel implementations.andP;  A parallel implementation runningin O(n.sup.2 log n) time using n processors and O(m) space is obtained.andP;  Thistime bound matches that of the Shiloach-Vishkin algorithm, which also  uses nprocessors but requires O(n.sup.2.) space.andM;For Correspondence: A. V. Goldberg, Department of Computer Science, StanfordUniversity, Stanford, CA 94305; R. E. Tarjan, ATandamp;T Bell Laboratories, 600Mountain Ave., Murray Hill, NJ 07974-2070.andM;Finite Monoids and the Fine Structure of NC.sup.1 David A. Mix Barrington andDenis TherienandM;Recently a new connection was discovered between the parallel complexityclass NC.sup.1 and the theory of finite automata in the work of Barrington onbounded with branching programs.andP;  There (nonuniform) NC.sup.1 wascharacterized as those languages recognized by a certain nonuniform versionof a DFA.andP;  Here we extend this characterization to show that the internalstructures of NC.sup.1 and the class of automata are closely related.andM;In particular, using Therien's classification of finite monoids, we give newcharacterizations of the classes AC.sup.0., depth-k AC.sup.0., and ACC, thelast being the AC.sup.0 closure of the mod q functions for al constant q.andP;  Wesettle some of the open questions in, give a new proof that the dot-depthhierarchy of algebraic automata theory is infinite, and offer a new frameworkfor understanding the internal structure of NC.sup.1..andM;For Correspondence: D. A. Mix Barrington, Department of Computer andInformation Science, University of Massachusetts, Amherst, MA 01003; D.andO;Therien, School of Computer Science, McGill University, Montreal, Quebec,Canada, H3A 2K6.andM;Meager and Replete Failures of Relative Completeness Daniel Leivant and TimFernandoandM;The nature of programming languages that fail to have a relatively completeproof formalism is discussed.andP;  First, it is shown that such failures may bedue to the meagerness of the programming language, rather than to thepresence of complex control structures as in the cases studied so far.andP;  Thefailure of relative completeness is then derived for  two languages with arich control structure, using simple simulations of general recursivefunctions by procedure call mechanisms.andM;For Correspondence: D. Leivant, Computer Science Department, Carnegie MellonUniversity, Pittsburgh, PA 15213-3890; T. Fernando, Computer ScienceDepartment, Stanford University, Stanford, CA 94305.andM;Computational Limitations on Learning from Examples Leonard Pitt and LeslieG. ValiantandM;The computational complexity of learning Boolean concepts from examples isinvestigated.andP;  It is shown for various classes of concept representationsthat these cannot be learned feasibly in a distribution-free sense unless R =NP.andP;  These classes include (a) disjunctions of two monomials, (b) Booleanthreshold functions, and (c) Boolean formulas in which each variable occursat most once.andP;  Relationships between learning of heuristics and findingapproximate solutions to NP-hard optimization problems are given.andM;For Correspondence: L. Pitt, Department of Computer Science, University ofIllinois, Urbana-Champaign, Urbana, IL 61801; L. G. Valiant, AikenComputation Laboratory, Harvard University, Cambridge, MA 02138.andM;Counting Is Easy Joel I. Seiferas and Paul M. B. VitanyiandM;For any fixed k, a remarkably simple single-tape Turing machine can simulatek independent counters in real time.andM;For Correspondence: J. I. Seiferas, Computer Science Department, Universityof Rochester, Rochester, NY 14627; P. M. B. Vitanyi, Centre for Mathematicsand Computer Science, P.O. Box 4079, 1009 AB Amsterdam, The Netherlands.andO;</TEXT></DOC>