<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF109-409-213  </DOCNO><DOCID>09 409 213.andM;</DOCID><JOURNAL>Hewlett-Packard Journal  June 1990 v41 n3 p48(11)* Full Text COPYRIGHT Hewlett Packard 1990.andM;</JOURNAL><TITLE>A new generation of software development tools. (the HP SoftBenchintegrated software development environment for computer-aidedsoftware engineering) (includes a related article on the HPSoftBench program builder)</TITLE><AUTHOR>Gerety, Colin; Wichelman, James W.andM;</AUTHOR><SUMMARY>THe HP SoftBench integrated software development environment isintended for use by development teams that require strong programconstruction, test and maintenance support; want to automate tasksin the development process; are looking for a task-oriented systemthat is easy to learn and use; and want to integrate existingtools into the environment and processes.andP;  HP SoftBench supportsfive targeted software development tasks: team file management,team communication, program construction, program testing andprogram maintenance; the first two are pervasive, and the lastthree support specific software life cycle phases.andP;  Individualtools in the suite include the development manager, programeditor, program builder, static analyzer, program debugger andintegrated help; each is described.andM;</SUMMARY><DESCRIPT>Company:   Hewlett-Packard Co. (products).andO;Ticker:    HWP.andO;Product:   HP SoftBench (Program development software) (design andconstruction).andO;Topic:     Program Development ToolsProgram Development TechniquesComputer-Aided Software EngineeringSoftware DesignIntegrated SystemsSoftware MetricsSoftware Maintenance.andM;</DESCRIPT><TEXT>The HP SoftBench environment's development manager, program editor, programbuilder, static analyzer, program debugger, and mail collaborate to supporttask-oriented program construction, test, and maintenance.andM;THE HP SOFTBENCH PRODUCT, as explained in the article on page 36, provides anintegrated software development environment designed to facilitate rapidinteractive program construction, test, and maintenance in a distributedcomputing environment.andP;  This article presents examples of computer-aidedsoftware engineering (CASE) tools that use the services of the HP SoftBenchtool integration architecture.andM;The HP SoftBench environment is designed for software development teams thathave the following characteristics:andM;* They need strong program construction, test, and maintenance support.andM;* They want to automate tasks in their development process.andM;* They want a task-oriented system that is easy to learnandM;and use.andM;* They want to integrate their existing tools into their developmentenvironment and processes.andM;The HP SoftBench environment is designed so that users can focus on softwaredevelopment tasks rather than on the specific tools needed to accomplish thetasks.andP;  Instead of having to specify tools, arguments, and data for each steprequired to perform a task, HP SoftBench users select an object to operate on(for example, an executable file) and then specify what they want to do (forexample, debug).andP;  The environment determines what tools to run, what machineto run them on, how to start them, what arguments are required, and where thedata resides that they will operate on.andP;  On the other hand, HP SoftBenchusers who prefer the conventional tool-oriented mode of operation can work inthat mode at their option.andM;The HP SoftBench tools collaborate to support five targeted softwaredevelopment tasks.andP;  Two of these-team file management and teamcommunication-we pervasive.andP;  The other three-program construction, programtesting, and program maintenance-support specific software life cycle phases.andO;A set of HP SoftBench tools assists the user with each of these five tasks.andO;The current HP SoftBench release supports software development in C, Fortran,and Pascal.andP;  Team File ManagementandM;Teams of software developers working together need ways to manage access toand revisions of the files that compose the software project.andP;  Team membersneed a stable and controlled area to develop and test the project software.andO;They also need an easy way to retrieve changes and additions to the projectfiles made by other team members, so that they can test their own changeswith the latest version.andP;  Once they are satisfied that their modificationswork with the latest version, they need to submit or promote theirmodifications or additions into the master set of project files.andP;  The HPSoftBench development manager provides these services (see box, page 49).andM;The notions of reserving, locking, or checking out a file and then replacingor checking in the modified file are central to all development, test, andmaintenance activities.andP;  Therefore, all HP SoftBench tools that allowmodification of project source files communicate directly with thedevelopment manager to retrieve the current file from the version managementsystem or to return it.andM;For example, if you are a developer who wants to modify a file, you requestaccess to the file through the development manager.andP;  If another developer isalready in the process of modifying that file, the development manager deniesthe request and tells you which team member is already working on the file.andO;In this case, you can either ask the development manager to create a branch,which will need to be merged with other changes later, or you can contact thenamed team member, either directly or through HP SoftBench mail, to negotiateaccess to the file.andM;In addition to this team support, standard versioning operations areprovided, such as storing change information for files so that previousrevisions can be retrieved.andP;  Also included is the ability to tag specificfile versions with symbolic names, such as Release 1.0, or with specificstates, such as Experimental.andP;  Sets of files that make up particularconfigurations of the project can be stored and retrieved on demand.andP;  You maywant to retrieve, for example, all the files that make up Release 2.0 or allthe files for a certain HP-UX version that have been tested.andP;  You might alsoask to retrieve the project files as they were on january 9.andM;Team CommunicationandM;HP SoftBench team communication support is designed to facilitatecommunication among members of the project team so that shared resources areefficiently used, developers are notified of key system events, and work andmeetings can be arranged and coordinated.andP;  Like team file management, teamcommunication is a pervasive task, necessary in all phases of softwaredevelopment.andM;The HP SoftBench product includes an electronic mail facility, HP SoftBenchmail (see Fig.andP;  1).andP;  Besides the standard electronic mail capabilities ofviewing, replying to, and filing messages from others and composing andforwarding messages to others, HP SoftBench mail is designed to link into therest of the software development environment.andP;  As an example of such a link,HP SoftBench mail can be instructed to watch for the completion of a systembuild and send out an announcement to members of the team if the build fails.andO;If the build is successful, HP SoftBench mail can announce the success,letting the team know that a new release of the software is available (seeFig.andP;  2).andM;More information on the HP SoftBench mail tool can be found in the article onpage 59.andM;Program ConstructionandM;Program construction is the transformation of a design into an executableprogram.andP;  The HP SoftBench environment supports either writing new sourcecode or assembling software from existing components, or a combination of thetwo.andM;Large projects often contain one or more common code libraries, designed tobe reused throughout the application.andP;  Software reuse of this sort has beenshown to be a major factor in improving both software quality andproductivity.andP;  The HP SoftBench environment facilitates software reuse byaddressing one of the common obstacles to reuse: locating appropriatefunctions and procedures.andP;  The HP SoftBench static analyzer (see box, page54) assists in this task by making it easy to search the project libraries,looking at parameters, return values, and function definitions.andM;Programs are created, modified, or synthesized from existing pieces in aprogram editor.andP;  The HP SoftBench program editor (see box, page 51) assistswith this task, and provides quick access to the other program constructiontools.andP;  For example, the user can select a function name in a program and askthe HP SoftBench environment to show the definition of the function or otherreferences to the function within the application.andP;  The user can also checkthe syntax of the program file under construction.andP;  The program editor istargeted at programmers who are new to the HP-UX operating system or who haveworked in PC environments and want a mouse- and menu-based editor.andP;  If theuser already has a favorite UNIX program editor, such as emacs or vi, the HPSoftBench environment allows the use of that editor instead.andM;Once the program source files have been created, the HP SoftBench systemanalyzes module dependencies and constructs a recipe, or make file, forbuilding executable programs or libraries.andP;  The HP SoftBench system thenbuilds the program, compiling and linking only modules that are out of date.andO;If compile or link errors are encountered, the user can correct theminteractively.andP;  The HP SoftBench program builder (see box, page 52) assistswith this task.andM;The result of the program editor, program builder, and static analyzerworking together is a rapid edit-compile cycle allowing quick exploration ofalternative implementations or construction of new functionality.andP;  ProgramTestandM;The program construction task results in an executable program.andP;  However,this does not mean that the program implementation perfectly meets its designrequirements.andP;  The task of analyzing the program to identify and correctdefects in implementation and design is known as the program test task.andP;  Onlarge projects, this is often a very difficult process.andM;The HP SoftBench environment provides strong support for understanding boththe structure (with the static analyzer) and the behavior (with the programdebugger) of large, complex applications.andM;The program debugger (see box, page 55) provides program execution in acontrolled environment.andP;  The user can step through the program, watching forspecific conditions, pausing at any time to examine the state of datastructures, and monitoring the control flow through the various paths of theprogram.andP;  If a variable is somehow being set to an illegal value, the usercan trace the variable to locate the conditions and location of the improperassignment.andP;  If a function is being called when it shouldn't be, the user canmonitor the execution, watching for the conditions which caused this call.andM;In analyzing the behavior of complex applications, it is often useful to viewthe execution at lower levels of abstraction.andP;  The program debugger cansimultaneously show the program's source code, the assembly code, and theprocessor's register contents.andP;  The program debugger can walk through theprogram's execution either at the assembly statement level or at the sourcestatement level.andM;The static analyzer is often used hand in hand with the program debugger.andO;For example, if a variable is being set to an illegal value, the staticanalyzer identifies all locations where the specific variable is set, and theprogram debugger can be used to set tracepoints at each of these locations.andM;When a problem has been located and a change has beenandM;AcknowledgmentsandM;The HP SoftBench software development tools were designed and built by MartinCagan, John Dutton, Jorge Gautier, Robert Heekendorn, Caroline Koff, BobMorain, John Repko, Nancy Steffens, Gary Thunquest, Anthony Walker, JimWhalen, and Jim Wichelman.andP;  The HP SoftBench team is grateful to the HPCalifornia Language Laboratory for providing the underlying support forstatic analysis, and to the HP Colorado Language Laboratory for their helpwith the underlying debugger support.andM;Development ManagerandM;The HP SoftBench development manager manages the versions of files on whichthe other tools operate.andP;  Fig.andP;  1 shows the development manager userinterface.andP;  The user can check files in and out, examine change histories,and compare revisions.andM;In the development model supported by the development manager, each personhas a private, local work area, which is associated with a team or masterwork area.andP;  The development manager presents a view of the files in theuser's work area, along with the state of each file (file type, whether it isunder version control, whether it is locked or writable).andM;The version management functions provided by the development manager can beaccessed directly through the development manager user interface orindirectly from the other tools via the development manager's messageinterface.andP;  For example, all HP SoftBench tools that provide the ability toedit source files (e.g., static analyzer, program builder, program editor)allow the user to check files in or out from version control.andP;  The tools dothis by communicating with the development manager to perform the requestedservices.andP;  Thus the development manager's version control is pervasivethroughout the environment.andM;The development manager also serves as an application launcher.andP;  Actions arepresented based on the file type.andP;  For example, the user can run, rebuild, ordebug an executable file and edit, compile, and show functions of aC sourcefile.andP;  Some actions are serviced directly by the development manager, whileothers are forwarded via the broadcast message server to other HP SoftBenchtools or user encapsulations.andM;Program EditorandM;Editors are controversial.andP;  Despite considerable reluctance, based on ourconviction that there are already too many editors for HP-UX programs, wefound ourselves writing a new editor for the HP SoftBench environment.andP;  Therequirements that forced this decision were:andM;*  Language sensitivity.andP;  The primary job of the HP SoftBench editor isprogram editing.andP;  To be effective, the editor should be language sensitive.andO;This ruled out the TextEdit widget in the X toolkit.andM;*  Ease of learning and use.andP;  We wanted an easy-to-use mouse/ menu interfaceconsistent with the other HP SoftBench tools.andM;*  Embedded edit capabilities.andP;  The HP SoftBench tools must prompt the userfor information.andP;  These prompts may be embedded in the tool window.andP;  Withouta difficult encapsulation, stand-alone editors like emacs or vi cannot beused in this way.andM;*  Consistent interface.andP;  it was an HP SoftBench requirement that editingcommands be consistent in all editable areas of all tools.andM;*  Broadcast message support.andP;  To be a good citizen of the HP SoftBenchenvironment, an editor should make its functionality available throughmessages and make other tools (e.g., the HP SoftBench program debugger)available from the editor.andM;To satisfy these requirements, we created the edit widget (see page 42).andO;Given the edit widget, the editor is just a sophisticated wrapper on theexisting functionality.andM;A user can configure the system to have edit requests serviced by anothereditor, but one or more of the goals of the system editor will be sacrificed.andO;If vi is chosen, consistency and broadcast message support are sacrificed.andO;If emacs is chosen, the consistent mouse/menu human interface is sacrificed.andM;In the HP SoftBench program editor, each file is given its own window andmenus are used to give easy access to the editing functionality (see Fig.andO;1).andP;  Messages are used to communicate with the HP SoftBench program builder,static analyzer, and development manager tools.andM;The HP SoftBench editor is designed for editing programs, as opposed togeneral prose.andP;  it has knowledge of program structures like procedures,blocks, and tokens and can use this information to control indentation andbalance delimiters.andM;The easy-to-use menu/mouse interface is particularly effective for writingcode.andP;  In the HP SoftBench environment there are mouse functions forselecting tokens, blocks, and procedures and there are mouse functions forcut, copy, and paste operations.andP;  Because program code involves repeatingsimilar structures, code can be written very quickly in the program editor bycopying a structure that is similar to the needed code and changing it to thedesired form.andM;For example, once code similar to what is needed is pasted into place, atypical change is in the names of variables.andP;  The edit widget replacesselected text with whatever is typed next.andP;  To make a change in the name of avariable that occurs several times, the first instance of the old variablename is selected by double-clicking the left mouse button.andP;  The new name istyped, replacing the old name.andP;  The new name is then selected and copied intothe paste buffer.andP;  Additional instances are changed by selecting the oldtoken and pasting the new token in its place.andM;Program BuilderandM;The HP SoftBench program builder is a tool that simplifies the compile andlink phases of the typical edit/compile/link/debug loop used during softwaredevelopment (see Fig.andP;  1).andP;  It shortens this part of the cycle by compilingonly the parts of a program that require recompilation because of direct orindirect changes.andP;  In addition, the program builder provides an errorbrowsing feature that facilitates direct access to identified source codeerrors, thereby speeding up the edit phase of this cycle.andM;in an effort to simplify further the task of building and maintaining asoftware project, the program builder provides facilities for creating andmaintaining the dependency control files required for intelligent builds.andO;This frees the user from having to deal with the format and content of suchfiles.andM;Rebuild Only What is NecessaryandM;The program builder compiles only the parts of a program that have changedsince the last build.andP;  if an include file common to several source files haschanged, the program builder is smart enough to compile all files that dependon (i.e., include) that file.andP;  This ensures that any change will be correctlypropagated through the entire software project.andM;in reality, it is not the program builder that performs these dependencycontrol tasks.andP;  It is the build program invoked by the program builder thathas these abilities.andP;  The program builder provides a friendly and consistentuser interface to this underlying program.andP;  The UNIX automatic dependencycontrol program make is the default program used to provide thisfunctionality.andP;  Make does its job by using time stamps maintained by the filesystem to determine if source files have changed since the last time theywere compiled.andP;  If any files (or dependent files) have changed, make willinvoke the appropriate compiler to recompile only those files and relinkthem.andM;Although the default build program is make, almost any build program can besubstituted.andP;  The program builder does not care what build program is run.andO;This makes it very simple to adapt to new build technologies.andP;  The only thingthat really needs to be known about the build program is how to pass compilerflag information through it to the compilers.andP;  The program builder must beable to control certain compiler behavior, including the generation ofinformation required to debug a program, the generation of informationrequired for static analysis, and the optimization of code for speed.andP;  Thisis necessary because the program builder message interface allowsspecification of parameters that request these behaviors.andP;  For example, thestatic analyzer tool will always request static information when it sends abuild request to the program builder.andM;By default, the program builder passes compiler flags through well-definedenvironment variables that all HP compilers know to look at, effectivelybypassing the build program.andP;  Therefore, almost any build program and relatedmake file should be usable without any changes to the program builderconfiguration or makefile.andM;For some build programs, such as the ATandamp;T ToolChest program make, which keepstrack of the compile options used to do a build, this scheme is notacceptable.andP;  Nmake will force all files to be recompiled if compile optionschange.andP;  Therefore, the program builder can be configured to pass compileoptions through the build program on the command line using almost any syntaxthat is appropriate for the build program or make file.andM;Automatic Generetion of DependenciesandM;For make to do its job, there must be a make file that contains a list ofsource files required to construct the program.andP;  The makefile must alsocontain dependency information (what files depend on what other files) sothat efficient builds can be performed.andP;  For many UNIX users, for all but thesimplest set of source files, makefiles are quite magical and for the mostpart, unintelligible.andP;  Maintaining them is a nightmare, and creating them isvery difficult.andP;  The program builder provides a user friendly interface forthe creation and maintenance of these files.andP;  It automates these tasks byusing the HP-UX program mkmf (make makefile) for both creation andmaintenance.andM;To create a makefile, the Makefile: Create Program menu selection is used.andP;  Asimple fill-in-the-blanks form is then displayed in a window (see Fig.andP;  2).andO;All entries are optional, but the user typically will specify items such asan executable file and any extra libraries to be linked with the program.andO;After the OK button is pressed, the program builder causes mkmf to scan allof the files in the context directory and construct a makefile based on thedependency graph generated from its analysis of the source files.andP;  Theprogram builder supports creation of makefiles for archive libraries as wellas for programs.andM;To update a makefile, the user simply selects the Makefile: Update menuselection.andP;  The program builder will then invoke mkmf to rescan all sourcefiles and update the dependency information in the existing makefile.andM;Makefiles can contain numerous targets for performing a variety of tasksother than building a program.andP;  Specifying one of these targets in the TARGETwindow of the the program builder and starting a build (pressing the BUILDbutton) causes the action associated with that target.andP;  Some of the targetsprovided in makefiles generated by the program builder include:andM;* print.andP;  Format all of the source files and output to the printer.andM;* lint.andP;  Run lint over the source files to check for syntax errors.andM;* clobber.andP;  Remove all reproducible files (.o files, program files, corefiles, etc).andM;* clean.andP;  Remove all object (.o) files.andM;* touch.andP;  TOUCH  update the time stamp of) all source files.andM;It is often desirable for more experienced users to customize the actionsassociated with these targets or to add new targets for additionalfunctionality.andP;  To this end, a menu selection  makefile: Edit) is availableso that the makefile can be edited in the edit area of the program builder orin a separate window.andP;  The program builder attempts to deal gracefully withbuild requests when no recognizable makefile is present.andP;  It is often thecase that a single directory may contain numerous simple, self-containedprograms.andP;  While it is currently not possible to instruct the program builderto build all of the programs in the directory without a makefile, requests tobuild individual programs are handled correctly.andM;Error BrowsingandM;A useful feature of the program builder is the error browser.andP;  The programbuilder presents compilation errors to the user in a browsable list.andP;  It is asimple matter for a programmer to walk through the list of errors, fixingthem one at a time.andP;  Error recognition is based on regular expressions andtherefore is easily extensible.andP;  The regular expressions are stored in a fileand read into the program builder during initialization.andP;  The file suppliedwith the program builder contains expressions for all of the languagessupported by the HP SoftBench system (HP 9000 Series 300 and Series 800compiler errors are recognized).andP;  The user can supply a file to be used inplace of the default file.andP;  To be recognized, all errors must contain afilename and a line number.andP;  The error need not be specified on a singleline, but may span several, as for the Series 800 Pascal compiler.andP;  The filethat contains the regular expressions supports syntax that allows the user tospecify how many expressions must be matched to recognize a line or set oflines as an error.andM;Each line received by the program builder from the build process is shown inthe build output area and compared with the current list of known regularexpressions.andP;  If it matches one of the expressions (or matches the last lineof a multiple-line expression whose preceding lines have already beenmatched), the filename and line number are stored in the list of recognizederror lines.andP;  Selecting any of these lines will display the associated sourcecode line in the file view area.andP;  The error buttons (FIRST, NEXT, etc.) areavailable to cycle through the errors in an orderly manner.andP;  The programbuilder uses features supplied by the HP SoftBench edit widget (floating linemarks) to ensure that error line references remain accurate as source codelines are inserted or deleted.andM;This facility is not limited to compiler errors.andP;  A useful example of itsflexibility is a grep browser.andP;  The program builder can be configured to actas one by changing the build program (either via the menu or by a resourcespecification) to grep, specifying -n in the program builder options windowto ensure that grep generates line numbers in its output, and specifying apattern and a list of files to search in the OPTIONS window.andP;  The regularexpression for recognizing grep output is already present in the defaultregular expression file supplied with the program builder.andP;  Now, when a buildis performed, all output from grep will be recognized as errors.andP;  Thus,selecting any of the output lines or using the error buttons (FIRST, NEXT,etc.) will display the selected file at the indicated line number in the fileview area of the program builder tool.andP;  This flexibility can be used tocreate a browser for many tools.andM;Remote BuildsandM;The program builder supports a simple distributed or remote build facility inaddition to the standard HP SoftBench remote execution and remote datafacilities (see &quot;Distributed Execution, Data, and Display,&quot; page 40).andP;  Thisallows users to specify any machine in the network (to which they haveaccess) to be used as a compile server.andP;  While this facility does notimplement true distributed builds (builds where the various compiles andlinks needed to complete a build request are distributed across variouscomputers on a network), it does allow the user to assign the compute and I/Ointensive task of compiles and links to a machine that may be better able tohandle these demands.andP;  Because of its simplicity, the program builder doesnot preclude true distributed builds.andP;  Any build facility capable of such atask can be substituted for the UNIX make program.andM;The HP SoftBench subprocess control (SPC) facility is used for automaticexecution of the build process on the specified remote computer.andP;  Before theprocess is started, the SPC daemon on the remote machine establishes a dataconnection to the machine and directory specified by the program builder'sdata context.andP;  The current working directory for the build process is thenchanged to match that of the context host and directory, and the build isthen performed as if it were run locally.andM;The HP SoftBench static analyzer aids the user in understanding source code.andO;Fig.andP;  1 shows its user interface.andP;  It supports language independent queriesabout code structure and provides cross-reference information that can helpin finding defects, planning code changes, or evaluating a piece of softwarefor reuse.andP;  Message communication with the development manager, programeditor, and program builder enhances its ability to provide window-based,interactive analysis.andM;The static analyzer receives its information from the compiler, much the sameas a debugger does.andP;  This has the advantage that source code is parsed onceand the results are shared between static analysis, debugging, and programexecution.andM;The compiler collects cross-reference information for the static analyzer onall identifiers within a program and categorizes each occurrence by how it isused.andP;  An assignment statement is categorized as a modification to theidentifier being assigned to, while a variable definition is categorized as adefinition.andP;  The static analyzer supports queries that return a singlecategory or group of categories of references about an identifier.andP;  Often auser only wants to see where the value of a variable has been changed or howa function has been defined or declared in different modules.andP;  The staticanalyzer supports these queries directly, returning only the relevantinformation.andM;A program may have many identifiers that have the same name, but because theyare different program elements or have different scopes, they refer todifferent objects.andP;  For instance, a structure field named slime may bedefined within two different structures and therefore represent two distinctentities that should not be confused during analysis.andP;  When only the nameslime is entered and its uses are requested, the static analyzer will returnthe uses of both fields because both are named slime and have uses.andP;  However,if the user identifies slime by selecting it within a source code view, thenthere is enough location information to indicate which field is wanted, andonly the references to the selected slime will be returned.andM;Coupling these capabilities with program structure queries provides a toolstreamlined for understanding and facilitating changes to software.andP;  Byallowing the user to ask questions about a program, browse results to seeprogram context, and use theandM;Program DebuggerandM;The HP SoftBench program debugger provides a powerful yet simple userinterface to the HP-UX symbolic debugger xdb, making users effective in theirdebugging tasks with a minimum of effort.andP;  We were surprised to learn howmany users avoid using some HP-UX debuggers because of the difficulty oflearning their command languages.andP;  These users would rather resort to some ofthe most tedious and time-consuming methods of tracking down simple bugs thanmaster some esoteric tool.andM;Other goals for the program debugger were integration with the other HPSoftBench tools, provision of added value over the standard HP-UX symbolicdebugger, and exploration of the potential for automated use of tools in thefuture.andM;User interfaceandM;Using the HP SoftBench program debugger, software developers can becomeproficient at common debugging tasks in very short order, even if they arenot familiar with the standard HP-UX debuggers.andP;  Pull-down menus andaccelerator buttons, along with point and select operations with the mouse,provide a very simple means for entering powerful debugging commands (seeFig.andP;  1).andP;  Almost all of the functionality of the standard HP-UX debugger isavailable via mouse-oriented commands.andP;  Many sophisticated sequences ofcommands are also made available with a single menu selection.andP;  When the usermust use a more esoteric command, it is possible to type it in directly tothe HP-UX debugger.andM;The program debugger extends the user's view of the program being debugged byallowing more simultaneous views than standard debuggers (see Fig.andP;  2).andP;  Theuser can see program input/output, debugger input/output, source code,assembly instructions, register sets, and even the state of signals beinghandled by the debugger-all at the same time if desired.andP;  Because these viewsare in separate windows, they are not constrained by the same space resourcesas in conventional, terminal-oriented HP-UX debuggers.andM;One of the most useful features is separation of the 1/0 streams for theHP-UX debugger and the program being debugged into separate window panes.andO;This allows the user to see (and remember) what the program is doing withoutsorting through confusing debugger commands, prompts, and printouts.andP;  Each ofthese views is scrollable and editable, allowing the user to review andrepeat previous entries.andP;  Added ValueandM;Since the program debugger is implemented using the HP SoftBench distributedsupport mechanisms, users can debug programs on other machines and withdistributed source files without doing any extra work.andP;  The program debuggertakes care of starting the HP-UX debugger on the correct machine (the onehosting the executable file) and establishes all the necessary interprocesscommunication.andP;  While this is not a substitute for nonintrusive distributeddebugging, it does satisfy the distributed debugging needs of many users.andM;For applications with signal handlers that must be debugged, the programdebugger has a special window to help the user monitor signals that arereceived, handle each signal specially, and send specific signals to theapplication.andP;  All of this can be done without going to a terminal window andwithout looking up process ID numbers and signal numbers.andM;Program debugger users rarely need to know about process ID numbers, evenwhen sending signals to their applications or when adopting already runningprocesses.andP;  The task of remembering the ID numbers when a process is forkedor of looking up the process ID number (with/bin/ps) using the program's nameis handled automatically.andM;The standard HP-UX symbolic debuggers give minimal support for monitoring thevalue of program variables.andP;  it is possible to set up assertions that showthe value after each instruction executed (slowing execution incredibly), orto set up breakpoints to show the value at specific points in the program,but great imagination (and tedium) are required to do much more.andP;  The HPSoftBench program debugger allows the user to specify a variable to be tracedand then uses a rather involved set of breakpoints and assertions toimplement a primitive but often useful variable tracing facility.andP;  AutomatedTool UseandM;The HP SoftBench tool integration architecture allows tools to communicatewith each other by means of request and notification messages.andP;  While thecurrent HP SoftBench tools only document a limited set of requests, it ispossible for tools such as the program debugger to be controlled entirely bya program rather than a person.andP;  For example, tool builders can use the HPEncapsulator (see article, page 59) to construct higher-level tools thatissue requests to the static analyzer and the program debugger.andP;  Thesehigher-level tools can monitor program data structure references ormodifications, perform branch flow analysis, monitor performance, or handledozens of other useful operations.andP;  Integrated HelpandM;The HP SoftBench help facility (see Fig.andP;  1) is independent of the tools forwhich it provides help.andP;  For efficiency, the help application is combinedwith the tool manager.andM;Each tool contains a help pull-down menu containing item Help and ApplicationHelp entries.andP;  When a user asks for Item Help, the mouse sprite changes intoa question mark.andP;  The user can then point at a region of any HP SoftBenchapplication and help text describing that part of the tool will appear in thehelp window.andM;Each piece of text is displayed with a list of related topics.andP;  Selecting therelated topic causes the text for that topic to appear.andP;  The cross referencescan point to topics inside another tool.andM;The normal HP SoftBench intertool communication mechanisms are used to drivethe help system.andP;  When a user selects Application Help, a request is sent tothe help system to display the information.andP;  The tool is not aware of its ownor any other tool's help text.andM;The help data base and communication between the other HP SoftBench tools andthe help tool (the item Help lookup mechanism) require no cooperation fromany application as long as it is implemented with the HP widgets and the Xtoolkit (which stores the needed properties on the widget windows).andP;  The helpmenu items do require minimal cooperation from the application, of course.andO;Ideally, dependence on the HP widgets would not have been needed, but theinformation provided by applications complying with the Inter-ClientCommunication Conventions Manual (see box, page 23) or by the X toolkit  Xtintrinsics) is not sufficient for this level of detail.andP;  interface betweenTools and the Help SystemandM;HP SoftBench tools communicate with the help system via the X protocol andthe HP SoftBench broadcast message server.andP;  Requests for item Help andApplication Help are sent as request messages to the help tool.andP;  A requestfor Application Help includes the application class of the application, and arequest for item Help causes the help tool to grab the pointer (changing thepointer to a question mark temporarily).andP;  For Item Help, the help tool has tofigure out which widget was selected.andP;  This is done without the assistance ofthe specific application as long as the application is built using HPwidgets.andP;  Each widget window stores a property xw_CLASS, which contains thewidget name and the class of the widget window.andP;  The top-level window alsostores the WM_CLASS property containing the name and class of the application(as defined by the Inter-Client Communication Conventions Manuanl).andP;  When theuser selects a window, the help tool determines the smallest enclosing windowcontaining the pointer and then traverses the window hierarchy outward todetermine the widget namelist and classlist used in a resource specificationin the X resource manager.andP;  It looks these up in the help data base to locatethe help text associated with the help window.andP;  This same mechanism is usedby the automated test facilities described in &quot;Architectural Support forAutomated Testing&quot; on page 37.andO;</TEXT></DOC>