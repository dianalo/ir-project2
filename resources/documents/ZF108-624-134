<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-624-134  </DOCNO><DOCID>08 624 134.andM;</DOCID><JOURNAL>Communications of the ACM  July 1990 v33 n7 p52(17)* Full Text COPYRIGHT Association for Computing Machinery 1990.andM;</JOURNAL><TITLE>Constraint logic programming languages.andO;</TITLE><AUTHOR>Cohen, Jacques.andM;</AUTHOR><SUMMARY>Theoretical approaches to program development techniques usingprogram logic arising from PROLOG and similar programminglanguages are advancing the theory of computation in such areas asartificial intelligence (AI).andP;  The pattern matching approach ofPROLOG is being replaced and enhanced with a constraint logicapproach in which variables in an array can have different domainvalues.andP;  This relatively new area of computer science is beingdeveloped theoretically, and new languages are being implemented.andO;The major programming languages used in constraint logicprogramming are Prolog III and CLP (R).andP;  Solutions developed fromthese languages may be applicable in operations research,combinatorics and numerical analysis, symbolic manipulation, andengineering as well as in AI.andM;</SUMMARY><DESCRIPT>Topic:     Programming LanguagesProgram LogicTheoretical ApproachPattern MatchingProgram Development TechniquesTheory of Computation.andO;Feature:   illustrationprogramcharttable.andO;Caption:   Nucleus of a CLP interpreter. (program)Classes of outcomes of logic programs. (chart)Four examples of constraint domains. (table)andM;</DESCRIPT><NOTE>Only Text is presented here; see printed issues for graphics.andO;</NOTE><TEXT>Constraint Logic Programming LanguagesandM;Logic Programming (LP) can be wiewed from two perspectives: one related tomathematical logic and automated theorem proving, the other to thedevelopment and usage of programming languages based on logic [11].andO;Similarly, the motivation for developing Constraint Logic Programming (CLP)can be viewed from these two perspectives.andM;Within the mathematical logic context, CLP represents an effort to establisha class of first-order theories which preserve the basic computationalproperties of Horn-clause logic.andP;  From the programming languages point ofview, the purpose is to establish a class of logic programming languages inwhich the variables can have values in a diverse set of domains includingtrees, booleans, reals, rationals, lists, etc.andP;  [16, 30].andM;The objectives of this article are:andM;* to provide a survey of the recent work done in designing and implementingCLP languages,andM;* to present their theoretical foundations, andandM;* to describe the current research being done in this exciting new area ofcomputer science.andM;This article directed toward users, implementors and designers of LPlanguages; a basic knowledge of Prolog is assumed.andP;  Two of the the main CLPrepresentatives will be emphasized and described: Prolog III and CLP(R).andP;  Thefirst has been proposed by Colmerauer, the originator of Prolog, and the headof the Groupe d'Intelligence Artificielle in Marseille, France; the secondwas developed by a logic programming team at IBM Yorktown Heights.andP;  Bothlanguages have been implemented.andP;  Two other groups, one European [19, 25],the other Japanese [1], have proposed and are currently implementing similarlanguages.andM;The work described in this article is quite recent, it began around 1986.andO;But the use of constraints in Artificial Intelligence had been proposedearlier by Steele and Sussman in 1980 [43].andP;  Constraints have also beenutilized in a graphic language developed by Borning in 1981 [5].andP;  The essenceof their work is illustrated by the following example.andP;  Consider the formulafor translating temperatures from Celsius to Fahrenheit (and vice versa):andM;F = 1.8 * C + 32andM;Steele and Sussman developed programming techniques for computing F given C,or C given F, using a variant of lazy evaluation known as local propagation.andO;Operations are performed only when both operands are known numerical values;this is done by traversing linked lists representing the formula.andP;  When bothF and C are unknown the result becomes the formula itself.andM;It is the author's opinion that the embryonic attempts to introduceconstraints in Prolog are due to Colmerauer with his design andimplementation of Prolog II [14].andP;  In that language the occur test becomesunnecessary since the domain of that language is that of infinite trees [13,15].andP;  The unification of such trees is performed by solving systems ofequations involving tree-valued variables.andP;  Backtracking is initiatedwhenever the equations have no solution; the equations are calledconstraints.andP;  &quot;Disequations&quot; were also introduced by Colmerauer, using thepredicate dif (T1, T2), where T1 and/or T2 can be unbound variables.andP;  If atsome future point T1 and T2 become equal, then this predicate will causebacktracking to occur.andP;  In the language of constraints, dif adds thedisequation T1 [is not equal to] T2 to the current set of constraints.andM;For the sake of establishing a historical record, it should be mentioned thatthe language Absys I (developed in the late 1960s at the University ofEdinburgh) already incorporated some of the features currently used in CLPlanguages [20, 21].andP;  Although non-determinism, the elimination of the occurtest, and testing for satisfiability of systems of equations were alreadypresent in Absys I, the SL theory of Kowalski and Kuehner [32], and theilluminating set of examples of Prolog usage given by Colmerauer and hisgroup were to appear only a few years later.andP;  The author considers the latterdevelopments essential in providing the impetus for the establishment of LPas practiced today.andM;Having presented this brief historical outline, the rationale for introducingconstraints in Prolog is considered.andP;  A natural extension of viewingunification as a method of solving systems of equations involving trees isthe generalization to new domains in which equations can be tested forsolvability.andP;  The following example motivates the introduction ofconstraints.andP;  In Prolog, the equality:andM;1 + X = 3andM;results in a failure, since the operation + is considered as an unevaluatedfunction symbol and the unification algorithm fails!andM;In the past, there have been two unsatisfactory ways to circumvent thisproblem.andP;  The first is to use Peano's axions, (i.e., to define predicatesusing the successor function).andP;  The predicate:andM;plus (X,Y,Z)andM;means that Z is the sum of X plus Y, and the axioms for addition are:andM;plus (O,Y,Y).andP;  plus (s(X),Y,s(Z)):-plus (X,Y,Z).andM;The equation 1 + X = 3 is expressed by the query:andM;?-plus (s(3),X,s(s(s(0)))).andM;resulting in X=s(s(0)).andM;The use of the successor function is obviously only teasible for smallintegers.andP;  Programming with Peano's axioms (like coding Turing Machines) isnot only anachronistic but incompatible with the very high-level-languagecharacteristics of Prolog.andM;The second (unsatisfactory) way to bypass the difficulties of expressing theequality of arithmetic expressions is to write special predicates using testsand assignments which attempt to determine the values of the variables.andP;  Inthe example, this results in:andM;X is 2andM;where the predicate is represents an assignment, always requiring a variableas its left operand.andM;A (still-unsatisfactory) variant of the above is to utilize the predicatefreeze (X,P) which postpones the interpretation of P until X is bound.andP;  Onecould then write:andM;plus(X,Y,Z):-freeze (X, freeze(Y,Z is X+Y)), (Y, freeze (Z, X ix Z+Y)), (Z,freeze (X,Y is Z+X)).andM;A general and clean solution to this problem is to replace unification oftrees by constraints such as the equality of arithmetic expressions.andP;  Forexample, the constraint:andM;2 + X = Z + 3andM;will be handled as in algebra.andP;  The actual values for X or Z may be computedlater when more constraints are added.andP;  &quot;Dead end&quot; situations occur when thesystem of constraints is unsatisfiable, and such situations result inbacktraking, just as in Prolog.andM;Program variables in CLP behave like mathematical variables, and the proposedlanguages cover a variety of domains (e.g., reals, booleans), relations(e.g., equalities, inequalities), and operations (e.g., addition,multiplication) that are used in expressing systems of constraints.andP;  A uniquecharacteristic of the CLP class of languages is that their semantics share alarge common nucleus.andP;  (This nucleus will be presented in the sectionsentitled &quot;Basic Theoretical Results&quot; and &quot;Overview of Theoretical Foundationsof CLP Languages.&quot;)  Most other language classes do not enjoy this property.andO;For example, apparently similar imperative languages (e.g., Pascal and Ada)or functional languages (e.g., Lisp and Scheme) can differ markedly in theirdenotational and operational semantics.andM;In the next section we present a few examples of CLP programs to illustratethe need for constraint languages (A fairly large body of examples appears in[17, 24] and the interested reader is encouraged to examine them).andM;A Few ExamplesandM;The first example presented is the classic program for computing Fibonacciseries.andP;  Before presenting it, it is helpful to consider its Prologcounterpart:andM;fib(0,1).andP;  fib(1,1).andP;  fib(N,R):-N1 is N-1.andP;  fib(N1,R1), N2 is N-2,fib(N2,R2), R is R1+R2.andM;The is predicate prevents the program from being invertible: the queryfib(10,X) succeeds in producing X=89 as a result, but the query fib(Y,89)fails, since N is unbound and the assignment to N1 is not performed.andP;  Notethat if we had placed the predicate N [is greater than or equal to] 2 priorto the first recursive call, the query fib(Y,89) would also fail, since thevalue of N is unbound and the test of inequality cannot be accomplished bythe Prolog interpreter.andM;The modified CLP version of the program illustrates the invertibilitycapabilities of CLP interpreters:andM;fib(0,1).andP;  fib(1,1).andP;  fib(N,R1+R2):- N [is greater than or equal to] 2,fib(N-1,R1), fib(N-2,R2).andM;where N [is greater than or equal to] 2,andM;The query:andM;?- fib(10,Fib)andM;yields Fib = 89, and the query:andM;?-fib(N,89)andM;yields N = 10.andM;The second example presented is a sorting program.andP;  For the purposes of thisarticle, it is unnecessary to provide the code of this procedure (see [44]);qsort (L, S) sorts an input list L by constructing the sorted list S.andM;When L is a list of variables, a Prolog interpreter would fail since unboundvariables cannot be compared using the relational operator [is less than orequal to].andP;  In CLP, the query:andM;?- qsort ([X1,X2,X3], S).andM;yields as result S = [X1,X2,X3], X1 [is less than or equal to] X3.andP;  Whenrequested to provide all solutions, the interpreter will generate all thepermutations of L as well as the applicable constraints.andM;The third and final example is the determination of the equation representingcircles passing through two points.andP;  The following unit clause specifies apoint of coordinates X, Y lying on the perimeter of a circle whose center hascoordinates A and B.andM;on_circle (p(X,Y) ,c(A,B,[(X-A).sup.2] + [(Y-B).sup.2])).andM;The query:andM;?- on_circle (p(7,1),C), on_circle(p(0,2),C).andM;yields the two constraints:andM;-2*B + 14*A - 46 = 0 -[R.sup.2] + 50*[A.sup.2] - 350*A + 625 = 0andM;The first equation represents the straight line containing the loci of thecenters of all circles passing through the two given points.andP;  The secondequation enables the calculation of the corresponding radii.andM;This example involves non-linear equations and cannot be processed usingeither of the two major languages.andP;  The above results were obtained using aCLP meta-level interpreter developed at Brandeis University.andM;This section concludes by noting that constraints can be used to increase thepurity of programs by avoiding cuts and the not operator.andP;  For example, theprogram:andM;p :-q,!,[alpha].andP;  p :-[beta].andM;where q is a constraint, can in certain cases be transformed into theequivalent one:andM;p :-q,[alpha].andP;  p : -q,[beta].andM;with q' being the complement of q(e.g., if the main predicate of q is = (or[is less than]), that of q' becomes [is not equal to] (or [is greater than orequal to]).andP;  The same artifice can be utilized to avoid certain uses of thenot operator.andM;Meta-Level Interpretation andandM;Abstract MachineandM;Two approaches for defining the inference mechanism utilized in constraintlogic programming languages are presented in this section.andP;  The first is ameta-level interpretation allowing the description of interpreters for thelanguages (such as Lisp or Prolog) using the languages themselves.andP;  Thesecond approach is based on automata theory.andM;In Prolog, the meta-level interpreter for pure programs consists of a fewlines of code.andP;  The procedure solve has as a parameter a list of Prolog goalsto be processed.andP;  The interpreter assumes that the program rules are storedas unit clauses:andM;clause(Head,Body).andM;each corresponding to a rule:andM;Head :- Body.andM;where Head is a literal and Body is a list of literals.andP;  Unit clauses arestored as:andM;clause(Head, []).andM;The interpreter is:andM;solve ([]).andP;  solve ([Goal|Restgoal]):- solve(Goal), solve(Restgoal).andO;solve(Goal):- clause(Goal,Body), solve(Body).andM;In CLP languages, a rule is represented bydandM;clause(Head,Body,Constraints)andM;corresponding to a rule:andM;Head:- Body {Constraints}.andM;The modified procedure solve contains three parameters:andM;1) the list of goals to be processed,andM;2) the current set of constraints, and 3) the new set of contraints obtainedby updating the previous set.andM;The meta-level interpreter for CLP, written in Prolog, is show in Figure 1.andM;The heart of the interpreter is the procedure merge-constraints, which mergestwo sets of constraints: the previous constraints, Previous_C, and theconstraints introduced by the current clause, Current_C.andP;  If there is nosolution to this new set of constraints, the procedure fails; otherwise, itsimplifies the resulting constraints, and it binds any variables which havebeen constrained to take a unique value.andP;  For example, the constraints X [isless than or equal to] 0 [and] X [is greater than or equal to] 0 simplify tothe constraint X = 0, which implies that X can now be bound to 0.andM;The design consideration which influence the implementation of this procedurewill be discussed in the section entitled &quot;Design and Implementation Issues.&quot;andO;Note that the controversial unit LIPS (logical inference steps per second),often used to estimate the speed of Prolog processors, loses its significancein the case of a constraint language.andP;  The number of LIPS is established bycounting how many times per second the procedure clause is activated; in thecase of CLP, the time to process clause and merge_constraints may varysignificantly depending on the constraints being processed.andM;The second approach to describing the inference mechanism for a CLP languageis to consider an abstract machine of the type suggested by Colmerauer inProlog III.andP;  It resembles a push-down automaton [27] whose stack is updatedwhenever a program rule is applied.andM;We define a constraint-machine state [sigma] as the triplet:andM;[sigma] = (W, [t.sub.0'[t.sub.1]...[t.sub.n], S}andM;in which:andM;W is the list of variables which appear in the original query,[t.sub.0][t.sub.1]...[t.sub.n] is a list of terms (goals), and S is a list ofcurrent (satisfiable) constraints.andM;An inference step for the machine consists of making a transition from thestate [sigma] to a state [sigma]' by applying a program rule:andM;[s.sub.0] [right arrow] [s.sub.1]S.sub.2...[s.sub.m], R (m [greater than orequal to] 0)andM;in which the s/s are terms and R is the set of constraints specified by therule.andP;  The new state [sigma]' becomes:andM;[sigma'' = (W, [s.sub.1]...[s.sub.m][t.sub.1]...[t.sub.n], S [union] R[union] ([s.sub.0] = [t.sub.0]}},andM;if (S [union] R [union] ([s.sub.0] =t.sub.0)) is satisfiable.andP;  Otherwise,another rule has to be tried nondeterministically.andP;  Note that the queryvariables W remain unchanged throughout the execution of a program.andM;As in the case of Prolog, there are two types of nondeterminism that arise inthe sequential interpretation of CLP programs: the first is the choice of anapplicable clause in the program, and the second is the selection of theliteral in the goal list that will be processed first.andM;It should be noted that the expression:andM;S [union] R [union] ([s.sub.0] = [t.sub.0])andM;corresponds to the result of the procedure merger_constraints describedearlier in this section.andP;  It will be shown later that the list W is useful inthe presentation of the output of a solution.andP;  A solution is found when afinal state is reached; it has the form:andM;[sigma]f = (W, [epsilon], final_Constraint)andM;where [epsilon] is the empty sequence.andP;  In this case, the Final_Constraint issimplified, and then output in terms of the variables in W and, if necessary,some additional ones.andM;Basic Theoretical ResultsandM;The objective of this section is to provide the reader with a summary of thefundamental results applicable to logic programs (see [2, 35]).andP;  It will beshown in the next section that these results remain applicable to a wideclass of constraint logic programs.andM;Consider a logic program P consisting of (definite) Horn clauses such as:andM;p [left arrow] [q.sub.1],...,[q.sub.n].andP;  (n [is greater than or equal to] 0)andM;in which p and the qi's are all positive literals.andP;  Recall that the logicreading of the above is:andM;p is true if [q.sub.1] and [q.sub.2]...andP;  and [q.sub.n] are trueandM;or, in the case where n = 0, simply:andM;p is true.andM;A query Q is a conjunction of positive literals [t.sub.1][t.sub.2],.andO;.,[t.sub.m] with m [is greater than or equal to] 1.andP;  Let us initially assumethat all literals [t.sub.1 in Q are ground, (i.e., do not contain variables).andO;The first of the main theoretical results is due to Hill [26] and it can besummarized as follows:andM;(a) Equivalence of the logical and operational meaning of programs: a correctinterpreter of the program (i.e., an SLD breadth-first prover) will provide ayes answer to Q if and only if Q is a logical consequence of P.andM;The second main result reinforces the first by providing yet another meaningfor logic programs, based on set theory.andP;  Consider the set [S.sub.0] of theunit clauses in P.andP;  If these clauses contain variables, then each such clauserepresents a potentially infinite number of ground literals where thevariables are replaced by every possible ground term (and their combinations)appearing in P, (i.e., the so-called elements of the Herbrand Universe).andP;  Let[S.sub.0' be the set of ground instances of unit clauses.andP;  Consider now theground instances of the rules in P in which all the q/s in their bodies areelements of [S.sub.0].andP;  Let T([S.sub.0]) be the set of heads of these groundsrules.andP;  Basically this operation amounts to finding all ground termscorresponding to the application of one rule.andP;  Note that [S.sub.0] *T([S.sub.0]) since unit clauses have empty bodies.andP;  Let us define T [uparrow] n as the result of applying T to [S.sub.0] n times.andP;  Note that:andM;T [up arrow] i * T [up arrow] (i + 1)andM;and let us define:andM;[Mathematical Expression Omitted]andM;This is the set of all ground terms that can be proved from the unit clausesby applying some finite number of rules.andP;  It can be shown that T [up arrow][omega] is the least-fixed-point of T, i.e., the smallest set S such that:andM;T(S) = SandM;The second important theoretical result due to Van Emden and Kowalski [46]can be stated as follows:andM;(b) Given a program P and a ground query Q, then (a) applies (i.e., Q is alogical consequence of P), if and only if the conjuncts of Q are members ofthe least-fixed-point set T [up arrow] [omega] of P, and conversely.andM;It can be shown that the results (a) and (b) generalize to include queriescontaining variables.andM;Note that these results are only applicable to (definite) Horn-clauseprograms P and queries Q yielding a yes answer.andP;  The results that explain themeaning of the program P and the query Q when the interpreter provides a noanswer are now summarized.andP;  Clark [10] defined the completion of a Prologpredicate to be a non-Horn formula, that gives both necessary and sufficientconditions for the predicate to be true.andP;  For example, the completion of:andM;p [left arrow] ...andP;  p [left arrow] [t.sub.i], ..., [t.sub.m]andM;is the formula:andM;[Mathematical Expression Omitted]andM;combined with the axioms specifying the equality of terms.andM;The following property corresponding to (a) is due to [10] and to [28]:andM;(a) A correct interpreter of the program (i.e., an SLD breadth-first theoremprover) will provide a no answer to Q if and only if * Q is a logicalconsequence of the completion of P.andM;To establish the property corresponding to (b) for the case of no answers, weagain use the operator T.andP;  First consider the set [H.sub.0], called theHerbrand base, whose elements are the literals of P in which variables arereplaced by elements of the Herbrand Universe.andP;  Let T [down arrow] n bedefined as the result of applying T to [H.sub.0] n times.andP;  Note that:andM;T [down arrow] i * T [down arrow] (i + 1_andM;and let us define:andM;[Mathematical Expression Omitted]andM;It should be noted that T [down arrow] [omega] is not necessarily a fixedpoint of T.andM;The property (b') corresponding to (b) for programs yields a no answer is(see [28]):andM;(b) Q is a logical consequence of the completion of P if and only if someconjunct of Q is not a member of the set T [down arrow] [omega].andM;Besides programs yielding yes or no answers, there are those which loop.andP;  Thehalting problem tells us that we cannot hope to detect all the programs whichwill eventually loop.andP;  Let us consider, as an example, the program [P.sub.i]:andM;p (a).andP;  p(b): -p(b).andM;As expected, the queries:andM;[Q.sub.1] : p(a), [Q.sub.2] : p(c)andM;yield respectively:andM;yes and noandM;since p(a) is a consequence of [P.sub.1.,] and *p(c) is a consequence of thecompletion of [p.sub.1], i.e.:andM;[Mathematical Expression Omitted]andM;But the interpreter will loop for the query [Q.sub.3] : p(b), or when allsolutions of [Q.sub.4] : p(X) are requested.andM;The sets t [up arrow] [omega] and T [down arrow] [omega] for [P.sub.1] aredepicted graphically in Figure 2a).andP;  The corresponding graphical setrepresentation for any logic program P is depicted in Figure 2b).andM;The complement of the set T [down arrow] [omega] defines the so-called finitefailure set F.andP;  If a query Q is in F then the execution of program P willyield a no answer.andM;A final example illustrates the semantic problems involved in using the notoperator, as defined in Prolog by:andM;not(X) : -X,1, fail.andP;  not (X).andM;This is a convenient way of implementing negation which is not yet thoroughlyunderstood: no rigorous semantic theory exists when not is employed in thebody of clauses.andP;  From a logical point of view such clauses are not Hornclauses and properties (a) and (b) are no longer applicable.andM;Consider the program [P.sub.2]:andM;p(a).andP;  q(b).andM;The query not (p(X)),q(X) yields a wrong no answer, since X is initiallybound to a, not (p(X) fails, and the binding of X is lost!andP;  By reversing theorder of the elements of the query to q(X), not (p(X), X is correctly boundto b and not (p(X) succeeds.andP;  [1]andM;Overview of Theoretical FoundationsandM;of CLP LanguagesandM;The theoretical underpinnings that have been proposed to explain the meaningof constraint logic programs are summarized in this section.andP;  Two approacheshave been explored.andP;  Jaffar and Lassez [29] provide a meta-theory insuringthat propositions (a, a') and (b, b') remain applicable in the case ofconstraint programs, provided the domains being considered satisfy certainconditions that will be explained below.andP;  The other approach, taken byColmerauer [17], is to describe the meaning of programs by establishing therelationship between rewriting rules representing the programs and the set ofsolutions obtained by applying these rules.andM;Jaffar and Lassez's ApproachandM;This approach replaces the unification of trees (terms) by considering itstwo components.andP;  The first is a theory [tau], which, in the case of trees,corresponds to a set of axioms defining the equality of terms.andP;  Note thatthese axioms are expressed by general predicate-calculus formulas (see [10]).andO;The second component is a model R: i.e., a mathematical description of theobjects and relations that are axiomatized by the theory [tau].andP;  In the caseof Prolog, the model is the set of finite trees with the usual equalityrelation and the theory is Clark's equality theory.andM;Both [tau] and R are defined in terms of two (finite) sets:andM;II: the set of predicate symbols, e.g., in the case of trees {=}andM;[Epsilon]: the set of function symbols, e.g., in the case of trees all(unevaluated) function symbolsandM;Another example of an interesting constraint domain is that of infinite treesand dif, as proposed by Colmerauer for Prolog II [14].andP;  In that case:andM;R: infinite trees [tau]: axioms defining the equality and disequality ofinfinite trees II: %=, [is not equal to]} [Epsilon]: as in the previousexampleandM;A basic property linking [tau] and R is: a constraint is satisfiable in thetheory [tau] if and only if it is satisfiable in its model R.andM;Jaffar and Lassez have shown that properties (a, a') and (b, b') of theprevious section remain valid for a new constraint domain D provided that:andM;(1) the theory [[tau].sub.d] is satisfaction-complete, i.e., every constraintis either provably satisfiable or provably unsatisfiable.andM;(2) the model [R.sub.D] is solution-compact, i.e., each element of the domainD can be specified by a (potentially infinite) number of constraints, and thecomplement of any constraint can be specified by a (possibly infinite) numberof constraints.andM;Table I contains four examples of constraint domains satisfying (or not)satisfaction-completeness and solution-compactness.andP;  Note that Condition (1)is satisfied when there is an algorithm for determining if a constraint is oris not satisfiable.andP;  For example, the unification algorithm applied to trees(as in prolog satisfies this property.andP;  Note also that Condition (2) iseasily satisfied in the case of Prolog.andM;Since the unification (equality) of infinite trees, as well as the predicatedif of (pure) Prolog II satisfy Conditions (1) and (2), one can infer thatproperties (a, a') and (b, b') of the previous section remain valid forprograms written in that language.andM;It is fairly straightforward to show that the existing constraint languagesalso satisfy Conditions (1) and (2).andM;From a purely theoretical point of view, the (hypothetical) inexistence ofRobinson's unification algorithm would imply that a theorem prover would haveto operate using a set of full first-order predicate-calculus calculus axiomsspecifying the equality (or disequality) of finite (or infinite) trees.andM;The beauty of the Jaffar and Lassez meta-theory is that they have establishedconditions under which the basic theorems of logic programming remain valid,provided that the set of proposed axioms specifying constraints satisfy thedescribed properties.andM;A convenient (although incomplete) taxonomy for CLP languages is to classifythem according to their domains or combinations thereof.andP;  One can have CLP(Rationals), or CLP (Booleans, Reals).andP;  Prolog can be described as CLP(Trees) and CLP (R) as CLP (Reals, Trees).andP;  A colleague of the author's (T.andO;Hickey) has pointed out the existence of CLP(); it corresponds toparameterless Horn clauses or to a puzzling language in which only variablesare allowed without specifying their domain.andP;  (2)  A complete specificationof CLP language would also have to include the predicates and operationsallowed in establishing valid constraints (see examples in Table I).andM;From the language-design perspective, the designer would have to demonstratethe correctness of an efficient algorithm implementing the test forconstraint satisfiability.andP;  This is equivalent to proving the satisfiabilityof the constraints specified by the axioms.andM;Colmerauer's ApproachandM;This approach is based partly on the analogy between top-down parsers and SLDtheorem provers.andP;  The reader is referred to [11], where this analogy isdescribed in greater detail.andP;  Essentially, a literal is considered as anon-terminal and a logic program is viewed as a sequence of context-freerewriting rules [27].andP;  Unit clauses correspond to rewriting the correspondingnon-terminal into the empty sequence [epsilon].andP;  A query corresponds to asequence of non-terminals, and it succeeds if those non-terminals can bewritten into [epsilon] (i.e., erased) using the program rules.andP;  In otherwords, every non-terminal has a finite parse tree whose leaves are [epsilon].andO;These trees are the counterpart of the proof trees in theorem proving and theabstract machine (in the section entitled &quot;Meta-Level Interpretation andAbstract Machine&quot;) is the parsing push-down automation.andP;  It should be notedthat a rule containing variables actually represents a potentially infinitenumber of rules in which the variable is replaced by all possible values thatcan be assigned to it.andP;  (This situation is not unlike the one evoked in theprevious section in describing the T [up arrow] operator).andM;Colmerauer proposes a self-contained theoretical description of the semanticsof a constraint language assuming that notions such as: domain of therationals, addition, multiplication, etc., are well known and need noaxiomatization.andM;In his approach, a term is constructed using known operations (or partialoperations) on variables, constants and function symbols in a given domain.andO;In Prolog III the basic domain is that of infinite trees.andP;  A program ruleconsists syntactically of a pair: rewriting rule {constraints} in which: (1)a rewriting rule specifies that a term can be rewritten into a (possiblyempty) sequence of terms, and (2) a constraint is a relation on terms.andM;Operations are partial since they are chosen by the language designer to beapplicable only to selected subsets of the domain being considered.andP;  Forexample, the operation x*y is only defined when x and y are numbers, (i.e.,andO;trees consisting of a leaf labeled by a number).andP;  Furthermore, only one ofthem is allowed to be an unknown so that the satisfiability of constraintscan be tested using efficient techniques applicable to linear arithmetic.andM;Semantically, a program rule represents a set of potentially infinite numberof ground rules obtained by replacing the variables in the rule with elementsof the basic domain such that (1) the rule's constraints are satisfied, and(2) the rule's operations are well defined.andM;A program is a set of such rules and it provides the accumulated constraintsobtained by successive rewritings of a query, using the abstract machinedescribed in the section &quot;Meta-Level Interpretation and Abstract Machine.&quot;andM;In an implementation of Colmeraurer's model, backtracking is initiated when:(1) the current set of constraints is unsatisfiable, or (2) it is meaninglessto apply an operation to the given operands.andM;A fact deducible by erasure (3) is a term (for instance, a query) which canbe rewritten in to the empty sequence using the program's rules.andM;A ground program rule:andM;head: - bodyandM;has two equivalent meanings: (1) the head can be rewritten as the body, or(2) if the elements of the body are found to be true (by erasure) then thehead must also be true.andP;  Colmerauer's result embodies features of bothpropositions (a) and (b) of the previous section.andM;Given a program P, its set of facts deductible by ensure is the smallestsubset of the domain satisfying the logical implications represented by therules of P.andM;RemarksandM;A comparison between the two approaches above is admittedly difficult.andO;Although some of their authors' aims overlap, their approaches are different.andO;Jaffar and Lassez are basically interested in a meta-theory applicable to anyconstraint language.andP;  Their emphasis is on the applicability of the theory tovarious domains rather than on the interaction between domains and theresulting complexity of an interpreter (or compiler) needed to processprograms in the language.andP;  In contrast, Colmerauer's theoretical workconcentrates on providing the semantics of a family of languages in whichgreat care is given to presenting a precise description of how the constructspertaining to different domains should interact so as to achieve a feasiblelanguage processor.andM;In Colemerauer's work the applicability of the theory to other domains isimplicit and based on mathematical arguments.andP;  In Jaffar and Lassez'sapproach the applicability is explicit and based on the existence of body ofhistorical results in logic.andM;Domains and ConstraintandM;SatisfiabilityandM;The various individual domains that have been considered in the design of themain existing constraint languages will be addressed in this section.andP;  In thenext section, the problems of combining several domains will be discussed.andM;Real Closed Fields (RCF)andM;This domain, as illustrated in the second and third examples in Table I,satisfies the conditions (1) and (2) of Jaffar and Lassez's meta-theory.andO;Tarski [45] has shown that there is a decision procedure for testing thesatisfiability of systems of general equations and inequations in that domain(also see [3]).andP;  However, the formidable complexity (4) of the algorithmrenders its direct usage by an interpreter infeasible.andP;  But this statementmust be qualified: simplified versions of the algorithm may suffice for manyinteresting problems.andP;  Collins [12] has already implemented programs whichcan solve certain classes of problems in RCF.andM;More recently, algorithms for determining the socalled Grobner Basis (5) havebeen developed to test the satisfiability of systems of polynomial equationsin RCF.andP;  The algorithm proposed by Buchberger [8] has been successfully usedin implementing special constraint languages.andP;  However, a word of caution isin order.andP;  The Grobner method tests whether a system of multivariatepolynomial equations has a solution over the complex numbers.andP;  Therefore, itspractical usage in a constraint language is to test the unsatisfiability of asystem of polynomial equations.andP;  If the system fails the Grobner test, thenit has no complex solutions, and consequently, no real solutions.andP;  If theGrobner test succeeds, further tests are needed to check if the solutions arereal, and not complex.andM;The worst-case complexity of the Grobner basis algorithm is doublyexponential (No &quot;average case&quot; complexity analysis is known).andP;  Note that itis possible to extend the Grobner basis method to the case of inequalities byusing Collins' techniques [12].andM;Most of the existing constraint languages utilize subsets of RCF, which haveefficient algorithms for testing the satisfiability of systems ofconstraints.andP;  Linear equations and inequations are allowed in both CLP(R) andin Prolog III.andP;  The latter only deals with rational numbers, whereas theformer includes reals.andP;  The design strategy for Prolog III is to consider theconstraint satisfaction test as a &quot;black box&quot; which should always return ayes or no answer.andP;  By using multiple precision rational arithmetic, one canmake an exact test for equality of numbers.andP;  On the other hand, CLP(R)utilizes real (floating point) numbers, so the test for equality must be doneby making explicit the precision with which real numbers can be tested.andP;  Thistask is relegated to the programmer or to the language implementor (as withmost current languages).andM;There is a wealth of algorithms and programs available for testing thesatisfiability, and finding solutions, of systems of linear equations andinequations.andP;  These algorithms have been developed in past decades bynumerical analysts and specialists in operations research.andP;  Gaussianelimination and the simplex method [36] are typical examples of suchalgorithms, and they have been used by implementors of interpreters ofconstraint languages.andP;  It will be seen in the next section that thesealgorithms have to be adapted or modified to increase the efficiency ofconstraint language processors.andM;As mentioned previously, the predicate [is not equal to] denoting the&quot;disequality&quot; of terms can also be introduced when using rational or realarithmetic; the equivalent predicate dif is already available in Prolog II,and its implementation in Prolog III is analogous to that of its predecessor[14].andP;  Disequalities are not yet available in CLP(R): the user must simulatethe effect by using other predicates.andM;An added advantage of this predicate is that it easily allows the use of thesimplex method involving strict inequalities.andP;  A slack variable X [is greaterthan or equal to] 0 combined with the constraint X [is not equal to] 0produces the desired effect.andM;BooleansandM;The constraints in this case are formulas in two-valued boolean algebra usingthe standard operators (*, [or], [and], [triple bond], *).andP;  It is well knownthat the worst case complexity of the algorithms for testing thesatisfiability of a system of boolean equations is exponential with thenumber of variables.andP;  Nevertheless, little is known about the &quot;average case&quot;(6) complexity.andP;  It is appropriate to draw a parallel between this situationand that encountered in the simplex method: although the worst casecomplexity of the simplex method is theoretically exponential, the averagecase is known to be polynomial.andM;There are several algorithms which have been proposed for testing thesatisfiability of boolean formulas.andP;  The classic ones are described in mostlogic textbooks.andP;  The approach utilized in Prolog III is that of SLresolution, which has been successful in proving theorems in the predicatecalculus [32].andP;  (The reader is referred to [11] for a Prolog description ofthis method).andP;  The version of SL resolution used in Prolog III is that ofSiegel [41].andP;  A detailed description of the algorithms is provided in [4].andM;Constraint language designers should be aware of two characteristics of theSL resolution method.andP;  First, it requires that formulas be translated intoclausal form, a task which may, in the worst case, also require exponentialtime and space.andP;  Second, in the case of satisfiability, the method canprovide a simpler system of boolean formulas equivalent to the one beingconsidered.andP;  In addition, the method is incremental in the sense that itavoids redoing computations.andP;  It will be seen in the next section thatincrementality and simplification play an important role in the choice ofalgorithms for testing the satisfiability of systems of constraints.andM;Other methods have been recently proposed to test the satisfiability ofsystems of boolean equations.andP;  One of them, [9], makes extensive use of theexclusive-or operator; the other [39] avoids the translation into clausalform.andP;  The appropriateness of these methods in constraint language processorsremains to be verified.andM;ListsandM;Although there are methods capable of checking the equality of two generallists containing variables, their complexity is forbidding [37].andP;  Thissituation parallels that of Tarski's decision procedure for RCF.andP;  In Prologprograms the ubiquitous lists are considered as sequences of embeddedappearances of the cons function.andP;  In Prolog III lists are given a specialstatus as a domain.andP;  The key operation in this domain is concatenation.andP;  Itsfunction is to append one list to another.andP;  Efficient implementation isguaranteed by requiring that the size of the first list be a known integerwhen the operation is performed.andP;  (7)  It can be shown that the concatenationof such strings can be done in constant time.andM;Design and Implementation IssuesandM;A dilemma facing constraint language implementors is the selection of theappropriate algorithm for testing the satisfiability of systems ofconstraints in a given domain.andP;  Two extreme approaches can be envisioned.andO;The first could be characterized as &quot;killing a rabbit with an elephant gun,&quot;(i.e., using an overly general and complex program to solve a relativelysimple problem).andP;  (An example might be the use of the Grobner Basis method totest the satisfiability of linear equations.)andM;An implementor may initially frown at such wastage; nevertheless, thispossibility should not be discarded a priori.andP;  The decreasing costs of(parallel) computers and the increasing costs of software development mayencourage such &quot;brute force&quot; solutions.andM;The other extreme approach is to develop an arsenal of carefully designedprogram tools, each applicable to a specific type of constraint problem.andO;This may be feasible when the complexity of determining the applicable toolis small, and the implementors have the resources needed to develop a varietyof specialized programs.andM;A wise choice of an appropriate constraint algorithm will probably avoidthese two extremes.andP;  Presently, it is fair to say that implementors lean moretoward the second approach; however, this situation may change as machinesbecome less expensive.andP;  It should be recalled that in the early constraintlanguages [5, 43] a great deal of programming effort was devoted to replacingthe solution of systems of linear equations by ad hoc methods.andP;  This is nolonger true for the current constraint languages.andM;There is an important implementation consideration that appears to befulfilled in both CLP(R) and Prolog III: the efficiency of processing Prologprograms (without constraints) should approach that of current Prologinterpreters, i.e., the overhead for recognizing more general constraintsshould be small.andP;  As indicated earlier, this strategy shows that, at least atpresent, the implementors prefer to avoid the &quot;brute force&quot; approach.andM;There are three factors that should be considered when selecting algorithmsfor testing the satisfiability of systems of contraints used in conjunctionwith CLP processors.andP;  They are:andM;* incrementalityandM;* simplificationandM;* canonical formsandM;The first is a desirable property which allows an increase in efficiency ofmultiple tests of satisfiability (by avoiding recomputations).andP;  This can beexplained in terms of the abstract machine described earlier in this article:if the current system of constraints S is known to be satisfiable, the testof satisfiability of:andM;S [union] R [union] ([s.sub.0] = t.sub.0])andM;should be incremental, minimizing the computational effort required to checkif the formula remains satisfiable ot not.andP;  Classical Prolog interpretershave this property, since previously performed unifications are notrecomputed at each inference step.andP;  There are modifications of Gaussianmethods for solving linear equations which also satisfy this property.andP;  (8) This is accomplished by introducing temporary variables and replacing theoriginal system of equations by an equivalent one of the form (see [30]):andM;variable = linear terms involving only the temporary variablesandM;The simplex method can also be modified to satisfy incrementality.andO;Similarly, the SL resolution method for testing the satisfiability of booleanequations, and the Grobner method for testing the satisfiability ofpolynomial equations, also have this property.andM;In nearly all the domains considered in the previous section, it may bepossible to replace a set of constraints by a simpler set.andP;  Thissimplification can be time consuming, but is sometimes necessary.andP;  Theimplementor of CLP languages may have to make a difficult choice as to whatlevel of simplification should occur at each step verifying constraintsatisfaction.andP;  It may turn out that a system of constraints eventuallybecomes unsatisfiable, and all the work done in simplification is lost.andM;The problem of whether or not simplification should be performed is notunlike that of garbage collection (GC): one could call it a semantic GC.andP;  Awell-known design strategy for classical GC is to perform it only whenstrictly necessary.andP;  A similar strategy might be used in the simplificationof constraints: when a final results has to be output, it becomes essentialto simplify it and present it to the reader in the clearest, most readableform.andM;An important function of simplification is to detect the assignment of avariable to a single value (e.g., from X [is greater than or equal to] 1 andX [is less than or equal to] 1 one infers X = 1).andP;  This property is essentialwhen implementing the control procedure freeze (X,P), in which the procedureP is executed only when X is assigned to a single value.andM;The sorting example presented earlier illustrates well the problems involvedin simplification.andP;  Recall that the result of a symbolic sorting of the list[X1, X2, X3] is the set of constraints:andM;X1 [is less than or equal to] X2 and X2 [is less than or equal to] X3andM;However, it is easy to check that the redundant constraint:andM;X1 [is less than or equal to] X3andM;would also be generated by the interpreter, and it should be eliminated bysimplification.andM;The extent to which a final constraint should be simplified is a touchydesign decision.andP;  In well-developed symbolic algebra languages, such asMacsyma, an arsenal of simplifying tools is available, and their selection isinteractively made by the user.andP;  Perhaps the same will occur in future CLPlanguages.andM;A topic related to simplification is that of finding a minimal set ofconstraints, equivalent to a given set.andP;  In the case of booleans this minimalset can be defined and computed, but the computational costs are prohibitive(such algorithms are used in VLSI design however).andM;The incremental algorithms for testing the satisfiability of linear equationsand inequations, as well as that used in the Grobner method for polynomialequations, are capable of discarding redundant equations; therefore, theyperform some simplifications.andM;The canonical forms referred to earlier in this section can be viewed as(internal) representations of the constraints which facilitate both the testsof satisfiability and the ensuing simplifications.andP;  For example, in the caseof the Grobner method for solving polynomial equations, the input polynomialsare internally represented in a normal form, such as variables arelexicographically ordered and the terms of the polynomials are orderedaccording to their degrees.andP;  This ordering is essential in performing therequired computations.andP;  Also note that if two seemingly different constraintshave the same canonical form, only one of them needs to be considered.andO;Therefore, the choice of appropriate canonical forms deserves an importantconsideration in the implementation of CLP languages [34].andM;It is worth making a final comment about the eventual use of automatictheorem provers in testing the satisfiability of systems of constraints (see[6]).andP;  Just as in the case of simplification the user may have to resort toseveral specialized tools capable of solving specific classes of theorems.andM;A Comparison of Two ApproachesandM;As noted earlier in this article, the Prolog III design philosophy fortesting contraints satisfaction was to consider this operation as alwayscapable of providing a yes-no answer, within a reasonable amount of time, andusing present-day computers.andP;  To fulfill that goal, Colmerauer selected thedomains of infinite trees, rationals, booleans and lists.andP;  The relations =and [is not equal to] are applicable to all the domains (in the case ofbooleans = corresponds to * and [is not equal to] to *).andP;  The alloweddomains, relations, and operations for Prolog III are summarized in Table II.andO;In contrast, the current CLP(R) processor covers only two domains: finitetrees and reals.andP;  (9)  The predicate for expressing tree constraints isequality, and the constraint predicates applicable to reals are [is lessthan], [is less than or equal to], [is greater than], [is lessthan or equalto].andM;Lists in CLP(R) are as in Prolog: a convenient syntactic notation is providedfor representing them; however, it is up to the programmer to define explicitoperations for their manipulation.andM;The strategy of the designers of CLP(R) is to allow a postponement of thesatisfiability test of systems of constraints.andP;  It has been shown that,according to Tarski's results [45], these tests are theoretically possible;however, they are also prohibitively complex.andP;  The CLP(R) designers opted fora pragmatic approach: the test of satisfiability of non-linear equalities andinequalities is postponed with the expectation that they might become linear,in which case the known efficient algorithms are applicable.andP;  However, thereis a caveat: if a solution is found in which the final set of constraints Cincludes non-linear constraints, it is up to the user to attempt to testwhether they are satisfiable or not.andP;  Therefore the CLP(R) processor's outputto such problems is : maybe, followed by C.andP;  If the user can determine that Cis indeed satisfiable, then the maybe answer is equivalent to a yes;otherwise, not only is the maybe a no, but it may become difficult to&quot;manually&quot; backtrack to the previous state of which a predecessor of C isindeed satisfiable.andM;The richness of domains in Prolog III, coupled with the design philosophy ofconsidering the test for constraint satisfaction as a &quot;black box&quot; capable ofproviding a yes-no answer in reasonable time, forced its designer tointroduce partial operations and to give careful consideration to howconstraints in various domains can be combined.andP;  An example illustrates thissituation: consider two linear inequalities [I.sub.2] and [I.sub.2] over therationals.andP;  [I.sub.1] V [I.sub.2] is not a valid boolean term in (standard)Prolog III (10), since the test for its satisfiability is computationallycomplex.andP;  Note that a variant of the simplex method can be used to test thesatisfiability of [I.sub.1] or [I.sub.2] individually.andP;  However, since[I.sub.1] V [I.sub.2] may represent a non convex polyhedron, the simplexmethod is no longer applicable.andP;  A considerable part of the formaldescription of Prolog III is devoted to these problems [17].andP;  At present, thetype checking of programs is performed at compile time.andM;Two other interesting features of Prolog III are worth mentioning.andP;  The firstis the existence of basic operators capable of determining the identifierrepresenting the functor of a term and its arguments.andP;  In classic Prolog,this is done using ad hoc built-in procedures which are difficult to defineformally.andP;  The second feature was also designed to replace the usage of thebuilt-in procedure call(X) by the simpoler term X.andP;  Recall that in PrologIII, there is no distinction between the terms and literals.andP;  The theory ofrewriting rules (contained in the section &quot;Colmerauer's Approach&quot;) isapplicable to sequences of trees, and X is simply a tree.andM;Applications Using CLPandM;Now that the main aspects of CLP languages and processors have beendescribed, it is tempting to predict the various problem areas in whichconstraints will play an important role.andP;  Some of these areas are:andM;Symbolic manipulation: although Lisp and Prolog are currently the mainlanguages in this area, it is quite probable that a CLP language may replaceProlog in the next few years.andP;  There is a close relationship between the aimsof CLP and Macsyma-like languages.andP;  It is likely that some features ofconstraint languages such as inequalities, booleans, inversibility, etc.,andO;will be of interest to Macsyma users.andP;  On the other hand, developers of CLPlanguges will have a great deal to learn from the experience gained inimplementing Macsyma.andM;Numerical Analysis and Operations Research: the proposed CLP languages allowtheir users to generate hundreds (or thousands) of equations and inequationshaving special characteristics.andP;  For example, the generation of linearequations approximating Laplace's differential equations is easily done in aCLP language [24].andP;  The same applies to Runge-Kutta methods for solvingdifferential equations.andP;  The possibility of expressing inequations in acomputer language will likely attract the interest of specialists inoperations research.andM;Combinatories: non-deterministic languages like Prolog have been verysuccessfully used in the solution of combinatorial problems.andP;  Theavailability of inequalities and disequalities ([is not equal to]) willcertainly extend the scope of problems which can easily be expressed by aprogram.andP;  A typical example is the now classic SEND + MORE = MONEY problem.andO;Its solution using constraints is considerably shorter and clearer than itscounterpart which does not use them.andP;  It is also known that a version of theeight queens problem using the constraint dif ([is not equal to]) isconsiderably more efficient than the classic one.andM;Artificial Intelligence Applications: the boolean constraints of Prolog IIIare already being utilized in the design of expert systems.andP;  It is expectedthat the possibility of expressing equations and inequations makes CLPlanguages attractive for writing natural language interfaces in which numericvalues play an important role.andP;  The increased potential for inversibilitymakes CLP languages unique in programming certain applications.andP;  An exampleworth mentioning is that of option trading presented in [33].andM;Engineering Applications: The ease with which CLP can be used for generatinglarge numbers of equations and inequations will have an impact in thesolution of engineering problems.andP;  Two examples illustrate this type ofapplication.andP;  Ohm's and Kirchhoff's laws can readily be used to generateequations describing the behavior of electrical circuits containing paralleland serial elements.andP;  The analysis of such circuits is easily and conciselydone using CLP (see [24]).andP;  The second example is the detection of faultycomponents in electronic circuits using boolean constraints (see [17]).andM;ConclusionandM;As in most sciences, there has always been a valuable symbiosis among thetheoretical and experimental practitioners of computer science including, ofcourse, those working in logic programming.andP;  It is worth recalling thefundamental role played by the talented and creative &quot;hackers&quot; in our field.andO;Three examples come to mind: the elimination of the occur test inunifications; the cut; and the not operator as defined in Prolog.andP;  Thesefeatures were created by practical programmers and are here to stay.andP;  Theyprovide a vast amount of food for thought for theoreticians.andP;  As mentionedearlier, the elimination of the occur test was instrumental in thedevelopment of algorithms for unification of infinite trees.andP;  Although theconcept of the cut has resisted repeated attempts for a clean semanticdefinition, its use is unavoidable in increasing the efficiency of programs.andO;Finally, Prolog's not operator is now playing a key role in extending logicprograms beyond Horn clauses.andM;The above comments remain valid in the area of CLP.andP;  The development of newpractical algorithms for dealing with constraints will undoubtly trigger aflurry of theoretical efforts to properly explain their behavior.andP;  Therefore,as in the case of Prolog, the increased availability of interpreters andcompilers for CLP will encourage their practical usage and will provide theexperience necessary to further refine the languages.andM;The remaining paragraphs will outline some of the promising research avenuesthat are wide open to researchers in CLP.andM;1.andP;  Development of novel satisfiability algorithms in various domains: it issafe to assume that linear equations and inequations (as well asdisequalities) will be incorporated into most CLP languages.andP;  There is asubstantial gap between the computational effort needed to solve suchconstraints and that needed to solve general polynomial equations andinequations [23].andP;  It is worthwhile to study subsets of these constraints andto develop incremental algorithms for testing their satisfiability.andM;2.andP;  Type theory: since several domains may be combined in a single constraintlanguage, it would be desirable to have some general means to test whether agiven combination of domains and predicates should or should not be allowedin a program.andP;  The criterion in this case might be a reasonable executiontime.andP;  (Some related results appear in [31]).andM;3.andP;  Implementation: a great deal of the success of Prolog is due to thedevelopment of a target language which can be efficiently used in executingprograms.andP;  Warren's target language called Warren Abstract Machine (WAM) isby far the most widely used lower-level code generated by current Prologcompilers [47].andP;  One of its main advantages is that it replaces unification,whenever possible, by simpler sequences of tests and assignments.andP;  Althoughsome of the implementations of existing constraint languages are WAM-based,it will still take a considerable effort to develop an efficient andwell-accepted WAM model for CLP's handling multiple domains.andP;  Recent research[42] indicates that partial evaluation of CLP programs may yield substantialefficiency gains.andM;4.andP;  Meta-level interpretation: a substantial advantage offered by Prolog isthat it allows a very concise description of its interpreter, using thelanguage itself.andP;  It would be valuable to have the description of afull-fledged constraint language written in CLP (the author's group ispresently developing a CLP interpreter written in Prolog).andP;  That interpreterwould be very useful as a prototype for trying out the implementation of newfeatures.andM;5.andP;  Data-flow analysis: it has already been mentioned that certain cuts couldbe eliminated by introducing constraints.andP;  Recall the example illustratingthis possibility:andM;p : - q, !, [alpha].andP;  p : - [beta].andP;  } transformed into { p : - q, [alpha].andO;p : - q, [beta].andM;in which Q [and] q' = false.andP;  It would be worthwhile to perform thiscomputation automatically at compile time (note that a CLP interpreter may becapable of generating q' and testing if q [and] q' is false)  This could beaccomplished by a data-flow analysis of the Cousot-Bruynooghe type [7, 18].andO;Many other optimizations of CLP programs should be possible using thesetechniques.andM;6.andP;  Parallelism: this is probably one of the most exciting areas in CLP,especially since it relates to all the preceding topics.andP;  (11)  There alreadyexist several parallel programs for solving equations, and for linearprogramming, which run on a variety of computer architectures (SIMD and MIMDmachines).andP;  A futuristic view of parallelism exploited for logic programmingmight envision a linkage between a loosely coupled shared-memory machine (theinference engine) and a connection machine dedicated to testing thesatisfiability of systems of constraints (the unifier).andM;This author believes that CLP is one of the most promising and stimulatingnew areas in computer science.andP;  It amalgamates the knowledge and experiencegained since the birth of computers in areas as varied as: numericalanalysis, operations research, artificial languages, symbolic processing, AI,logic and mathematics.andP;  It represents a gold mine of concepts and problemswhich are bound to influence computer science in the coming decades.andM;(1) It has been shown that properties (a, a') (b, b') are still applicablefor ground queries containing positive and negative literals [35].andM;(2) The cognoscenti would equate CLP () to Datalog without constant symbols.andM;(3) In [17] Colmerauer uses the term admissible element of the domain insteadof deducible fact.andM;(4) At least doubly exponential with the number of variables.andM;(5) The Grobner basis of a given system of polynomial equations isessentially a simplified set of equations enabling the test forsatisfiability.andM;(6) It is admittedly hard to define what constitutes an average case.andM;(7) Note the analogy between this concatenation and the multiplication ofconstants by variables in linear arithmetic.andM;(8) Reference [22] describes recent work in this area.andM;(9) Reals are implemented as floating point numbers.andM;(10) Recent Prolog III implementations allow the delayed evaluation of suchconstraints.andM;(11) A recent dissertation [40] deals with constraints and concurrent logicprogramming.andM;ReferencesandM;[1] Aiba, A. et al.andP;  Constraint logic programming language CAL.andP;  InProceedings of the International Conference on Fifth Generation ComputerSystems, (1988) Ohmsha Publishers, Tokyo, pp.andP;  263-276.andM;[2] Apt, K.R.andP;  Introduction to logic programming.andP;  Rep.andP;  TR-87-35, Dept ofComputer Science, Univ.andP;  of Texas at Austin, July 1988.andM;[3] Arno, D.S.andP;  A bibliography of quantifier elimination for real closedfields.andP;  J. Symbolic Comput.andP;  5 (1988), 267-274.andM;[4] Boi, J.M.andP;  and Benhamou, F. Boolean constraints in Prolog III.andP;  Ph.D.andO;dissertation, Groupe d'Intelligence Artificielle, Universite d'AixMarseille,Luminy, Nov. 1988.andM;[5] Borning, A.andP;  The programming language aspects of thing-lab, aconstraint-oriented simulation laboratory.andP;  ACM TOPLAS 3,4 (Oct.andP;  1981),252-387.andM;[6] Boyer, R.S.andP;  and Moore, J.S.andP;  A Computational Logic Handbook.andP;  AcademicPress, Orlando, Fla., 1988.andM;[7] Bruynooghe, M. and Janssens, G.andP;  An instance of abstract interpretationintegrating type and mode interferencing in logic programming.andP;  InProceedings of the Fifth International Conference and Symposium.andP;  (Seattle,Wash., 1988) vol.andP;  1, MIT Press, pp.andP;  669-683.andM;[8] Buchberger, B. Grobner Bases: An algorithmic method in polynomial idealtheory.andP;  In Multidimentional Systems Theory.andP;  N.K.andP;  Bose Ed., D. ReidelPublishing Co., 1985, pp.andP;  184-232.andM;[9] Buttner, W. and Simonis, H. Embedding Boolean expressions into logicprogramming.andP;  J. of Symbolic Comput., 4 (Oct.andP;  1987), 191-205.andM;[10] Clark, K.L.andP;  Negation as Failure.andP;  In Logic and Data Bases, H. Gallaireand J. Minerk, Eds.andP;  Prenum Press, New York, 1978, pp.andP;  293-322.andM;[11] Cohen, J.andP;  A view of the origins and development of Prolog.andP;  Commun.andO;ACM, 31, 1 (Jan.andP;  1988), 26-36.andM;[12] Collins, G.E.andP;  Quantifier Elimination for Real Closed Fields: A Guide tothe Literature, in Computing.andP;  B. Buchberger, G.E.andP;  Collins and R. Loos, Eds.andO;Computer Algebra: Symbolic and Algebraic Computation, 2d ed.andP;  SpringerVerlag,Vienna, pp.andP;  79-81.andM;[13] Colmerauer, A.andP;  Prolog and Infinite Trees.andP;  In Logic Programming, K.L.andO;Clark and S.A.andP;  Tarnlund, Eds.andP;  Academic Press, New York, 1982, pp.andP;  231-251.andM;[14] Colmerauer, A.andP;  Prolog II Reference Manual and Theoretical Model.andP;  Rep.andO;Groupe d'Intelligence Artificielle, Universite d'Aix-Marseille II, Luminy,Oct. 1982.andM;[15] Colmerauer, A.andP;  Solving equations and inequations on finite and infinitetrees.andP;  In Proceedings of the Conference on Fifth Generation ComputerSystems, (Tokyo, Nov. 1984), pp.andP;  85-99.andM;[16] Colmerauer, A.andP;  Opening the Prolog-III universe.andP;  Byte Maga, (Aug.andO;1987), 12, 9.andM;[17] Colmerauer, A.andP;  An introduction to Prolog III.andP;  Commun.andP;  ACM 33, 7 (July1990), pp.andP;  0000.andM;[18] Cousot, P. and Cousot, R.andP;  Abstract interpretation: A unified latticemodel for static analysis of programs by construction or approximation offix-points.andP;  In Proceedings of the Fourth ACM POPL Symposium (Los Angeles,1977), pp.andP;  238-252.andM;[19] Dincbas, M. et al.andP;  The constraint logic programming language CHIP, InProceedings of the International Conference on Fifth Generation ComputerSystems, (1988), Ohmsha Publishers, Tokyo, pp.andP;  693-702.andM;[20] Elcock, E.W.andP;  Absys 1: The historical inevitability of logicprogramming.andP;  In Proceedings of the North American Logic ProgrammingConference.andP;  MIT Press, Cambridge, Mass., 1989, pp.andP;  1201-1214.andM;[21] Foster, J.M.andP;  and Elcock, E.W.andP;  Absys 1: An Incremental Compiler forAssertions: an Introduction.andP;  In Mach.andP;  Intell.andP;  4, Edinburgh UniversityPress, 1969, pp.andP;  423-429.andM;[22] Freeman-Benson, B.N., Maloney, J. and Borning, A.andP;  An incrementalconstraint solver.andP;  Commun.andP;  ACM 33, 1 (Jan.andP;  1990), 54-63.andM;[23] Grigorev, D.Y.andP;  and Vorobjov, N.V.andP;  Solving systems of polynomialinequalities in subexponential time.andP;  J. Symbolic Comput.andP;  5 (1988), 37-64.andM;[24] Heintze, N.C., Michaylov, S. and Stuckey, P.J.andP;  CLP (R) and someelectrical engineering problems.andP;  In Proceedings of the Fourth InternationalConference on Logic Programming, (Melbourne, 1987), MIT Press, pp.andP;  675-703.andM;[25] Hentenryck, P.V.andP;  Constraint Satisfaction in Logic Programming, MITPress, Cambridge, Mass., 1989.andM;[26] Hill, R.andP;  LUSH-resolution and its completeness, DCL Memo 78, Dept.andP;  ofArtificial Intelligence, Univ.andP;  of Edinburgh, U.K., 1974.andM;[27] Hopcroft, J.E.andP;  and Ullman, J.D.andP;  Introduction to Automata Theory,Languages and Computation.andP;  Addison-Wesley, Reading, Mass., 1979.andM;[28] Jaffar, J., Lassez, J-L.andP;  and Lloyd, J.W.andP;  Completeness of the negationas failure rule.andP;  In Proceedings of the International Conference onArtificial Intelligence.andP;  (IJCAI), 1983, Karlsruhe, pp.andP;  500-506.andM;[29] Jaffar, J. and Lassez, J-L.andP;  Constraint logic programming, InProceedings of the Fourteenth ACM Symposium of the Principles of ProgrammingLanguages, (Munich, 1987), pp.andP;  111-119.andM;[30] Jaffar, J. and Michaylov, S.andP;  Methodology and implementation of aconstraint logic programming system.andP;  In Proceedings of the FourthInternational Conference on Logic Programming (Melbourne, 1987), MIT Press,Cambridge, Mass., pp.andP;  196-218.andP;  (A revised version of this paper has beenpresented in the Languages and Constraints Workshop, Alton Jones Campus,Rhode Island, April 1988.)andM;[31] Kanellakis, P.C., Kuper, G.M.andP;  and Revesz, P.Z.andP;  Constraint querylanguages, Tech.andP;  Rep., Brown Univ., Providence, R.I., 1990.andM;[32] Kowalski, R. and Kuehner, D.andP;  Resolution with selection function.andO;Artif.andP;  Intell.andP;  3, 3 (1970), 227-260.andM;[33] Lassez, C., McAloon, K. and Yap, R.andP;  Constraint logic programming inoptions trading.andP;  IEEE Expert (Aug.andP;  1987).andM;[34] Lassez, J-L., McAloon, K.andP;  Application of a canonical form forgeneralised linear arithmetic constraints.andP;  In Proceedings of the FifthGeneration Computer Systems, (1988), Ohmsha Publishers, Tokyo, pp.andP;  703-710.andM;[35] Lloyd, J.W.andP;  Foundations of Logic Programming, 2d ed., Springer-Verlag,New York, 1987.andM;[36] Luenberger, D.G.andP;  Linear and Nonlinear Programming, 2d ed.andO;Addison-Wesley, Waltham, Mass., 1984.andM;[37] Makanin, G.S.andP;  The Problem of Solvability of Equations on a FreeSemi-Group.andP;  Math.andP;  USSR Sbornik 32, 2, (1977), English Translation, AMS,(1979), 129-198.andM;[38] Matijasevic, Y.andP;  Diophantine sets, Uspehi Mat.andP;  Nauk 27, 5 (1972),185-222; English translation: Russ.andP;  Math Surveys 27, 5 (1972), 124-164.andM;[39] Murray, N.V.andP;  Completely Non-Clausal Theorem Proving.andP;  Artif.andP;  Intell.andO;18 (1982), 67-85.andM;[40] Saraswat, V.A.andP;  Concurrent constraint programming languages, Ph.D.andO;dissertation, Carnegie Mellon Univ., Jan. 1989, To be published as an ACMdoctoral dissertation, MIT Press 1990.andM;[41] Siegel, P.andP;  Representation et utilisation de la connaissance en calculpropositionnel.andP;  These de docteur d'Etat es Sciences, UniversiteAixMarseille, Luminy, 1987.andM;[42] Smith, D.S.andP;  and Hickey, T.J.andP;  Partial evaluation of CLP (FT), Tech.andO;Rep., CS-90-148 Brandeis Univ., 1990.andM;[43] Steele, G.L.andP;  The implementation and definition of a computerprogramming language based on constraints.andP;  Ph.D.andP;  dissertation, Dept of EEand CS, MIT, Cambridge, Mass.andP;  (Artificial Intelligence Tech.andP;  Rep.andP;  AITR595), Aug. 1980.andM;[44] Sterling, l. and Shapiro, E.andP;  The Art of Prolog.andP;  MIT Press, Cambridge,Mass., 1986.andM;[45] Tarski, A.andP;  A Decision Method for Elementary Algebra and Geometry, 2drevised ed., Univ.andP;  of california Press, 1948.andM;[46] Van Emden, M.H.andP;  and Kowalski, R.andP;  The semantics of predicate logic as aprogramming language.andP;  J. ACM 23, 4 (1976), 733-742.andM;[47] Warren, D.H.D.andP;  An abstract Prolog instruction set.andP;  Tech.andP;  Note 309,SRI International, Menlo Park, Calif., 1983.andM;CR categories and Subject Descriptors: D.3.2 [Programming Languages]:Language Classification--very high-level languages; F.4.1.andP;  [MathematicalLogic and Formal Languages]: Mathematical logic--Logic programming; I.2.3[Artificial Intelligence]: Deduction and Theorem ProvingandM;General Terms: Design, LanguagesandM;Additional Key Words and Phrases: Constraints, constraint satisfiability,language design, logic programming, nondeterministic algorithmsandM;Jacques Cohen is the Zayer/Feldberg professor in the Michtom School ofComputer Science at Brandeis University.andP;  He holds doctorates from theUniversity of Illinois (Engineering) and the University of Grenoble, France(Computer Science).andP;  He has held visiting positions at MIT Brown and morerecently at the University of Aix-Marseilles where the language Prologoriginated.andP;  His current research interests are in the areas of microanalysisof programs and in compiler development using logic programming with specialemphasis on the usage of parallel computers.andP;  Author's Present Address:Michtom School of Computer Science, Ford Hall, Brandeis University, Waltham,MA 02254.andP;  email: csnet: jc@cs.andP;  brandeis.andP;  edu.andO;</TEXT></DOC>