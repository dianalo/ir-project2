<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-749-548  </DOCNO><DOCID>07 749 548.andM;</DOCID><JOURNAL>Communications of the ACM  Oct 1989 v32 n10 p1237(3)* Full Text COPYRIGHT Assn. for Computing Machinery, Inc. 1989.andM;</JOURNAL><TITLE>Practical performance of Bloom filters and parallel free-textsearching. (hash coding)</TITLE><AUTHOR>Ramakrishna, M.V.andM;</AUTHOR><SUMMARY>The Bloom filter technique of hash coding can be used in severalapplications to improve efficiency in information storage,searching and file maintenance.andP;  This performance increase isachieved by the right choice of transformations.andP;  Specificapplications explored include reducing disk access to differentialfiles, efficiently storing dictionaries and parallel free-textsearching.andP;  Class of transformations and theoretically predictedfilter error rates for actual test files are discussed.andM;</SUMMARY><DESCRIPT>Topic:     Hashing FunctionsApplicationsFilteringFile MaintenanceInformation Storage and Retrieval.andO;Feature:   illustrationtable.andO;Caption:   Filter error rate. (table)Error rate with transformations from class H sub 1. (table)andM;</DESCRIPT><NOTE>Only Text is presented here; see printed issues for graphics.andO;</NOTE><TEXT>Bloom filter technique of hashing finds several applications, such as inefficient maintenance of differential files, space efficient storage ofdictionaries, and parallel free-text searching.andP;  The performance of hashtransformations with reference to the filter error rate is the focus of thisarticle.andP;  The Bloom filter technique of hash coding finds severalapplications.andP;  Consider the problem of reducing disk accesses to adifferential file, as discussed by Gremillion [3) and Mullin [5].andP;  Adifferential file is essentially a separate file which contains records thatare modified in the main file.andP;  The main file itself is not modified in orderto preserve integrity.andP;  This implies that each reference to the main filemust first access the differential file in order to check whether or not therecord has been modified.andP;  If the record has not been modified, the main fileis searched.andP;  Usually, the record would not be found in the differentialfile.andP;  Nonetheless, it has to be searched every time.andP;  The searching of thedifferential file can be greatly reduced using the following Bloom filtertechnique.andM;The filter consists of m bits of memory initialized to zero and k hashtransformations on the primary key of the files.andP;  For a given key, each hashtransformation produces an integer in the range 0 to m - 1.andP;  Initially, thedifferential file is empty.andP;  Whenever a record in the main file is to bemodified, the modified record is entered into the differential file.andP;  At thesame time, each of the k transformations are applied to the key and thecorresponding bits of the bit vector is set to 1.andP;  Note that no changes aremade to the main file.andP;  On subsequent searches, the transformations areapplied to the key.andP;  If all the corresponding bits are not set in the bitvector, then the record could not have been stored in the differential file(and hence there is no need to access the differential file).andP;  If all k bitsfor the record in question are set, however, it does not imply that therecord is stored in the differential file.andP;  The differential file has to besearched to see if the record is present.andP;  If the record is not found in thedifferential file, when all k bits have been set by chance collisions withother keys, a filter error is said to have occurred.andP;  The filter error rateand the performance of hash transformations is the topic of this article.andM;Let n be the number of entries in the differential file, and a the fractionof records in the differential file.andP;  The probability of a filter erroroccurring can be shown to be [5]andM;P sub e, = (1 - alpha)[1 - (1 - l/m)sup nk]sup k.andM;This analytical result assumes that each of the transformations is equallylikely to set each of the m bits, i.andP;  e., ideal in some sense.andP;  Thesimulation results reported in the literature indicate that the filter errorrate is larger than the analytical results.andP;  Table I, extracted from [3, 5],compares the filter error rate of simulations and analytical results.andP;  InMullin's words,andM;An alarming feature of the simulation is that the probability of a filtererror is higher than the theory predicts.andP;  It may, indeed, be difficult todevelop good transformations, but Table I shows that perfect transformationswith a filter size of 49,152 bits yield the same performance as the actualtransformations with 65,536 bits.andP;  If space is important, one might wish toinvestigate transformations a bit more [5].andM;This article shows that the theoretical performance can be achieved by theright choice of transformations.andP;  My investigations into a class oftransformations, which give theoretically predicted filter error rates withreallife test files, are reported.andM;Bloom filter techniques find other applications.andP;  Freetext search systemsallowthe user to search the text of the stored documents for arbitrarycombinations of words, without the help of any indexing.andP;  One problem withthe free-text database systems, which hinders its wide usage, is that theymake computational demands beyond the practical limits of conventionalcomputers.andM;Stanfill and Kahle presented an implementation of free-text searching on theConnection Machine that takes advantage of the possibilities offered bymassively parallel computers [8].andP;  The data structure they use and the searchoperation follow the same principle as Bloom filtering.andP;  The bit array isreferred to as a surrogate table.andP;  A document is said to have been stored inthe table when the transformations are applied to the words of the documentand the corresponding bits are set to one.andP;  To search if a word from thegiven query is present in the document stored, the transformations areapplied to the word and the corresponding bits are checked in the surrogatetable.andP;  If all the bits are not set, then the word is not contained in thedocument.andP;  Otherwise, with a high probability, the word is contained in thedocument.andP;  The way the parameters of the surrogate table are chosen make theprobability of error quite small.andP;  The interested reader can refer to [8] forfurther details of free-text searching.andM;The same data structure has been used for space efficient storage ofdictionaries (see Jon Bentley's column, &quot;Programming Pearls&quot; [1]).andP;  Insteadof storing the words as such in a dictionary for use in spelling checking,the idea is to store the words in a bit array similar to the surrogate tablewhich has to be sufficiently large.andP;  Apart from memory-space savings withthis technique, searching also becomes very fast 'There is still a smallprobability of error though.andP;  Further details of error rate are discussed byNix in [6).andP;  The transformations referred to as &quot;perfect&quot; by Mullin arereferred to as &quot;random&quot; by Nix.andP;  The transformations presented in thisarticle satisfy the requirements of this application also, and, in fact, wehave used the UNIXs dictionary as a test file for the experiments.andM;Recently, hardware implementation of the technique has been suggested forhigh-speed event counting and classification [4].andP;  Such hardware findsapplications in areas such as signal processing, process monitoring andcontrol, and computer communications network monitoring and control.andM;h sub c,d(X) = ((cx + d) mod p) mod m, andandM;H, = (h sub c,d()!0 andless; C andless; P, 0 andless;/= d andless; p].andM;A Class of Hash TransformationsandM;Consider the class of hash transformations defined as follows.andP;  The keys areassumed to be integers drawn from a universe A, A = [1, 2, .andP;  .  .  , p - 1],and let B denote the range of hash addresses, B = 10, 1, .andP;  .  .  , m - 1}.andO;We assume p is a prime, without loss of generality.andP;  Define transformations hsub c,d which map A into B, and the class H sub 1 as,andM;The results and the details of the experiments presented in the next sectionillustrate that transformations chosen at random from the class Hj yield thetheoretical performance of the Bloom filters.andP;  (The class H sub 1 is auniversal sub 2 class of hashing functions.andP;  Definitions and theoreticalinvestigations of universal sub 2 classes of hashing functions may be foundin [2].)andM;Experimental Results and Concluding RemarksandM;To test the performance of the Bloom filters under the transformations justdiscussed, I ran several simulations of differential file loadings.andP;  In orderto enable direct comparison of the results, the parameters of the Bloomfilter given in Table I of [5] are used (which in turn corresponds tosimulation results in [3]).andP;  Three different real-life files are used in theexperiments: the dictionary on UNIX, call numbers from a library, and theuserids from a large time sharing installation.andP;  The keys are first convertedinto integers.'andM;Each simulation run consisted of randomly choosing k transformations from theclass Hi.andP;  This was accomplished by generating 2k pseudo-random numbers, eachpair defining a hash transformation.andP;  The m bits of the filter are clearedinitially.andP;  The k transformations are applied to each of the n (n = 7000)keys, and the corresponding bits of the filter are set to one.andP;  After all then keys are processed, the next 1000 keys from the file are used to determinethe fault rate of the filter.andP;  Each key is transformed by the ktransformations, and if all the k bits are set, it is counted as a filterfailure (note that none of the 1000 keys were used before in setting thebits).andP;  The fault rate for the set of k hashing functions is determined as afraction of the l000 keys tried.andP;  This experiment is repeated for 100different sets transformations, and the mean and the standard deviations ofthe fault rates for the parameter combination is noted.andP;  The whole procedureis repeated for different parameter sets and the results are tabulated inTable II which corresponds to the file of user ids.andP;  We observe that theexperimental results are in agreement with the analytical results, and thetwo are less than a standard deviation apart.andP;  Similar results are obtainedwith other files.andP;  We thus conclude that by choosing hash transformationsrandomly from the class Hi as described, the theoretical error rate can beachieved in practice.andO;</TEXT></DOC>