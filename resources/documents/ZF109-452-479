<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF109-452-479  </DOCNO><DOCID>09 452 479.andM;</DOCID><JOURNAL>Communications of the ACM  Sept 1990 v33 n9 p142(18)* Full Text COPYRIGHT Association for Computing Machinery 1990.andM;</JOURNAL><TITLE>The object-oriented systems life cycle.andO;</TITLE><AUTHOR>Henderson-Sellers, Brian; Edwards, Julian M.andM;</AUTHOR><SUMMARY>The 'waterfall' model describes the underlying view of thetraditional software life cycle.andP;  Its most general descriptionidentifies three phases: analysis, design andconstruction/implementation.andP;  More detailed descriptions addseveral subdivisions; most implementations are based on functionaldecomposition, which bases system description on what it does.andO;This top-down analysis and design methodology has several flaws,among which are exclusion of evolutionary changes and the datastructure aspect.andP;  Two alternative systems development options aredescribed: Jackson Structured Development (JSD) andobject-oriented decomposition.andP;  JSD techniques model the world,impose some chronology and use some object-based concepts such asdata structure methods, but are essentially functionaldecomposition methodologies.andP;  The advantages of object-orienteddevelopment are described.andM;</SUMMARY><DESCRIPT>Topic:     Object-Oriented ProgrammingNew TechniqueProgram Development TechniquesTop-Down DesignStructured Design TechniquesSoftware DesignSystem DesignSystems Analysis.andO;Feature:   illustrationchart.andO;Caption:   The traditional software life cycle. (chart)Problem space versus solution space for a typical software system.andO;(chart)Three options for systems design methodologies. (chart)andM;</DESCRIPT><NOTE>Only Text is presented here; see printed issues for graphics.andO;</NOTE><TEXT>THE OBJECT-ORIENTED SYSTEMS LIFE CYCLE In software engineering, thetraditional description of the software life cycle is based on an underlyingmodel, commonly referred to as the &quot;waterfall&quot; model (e.g., [4]).andP;  This modelinitially attempts to discretize the identifiable activities within thesoftware development process as a linear series of actions, each of whichmust be completed before the next is commenced.andP;  Further refinements to thismodel appreciate that such completion is seldom absolute and that iterationback to a previous stage is likely.andP;  Various authors' descriptions of thismodel relate to the detailed level at which the software building process isviewed.andP;  At the most general level, three phases to the life cycle aregenerally agreed upon: 1) analysis, 2) design and 3)construction/implementation (e.g., [36], p. 262; [42]) (Figure 1(a)).andP;  Theanalysis phase covers from the initiation of the project, through tousers-needs analysis and feasibility study (cf.andP;  [15]); the design phasecovers the various concepts of system design, broad design, logical design,detailed design, program design and physical design.andP;  Following from thedesign stage(s), the computer program is written, the program tested, interms of verification, validation and sensitivity testing, and when foundacceptable, put into use and then maintained well into the future.andM;In the more detailed description of the life cycle a number of subdivisionsare identified (Figure 1(b)).andP;  The number of these subdivisions variesbetween authors.andP;  In general, the problem is first defined and an analysis ofthe requirements of current and future users undertaken, usually by directand indirect questioning and iterative discussion.andP;  Included in this stageshould be a feasibility study.andP;  Following this a user requirements definitionand a software requirements specification, (SRS) [15], are written.andP;  Theusers requirements definition is in the language of the users so that thiscan be agreed upon by both the software engineer and the software user.andP;  Thesoftware requirements specification is written in the language of theprogrammer and details the precise requirements of the system.andP;  These twostages comprise an answer to the question of WHAT? (viz.andP;  problemdefinition).andP;  The user-needs analysis stage and examination of the solutionspace are still within the overall phase of analysis but are beginning tomove toward not only problem decomposition, but also highlighting conceptswhich are likely to be of use in the subsequent system design; thus beginningto answer the question HOW?andP;  On the other hand, Davis [15] nots that thisdivision into &quot;what&quot; and &quot;how&quot; cna be subject to individual perception,giving six different what/how interpretations of an example telephone system.andO;At this requirements stage, however, the domain of interest is still verymuch that of the problem space.andP;  Not until we move from (real-world) systemsanalysis to (software) systems design do we move from the problem space tothe solution space (Figure 2).andP;  It is important to observe the occurrence andlocation of this interface.andP;  As noted by Booch [6], this provides a usefulframework in object-oriented analysis and design.andM;The desgin stage is perhaps the most loosely defined since it is a phase ofprogressive decomposition toward more and more detail (e.g., [41]) and isessnetially a creative, not a mechanistic, process [42].andP;  Consequently,systems design may also be referred to as &quot;broad design&quot; and program designas &quot;detailed design&quot; [20].andP;  Brookes et al.andP;  [9] refer to these phases as&quot;logical design&quot; and &quot;physical design.&quot;andP;  In the traditional life cycle thesetwo design stages can become both blurred and iterative; but in theobject-oriented life cycle the boundary becomes even more indistinct.andM;The software life cycle, as described above, is frequently implemented basedon a view of the world interpreted in terms of a functional decomposition;that is, the primary question addressed by the systems analysis and design isWHAT does the system do viz.andP;  what is its function?andP;  Functional design, andthe functional decomposition techniques used to achieve this, is based on theinterpretation of the problem space and its translation to solution space asan interdependent set of functions or procedures.andP;  The final system is seenas a set of procedures which, apparently secondarily, operate on data.andM;Functional decomposition is also a top-down analysis and design methodology.andO;Although the two are not synonymous, most of the recently published systemsanalysis and design methods exhibit both characteristics (e.g., [14, 17]) andsome also add a real-time component (e.G., [44]).andP;  Top-down design doesimpose some discipline on the systems analyst and program designer; yet itcan be criticized as being too restrictive to support contemporary softwareengineering desings.andP;  Meyer [29] summarizes the flaws in top-down systemdesign as follows:andM;1.andP;  top-down design takes no account of evolutionary changes;andM;2.andP;  in top-down design, the system is characterized by a single function--aquestionable concept;andM;3.andP;  top-down design is based on a functional mindset, and consequently thedata structure aspect is often completely neglected;andM;4.andP;  top-down design does not encourage reusability.andP;  (See also discussion in[41], p. 352 et seq.)andM;AlternativeandM;DecompositionandM;MethodologiesandM;Figure 3 considers three basic options for systems analysis and design(collectively called systems development).andP;  These three options areessentially on a grey scale from top-down functional decomposition which isprocess-driven, through Jackson Structured Development (JSD) toobject-oriented decomposition.andP;  A more detailed discussion on variants onthese themes can be found in [15], for example.andM;Functional DecompositionandM;In functional decomposition, procedures and algorithms are uppermost in thedesigner's mind.andP;  Initially the system is viewed at a high level in terms ofwhat it is intended to do and then at a detailed design stage how it willaccomplish these process-oriented goals.andP;  Design tools used to support thismethodology which is strongly based on data flows include data flow diagrams(DFDs), data dictionaries (DDs) and structure charts.andM;Functional decomposition is well supported by the older procedural languagesand is therefore a natural mode of design expression in that context.andP;  Theincorporation of subroutines into these languages led to the ability toundertake some degree of autonomy and information hiding; whilst at the sametime shared data tended to be placed in globally accessible data storageareas (e.g., COMMON blocks in Fortran, externals in C).andP;  This leads to the&quot;stack of dominoes&quot; effect familiar to anyone working in program maintenancewhereby changes to one part of a software system often cause a problem in anapparently dissociated program area.andP;  Furthermore, a system envisaged asproviding a single service (single function) is unable to evolve to take intoaccount new data structures or new functions with any degree of robustness.andM;Jackson StructuredandM;DevelopmentandM;Jackson Structured Programming and Jackson Structured Development (JSD) [21,22] are techniques which initially model the real world, impose somechronology and use some object-based concepts (data structure methods).andO;However, they are essentially functional decomposition methodologies ([41],p. 185) in which the data structures are used to assist in the functionaldecomposition; as compared to a functional decomposition in which the datastructures are essentially determined by the procedure structure; although insome sense, JSD can be considered to be at least partially object-based and&quot;middle-out&quot; [10].andP;  Certainly, it attempts to shift the emphasis away fromprocedures (or functions) by commencing analysis with a system-modelingexercise [22].andM;JSD attempts to model systems by taking some account of objects, but, asnoted above, imposes a rigid chronology on the system components.andP;  Forsystems for which this is a reasonable assumption, the JSD methodology wouldappear to provide useful insights, especially since it provides the samerepresentation for program structure as for systems and data structureanalysis viz.andP;  elementary, sequence, iteration and selection ([9], p. 160).andO;This provides a graphical interpretation and analysis tool which adopts adifferent approach to that embodied in the data flow diagram in which suchiteration and selection structures are forbidden.andM;Object-OrientedandM;DevelopmentandM;The object-oriented (OO) paradigm, at its simplest, takes the same componentsof a software system: data and procedures, but de-emphasizes the procedures,stressing instead the encapsulation of data and procedural features together,exemplified by the clear and concise specification of the module interface.andO;In a systems decomposition based on an object-oriented approach, the systemis viewed as a collection of objects, sometimes referred to as entities [324] or object classes [29].andP;  High-level analysis and design is accomplishednot only in terms of these objects, but also the services they provide usinga client-server model of object relationships in which objects interact witheach other via &quot;messages&quot; which pass information, invoke the objects toimplement a procedure etc.andP;  The use of the client-server model leads to thesystem being described as &quot;responsibility-driven&quot; [47].andM;Detailed design, including procedure implementation and specification of datastructures, is deferred until much later in the development process and areprivate to the object, thus adhering strictly to the concepts of informationhiding as promulgated by Parnas [34].andP;  Consequently, algorithmic proceduresand data structures are no longer &quot;frozen&quot; at a high level of systems design.andO;Therefore a system based upon object representation can remain more flexiblesince changes at the implementation level are more easily accomplishedwithout requiring changes to the systems design itself.andP;  It is important thatdata structures should not be specified too early in the design process.andO;Data entities may, however, provide the basis of object identification aroundwhich an interface is then developed.andP;  Thus, object development focuses ondata abstraction rather than freezing specific data structures into theobject specification.andM;Since much of object-oriented program development is bottom-up, thedifferentiation between program design and coding is much less distinct thanin a procedurally-based systems life cycle (e.g., [30]).andP;  However at thislater stage, it would seem reasonable that within individual code modules,called classes in a object-oriented system, the tools developed forhigh-level functional decomposition and top-down system design, such as DFDs,can still be found to be useful.andP;  Other graphical tools which areindispensable at different stages within the OO systems life cycle areobject-relationship graphs, client-server diagrams, inheritance charts orcollaboration graphs [46].andM;In contrast to the common structured systems analysis based largely ontop-down functional decomposition, object-oriented (OO) design and analysishas many attributes of both top-down and, perhaps predominantly, bottom-updesign.andP;  Since one of the aims of an OO implementation is the development ofgeneric classes for storage in libraries, an approach which considers bothtopdown analysis and bottom-up design simultaneously is likely to lead to themost robust software systems.andP;  Indeed several authors [13, 22, 27, 42]suggest that in reality, practitioners purporting to be following a strictlytop-down approach actually utilize a mixed mode of operation betweentop-down, bottom-up and middle-out.andM;Matching SystemsandM;Analysis and DesignandM;MethodologiesandM;Perhaps the most important question regarding the introduction ofobject-oriented methodologies into commercial environments is whether it isnecessary to use the techniques throughout the whole life cycle or whether itis possible to &quot;mix and match&quot; with functional decomposition techniques.andO;Although it would appear that the former would be more self-consistent, thearguments for proposing the latter approach consider the reality of the largecurrent investment in top-down functional decomposition, both in terms ofexpertise and front-end CASE tools, which many industries currently possess(e.g., [43]).andP;  Secondly, even if the OO design methods are viewed as &quot;morenatural,&quot; the investment in code in COBOL, for example, leads to thequestion: can an object-oriented design, viewed simply as a better design, beimplemented in a non-OO language?andM;Figure 4 summarizes the possible routes.andP;  On the left-hand side of the figureis the traditional top-down functional design approach.andP;  The analysis of theproblem is undertaken in problem space, which is full of objects, and thetransition to the solution space model (Figure 2) requires a mapping betweeninhomogeneous concepts i.e., from problem space real-time objects to solutionspace functions (indicated by the wavy arrow).andP;  If this design is thendescribed using the same language it will be implemented in, then there is aone-to-one mapping to the implementation.andP;  However, if the design language(DL) is not the same as the implementation language, there is a potentialmismatch at the DL to implementation stage.andM;On the right-hand side of Figure 4 is illustrated a thoroughbredobject-oriented methodology: an analysis of objects in problem space beingdirectly mapped on to objects in solution space and, if the same languageenvironment is used for implementation, a second direct mapping to the code.andO;Indeed, the use of the same language environment for both systems design andsystems implementation is seen by many as one of the great strengths of anobject-oriented approach ([3, 7]).andP;  Furthermore, many of the methodologiescurrently being developed for the object-oriented programming environmentstress the implementation phase since an OO design, in some snese designedtop-down at a high level, can be implemented bottom-up by identifyingexisting library classes, extending these by using inheritance andconstructing new classes as appropriate (e.g., [19, 29, 40]).andP;  In such aprocess, both top-down design and bottom-up construction occur concurrently.andM;Two major likely linkages are illustrated in Figure 4: from a functionaldescription at the analysis stage which is then transferred to an object viewat the design stage [2, 6] and presumably then an OO implementation (referredto hereafter as the FOO, for Functional analysis, Object-oriented design,Object-oriented implementation methodology) or the implementation in astandard procedural language of an object-oriented design (OOF).andP;  Either ofthese paths is indeed feasible and is currently under investigation.andP;  Here weanalyze the OOO (Object-oriented analysis, Object-oriented design,Object-oriented implementation) approach, commenting only briefly upon theutility of the two hybrid approaches, FOO and OOF.andM;It should be noted that in much of the work in the Ada environment, theobject-oriented development approach is seen by many as only a partiallife-cycle methodology in that it is considered to be a design andimplementation methodology only ([6], p. 47).andP;  As such it is required to bepreceded with a methodology for requirements analysis and systems analysisand consequently viewed as being of a FOO type.andP;  Booch [6] recommends JSD asproviding the requirements analysis tool in this approach.andP;  On the otherhand, Seidewitz [37] considers that the DFD to OO design step of e.g., [2,38, 43] is more appropriately replaced by beginning the cycle with an objectidentification and object-oriented requirements analysis in the problemdomain [3].andP;  Ladden's [25] perspective is that of a thoroughbredobject-oriented life cycle but the entity-data flow diagrams (EDFSs), asdefined in [3], to be written in the analysis stage are seen as being&quot;carved&quot; from a functionally-derived DFD in the traditional sense.andP;  Althoughthis builds on existing, understood methodologies, it would appear to addunnecessary complication in the form of an additional intermediate step inderiving an entity data flow diagram, a step which is often difficult and/ortime consuming.andP;  Ladden [25] notes this problem and also suggests a moredirect approach.andP;  Overall, he sees functional decomposition andobject-oriented design as complementary.andM;Most of the object-oriented development methodologies presented in theliterature to date are not generic, having been structured specifically withAda in mind.andP;  Since Ada is not an object-oriented language, but only anobject-based language [45], some of the major features of the object-orientedparadigm, such as inheritance, are not addressed directly in the analysis anddesign notations, such as those of Booch [5, 6], although some of theanalysis and design ideas can be more generally applied (see the followingsection).andP;  (Overviews of Ada-specific design methodologies are contained ine.g., [3, 25, 37].)andP;  In recent years non-Ada oriented methodologies havebegun to appear, for example [11, 12, 29].andP;  These are mainly partiallife-cycle models concerning program design or the requirements phase only.andO;Meyer [29], for example, concentrates on class development using formalspecification of abstract data types (ADTs) to define behavior and providesexamples on how to transform a functional design to an object-oriented designto an object-oriented Yourdon [12] present an object-oriented analysis (OOA)method, using data modeling techniques, in which they define the systemarchitecture in terms of assembly and classification structures.andP;  Servicesare specified for objects by techniques such as entity-life-history andstate-event-response charts.andP;  Wirfs-Brock and Wilkerson [47] use aresponsibility-driven approach to OOD.andP;  This method concentrates on theresponsibilities of an object and the information it shares with otherobjects.andP;  The aim here is to increase encapsulation of information within theobject.andM;These approaches were designed to try to utilize all the features of anobject-oriented design, unlike many of the Ada methodologies.andM;A Coherent Object-OrientedandM;DevelopmentandM;MethodologyandM;As illustrated in Figure 4, there is a distinct difference betweenobject-oriented programming and object-oriented systems analysis and design.andO;Many techniques discussed by e.g., [6, 29] are primarily aimed at OO programimplementation; although such authors also make some proposition regardingthe analysis and design stages.andP;  Booch ([6], p. 48) identifies five majorstages:andM;* Identify objects and attributesandM;* Identify operations affecting objectsandM;* Establish visibilityandM;* Establish interfaceandM;* Implement each objectandM;It can be seen that the first items are, indeed, at a system level, but thelast few are more strictly detailed design or implementation details.andP;  As aset of criteria, therefore, they are better suited to &quot;object design&quot; ratherthan csystem design,&quot; confirming that bottom-up or middle-out design is alsoappropriate in an object-oriented development process.andP;  In other words, ascan be seen simply from this list, the distinction between system design andcode design can become rapidly blurred.andP;  This results from the twin,concurrent needs to analyze the overall system at a high level of abstractionin terms of an object-oriented systems design, while acknowledging thatimplementation in an object-oriented programming language is accomplishedbest by using a bottom-up development of new objects which can utilize theextensive set of library classes already in existence.andP;  These library classesare the coded versions of the design objects, or object classes.andP;  In general,the term class refers to the compile-time description of the abstract datatype used to describe the solution space objects and design objects.andM;Both top-down analysis and bottom-up class design, seen as the hardest partof the entire object-oriented software life cycle [28], must therefore beeither concurrent or, at least, iterative.andP;  In order for successful codereuse, existing, well-validated classes must be seen to be part of the designstage, not just the implementation.andP;  It should also be noted that these fivesteps do not provide guidelines on establishing object-object relationshipsin terms either of client-server or in terms of the powerful inheritancemechanism.andP;  This may be, in part due to the Ada-orientation of Boochhsmethodology which precludes a straightforward use of inheritance concepts.andM;In a study of an object-oriented requirements specification method, Bailin[3] also identifies the large degree of overlap between not only design andcoding, but also between requirements specification and systems design.andP;  Heidentifies seven steps for his specification method, which could obviouslytranscend the requirements stage well into detailed design:andM;1.andP;  identification of key problem space objects (Bailin uses the term&quot;entities&quot; throughout);andM;2.andP;  distinguish between active and passive objects;andM;3.andP;  establish data flows between active objects;andM;4.andP;  decomposition of objects into &quot;sub-objects&quot;;andM;5.andP;  check for new objects;andM;6.andP;  group functions under new objects;andM;7.andP;  assign new objects to appropriate domains.andM;Bailin [3] sees the steps 1-3 as once-only steps, with steps 4-7 beingperformed iteratively.andP;  He applies these steps to the analysis phase of thelife cycle.andP;  However, there are immediate links to class design andimplementation.andP;  For example, decomposition of objects can be identified atthe implementation stage with the procedures of classification, aggregationand generalization.andP;  In this method, a data-flow diagramming technique isretained to describe the system in which the nodes become objects (i.e.,andO;classes at implementation).andP;  Although Bailin [3] suggests that EDFDs can alsopossess nodes to represent functions, both he and other authors (e.g., [29])suggest that functions should be part of the implemented object (i.e., theclass) and, therefore by implication, part of the analysis phase object.andM;Based on these two possible criteria for object-oriented systems development,a censensus can be drawn on both the stages pertinent to an object-orientedlife cycle and the common features associated with each phase.andP;  Althoughseveral stages will be identified (Table 1), each overlaps and there are manyiterative possibilities that must be borne in mind.andM;1) Undertake system requirements specification.andP;  This stage is a high-levelanalysis of the system in terms of objects and their services, as opposed tothe system functions.andP;  However, if a great deal of OOA is undertaken, thenthe result may be an object-oriented requirements specification (OORS)including timing details, hardware usage, cost estimates and otherdocumentation.andP;  Coad and Yourdon [12] and Shlaer and Mellor [39] both presentOOA methods that may be used at this stage.andM;2) Identify the objects.andP;  At both the analysis and the high-level designstage, it is necessary to identify the objects or entities, their attributesand the services they provide.andP;  This is where the functional features will bedefined, although no indication of implementation is required; this being oneof the basic tenets of the object-oriented paradigm.andP;  Objects can often beidentified in terms of the real-world objects, although as Meyer [28] notes,often, abstract nouns also provide excellent objects.andP;  However, at this highlevel of abstraction it seems unnecessary to decompose the object and lookfor more primitive object representations, since these are more reasonablypart of the detailed design stage.andP;  Here, an object (entity) dictionaryshould be used as the object-oriented analogue of the data dictionary.andM;Identification of appropriate objects must therefore not be undertaken solelyon the objects identified in the requirements specification and the analysisand design stage, since it is anticipated that well-designed object classeswill be used again and again.andP;  Such identification of genericity (see alsoSteps 6 and 7), although encouraged in standard procedural language courses,is seldom taken seriously.andP;  Identification of objects and ultimately ofclasses will de facto define the operations affecting the objects, and theservices they offer, hence defining the visible interface.andM;3) Establish interactions between objects in terms of services required andservices rendered (analogous to the data flow of Bailin's EDFD).andP;  For thisstage, a diagrammatic notation akin to the EDFD and/or theentity-relationship (ER) diagram would be most useful.andP;  Perhaps a better namefor the object-oriented equivalent of the DFD, rather than EDFD, might be IFD(information flow diagram) where &quot;information&quot; relates to messages and/ormessage-arguments, since in general, data are contained within an object anddo not flow in the same sense as that described by a DFD in functionaldecomposition techniques.andP;  Another type of software tool, useful in specificprogramming environments is illustrated by the Eiffel (*1)-specific editor,GOOD [30].andP;  GOOD is an interactive object browsing facility that permits theuser to trace the object hierarchies and object relations.andP;  It also permitsexamination of attributes and routines of individual objects.andP;  (Browsingtools are discussed in more detail in [18]).andM;4) As the analysis stage merges into the design stage, lower level EDFDs/IFDscan be drawn to illustrate more internal details of the objects.andP;  From thisstage onward, bottom-up concerns should be taken into consideration.andP;  Theidentification of reusable design components, or classes, from previousdesigns is an important part of the OO strategy.andP;  In some languages (e.g.,andO;Ada), classes can be embedded inside other classes (e.g., [23]).andP;  In a pureobject-oriented life cycle (right-hand side of Figure 4), especially onewhich is using the same language for both systems analysis, design andimplementation, the decision of whether to represent embedded classes or notwill therefore reflect the language being used.andP;  In Eiffel, no embedding ispossible.andP;  Instead, classes refer to other classes so that including anattribute of a given (abstract data) type inside a class is simply areference to an object (which at the coding level now refers to a singleinstantiation) of the class which defines the implementation of that abstractdata type.andP;  Diagrammatically design-level objects would remain asindividuals.andP;  However, at the top level an object of higher-level abstractionwould be represented by a single piece of notation (which we note we have notyet defined!--see the following section, &quot;Graphical Notation forObject-Oriented Software Development&quot;).andM;5) Concurrently, bottom-up concerns should be being realized insofar asentity-relationship diagrams, such as EDFDs or IFDs, can be used to describethe more detailed internal structure of the objects of the analysis diagrams.andO;Objects are themselves constructed from libraries of more primitive objectsusing concepts of client-server and contracting [31, 47]; the librariesthemselves contain object classes created as one of the successful outcomesof a previous application of this (or other) proposed developmentmethodology.andP;  Initially, implementation (coding plus testing) of low-levelclasses may begin at this stage, following the cluster model described below.andM;6) As more objects are identified within the detailed design, reevaluation ofthe total set of classes will require an iterative analysis of whether newsuperclasses (parents) or new subclasses (children) will be useful, creatinga need for inheritance diagrams (Figure 5).andP;  For example, a class of &quot;bird&quot;with an attribute that &quot;birds can fly&quot; is successful until we consider theSouthern Hemisphere and &quot;penguins,&quot; &quot;ostriches,&quot; &quot;kiwis&quot; etc.andP;  In this case,one solution is to introduce an additional level in the inheritance hierarchyby introducing two children classes of class bird as &quot;flying bird&quot; and&quot;non-flying bird&quot; and redefining the parent class to remove the attributesrelating to flight [7, 30].andP;  This process tries to develop a logicalhierarchy of objects so there are no &quot;missing&quot; objects.andP;  This step is neededin order to provide a well-defined hierarchy so that future projects canreuse the structure without having to redesign the inheritance chart forthemselves.andP;  This process will probably take place during the generalizationphase of the cluster model of class development.andM;7) Aggregation and/or generalization of classes, as undertaken in theprevious step, may require iteration back to reconsider the EDFDs/IFDsdescribing the system.andP;  It may be that prototyping will already havecommenced by this stage, providing constructive feedback to the potentialusers so the requirements documents may require modification andclarification (e.g., [42]) leading to further development of the classspecified.andP;  Although this is contrary to expectations of the traditionallife-cycle model, such feedback, essentially from one end of the traditionallife cycle to the other, is made possible by the object-oriented techniquesand is seen as providing a more reliable, robust and useful software system.andM;The system classes that are identified and developed during this process maythen undergo another stage of development, known as generalization, followingthe cluster model.andP;  At this stage the components continue to be worked onuntil they are general, generic and robust enough to be placed in a libraryof components.andP;  In the short term, this adds a development overhead to thecurrent project which is more than compensated for by the long-term savingwhen future projects can directly utilize library objects rather than have todesign, implement and test them from scratch.andM;As can be seen from this suggested OOO methodological framework, class designand system design go hand-in-hand.andP;  Meyer [29] stresses the bottom-up natureof class design in order to provide generically useful classes.andP;  However,these cannot be decided in vacuo.andP;  System design must influence class designand implementation; whilst class design and class availability must influencesystem analysis and structural design.andM;The cluster model (Figure 6) has been proposed by Meyer [30] as a life cyclefor a tightly related group of classes, or cluster, in which three phases areidentified.andP;  First a specification is written by the systems designer (SPEC),then this is designed and implemented (DESIMPL) (one process in a languagelike Eiffel) and finally it is validated and generalized (VALGEN).andP;  This lifecycle occurs for different clusters of classes at different times.andP;  Forexample, a graphics cluster and a windows cluster of classes could bespecified, designed and implemented and then validated and generalized atdifferent times.andP;  It should be noted that this model applies to softwareclasses and not to software systems.andP;  The specification of a class is refinedfrom a specification of the system and describes in as much detail aspossible the services and semantics of the class.andP;  This would best beexpressed theoretically as a formal specification of an Abstract Data Type[29].andM;High-level object identification at relatively early information systemsdesign stages allows programmers to begin work while analysis of the systemcontinues.andP;  In this way, the requirement may be changed as the customerdevelops an understanding of his or her needs without adversely affecting thesoftware design stages.andP;  The initial object identification will probably beof persistent objects which can be identified early and thus are unlikely tochange a great deal as new requirements are added.andP;  For example, in anaircraft radar system objects such as radar, aircraft and windows will berequired.andP;  These may be presented to programmers as groups of object classesto program at a very early stage with a high degree of confidence that evenif the systems specifications were to change (or the project be cancelled),these classes would still be useful.andM;Graphical Notation forandM;Object-OrientedandM;Software DevelopmentandM;Object-Oriented Life CycleandM;NotationandM;Any graphical representation of the object-oriented version of the overallsoftware development life cycle must take into account the high degree ofoverlap and iteration implicit ([27, 30, 35, 42]).andP;  Rather than using arevised waterfall model, the &quot;fountain model&quot; of Figure 7 seems to beappropriate.andP;  First, it provides a diagrammatic version of the stages presentin an object-oriented software life cycle and a clearer representation of theiteration and overlap made possible by object-oriented technology.andP;  Second,since the foundation of a successful software project is its requirementsanalysis and specification, this stage has been placed at the base of thediagram.andP;  The life cycle thus grows upward to a pinnacle of software use,falling only in terms of necessary maintenance.andP;  This effectively reverts thestage of the cycle to a lower level.andP;  Application of this model to specificenvironments may lead to software life cycles such as prototyping: adevelopment environment for which object-oriented programming languages(OOPLs) are well suited.andP;  (This model is also applicable to the traditionalfunctional-decomposition-based description of the life cycle, as described inFigure 1.andP;  In this case, however, there is a significant decrease in theoverlap of the circles, and in some cases disjoint processes may berepresented by tangential circles.)andM;The system can be viewed not only in terms of the systems life cycle, aspresented in Figure 7, but also in terms of a synergistic amalgamation of a(usually large) number of autonomous classes.andP;  Modifications can more easilybe made interactively between class development and systems specification sothere is no longer a need to freeze the overall systems requirementspecification at an early stage of the system life cycle--an attribute of theobject-oriented methodology viewed very positively by many authors.andO;Consequently, since an object-oriented program will be developed essentiallyas an interacting system of classes (usually developed independently), thestages of the life cycle model can be applied more accurately to thedevelopment cycle of each individual class (Figure 8) rather than the systemas a whole [19].andP;  More generally, the stages of Figure 8 would applyconcurrently to a small number of classes grouped as a cluster (Figure 6).andO;In this sense the model represented by Figure 8 could be utilized directlyfor clusters as well as individual classes.andP;  Through the introduction ofexplicit stages of aggregation and generalization, case-specific classes arerevised so that they can be sufficiently generic to be of use in asubstantially wider range of applications than the single one for which theywere originally developed.andP;  This requires a greater effort than one-offdesign/implementation in the short term, but in the long term, when asufficiently broad library has been constructed, will lead to significantreduction in overall systems development time and effort.andP;  This is aconsequence of the emphasis on code reusability within the object-orienteddesign environment which can be accomplished best by both bottom-updevelopment of classes often within the framework of an overall top-downobject-oriented systems analysis and high-level design.andM;The significance of the cluster models (described previously--Figures 6 and8) in the software life cycle is as a branch of the systems specification anda result of its modular refinement.andP;  Figure 9 synthesizes the systemsconcepts of Figure 7 with the cluster life cycle ideas of Figures 6 and 8 andis a diagrammatic representation of how requirements design andimplementation stages grow and iterate over time while individual classes orclusters of classes undergo their own cluster and fountain life cycle.andP;  Theadvantages of such a representation are that characterisitcs of a system,which evolves dynamically as users' and analysts' knowledge grow, can beincorporated in the overall life-cycle model.andP;  It has been recognized forsome time that users' needs continually change and specifications are rarelyfixed (e.g., [16]), but only now are methodologies being developed andapplied which are able to incorporate such characteristics within the overallsystems development.andP;  The decentralized architecture of object-orientedmethods is the key to this approach.andM;The fact that clusters of classes can undergo detailed design and beimplemented in isolation from the system means that system requirements anddesign spawn clusters which are then passed on to a team of programmers fordetailed design and implementation, only later to be incorporated in thefinals system design by bottom-up methods.andP;  This makes iteration betweensystems requirements analysis and system design a much easier process, asdesigns are not based upon the first (and often least informed) decisionsmade, as is the case in top-down functional design.andP;  For example, Figure 10shows how a change in the requirements in a system designed and implemented&quot;top-down&quot; necessitates a change in the &quot;top&quot; of the functional decompositiondesign, resulting in a great deal of necessary reworking since the moredetailed design, having been decomposed from the uppermost function, ishighly dependent on this main systems function.andP;  On the other hand, as seenin Figure 9, a change in requirements may cause the abandonment of a singlecluster but this will not cause any major redesign since the overall systemsynthesis occurs much later in the systems life cycle.andM;Object-Oriented DesignandM;NotationandM;Diagrammatic notation at the level of class or cluster design and refinementrequires representation for individual object classes, their subclasses andtheir interrelationships, especially in terms of inheritance andclient-server mechanisms.andP;  In this context, Booch's graphical notation(Figure 11), despite being conceived as Ada-specific, is worthy of furtherstudy.andP;  These symbols relate most successfully to the detailed design stageor to class design.andP;  Indeed, Seidewitz [37] is critical of such a methodologyapplied at the systems-design level since he suggests that for a system ofany real size such a graphical method becomes unwieldy (see also [23]).andP;  Inmore general terms, the graphical representation of an Ada package can beutilized as a general representation of an object, since it successfullytypifies the discrimination between the private, hidden part of the objectand the public portion, as represented by the protrusions.andP;  However, the Ada&quot;task&quot; has no general implementation; although the object-oriented paradigmis now beginning to embrace the need for concurrency (see e.g., [1]).andP;  Analternative graphical notation for objects and their interrelationships isgiven by Meyer [29] (Figure 12).andP;  Here, the object is shown to containseveral attributes, some of which are defined within the object itself andsome of which are references to other objects.andP;  In this example, thesereferences, which access a shared object, represent services supplied to andobtained from other objects.andP;  However, no differentiation is made herebetween private and public parts, as in the Ada package notation.andP;  Alabiso[2] outlines an object structure chart (OSC) (Figure 13) notation whichrepresents inheritance by a dashed line and object use by a solid line.andO;Although differentiation is made between attribute and services provided bythe class, it seems likely that with any significant number of interrelatingclasses, such a notation would become unwieldy.andP;  However at the detaileddesign stage such a notation could be useful and is similar to that describedbelow.andM;A general, non-language-specific notation is therefore required.andP;  Objectnotation pertains to the design-level objects (or entities) and also to theclasses of run-time objects prior to implementation.andP;  Sinceinterrelationships between design objects and also between classes can berepresented similarly, but at different stages of the life cycle, we willrefer to such generic applicability by &quot;O/C&quot; (objects or classes).andP;  Thesediagrammatic representations must possess the following properties: O/C name,and public interface in terms both of services offered and informationalattributes available.andP;  A slight modification of the Booch diagram seems tosatisfy these requirements (Figure 14(a)).andP;  In addition, object-object (orclass-class) relationships must be represented.andP;  For clietn-server, in whichan attribute of an O/C is of an abstract data type and hence requiresreference to another O/C for its realization, the arrow from a circleinternal to the O/C directed to the name of the server O/C is useful (Figure14(b)).andP;  Inheritance can be represented simply by a thick, directed arrowfrom the outer shell of the child O/C to the outer shell of the parent O/C.andO;This is analogous to the is a arrowed relationships of e.g., [13].andM;Object identification, the first step of Booch's [6h methodology requiresclarification.andP;  Although object-oriented terminology is not yet standardizedand agreed upon, there are common threads, some of which are, nevertheless,language-dependent.andP;  Sommerville [41] identifies two types of objects: directspecification of the object (with all its attributes and operations), anddefining an (object) class as a template.andP;  The latter is always to be usedwhenever more than a single instantiation of that class is required.andO;Although supported in Ada, other languages do not require suchdifferentiation.andP;  In Eiffel, all objects are instantiations of a class type(which is itself defined as an implementation of an abstract data type).andP;  Inother words, the code contains only classes which are the templates for thecreation of objects as instantiation of these class types at runtime.andM;A brief example will illustrate this approach.andP;  (This example is by no meansintended to be complete, merely illustrative.)andP;  Consider the problem ofconstructing and manipulating a bibliography.andP;  A simple functional DFD todescribe inputting and sorting the bibliography is shown in Figure 15(a).andP;  Incontrast, consider the OOO methodology applied to this problem.andP;  In Setp 1the objects are identified.andP;  These are bibliography itself, reference,author, title, date (for the simplest case).andP;  Also the notion of command,session and stored file will be useful as objects.andP;  One possible EDFD/IFDdiagram, analogous to the functional DFD in Figure 15(a), is shown in Figure15(b).andP;  In this diagram are indicated some of the top-level relationships(step 3) between objects.andP;  Further lower-level designs details are added atstep 4, probably for individual clusters of O/Cs (Figure 16).andP;  (In thisexample, all the classes used would be essentially part of the same cluster.)andO;In step 5, details of the bottom-up concerns are realized in terms of theimplementation of these new O/Cs in terms of existing library classes (Figure17, together with Table II for the associated object dictionary).andP;  In thislimited example, steps 6 and 7 are not evident.andM;Productivity ConcernsandM;Figure 18 shows schematically the predicted time and effort associated withthe object-oriented model described above.andP;  It shows that different stages ofthe information system and software life cycle could occur concurrently.andP;  Theresult is that at any one time the same amount of effort could be going intothe project as with the &quot;linear&quot; life cycle but that this effort would bedistributed more evenly across the project stages.andP;  The result is a reductionin the time taken to complete the project, but not a reduction in the timespent in any one area.andP;  Indeed, it is likely that the class design andimplementation could take considerably longer since geneicity and code reuseis one of the aims of the object-oriented life cycle, in order thatmaintenance costs (often, unwisely, excluded from project development costs)can be dramatically reduced.andP;  Consequently, the traditional software metrics,either in terms of source lines of code or function points, will inevitablyindicate a decrease of productivity since they do not address the subsequentphase of program maintenance.andP;  Thus it may be that traditional metrics are oflittle use to OOD.andP;  In terms of code and design elements there may now be twoconceptual libraries to deal with: one for the project, storing revisions forthe project under way and one for components that are fully generalized.andO;This product library would be where the components produced following thecluster model of Figure 8 would eventually reside ready to be accessed forother developmental projects [32, 33].andP;  In the object-oriented life cycle,more effort is required in the design and implementation phases andconsiderably less in program maintenance.andP;  Strategic planning is thereforerequired by an industry together with concomitant software metrics in orderfor the actual productivity gain foreseen for large systems developmentsusing the object-oriented paradigm to be consistently evaluated.andP;  It shouldalso be noted that the object-oriented life cycle retains the advantages ofthe prototyping approach so the user can develop a better understanding ofthe system before signing off the specification documents.andM;ConclusionsandM;There is no one object-oriented software model of the life cycle that has yetgained universal acceptance (e.g., [35]).andP;  However, by trying to maximize theadvantages of the application of the object-oriented paradigm, the seven-stepmethodological framework seems appropriate.andP;  By using bottom-up design forclasses at the same time as top-down object-oriented systems design,interactions can be encouraged so that the design is more robust and at thesame time more flexible and the classes themselves are generically useful.andO;Use of the same programming language environment from requirements analysisthrough to implementation also facilitates the coherent binding between thevarious processes in software development.andP;  The result should be a moremaintainable system, a more extensible (flexible) system closer to the users'requirements and a system that requires overall less total time to produceand maintain.andM;Acknowledgments.andM;J.M.andP;  Edwards wishes to thank The Urban Water Research Association ofAustralia for financial support for the duration of this project.andP;  Theauthors are also grateful to the reviewers of this article.andM;ReferencesandM;[1] Agha, C.andP;  Concurrent object-oriented programming.andP;  Commun.andP;  ACM 33, 9(Sept.andP;  1990).andM;[2] Alabiso, B.andP;  Transformation of data flow analysis models to objectoriented design.andP;  In Proceedings of OOPSLA '88 (1988) ACM, New York, pp.andO;335-353.andM;[3] Bailin, S.C.andP;  1989, An object-oriented requirements specification method.andO;Commun.andP;  ACM 32, 5 (1989), 608-623.andM;[4] Boehm, B.W.andP;  Software engineering.andP;  IEEE Trans Comput.andP;  C-25, (1976),1226-1241.andM;[5] Booch, G.andP;  Describing software design in Ada.andP;  Sigplan Not.andP;  in Ada, 69(1981), 42-47.andM;[6] Booch, G.andP;  Software Engineering with Ada.andP;  Benjamin/Cummings, California,1987, 580.andM;[7] Borgida, A.andP;  Greenspan, S. and Mylopoulos J. Knowledge representation asa basis for requirements specification, IEEE Comput.andP;  18, 4 (1985), 82-101.andM;[8] Boyd, S. Object-oriented design and PAMELA[TM]: A comparison of twodesign methods for Ada.andP;  Ada Lett.andP;  7 July-Aug 1987), 68-78.andM;[9] Brookes, C.H.P., Grouse, P.J., Jeffery, D.R.andP;  and Lawrence, M.J.andO;Information Systems Design.andP;  Prentice-Hall, Sydney, 1982, 477.andM;[10] Cameron, J.R.andP;  An overview of JSD, IEEE Trans.andP;  Softw.andP;  Eng.andP;  SE-12, 2(1986), 222-240.andM;[11] Carver, D.L.andP;  and Cordes, D.W.andP;  An object-oriented framework to supportarchitectural design development, In Proceedings of Hawaii InternationalConference Systems Science, v II, IEEE, (Los Alamitos, CA, 1990) pp.andO;349-357.andM;[12] Coad, P. and Yourdon, E.andP;  Object-Oriented Analysis.andP;  Prentice-Hall,Englewood Cliffs, N.J., 1990, 240.andM;[13] Constantine, L.L.andP;  Object Oriented and Structured Design Seminar.andO;Digital Consulting Pacific, 1989.andM;[14] Constantine, L.L.andP;  and Yourdon, E.andP;  Structured Design.andP;  Prentice-Hall,Englewood Cliffs, NJ, 1979.andM;[15] Davis, A.M.andP;  A taxonomy for the early stages of the software developmentlife cycle.andP;  J. Syst.andP;  Softw., 8, (1988), 297-311.andM;[16] Davis, A.M., Bersoff, E.H., and Comer, E.R.andP;  A strategy for comparingalternative software development life cycle models.andP;  IEEE Trans.andP;  Softw.andO;Eng.andP;  14, (1988), 1453-1460.andM;[17] DeMarco, T. Structured Analysis and System Specification.andP;  YourdonPress, New York, (1978).andM;[18] Gibbs, S., Tsichritzis, D., Casais, E., Nierstrasz, O. and Pintado, X.andO;Class management for software communities, Commun.andP;  ACM 33, 9 (Sept.andP;  1990).andM;[19] Gindre, C. and Sada, F.andP;  A development in Eiffel: design andimplementation of a network simulator.andP;  J. Object Oriented Program.andP;  2, 1(1989), 27-33.andM;[20] Hawryszkiewycz, I.T.andP;  Introduction to Systems Analysis and Design.andO;Prentice-Hall, New York, 1988, 373.andM;[21] Jackson, M.A.andP;  Principles of Program Design.andP;  Academic Press, London,1975.andM;[22] Jackson, M.A.andP;  System Development.andP;  Prentice-Hall, London, 1983.andM;[23] Jalote, P.andP;  Functional refinement and nested objects for object-orienteddesign.andP;  IEEE Trans.andP;  Softw.andP;  Eng.andP;  15, 3 (1989) 264-270.andM;[24] Korson, T. and McGregor, J.D.andP;  Understanding Object-Oriented: A Unifyingparadigm.andP;  Commun.andP;  ACM 33, 9 (Sept.andP;  1990).andM;[25] Ladden, R.M.andP;  A survey of issues to be considered in the development ofan object-oriented development methodology for Ada.andP;  Ada Letters, 2, (1989),78-88.andM;[26] Ledgard, H. and Marcotty, M.andP;  The Programming Language Landscape,Science Research Associates, Chicago, 1981.andM;[27] Malhotra, A., Thomas, J.C., Carroll, J.M.andP;  and Miller, L.andP;  Cognitiveprocesses in design.andP;  J. Man-Mach.andP;  Studies 12, (1980), 119-140.andM;[28h Meyer, B.andP;  Bidding farewell to globals, J. Object Oriented Program.andP;  I,3 (1988), 73-76.andM;[29] Meyer, B.andP;  Object-Oriented Software Construction.andP;  Prentice-Hall, HemelHempstead, 1988, 534.andM;[30h Meyer, B.andP;  From structured programming to object-oriented design: theroad to Eiffel.andP;  Structured Programming, 1, (1989), 19-39.andM;[31] Meyer, B.andP;  Programming as contracting, Tech.andP;  No.andP;  TR-EI-12/CO, Version2, Interactive Software Engineering, CA, 1989, 46.andM;[32] Meyer, B.andP;  The new culture of software development: reflections on thepractice of object-oriented design, In Proceedings of TOOLS '89, (Paris,November 13-15, 13-29, 1989).andM;[33] Meyer, B.andP;  Tools for the New Culture: Lessons from the design of theEiffel libraries, Commun.andP;  ACM 33, 9 (Sept.andP;  1990).andM;[34] Parnas, D.andP;  On the criteria to be used in decomposing systems intomodules, Commun.andP;  ACM, 15, 12 (1972), 1053-1058.andM;[35] Rajlich, V.andP;  Paradigms for design and implementation in Ada.andP;  Commun.andO;ACM 28, 7 (1985), 718-727.andM;[36] Reynolds, G.W.andP;  Information Systems for Managers.andP;  West Publishing Co.,andO;St. Paul, MN, 1988, 437.andM;[37]  Seidewitz, E.andP;  General object-oriented software development: backgroundand experience, J. Syst.andP;  and Softw.andP;  9, (1989), 95-108.andM;[38] Seidewitz, E. and Stark, M.andP;  Towards a general object-oriented softwaredevelopment methodology.andP;  Ada Letters, 7 (July/August 1987), 54-67.andM;[39] Shlaer, S. and Mellor, S.J.andP;  Object-Oriented Systems Analysis: Modelingthe World in Data.andP;  Yourdon Press Computing Series, 1988, 144.andM;[40] Snyder, A.andP;  Encapsulation and inheritance in object-oriented programminglanguages, In Proceedings of OOPSLA '86, ACM, New York (1986), pp.andP;  38-45.andM;[41] Sommerville, I.andP;  Software Engineering, 3rd ed., Addison-Wesley,Wokingham, 1989, 653.andM;[42] Turner, J.A.andP;  Understanding the elements of system design.andP;  In CriticalIssues in Information Systems Research, R.J.andP;  Boland, Jr.andP;  and R.A.andO;Hirschheim, Ed.andP;  John Wiley, Chichester, 1987, 97-111.andM;[43] Ward, P.andP;  How to integrate object orientation with structured analysisand design IEEE Softw.andP;  (March, 1989), 74-82.andM;[44] Ward, P. and Mellor, S.andP;  Structured Development for Real-Time Systems,Prentice-Hall, Englewood Cliffs, New Jersey, 1985.andM;[45] Wegner, P.andP;  Learning the language, Byte, (March 1989), 245-253.andM;[46] Wirfs-Brock, R.J.andP;  and Johnson, R.E.andP;  Surveying current research inobject-oriented design, Commun.andP;  ACM, 33, 9 (Sept.andP;  1990).andM;[47] Wirfs-Brock, R.J.andP;  and Wilkerson, B.andP;  Object-oriented design: aresponsibility-driven approach, In Proceedings of OOPSLA '89, (1989), 71-75.andM;BRIAN HENDERSON-SELLERS is Senior Lecturer in the School of InformationSystems at the University of New South Wales.andP;  His current research interestsinclude object-oriented systems development methodologies and notation;implementations of the object-oriented paradigm in the commercialenvironment; environmental decision support and simulation modelling.andP;  He isConvenor of the Object-Oriented Special Interest Group of the AustralianComputer Society (NSW Branch).andM;JULIAN M. EDWARDS is a Ph.andP;  D. candidate at the University of New South Walesin the School of Information Systems and the Urban Water Policy Centre.andP;  Heis investigating the application of the object-oriented approach to theeconomic evaluation of water treatment processes.andO;</TEXT></DOC>