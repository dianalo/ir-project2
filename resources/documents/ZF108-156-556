<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-156-556  </DOCNO><DOCID>08 156 556.andM;</DOCID><JOURNAL>Dr. Dobb's Journal  Jan 1990 v15 n1 p140(7)* Full Text COPYRIGHT Mandamp;T Publishing 1990.andM;</JOURNAL><TITLE>Dressing the truth in rubber suits. (truths about object-orientedprogramming; aspects of polymorphism in object-orientedprogramming) (column)</TITLE><AUTHOR>Duntemann, Jeff.andM;</AUTHOR><SUMMARY>Misleading assertions about object-oriented programming (OOP) arecorrected, and the nature of polymorphism in OOP is discussed.andO;OOP does not make coding effortless, but the hardest work isperformed up front in the development of the conceptual model.andO;The encapsulation aspect of OOP languages does prevent a certainclass of bugs, but erroneous code is inheritable.andP;  'Rapidfree-form prototyping' is possible to some degree in some OOPlanguages, but the quality of the OOP prototype depends upon thequality of the standard class library.andP;  Polymorphism in OOP wasdiscussed in a previous column, but several aspects are notunderstood well by many users.andP;  These include polymorphicassignment compatibility, which involves the assignment of adomain of an object class and its descendent classes to a rootdomain in an object hierarchy.andP;  Polymorphism in QuickPascal andTurbo Pascal are discussed.andM;</SUMMARY><DESCRIPT>Product:   Turbo Pascal (Compiler) (programming)QuickPascal (Computer program language) (programming).andO;Topic:     Object-Oriented ProgrammingEvaluationUtilizationProgram LogicHierarchical OrganizationClassification SystemsPASCAL.andO;Feature:   illustrationchartprogram.andO;Caption:   The domain of object class ARC. (chart)Listing one: PolyTest program for QuickPascal 1.0. (program)Listing two: PolyTest program for Turbo Pascal 5.5. (program)andM;</DESCRIPT><TEXT>Dressing the Truth In Rubber SuitsandM;Remember AI?andP;  Sure you do.andP;  A couple of years ago, it was going to change theface of the planet, according to the legions of ignorant Esther Dysonwannabees selling $900 newsletters to corporate seatwarmers with lots ofmoney to waste.andP;  AI was going to allow programs to configure themselves.andP;  AIwas going to allow us to get our work done without expending any effort.andP;  AIwas going to allow our software to read our minds.andP;  It got so bad that PCWeek columnist Jim Seymour suggested that software vendors could double salesby slapping a gold starburst sticker on the outside of every product packagereading, &quot;New!andP;  Improved!andP;  With AI!&quot;andM;Meanwhile, back in the trenches, the guys who were researching AI were sadlyshaking their heads.andP;  They never made those promises, or any promises.andP;  Theyweren't trying to create an artificial human brain.andP;  They were just lookingfor new ways to arrange the same old instructions we've been fetching andexecuting all along.andP;  The human brain is a pretty successful computer, theyreasoned, so why not try to learn something from the way it works?andP;  Had theycalled it cognitive modeling or somesuch, nothing dramatic would havehappened.andP;  (Industry mavens rarely abuse what they can't pronounce.)andP;  But say&quot;artificial intelligence&quot; and, whammo!andP;  Isaac Asimov's robots come stridingover the horizon, with Popular Mechanics, People Magazine, and finally TheNational Enquirer in hot pursuit.andM;You'll notice that nobody's talking much about AI anymore.andP;  The hypemongersburied it so deep that nobody in the mainstream software developmentcommunity may ever take it seriously again.andP;  The hype machines have beenquiet lately, but don't assume that they're gone -- they're just getting avalve-and-ring job so to be in top shape when the next fad happens by, likeremoras watching for a passing grouper.andM;Lately, I've begun to hear them reviving, this time over something with a lotmore near-term potential than AI: Object-oriented programming.andP;  People whonever said OOPs before, except when using chopsticks, have becomeself-anointed experts, and have begun dressing the truth in rubber suits.andM;So let's dump some sand in the hype machines, and nail some nascentconventional wisdom to the wall.andM;Rubber Truth #1: OOP Makes CodingandM;EffortlessandM;Dream on.andP;  Furthermore, OOP doesn't even make coding easy.andP;  One might arguethat it makes coding more difficult, in that OOP requires considerableforethought and design effort up front.andM;An object hierarchy requires a starting points; a handful of abstract classesthat exist to broadcast certain characteristic behavior down the manyinheritance branches.andP;  The root of the tree is a foundation on whichthousands or tens of thousands of lines of code may depend.andP;  If you discoverhalfway through a 50,000 line application that you've conceptualized thefundamental abstract classes wrong, you might just have to kiss 25,000 linesof code good-bye.andP;  So take heed:andM;Duntemann's OOP Warning #1:andM;Invalidating the Root InvalidatesandM;The Leaves!andM;When you cast a program design in OOP terms, think very hard about the natureof your conceptual model.andP;  Once you've created a solid, correct, and workablefoundation in terms of an object hierarchy, coding gets a little easierbecause you can inherit and reuse some of that hard, early general work inthe later, more specific tasks.andP;  That doesn't mean that the total effortrequired to finish the project is going to be any less.andP;  It's just that thehardest work gets done up front, and the rest of it seems easy only bycomparison.andM;Rubber Truth #2: OOP Makes ProgramsandM;BulletproofandM;I confess, I've stretched this one a little myself, and have been bitten inthe hindparts for my trouble.andP;  At first thought, encapsulation might appearto make it harder for bugs to propagate beyond the bounds of the object inwhich they occur.andP;  Unfortunately, all method code is bequeathed to anobject's children, for good or for bad.andP;  There's no software equivalent ofMaxwell's Daemon sitting on a post at the object's interface, lettingfeatures pass down the object hierarchy but keeping the bugs behind.andP;  So,folks, keep in mind:andM;Duntemann's OOP Warning #2: Bugs AreandM;Just as Inheritable as FeaturesandM;It's true to an extent that languages that enforce encapsulation, such asSmalltalk and Actor, prevent a certain class of under-the-table bugs causedby directly referencing an object's state or instance variables.andP;  InSmalltalk and Actor, you simply cannot reference an object's internal state(that is, what in Object Pascal we would call its fields) directly.andP;  Thismakes bug propagation a one-way street down along the object hierarchy, whichis better than nothing.andP;  Unfortunately, even this protection is missing fromC++ and the various dialects of Object Pascal.andP;  Both Turbo Pascal andQuickPascal require that you, the programmer, enforce encapsulation, and ifyou're a bad enforcer, you're no better off than with traditional structuredprogramming techniques.andM;Rubber Truth #3: OOP Allows EasyandM;Free-form Prototyping, and You Can KeepandM;The Prototype!andM;This is one of those deceptive and infuriating assertions that in certaincircumstances might well be right -- but for all the wrong reasons.andP;  I'mreminded of a pre-Lego construction toy I had when I was six called&quot;Lock-A-Blox.&quot;andP;  It was a boxful of brightly-colored blocks, with slots on twofaces and tabs on the two opposite faces.andP;  All the tabs fit all the slots,and all block dimensions were always even multiples of the smallest.andO;Everything always fit together, no matter how you tried it.andP;  There were nowrong combinations, no embarrassing chinks or bulges where things didn'tquite fit.andM;Nonetheless, no matter what you built with it, from the Brooklyn Bridge tothe Eiffel Tower to Godzilla, your creation always looked like .andP;  .  .  abunch of Lock-A-Blox.andM;Rapid free-form prototyping is indeed possible in Smalltalk and Actor.andP;  It'sdone by taking instances of the hundred-plus object types in the standardclass library and hooking them together until things work.andP;  You stick menu Bbehind radio button A, and if they don't look quite right, well, pull themapart and try something else.andP;  There's no sense of loss in throwing away themenu because you didn't have to write the code to create the menu.andP;  It wasall there in the class library, like bubble-packed cold meat hanging on pegsin the refrigerator case down at Safeway.andM;You can very quickly get a series of menus and other screen controls togetherin Smalltalk or Actor, and if the prototype user interface isn't too messy,you have a reasonable chance of filling in the guts without having to abandonand rewrite the user interface.andM;There's a price to be paid:  Your application will be made out of pieceswritten by somebody else, and it will have a look and overall structuredictated by the shape of those pieces.andP;  This is not necessarily a bad thing,especially if you're sick of messing around with your own window manager codeand you are looking for a standard user interface.andM;That, however, is for Smalltalk and Actor.andP;  There is currently no massiveclass library in QuickPascal, Turbo Pascal, or Zortech C++.andP;  In Object Pascaland C++ you have to build your own Lock-A-Blox, with all the time, effort,and torn hair that that implies.andM;Duntemann's OOP Warning #3: TheandM;Quality of an OOP Prototype DependsandM;Utterly on the Quality of the StandardandM;Class LibraryandM;The bottom line of this rubber truth is that the ease of prototyping has lessto do with OOP than with a well-thoughtout library of prefab programcomponents.andP;  I've done some amazingly easy prototyping with Turbo PowerSoftware's Turbo Professional 5.0, and with a superb Modula-2 library productcalled &quot;Repertoire,&quot; all without object-oriented anything.andP;  OOP contributes alittle -- objects are more independent than traditional procedures andfunctions, and thus, they combine better and with fewer possible side effects-- but far less than most people think.andM;Turbo Pascal prototyping will be made lots easier once Turbo Power's ObjectProfessional library is finished and shipping.andP;  (This may well be the casenow, while you're reading this; though, while I'm writing, they still have aways to go.)andP;  And over time, such ambitious class libraries will become derigueur in all OOP languages, just as they have been in Smalltalk and Actorfrom day one.andM;Object-oriented programming is no magic pill.andP;  It does not allow effortlessprogramming of complex applications that work the first time and never break.andO;It does not make applications run faster, but if badly used can make them runslower.andP;  (In fairness to OOP, this is also true of most every programmingtechnique you could name.)andP;  Its benefits fall mostly to the programmer:Greater richness of expression in program design; greater potential to reusewell-designed program components; and greater ability to fix, change, andextend existing applications in a maintainable manner.andP;  From the outside, theprograms will look exactly the same.andM;The Parent TrapandM;I treated polymorphism in detail back in November, but it may be time to comeback and shed some light into some corners that have remained dark through itall.andP;  I lurk on CompuServe a lot, tallying the subjects people have troubleunderstanding -- that's an excellent place for professional explainers, likeme, to get their raw material.andP;  And whereas the broad concepts ofpolymorphism seem to be coming across, the details keep getting scrambled andmisconstrued.andM;Chief among these is the matter of polymorphic assignment compatibility.andP;  Inan object hierarchy, assignment compatibility is extended along a givenobject class' domain.andP;  This domain includes the class and all of itsdescendant classes, as shown in Figure 1.andP;  The shaded classes are the domainof class Arc.andM;The rule is this: An object can be assigned to any type &quot;rootward&quot; in itsdomain.andP;  (Let's not argue about &quot;above&quot; or &quot;below,&quot; because those wordsdepend utterly on how you draw the hierarchy.andP;  In Figure 1, the root of thehierarchy is at the top of the page).andP;  In other words, you could take aninstance of type Arc and assign it to an instance of type Circle:andM;MyCircle := MyArc;andM;Ordinarily, Pascal would call you down on type conflict grounds, and it stillwill, if you were to assign MyArc to something outside of its domain; say, toan instance of type Rectangle or Polygon.andM;One thing to remember that people too often forget is that the reverse is nottrue: You cannot assign a parent to a child.andP;  This won't compile:andM;MyArc := MyCricle;andM;Try to remember this key phrase: &quot;To the general assign the specific.&quot;andP;  Oneway to think of an object hierarchy is as a movement from the most generalabstract classes at the root to the most specific classes at the leaves.andP;  Ifyou'd prefer an earthier mnemonic, try this: &quot;You can hang a leaf on a root.andO;You can't hang a root on a leaf.&quot;andP;  Think of assigning the specific to thegeneral as hanging a leaf on the root.andM;Making the Compiler SwallowandM;PolymorphismandM;The whole idea behind extending assignment compatibility rootward through anobject's domain is to make polymorphism syntactically kosher to the compiler.andO;In a sense, polymorphism is the hiding of different classes behind the maskof a common ancestor class.andP;  The mask hides the differences between theclasses, and emphasizes those aspects the classes have in common -- in thiscase, the aspects defined in the common ancestor class.andM;In Figure 1, for example, Line, Rectangle, and Circle are all descended fromPoint.andP;  Point is literally all that the three have in common.andP;  Inside Pointthere is a pair of methods for displaying and erasing the object's graphicimage: Show and Hide.andP;  Inheritance causes Show and Hide to be passed downinto all of Point's child classes.andP;  The child classes, however, have theoption of redefining their own specific methods under the names Show andHide.andP;  A line is drawn differently from a circle, so Line.Show wouldnecessarily be different from Circle.Show.andM;Nonetheless, the method name and the general idea (to display a figure on thescreen) is the same for all the graphic object classes.andP;  So bring on themasks:andM;VAR Figures : ARRAY[1..3] OF Point; ACircle : Circle; ARectangle : Rectangle;ALine : Line;andM;.  .  .Figures[1] := ACircle; Figures[2] := ALine; Figures[3] := ARectangle;andM;FOR I := 1 TO 3 DO Figures[I].Show;andM;Here we have an array of type Point, to which we assign instances of Circle,Line, and Rectangle as we choose.andP;  Because Point is within the domain of allthree, extended assignment compatibility allows the compiler to accept theseassignments, even though they violate traditional Pascal strong typing.andM;Polymorphism enters the picture in the FOR statement, where we step throughthe array, calling the Show method belonging to each array element.andP;  Eventhough the elements of the array Figures are all nominally type Point, latebinding and polymorphism allow the Circle.Show method to be invoked forelement 1, the Line.Show method for element 2, and the Rectangle.Show methodfor element 3.andP;  Without extended assignment compatibility, the three graphicsfigure objects could never have been assigned to the array, and thepolymorphic method calls could never have happened.andM;The Parting of the PascalsandM;One (serious) catch.andP;  The syntax shown before doesn't work in Turbo Pascal.andO;It compiles correctly, but polymorphism won't happen.andP;  In other words, if youcompile the above code fragment under Turbo Pascal, the FOR statement willexecute Point.Show for all three of its array elements -- as if thepolymorphic assignments to the three descendant classes never took place.andM;This isn't a bug -- it's part of the spec.andP;  QuickPascal will compile and runcode like the example shown earlier.andP;  The two Object Pascals differsignificantly in their object philosophy (while agreeing in almost everythingelse), but the most fundamental difference between them is that allQuickPascal objects are allocated on the heap, whereas Turbo Pascal objectsmay be allocated either on the heap or (by default) in the data segment.andO;Turbo Pascal objects allocated in the data segment (static objects) andaddressed directly cannot take part in polymorphism.andM;Keep this in mind, always: Polymorphism is by nature a dynamic business, andis done through pointers.andP;  If an object is not accessed through a pointer, itwon't polymorph.andM;So how, then, does QuickPascal manage to make the example code above runcorrectly?andP;  It's an aspect of the between-two-worlds nature of objects inQuickPascal.andP;  When a QuickPascal object is declared, it's declaredstatically, just as any variable is:andM;VAR ACircle : Circle;andM;However, declaring a QuickPascal object is not enough.andP;  Before it can be used(actually, before it really exists) it must be allocated on the heap, viaNew:andM;New(ACircle);andM;Thereafter, the object can be referenced as though it were a static variable:andM;ACircle.Show;andM;No caret symbols here, even though ACircle exists entirely on the heap.andP;  In asense, QuickPascal objects are neither fully static nor fully dynamic.andO;They're just ...well...andP;  objects, that's all.andM;Behind the scenes, an apparently static reference to a QuickPascal objectreally is a pointer reference.andP;  The name of a QuickPascal object is in trutha pointer to that object on the heap.andP;  They've just done away with thefamiliar caret or &quot;up arrow&quot; pointer reference notation.andM;In Turbo Pascal, by contrast, an object is either fully static and exists inthe data segment, or is fully dynamic and exists on the heap and must beaccessed through the traditional pointer reference notation.andP;  A Turbo Pascalobject is best approached as a record with some special properties, and obeysall the rules a record would with respect to allocation and referencing.andM;Thus, when in QuickPascal, we assign object instances to an array of objectinstances, we're actually assigning object pointers to an array of objectpointers:andM;Figures[1] := ACircle; Figures[2] := ALine; Figures[3] := ARectangle;andM;Here, ACircle is actually a pointer to a block of memory on the heapcontaining the object's actual data and method table.andP;  Similarly, theFigure's array is in reality an array of pointers -- not whole objects.andP;  Ifwe had intended to use the elements of Figures without assigningalready-allocated objects to them, we would have had to allocate eachindividual element of Figures with the New statement:andM;New(Figures[1]); New(Figures[1]); New(Figures[1]);andM;This static/dynamic duality of QuickPascal objects (and Apple Pascal objectsbefore them) is a source of some serious confusion to newcomers.andP;  Best toremember: All QuickPascal objects are at the end of pointer references,whether it looks like they are or not!andM;Polymorphism Through PointersandM;Fortunately, both QuickPascal and Turbo Pascal objects can be manipulatedthrough explicit pointer references.andP;  And just as assignment compatibility ofobjects is loosened up within an object's domain, so is the assignmentcompatibility of pointers to those objects.andM;In other words, just as a Circle object may be assigned to a Point object, apointer defined as a pointer to Circle may be assigned to a pointer definedas a pointer to Point:andM;TYPE PointPtr = andless;Point; CirclePtr = andless;Circle;andM;VAR CircleHandle : CirclePtr; PointHandle : PointPtr;andM;....Pointhandle := CircleHandle;andM;In this situation, polymorphism will work with either compiler, usingidentical syntax.andM;The best way to show polymorphism through pointers is with a completeprogram.andP;  There's no substitute for loading up a piece of code and watchingit work before your eyes.andP;  Listings One and Two, page 158, are pretty muchthe same program, implemented as their particular compilers demand.andP;  ListingOne is the QuickPascal version, and Listing Two is the Turbo Pascal 5.5version.andM;The programs implement two object classes: Father and Son.andP;  Son is adescendant of Father.andP;  Both have methods named Talk, which displayappropriate text to the screen for each class.andP;  Father says one thing; Sonsays another.andP;  The main body of each program does three things:andM;1.andP;  Allocates and initializes three objects, Dad (of type Father), Twerp (oftype Son), and Person (also of type Father).andM;2.andP;  Attempts polymorphism through direct references.andP;  This works forQuickPascal and fails for Turbo Pascal.andM;3.andP;  Attempts polymorphism through pointer references.andP;  This works identicallyfor both compilers.andM;Assigning a son instance to a Father instance is done in both programs:andM;Person := Twerp; Person.Talk;andM;The method invocation will call Son.Talk in QuickPascal and Father.Talk inTurbo Pascal.andP;  Why?andM;Person and Twerp are both pointers beneath the skin of QuickPascal, andassining Twerp to Person only copies the Twerp pointer to the Person pointer.andO;This is easy and fast -- all pointers are the same size, 32 bits.andM;In the Turbo Pascal version, on the other hand, Person and Twerp are bothobjects in the data segment.andP;  They are of different sizes.andP;  Assining Twerp toPerson means moving physical data from one location in the data segment toanother.andP;  To avoid disrupting data beyond the bounds of Person, Twerp willhave to be truncated during the move -- because Twerp is larger than Person.andO;Data is lost, which is never a good idea.andM;If you look beneath the surface of the Turbo Pascal version, you'll find thatdata is moved from Twerp to Person, and that the Twerp.Girlfriend's field islost in the move.andP;  Person retains its identity as a Father object, however,and any call to a method in Person will invoke Father's methods rather thanSon's.andM;The key here is Person's link to the Virtual Method Table, which I describedin some detail in my November column.andP;  When Twerp is assigned to Person, allof Twerp's data is copied over Person's, but the VMT links are not involvedin the move.andP;  Person's VMT link remains intact, even after the assignmentoverwrites all of Person's data with Twerp's.andP;  Why?andP;  The VMT contains thesize of its object, returned by the Sizeof function and used internally byother aspects of the run-time library.andP;  Especially when you're dealing withstatically allocated data, you do not want to lose track of how big anindividual item is.andP;  Get it wrong during something as simple as anassignment, and you overwrite adjacent data.andM;In short, static data is no place for polymorphic fooling around.andP;  It's muchsafer on the heap, where you can throw pointers around instead of wholeobjects.andM;Much better to do it this way:andM;Link := @Dad; KidLink := @Twerp; Link := KidLink; Linkandless;.Talk;andM;Here, Link is a pointer to Father object Dad, and KidLink is a pointer to Sonobject Twerp.andP;  Assigning KidLink to Link can be done because Link's referentshares KidLink's referent's domain.andP;  And this time, specifying Linkandless;.Talkexecutes Son.Talk because polymorphism works through pointer references inboth QuickPascal and Turbo Pascal.andP;  No data is moved; once the assignmenthappens, Link points directly to Twerp, so Linkandless;.Talk executes Twerp's Talkmethod.andM;The Limits of PolymorphismandM;This is terrific stuff -- hiding the son behind a mask of the father.andO;There's a catch: The only object methods or data accessible throughpolymorphic assignment are those that the two involved classes have incommon.andP;  This is subtle, and causes a lot of head scratching during thelearning process.andM;Consider:  We've assigned a pointer to Twerp to a pointer to Dad.andP;  Now, canwe access a field specific to Twerp through that pointers?andP;  No!andM;Try adding this to either Listing Once or to Listing Two after the assignmentof KidLink to Link:andM;Writeln(Linkandless;.Girlfriends);andM;Now, Link points to a Son object, but the compiler will steadfastly claimignorance that the Girlfriends field exists.andP;  (Turbo Pascal will give youerror 44, and QuickPascal will give you error 60.)andP;  Hell, if we can accesstwerp's methods through Link, we should be able to access Twerp's fields!andO;And we can -- but only those fields that Twerp and Dad both have in common.andO;Type Father defines an Age field and Son inherits it, but Son defines aGirlfriends field that Father doesn't have.andP;  A pointer defined as pointing toa Father type (as Link is) can't access things (either methods or data) thataren't defined in type Father.andM;Why not?andP;  Well, loosening assignment compatibility rules doesn't meanthrowing them away entirely.andP;  Neither compiler is quite smart enough todeduce things across an assignment statement.andP;  Assigning a SonPtrto a FatherPtr doesn't change the fact that the FatherPtr is a FatherPtr in thecompiler's symbol table.andP;  When you try to access a field called Girlfriendsthrough a FatherPtr, the compiler checks the fields defined under type Fatherfor a field called Girlfriends and doesn't see it.andM;If you want to access Son-specific fields through a FatherPtr you'll have tohelp the compiler a little, with some &quot;Pizza Terra Typecasting.&quot;andP;  (See my May1989 column for an explanation of that peculiar reference ...)andP;  Try this ineither Listing One or Listing Two, again, after the assignment of KidLink toLink:andM;Writeln(SonPtr(Link)andless;.Girlfriends);andM;This time it works, both from a compile-time and a run-time perspective.andO;Casting Link (a FatherPtr) onto a SonPtr lets the compiler check and seethat, yes, there really is a Girlfriends' field associated with the pointerin question.andP;  All of the usual dangers of typecasting apply.andP;  As always, dowhat you must; just know what you're doing.andM;Typecasting used in this way kills the magic of polymorphism, in that whatwe're doing is peeking behind the Father mask to see the Son hiding there,and acting on that knowledge.andP;  Theoretically, we aren't supposed to know thetype of the object &quot;behind&quot; a polymorphic assignment.andP;  However, if we want tomake use of elements specific to the actual type of the object, peeking isour only recourse.andM;Typecasting your way around polymorphic type-blindness can get you out ofsome tight corners on occasion.andP;  One way to avoid typecasting is to migratefields and methods &quot;up&quot; the hierarchy so that all classes within a domainshare all fields and methods, even if the fields are not used and the methodsare empty in the more general classes.andP;  In our simple example, this wouldmean giving the Girlfriends' field to Father and letting Son inherit it, justas is done with the Age field.andP;  Better still, (and at the risk of sounding alittle too Eastern) let the son be a son while he is a Son, but when he isplaying Father let him leave his girlfriends at home ....andM;Programmer's Productivity PackandM;I'll never forget the rush of loading Sidekick for the first time back in1984, and seeing a calculator that worked in hex.andP;  No more fiddling on paperand machine gun bashing on my ancient SR10.andP;  Sidekick changed the way Iapproached certain things in programming, because there was no longer anyneed to avoid working in pure hex or even binary.andM;The notion of memory resident tools took off with Sidekick, but mostly towardthe users -- DOS shells to make picking files easier, things like that.andP;  It'snice to find an occasional TSR tool that won't do the users a damned bit ofgood.andP;  Such a one is Falk Data Systems' Programmer's Productivity Pack (PPP).andM;The PPP is a loose collection of useful gadgetry centering on a world-classprogrammer's calculator with four memories and a full set of bit-wise logicaloperators, including AND, OR, NOT, XOR, shifts, and rotates.andP;  The binarydisplay field allows you to set individual bits rather than enter 31 digitsjust to set the MSB to 1.andP;  Values are displayed simultaneously in binary,hex, decimal, and (gakkh!) octal.andM;The calculator is good, but the most innovative gadget in the PPP is a sortof empirical keyboard reference screen that displays the scan codes of anykey combination you can press on the keyboard.andP;  If you need to look up thescan code for a key combination, don't bother with a book; just press the keycombination -- and you'll get the scan code.andP;  As a bonus, attached to certainkey combinations are helpful notes indicating whether certain PC-family BIOSversions do or don't recognize a given key combination.andP;  Key code informationis also given for the dBase data base and dBase compatible languages such asClipper and QuickSilver, along with helpful notes such as pointing out thatdBase and friends consider the Ctrl-\ and F1 keys to be identical.andM;The shift and lock keys are also displayed as the bit patterns they reallyare.andP;  Beats thumbing through some tech ref manual any day.andP;  Other details areright on: Redefinition of PPP's several hotkey assignments, the ability tounload the utility from memory on command, an unusually readable manual, anda superb paper(!)andP;  ASCII code chart that I have framed on the wall beside themachine.andP;  There's more to it but I'm out of space at this point.andP;  Highlyrecommended.andM;Memory Hog HeavenandM;This is a good time to be a programmer.andP;  Tom Swan's newest book, MasteringTurbo Pascal 5.5 is on the streets; finally something good in print aboutobjects.andP;  Eighty nanosecond, 1-Mbyte SIMMS are down to about $125 if youshop; by the time you read this they could be at $100.andP;  You can get a 20-MHz386 system with 4 Mbytes of RAM for about $2500.andP;  With Windows/386 you canload Turbo Pascal, QuickPascal, PageMaker, and Paradox each into its ownvirtual-86 partition and carom from one to another like a rock off a canyonwall.andP;  Software development is more than just code; it's also data dictionarymanagement and documentation.andP;  With Windows/386, you can build your own dreamsystem for creating that ultimate app.andM;Good old days?andP;  We're here, guys.andP;  Really.andM;AvailabilityandM;All source code is available on a single disk and online.andP;  To order the disk,send $14.95 (Calif.andP;  residents add sales tax) to Dr. Dobb's Journal, 501Galveston Dr., Redwood City., CA 94063, or call 800-356-2002 (from insideCalif.) or 800-533-4372 (from outside Calif.).andP;  Please specify the issuenumber and format (MS-DOS, Macintosh, Kaypro).andP;  Source code is also availableonline through the DDJ Forum on CompuServe (type GO DDJ).andP;  The DDJ ListingService (603-882-1599) supports 300/1200/2400 baud, 8-data bits, not parity,1-stop bits.andP;  Press SPACEBAR when the system answers, type: listings(lowercase) at the log-in promt.andM;DDJandM;(Listings begin on page 158.)andM;Vote for your favorite feature/article.andP;  Circle Reader Service No.andP;  11.andO;</TEXT></DOC>