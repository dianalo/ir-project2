<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-169-172  </DOCNO><DOCID>07 169 172.andM;</DOCID><JOURNAL>Computer Language  April 1989 v6 n4 p45(6)* Full Text COPYRIGHT Miller-Freeman 1989.andM;</JOURNAL><TITLE>Reading and writing the DOS environment.andO;</TITLE><AUTHOR>Adams, Jon-K.andM;</AUTHOR><SUMMARY>The DOS environment holds information such as PATH and PROMPTsettings for programs to access while executing.andP;  Programs shouldbe able to communicate through DOS, sharing information stored inthe environment, but data can be manipulated only at the DOSprompt.andP;  If the DOS environment is located, data can be read fromit and written to it to allow the exchange of information betweenprograms, among other things.andP;  Five steps for locating the DOSenvironment are described and the three environment types arediscussed.andP;  Techniques for reading strings from and writingstrings to the environment by using memory arrays is presented.andM;</SUMMARY><DESCRIPT>Topic:     MS-DOSProgrammingConnectivityTutorialNew Technique.andM;</DESCRIPT><TEXT>Reading andamp; Writing the DOS Environment The function of the DOS environment isto hold information provided by the user for programs to access duringexecution.andP;  In most cases this means holding the PATH and PROMPT setting thatare read by the command processor.andP;  But since any program can readenvironment settings, the DOS environment can be put to other uses.andM;For example, the Microsoft Macro Assembler uses the environment parametersINCLUDE and MASM to get the directory of the include files and the user'sassemlber options.andP;  In addition, the command processor uses the environmentto pass variable to batch files.andM;In theory, the DOS environment can be used to communicate between programs.andO;But in practice, the environment does not live up to this potential becausethe data it holds can be manipulated only at the DOS prompt (with the SETcommand).andP;  Unlike many system features--from changing the current directoryto changing the shape of the cursor--no documented method exists for changingthe path or any other environment setting from within an executing program.andM;As far as our programs are concerned, DOS considers the environment aread-only device, which means that to read and write the DOS environmentdirectly from an executing program, we first need to find the location of theenvironment in memory.andP;  Once the DOS environment has been located, we canread data from and write data to it, change the path, pass variables to batchfiles, exchange information between programs, and even save one environmentto disk and load another one.andM;Locating the DOS environmentandM;The DOS environment can be located by first locating the resident portion ofCOMMAND.COM.andP;  When DOS is booted, COMMAND.COM is loaded in low memory; itsexact location depends on the size of the system files and device drivers (ifany) loaded before it.andP;  COMMAND.COM is allocated the first memory block, andafter it loads, it allocates a memory block to the DOS environment.andP;  Themethod for finding the environment is straightforward: get the address ofCOMMAND.COM and calculate the location of the environment from there.andO;Unfortunately, this method is complicated by two factors.andP;  The location ofthe DOS environment varies according to the version of DOS installed andwhether a secondary copy of COMMAND.COM is loaded.andP;  A revised synopsis of thetechnique for locating the environment, which takes into account both thecurrent and root environments and all versions of DOS (2.0-4.0), includesfive basic steps:andM;* Get the DOS version.andM;* Get the address of COMMAND.COM.andM;* Calculate the location of the current environment.andM;* Check for a secondary copy of COMMAND.COM.andM;* Makes adjustments according to the DOS version.andM;When COMMAND.COM loads a program, it first assigns it a 256-byte headercalled the Program Segment Prefix (PSP).andP;  A program's PSP has some usefulinformation, such as the address of the environment a program inherits.andO;This, by the way, is the inherited environment and is distinct from the DOSenvironment manipulated with the SET command.andP;  An undocumented feature of thePSP is that it also holds the address of the current COMMAND.COM's PSP atoffset 16 hex.andP;  The address of the program's PSP is predefined in TurboPascal v. 4 as PrefixSeg.andP;  With this address we can get COMMAND.COM's PSP byusing a memory array PSPaddr := MemW[PrefixSeg : $16];.andM;The memory array functions like a standard array except indexing is done bysegment and offset.andP;  In the previous example, the contents of the address aregiven in the index; that is, the address of COMMAND.COM's PSP is assigned tothe variable PSP addr.andM;At this point, we need to be aware of an exception: usually this addresspoints to the current COMMAND.COM's PSP, but it can point to the PSP of someother program that has used the Exec function to create a child process.andP;  Wecan check this by comparing the address at offset 16 hex with the PSPaddress.andP;  COMMAND.COM always holds the address of its own PSP at offset 16hex; other programs hold the address of the program that loaded them atoffset 16 hex: while (PSPaddr andless;andgt; MemW[PSPaddr : $16]) do PSPaddr :=MemW]PSPaddr : $16];andM;If one or more programs are loaded between our program and the currentCOMMAND.COM, the WHILE loop will continue until we have the address ofCOMMAND.COM's PSP.andP;  Once we have COMMAND.COM's PSP, we can calculate thelocation of the environment.andM;The paragraph above the PSP address is COMMAND.COM's Memory Control Block(MCB).andP;  We can calculate the location of the next MCB by getting the size ofCOMMAND.COM (in paragraphs) from bytes 3 and 4 in COMMAND.COM's MCB andadding it to the PSP address.andP;  The starting address of the environment is theparagraph following the environment's MCB: ComMCB := Pred(PSPaddr); MCBsize:= MemW[ComMCB : 3]; EnvMCB := PSPaddr + MCBsize; EnvAddr := Succ(EnvMCB);andM;Even though this does not give us the location of the environment for DOS v.andO;3.3 and 4.0, this information is still needed to check for a secondary copyof COMMAND.COM.andP;  But before we can do this, we need to know which type ofenvironment we are working with.andM;Three types of environmentsandM;There are three types of environments, depending on which DOS version isinstalled: DOS v. 2.0-3.1, DOS v. 3.2, and DOS v. 3.3 and 4.0.andP;  Threefeatures distinguish these versions: the information at offset 2C hex inCOMMAND.COM's PSP, the location of the root environment in relation toCOMMAND.COM, and the location of the environment when a secondary copy ofCOMMAND.COM is loaded.andM;In DOS v. 2.0-3.1, the address at offset 2C hex is either 0, which means wehave the root COMMAND.COM and the root environment is the MCB that followsCOMMAND.COM, or it contains the address of the secondary environment.andO;(Actually, it is more complicated than this: the secondary environment isabove COMMAND.COM, in the location of the inherited environment.andP;  In thisenvironment type, there is also a copy of the environment in the MCBbelowCOMMAND.COM, which is used as a scratch area when a program is being loaded.andO;When a program is unloaded, COMMAND.COM copies the inherited environment backover the scratch area.andP;  This is why we cannot read or write to thisenvironment.)andM;In this environment type, we check if the address at offset 2C hex is 0 and,if it is not, we need to reassign the environment address and search memoryfor the root environment: if (MemW[PSPaddr : $2C] andless;andgt; 0) then begin EnVAddr:=MemW[PSPaddr : $2C]; SearchMemory (RootEnVAddr, RootEnvSize); end;andM;In DOS V. 3.2, the environment location is similar to the earlier type,except the environment follows COMMAND.COM.andP;  This means offset 2C hex neverpoints to the DOS environment.andP;  In the root COMMAND.COM, the address atoffset 2C hex is 0, and when a secondary copy of COMMAND.COM is loaded, 2Chex points to the inherited environment that precedes COMMAND.COM, like theinherited environment of all other programs.andP;  This inherited environment doesnot interact with the secondary DOS environment located after COMMAND.COM.andO;Since we already have the address of the current environment, we only need tosearch for the root environment if the address at offset 2C hex indicatesthat a secondary copy of COMMAND.COM is loaded: if (MemW[PSPaddr : $2C] andless;andgt; 0)then SearchMemory(RootEnvAddr.andP;  RootEnvSize):andM;In DOS v. 3.3 and 4.0, the address at offset 2C hex always points to the DOSenvironment, even in the root COMMAND.COM, and the environment always followsCOMMAND.COM, except in the root version.andP;  Between the root COMMAND.COM andthe environment is a scratch memory block of three paragraphs that is similarto the scratch memory block in the first environment type.andP;  This informationis used to determine if we have the root COMMAND.COM or not.andP;  If the addressat offset 2C hex matches our calculated enviroment address, we have asecondary copy of COMMAND.COM and we have to search for the root environment.andO;Otherwise, we have the root COMMAND.COM and we need to reassign theenvironment address, which is the memory block after the scratch memoryblock: if (MemW[PSPaddr : $2C] &quot; EnvAddr) then SearchMemory (RootEnvAddr,RootEnvSize) else EnvAddr :=MemW[PSPaddr &quot; $2C]:andM;Although the different versions of DOS make locating the environment somewhatcumbersome, the changes in how the environment is handled suggested changesin the attitude toward its function.andP;  Beginning with DOS v. 3.2, the user isable to increase the size of the environment from the 160 bytes of earlierversions to 32K by using the SHELL command in the CONFIG.SYS file.andP;  Thisdramatic increase in size indicates an equally dramatic increase in theenvironment's potential usefulness.andP;  And beginning with DOS v. 3.3, locatingthe current environment becomes more direct.andP;  In other words, in using theenvironment to communicate between programs, there is no reason to feel weare trespassing on territory reserved exclusively for DOS.andM;Searching memoryandM;So far we have been able to locate the environment and determine if asecondary copy of COMMAND.COM is loaded.andP;  With the technique used here wealways locate the current environment, which is usually the root environment.andO;But when a secondary copy of COMMAND.COM is loaded, the current environmentis related to the secondary COMMAND.COM.andP;  In some cases, we may want to workspecifically with the root environment.andP;  For example, if we want to passinformation to the command processor, we must work with the currentenvironment, but if we want to pass information between programs, the rootenvironment offers more space.andP;  This presents a slight problem because thereis no secure way of working back beyond the current COMMAND.COM to find theroot COMMAND.COM.andP;  We have to use an indirect method in which we search forCOMMAND.COM in low memory.andM;One way to find the location of COMMAND.COM is to begin in low memory andsearch each paragraph boundary for the first allocated memory block.andP;  Oncethe first memory block is found, the location of the second memory block canbe calculated and from there, the location of the DOS environment.andP;  The MCBprovides three pieces of information.andP;  Byte 0 contains an ASCII &quot;M&quot; (4D hex)unless it is the last MCB, in which case it contains a &quot;Z&quot; (A5 hex).andP;  If theMCB has been allocated to a program, the next two bytes hold the address ofthe program's PSP.andP;  If it has not been allocated, these bytes (1 and 2)contain 0.andP;  The next two bytes contain the number of paragraphs that havebeen allocated to the memory block.andP;  With this number, the location of thenext MCB can be calculated.andM;(There are at least two exceptions to this: the address in bytes 1 and 2 ofthe environment MCB itself points to the PSP of the program to which itbelongs.andP;  The address in the scratch MCB can be one of three possibilities;0, COMMAND.COM's PSP address, or the address of the next unallocated block.)andM;All three pieces of information in the MCB are used to locate COMMAND.COM.andO;Beginning at 500 hex, each paragraph boundary is searched for an &quot;M.&quot;andP;  If oneis found, the next two bytes are compared with the address of the nextparagraph boundary.andP;  This comparison is to check for a match between the PSPaddress in bytes 1 and 2 of the MCB and the address of the paragraphfollowing the MCB.andP;  If a match is found, the next two bytes are used tocalculate the location of the second MCB.andP;  The size of the memory block (inparagraphs) is added to the PSP address, and if this points t an &quot;M,&quot; we canassume we have found the beginning of the memory control block chain.andP;  Fromthis point on, we use the techniques for determining the current environment.andM;Manipulating the environmentandM;The main reason for locating the environment is to read strings from andwrite strings to it.andP;  For this purpose, the environment can be thought of asa predefined array of characters and efficiently manipulated by using memoryarrays.andP;  The environment array holds information in the form of ASCIIZstrings: character strings terminated by a NUL character (0 hex).andM;Each environment string has two parts: a parameter, such as PATH, and avariable assigned to the parameter.andP;  When the SET command is used, DOSsearches the environment array for the parameter.andP;  If it is found, theenvironment string is deleted from its current position in the array.andP;  If theparameter in the SET command has a variable, the string is added to the endof the array.andM;Before manipulating the environment, it is necessary to determine whethertheenvironment is empty and, if not, to get the length of the environment array.andO;We need this length so we know where to put a string and so we do not writebeyond the end of the environment, which would cause a memory allocationerror.andP;  We determine whether the environment is empty by seeing if the firstcharacter is NUL.andP;  To find the end of the environment array, we use Position,a function similar to the Turbo POS except it finds the position of a stringin an array of characters rather than in another string.andP;  This means we needto pass the size of the environment as well as the address of the array andthe string we are searching for.andP;  The last environment string has a secondNUL character at the end, so to get the length of the environment array wesearch for #0#0.andM;Note how the NUL characters are used: if the environment array is empty, thesecond NUL character is at the head of the array, which means there may notbe any double NUL in the environment: if Mem[EnvAddr : 0] = 0 then ArrayLen:= 0 else ArrayLen := Position (#0#0, EnvAddr, EnvSize);andM;Since the first index position in the array is /, --1 is used to indicatethat a string has not been found.andM;Reading an environment stringandM;Reading a string from the environment requires two arguments: the environmentparameter and its variable.andP;  The Position function is used again to get thelocation of the parameter string in the environment array, except now thelength of the environment array is passed instead of the entire size of theenvironment.andP;  If the environment parameter is not found, the procedureReadEnvVar returns an empty string.andP;  Once the position of the parameterstring has been found, its corresponding variable can be read because we knowthat the variable begins after the equal sign and ends at the next NULcharacter: ParamPos := ParamPos + Length (EnvParam): VarPos := ParamPos;while Mem[EnvAddr : VarPos] andless;andgt; 0 do Inc(VarPos): Move(Mem]EnvAddr : ParamPos]EnvVar[1], VarPos-ParamPos); EnvVar[0] :=Chr(VarPos-ParamPos);andM;Writing an environment stringandM;Writing a string to the environment requires more work.andP;  If the environmentparameter is not found, we simply add the new environment string to the endof the array, making sure we still have two NUL characters at the end and wedo not write byond the end of the environment.andP;  If the environment parameteris found, we first delete the environment string from its current position inthe array, and then add the new string to the end of the array.andP;  If an emptystring is passed as the EnvVar argument, the environment string is simplydeleted.andP;  The Move procedure is used for both adding and deleting.andP;  In thecase of deleting, the second half of the array is moved over the string wewant to delete.andP;  In the case of adding, the string is moved to the end of theenvironment array: i := ParamPos; while Mem[EvrAddr : i] andless;andgt; 0 do Inc(i);Inc(i); Move(Mem[EndAddr:i],Mem[EndAddr: ParamPos],(ArrayLen+2)-1); ArrayLen:= ArrayLen - (i-ParamPos); if (ArrayLen + StLen + 1) andgt; EnvSize then Error :=2 else Move(EnvStr[1],Mem[EndAddr : ArrayLen+1],StLen);andM;Example code that illustrates these principles -- including a Turbo PascalEnv unit and programs to set up a simple DOS menuing system -- is availablefrom COMPUTER LANGUAGE's Bulletin Board Service and CompuServe forum.andO;</TEXT></DOC>