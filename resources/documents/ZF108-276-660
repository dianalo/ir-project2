<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-276-660  </DOCNO><DOCID>08 276 660.andM;</DOCID><JOURNAL>IBM Systems Journal  March 1990 v29 n1 p44(15)* Full Text COPYRIGHT International Business Machines Corp. 1990.andM;</JOURNAL><TITLE>Effective application development for Presentation Managerprograms. (tutorial)</TITLE><AUTHOR>Franklin, S.M.; Peters, A.M.andM;</AUTHOR><SUMMARY>The OS/2 Presentation Manager provides an integrated graphical,windowing user interface to IBM's OS/2 operating system.andP;  Thispaper addresses a primary area of interest for PresentationManager application developers: the use and development of usercontrols.andP;  A control in the Presentation Manager environment is aprogram object with a programming interface and applicationfunction.andP;  The structure and interfaces between controls and thesystem are described in order to provide an understanding of thecorrect procedure for programming the Presentation Managerefficiently.andP;  (Reprinted by permission of the publisher.)andM;</SUMMARY><DESCRIPT>Product:   OS (Presentation Manager (Graphical user interface)_usage).andO;Topic:     OS-2Graphical User InterfaceEnd UsersProgrammingTutorialApplications.andO;Feature:   illustrationprogramtable.andO;Caption:   Sample value set invocation by calling application. (program)Value set messages. (table)Value set input structure. (program)andM;</DESCRIPT><TEXT>Effective application development for Presentation Manager programs TheOS/2[TM] Presentation Manager[TM] provides an integrated graphical, windowinguser interface to IBM's OS/2 operating system.andP;  This paper addresses aprimary area of interest for Presentation Manager application developers: theuse and development of user controls.andP;  A control in the Presentation Managerenvironment is a program object with a programming interface and applicationfunction.andP;  The structure and interfaces between controls and the system aredescribed in order to provide an understanding of the correct procedure forprogramming the Presentation Manager efficiently.andM;With the introduction of a new generation of workstations and midrangecomputing systems, IBM has made several key strategic announcements which setthe direction for both IBM products and applications developed for IBMsystems.andP;  Systems Application Architecture[TM] (SAA[TM]) and its end-userinterface component, Common User Access (CUA), define how a system andapplications running on it interact with an individual at a terminal.andP;  [1] Cooperative processing requirements among IBM's Personal System/2[R](PS/2[R]) workstations, midrange systems, and large systems and IBM's plan tostandardize user interfaces across hardware product lines have given the PS/2workstation the key role in end-user interface support.andP;  The primary userinterface component of the PS/2 multitasking operating system, OperatingSystem/2[R] (OS/2[R]), is the Presentation Manager[TM] which gives the user awindowed, graphical interface.andP;  [2]  The Presentation Manager is thesystem-supplied CUA end-user interface tool that provides access to the filesystem, system services, and applications.andP;  Also available from IBM is aprogrammer's toolkit which allows application developers to develop new,graphically based applications.andM;User who interact with multiple applications are more productive in theirwork if the user interface is consistent across applications.andP;  [3]  Thisstatement becomes increasingly true as cooperative processing requirementscontinue to grow and application developers build applications designed formultiple systems environments.andP;  To make applications consistent with oneanother, each application needs to follow a set of rules regulating theinterface consistency.andP;  [4]  Adhering to such rules is particularly importantwith the incorporation of a graphical user interface such as the PresentationManager.andP;  The sophisticated capabilities of the Presentation Manager havepromoted the growth of advanced user interaction styles and techniques andmake the requirement for a user interface definition all the more important.andO;[5]  CUA is IBM's solution to achieve this consistency for SAA-conformingapplications.andP;  [3]  Application sets may choose, as well, to follow morestringent conformance definitions.andM;As application developers implement many of these new concepts, the need fora consistent set of both graphical and text user interface services forapplications styles and techniques and make the requirement for a userinterface definition all the more important.andP;  [5]  CUA is IBM's solution toachieve this consistency for SAA-conforming applications.andP;  [3]  Applicationsets may choose, as well, to follow more stringent conformance definitions.andM;As application developers implement many of these new concepts, the need fora consistent set of both graphical and text user interface services forapplications styles and techniques and make the requirement for a userinterface definition all the more important.andP;  [5]  CUA is IBM's solution toachieve this consistency for SAA-conforming applications.andP;  [3]  Applicationsets may choose, as well, to follow more stringent conformance definitions.andM;As application developers implement many of these new concepts, the need fora consistent set of both graphical and text user interface services forapplications be integrated into existing applications if they are to remaincompetitive.andP;  To provide for consistency in the user interface and forevolution, these services should be implemented in such a way that they areeasily reusable and can be modified and extended without the changingexisting program code.andP;  [6]andM;This paper discusses a strategy for providing such sets of services, orbuilding blocks, referred to in Presentation Manager terminology as controls,which allow a consistent approach to end-user interface development.andP;  Acontrol under the Presentation Manager is a user interface element with aunique programming interface and application function.andP;  Examples ofsystem-supplied controls are menus and dialog boxes.andP;  Clearly, any attempt tostandardize application development should not restrict the usage of theunderlying system capabilities.andP;  Application-defined controls in no wayinhibit any of the sophisticated capability of the Presentation Manager orthe designated manner in which developers implement programsandgt; allPresentation Manager function remains available to an application.andO;Application developers can, in fact, enhance the existing function bydeveloping controls for specific program purposes.andP;  Control can also bestructured so that the burden of change is isolated from the application andlocalized within the control, thus promoting an object-oriented design.andM;Making application-developed controls available has been a system designapproach used in the development of IBM's OfficeVision/2[TM] by theApplication Solutions Division.andP;  This product is a set of SAA-compatible,CUA-compliant applications that form an electronic office for system users.andO;The programs exploit the capabilities of the Presentation Manager and at thesame time provide a tool set that minimizes development effort, enforces userinterface consistency, and maximizes code reusability.andP;  Interface consistencygives developers the flexibility to make internal control changes as CUAdevelops.andM;This paper explores the concept of application-developed controls byexamining Presentation Manager-supplied controls and the design and structureof application-developed controls.andP;  We discuss how controls are used byapplications and how developers can design and develop additional controls.andO;We highlight aspects of our experience in control development and discussfuture requirements for building controls as the Presentation Managerevolves.andM;Presentation Manager user controlsandM;The Presentation Manager implements a windowing interface by passinguser-generated input events to underlying windows displayed on a workstationdisplay screen.andP;  An input event is translated into a message and sent to thewindow procedure that processes input for a specific window.andP;  For example, ifa user positions a mouse pointer over a button window and clicks the mouse,the window-processing procedure for the button window class receives amessage indicating that a particular button has been selected on the screenby the user.andM;A control is a special kind of window.andP;  When a control is created, it is aninstance of that special window class.andP;  Some controls are predefined by thePresentation Manager such as the title bar, iconic maximize and minimizearrows, menus, sizing borders, push buttons, scroll bars, and text entryfields.andP;  These types of controls are the basic user interface building blocksfor Presentation Manager applications.andP;  A typical application consists of aframe containing an application-specific window known as the client window.andO;The frame window itself consists of multiple controls such as the title bar,maximize and minimize icons, menus, sizing border, and scroll bars.andP;  Figure 1shows an example of a frame window made up of frame window controls and theclient window.andP;  The application selects the desired controls that make up theframe window at its creation.andP;  Each of these controls receives and processesmessages from user-generated input events.andM;A window class definition is analogous to a definition for a new data type,just like a data-type class in an object-oriented language.andP;  [7]  Windowclass definitions describe class-unique data and specify the processingintelligence for the window class by indicating the window procedure forprocessing the class.andP;  The window procedure defines how the control appearsto the user and is responsible for &quot;painting&quot; the control on the displayscreen.andP;  The procedure also defines how the control responds to user inputbecause it processes the user's input, which comes to the control in the formof a message.andM;A simple example will help to illustrate how using controls impacts thestructure of a Presentation Manager program.andP;  Suppose it is necessary for anapplication to display selection input fields such as the button selectors inFigure 2.andP;  The user indicates the desired action by positioning the cursorover the button selected and clicking the mouse.andM;The application could implement a button by drawing the oval outline for abutton and displaying the text inside the outline.andP;  Whenever the applicationreceives input from the mouse, the application could check to determine ifthe mouse was positioned over the oval when the mouse was clicked, and if so,process the command indicated by the text for the button.andP;  In this situation,the application creates and processes each button separately.andM;Instead, each button is defiened as a &quot;control&quot; having particular buttoncharacteristics.andP;  The application creates the button by using theWinCreateWindow function call of os/2, which specifies the size of thebutton, the text to appear in the button, and the location of the button.andO;The WinCreateWindow function passes an application-defined amount ofinformation to the new control when it is created, therefore allowingdetailed information about button color, text fonts, etc., to be specifiedwhen the button is created.andM;Since the button is a predefined window class, the application need not drawthe button.andP;  Instead, the window procedure of the button &quot;paints&quot; the button.andO;When the user selects a button, it is the button control that receivesnotification that the button was selected.andP;  The button control then sends amessage back to the application program indicating that it was selected.andP;  Touse buttons the application must only create the button with a singlefunction call and accept notification when the button is selected.andP;  Thecontrol handles the mouse and graphics processing.andP;  [7]andM;The advantages of implementing the button as a control increase as therequirements for using buttons grow more complex.andP;  Consider that theapplication may be set up so that buttons are to be used in various parts ofthe application which require different forms of processing.andP;  It may benecessary for the application to use buttons both in the client window of theapplication and in dialog boxes.andP;  Client windows are normally createddynamically by the application program.andP;  Dialog boxes are normally createdimplicitly by defining the dialog box in an application resource file,including the components of the dialog box, which in this case includes abutton control.andP;  If the button control is specified in the applicationresource file as part of the dialog box, the Presentation Managerautomatically creates the button within the dialog box.andM;Further, the requirements for buttons may change after the application isdeveloped, or different forms of buttons may be required in differentcomputing environments.andP;  For example, a button might need to have both ashort and a long form of text inside of the button, or possibly a variableshape.andP;  These changes are located within the button control without having animpact on the application program.andM;We have already shown how the components of the frame window, exclusive ofthe client area, are primarily a collection of controls supplied by thePresentation Manager.andP;  Below we propose the same methodology within theclient window based on an application-specific hierarachy of controls.andO;Reusable, consistent program components can be structured and provided tocalling applications as publicly defined window classes and then used as acontrol.andP;  Each component that is implemented as a control, regardless of itscomplexity, provides the same benefits for an application as the samplebutton control previously described.andP;  A control initializes itself, processesrelevant information within itself, and interacts with the application with aminimal amount of messages.andP;  Changes and evolution within the sphere of acontrol are encapsulated within the control itself, making the remainder ofthe application immune from change occurring within the control.andM;To illustrate the point, Figure 3 and Figure 4 are examples of a relativelycomplex application which is implemented by constructing the application as acollection of basic controls.andP;  The purpose of the example application is toallow the user to define the colors and various screen components ofPresentation Manager.andP;  Virtually every object on the screen is a predefinedcontrol supplied to the application from a previously existing source.andP;  InFigure 3 the frame window entitled &quot;Control Panel&quot; consists of a title bar,iconic minimize control, nenu, scroll bar, and text input and outputcontrols.andP;  When the user selects Preferences-Screen colors ..., the dialogbox control labeled &quot;Screen Colors&quot; in Figure 4 is displayed, which consistsof the same title bar, menu, scroll bar, and text input and output controls,as well as list, button, and window sizing controls, along with anapplication-defined color selection display control.andM;Not only does this example show how a relatively complex application isquickly implemented through the use of existing control components, but it isalso an excellent illustration of how controls are able to provide userinterface consistently.andP;  A new application, which provided an exact mockup ofthe user interface that the user can see and adjust, is created usingexisting user interface controls.andP;  This example provides a substantial amountof complex function in a consistent manner by simply specifying whichcontrols are to be displayed and processing simple sets of messages sent toit by each of the controls.andP;  The controls handle most of the processing,without any involvement by the application.andP;  Of course, not every portion ofan application can or should be structured into a control, but controls are asolution for those application segments that normally would be structured ina procedural manner.andM;This concept can be extended to broad categories of applications.andP;  Within theoffice application several loosely coupled collections of data objects makeup a substantial set of the office programs such as mail boxes, filecabinets, fild drawers, and folders.andP;  Each of these programs keep track ofand maintains both similar and diverse sets of objects that have a commonuser interface format.andP;  This style is a list graphics-based iconicrepresentations of the objects within the collection.andP;  The exact style of thelist is dependent on several criteria, including application requirements anduser preferences.andP;  For example, the office window, which provides access tothe office application set (Figure 5), is displayed in two distinct styles,one listed vertically and the other as a user-adjustable matrix.andM;To achieve user interface consistency, we decided that the user interface foreach office application should be base on a common set of functions.andP;  We knewwithin the development cycle that our user interface would be developed in aniterative fashion in conjunction with substantial human factors testing andwould therefore be subject to considerable change thoughout development.andO;Development costs could soar unrealistically if every applicatioh within theproduct set was obligated to &quot;understand&quot; the intricacies involved indeveloping the graphical interface for the entire set of applications for theproduct.andM;Accordingly, we implemented the primary user interface components ascontrols.andP;  Figure 5 shows two instances of the office window using the samecontrol to produce different variations of the iconic interface.andP;  Thiscontrol also provides other office programs with a simple interface for theirown graphical user interface componentsandgt; each application programmer need notunderstand the complexities of the graphical iconic interface.andP;  As changessurfaced and the user interface evolved, we changed only the controls thatdid not involve individual applications.andP;  This strategy ensured thatindividual application philosophies were superseded by those of theapplication set as a whole.andP;  These controls also make it possible for non-IBMdevelopers to build applications that run as part of Office Vision/2 and havethe same user interface as the IBM-supplied applications which make up theoffice system.andM;An example user controlandM;As illustrated previously, it is possible for an application to providesubstantial function simply by using system-supplied controls.andP;  When thesecontrols are not appropriate for a specific task, the application developermay implement the unique requirement as a &quot;user control.&quot;andP;  If the code isstructured so that the function is packaged as a unique window class, thecontrol may be used in many different places throughout the application, aswell as in other applications.andP;  In developing an application control, thelogic and data of the control must be structured and maintained such thateach instance of a control maintains its own set of specific data, whileresponding to user interaction in a consistent manner.andM;We will create a user control called &quot;value set&quot; as an example of the use anddevelopment of application controls, but first, we explore the requirementsfor the value set control.andM;Function of a value set controlandM;Often, the user of an application must make a selection from among a list ofgraphical elements.andP;  The Presentation Manager has controls for choosing itemsfrom lists of words.andP;  The value set control provides a mechanism fordiscrete, single selections depicted by icons, text, numeric values,patterns, or color.andP;  When a program requires the user to make a visual,single selection choice, a value set may be used to provide the interactionand selection.andM;For example, consider an application that displays a dialog box prompting theuser for a color selection.andP;  This choice could be depicted using PresentationManager buttons labeled &quot;red,&quot; &quot;white,&quot; and &quot;blue,&quot; but the value set couldalso present this choice by displaying a palette containing red, white, andblue items.andP;  Use of the value set in this situation provides a more visualchoice and may save valuable screen area.andP;  [8].andP;  It also eliminates thenecessity of translating text as the product is developed for foreigncountries.andP;  Figure 6 shows a dialog box containing several different stylesof value sets.andM;Application users may interact with the value set by using a mouse, keyboard,or a combination of both.andP;  When using the mouse, the user selects an item bypointing to it and clicking with the mouse button.andP;  The value set controlnotifies its owner with a message whenever one of its items is selected ordeselected.andP;  It also provides visual feedback of the selection state bydrawing a heavy black line around the value set selection.andP;  The user maydeselect items by clicking a second time, or by clicking on another item.andM;Use of the keyboard to navigate through the value set requires informationabout the current cursor position.andP;  When a value set receives attention fromthe keyboard, it reflects both the current selection and the current cursorposition.andP;  The cursor position is indicated with a broken line drawn aroundthe value set item.andP;  (See &quot;Pie&quot; in the &quot;Chart&quot; value set in Figure 6.)andP;  Asthe user navigates through the value set items using the cursor keys, thebroken outline follows.andP;  When the desired selection is reached, the Enter keyis used to select the item.andP;  If the user presses Enter a second time, theitem is deselected.andM;Although implementation of the value set selection mechanism could beundertaken as an application supplied function, it would not facilitate codereuse.andP;  Other applications with similar requirements would have anindividualized implementation of the value set which could result indifferent, perhaps confusing, interaction styles among similar functions.andP;  Bystructuring the value set function as a control, the function may be reusedthroughout the application and in many related applications.andM;User control invocationandM;The two primary requirements of an application program in creating a usercontrol are to register the window class for the control and create thewindow.andP;  Each control is an instance of a particular window class.andO;Registration tells the operating system what window procedure to call when awindow of that class receives a message.andP;  Registration also specifiesparameters such as storage requirements and the actions that the operatingsystem is to perform when moving or sizing operations occur on that window.andO;Once a window class has been defined to the operating system throughregistration, the program can create as many controls of this specific classas necessary.andM;Once the window class has been registered, the application creates thecontrol by issuing a WinCreateWindow call specifying this class.andP;  With thevalue set serving as the example, it can be seen that the application issuesthe WinCreateWindow using the registered class of ValueSet.andM;Four basic types of information must be passed when the control is invoked:andM;1.andP;  Information describing the ownership and parentage of the control.andP;  Thisinformation is necessary in defining the messaging matrix to the system forcommunication between the owning window and the subordinate controls.andM;2.andP;  Size information during the creation of the control.andP;  This informationcan be omitted at creation time and dynamically supplied by the applicationwhen the control is displayed.andM;3.andP;  Application-specific parameters.andP;  In the value set, these parametersdescribe the row and column structure of the items within the control.andM;4.andP;  System-required parameters.andP;  Applications must supply identification (ID)for a window, identifying the control to the operating system.andM;When a window is created, the operating system returns a unique windowidentifier to be used by the application in communicating with the control.andO;This identifier is called a window handle.andM;Figure 7 shows the sample calling sequence for invoking a value set.andM;General requirements for user controlandM;implementationandM;Although the implementation of a specific Presentation Manager user interfacecontrol will vary depending on the requirements, there are general guidelinesfor implementing a control.andP;  Successful development of a control begins byunderstanding the general characteristics and the skeletal structure of acontrol.andP;  This template can then be expanded to include the specificfunctional requirements of the control.andM;Message handling.andP;  From an implementation viewpiont, a control is nothingmore than a specialized window class which is expected to field certainmessages and return the expected values.andP;  The internal structure of a controlis simply a window procedure.andP;  There is no main program or invoking routineandgt;these tasks are performed by the application creating the control.andP;  Thefunctionality of a control is determined simply by the types of messages thatare accepted.andM;A control generally accepts two types of messages: window messages predefinedin the Presentation Manager and new messages defined by the control.andP;  Asubset of the former group is fielded by all controls.andP;  For example, thecontrol must always be prepared to redraw its contents when the WM_PAINTmessage is received.andP;  Likewise, the contents of the control may need to berepositioned or resized when the WM_SIZE message is encountered.andP;  WM_CREATEprocessing gives the control a chance to initialize data and set up storageblocks, whereas the WM_DESTROY message is the appropriate time to release allresources allocated for the control.andP;  Beyond these four messages, thespecific purpose of the control determines what additional system windowmessages (such as WM_BUTTON1DOWN) or specific control-defined messages mustbe fielded.andM;The value set control processes system messages such as WM_BUTTON1DOWN andWM_CHAR in order to determine mouse and keyboard navigation and selection.andO;The remaining messages fielded by the value set are control-specific.andP;  Thecontrol provides a message set that allows the application developer todynamically add, delete, and alter selection items in the value set control.andO;The text and graphics inside the value set items may also be queried.andP;  Table1 summarizes the value set messages.andM;Control parent and owner relationships.andP;  In addition to fielding certainmessages and returning values, controls often post messages when certainspecified events occur.andP;  The value set generates messages as an item isselected or deselected.andP;  Notification messages are posted to a window knownas the owner of the control, the owner being specified during creation of thecontrol.andP;  The only logical relationship between a control and its owner isthe fact that notification messages are posted to the owner.andP;  It is theparent of the window that determines positioning of the control.andP;  The parentand owner may be the same window but do not necessarily have to be.andP;  Forexample, Figure 8 shows an application which has placed the value set controlinside a dialog box.andP;  In this case, the dialog box is the parent of thecontrol, although the client window will receive notification messages andact on selections that occur within the dialog box.andP;  In order to receivenotification messages, the client window of the application is specified asthe owner of the control.andP;  The role of the parent and owner with respect to acontrol is often muddled by control implementations.andP;  A simple rule is thatall outgoing messages from a control are posted to the owner.andP;  There shouldnever be any reason for a control to communicate with its parent.andM;Control status and instance data.andP;  Since a user interface control is aresource made available to all applications, a control cannot make anyassumptions regarding its origin.andP;  For example, the control may be invokedseveral times by the same application or by many different applications.andO;Associated with each invocation of a control is a particular state.andP;  Forexample, each value set contains a certain number of items positioned inparticular locations within the control.andP;  Data which describe suchinformation are called instance data and must be stored such that eachindividual instance of a control can access its instance data at all timesduring execution of the control.andM;Storage of instance data can be accomplished by storing a pointer to the datain a Presentation Manager window word.andP;  During class registration, anapplication may specify a specific amount of data to be reserved for eachinstance of the window class.andP;  These data block, or window words, areaccessible through a standard Presentation Manager application programinterface (API) call.andP;  Given any window handle, the Presentation Manager canreturn a pointer to any of the requested window words.andP;  The window class ofthe value set is registered with an additional four bytes of window word datain order to maintain and access instance data.andP;  This window word is requestedin the last parameter of class registration as illustrated in Figure 7.andP;  Itis used to hold a long pointer to the instance data block of the control andmay be accessed at any time during execution of the control.andP;  Since one ofthe parameters to a window procedure is the handle of the window receivingthe message, there is no confusion as to which invocation of the control isexecuting.andP;  This handle may be used to access the pointer to the correctinstance data block.andM;With use of this design approach, each value set control has a standardfour-byte window word that points to its unique instance data block.andP;  Thesize and contents of the instance data block will vary widely in differentcontrols.andP;  In the value set this block contains information concerning thenumber of items present, the size of the items, the presentation format ofthe items, and pointers to the data concerning each individual item.andP;  Thecontents of the instance data block are likely to change as the developeriterates on the implementation of a user interface control.andP;  These iterationshave no effect on any other applications, since the instance block pointerremains the same.andM;Control input structure.andP;  Each user control generally has a specialized datastructure which is used by the application to supply information regardingthe objects in the control.andP;  The value set defines a VALUEITEM structurecontaining the text and graphics that comprise an element in the value set.andO;Figure 9 illustrates the VALUEITEM structure.andP;  A primary goal of the valueset implementation is to provide a flexible set of input formats for thegraphical data, so that the supplying application may use any drawing methodto enter the graphics.andP;  Figure 10 shows a client window which has two valueset controls containing graphics in raster and vector format.andP;  The value setaccepts graphics as both bitmaps and drawing orders deposited into a memoryblock.andM;Bitmaps are a commonly used input format for standard Presentation Manageruser interface controls such as buttons and menus.andP;  Bitmaps provide a fastmechanism for drawing graphics, but they are very device-dependent.andP;  Bitmapsmay change somewhat in size and appearance, depending on the particularhardware display device that is being used.andP;  However, they provide a simpleway for applications to load or create graphics and pass them to a control.andO;The value set provides two methods for supplying bitmap data.andP;  First, abitmap handle created by the system may be supplied.andP;  This method is used bythe menu and button controls.andP;  An application utilizes system calls to load abitmap from resources ro to create one dynamically.andP;  The system returns aunique handle describing the bitmap.andP;  This handle may be used within the OS/2process that created the bitmap but may not be shared with other processes.andO;since an application and its control execute in the same process, this formatis usually acceptable.andP;  However, in some cases it may be necessary for theapplication to use graphical data supplied by another independentapplication.andP;  To facilitate the input of bitmaps received from outsidesources, the value set also accepts bitmpas in a raw format consisting of aPresentation Manager BITMAPINFOHEADER structure which describes the bitmpafollowed by the actual bit settings for each pixel.andP;  In this case, the valueset generates its own private bitmap handle.andM;Applications may provide graphics in a format that is independent amongdevices.andP;  In such a case, the Presentation Manager Graphical ProgrammingInterface (GPI) may be used to generate drawing orders that describe thepicture in vector format, as opposed to the raster image described bybitmaps.andP;  The standard Presentation Manager controls do not accept drawingorders as inputs.andP;  If applications are to utilize the GPI interface to drawcontrol items, they must explicitly request that the control notify theapplication when the item is to be drawn.andP;  This method is called OWNERDRAW.andO;If a control item is set with the OWNERDRAW style bit, the owning applicationwill receive a message every time the item must be painted.andP;  The applicationis provided with a presentation space for drawing and a description of thesize and location of the item and may then use the GPI interface or any otherpreferred drawing APIs to draw the item.andP;  This method requires that theapplication process the WM_DRAWITEM message in order to draw any item asowner-drawn.andM;The value set expands the notion of owner-drawn items by providing an inputformat which consists of drawing orders written into memory.andP;  The applicationmay draw its control item into a presentation space and then usesystem-supplied calls to write the drawing orders to memory.andP;  These drawingorders are then saved by the control and re-executed each time that the itemmust be drawn.andP;  By using this input format, the application need only drawthe item once and pass it to the control.andP;  When redrawing is necessary, thecontrol executes the stored drawing instructions, rather than requestingtheat the application redraw the items.andM;Keyboard su pport.andP;  an y function provided by a user interface control mustbe accessible through a keyboard as well as a mouse.andP;  Although actions suchas selection or direct manipulation may seem more natural using a mouse, thecontrol must provide equivalent function for the keyboard user.andP;  This impliesthat the control instance data block must contain information concerning thecurrent cursor position along with other status data.andP;  Even if the items inthe control have no real logical ordering, the control must order the itemssuch that keyboard navigation permits access to all of the objects in acontrol.andM;User control expansion.andP;  Understanding the basic guidelines in designing andimplementing a user control is the first step in developing application codewhich can be shared and reused.andP;  Once the basic structure for a control isdesigned, the function of the control may be extended by processing a greaternumber of messages and adding information to its instance data or inputstructure as application requirements change.andP;  These changes can be madewithout dramatically altering the original structure or the processingperformed by the control.andP;  If the control message interfaces and inputstructures remain stable, applications may obtain expanded function withoutany modification.andM;Concluding remarksandM;Our development of controls for the IBM office environment product has provedto be a successful method for both propagating consistent user interactionrequirements throughout all components of the office system and reducing theprogramming effort for the individual applications.andP;  The development ofspecific controls as well as the use of the system-supplied controlsencapsulates very specific functional requirements into specialized objectsthat can be used by all applications that are a part of the officeenvironment.andP;  The user is presented with a visual interface that behavesconsistently across office components, and the application programmerbenefits from the availability of these controls when designing andprogramming an office application.andM;As workstation interaction techniques continue to mature, the need for userinterface consistency across applications will become increasingly important.andO;Definition of a uniform interaction style is the framework for thisconsistency.andP;  However, this definition is no guarantee of conformance unlesstools are developed that enable an application to conform to user interfacedefinitions while preserving the freedom of the application.andP;  Controls serveas flexible application enabling tools by providing programs with a set ofuser interface building blocks for application development.andP;  Properlystructuring our controls allows us to take a first step toward anobject-oriented application programming interface by hiding the data andinternal control processing mechanisms and surfacing only a message set tothe applications.andP;  The object-oriented approach to Presentation Managerapplication development can be expanded by developing base classes of controlobjects upon which can be built more specialized controls that inheritbehavior from the base classes.andM;We have seen how the implementation of application function as user controlshas many practical advantages.andP;  In addition, the evolution of controlstowards objects in an object-oriented environment provides an opportunity forcontinuing research and development in the use of design of PresentationManager controls.andP;  Controls may be designed and implemented not only as aindividual building blocks for specific application function, but asintegrated sets of objects related in a hierarchical fashion and sharingcertain levels of behavior.andM;AcknowledgmentsandM;The authors wish to acknowledge the support of Sandy Cureton, Bill Braley,and Dorene Palermo in writing this article.andP;  We also acknowledge NancyJackson, Tony Temple, Ellen Cohen Sonenthal, and Art Goldstein for theirsupport of the Office Vision/2 Presentation Manager platform.andP;  We extendspecial thanks to Dave McGehe, Randy Black, and Dan Kardell for their helpwith the manuscript and to Mark Estes for his programming efforts.andM;OS/2, Presentation Manager, Systems Application Architecture, SAA, OperatingSystem/2, and Office Vision/2 are trademarks, and Personal System/2 and PS/2are registered trademarks of International Business Machines Corporation.andM;Cited referencesandM;[1.] E. F. Wheeler and A. G. Ganek, &quot;introduction to Systems ApplicationArchitecture,&quot; IBM Systems Journal 27, No.andP;  3, 250-263 (1988).andM;[2.] M. Vellon, &quot;OS/2 Windows Presentation Manager: Microsoft Windows on theFuture,&quot; Microsoft Systems Journal 2, No.andP;  2, 13-18 (May 1987).andM;[3.] R. E. Berry, &quot;Common User Access--A Consistent and Usable Human-ComputerInterface for the SAA Environments,&quot; IBM Systems Journal 27, No.andP;  3, 281-300(1988).andM;[4.] S. Uhlir, &quot;Enabling the User Interface,&quot; IBM Systems Journal 27, No.andP;  3,306-314 (1988).andM;[5.] S. Franklin and T. Peters, &quot;Graphical Interface Services for ApplicationIntegration,&quot; Graphics Interface '89 Proceedings, Canadian InformationProcessing Society and Canadian Man-Computer Communications Society (June1989), pp.andP;  105-112.andM;[6.] B. Cox, Object-Oriented Programming Productivity Products International,Inc., Sandy Hook, CT (1986).andM;[7.] C. Petzold, &quot;Object Oriented Programming,&quot; PC Magazine 8, No.andP;  1,317-324 (January 17, 1989).andM;[8.] Systems Application Architecture Common User Access Advanced InterfaceDesign Guide, SC26-4582, IBM Corporationandgt; available through IBM offices.andM;General referencesandM;D.andP;  M. Chess and M. F. Cowlishaw, &quot;A Large-Scale Computer ConferencingSystem,&quot; IBM Systems Journal 26, No.andP;  1, 138-153 (1987).andM;W.andP;  P. Dunfee, J. D. McGehe, R. C. Rauf, and K. O. Shipp, &quot;Designing SAAApplications and User Interfaces,&quot; IBM Systems Journal 27, No.andP;  3, 325-347(1988).andM;S.andP;  Franklin and T. Peters, &quot;A Technical Study of Dynamic Data Exchange UnderPresentation Manager,&quot; Microsoft Systems Journal 4, No.andP;  3, 1-16 (May 1989).andM;EL Iacobucci, OS/2 Programmer's Guide, McGraw-Hill, Inc., Berkeley, CA(1988).andM;&quot;IBM Operating System/2,&quot; IBM Personal System/2 Seminar Proceedings 5, No.andO;5, 32-45 (May 1987).andM;IBM Operating System/2 Internals Volume 2: Presentation Manager, IBMInternational Technical Support Center, Boca Raton, Florida (1988).andM;IBM Operating System/2 Version 1.1 Programmer's Toolkit, Part No.andP;  6280211,IBM Corporationandgt; available through IBM branch offices.andM;IBM Operating System/2 Version 1.1 Technical REference, Part No.andP;  6280212,IBM Corporationandgt; available through IBM branch offices.andM;&quot;IBM OS/2 Standard Edition Version 1.1, IBM Operating system/2 Update,Presentation Manager (Part 1),&quot; IBM Personal System/2 Seminar Proceedings 6,No.andP;  1, 13-62 (april 1988).andM;&quot;IBM OS/2 Standard Edition Version 1.1, Presentation Manager (Part 2),&quot; IBMPersonal System/2 Seminar Proceedings 6, No.andP;  2, 2-41 (April 1988).andM;M.andP;  S. Kogan and F. L. Rawson III, &quot;The Design of Operating System/2,&quot; IBMSystems Journal 27, No.andP;  2, 90-104 (1988).andM;C.andP;  Petzold, &quot;The Graphics Programming Interface: A Guide to OS/2Presentation Spaces,&quot; Microsoft Systems Journal 3, No.andP;  3, 9-18 (May 1988).andM;C.andP;  Petzold, &quot;OS/2 Graphics Programming Interface: An Introduction toCoordinate Spaces,&quot; Microsoft Systems Journal 3, No.andP;  4, 23-40 (July 1988).andM;C.andP;  Petzold, Programming the OS/2 Presentation Manager, Microsoft Press.andO;Redmond, WA (1988).andM;K.andP;  Welch, &quot;Creating User-Defined Controls for Your Own WindowsApplications,&quot; Microsoft Systems Journal 3, No.andP;  4, 54-66 (July 1988).andM;K.andP;  Welch, &quot;Inter-Program Communication Using Windows' Dynamic DataExchange,&quot; Microsoft Systems Journal 2, No.andP;  6, 13-23 (November 1987).andM;Susan Franklin  IBM Application Solutions Division, 5 West KirkwoodBoulevard, Roanoke, Texas 76299.andP;  Ms.andP;  Franklin is a senior associateprogrammer who joined IBM in 1987.andP;  She received a B.S.andP;  degree in computingscience from Texas Aandamp;M University at College Station in 1987.andP;  Since joiningIBM, she has worked at the ASD Software Development Laboratory in Westlake,Texas, in user interface design and platform development of Office Vision/2.andO;Ms.andP;  Franklin has received two Invention Achievement Awards and oneOutstanding Technical Achievement Award for her work in enhancing OS/2interapplication data transfer techniques.andM;Tony Peters  IBM Application Solutions Division, 5 West Kirkwood Boulevard,Roanoke, Texas 76299.andP;  Mr. Peters is a senior programmer who has been withIBM since 1982.andP;  He received a B.S.andP;  degree in mathematics and computerscience from the University of Tennessee at Nashville in 1977 and an M.S.andO;degree in computer science from the University of Tennessee at Knoxville in1979.andP;  Prior to joining IBM, Mr. Peters was a member of the technical staffat Bell Telephone Laboratories in Naperville, Illinois.andP;  From 1982 to 1984,he was a project leader on the UNIX[R] development effort in Dallas, Texas.andO;In 1984 and 1985 he was on international assignment in Boblingen, Germany,where he worked on the IX/370 project.andP;  Since 1986, he has been working onthe Office Vision/2 project in the Westlake ASD laboratory.andP;  Mr. Peters hasreceived five Invention Achievement Awards and two Outstanding TechnicalAchievement Awards for his work in developing the OS/2 Dynamic Data Exchange(DDE) protocol for the OS/2 Presentation Manager and for his work on theOffice Presentation Manager user interface platform.andO;</TEXT></DOC>