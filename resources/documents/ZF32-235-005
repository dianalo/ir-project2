<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO> ZF32-235-005 </DOCNO><DOCID>10 364 242</DOCID><JOURNAL>UNIX Review  Feb 1991 v9 n2 p66(3)* Full Text COPYRIGHT Miller Freeman Publications 1991.andM;</JOURNAL><TITLE>By the pricking of my thumbs. (comparison of C and FORTRAN;outlook for computer languages)(C Advisor) (column)</TITLE><AUTHOR>Allman, Eric.andM;</AUTHOR><SUMMARY>FORTRAN's history is analagous to Unix's and C's.andP;  C and Fortranwere both developed by one person, and incompatabilities emergedwith later versions, which tended to accumulate new featureswithout deleting old ones.andP;  The next step in the developmentprocess is standardization.andP;  The next group of languages will beobject-oriented.andP;  Although Candplus;andplus; is not fully object-oriented, itwill probably dominate the Unix arena.andP;  In the future, systemsconversions will take place incrementally, thus making itdifficult for new languages to gain popularity.andP;  To succeed, a newlanguage would have to be better than those currently available;it will have to be able to coexist with current systems; and itwill have to be cheap, easily licensed, and available on a varietyof architectures.andM;</SUMMARY><DESCRIPT>Topic:     OutlookC Programming LanguageFORTRANComparisonProgramming SupportObject-Oriented Languages.andM;</DESCRIPT><TEXT>As you may have noticed, this magazine has been undergoing some changes informat and editorial policy.andP;  Surveys of readers have revealed that theywould be better served by including more &quot;how to&quot; articles.andP;  As you have nodoubt noticed, some long-time &quot;background information&quot; columns have beendeleted in favor of product reviews and the like.andM;This space has always provided a contrast to the rest of the magazine,providing concrete, current material where the editorial copy was involvedwith futures.andP;  Indeed, the success of this column has encouraged themanagement to change the format of the magazine.andP;  However, in keeping withthe tradition of contrast, this month's column will provide some of my musingabout the future of C, and to a certain extent about UNIX itself.andM;I promise that I won't feel this departure necessary in future columns.andM;C: the FORTRAN of the 80s?andM;A  few days ago, I was reading a comparison of UNIX to FORTRAN, Ill passed tome by Jeffrey Haemer of Interactive Systems (and of Usenix &quot;snitch report&quot;fame) .andP;  I like the analogy, which extends to C. Like C, FORTRAN wasinitially designed and implemented by one person (Dennis Ritchie and JohnBackus, respectively).andP;  The languages were small and simple, and thedocumentation described the state of the compiler as it was, not as it mightbe someday.andP;  They actively modified the language as they gained experiencewith it, and new versions were in some cases incompatible with olderversions.andP;  For example, between FORTRAN 11 and FORTRAN IV the syntax of I/Ostatements changed; initial versions of C would allowandM;int i 0;andM;which was later changed to require an equal sign:andM;int i andequals; 0;andM;These incompatibilities kept the number of users of the language small.andM;Later, the user base got larger, and incompatible changes created ever moreproblems.andP;  The tendency was to add new features without deleting oldconstructs.andP;  In many cases this was easy and clean: adding union didn'tdisturb struct, and file static variables slipped in cleanly.andP;  Some thingswere easy, albeit slightly less clean: casts didn't break anything bythemselves, but the stricter automatic coercion rules that casts permittedbroke lots of old programs (probably deservedly so) .andP;  Similarly, theaddition of enum was easy, but the semantics are rather messy: for example,given the declarationandM;enum color-t andlsqb; red, green, blue andrsqb; color; there should be a printf format thatwould print &quot;red&quot; rather than &quot;O&quot;.andP;  It's also not clear what the (legal)statementsandM;color andequals; green andplus; blue;andM;color /andequals; 2;andM;should mean.andP;  But this is what happens when you incrementally enhance alanguage without doing a complete redesign.andM;The Committee ComethandM;In any case, it was too much to hope that the committees could keep theirfingers out of a juicy pie like a popular programming language for too long.andO;in the cases of FORTRAN and C, standardization eventually became a buzzword.andO;At this point I'd best not speak further of FORTRAN, since the last time Iused that language extensively was long before the days of FORTRAN 77.andM;Please don't interpret my comments as meaning that I believe thatstandardization is wicked, or even unnecessary.andP;  I may disagree with somedetails of ANSI C, but I believe deeply in the necessity of standardization.andO;Too many fine points of the language were not actually defined, relyinginstead on oral tradition.andP;  Given the wide variety of platforms availabletoday, this is simply not an option.andP;  It is true that, to a certain extent,standardization stifles creativity; however, there is also a time to stopworking on the language itself and start writing the literature.andP;  (StanKelly-Bootle will doubtless point out the dialectic flaw in this analogy,noting that in writing Macbeth, Shakespeare modified the language.andP;  Try toignore him.)andM;But time marches forward; people cannot resist making changes in the name ofprogress.andP;  Brian Kernighan couldn't resist creating Ratfor,andlsqb;2andrsqb; Stu Feldman inturn gave the world EFL (Extended FORTRAN Language),  andlsqb;3andrsqb; and BjarneStroustrup hacked C into Candplus;andplus;.andP;  Despite the claim that &quot;C is retained as asubset andlsqb;of Candplus;andplus;andrsqb;,&quot; andlsqb;4andrsqb; Candplus;andplus; will not compile all C programs.andP;  Again we have acreative jump that abandons complete compatibility in favor of innovation.andO;Candplus;andplus; retains the same history: originally designed by one person, severalversions evolved until eventually the basic structure was fixed.andP;  The nextstep-standardization-is next.andM;The FutureandM;It's fairly clear that the next wave of languages will be object-oriented.andO;In the UNIX arena, Candplus;andplus; will probably be the hot language for a while, despitethe fact that it really isn't completely object-oriented.andP;  What Candplus;andplus; reallydoes is attach procedures to structures and supports structure inheritance.andO;However, basic types (such as int) are not objects: you cannot subclass themand they cannot receive messages.andP;  Thus, you can't create a subclass of intthat is a subrange, as you might like to completely implement the enum type:a complete implementation would restrict the values to the defined set ofconstants, and would not allow you to, say, add a color to a shape.andP;  (You cancreate a class with a single member, giving you almost the same thing.)andM;Object-oriented languages are usually either compiled or interpreted.andP;  Candplus;andplus; iscompiled, while Smalltalkandlsqb;5andrsqb;, (in some sense the grand daddy ofobject-oriented languages) is interpreted.andP;  Other compiled object-orientedlanguages include Objective Candlsqb;6andrsqb; and Eiffelandlsqb;7andrsqb; Compiled languages aretypically more run-time efficient, but interpreted languages are often moreflexible.andM;Like Candplus;andplus;, Objective C extends the C language.andP;  To my taste the attempt fails,since the objective constructs are based on Smalltalk syntax.andP;  The result isreminiscent of Professor Michael Stonebraker's description of embedding adatabase sublanguage into C: &quot;it's like gluing an apple to a pancake.&quot;andO;However, some people like this result-Objective C is the language of choiceon the Next workstation.andM;Eiffel doesn't try to extend any existing language.andP;  Loosely based on someearlier designs, such as CLU and Alphard, Eiffel uses a much more rigorousprogramming model.andP;  For example, Eiffel routines can include a require clausethat is essentially an assertion about what must be true before the routineis called, and an ensure clause that asserts what will be true when theroutine finishes execution.andP;  Besides providing better debugging (the compilercan insert code at the prologue/epilogue to check these clauses and make surethat things are behaving properly), the optimizer can use them to producemore efficient code.andP;  Eiffel also provides true exceptions in the language,unlike C or Candplus;andplus;.andM;Smalltalk is interpreted (actually, it is compiled &quot;on the fly,&quot; that is, thecompiler is linked in at runtime) .andP;  This makes it excellent for rapidprototyping.andP;  Programmers can drop into the editor during execution,modifying routines even while they are running.andP;  New object types can beadded without a compile/link session, which can be very nice forsophisticated, dynamic user interfaces.andM;I don't actually expect any of these to become the next hot language, for thesimple reason that they are al licensed, and hence have failed to reach acritical mass audience.andP;  In comparison, FORTRAN was available on virtuallyall machines of the time, and C soared with the success of UNIX, both beingfairly freely available in the early days when the minicomputer market wasexploding.andM;It seems to me that the push towards &quot;open systems&quot; will prevent any completeupheaval in the market.andP;  For example, in the not-so-good old days, convertingfrom an IBM 1401 to an IBM 360 required changing hardware, most peripherals,the operating system, and most application programs; even the COBOL compilersspoke different dialects.andP;  Today, this sort of transition would beunthinkable.andP;  Future innovation will be a piece at a time.andP;  For example, thetransition to FDDI networking will not require you to dump UNIX or C orFramemaker.andP;  The bad news is that it will make it hard for a new language toget a foothold.andM;Compiled languages are particularly difficult to move, since they require anew code generator for each architecture.andP;  The trend is toward a modularcompiler technology, so that different front ends (that is, thescanner/parser for a language) can be &quot;plugged in&quot; to the back end (the codegenerator) .andP;  However, there is no standard for the front-end/back-endinterface, which will stifle new languages.andP;  In contrast, there is a standard(well, actually several standards) for the compiler/linker interface; oldersystems used to treat this as an internal interface.andP;  As a result, it wasquite common to be unable to link modules written in different languages.andO;Why would you want to link Pascal to FORTRAN, anyway?andM;In short, I can imagine a new language appearing, but it would have tosatisfy several requirements.andP;  First, it would have to substantially betterthan what we have today.andP;  Personally, I think that exception handling is tooweak in C or Candplus;@, and the declaration syntax is pretty grotesque, but thesearen't good enough reasons to switch.andP;  Second, it will have to coexist withthe existing systems, including cross-linking.andP;  Third, it will probably haveto be widely available-that is, cheap, easily licensed, and supported on awide variety of architectures.andP;  The only group extant today likely to satisfythis requirement is the Free Software Foundation.andP;  A new language front endto the GCC code generator would give them many platforms very quickly, andthey are not adverse to giving things away, unlike IBM, DEC, HP...andP;  Thelanguage would probably be developed at a University somewhere, using the GCCcode generator, and then freely released with the GNU distribution.andP;  Beyondthis I am unwilling to speculate.andM;It is worth noting that there is no particular reason to believe thatlanguages will remain text-oriented.andP;  A fair amount of work has been done onvisual programming languages: &quot;programming&quot; using a graphics editor.andO;Considering that it wasn't all that long ago when few terminals even hadlower-case letters, a language that required a bitmap display to programisn't out of the question.andM;My mother warned me about gazing into crystal balls.andP;  Let's hope she waswrong.andM;Eric Allman works on the Mammoth project at the University of California atBerkeley and is active in the Usenix Association.andP;  Previously, he worked atthe International Computer Science Institute, Britton Lee Inc., and on theINGRES project at the University of California.andP;  During his first incarnationat Berkeley, he authored sendmail, the -me macros, the sccs front end, andsyslog, among other contributions to BSD.andP;  He had the dubious pleasure ofchanging all the andequals; andplus; operators in INGRES to andplus;andequals;.andM;ReforencesandM;andlsqb;1andrsqb; Jeffrey S. Haemer, Shane P. McCarron, and Peter H. Salus, &quot;Trends in UNIXSoftware,&quot; to appear in COMPCON Spring 1991.andM;andlsqb;2andrsqb; B. W. Kernighan, &quot;Ratfor-A Preprocessor for a Rational Fortran,&quot; BellLaboratories Computing Science Technical Report #55.andM;andlsqb;3andrsqb; S. I. Feldman, &quot;The Programming Language EFL,&quot; 1979, reprinted in UNIXProgrammer's Manual Supplementary Documents 2 (4.3 BSD edition).andM;andlsqb;4andrsqb; Bjarne Stroustrup, The C4-andplus; Programming Language, Reading, MA:Addison-Wesley, 1986, p. 3.andM;andlsqb;5andrsqb; Adele Goldberg and David Robson, Smalltalk-80-The Language and itsImplementation, Reading, MA: Addison-Wesley, 1983.andM;andlsqb;6andrsqb; Brad J. Cox, Object-oriented programming-An Evolutionary Approach,Reading, MA: Addison-Wesley, 1986.andM;andlsqb;7andrsqb; Bertrand Meyer, Object-oriented Software Construction, New York: PrenticeHall, 1988.andO;</TEXT></DOC>