<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-102-862  </DOCNO><DOCID>07 102 862.andM;</DOCID><JOURNAL>Communications of the ACM  March 1989 v32 n3 p374(8)* Full Text COPYRIGHT Assn. for Computing Machinery, Inc. 1989.andM;</JOURNAL><TITLE>Technical correspondence. (letters to editor)</TITLE><AUTHOR>Pleasant, James C.; Paulson, Lawrence; Cohen, Avra; Gordon,Michael; Bevier, William R.; Fetzer, James H.; Clune, Thomas R.;andO;Savitzky, Stephen; Smith, Michael K.; Young, William D.andM;</AUTHOR><DESCRIPT/><NOTE>Only Text is presented here; see printed issues for graphics.andO;</NOTE><TEXT>Technical CorrespondenceandM;The Very Idea The article &quot;Program Verification: The Very Idea&quot; by James H.andO;Fetzer [5] does a disservice to the cause of the advancement of the scienceof programming by belaboring the rather obvious fact that programs which arerun on real machines cannot be completely reliable, as though advocates ofverification though otherwise.andP;  It is unfortunate that, even though Fetzermakes some good points, including his analysis of the bad arguments againstverification given by De Millo, Lipton and Perlis [3], the center stage ofthe (Fetzer) article is occupied by an attempt to establish thatandM;&quot;Algorithms, as logical structures, are appropriate subjects for deductiveverification.andP;  Programs, as causal models of those structures, are not.andP;  Thesuccess of program verification as a generally applicable and completelyreliable method for guaranteeing program performance is not even atheoretical possibility.&quot; (p.andP;  1048)andM;Few knowledgeable people would disagree with the first sentence of thisthesis, assuming the commonly understood meanings of the terms involved.andO;Fetzer spends a major part of his article establishing an argument for thesecond sentence, essentially by pointing out that empirical evidence is aprerequisite for concluding that a program which is run on a real machine hasa degree of reliability.andP;  Again, who would disagree?andP;  Yet Fetzer hammers onthis point repeatedly, e.g.,andM;&quot;...  if the function of a program is to satisfy the constraints imposed byan abstract machine for which there is an intended interpretation withrespect to a physical system, then the behavior of that system cannot besubject to conclusive absolute verification but requires instead empiricalinductive investigation to support inconclusive relative verifications.&quot; (pp.andO;1059-1060)andM;In examining the third sentence of Fetzer's thesis, it is important to knowthe sense in which he intends the word &quot;porgram.&quot; Even though the authorgives various interpretations of this term ((i)-(iv), p. 1058), he does notmake clear which interpretation he has in mind when he concludes on p. 1062thatandM;&quot;In maintaining that program verification cannot succeed as a generallyapplicable and completely reliable method for guaranteeing the performance ofa program, De Millo, Lipton and Perlis thus arrived at the right generalconclusions for the wrong specific reasons.&quot;andM;Presumably the phrase &quot;guaranteeing the performance of a program&quot; refers toexecution of the program on a real machine, in which case the statement isobviously true, but has little implication regarding the applicability orvalue of deductive verification methods.andP;  It is unfortunate that the phrase&quot;generally applicable&quot; is not explained.andP;  The value of the deductiveverification methods will surely have been demonstrated if they are shown tobe useful in connection with verifying a respectable subset of the algorithmswhich humans find to be of interest.andP;  There is,in fact, ample evidence thatsuch is already the case.andP;  The publication of loop invariants, for example,to verify that loops do what they should (see, e.g., [4], pp.andP;  39, 44, forexamples of their use in a book devoted to something other than programmingmethodology) is a useful activity which can aid immensely in providingevidence that an algorithm is correct.andP;  Whereas the programmer whofinds aloop invariant often spends a great deal of effort in the process, once oneis found, it is available for all who desire confirmation of the correctnessof the loop.andM;It might be argued that the first two sentences of Fetzer's thesis, takentogether, mean that it is reasonable to apply deductive verification methodsto an algorithm, but one should not apply such methods to an encoding of analgorithm in a programming language, i.e., a &quot;program.&quot;andP;  The weakness of thispoint of view is, first of all, its artificiality, particularly in view ofthe narrow margin, if any, which sometimes separates the two.andP;  Moreimportantly, in the common situation in which the &quot;program&quot; corresponding toan algorithm contains numerous details which are no only implicit in thealgorithm, surely we should not, as a matter of course, ban the use ofdeductive methods in connection with verifying these details.andM;Concerning Fetzer's speculation as to the applicability of deductive methodsin connection with complex systems, it would clearly be incorrect to assumethat such methods cannot be used for at least some parts of the work.andP;  It isalso unfortunate that Fetzer's article, by indicating support of theconclusions of the De Millo, Lipton and Perlis article (even though thearguments are judged to be bad), may be taken as upholding views which theearlier authors chose to express in such terms as their concern about the&quot;poverty that does, we fear, result from infatuation with formal logic&quot; (p.andO;275), and the following:andM;&quot;We wish we could report that he [C.A.R.andP;  Hoare] thereupon threw up his handsand abandoned verification, but no such luck.&quot; (p.andP;  278)andM;Surely, in addition to there being a great need for programmers to forgeahead, using intuition and (when better methods are not available) &quot;patches,ad hoc constructions, band-aids and tourniquets, bells and whistles, glue,spit and polish ...&quot; ([3], p. 277), there is a need for theoreticians torefine our understanding of the theoretical basis of programming, inparticular, and computer science, in general.andP;  Without this continuingeffort, the word &quot;science&quot; would not be justified as part of the name of thissubject and the most severe poverty of all would be the result.andM;In fairness, both the Fetzer and the De Millo, Lipton and Perlis articleshave discussed important issues relative to the question of whether or notverifiability should be a &quot;dominating concern in software design&quot; ([3], p.andO;279).andP;  Both articles emphasized the fruitlessness of the &quot;pursuit ofperfection when perfection cannot be realized&quot; ([5], p. 1062).andP;  There is, ofcourse, the question of whether the whole approach to programming might needto be changed (see, e.g.andP;  [1]), possibly resulting in a basic alteration ofthe relative difficulty involved in program development and verification.andP;  Asthese questions are pursued, let us not be too quick to dismiss theimportance of achievements stockpiled along the way.andP;  James C. PleasantDepartment of Computer and Information Sciences East Tennessee StateUniversity Johnson City, TN 37614andM;Fetzer (&quot;Program Verification: The Very Idea&quot;) makes one important butelementary observation and takes it to an absurd conclusion.andP;  His point isthis: a computer systems involves physical components that can behaveunpredictably, so no deductive argument can guarantee that the system willwork perfectly.andP;  For example, a verified Strategic Defense Initiative (SDI)system could fail disastrously.andM;Practically everyone would accept that this is obvious.andP;  But most systems,unlike SDI, do not need to work perfectly.andP;  A system can fail for tworeasons: physical (say, wear and tear) or logical (say, a design error in aprogram or circuit).andP;  A physical fault can usually be repaired quickly,replacing the damaged part; then the job can be run again.andP;  A logical faultis often impossible to repair; the job must be modified or abandoned.andM;Fetzer claims that verification is useless because it cannot guaranteeperfection.andP;  Even our proofs are not perfect, for humans and theirverification tools are fallible.andP;  But research shows that formal methods,including formal specification and verification, do locate logical faults atthe design stage--before they can cause harm.andM;Remarks like &quot;most real software tends to consist of a lot of error messagesand user interfaces&quot; (p.andP;  1055) reveal the extent of Fetzer's ignorance.andP;  Healso refers to theorem-proving programs as &quot;an intriguing prospect&quot; (p.andO;1061), seemingly unaware of the many theoremproving programs and theiraccomplishments.andP;  Fetzer has condemned a subject of which he knows nothing.andO;Lawrence Paulson Avra Cohen Michael Gordon University of Cambridge ComputerLaboratory Pembroke Street Cambridge, CBZ 3QG EnglandandM;James Fetzer's article &quot;Program Verification: The Very Idea,&quot; thoughpresented as ostensibly careful philosophical analysis, distorts the practiceand goals of program verification.andP;  The purpose of Fetzer's paper is twofold:first, to claim that the very idea of program verification is misconceived,and second, to explain why DeMillo, Lipton and Perlis's justification for asimilar conclusion is wrong.andP;  Fetzer does a service in pointing out (onceagain) flaws in DeMillo, Lipton and Perlis's argument, but a profounddisservice in reviving their conclusion.andP;  His critique is predicated upon afundamental misunderstanding about the nature of program verification.andM;Fetzer argues as follows:andM;1.andP;  The purpose of program verification is to provide a &quot;completely reliablemethod for guaranteeing the performance of a program&quot; (p.andP;  1049).andM;2.andP;  This is impossible.andP;  The fundamental reason is the distinction betweenalgorithms (abstract machines) and executions (encodings of algorithmsexecuted by a machine, which Fetzer refers to as programs).andP;  A theorem whichmay hold for an algorithm cannot provide an absolute guarantee of thebehavior of an execution.andM;3.andP;  &quot;There is little to be gained and much to be lost through fruitlessefforts to guarantee the reliability of programs when no guarantees are to behad.&quot;andM;The strong implication is that program verification is a useless, if notharmful, activity.andM;Fetzer's argument misrepresents the goals of program verification.andP;  Hereasons from a false premise.andP;  The purpose of program verification iw not toprovide an absolute guarantee of correctness with respect to the execution ofa program on hardware (while the quote from Hoare on p. 1052 seems to implyhis view, the quote on p. 1059, from the same aritcle, explicity statesotherwise).andP;  Despite his explicit denial, Fetzer is attacking a straw man.andM;Program verification is not an attempt to put computer science on the samefooting as mathematics, but to put it on the same footing as any scientificdiscipline in which Mathematics is used to make predictions about thebehavior of physical phenomena.andP;  The goal of research in program verificationis to discover techniques for mathematically describing an algorithm so thatconclusions drawn from formal deduction predict the behavious of execution ofthe algorithm on a physical machine with a high degree of accuracy.andP;  The moreclosely one can mathematically tie the algorithmic description to theexecution, the more one can depend on the predictive power of themathematical analysis.andM;Fetzer seems to be unaware of work in program verification in which the aimis to bridge the gap between algorithms and executionS.andP;  There has been muchrecent interest in the formal description and verification of hardware andsystems software, such as compilers and operating systems.andP;  A high leveldescription of an algorithm can be formally realted to its interpretationwith respect to a formal description of hardware.andP;  A mathematical descriptionof hardware at the gate level would reduce the algorithm/execution gap to thepoint where only the relation between the gate description and the physicalproperties of silicon would be subject to Felzer's distinction.andP;  And whereasit is true that physical gates do not always behave as their mathematicalcounterparts--for example, the formalism does not account for suchcontingencies as Luddite antiverificationists with hammers smashing the gatesto bits--the semantic gap is sufficiently small to render Fetzer's objectionsinconsequential.andP;  To deny any relation between, say, a physical AND gate andthe corresponding boolean function is to deny that there can be any usefulmathematical model of physical reality.andP;  This is tantamount to asserting theimpossibility of physical science.andM;Fetzer condludes that since program verification provides no certainty, it isuseless and possibly harmful.andP;  Carried to its logical conclusion, thisposition vitiates any attempt to improve the quality of programs.andP;  Ifverification cannot guarantee reliability and is therefore useless, whatabout testing?andP;  Why test programs, given that testing clearly does notguarantee reliability?andP;  Because of the inevitable semantic gap betweenalgorithms and executions, no amount of careful coding can guarantee programcorrectness.andP;  So why code carefully?andP;  Program verification, like softwareengineering techniques and careful testing, does not promise certainty, onlya technique for enhancing the reliability of programs.andP;  Most researchersconsider this a useful goal.andP;  Fetzer's all-or-nothing argument is simplypointeless in the context of the real goals of program verification andsoftware engineering in general.andM;Fetzer need not worry about the application of program verificationtechniques to complex systems like SDI, only about their misapplication.andO;Danger lurks in the claim that software can be verified with absolutecertainty.andP;  Such a claim can lead to false security.andP;  But no intellectuallyhonest application of program verification would result in such a claim.andM;We believe that Fetzer's article contributes to a gross misunderstanding ofthe nature of program verification.andP;  Fetzer promotes the view that programverification purports to provide absolute certainty.andP;  This is false.andP;  Thegoal of program verification research is to make it possible to make highlyaccurate predictions about the behavior of programs running on computers.andP;  Weare far from that goal at present, but we believe that progress can be madeto improve upon the current state of affairs in software reliability.andO;William R. Bevier Michael K. Smith William D. Young Computer LogicIncorporated 1717 W. Sixth Street Austin, TX 78703andM;In &quot;Program Verification: The Very Idea&quot; James Fetzer's careful orchestrationof the distinctions between syntax and semantics, algorithm and program, andabsolute and relative proof to elucidate what is and what is not provable inprogramming was clear and cogent.andP;  The essential correctness of hisassessment is well-indicated by the state of current practice in computerscience and software engineering.andP;  Increasingly, publication of a newalgorithm is accompanied by a proof of correctness, while proving programsremains a fever-dream of computer scientists and the Department of Defense.andM;However, I believe that Fetzer's assessment of DeMillo, Lipton, and Perlis isunnecessarily harsh.andP;  In particular, I take exception to his suggestion that&quot;...their position, in part, rests upon a difference in social practice thatcould change if program verifiers were to modify their behavior&quot; (italicsadded).andP;  His assumption seems to be that anything that is not necessary isaleatory.andP;  In fact, I would contend that social practice can provide anindication of, if not proof of, the underlying formal condition that Fetzercharacterizes, just as people were able to use levers long before Archimedesexpressed the principle upon which they worked.andM;It seems to me that Fetzer has uncovered the structural bedrock thatunderlies the great divide between the practice of computer science andsoftware engineering.andP;  While we may be able to imagine a possible world inwhich map makers withhold their ink orders until the four-color problem issolved, or mathematicians are awarded grants on the basis of who promises tosolve the problem with the fewest colors, we would be hardpressed to imaginea plausible world with such constraints.andP;  Conversely, we may be able toconjure up a possible world in which upper management cares not a whit aboutthe greater market share that comes from being first to market with asoftware product, or where end users would gladly wait an extra six months toa year for a correct product rather than being able to start work now with a&quot;substantially correct&quot; product, but such a world strains our credulity.andM;The point is that the concern of computer science is process, while theconcern of software engineering is product.andP;  This is a direct, social,manifestation of the distinction between syntax and semantics upon whichFetzer bases his formal analysis of the differences between algorithms andprograms.andM;All of this has an interesting reverberation in an ongoing Forum controversyinspired by Eric Weiss.andP;  For me, one of the most interesting parts of Weiss'&quot;Commentaries On The Past 15 Years&quot; [Communications, Oct. 1987, pp.andP;  880-883]was his noting in passing some &quot;.andP;  .  .  decline in the influence ofacademics in ACM and a rise in the proportion of practitioners among the ACMleaders.&quot;andP;  A major reason why I believe that Weiss is justified indownplaying detail in favor of interpretation in Communications writings isthat the audience is a mix of software engineers and computer scientists.andO;The mathematical logic details of a computer scientist's work is of no moreuse to me than the computer architecture details of my work is to him.andP;  Whatwe can learn from each other, and what the Communications provides a forumfor, is our sharing the distilled essence of our differing partialperceptions of computing machines.andP;  We are like the blind men and theelephant, saying, &quot;a computer is like a Turing machine,&quot; or &quot;a computer islike a mechanical switching device.&quot;andP;  By pooling our limited views, we holdout the possibility of rising above our limitations.andP;  Since the words Weissused, &quot;.andP;  .  .  sacrific[ing] precision to gain sensationalism,&quot; seem to havemet with almost universal dismay, may I suggest the functionally equivalentwords of Wallace Stevens as a substitute, &quot;In ghostlier demarcations, keenersounds.&quot;andM;James Fetzer's article in Communications provides a theoretical basis forsupposing that program verification may be impossible.andP;  One can, however, gofurther to present the following more pragmatic points:andM;* Many (possibly most) useful programs are not merely unverifiable, they areincorrect.andP;  This is due, among other things, to the fact that the computercan at best approximate the real numbers.andP;  The most that one can say of aprogram that inverts matrices, for example, is that it will produce a useableapproximation to an inverse provided that the input is sufficiently wellbehaved.andP;  One could verify an appropriately modified specification, but thisis likely to be much harder.andM;* Even when a verifiably correct program exists, it may be less useful than averifiably incorrect program with better average performance.andP;  For example,although a program that produces optimal solutions to the &quot;travellingsalesman&quot; problem is fairly simple to construct, any program that operates ina useful amount of time (i.e., before the salesman and his goods have longsince crumbled into dust) will necessarily employ heuristics that will comereasonably close to the optimum in most cases, and fail miserably on others.andM;* Even programs that function correctly in isolation may not do so incombination; for example if they compete for system resources.andP;  I am sure Iam not the only programmer to have a compiler run out of memory becausesomeone else was sharing the machine.andM;* Formal logic is a terrible programming language, and there is no reason toexpect that, just because a specification is formal, it describes somethingthat can actually be constructed or, even if it could be constructed, woulddo what the user really wanted.andP;  Presumably a formal verification procedurewould detect the first instance (or at least fail, possibly at great lengthand vast expense, to construct a proof), but there is no way it could detectthe second.andM;* Finally, many of the most important requirements of real programs aresimply not formalizable.andP;  I would hate to try to come up with a formalspecification for the &quot;playability&quot; of a video game, or the probablehostility of a radar echo.andM;In the long run it is considerations like these that make programming a craftrather than a science.andP;  There is, indeed, a science of computing, just asthere is a science of physics.andP;  But I would no more hire a theoreticalcomputer scientist to write a program than I would contract with atheoretical physicist to build a house.andP;  This is not to say that people don'texist with skills in both the science and the craft, only that it isdangerous to ignore the distinction.andP;  It is not for nothing that Don Knuth(perhaps the best example of such a person that I know of) entitled his bookThe Art of Computer Programming.andM;Program Verification Reprise:andM;The Author's ResponseandM;Insofar as the original article by Richard DeMillo, Richard Lipton, and AlanPerlis (&quot;Social Processes and Proofs of Theorems and Programs,&quot;Communications May 1979, pp.andP;  271-280) that was the stimulus for my ownprovoked great controversy, it comes as no surprise that some of those whoseletters have been published here generate more heat than light.andP;  Moregratifying to note, therefore, is that several raise issues that deservefurther clarification, even though what I shall now add may or may notcompletely satisfy my critics.andP;  I am a philosopher by profession, of course,and philosophers, of all people, can appreciate the benefits that accrue fromstrong arguments advanced in pursuit of one's point of view.andP;  I am gratefulfor this opportunity to respond.andM;The letter by James C. Pleasant suggests that I have done a &quot;disservice&quot; tothe programming profession by &quot;belaboring the rather obvious fact thatprograms which are run on real machines cannot be completely reliable, asthough advocates of verification thought otherwise.&quot;andP;  He contends that,although I differentiate between different conceptions of what it is forsomething to be a program.andP;  I do &quot;not make clear which interpretation [I]have in mind&quot; in drawing the conclusion that program verification cannotsucceed as a generally applicable and completely reliable method forguaranteeing the performance of a program.andP;  The core of his position,however, emerges from the following paragraphs in which he maintains (a) thatthe performance of any program during its execution cannot be guaranteed; (b)that deductive methods can be shown to be &quot;useful&quot; for the verification ofalgorithms; and, (c) that any distinction I may have intended between&quot;programs&quot; and &quot;algorithms&quot; is an &quot;artificial&quot; contrivance, especially as amatter involving &quot;details.&quot;andM;Pleasant uses these premises to conclude that &quot;surely we should not, as amatter of course, ban the use of deductive methods in connection withverifying these details.&quot;andP;  These complaints, I am afraid, are largely, if notentirely, without merit.andP;  The principal position under consideration withrespect to program verification, no doubt, is that of C. A. R. Hoare andthose who share a similar point of view, a matter about which my article isquite explicit.andP;  On several occasions, I quote Hoare himself, mostsignificantly as follows: &quot;Computer programming is an exact science in thatall the properties of a program and all the consequences of executing it can,in principle, be found out from the text of the program itself by means ofpurely deductive reasoning&quot; (emphasis added).andP;  This sentence, which is themost unambiguous formulation of his position that I have yet to discover,reflects a bold conjecture concerning computer programming--a conjecture thatI contend is impossible to justify.andM;Since Hoare is an individual possessed of enormous intelligence, I take itthat either he does not mean what he says in this fascinating sentence or heseriously believes something that cannot possibly be true.andP;  Either way, Ifind it difficult to accept Pleasant's presumption that the untenability ofHoare's position is &quot;a rather obvious fact&quot; that no advocate of verificationcould deny.andP;  Hoare, after all, is an advocate of program verification, ifanyone is.andP;  Therefore, unless he does not mean what he says, he believessomething that is unjustifiable and false, so far as I have been able todiscern.andP;  I would acknowledge, however, that one person's &quot;self-evidentprinciple&quot; may be another person's &quot;manifest absurdity.&quot;andP;  If something thatHoare takes to be true is something that Pleasant takes to be false, perhapsthe facts are not entirely obvious.andM;As to the suggestion that I fail to explain the meaning of &quot;program&quot; withrespect to my conclusion, that is a difficult criticism to defend, especiallyin light of the extensive discussion devoted to this issue (from p. 1056through p. 1062) and the explicit definitions that I formulate as (D1) and(D2) on p. 1057.andP;  My endorsement of thesis (a) above, moreover, does notimply that I deny thesis (b), which I explicitly concede on p. 1058, on p.andO;1059, and again on p. 1060.andP;  Pleasant maintains (c) that the distinction atissue is &quot;artificial.&quot;andP;  But if programs are causal models obtained byimplementing algorithms in a form that is suitable for execution bymachine--where algorithms are, but programs are not, appropriate subjects forconclusive absolute verification--their differences cannot be properlydismissed as merely &quot;matters of detail.&quot;andP;  The general remarks with whichPleasant concludes his letter, however, are ones with which I can agree, atleast in spirit if not in letter.andP;  These methods have a place in programmingpractice when their limitations are understood.andM;The letter from the three Cambridge scholars, by comparison, was far lesspleasant.andP;  These persons grossly oversimply a complex argument as though itshould immediately be acknowledged as &quot;obvious&quot; and then be dismissed as&quot;insignificant.&quot;andP;  They allege that, &quot;Fetzer claims that verification isuseless because it cannot guarantee perfection,&quot; which is mistaken andunjustifiable.andP;  For while I do maintain that verification cannot guaranteewhat will happen when a program is executed by a physical machine(&quot;perfection&quot;?), I do not assert that verification is therefore useless.andP;  Amore judicious formulation of the implications of my position would be toremark that, &quot;Fetzer argues that deductive proofs within formal systemscannot definitively characterize the behavior of causal systems.andP;  As aconsequence, program verification can, at best, play a much more limited rolein assuring the production of high quality software than advocates suggest.&quot;andO;This is a point they fail to understand.andM;Fortunately, there are others in the field who have appreciated what myarticle is all about.andP;  The &quot;more judicious&quot; formulation proposed above, forexample, is excerpted from a letter by Rob Kling to James Maurer recommendingthat it should be published.andP;  Indeed, there are other indications that theCambridge scholars have not really grasped what has been going on in thecourse of these deliberations.andP;  They preface their contemptuous dismissal ofmy efforts by citing the remark that &quot;most real software tends to consist ofa lot of error messages and user interfaces&quot; on p. 1055 as disclosing &quot;theextent of Fetzer's ignorance.&quot;andP;  They are completely oblivious of the factthat at that point I was characterizing the position of DeMillo, Lipton, andPerlis, as I implicitly reiterate on p. 1058.andP;  The position they attack isnot even mine.andM;The Cambridge scholars, I believe, had already made up their minds and didnot want to be bothered with facts; but if they had only paused to read theoriginal DeMillo, Lipton and Perlis article, they might have discovered thefollowing assertion on p. 277 (not on p. 227, which I cite): &quot;It has beenestimated that more than half the code in any real production system consistsof user interfaces and error messages--ad hoc, informal structures that areby definition unverifiable.&quot;andP;  This example, moreover, is highly instructivewith respect to the style of criticism that the Cambridge scholars employ.andO;For the passage they cite has been taken out of context andmisattributed--which is bad enough in itself--but without any attempt todiscern whether or not its truth or falsity makes the least difference to thepoints that I am urging.andP;  I do not doubt that the extent to which userinterfaces and error messages actually occur depends upon and varies with thetype of programming under consideration.andP;  But nothing about this matter makesany difference at all to any of the points at issue in my article.andP;  In fact,quite the contrary is the case, since I explicitly treat aspects ofprogramming that are ordinarily viewed as inaccessible to verification asthough they were accessible to verification in order to avoid being chargedwith having attacked a straw man (p.andP;  1059).andM;The indiscriminate and unscrupulous means that they employ to tar and feathermy position extend to either misreading or misrepresenting what I have saidin other cases when I have spoken for myself.andP;  They further denigrate myknowledge of these matters by gleefully reporting that I refer &quot;totheorem-proving programs as 'an intriguing prospect' (p.andP;  1061), seeminglyunaware of the many theorem-proving programs and their accomplishments.&quot;andO;Those who actually consider what I have to say on p. 1061, however, might bestunned to discover that what I am actually contemplating is the use of&quot;higher level machines that have the capacity to validate proofs that aremany orders of magnitude more complex than those that can be mechanicallyverified today&quot; (emphasis added).andP;  For it is difficult to see how theaccomplishments of currently available theorem provers affects myconsideration of the prospects for verification by machines more complex thanthose that are currently available.andP;  Certainly, somebody does not know whatthey are talking about.andP;  If Cambridge cannot be the source of light that ithas been in the past, alas, I guess it can compensate by generating at leasta little heat.andM;The letter from Computational Logic by William Bevier, Michael Smith, andWilliam Young seems to be of a completely different order altogether.andP;  Theseauthors have made a serious attempt to understand the objective of myinvestigation, even providing a reconstruction that represents much of theskeleton of my position.andP;  Thus, they assert that I maintain (1) that thepurpose of program verification is to provide a completely reliable methodfor guaranteeing the perforance of a program; (2) that this is possible foralgorithms (which cannot be executed by machine), but not for programs (whichcan); yielding the conclusion (3) that there is little to be gained and muchto be lost through fruitless efforts to guarantee the reliability of programswhen no guarantees are to be had.andP;  They then add that, &quot;The strongimplication is that program verification is a useless, if not harmfulactivity.&quot;andM;The reconstruction of my position that is represented by (1) through (3)seems to me to be perfectly reasonable, so long as it is understood that thefirst premise is intended as a reflection of the position that is--implicitlyor explicitly--endorsed by the proponents of program verification.andP;  Thus,when they suggest that I have misconstrued the goals of program verification,we have successfully joined issues.andP;  They assert, &quot;The purpose of programverification is not to provide an absolute guarantee of correctness withrespect to the execution of a program on hardware&quot; and note that, even thoughthe quote from Hoare that occurs on p. 1052 &quot;seems to imply this view,&quot;another that occurs on p. 1059 &quot;from the same article&quot; explicitly statesotherwise.andP;  In their estimation--despite my denial--they think I am attackinga straw man.andM;The passages from Hoare's article of 1969, of course, had not escaped myattention.andP;  What I find fascinating to behold is not the prospect that famousfigures sometimes affirm various propositions that cannot possibly besimultaneously true--who among us is immune from that fate?--but thecertitude evinced by their followers that they know which of the members ofsuch an inconsistent set are supposed to be true and which are supposed to befalse in the mind of their original authors.andP;  How do Bevier, Smith and Younghappen to know that Hoare accepts his second quote and rejects his first?andO;Why not accept the first and reject the second?andP;  Why not assume that anauthor who has the ability of a Hoare to say what he means and to mean whathe says believes them both?andP;  That they are mutually inconsistent (which Itend to concede) does not mean that they are jointly unbelievable (which Ideny).andM;It would have been a good thing, no doubt, had Hoare spoken for himself onthis matter.andP;  Nevertheless, there are virtues in considering the argumentsthat Bevier, Smith and Young have posed rather than others that Hoare hasnot, especially since they lead to a crucial intersection.andP;  In particular,Bevier, Smith and Young maintain that the objective of program verificationis not to place computer science &quot;on the same footing with mathematics, butto put it on the same footing as any scientific discipline in whichmathematics is used to make predictions about the behavior of physicalphenomena.&quot;andP;  This seems to me to be an excellent summation of a fundamentalissue before us, insofar as it accents the key question, &quot;Is computer sciencea formal discipline (like mathematics), or is it an empirical discipline(like physics, chemistry, etc.)?&quot;andM;The answer that I suggest, of course, is that it is a formal discipline tothe extent to which it focuses upon algorithms and an empirical discipline tothe extent to which it implements them in the form of programs.andP;  I contendthat the methods appropriate to formal disciplines, such as mathematics, arealso applicable to algorithms, and that those appropriate to empiricaldisciplines, such as physics, chemistry, etc., are applicable to programs.andO;The point thus becomes one of understanding the scope and limits of deductiveprocedures within this theoretical framework, since it would be a mistake tothink that exclusively deductive procedures that are completely adequatewithin purely formal contexts could possibly be completely adequate withinempirical contexts that are not purely formal.andP;  Deductive methods are enoughonly in purely formal contexts; empirical contexts depend essentially oninduction; hence, the critical distinction between &quot;absolute&quot; and &quot;relative&quot;verifiability.andM;The sincerity of these authors as they wrestle with these issues is quiteapparent.andP;  The culmination of their efforts to draw the distinctions that areinvolved here occurs when they contemplate the difference--which, in theireyes, is vanishingly small--between AND-gates and corresponding booleanfunctions, suggesting that the semantic distance encountered here is&quot;sufficiently small to render Fetzer's objections inconsequential&quot;: &quot;To denyany relation between, say, a physical AND gate and the corresponding booleanfunction is to deny that there can be any useful mathematical model ofreality.andP;  This is tantamount to asserting the impossibility of physicalscience.&quot;andP;  Since I certainly do not want to assert the impossibility ofphysical science--thereby terminating my own profession as a philosopher ofscience--I had better be prepared to dispute the premises that yield thisconclusion.andP;  But that turns out to be surprisingly effortless, insofar aseven &quot;vanishingly small&quot; differences are enough, so long as they are&quot;differences,&quot; i.e., do exist.andP;  For every argument that I have given for thedifference between programs and algorithms obtains alike for physicalAND-gates and their abstract counterparts.andM;It is not that I am denying &quot;any relation&quot; at all between these physicaldevices and the logical operations that we design them to reflect any morethan I am asserting that program verification is a useless if not harmfulactivity.andP;  Deductive procedures have their place in physical science as wellas in formal science.andP;  The mathematical equations of classical mechanics havea fundamental role to fulfill in extracting consequences from premises, i.e.,andO;in exhibiting what must be true if certain assumptions, such as Newton'sthree laws of motion and law of universal gravitation, happen to be true.andO;Nothing about mathematical physics is compromised by the recognition that theuse of these methods does not guarantee the truth of the &quot;theorems&quot; ofclassical mechanics that are derived by their application to these Newtonian&quot;axioms,&quot; precisely because these &quot;axioms&quot; themselves are empirical claimsthat might be false.andP;  The question is not even whether they actually arefalse (although, in this case, I presume that they are) but rather that theirfalsity remains a logical possibility in spite of their status as theorems.andO;This is the key point.andM;The intersection between Bevier, Smith and Young's defense and the positionoccupied by Hoare, therefore, emerges at this point.andP;  For while these authorsovertly abandon the mathematical paradigm--the thesis that programming shouldmodel itself after mathematics--Hoare overtly harbors it.andP;  Indeed, I think itis almost impossible to read his &quot;Mathematics of Programming&quot;, BYTE (August1986), without being profoundly impressed by the degree of his conviction.andO;Thus, after enunciating his four basic principles, i.e.,andM;(1) computers are mathematical machines;andM;(2) computer programs are mathematical expressions;andM;(3) a programming language is a mathematical theory; and,andM;(4) programming is a mathematical activity; he emphasizes that, while theseare general philosophical and moral principles, &quot;all the actual evidence isagainst them.andP;  Nothing is as I have described it, neither computers norprograms nor programming languages nor even programmers&quot; (p.andP;  116).andP;  Themachines are complicated and not well understood, the programs are enormousand complex, the languages are difficult to grasp, and programmers are raisedin ignorance and fear of mathematics.andM;Has Hoare therefore abandoned principles (1) through (4)?andP;  I do not think so.andO;His view, as he hastens to explain, is that &quot;the laws of programming are assimple, as obvious, and as useful as the laws in any other branch ofmathematics&quot; (p.andP;  116).andP;  He thus regrets the divergence between theprinciples of programming (properly understood) and the practice ofprogramming (in its current manifestations).andP;  Toward the conclusion of thisarticle, Hoare admits that, &quot;No method by itself can guarantee absolutereliability,&quot; by which he means that mistakes can occur even when theappropriate methods are employed.andP;  Thus, Hoare's position, as I construe it,maintains that programming practice can increasingly come to fulfill theprinciples of programming as he has articulated them by improvements in themachines, the programs, the languages and the programmers, where, within anideal environment, it can be the case that programming is a mathematicaldiscipline like all the others.andM;If my arguments are sound, then Hoare's ideal is incapable of realization,not because of any imperfections in the practice of programming--though he iscertainly correct to bemoan them--but because of certain limitations upon theprinciples of programming.andP;  These limitations arise from the character ofcomputers as complex causal systems whose behavior, in principle, can only beknown with the uncertainty that attends empirical knowledge as opposed to thecertainty that attends specific kinds of mathematical demonstrations.andP;  Forwhen the domain of entities that is thereby described consists of purelyabstract entities, conclusive absolute verifications are possible; but whenthe domain of entities that is thereby described consists of non-abstractphysical entities (from the very large, such as the universe, to the verysmall, such as the AND-gate), only inconclusive relative verifications arepossible.andP;  And for this reason Hoare's four principles must be qualified byacknowledging the difference between pure and applied mathematics, preciselyas I have done.andM;I would like to believe that this distinction, which leads to thequalification of Hoare's basic principles and their replacement by thefollowing four,andM;(1') computers are applied mathematical machines;andM;(2') computer programs are applied mathematical expressions;andM;(3') a programming language is an applied mathematical theory; and,andM;(4') programming is an applied mathematical activity; does not &quot;contribute toa gross misunderstanding of the nature of program verification,&quot; as Bevier,Smith and Young suggest.andP;  I am not promoting the view that programverification purports to provide absolute certainty, but rather attacking thebelief that this might be possible.andP;  So long as the scope and limits of thismethodology are properly understood, I have no reason to dissent from theirconception that &quot;The [proper] goal of program verification research is tomake it possible to make highly accurate predictions about the behavior ofprograms running on computers.&quot;andP;  Presumably, of course, this is an objectivethat might also be attained by other methods as well, including ad hocprogram testing.andP;  But so long as this is acknowledged, I would agree.andM;The letter from Thomas Clune, it should come as no surprise, is one that Ifind very reassuring.andP;  Indeed, perhaps the only qualification I would add towhat he has said is about his conception of the hypothetical scenario that Iintroduced--whereby social conditions might change to foster the creation ofprogram verification groups--as &quot;aleatory.&quot;andP;  This intriguing term has severaldistinct senses, including those of (i) chance (in the sense of accidental;not on purpose) and (ii) random (in the sense of probabilistic; notdeterministic), and others as well.andP;  By introducing this possibility--whichis not merely logically possible (consistent with the laws of logic) andphysically possible (consistent with the laws of nature) but historicallypossible (consistent with the history of the world up until now)--I merelyintended to illustrate a course of events that might yet occur, relative towhich the principal rationale that lay behind the critique of verificationpractices advanced by DeMillo, Lipton and Perlis would no longer obtain.andO;While I am unsure whether I completely understand his analogy betweencomputer science as process and software engineering as product in relationto the distinction between syntax and semantics, I found this letter--likeothers I have received--a pleasure to read.andM;The letter from Stephen Savitzky, finally, goes beyond the arguments of myarticle to extend additional reasons why the very idea of programverification is fraught with hazard.andP;  He offers five arguments for such aposition:andM;(a) the limitations of programs in representing real numbers means that manyuseful programs are not merely unverifiable but actually incorrect;andM;(b) sometimes a verifiably incorrect program can yield a better performancethan a verifiably correct program as a preferable solution to a problem;andM;(c) programs that happen to function correctly independently (in isolation)sometimes do not function correctly in combination for many reasons;andM;(d) merely because a specification is formally expressible does not mean thatit can be constructed or that it will do what it is supposed to do if it is;andM;(e) many of the most important requirements that our programs ought tofulfill involve properties that tend to be difficult or impossible toformalize.andM;These are all excellent additional reasons for adopting the conclusion thatthe techniques of program verification have to play a much more limited rolein assuring the production of high quality software than its advocatespropose.andM;Savitzky also suggests that although there is a science of computing just asthere is a science of physics, programming is a craft rather than a science.andO;Provided all this is understood from a certain point of view, I tend toagree.andP;  I believe that computer science is a science in the same sense thatphysics is a science, where they both have theoretical and experimentaldimensions.andP;  For hardware, the task is to design machines that can processcertain classes of software; for software, the task is to design programsthat can be processed by certain classes of hardware.andP;  When hardware isproduced, it is tested by attempting to process software of correspondingkinds, where it can fail to meet its requirements.andP;  When software isproduced, it is tested by attempting to execute it using corresponding typesof hardware, where it can fail to meet its requirements too.andP;  The design ofhardware and of software alike, however, is a creative activity.andP;  Ultimately,I believe, the case can be made for viewing computer science as an empiricalscience within a Popperian framework.andP;  Indeed, the basic elements of such aposition can already be found in my article.andP;  Matters like these areessential to understanding this discipline.andP;  James H. Fetzer Philosophy andHumanities University of Minnesota Duluth, MN 55812</TEXT></DOC>