<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-039-626  </DOCNO><DOCID>08 039 626.andM;</DOCID><JOURNAL>Dr. Dobb's Journal  Winter 1989 v14 n159 p96(2)* Full Text COPYRIGHT Mandamp;T Publishing 1989.andM;</JOURNAL><TITLE>What's right with C? (Viewpoint) (column)</TITLE><AUTHOR>Carew, David.andM;</AUTHOR><SUMMARY>Two principal problems characterizing the C programming languagein the 1980s, the quality and output of C compilers and theproductivity of programmers, have been substantially amelioratedin the past several years.andP;  Since the quality of the object codeis more a function of implementation than the language itself, itis more difficult to optimize and enhance productivity for Clanguage applications.andP;  At the same time, there has been a greatimprovement in C compilers, which have become production qualitytools.andP;  The American National Standards Institute's ANSI C is alarger and more complex language, oriented more towards real-worldproduction services such as parameter checking.andP;  C compilers nowembody state-of-the-art debuggers and code profilers and frontends with hypertext on-line documentation.andP;  With prospectspositive for the 1990s, C promises benefits to the individual, theteam and the system.andM;</SUMMARY><DESCRIPT>Topic:     C Programming LanguageObject CodeCompilersSoftware DesignAmerican National Standards InstituteStandardizationProductivity.andM;</DESCRIPT><TEXT>What's Right with C?andM;In the June 1986 issue of Dr. Dobb's Journal, I wrote a &quot;Viewpoint&quot; entitled&quot;What's Wrong With C.&quot;andP;  Have things changed enough to make me alter myopinion?andP;  While the title of this &quot;Viewpoint&quot; probably gives away my positiontoday, it is nonetheless time to reassess the state of C, and see how itstacks up for the 1990s.andM;Just to recap: My two priciple objections to C in the mid-1980s were: a. Thequality of C compilers and their output; and b.andP;  The productivity (includingthe maintenance part of the software life cycle) of programmers using C.andO;Let's put the easy one to bed quickly -- the quality of today's C compilersis dramatically better than it was a few years ago.andM;The popularity of a language correlates well with the quality of itscompilers.andP;  The compiler vendors can afford to spend more of those expensiveman-hours improving a product that sells well -- and they are compelled bycompetition to do so.andP;  This is why nasty (but popular) languages, such asFortran and Cobol, often produce the tightest code in the environments wherethey run.andM;The size and quickness of the object code is (mostly) a consequence of theimplementation, not the language itself.andP;  The real point is that C, with itsinherently low-level nature, is much harder (but not impossible, as my 1986article implied) to optimize to the same degree as &quot;better&quot; languages.andP;  I'mstill willing to bet that Microsoft has many more man-months' effort investedin its C compilers' optimizing technology than, for example, JPI has in theoptimization portions of its excellent Modula-2, which produces comparablecode.andP;  Perhaps many times more.andP;  But, as long as someone has gone to thetrouble for us, and as long as people are willing to amortize the extra costby buying and using C in droves, then who cares?andP;  C compilers nowadays aregenerally &quot;right and tight.&quot;andP;  They are production quality tools in a way muchhyped and hoped for in the early 1980s, but seldom seen.andM;Somewhat of a corollary to C's inherently low-level, operator-rich, &quot;portableassembler&quot; character was an ethos I thought of as &quot;small is beautiful.&quot;andP;  Theidea was that obscure idioms are O.K.andP;  because &quot;the notational convenience isconsiderable&quot; (to quote Kandamp;R); and that C compilers did not have much to dobecause a truly good programmer could always build his own (ideally designedand reusable) libraries; and unerringly find the appropriate, optimalalgorithm; and without fail put a finger on the right ten percent of aprogram to convert into assembler; or do something else beautiful (whileexpending practically no time) to compensate for the elegant simplicity ofhis tools.andM;Tens of thousands of people are now using C full time; it should be obviousthat we are not all legendary coding paragons such as Jon Bentley, DennisRitchie, and Brian Kernighan.andP;  Let &quot;small is beautiful&quot; rest in peace.andO;Codified ANSI C seems much less the small, informally specified, gratuitously&quot;elegant,&quot; personal use language that was so objectionable to those facinglarge-scale, serious systems implementation projects.andP;  ANSI C is larger, witha more &quot;designed by committee&quot; feel.andP;  ANSI C is internally more complex, forthe purpose of providing real-world production services, such as compile-timeparameter checking, which production coding shops have come to expect anddepend on.andM;C compilers are now presented as environments that do lots of things for the&quot;pilot.&quot;andP;  State-of-the-art debuggers and code profilers and front ends withhypertext online documentation are conveniently (or instantly) available, asare function libraries, prepackaged to do nearly any part of an applicationthe programmer doesn't wish to tackle.andP;  The infrastructure, which has grownup around C, has contributed enormously to the productivity of C programmers.andO;For my money, this is as it should be and (almost) all to the good.andM;In most programming situations, bottom-line productivity -- man-hours to aresult with some acceptable functionality -- is the most important factorseparating the quick from the dead.andP;  C programmers are probably moreproductive than ever before; I believe it is safe to say, even without citingcorroborating studies.andP;  It may be ironic that the plethora of productivityaids surrounding C grew up because raw &quot;early C&quot; was so idiomatic anddifficult that help had a market value.andP;  Or it may be that the utilities andsubordinate tools appeared for reasons having nothing to do with allegeddifficulties in C.andP;  Again, who cares, as long as we got the boost we needed?andM;A tremendous strength of C, which I totally overlooked, is evidenced by thegrowth of new technologies that leverage on C's portability and low-levelrobustness.andP;  The very terseness and richness of C's operator set, which Ibemoaned as distracting to the human programmer, makes C a good targetlanguage to be emitted from translators evincing new concepts and powers.andO;C++ is perhaps the most famous example of this.andP;  The first C++ emittedordinary C as its output, bringing &quot;object oriented-ness&quot; to C in the sameway that RATFOR brought &quot;structured-ness&quot; to Fortran.andM;Even for those purists who believe that tacking on &quot;object orientation&quot; to anexisting language is the wrong approach, C has made its contribution.andP;  Forexample, Bertrand Meyer's Eiffel language emits C as its object code.andP;  Eiffelis a promising, practical (not interpreted or Smalltalk-like), purelyobject-oriented programming system.andP;  Meyer's (recommended) book, The Designof Object Oriented Systems, uses Eiffel as its &quot;presentation language.&quot;andM;When employed as an intermediate language, C's terse and impenetrabletendencies may be a decided plus.andP;  No less an authority than Knuth advisesthat if the emitted code is deliberately unfriendly, then people will use thefront end for modifications, rather than tweaking the intermediate (C) codeand causing maintenance headaches.andP;  Knuth's WEB document compiler system usesthis approach, deliberately emitting &quot;unreadable&quot; Pascal.andP;  Arranging for yournew translator to emit unreadable C should be easy; getting human beings (oranything else) to write halfway readable C appears to be the real trick.andM;C still is (in my mind) the consummate virtuoso's ax for &quot;programming in thesmall.&quot;andP;  For large teams working on large problems, even ANSI C'simprovements are not enough.andP;  I am intrigued by how much of the interest inC++ and other C variants (such as Object C and Objective C) may be due not tothe attractions of object-oriented technology itself (which truly requires ashift in world view) but to the possibility that &quot;C objects&quot; might be used inthe context of traditional design (as Modula-2 modules and Ada packages).andO;That is, to render &quot;programming in the large&quot; more practical and productive,and design software modules more &quot;plug compatible&quot; and reusable.andP;  Theperceived need is not for (yet another) fundamental paradigm shift, butrather for a way to manage implementation of large traditional designs in alanguage that is neither obscure, nor unwieldy, nor disdained by the bestprogrammers.andP;  Many people appear to be examining the &quot;right technology&quot; (suchas object oriented-ness) for the &quot;wrong reason&quot; (or the hope of dataabstraction and reliable modularity) just because both the reason and thetechnology are connected with C.andM;It is a monument to C's mutability, resilience, and popularity among the bestand brightest that C seems to be carrying the freight of the world's hope fora language which is great for the individual, nice for the team, andeconomical for the life cycle of a system.andM;David works for Berger and Company in Denver, Colorado.andP;  David can be reachedat 1623 N. El Paseo St. Colorado Springs, CO 80907</TEXT></DOC>