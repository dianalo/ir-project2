<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF109-716-281  </DOCNO><DOCID>09 716 281.andM;</DOCID><JOURNAL>Communications of the ACM  Dec 1990 v33 n12 p32(13)* Full Text COPYRIGHT Association for Computing Machinery 1990.andM;</JOURNAL><TITLE>An empirical study of the reliability of UNIX utilities. (includesrelated article on user commands) (technical)</TITLE><AUTHOR>Miller, Barton P.; Fredriksen, Lars; So, Bryan.andM;</AUTHOR><SUMMARY>A group of software programmers tested 90 different utilityprograms running on seven versions of the Unix operating system inan effort to identify bugs in the programs and trace their causes.andO;Using a program to generate random characters known to disrupt andsometimes crash utilities, the experimenters were able to crashover 24 percent of the programs, some of which had been previouslytested for commercial release.andP;  The effort identified bugs thatmay lead to security holes.andP;  Programmers expect major utilities towithstand crashes in spite of noisy telephone lines, but theempirical project demonstrated that many did not.andP;  The testers'tools are available to others wishing to expand the project.andM;</SUMMARY><DESCRIPT>Topic:     UNIX-Like Operating SystemsUtility ProgramsTestingReliabilitySoftware Quality.andO;Feature:   illustrationtablechart.andO;Caption:   List of systems tested. (table)Output of fuzz piped to a utility. (chart)Fuzz with ptyjig to test an interactive utility. (chart)andM;</DESCRIPT><NOTE>Only Text is presented here; see printed issues for graphics.andO;</NOTE><TEXT>An Empirical Study of the Reliability of UtilitiesandM;When we use basic operating system facilities, such as the kernel and majorutility programs, we expect a high degree of reliability.andP;  These parts of thesystem are used frequently and this frequent use implies that the programsare well-tested andworking correctly.andP;  To make a systematic statement aboutthe correctness of a program, we should probably use some form of formalverification.andP;  While the technology for program verification is advancing, ithas not yet reached the point where it is easy to apply (or commonly applied)to large systems.andM;A recent experience led us to believe that, while formal verification of acomplete set of operating system utilities was too onerous a task, there wasstill a need for some form of more complete testing: On a dark and stormynight one of the authors was logged on to his workstation on a dial-up linefrom home and the rain had affected the phone lines; there were frequentspurious characters on the line.andP;  The author had to race to see if he couldtype a sensible sequence of characters before the noise scrambled thecommand.andP;  This line noise was not surprising; but we were surprised thatthese spurious characters were causing programs to crash.andP;  These programsincluded a significant number of basic operating system utilities.andP;  It isreasonable to expect that basic utilities should not crash (&quot;core dump&quot;); onreceiving unusual input, they might exit with minimal error messages, butthey should not crash.andP;  This experience led us to believe that there might beserious bugs lurking in the systems that we regularly used.andM;This scenario motivated a systematic test of the utility programs running onvarious versions of the Unix operating system.andP;  The project proceede in foursteps: (1) programs were constructed to generate random characters, and tohelp test interactive utilities; (2) these programs were used to test a largenumber of utilities on random input strings to see if they crashed; [3] thestrings (or types of strings) that crash these prgrams were identified; and(4) the causes of the program crashes were identified and the common mistakesthat cause these crashes were categorized.andP;  As a result of testing almost 90different utility programs on seven versions of Unix[TM], we were able tocrash more than 24% of these prgrams.andP;  Our testing included versions of Unixthat underwent commercila product testing.andP;  A byproduct of this project is alist of bug reports (and fixes) for the crashed prgrams and a set of toolsavailable to the systems community.andM;There is a rich body of research on program testing and verification.andP;  Ourapproach is not a substitute for a formal verification or testing procedures,but rather an inexpensive mechanism to identify bugs and increase overallsystem reliability.andP;  We are using a coarse notion of correctness in ourstudy.andP;  A program is detected as faulty only if it crashs or hangs (loopsindefinitely).andP;  Our goal is to complement, not replace, existing testprocedures.andM;This type of study is important for several reasons: First, it contributes tothe testing community a large list of real bugs.andP;  These bugs can provide testcases against which researchers can evaluate more sophisticated testing andverification strategies.andP;  Second, one of the bugs that we found was cause bythe same programming practice that provided one of the security holes to theInternet worm (the &quot;gets finger&quot; bug) [2,3] We have found additional bugsthat might indicate future security holes.andP;  Third, some of the crashes werecaused by input that might be carelessly typed--some strange and unexpectederrors were uncovered by this method of testing.andP;  Fourth, we sometimesinadvertently feed programs noisy input (e.g., trying to edit or view anobject module).andP;  In these cases, we would like some meaningful andpredictable response.andP;  Fifth, noisy phone lines are a reality, and majorutilities (like shells and editors) should not crash because of them.andP;  Last,we were interested in the interactions between our random testing and moretraditional industrial software testing.andM;While our testing strategy sounds somewhat naive, its ability to discoverfatal program bugs is impressive.andP;  If we consider a program to be a complexfinite state machine, then our testing strategy can be thought of as a randomwalk through the state space, searching for undefined states.andP;  Similartechniques have been used in areas such as network protocols and CPU cachetesting.andP;  When testing network protocols, a module can be inserted in thedate stream.andP;  This module randomly perturbs the packets (either destroyingthem or modifying them) to test the protocol's error detection and recoveryfeatures.andP;  Random testing has been used in evaluating complex hardware, suchas multiprocessor cache coherence protocols [4].andP;  The state space of thedevice, when combined with the memory architecture, is large enough that itis difficult to generate systematic tests.andP;  In the multiprocessor example,random generation of test cases helped cover a large part of the state spaceand simplify the generation of cases.andM;The following section describes the tools we built to test the utilities.andO;These tools include the fuzz (random character) generator, ptyjig (to testinteractive utilities), and scripts to automate the testing process.andP;  Next,we will describe the tests we performed, giving the types of input wepresented to the utilities.andP;  Results from the tests will follow along with ananalysis of the results, including idenfification and classification of theprogram bugs that caused the crashes.andP;  The final section presents concludingremarks, including suggestions for avoiding the types of problems detected byour study and some commentary on the bugs we found.andP;  We include an Appendixwith the user manual pages for fuzz and ptyjig.andM;The ToolsandM;We developed two basic programs to test the utilities.andP;  The first program,called fuzz, generates a stream of random characters to be consumed by atarget program.andP;  There are various options to fuzz to control the testingactivity.andP;  A second program, ptyjig, was also written to test interactiveutility programs.andP;  Interactive utilities, such as a screen editor, expecttheir standard input file to have the characteristics of a terminal device.andO;In addition to these two programs, we used scripts to automate the testing ofa large number of utilities.andM;Fuzz: Generating Random Input Strings.andP;  The program fuzz is basically agenerator of random characters.andP;  It produces a continuous string ofcharacters on its standard output file (see Figure 1).andP;  We can performdifferent types of tests depending on the options given to fuzz.andP;  Fuzz iscapable of producing both printable and control characters, only printablecharacters, or either of these groups along with the NULL (zero) character.andO;You can also specify a delay between each character.andP;  This option can accountfor the delay in characters passing through a pipe and help the user locatethe characters that caused a utility tocrash.andP;  Another option allows you tospecify the seed for the random number generator, to provide for repeatabletests.andM;Fuzz can record its output stream in a file, in addition to printing to itsstandard output.andP;  This file can be examined later.andP;  There are options torandomly insert NEWLINE characters in the output stream, and to limit thelength of the output stream.andP;  For a complete description of fuzz, see themanual page in the Appendix.andM;The following is an example of fuz being used to test deqn, the equationprocessor.andM;fuzz 100000 -o outfile | degn The output stream will be at most 100,000characters in length and the stream will be recorded in file &quot;outfile.&quot;andM;Ptyjig: Testing Interactive Utilities.andP;  There are utility programs whoseinput (and output) files must have the characteristics of a terminal device,(e.g., the vi editor and the mail program).andP;  The standard output from fuzzsent through a pipe is not sufficient to test these programs.andM;Ptyjig is a program that allows us to test interactive utilities.andP;  It firstallocates a pseudo-terminal file.andP;  This is a two-part device file that, onone side looks like a standard terminal device file (with a name of the form&quot;/dev/ttyp?&quot;) and, on the other side can be used to send or receivecharacters on the terminal file (&quot;/dev/ptyp?&quot;,see Figure 2).andP;  After creatingthe pseudo-terminal file, ptyjig then starts the specified utility program.andO;Ptyjig passes characters that are sent to its input through thepseudo-terminal to be read by the utility.andM;The following is an example of fuzz and ptyjig being used to test vi, aterminal-based screen editor: fuzz 100000 -o outfile | ptyjig vi The outputstream of fuzz will be at most 100,000 characters in length and the streamwill be recorded in file &quot;output.&quot;andP;  For a complete description of ptyjig, seethe Appendix.andM;The Scripts: Automating the Tests.andP;  A command (shell), script file waswritten for each type of test.andP;  Each script executes all the utilities for agiven set of input characteristics.andP;  The script checks for the existence of acore file after each utility terminates, indicating the crash of thatutility.andP;  The core file and the offending input data file are saved for alteranalysis.andM;The TestsandM;After building the software tools, we used them to test a large collection ofutilities running on several versions of the Unix operating system.andP;  Eachutility on each system was executed with several different types of inputstreams.andP;  A test of a utility program can produce one of three results:crash--the program terminates abnormally producing a core file; hand--theprogram appears to loop indefinitely; or succeed--the program terminatesnormally.andP;  Note that in the last case, we do not specify the correctness ofthe output.andM;To date, we have tested utilities on seven versions of Unix(1).andP;  Theseversions are summarized in Table I.andP;  Most of these versions are derived fromsome form of 4.2BSD or 4.3BSD Berkeley Unix.andP;  Some versions, like the SunOSrelease, have undergone substantial revision (especially at the kernellevel).andP;  The SCO Xenix version is based on the System V standard from ATandamp;T.andO;The IBM AIX 1.1 Unix is a released, tested product, supporting mostly thebasic System V utilities.andP;  It is also important that the tests coveredseveral hardware architectures, as well as several systems.andP;  A programstatement with an error might be tolerated on one machine and cause theprogram to crash on another.andP;  Referencing through a null-value pointer is anexample of this type of problem.andM;Our testing covered a total of 88 utility programs on the seven versions ofUnix.andP;  Most utilities were tested on each system.andP;  Table II lists the namesof the utilities that were tested, along with the type of each system onwhich that utility was tested.andP;  For a detailed description of each of theseutilities, we refer readers to the user manual for appropriate systems.andP;  Thelist of utilities covers a substantial part of those that are commonly used,such as the mail program, screen editors, compilers, and document-formatingpackages.andP;  The list also includes less commonly used utilities, such as cb,the C language pretty-printer.andM;Each utility program we tested was subjected to several different types ofinput streams.andP;  The different types of inputs were intended to test for avariety of errors that might be triggered in the utilities being tested.andP;  Themajor variations in test data were including nonprintable (control)characters, including the NULL (zero) byte, and maximum lengthe of the inputstream.andP;  These test are summarized in Table IIIa.andM;The input streams for interactive utilities have slightly differentcharacteristics.andP;  To avoid overflowing the input buffers on the terminaldevice, the input was split into random length lines (i.e., terminated by aNEWLINE character) with a mean length of 128 characters.andP;  The input lengthparameter is described by the number of lines, and is therefore scaled downby a factor of 100..andM;The Results And AnalysisandM;Our tests of the Unix utilities produced a surprising number of programs thatwould crash or hang.andP;  In this section, we summarize these results, group theresults by the common programming errors that caused the crashes, and showthe programming practices that caused the errors.andP;  As a side comment, wenoticed during our test that many of the programs that did not crash wouldterminate with no error message or with a message that was difficult tointerpret.andM;The basic test results are summarized in Table II.andP;  The first result tonotice is that we were able to crash or hang a significant number of utilityprograms on each system (from 24%-33%).andP;  Included in the list of programs areseveral commonly used utilitiesd vi and emacs, the most popular screeneditors; csh, the c-shell; and various programs for document formatting.andP;  Wedetected two types of error results--crashing and hanging.andP;  A program wasconsidered crashed if it terminated, producing a core (state dump) file, andwas considered hung if it continued executing, producing no output whilehaving available input.andP;  A program was also considered hung if it continuedto produce output after its input had stopped.andP;  Hung programs were typicallyallowed to execute for an additional five minutes after the hung state wasdetected.andP;  Programs that were blocked waiting for input were not consideredhung.andM;Table IV summarizes the list of utility programs that we were able to crashor hang, categorized by the cause of the crash, and showing on which systemswe were able to crash the programs.andP;  Notice that a utility might crash on onesystem but not on another.andP;  There are several reasons for this: One reason isdifferences in the processor architecture.andP;  For example, while the VAX will(incorrectly) tolerate references through null pointers, many otherarchitectures will not (e.g., the Sun 4).andP;  A second reason is that thedifferent systems had differences in the versions of the utilities.andP;  Localchanges might improve or degrade a utility's reliability.andP;  Both internalstructure as well as external specification of the utilities change fromsystem to system.andP;  It is interesting to note that the commercially tested AIX1.1 Unix is as susceptible as other versions of Unix to the type of errorsfor which we tested.andM;We grouped the causes of the crashes into the following categories:pointer/array errors, not checking return codes, input functions,sub-processes, interaction effects, bad error handler, signed characters,race conditions, and currently undetermined.andP;  For each of these categories,we discuss the error, show code fragments as examples of the error, presentimplications of the error, and suggest fixes for the problem.andM;Note that, except for one example (noted in the text), all of the crashes orhangs were discovered through automatic testing.andM;Pointer/ArraysandM;The first class of pointer and array errors is the case where a program mightsequentially access the cells of an array with a pointer or array subscript,while not checking for exceeding the range of the array.andP;  This was one of themost common programming errors found in our tests.andP;  An example (taken fromcb) shows this error using character input: while ((cc = getch())!=c){ string[j++]=cc; ...andP;  }andM;This example could be easily fixed to check for a maximum array length.andO;Often the terseness of the C programming style is carried to extremes; formis emphasized over correct function.andP;  The ability to overflow an input bufferis also a potential security hole, as shown by the recent Internet worm.andM;The second class of pointer problems is caused by references through a nullpointer.andP;  The prolog interpreter, in its main loop, can incorrectly set apointer value that is then assumed to be valid in the next pass around theloop.andP;  A crash caused by this type of error can occur in one of two places.andO;On machines like the VAX [TM], the reference through the null pointer isvalid and reads data at location zero.andP;  The data accessed are machineinstructions.andP;  A field in the (incorrectly) accessed data is then used as apointer and the crash occurs.andP;  On machines like the Sun 4, the referencethrough the null pointer is an error and the program crashes immediately.andP;  Ifthe path from where the pointer was set to where it was used is not anobvious one, extra checking may be needed.andM;The assembly language debugger (adb) also had a reference through a nullpointer.andP;  In this case, the pointer was supposed to be a global variable thatwas set in another module.andP;  The external (global) definition was accidentallyomitted from the variable declaration in the module that expected to use thepointer.andP;  This module then referenced an uninitialized (in Unix, zero)pointer.andM;Pointer errors do not always appear as bad references.andP;  A pointer mightcontain a bad address that, when used to write a variable, mayunintentionally overwrite some other data or code location.andP;  It is thenunpredictable when the error will manifest itself.andP;  In our tests, the crashof lex (scanner generator) and ptx (permuted index generator) were examplesof overwriting data, and the crash of ul (underlining text) was an example ofoverwriting code.andM;The crash of as (the assembler originally appeared to be a result of improperuse of an input routine.andP;  The crash occurred at a call to the standard inputlibrary routine ungetc(), which returns a character back to the input buffer(often used for look-ahead processing).andP;  The actual cause was that ungetc()was redefined in the program as a macro that performed a similar function.andO;Unfortunately, the new macro had less error checking than the system versionof ungetc() and allowed a buffer pointer to be incorrectly set.andP;  Since thenew macro looks like the original routine, it is easy to forget thedifferences.andM;Not Checking Return CodesandM;Not checking return codes is a sign of careless programming.andP;  It is afavorable comment on the current state of Unix that there are so few examplesof this error.andP;  During our tests, we were able to crash adb (the assemblylanguage debugger) and col (multi-column output filter ASCII terminals)utilities because of this error.andP;  Adb provides an interesting example of aprogramming practice to avoid.andP;  This code fragment represents a loop in adband a procedure called from that loop.andP;  format.c (line 276): ...andP;  while(lastc!='\n'){ rdc(); } ...andP;  input.c (line 27): rdc () { do { readchar ();}while (lastc == ''|| lastc=='\t'); return (lastc); }andM;The initial loop reads characters, one by one, terminating when the end of aline has been seen.andP;  The rdc() routine calls readchar(), which places the newcharacter into a global variable named &quot;lastc.&quot;andP;  Rdc() will skip over tab andspace characters.andP;  Readchar() uses the Unix file read kernel call to read thecharacters.andP;  If readchar() detects the end of the input file, it will set thevalue of lastc to zero.andP;  Neither rdc() nor the initial loop check for the endof file.andP;  If the end of file is detected during the middle of a line, thisprogram hangs.andM;We can speculate as to why there was no end of file check on the initialloop.andP;  It may be because the program author thought it unlikely that the endof file would occur in this situation.andP;  It might also be that it was awkwardto handle the end of file in this location.andP;  While this is not difficult toprogram, it requires extra tests and flags, more complex loop conditions, orpossibly the use of a goto statement.andM;This problem was made more complex to diagnose because of the extensive useof macros (the code fragment above has the macros expanded).andP;  These macrosmay have made it easier to overlook the need for the extra test for the endof file.andM;Input FunctionsandM;We have already seen cases where character input routines within a loop cancause a program to store into locations past the end of an array.andP;  Inputroutines that read entire strings are also vulnerable.andP;  One of the main holesthrough which the Internet worm entered was the gets() routine.andP;  The gets()routine takes a single parameter that is a pointer to a character string.andO;There is no possible means of bounds checking.andP;  Our tests crashed the ftp andtelnet utilities through use of gets().andM;The scanf() routine is also vulnerable.andP;  In the input specification, it ispossible to specify an unbounded string field.andP;  An example of this comes fromthe topological sort (tsort) utility.andP;  x=fscanf(input, &quot;%s%s&quot;, precedes,follows);andM;The input format field specifies two unbounded strings.andP;  In the program,&quot;precedes&quot; and &quot;follows&quot; are declared with the relatively small lengths of 50characters.andP;  It is possible to place a bound on the string fieldspecification, solving this problem.andM;Sub-ProcessesandM;The code might be carefully designed and written, with the programmingfollowing all the good rules for program writing.andP;  But this might not beenough if another program is used as part of this one.andP;  Several of the Unixutilities execute other utilities as part of doing their work.andP;  For example,the diction and style utilities call deroff, vi calls csh, and vgrind callstroff.andP;  When these sub-processes are called, they are often given directaccess to the raw input data stream, so they are vulnerable to erroneousinput.andP;  Access to sub-processes should be carefully controlled or insuranceprovided that the program input to the sub-process is first checked.andO;Alternatively, the utility should be programmed to tolerate the failure of asubprocess (though this can be diificult).andM;Interaction EffectsandM;Perhaps one of the most interesting errors that we discovered was a result ofan unusual interaction of two parts of csh, along with a little carelessprogramming.andP;  the following string will cause the VAX version of csh to crash!0%8fandM;and the following string !0%888888888fandM;will hang (continuous output of space characters) most versions of csh.andP;  Thefirst example, which triggers the csh's command history mechanism, says&quot;repeat the last command that began with '0%8f.'&quot;  Since it does not findsuch a command, csh forms an error message string of the form: &quot;0%8f: Eventnot found.&quot;andP;  This string is passed to the error-printing routine, which usesthe string as the first parameter to the printf() function.andP;  The firstparameter to printf() can include format items, denoted by a &quot;%.&quot;andP;  The &quot;%8f&quot;describes a floating point value printed in a field that is 8 characterswide.andP;  Each format item expects an additional parameter to printf(), but inthe csh error, none is supplied (or expected).andP;  This string was generatedduring the normal random testing.andM;The second example string follows the same path, but causes csh to try toprint the floating point value in a field that is 888,888,888 characterswide.andO;The seemingly infinite loop is the printf() routine's attempt to pad theoutput field with sufficient leading space characters.andP;  This second stringwas one that we generated by hand after discivering the first string.andM;Both of these errors could be prevented by substituting the printf() callwith a simple string printing routine (such as put()).andP;  The printf() was usedfor historical reasons related to space efficiency.andP;  The error-printingroutine assumed that it would always be passes strings that were safe toprint.andM;Bad Error HandlerandM;Sometimes the best intentions do not reach completion.andP;  The units programdetects and traps floating point arithmetic errors.andP;  Unfortunately, the errorrecovery routine only increments a count of the number of errors detected.andO;When control is returned to the faulty code, the error recurs, resulting inan infinite loop.andM;Signed CharactersandM;The ASCII character code is designed so that codes normally fall in the rangethat ca be represented in seven bits.andP;  The equation processor (eqn) depeds onthis assumption.andP;  Characters are read into an array of siged 8-bit integers(the default of signed vs.andP;  unsigned characters in C varies from compiler tocompiler).andP;  These characters are then used to compute a hash function.andP;  If an8-bit character value is read, it will appear as a negative number and resultin an erroneous hash value.andP;  The index to the hash table will then be out ofrange.andP;  This problem can be easily fixed by using unsigned values for thecharacter buffer.andP;  In a more sophisticated language than C, characters andstrigs would be identified as a specific type not related to integers.andM;This error does not crash all versions of adb.andP;  The consequence of the errordepends on where in the address space is accessed by the bad hash value.andO;(This error could be considered a subcase of the pointer/array errors.)andM;Race ConditionsandM;Unix provides a signal mechanism to allow a program to asynchronously respondto unusual events.andP;  These events include keyboard-selected functions to killthe program (usually control-C), kill the program with a core dump (usuallycontrol-\), and suspend the program (usually control-Z).andP;  There are someprograms that do not want to allow themselves to be interrupted or suspended;they want to process these control characters directly, perhaps taking someintermediate action before terminating or suspending themselves.andP;  Programsthat make use of the cursor motions features of a terminal are examples ofprograms that directly process these special characters.andP;  When these programsstart executing, they place the terminal device in a state that overridesprocessing of the special characters.andP;  When these programs exit, it isimportant that they restore the device to its original state.andM;So, when a program, such as emacs, receives the suspend character, it appearsas an ordinary control-Z character (not triggering the suspend signal).andO;Emacs will, on reading a control-Z, do the followig: (1) reset the terminalto its original state (and will now respond to suspend or terminate signals),(2) clean up its internal data structures, and (3) generate a suspend sigalto let the kernel actually stop the program.andM;If a control-\ character is received on input between steps (1) and (3), thethe program will terminate, generating a core dump.andP;  This race condition isinherent in the Unix signal mechanism since a process cannot reset theterminal and exit in one atomic operation.andP;  Other programs, such as vi andmore, are also subject to the same problem.andP;  The problem is less likely inthese other programs because they do less processing between steps (1) and(3), providing a smaller widow of vulnerability.&quot;andM;Undetermined ErrorsandM;The last two columns of Table IV list the programs where the source code wascurrently not available to us or where we have not yet determined the causeof the crash.andM;ConclusionsandM;This project started as a simple experiment to try to better understand anobserved phenomenon--that of programs crashing when we used a noisy dial-upline.andP;  As a result of testig a comprehensive list of utility programs onseveral versions of Unix, it appears that this is not an isolated problem.andO;We offer two tangible products as a result of this project.andP;  First, weprovide a list of bug reports to fix the utilities that we were able tocrash.andP;  This should qualitatively improve the reliability of Unix utilities.andO;Second, we provide a simple-to-use, yet surprisingly effective test method(and tools).andM;We do not claim that our tests are exhaustive; formal verification isrequired to make such strong claims.andP;  We cannot even estimate how many bugsremain to be found in a given program.andP;  But our simple testing technique hasdiscovered a wealth of errors and is likely to be more commonly used (atleast in the near term) than more formal procedures.andP;  Our tests appear todiscover errors that are not easily found by traditional testing practices.andO;This conclusion is based on the results from testing AIX 1.1 Unix.andM;Comments on the ResultsandM;Our examination of the results of the tests have exposed several commonmistakes made by programmers.andP;  Most of these mistakes involve areas alreadyknown to experienced programmers, but an occasional reminder is sometimeshelpful.andP;  From our inspection of the errors found, we suggest the followingguidelines:andM;(1) Check all array references for valid bounds.andP;  This is an argument forusing range checking full-time.andP;  Even (especially!) pointer-based arrayreferences in C should be checked.andP;  This spoils the terse and elegant styleoften used by experienced C programmers, but correct programs are moreelegant than incorrect ones.andM;(2) Be sure that all input fields are bounded--this is just an extension ofguideline (1).andP;  In Unix, using &quot;%s&quot; without a length specification in aninput format is a bad idea.andM;(3) Check all system call return values; do this checking even when an errorresult is unlikely and the response to an error result is awkward.andM;(4) Check pointer values often before using them.andP;  If all the paths to areference are not obvious, an extra sanity check can help catch unexpectedproblems.andM;(5) Judiciously extend trust to others; not all programmers exercise the samestandards of carefulness.andP;  If using someone else's program is necessary, makesure that the data its fed has been checked.andP;  This is sometimes called&quot;defensive programming.&quot;andM;(6) In redefining something to look too much like something else, aprogrammer may eventually forget about the redefinition.andP;  He or she thenbecomes subject to problems that occur because of the hidden differences.andO;This may be an argument against excessive use of procedure overloading inlanguages such as Ada or C++.andM;(7) Error handlers should handle errors.andP;  These routines should be thoroughlytested so that they do not introduce new errors or obfuscate old ones.andM;(8) Goto statements are generally a bad idea.andP;  Dijkstra observed this manyyears ago [1], but it is difficult to convince some programmers.andP;  Our searchfor the cause of a bad pointer in the prolog interpreter's main loop wascomplicated by the interesting weaving of control flow caused by the gotostatements.andM;Comments on Lurking BugsandM;An interesting question is: why are there so many buggy programs in Unix?andO;This section contains commentary and speculation; it should be consideredmore editorial than factual.andP;  It is our experience that we often encounterbugs in programs, but ignore them; we do so, not because they are not serious(they often cause crashes).andP;  There are, however, two reasons for ignoringbugs: First, it is often difficult to isolate exactly what activity causedthe program to crash.andP;  Second, it's quicker to try a slightly differentmethod to get the current job done than it is to find and report a bug.andM;As part of an informal survey of the Unix user community in our department(comprising researchers, staff, and students on several hundred Unixworkstations), we asked if they had encountered bugs that they had notreported to anyone.andP;  We also asked about the severity of the bugs and whythey had not reported them.andP;  Many users responded to the survey and all (butone) reported finding bugs that they did not report; about two-thirds ofthese bugs were serious ones.andP;  The commentary of the various users speaks foritself.andP;  Following are quotes from the responses of several users:andM;&quot;Because andless;name of research toolandgt; was involved, I figured it is toocomplicated.andP;  Besides, by changing a few parameters, I would get a core imagethat dbx would not crash on, thus preventing me from really having to dealwith the problem.&quot;andM;&quot;My experience is that it is largely useless to report bugs unless I cansupply algorithms to reproduce them.&quot;andM;&quot;I haven't reported this because recovery from this error is usually fast andeasy...That is, the time and effort wasted due to a single occurrence of thebug is usually smaller than the time needed to report it.&quot;andM;&quot;I don't generally report problems because I have gotten the impression overthe years that unless it's a security hole in mail or something, eitherno-one will look at it, they will chalk it up to a one-time event or usermistake, or it will take forever to fix.&quot;andM;Some users are easy to please.andP;  We received one response from our survey thatstated:andM;&quot;I have not encountered any bugs in Unix software.&quot;andM;The number of bugs in Unix might also be explained by its evolution.andP;  Unichas suffered from a &quot;features are more important than testing&quot; mentality.andP;  Inits early years, it was a research-only tool.andP;  The commercial effort reuqiredto do complete testing was not part of the environment in which it was used.andO;Later, the Berkeley Unix v. System V (&quot;tastes great&quot; v. &quot;less filling&quot;)competition forced a race for features, power, and performance.andP;  Absent fromthat debate was a serious discussion of reliability.andP;  There were some claimsthat the industry version (System V) had support when compared to that of auniversity product.andP;  Support for Unix seems to be more concerned with usercomplaints than with releasing a significantly more reliable product.andM;Unix should not be singled out as a buggy-operating system.andP;  Its strengthshelp make its weaknesses visible--testing programs under Unix wasparticularly easy because of the mix-and-match modularity provided by pipesand standard I/O.andP;  Other systems must undergo similar tests before anyconclusion can be made about Unix's reliability compared to other systems.andM;More to DoandM;We still have many experiments left to perform.andP;  We have tested only theutilities that are directly accessible by the user.andP;  Network services shouldalso receive the same attention.andP;  It is a simple matter to construct aportjig program, analogous to our ptyjig, to allow us to connect to a networkservice and feed it the output of the fuzz generator.andP;  A second area toexamine is the processing of command-line parameters to utilities.andP;  Again, itwould be simple to construct a parmjig that would start up utilities with thecommand-line parameters being generated by the random strings from the fuzzgenerator.andP;  A third area to study is other operating systems.andP;  While Unixpipes make it simple to apply our techniques, utility programs canstill betested on other systems.andP;  The random strings from fuzz can be placed in afile and the file used as program input.andP;  A comparison across differentsystems would provide a more comprehensive statement on operating-systemreliability.andP;  A fourth area is using random testing to help find securityholes.andP;  The testing might involve sending programs random sequences ofnonrandom key or command words.andM;Our next step is to fix the bugs that we have found and reapply our tests.andO;This retesting may discover new program errors that were masked by the errorsfound in the first study.andP;  We believe that a few rounds of testing will beneeded before we reach the limits of our tools.andM;We are making our testing tools generally available and invite others toduplicate and extend our tests.andP;  Initial results coming in from otherresearchers match the experiences in this report.andM;(1) Only the csh utility was tested on the IBM RT/PC.andP;  More complete testingis in progress.andM;ReferencesandM;[1] Dijkstra, E. W. GOTO Statement Considered Harmful.andP;  Commun.andP;  ACM 11, 3(March 1968), 147-8.andM;[2] Rochlis, J. A., and Eichin, M. W.andP;  With microscope and tweezers: The Wormfrom MIT's perspective.andP;  Commun.andP;  ACM 32, 6 (June 1989), 689-698.andM;[3] Spafford, E. H.andP;  The Internet Worm: Crisis and aftermath.andP;  Commun.andP;  ACM32, 6 (June 1989), 678-687.andM;[4] Wood, D. A., Gibson, G. A., and Katz, R. H.andP;  Verifying a multiprocessorcache controller using random case genration.andP;  Computer Science Tech.andP;  Rep.andO;UCB/CSD 89/490, University of California, Berkeley (January 1989).andM;CR Categories and Subject Descriptors: D.2.5 $([Software Engineering]:testing and debugging; D.4.9 [Operating Systems]: Systems Programs andUtilitiesandM;General Terms: ReliabilityandM;Additonal Key Words and Phrases: UnixandM;BARTON P. MILLER is an associate professor of computer science at theUniversity of Wisconsin-Madison.andP;  His research interests include parallel anddistributed debugging, network management and naming service, distributedoperating systems, and user interfaces.andP;  Author's Present Address: ComputerScience Department, University of Wisconsin-Madison, 1210 W. Dayton St.,andO;Madison, WI 53706.andP;  email bar@cs.wisc.edu.andM;LARS FREDRIKSEN is a member of the technical staff at ATandamp;T Bell Labs.andP;  Hisresearch interests include software development dealing with real-timedatabase and operating systems, development tools and applicationprogramming.andP;  Author's Present Address: ATandamp;T Bell Labs, 2000 N. NapervilleRd., Naperville, IL 60566.andP;  email L.Fredriksen@att.com.andM;BRYAN SO is a Ph.D.andP;  candidate at the University of Wisconsin-Madison.andP;  Hisresearch interests include hypertext systems and expert systems.andP;  Author'sPresent Address: Computer Sciences Department, University ofWisconsin-Madison, 1210 W. Dayton St., Madison, WI 53706.andP;  emailso@cs.wisc.edu.andO;</TEXT></DOC>