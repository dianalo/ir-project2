<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-679-062  </DOCNO><DOCID>08 679 062.andM;</DOCID><JOURNAL>Patricia Seybold's Network Monitor  July 1990 v5 n7 p16(10)* Full Text COPYRIGHT Seybold Office Computing Inc 1990.andM;</JOURNAL><TITLE>MetaCourier: the shape of network programming to come.andO;</TITLE><AUTHOR>Rymer, John R.andM;</AUTHOR><DESCRIPT>Product:   metaCourier (Computer program) (usage).andO;Topic:     NetworksDistributed ProcessingApplications Programming InterfaceTrendsOpen Software Foundation.andO;Feature:   illustrationchart.andO;Caption:   A MetaCourier computation. (chart)The MetaCourier kernel. (chart)In-filters and out-filters. (chart)andM;</DESCRIPT><TEXT>MetaCourierandM;AS THE Open Software Foundation (OSF) and Sun Microsystems argfue over whichhas the better RPC-based distributed computing environment, some developersare asking a disturbing question: Is RPC (remote procedure call) the best wecan do for a distributed application programming interface (API)?andP;  RPCs movethe developer one step away from the network details, but what about movingtwo, three, or even four steps?andM;Even RPC proponents acknowledge the need to progress from what's availabletoday to a more abstract and flexible model of distributed-applicationdevelopment than the one RPCs provide today.andM;There are alternatives to the popular RPCs.andP;  One of these is MetaCourier, adistributed computing environment from Symbiotics Incorporated, based inCambridge, Massachusetts.andP;  MetaCourier uses the message-passing model andobject-oriented development techniques to present developers with ahigher-level API for network applications than do RPCs.andM;What Is MetaCourier?andM;Symbiotics was founded in 1986 by Robert Paslay and Bruce Cottman to builddistributed systems technology, with emphasis on deploying expert systems ina distributed environment.andP;  Six months after its founding, Symbioticsreceived funding under the U.S.andP;  Army Small Business Innovative Research(SBIR) program to develop a generalized distributed application developmentenvironment.andP;  Bruce D. Nilo, the company's chief technologist, was then hiredto help develop MetaCourier.andM;The Army's interest in an environment like MetaCourier arose out of its largebase of PCs and VAX/MS machines.andP;  In late 1986, there were no RPCs availableto tie those two platforms together.andP;  Interestingly, even though RPCs havespread, they're most common on Unix platforms.andP;  MetaCourier still operatesacross more platforms today than RPCs do.andM;MetaCourier is an API and a message-passing environment which provides avirtual platform independent of processor architecture, operating system, andcommunications protocols.andP;  &quot;Agents,&quot; the fundamental computational unit inMetaCourier, perform the tasks in a distributed application.andP;  Each agentfulfills a specific role within a distributed task, acting on behalf of anapplication program or another agent.andM;THE RPC COMPARISON.andP;  Symbiotics often compares MetaCourier to RPCs.andP;  Bothtools support distribution of function in applications, but at differentlevels.andM;In MetaCourier's message-passing model, commands, files, and data aretransported between peer processes, masking the differences between hardwareand operating system environments.andP;  These peers may be dynamically configuredas clients or servers, and they support bidirectional information flows.andO;And, because a high level of abstraction is employed, Symbiotics can supporta large number of incompatible systems, even the Macintosh and Lisp-based AIsystems.andP;  Message-passing offers an attractive model in applications that are&quot;conversational&quot; in nature.andM;The RPC model is more structured, with clients typically calling on remoteservers to complete a function.andP;  Client and server roles are typically fixed.andO;RPC extends across networks the procedure-call programming paradigm, whichallows millions of programmers to ease into distributed applicationsdevelopment.andP;  The major RPCs are closely tied to the Unix concepts ofprocesses and threads; they haven't been implemented across a wide number ofoperating system platforms.andM;When Symbiotics built MetaCourier, the differences between it and the majorRPCs--NCS and Sun's RPCgen--were very wide.andP;  Recently, the differences havenarrowed as HP/Apollo and Sun have enhanced their RPCs to provide support forasynchronous operations and other features which are found in MetaCourier.andO;The current distinction, which is discussed below, is really between twolevels of abstraction and availability across a variety of systems.andM;METACOURIER DISTRIBUTED APPLICATIONS.andP;  MetaCourier is particularlywell-suited to integrating incompatible applications on many diverseplatforms and operating systems.andP;  A distributed application, as defined inMetaCourier, is a set of application programs and cooperating agents thatexecute concurrently on separate processors--or single processors as well--ona network.andP;  Agents execute in a task context defined by MetaCourier SystemObjects, which are called hosts and environments.andM;A distributed computation within a MetaCourier application is a rooted,dynamic graph of communicating objects.andP;  (See Illustration 1.)andP;  In fact,every element of a MetaCourier distributed application--files, programs,devices, entire systems--is an object defined by its characteristics andrelations to other objects.andP;  The relations are codified, allowing each objectto properly interpret information passed to it by other objects.andM;Every distributed computation begins with a root application executing a Tellcommand, which passes an agent a message.andP;  It proceeds outward on the graphfrom agent to agent(s), returning along the same path(s) with an answer.andP;  Agood example of an application in which MetaCourier particularly excels is adecision-support task involving data from multiple databases.andP;  MetaCourierallows the user to issue database requests from within a spreadsheet, withagents interpreting the requests for each database involved and returning therequested information when the databases complete their processing.andM;Applications communicate with agents by using the Tell command.andP;  Agentscommunicate with other agents by using the Pass command to send or forwardmessages over the network.andP;  Messages are passed asynchronously betweenagents.andM;An agent may play one of three roles in a distributed computation: a root,intermediate, or terminating agent.andM;* A root agent is invoked by a Tell command.andP;  It usually passes on themessage generated by the Tell command to one or more agents for furtherevaluation and processing.andM;* An intermediate agent receives a message from the originating agent andpasses it on to another agent(s) for evaluation and processing.andM;* A terminating agent receives a message, processes it, and places the resultin a message.andP;  MetaCourier's run-time environment picks up the message andsends it back along the path through the intermediate agents to the rootagent.andM;Each Tell command generates a unique Transaction Identifier for thedistributed computation.andP;  All messages generated by subsequent Pass commandsretain this identifier.andP;  The Tell command also returns the identifier to theapplication program issuing the Tell; the application can use the identifierto query the status of the computation and obtain the final result.andM;Architecture and ComponentsandM;MetaCourier segments the application-specific functions, control,communications, and dependencies on network, operating system, and languageswithin a distributed application.andM;KERNEL.andP;  The kernel is the environment which manages the interactions amongthe operating systems, the network, and MetaCourier objects.andP;  It is anextension of the native operating system of the particular machine it resideson, running concurrently with the operating system.andM;MetaCourier's kernel comprises three logical processes: the Agent Scheduler,the Outgoing Message Processor, and the Incoming Message Processor.andP;  (SeeIllustration 2.)andM;The MetaCourier kernel provides a consistent message-passing interface acrossall hardware and operating systems.andP;  It also provides three services:andM;* It encodes MetaCourier messages and translates data from one format toanother.andM;* It manages message queues and schedules agents.andM;* It multiplexes and transmits messages over the network.andM;LANGUAGE EXTENSIONS.andP;  Meta-Courier provides object-oriented syntax andcommand extensions that support multiple inheritance for C, Pascal, Fortran,and other languages.andP;  The only constraint on this approach is that thecompiler in use on a MetaCourier system must provide code that islink-compatible with the API libraries in MetaCourier.andP;  In Lisp, MetaCourierworks as an embedded language.andP;  MetaCourier accomplishes the languagemappings using its own language preprocessor, which transforms nativelanguages into object-method definitions.andM;PROCESS CONTROL.andP;  MetaCourier's process control structure is a dynamicallyreconfigurable asynchronous communications tree.andP;  Developers can specify thatan interaction between agents be synchronous or asynchronous by usingdifferent API calls.andM;DEVELOPMENT ENVIRONMENT.andP;  The MetaCourier development environment allowsdevelopers to dynamically create, change, and migrate agents.andP;  If a developerchanges the attributes of an agent that is the parent object of other agents,those other agents simultaneously inherit the modifications.andM;MetaCourier includes a development toolkit containing the commands to define,describe, edit, print, and destroy MetaCourier agents and other objects, andto query MetaCourier databases.andP;  The development toolkit contains functionlibraries to aid development of distributed applications.andM;FUNCTION LIBRARIES.andP;  One of the MetaCourier toolkit function libraries helpsdevelopers implement agent methods.andP;  It contains functions for:andM;* Initialization and exitingandM;* Sending messages with a Pass commandandM;* The display interfaceandM;* Querying object attributesandM;* Querying the fields, or slots, of a messageandM;* Setting the vaues of certain slots of a message.andM;Two other libraries help developers to interface application programs withagents.andP;  One of these contains linkable functions; the other, executableutilities.andP;  Both contain functions for sending messages to agents via a Tellcommand, querying the status and accessing the results of a MetaCouriercomputation or transaction initiated by a Tell command, and retrieving andprocessing messages from an agent's queue.andM;RUN-TIME ENVIRONMENT.andP;  The run-time version of MetaCourier does not include adevelopment environment.andP;  It can only load and execute MetaCourierapplications.andP;  Applications are compiled and can't be modified at run-time.andO;The run-time environment is static.andM;Agents and Other ObjectsandM;MetaCourier is defined as an object-oriented system, with three differenttypes of objects: Agents, Hosts, and Environments.andP;  (See Illustration 4, page20.)andP;  Using simple templates, developers can build objects by defining boththeir attributes and the methods they support.andM;AGENTS.andP;  MetaCourier agents define (in code) the computations to be performedby an application in a particular environment running on a specified system.andM;Agents support three principal methods, or message handlers: an in-filtermethod, a finished-p method, and an out-filter method.andP;  These methods containthe code that receives and act on the messages directed to the agent.andP;  Aninstance of an agent object is an executing or waiting process.andP;  All themethods the agent object supports are coded in the language associated withthat agent's environment.andP;  (See Illustration 3.)andM;In-Filter Method.andP;  The in-filter method executes whenever the agent receivesa message proceeding away in the control tree from the root agent.andP;  Thein-filter performs a variety of tasks, depending on the agent's position inthe distributed computation.andP;  In root and intermediate agents, the in-filteralways directs the continuation of the computation's flow by sending themessage to another agent or agents, invoking them with Pass commands.andO;Depending on the values of the arguments in the message, the receivingagent's in-filter determines which other agents to direct the message to orperforms a variety of other tasks, like reading in a file and changing theargument of the message based on that file.andM;A terminating agent's in-filter method computes a result, which the kernelsends back in the reply field of a reply message.andP;  The terminating agent maycompute the result itself or it may call an application program--a DBMS, aspreadsheet--to compute the result.andM;Finished-p Method.andP;  The finished-p method executes whenever the agentreceives a reply message destined for a root agent.andP;  Terminating agents don'tuse the finished-p method.andP;  The intermediate and root agents' finished-pmethods examine the reply message(s) received to determine how to react.andM;Out-Filter Method.andP;  The out-filter method executes whenever an agent'sfinished-p method has returned the value &quot;t,&quot; or true.andP;  A t value means thefinished-p has received all of the results required for completion of thecomputation.andP;  The out-filter computes the final result (the finished-p methodmay have already have done some processing), puts it into the result field ofa reply message, and returns.andM;When the out-filter returns, several possible operations are triggered.andP;  Inintermediate agents, the return causes the reply message to be sent to thenext agent in the computational path.andP;  In root agents, no reply message issent.andP;  Rather, the root agent stores the result by transaction identifier forlater retieval by the application through the API functions.andM;Agent Object Attributes.andP;  In addition to its three methods, each MetaCourieragent also has attributes, including:andM;* The name of the host where the agent residesandM;* The name of the environment that will interpret the code in the agent'smethodsandM;* A list of additional methods that will execute when called from thein-fiter, finished-p, out-filter, or other methodsandM;SYSTEM OBJECTS.andP;  A system object captures the structure of a networknode--its address, host hardware, and operating system.andP;  Each system objecthas a name and a set of attributes, which include the following:andM;* Network addressandM;* A unique integer used to calculate transaction identifiersandM;* The default number of seconds the kernel will wait for acknowledgement fromthis node before timing outandM;* The processor typeandM;* The operating systemandM;* The name of the default environment if the environment is not specified ina Tell or Pass commandandM;* The pathname of the directory in which definitions of environment objectsare storedandM;* The pathname of the directory in which the MetaCourier kernel residesandM;Every network node has a system object definition of itself as well asdefinitions of every orhwe host on the network with which it willcommunicate.andP;  Each host maintains as identical copy of this information in ahost database file.andP;  The current version of MetaCourier does not provide amechanism to synchronize these host object databases.andP;  Clearly, this is aproblem requiring urgent attention by Symbiotics.andM;ENVIRONMENT OBJECTS.andP;  The environment objet provides MetaCourier with thefacilities to act as an extension of a language.andP;  These objects describe thelanguage environment in which the agent is defined, including the editor,compiler, and linker dependencies.andP;  An agent's environment determines how thecode in the agent's methods will be compiled and linked.andP;  Environment objectscan contain methods that encode data-types into an internal canonical formand decode them into the appropriate platform-specific form.andM;Like system objects, environment objects have names and attributes.andP;  For mostsupported languages, these include:andM;* The name of the hostandM;* The pathname of the editor used to create and modify objectsandM;* The symbol to be used as a filename extension for source code generatedwithin the MetaCourier Development Toolkit (example: .C)andM;* The name of the compiler used for the agent's methodsandM;* A list of switches used to select compiler optionsandM;* The name of the linker used when the object code is linkedandM;* A list of switches used to select linker optionsandM;* The pathname of the library containing the routines used by the linker forexternal function resolution when implementing agent methodsandM;* The pathnames to other function libraries used by the liner (example: Thepathname to the library of C-support functions for interfacing with SQLdatabases)andM;* The pathname of the directory storing definitions of persistent andpermanent agentsandM;Object Lifetimes.andP;  A MetaCourier object may be defined with a lifetimeattribute as being an &quot;:image&quot;, &quot;:persistent&quot;, or &quot;:permanent&quot;.andP;  The :imageobjects are loaded into memory but not stored on disk.andP;  They exist only forthe duration of the development session.andP;  Objects with :persistent or:permanent attributes are stored to disk.andM;When MetaCourier is restarted, it loads into memory all agents andenvironments that have been defined with a lifetime attribute of :persistent.andO;It loads agents or environments with an attribute of :permanent into memoryonly on demand.andM;Inheritance.andP;  Agent and Environment objects can inherit attributes andmethods from other agents and environments.andP;  Each Agent and Environmentobject has a :type attribute that determines which other agents andenvironments it inherits attributes and/or methods fromandM;As agents and environments are defined and redefined during programdevelopment, MetaCourier automatically updates all affected objects in theinheritance lattice.andP;  If the :type attribute of an object is leftunspecified, that object inherits from the appropriate base object.andM;The Messaging ProcessandM;To the developer, messages are the interface between applications and agentsand between agents and agents.andP;  Messages are MetaCourier's base unit ofcurrency.andP;  Messages passed between agents contain values or results.andP;  Themessage-passing paradigm shields developers from many communications details.andM;The internal working of the messaging process are as follows.andP;  Messages aremultiplexed to their correct communications port--one port per active networknode.andP;  Communications routines then manage the transport, network, and linklayer protocols, and they control the reliable transport of the message overthe network to its destination.andM;Message connections remain open indefinitely while there is communicationbetween the hosts.andP;  To support scalability and a dynamic host environment,connections may be activated or deactivated at any time by either side.andP;  If amessage is directed to a port that is not currently active, an active portthat has not recently seen traffic will be deactivated and the new one willbe activated.andP;  This scheme is analogous to virtual memory-paging.andM;When the MetaCourier message arrives at the host on which the agent to whichthe message was addressed resides, the same process takes place in reverse.andO;The incoming message processor demultiplexes the byte streams arriving fromvarious communications ports, parses and decodes the headers, assembles themessages, and then places them into the MetaCourier kernel's scheduler queue.andM;If there are no other messages of higher priority waiting in the &quot;incoming&quot;scheduler queue for this particular agent, the scheduler process invokes aninstance of the agent by scheduling a new process.andP;  If the message is from aremote host, the content of each field (slot) of the message is convertedfrom the canonical data format used for transmission over the network intothe data format specified by the agent's environment.andP;  The agent's in-filterexecutes and then returns.andM;If the agent is an intermediate agent, it passes the message on to otheragents and &quot;goes to sleep.&quot;andP;  It will be reinvoked by the arrival of replymessages.andP;  After all appropriate reply messages are received and processed,the agent's out-filter executes and returns.andP;  A reply message is sent backacross the network, and the agent (process) terminates.andM;Three types of commands/events trigger the encoding, transmission, anddelivery of a message: Tell, Pass, and Reply.andM;TELL COMMAND.andP;  The Tell command sends messages from the application to a rootagent which flow outward along the computational path.andP;  When a Tell commandis exeucted, the code associated with it determines the relevant informationand encodes the information into a valid message structure.andM;If the agent to which the Tell command is directed resides on the same hostsystem as the sender of the message, the message is placed in the localkernel's scheduler queue.andP;  The agent scheduler then takes control, and thelocal agent is scheduled and run.andP;  If, on the other hand, the agent to whichthe message is being sent resides on a different node, the code associatedwith the Tell function uses the encode method of the local host's defaultenvironment to convert the content of each slot of the message from thenative data formats of the local host to a canonical representation fortransmission over the network.andP;  It then attaches a MetaCourier-specificheader to the message and places it in the kernel's outgoing message queue.andM;PASS COMMAND.andP;  The Pass command passes messages between agents in aMetaCourier application.andP;  It is identical to the Tell command.andM;REPLY MESSAGES.andP;  Reply messages are sent at the completion of an agent'sout-filter (reply-processing) method.andM;Developing a MetaCourierandM;Distributed ApplicationandM;The MetaCourier development process follows the object-oriented paradigm,which requires a change in thinking about what an application is.andP;  The RPCmodel does not require the developer to switch paradigms, which is ashort-term advantage of the approach.andM;To build a MetaCourier application, the developer must first define andimplement agents, along with the graph of message flows that will link andcontrol the passage of messages between the agents.andP;  Next, the developerdefines the interfaces between agents and applications.andP;  (See Illustration5.)andM;Developers define MetaCourier objects using the MetaCourier DevelopmentToolkit, which helps them code object methods in the supported language andthen check and test the status of objects in the MetaCourier network.andM;MetaCourier vs.andP;  RPCandM;MetaCourier competes with RPCs as a way of building distributed applications.andO;There are five broad distinctions between MetaCourier and the major RPCs,Sun's ONC RPC (the RPC Tool from Netwise Incorporated of Boulder, Colorado)and Hewlett-Packard/Apollo's NCS RPC.andP;  They are:andM;* Point-to-point vs.andP;  point-to-multipointandM;* Asynchronous vs.andP;  synchronousandM;* Ease of developmentandM;* PerformanceandM;* Range of supported systemsandM;POINT-TO-POINT VS.andP;  POINT-TO-MULTIPOINT.andP;  RPCs are built on the notion ofpoint-to-point communications.andP;  An active client process issues a procedurecall to a passive remote process, which responds as required.andP;  Sun andHP/Apollo both have augmented this model with a broadcast protocol thatallows a single process to send an RPC to every element on the network.andM;MetaCourier isn't built on any particular model.andP;  Symbiotics has implementeda point-to-point protocol as well as a point-to-multipoint protocol.andP;  Apoint-to-multipoint protocol can support a broadcast and also more targetedcommunications between one agent and a number of others.andM;ASYNCHRONOUS VS.andP;  SYNCHRONOUS.andP;  In general, RPCs use a synchronouscommunications model that assumes one RPC for each desired result.andP;  Thismodel works fine for many applications, but it can be inefficient inapplications that require intermediate processing and results before thefinal result is obtained.andP;  First, every result, intermediate or final,requires a separate RPC.andP;  Second, the base RPC model assumes that tasks willbe processed in a serial sequence.andP;  thus, intermediate results potentiallycan block the completion of a task.andM;Both Sun and HP/Apollo have added support for asynchronous operations totheir environments.andP;  In both cases, an asynchronous RPC is marked as such.andO;It operates within a thread within a process, returning its result to aqueue.andM;MetaCourier's base model is asynchronous communications.andP;  The originatingprocess does not have to wait until a server completes a calculation beforeproceeding with the other steps in the task.andP;  Developers can make a messagesynchronous using a single command: Tell and Block.andM;HOW COMPLEX IS DEVELOPMENT?andP;  An RPC is a lower level API than MetaCourier.andO;The general rule that higher level APIs are easier to use than loser levelinterfaces applies.andP;  The preceding discussion about asymmetry vs.andP;  symmetryillustrates the potential differences between RPC and MetaCourier asdevelopment environments.andP;  To issue an asymmetric RPC in Sun's ONC, forexample, a developer must change the implementation of the RPC for thatspecific case.andP;  In MetaCourier, developers switch modes using differentcommands.andM;The industry is awah in hype about rPCs and how much they ease development ofdistributed applications.andP;  Unfortunately, all blanket statements that onemethod or another is easy to use should be taken with a grain of salt.andP;  Easeof use depends on the applications task and the individual developer'sexperience.andP;  One reason RPC is such a hot technology right now is that itconforms to the programming model used by millions of programmers.andP;  It's onething to use an RPC to invoke a remote procedure, but quite another tomaintain effective control structures over a complex web of RPCs in aheterogenous environment.andP;  MetaCourier's use of the object-oriented paradigmand implicit control structures can simplify applications developmentsignificantly.andP;  However, the object paradigm requires a change in thinkingand approach that most typical developers have not yet made.andM;METACOURIER PERFORMANCE.andP;  In most applications, an RPC will perform fasterthan MetaCourier.andP;  An RPC is a lower level interface while Meta- Courier'srun-time kernel imposes additional overhead on operation as it coordinatesagent messages and resolves the differences among operating systems,compilers, linkers, and protocols.andM;SUPPORT OF HETEROGENOUS ENVIRONMENTS.andP;  MetaCourier is available on a numberof environments now.andP;  (See Illustration 6, page 23.)andP;  This has helped gainMetaCourier a following among AI developers working in Lisp and Prolog, aswell as organizations with a hodgepodge of systems.andP;  By comparison, the newfeatures included in Sun's ONC Roadmap will start rolling out later thisyear.andP;  And OSF's Distributed Computing Environment (DCE) is a longer-termproject.andP;  Sun's ONC, at this point, is closely associated with Unixplatforms.andP;  OSF's DCE is designed to be independent of operating system andhardware dependencies.andM;Development PrioritiesandM;Symbiotics has been focused on making MetaCourier work reliably and work overa number of platforms.andP;  Paslay, Nilo andamp; Company will continue to port toadditional platforms and will work on several other enhancements.andP;  Much ofthis work involves implementing features of the Lisp version of MetaCourierin the C version, which is due in the summer of 1990.andM;Symbiotics has an ongoing effort to improve the performance of MetaCourier.andO;In the next version, agents will work within their own processes.andP;  In thefirst version of the environment, agent operations were multiplexed intosingle processes.andP;  The DOS version is slowed because everything is written todisk.andP;  Future DOS versions will make better use of extended memory, improvingpeformance.andM;The company expects to gain an additional performance boost in certainapplications by implementing support for TCP data streams between agents inthe next version of the environment.andP;  The Lisp version has streams supportnow.andP;  The streams model will allow MetaCourier to support technologies like XWindow, improve the speed of operations like file transfers, and bettersupport real-time applications.andM;The primary development issue Symbiotics faces with MetaCourier is how tosynchronize updates of system object description databases.andP;  Neither the Lispnor the C versions of MetaCourier have update mechanisms.andP;  The company willadd a namespace server sometime after this summer's major release ofMetaCourier, probably in autumn 1990.andP;  The name service will be patternedafter Sun's Network Information Service (formerly known as Yellow Pages).andO;The one major difference: Symbiotics will cache information to mitigate theusual system-wide effect of server crashes.andM;Symbiotics ultimately wants to implement a distributed database scheme toensure that all system object databases are reliably updated.andP;  But this alonger-term project.andM;The final development priority for both versions of MetaCourier isimplementation of an instance-based object system on all versions of theproduct.andP;  An instance-based system allows a computation to be processed andmaintained in parallel by different instantiations of the same agent.andO;Currently, agents have absolute identities and states, which do not persistbetween messages.andP;  This enhancement to MetaCourier will support distributedcomputations like recursion over the network.andM;ConclusionsandM;MetaCourier is an interesting environment that is better than RPCs for someapplications.andP;  We believe MetaCourier's future will hinge on two questions:First, can a small group--12 people--like Symbiotics provide a full-featured,robust distributed computing environment?andP;  So far, Symbiotics hasaccomplished much on its own, but there's more to be done.andP;  Second, howwilling will users be to adopt an environment like MetaCourier without theimplicit backing of the hardware and operating system vendor?andM;If you campare the capabilities of MetaCourier to the OSF's DCE, thedevelopment challenges Symbiotics faces in carrying MetaCourier forwardbecome obvious.andP;  The absence of a name server outlined above is just one ofthe places where MetaCourier needs additional function.andP;  We'd like to seeMetaCourier work with other vendors to help flesh out its environment.andP;  TheRPC vendors themselves are good candidates.andM;The second issue really concerns distribution.andP;  Symbiotics has had its bestsuccess selling MetaCourier to advanced technology groups in largeorganizations.andP;  These customers are willing to take risks as they seek todefine the leading edge or deal with impossible tangles of operating systems.andO;These MetaCourier customers say they have found no other option to buildtheir applications.andP;  &quot;I don't know oa anyone providing this kind of toolacross this number of environments,&quot; said Ken Bowen, president of AppliedLogic Systems of Syracuse, New York.andP;  &quot;The other tools we've seen force toyou to program at the packet level--I've got better things to do with mylife.&quot;andM;However, the broad spectrum of customers will view MetaCourier as platformsoftware, and they'll want their platform vendors--IBM, Digital, HP, Compaq,and so on--to endorse and support MetaCourier.andP;  This will require Symbioticsto build relationship with a variety of platform vendors.andP;  According to BobPaslay, the company has just completed a five-year business plan thataddresses these issues.andP;  The plan will be used to seek outside financing forSymbiotics.andM;Symbiotics is entering the second phase of life as a technology company.andO;Having built very sophisticated technology, its future success will depend onits building a sophisticated business strategy as well.andO;</TEXT></DOC>