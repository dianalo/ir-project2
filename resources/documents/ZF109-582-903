<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF109-582-903  </DOCNO><DOCID>09 582 903.andM;</DOCID><JOURNAL>Hewlett-Packard Journal  Oct 1990 v41 n5 p11(10)* Full Text COPYRIGHT Hewlett Packard 1990.andM;</JOURNAL><TITLE>The HP IVI object-oriented toolkit. (HP Interactive VisualInterface)</TITLE><AUTHOR>Tran, Mydung Thi; Wathen, David G.andM;</AUTHOR><SUMMARY>The HP IVI Application Program Interface (API) permits thesoftware developer to create an interactive and informativegraphical user interface.andP;  API functions supply the ability tobuild different models of user interfaces, which can be saved andused again.andP;  API components are separate objects that are combinedin a hierarchical arrangement.andP;  High-level objects control andorganize groups of objects and hold global resources.andP;  Compositeobjects that organize and manage other objects.andP;  Primitive, basicvisual objects are either graphic primitive or widget primitives.andO;Low-level, standalone objects specify attribute values for theother three groups.andP;  An identifier called Ztld is used to providethe functionality of polymorphism.andP;  API provides reparenting,regrouping of objects by changing relationships, eliminating theneed to destroy the objects and start over to change relationshipsbetween objects.andP;  API is based on an object-oriented framework andis an object-oriented toolkit of C functions.andM;</SUMMARY><DESCRIPT>Topic:     Object-Oriented ProgrammingUser InterfaceSoftware EngineeringC Programming LanguageProgram Development ToolsProduct DevelopmentGraphical User Interface.andO;Feature:   illustrationcharttable.andO;Caption:   The API object hierarchy of a simple application. (chart)API object groups. (chart)Categories of API attributes. (table)andM;</DESCRIPT><TEXT>The HP IVI Object-Oriented ToolkitandM;THE HP IVI APPLICATION PROGRAM INTERFACE (API) is an object-oriented toolkitof C functions that enable a software developer to create an interactive andinformative graphical user interface programmatically.andP;  The API functions canbe used for any application in which a highly interactive graphical userinterface is required.andP;  The collection of API functions provides the abilityto build different models of user interfaces that can be saved and used againin other user interfaces.andP;  High-level objects provide the control andorganization necessary to support lower-level composite and primitiveobjects.andP;  All objects have configurable attributes or characteristics thatmake it possible to customize the look and feel of a particular object.andO;Color, size, and font are a few examples of these attributes.andP;  The APIfunctions allow a programmer to do things like create and free objects, queryattributes, save and restore objects, get input, and find objects bylocation.andM;This article describes the API functions and the article on page 21 describesthe internal design supporting these functions.andM;The API Object HierarchyandM;All the components of an API application are separate objects that arecombined together in a hierarchical arrangement to form a working userinterface.andP;  An example of this hierarchical relationship is shown in Fig.andP;  1.andO;This relationship is described in terms of ancestry.andP;  For instance, Model 12in Fig.andP;  1 is the parent of three children:  Model 21, a rectangle, and arow-column object.andP;  Another way of saying this is that Model 12 is theancestor of three descendants: Model 21, a rectangle, and a row-columnobject.andM;Every API object belongs to one of four groups:  high-level objects,composite objects, primitive objects, or low-level objects.andP;  Fig 2 lists thedifferent API object groups.andM;High-Level Objects.andP;  These objects control and organize groups of objects andhold global resources that help define other objects in the hierarchy.andP;  Thehigh-level objects must be created in a specific order: system object, serverobject, window objects, and model objects.andP;  Before anything can be displayed,at least one of each of these objects must be available.andP;  Since these objectsare required for every application, the API will create default high-levelobjects if they are not explicitly created.andM;The system object is the highest object in the API object hierarchy.andP;  Thisobject stores global attributes that affect the input loop, the update pass,and global resources.andP;  The input loop is composed of the code that handlesuser input and an update pass is the process of flushing changes to thedisplay.andP;  There can only be one system object per application.andP;  All otherobjects (except low-level objects) are descendants of the system object.andP;  Thedirect descendant of a system object must be a server object.andM;A server object is the interface to the display system.andP;  Informationregarding the display and its physical characteristics is stored in thisobject.andP;  The server object establishes the link between the display device(an X11 server) and the user application (the client).andP;  Just like the systemobject, there can only be one server object per application.andP;  Windows are theonly children of the server object.andM;Window objects represent the drawable region of the display.andP;  A window is anarea on a display that connects the world coordinate system (e.g., inches,mm, etc.) defined for a window to the devide coordinates (i.e., pixels) ofthe display system.andP;  The window can be seen as a viewport into the worldcoordinate system.andP;  An application can have any number of windows.andP;  They canoverlap one another and they can be manipulated using a window manager or theAPI functions.andP;  The last high-level object, the model object, is the onlyvalid child of a window object.andM;The model object allows an application to put composite, primitive, or othermodel objects into a single group or collection.andP;  When these objects aregrouped together, functions can be performed on them as if they were a singleobject.andP;  At the same time, each part will retain its individuality.andP;  Modelscan represent a symbol or template than can be saved and restored as manytimes as desired.andP;  Models can have other models, composites, or primitiveobjects as children.andM;Primitive Objects.andP;  These are basic visual objects that are part of one oftwo categories: graphic primitives or widget primitives.andP;  The graphicprimitives are visual objects (e.g., circles, rectangles, and arcs) that canreceive mouse input.andP;  An application can use these objects for graphicallyrepresenting user-oriented objects that display crucial information such asliquid levels and temperature.andP;  The widget primitives (e.g., pushbuttons,scrollbars, and text edits) are also visual objects.andP;  However, unlike thegraphics primitives, widget primitives can receive keyboard input as well asmouse input.andP;  The widget primitives are used for display, text editing andinput, and selection capabilities.andP;  Primitive objects have no children.andM;Composite Objects.andP;  These objects provide the means to organize and manageother objects.andP;  Specifically, composite objects make it possible to groupprimitive widget objects and other composite objects so that they can bemanipulated as a single object.andP;  A function or attribute specified for acomposite object affects its children without actually changing them.andP;  Forexample, erasing or redrawing a row-column object will cause all its childrento be erased or redrawn automatically.andM;Low-Level Objects.andP;  These are objects that are not directly visible likeprimitive or composite objects.andP;  They are stand-alone objects that are usedto specify attribute values for primitive, composite, or high-level objects.andO;Low-level objects are used to set attributes for the other three objectgroups, apply API functions to a list of objects, or deal with user inputfrom the activated objects.andM;Polymorphism and APIandM;One of the key features of object-based systems is the concept ofpolymorphism.andP;  Polymorphism allows different objects to share a commonoperational interface (operations with the same name).andP;  When an operation isinvoked, the function dynamically determines the object type and executes theappropriate code.andP;  Object-oriented programs are polymorphic because they canoperate on many different object types with the same functional interface.andO;This common interface provides a great deal of flexibility and ease of use tothe API programmer.andP;  Common access reduces the number of functions andincreases the power provided by the basic set of functions.andM;The API functions provide the functionality of polymorphism through anidentifier called Ztld.andP;  When an object is created via the ZtCreate function,a Ztld is returned from the call for use in further operations.andP;  The Ztld isa pointer to the object that was just created.andP;  This handle allows theprogrammer to reference the object when additional modifications arenecessary.andP;  The API functions use this identifier to determine the type ofobject being manipulated.andM;Attributes and ArglistsandM;Associated with API objects are attributes that describe properties of theseobjects.andP;  Examples of object attributes include properties that defineappearance characteristics such as colors and fill patterns for graphicobjects, and font, highlight area, and 3D shadowing for widget objects.andO;There are also coordinate system attributes that control the position andsizing of objects, including their point, height, width, scale, rotation, andtranslation.andP;  table I lists the categories of API attributes.andM;There is a specific list of attributes assigned to each API object type.andO;Users can set these attributes to desired values or can query the valuescontained in them through a data structure called an Arglist.andP;  An Arglist isa variable-length array of attribute-value pairs.andP;  The following is the Cstructure declaration for an attribute-value pair.andM;struct ZtArglistStruct { ZtAttribute Type ZtAttribute; ZtValueTypeZtValue; };typedef struct ZtArgListStructZtArgListltem; /*where: */ /* ZtAttribute isthe defined attribute */ /* ZtValueType is defined as a pointer to a */ /*variable containing the attribute value */andM;Arglists are used to define attributes of objects or functions.andP;  Some of theadvantages of using Arglists include:andM;* Arglists free users from fixed parameters in a function call.andP;  The numberof attributes that the user can pass as parameters can vary.andM;* The number of function calls can be minimized by including multipleattributes in the Arglist as opposed to having to use one function call perattribute change.andM;* Attributes can be initialized in the Arglist either statically ordynamically (at run time).andM;API FUNCTIONSandM;Because of polymorphism a minimum number of API functions are required formanipulating API objects.andP;  Polymorphism allows the same API function to beused to handle more than one object.andP;  Table II shows the API functionsavailable for manipulating the object groups shown in Fig.andP;  2.andM;Create and Free ObjectsandM;Objects are created using the function ZtCreate.andP;  Any attributes that arerequired to be different from the defaults can be passed in the objectArgList when calling ZtCreate.andP;  For all the attributes not included in theobject ArgList, the API will automatically set them to defaults.andP;  Once anobject exists, multiple copies of this object can be made by cloning it withthe function ZtClone.andP;  ZtClone also allows the users to alter some of theattributes of the newly cloned objects in the same call.andM;The following example shows the creation of two text objects with one fixedsize, different text strings, and different positions on the display.andP;  Fig.andO;3 shows the data organization resulting from this example.andM;int return_val; Ztld text1_ld, text2_ld, pointld; /* object identifiers */ /*arglist for text object (containing attribute-value pairs) */ staticREAL64h,w; static ZtArgListltem textArglist []= { ZtHEIGHT, (ZtValueType)andamp;h,/* textheight */ ZtWIDTH, (ZtValueType)andamp;w, /* textwidth */ ZtPOINT,(ZtValueType)NULL, /* Ztld for point */ ZtSTRING, (ZtValueType)NULL,/* textstring */ NULL, (ZtValueType)NULL }; /* arglist for point object */ staticREAL64 x, y; static ZtArgListltem pointArglist %} = { ZtX, (ZtValueType)andamp;x,ZtY, (ZtValueType)andamp;y, NULL, (ZtValueType)NULL; } /* create reference pointfor objects */ x = 10.0; y = 10.0; pointld =ZtCreate(ZtPOINT_OBJ,pointArglist,NULL);andM;/* setup to create first text object with height = 20 and */ /* width = 40 */h = 20.0;W = 40.0; textArglist[2].ZtValue = (ZtValueType)pointld;textArglist[3].ZtValue = (ZtValueType)&quot;First text object&quot;; /* create thefirst text object */ text1_ld = ZtCreate(ZtTEXT_OBJ, textArglist, NULL); /*change point components */ y = 60.0; return_val = ZtChange (pointld,pointArglist,NULL);andM;/* create second text object at (10.0,60.0) */ textArglist[3].ZtValue =(ZtValueType) &quot;Second text object&quot;; text2_ld =ZtCreate(ZtTEXT_OBJ,textArglist,NULL);andM;/* free point object if it is no longer needed */ ZtFree(pointld, NULL);andM;Instead of calling ZtCreate twice, the function ZtClone can be used to createthe second text string object: int return_val; Ztld text 1_ld,text2_ld,pointld;/* object identifiers*/ /* arglist for text object(containing attribute-value pairs */ .andP;  .  The text Arglist and the point .andO;Arglist are the same as in the .andP;  previous example.andM;/* arglist for cloned text object */ static ZTArgListltem cloneArglist [] = {ZtPOINT,(ZtValueType)NULL, ZtSTRING,(ZtValueType)NULL, NULL,(ZtValueType)NULL}; .andP;  .  The reference points and the first .andP;  text object are created thesame as .andP;  in the previous example.andM;/* create the second text object at (10,60) using the */ /* ZtClone function*/ y = 60.0; return_val = ZtChange (pointld, pointArglist, NULL);cloneArglist[0].ZtValue = (ZtValue Type)pointld; cloneArglist[1].ZtValue =(ZtValueType)&quot;Second text object&quot;;andM;text2_ld = ZtClone(Text1_ld,cloneArglist, NULL); .andP;  .  .  /* free pointobject if it is no longer needed */ ZtFree(pointld,NULL);andM;ZtClone is particularly useful for models and composite objects.andP;  With onecall, the model or the composite object and its descendants can beduplicated.andP;  A call to ZtClone can be modified to control the depth ofcloning for a list of objects.andP;  In the following example there are two modelobjects that have identical properties except for the background andforeground colors.andP;  The first model object has been created with the childlist model1Id.andP;  Instead of repeating the same process for the second modelmodel2Id, ZtClone is used with the function arglist containing theZtRECURSIVE attribute set to TRUE.andP;  The call ZtChange() changes the colors.andM;intret_val; Ztld model1Id, model2Id; /* objectArglist for colors */ staticZtArgListItem color Arglist [] = { ZtBACKGROUND_COLOR,(ZtValueType)red,ZtFOREGROUNDCOLOR,(ZtValueType)black, NULL,(ZtValueType)NULL }; /*functionArglist for recursive attribute */ static ZtArgListltemrecursiveArglist [] = { ZtRECURSIVE,(ZtValueType)TRUE, NULL,(ZtValueType)NULL} [Mathematical Expression Omitted] model2Id = ZtClone(model1Id, Null,recursiveArglist); ret_val = ZtChange(model2Id,colorArglist,recursiveArglist);andM;Cloning nonrecursively (ZtRECURSIVE = FALSE) can be used in cases whereobjects need to be referenced but copies of these objects are not needed.andO;Fig.andP;  4 shows the data structure that would result after nonrecursivelycloning the objects referenced by the linked list called List1.andP;  Instead ofcopying the objects, a new linked list (List2) of pointers is created forreferencing the objects.andP;  The original and newly cloned list will dereferencethe same objects.andP;  HP IVIBuild, the builder component of HP IVI, makes use ofthis option of ZtClone to duplicate lists of selected objects.andP;  The clonedlists are manipulated through the use of list functions to provide the undoand backup capabilities of HPIVIBuild (see page 36).andM;When an object is no longer needed, the function ZtFree can be used to freeall memory allocated for the object.andP;  Arglists can also be freed using thefunction ZtFreeArgList.andP;  This function will free all memory associated withthe Arglist including the additional memory allocated for attributes.andM;Manipulate AttributesandM;Most attributes of existing objects can be modified.andP;  For example, in anapplication in which a text object contains a string that indicates elapsedtime, the time needs to be updated periodically.andP;  ZtChange can be calledpassing the new value of the elapsed time in the ZtSTRING attribute of theobject Arglist.andM;ZtChange also provides a way to modify several objects in one call.andP;  The usersimply has to put all the desired objects into a list and issue a ZtChangecall on the list object.andP;  The changes will be made to all objects that thelist references.andP;  In the following code fragment the foreground color ischanged for all objects referenced by the identifier listId.andM;/* arglist for foreground color */ static ZtArgListItem fgcArglist [] = {ZtFOREGROUND_COLOR, (ZtValueType)NULL, NULL, (ZtValueType)NULL }; intreturn_val; fgcArglist[0].Ztvalue = (ZtValueType) steelblue /* Steelblue isthe index into the system object's color list */ /* (the ZtCOLOR_LISTattribute on the ZtSYSTEM_OBJ).andP;  */ /* change the color to steelblue */return_val = ZtChange (listId, fgcArglist, NULL);andM;Default values can also be changed with the same call.andP;  To change the valueof a default attribute, the object type and not the objectId must be sent toZtChange.andP;  For instance, if at some point in the program it is desired tohave all the windows have a red background instead of the default blue, acall could be made to ZtChange with the object type set to ZtWINDOW_OBJinstead of the objectId.andM;Information about the current value of an object's attributes or the defaultvalues can be obtained by making use of the ZtQuery call.andP;  If required, APIwill handle the space allocation for the queried values.andP;  The following codefragment is requesting information on a pushbutton object.andM;int return_val; char *querystr; /* arglist for querying string */ staticZtArgListItem qstringArglist [] = { ZtLABEL_STRING, (ZtValueType)NULL, NULL,(ZtValueType)NULL }; /* a copy of the pushbuttonId's label string will bereturned in querystr */ /* after the ZtQuery call.andP;  A return value of FALSEindicates that */ /* memory could not be allocated or an invalid pointer is*/ /* specified in pushbuttonId.andP;  */ return_val = ZtQuery (pushbuttonId,qstringArglist, NULL); querystr = (char*) qstringArglist[0].ZtValue; /* thefollowing call frees the memory allocated for ZtLABEL_STRING */ /* in theZtQuery call.andP;  */ ZtFreeArgList(qstringArglist);andM;Save and Retrieve ObjectsandM;The ZtSave function allows users to save objects in a file.andP;  A filename canbe specified by the user in the function Arglist.andP;  If the file exists, theuser also has the option to overwrite the existing file.andP;  Objects or defaultsof one application can be retrieved easily in another application with theZtRestore call.andP;  In the following example the window windowId is saved into afile named windfile.w.andM;int return_val; Ztld windowId /* filename arglist */ static ZtArgListItemsaveArglist[] = { ZtFILENAME, (ZtValueType)&quot;windfile.W&quot;, ZtOVERWRITE,(ZtValueType)TRUE, NULL, (ZtValueType)NULLandM;};return_val = ZtSave (windowId, saveArglist)andM;Locate ObjectsandM;The capability of locating the closest object near a user-defined point in awindow is provided by the function ZtFindByLocation.andP;  Users can control theaperture of the search (i.e., how close or how far from the point) and thedepth of the search (i.e., whether or not the action should be recursivelyapplied down to primitive objects within any model or composite object).andP;  Forexample, a row-column object contains a pushbutton object, a text object, anda scrollbar object.andP;  A mouse click (i.e., a button event) generated on thepushbutton will cause ZtFindByLocation to return the ZtId of the pushbuttonif the function Arglist contains the value TRUE for the ZtRECURSIVEattribute.andP;  If ZtRECURSIVE is set to FALSE, the return value ofZtFindByLocation will be the Ztld of the row-column object instead of thepushbutton (see Fig.andP;  5)andM;ZtFindByAttribute also enables the user to match objects that have certainproperties.andP;  For example, if an application creates a large number of objectsand some of them are invisible, to find all the invisible objects, theZtFindByAttribute function is used on the window object, passing an objectArglist with the ZtVISIBLE attribute set to FALSE.andM;Receive Input FunctionsandM;Input events like button and key presses can be collected using the functionZtDo(ObjectId, ZtINPUT, NULL).andP;  Where objectId is the ZtId of a system objectand ZtINPUT is the action for ZtDo to do.andP;  The input-handling ZtDo functionretrieves the events and dispatches them to the appropriate callback functionso that the user-defined action can be executed.andP;  User input can be collectedcontinuously or in a single pass.andM;Visual Update FunctionsandM;In addition to getting input, ZtDo provides several other actions.andP;  Itprovides the capabilities to update, draw, redraw, flash, erase, raise, andlower objects on the display.andP;  The following is a list of the differentoperations possible with the ZtDo function.andM;/* redraw all objects whether or not they have been modified */ZtDo(systemId, ZtREDRAW, NULL); /* draw a window */ ZtDo(windowId, ZtUPDATE,NULL); /* flash an object on the display */ ZtDo(pushbuttonId, ZtFLASH,NULL); /* flash the objects on a list */ ZtDo(listId, ZtFLASH, NULL); /*erase a rectangle object */ ZtDo(rectangleId, ZtERASE, NULL); /* erase a listof objects */ ZtDo(listId, ZtERASE, NULL); /* draw a text object whether ornot it has been modified */ ZtDo(textId, ZtDRAW, NULL); /* draw a list ofobjects other than low-level objects */ ZtDo(listId, ZtDRAW, NULL); /* raisea window */ ZtDo(windoId, ZtRAISE, NULL); /* lower a window */ ZtDo(windowId,ZtLOWER, NULL);andM;Two modes of updating or drawing objects on the display are possible:immediate update and deferred update.andP;  In immediate update mode the windowsare redrawn anytime there is a visual change in the objects.andP;  In the deferredmode, the process of redrawing windows can be postponed until an explicitupdate is performed through ZtDo(...ZtUPDATE...), or a change in the updatemode.andP;  This mode is useful if changes need to be made to many objects and itis only necessary to refresh the window once.andP;  Both modes are activated bysetting the system object's update attribute to either immediate or deferred.andO;The following code puts the system object in the deferred update mode.andM;/* update mode arglist for system object */ static ZtArgListItemupdateModeArglist[] = { ZtDEFER_UPDATE, (ZtValueType)TRUE, NULL,(ZtValueType)NULL }; Ztld systemId, windowId; int return_val; /* at somepoint in the application, set update mode to deferred */ return_val =ZtChange (systemId, updateModeArglist, NULL); [Mathematical ExpressionOmitted] /* now it is necessary to redraw one of the windows */ return_val =ZtDo (windowId, ZtUPDATE, NULL);andM;List Manipulation FunctionsandM;The API list manipulation functions allow programmers to create andmanipulate list of objects.andM;Creating an Object List.andP;  The following example creates a list of two pointsusing the function ZtCreateList (see Fig.andP;  6).andM;/* arglist for point object */ static REAL64 x, y; static ZtArgListItempointArglist[] = { ZtX, (ZtValueType)andamp;x, ZtY, (ZtValueType)andamp;y, NULL,(ZtValueType)NULL }; /* Identifiers for pointer objects */ Ztld point1Id,point2Id, point_list; /*Identifiers for pointer objects */ /* create a pointat (50.0,50.0) */ x = 50.0, y = 50.0; point1Id = ZtCreate (ZtPOINT_OBJ,pointArglist, NULL); /* create another point at (60.0,50.0) */ x = 60.0;point2ld = ZtCreate (ZtPOINT_OBJ, pointArglist, NULL); /* create the list forthese two points */ point_list = ZtCreateList (ZtLIST_OBJ, point1Id,point2Id, NULL);andM;Freeing a List.andP;  When the list of objects is no longer needed, it can befreed.andP;  The application has the option to free the list along with all theobjects it references, or to free the list but retain the objects.andM;/* free the point list (point_list) in the example above */ int return_val;static ZtArgListItem recursiveArglist [] { ZtRECURSIVE, (ZtValueType)TRUE,NULL, (ZtValueType)NULL };andM;/* free the list and its references, the two point objects */recursiveArglist[0].ZtValue = (ZtValueType)TRUE; return_val =ZtFree(point_list, recursiveArglist);andM;/* free the list but leave the two point objects alone */recursiveArglist[0].ZtValue = (ZtValueType)FALSE; return_val =ZtFree(point_list, recursiveArglist);andM;Bookeeping.andP;  Three API functions are provided for retrieving informationabout list objects.andP;  These functions include:andM;* ZtCheckListObject for verifying the presence or absence of an object in alist.andM;* ZtCountList for ounting the number of objects in a list.andM;* ZtGetListIndex for determining the position of an object in a list.andM;Extraction.andP;  An object can be extracted from a list of objects by invokingZtGetListObject and specifying the index of the object, or by using thefunction ZtGetListTail to extract the last object in a list.andM;Insertion.andP;  Objects can be inserted into a list by using:andM;* ZtInsertListIndex to place the object at a specified indexandM;* ZtInsertListObject to place the object before an object with a knownidentifierandM;* ZtInsertListTail to place the object at the end of a list.andM;These functions can be used to add an object to the child lists of windows,models, or composite objects.andP;  The following code fragments demonstrate usingthese functions.andP;  Figs.andP;  7a and 7b show the results of the ZtInsertListIndexand the ZtlnsertListObject examples respectively.andM;/* insert an object at location two in list pointListId */ Ztld pointListId,point1Id, newpointListId, insertpointId, refpointId, pointId; int ret;andM;/* pointListId : the ZtId of a ZtLIST_OBJ to insert the object into */ /*point1Id : the ZtId of the object to insert into the list */ /*newpointListId: The ZtId of the new list.andP;  If the function */ /* fails, theoriginal pointListId is returned */ /* in newpointListId.andP;  If the functionsucceeds, */ /* the new list is returned in newpointListId.andP;  */andM;objIndex = 2; ret = ZtInsertListIndex(pointListId, objIndex, point1Id,andamp;newpointListId); [Mathematical Expression Omitted] /* insert an object(insertpointId) into a list (pointListId) */ /* in front of another object(refpointId) */andM;ret = ZtInsertListObject(pointListId, refpointId,insertpointId,andamp;newpointListId); [Mathematical Expression Omitted] /* add apoint object (pointld) to the end of a point list */ /* (pointListId) */andM;ret = ZeInsertListTail(pointListId, pointId, andamp;newpointListId);andM;Merging Lists.andP;  A list of objects can be merged into another list by using:andM;* ZtMergeListindex to place the list at a specified indexandM;* ZtMergeListObject to place the list before an object with a knownidentifierandM;* ZtMergeLisTail to place the list at the end of a list.andM;In the following example three objects of type ZtLIST[OBJ are used toillustrate merging lists.andP;  Listld references three objects (object1ld,object2ld, object3ld), Mergeld references two objects (object4ld andobject5ld), and Newlistld is the list object obtained by merging Listld andMergeld (see Fig.andP;  8).andM;/* Using ZtMergeListIndex to insert all objects of Mergeld */ /* into Listldbetween object1ld and object2ld */ Ztld Listld, Mergeld, Newlistld; int retval; INT32 list index = 1;andM;ret_val = ZtMergeListindex(Listld, list_index, Mergeld, andamp;Newlistld); /* UsingZtMergeListObject to insert all objects of Mergeld into */ /* Listld in frontof object2ldandM;Ztld Listld, Mergeld, Newlistld, object2ld; int ret_val; ret_val =ZtMergeListObject(Listld, object2ld, Mergeld, andamp;Newlistld);andM;Removing Lists.andP;  Objects can be removed from a list by using:andM;* ZtRemoveListindex to remove an object at a specified indexandM;* ZtRemoveListObject to remove an object before an object with a knownidentifierandM;* ZtRemoveListTail to remove an object at the end of a list.andM;Children of windows, models, or composite objects can be deleted by invokingthese functions on the list object specified in the ZtCHILD_LIST attribute.andM;Replacement.andP;  An object can replace another object using:andM;* ZtReplaceListlndex to place the object at specified indexandM;* ZtReplaceListObject to place the object before an object with a knownidentifierandM;* ZtReplaceListTail to place the object at the end of a list.andM;/* replace a point object at the index position of a point /* list(pointlistld) with a new point object (newpointlD) */andM;/* pointlistld : the Ztld of a ZtLIST_OBJ to replace the */ /* object with *//* newpointld : the Ztld of the object to replace the indexed */ /* objectwith */ /* replacedld : the Ztld of the replaced object.andP;  This variable maybe given as NULL if this return value is not of interest.andP;  */andM;Ztld pointListld, replacedld, newpointld; INT32 objIndex = 2; int ret;andM;ret = ZtReplaceListlndex(pointlistld, objlndex, newpointld, andamp;replacedld);andM;/* The next code fragment illustrates using ZtReplaceListObject */ /* Theobject identifiers have the following meanings: */ /* pointListld : same asabove */ /* point_index_ld: the Ztld of the object to replace */ /*newpointld : the Ztld of the object to replace point_index_ld */ /*replacedld : same as above */andM;ret = ZtReplaceListObject(pointListld, point_index_ld, newpointld,replacedld);andM;/* replace the tail object of a point list (pointListld) */ /* with a newpoint object (newpointld) */andM;ret = ZtReplaceListTail(pointListld, newpointld, andamp;replacedld);andM;Grouping and Reparenting ObjectsandM;Using the methods and techniques described so far, objects can be created andgrouped together to form an object hierarchy like the one shown in Fig.andP;  1.andO;This is accomplished using model objects or composite objects.andP;  Model objectsallow an application to group together composite objects, primitive objects,and other model objects into one group.andP;  They are invisible container objectsand they do not own any visual attributes.andP;  Composite objects have visualattributes and they make it possible to group together primitive widgetobjects and other composite objects.andP;  Examples of composite objects includemenus, menu panes, row-columns, and scroll lists.andP;  There are two ways ofcreating model or composite objects in API: creating objects with the childlist attribute (ZtCHILD_LIST), or assigning a group of objects to anotherparent.andM;Creating Composites with ZtCHILD_LISTandM;Using ZtCHILD_LIST, model and composite objects and their descendants can becreated either top down or bottom up.andM;Top Down.andP;  The composite object is created with NULL assigned to the childlist attribute ZtCHILD_LIST.andP;  It then becomes the current composite objectand all newly created primitive objects will automatically become thecomposite's children.andP;  For example, to create a menu system from the top tothe bottom, start from the top of the menu hierarchy and work down creatingchildren.andP;  This process is summarized in the following steps:andM;* Create the menu object ZtMENU_OBJ with the ZtCHILD_LIST attribute set toNULL.andP;  This will make the menu the current composite object.andM;* Create a menu pane object ZtMENUPANE_OBJ.andP;  This will make the menu pane achild of the menu object and also make it the current composite object.andM;* Create the menu button objects.andP;  This will make the menu buttons childrenof the menu pane.andM;* Change the attribute ZtCURRENT_COMPOSITE on the system object(ZtSYSTEM_OBJ) to the menu object created in the first step.andP;  This will makethe menu the parent of the next menu pane.andM;* Repeat the last three steps until all the menu panes and menu buttons arecreated.andM;Bottom Up.andP;  To create a composite object from the bottom up, create allprimitive objects, put them in a list, and then create the composite objectsetting the ZtCHILD_LIST attribute to the Ztld of the object list.andP;  Forexample, to create a menu system from the bottom up, start from the bottom ofthe menu object hierarchy, making the newly created objects children ofobjects higher in the menu hierarchy.andP;  This process is summarized in thefollowing steps.andM;* Create a group of menu buttons and put them in a list object ZtLIST_OBJ.andM;* Create a menu pane with the ZtCHILD_LIST attribute set to the Ztld of theZtLIST_OBJ created in the first step.andM;* Repeat the first two steps until all the menu panes and menu buttons arecreated.andM;* Put all the menu panes into a list object.andM;* Create the menu object with te ZtCHILD_LIST attribute set to the newlycreated ZtLIST_OBJ from the previous step.andM;ReparentingandM;In API it is not necessary to destroy all the objects created and start allover when the user wants to change the objects' relationships.andP;  Regroupingobjects by changing relationships is called reparenting.andP;  The ZtChangefunction makes the task of regrouping very easy.andP;  The new child list issimply passed to the desired parent object, and the API takes care ofremoving the targeted children from the old parent's child list and assigningthem to the new parent.andP;  For example, the following code segment moves thepushbutton object PushButton 1 from Model 2 to Model 1, and insertsPushButton 1 into the child list of Model 1.andM;Ztld pbld;  /* PushButton */ Ztld model1ld;  /* Model 1 ld */ Ztldchildlist1ld;  /* Model 1 childlist */ INT32ret;  /* Return Value */andM;static ZtArgListltem childlistArglist [ ] =andM;{ ZtCHILD_LIST, (ZtValueType)NULL, NULL, (ZtValueType)NULL };andM;/* get the current childlist of Model 1 */ ret = ZtQuery (model1ld,childlistArglist, NULL); if (ret) { childlist1ld = (Ztld)childlistArglist[0].ZtValue;andM;/* add pushbutton pb1ld to the end of the childlist of model 1 */ ret =ZtlnsertListTail (childlist1ld, pb1ld, andamp;childlist1ld); if (ret)andM;/* Change model1ld's childlist to include the pushbutton pb1ld */ /* The APIautomatically updates the childlist of model 2 */ ret = ZtChange (model1ld,childlistArglist, NULL); }andM;Freeing Model or Composite ObjectsandM;The counterpart of cloning model and composite objects recursively ornonrecursively is the ability to free these objects from the intermediateparent.andP;  Take the case of an application in which one of its model objectshas a row-column object as one of its children.andP;  Suppose the applicationrequires that the row-column object be freed, but the children of therow-column object must remain.andP;  The API provides an option in the ZtFreefunction that allows the user to accomplish this task.andP;  Setting theZtRECURSIVE attribute in the function Arglist to FALSE, and calling ZtFree onthe row-column object, destroys the row-column object, and its childrenbecome the children of the model object.andP;  In contrast, passing a functionArglist to ZtFree with ZtRECURSIVE set to TRUE will free the row-columnobject and its children.andM;Symbols and ModelsandM;Models can be created as children of other models.andP;  A model within anothermodel is called a submodel.andP;  For example, in Fig.andP;  1, Model 21 is a submodelof Model 12.andP;  The user can create a symbol library out of submodels.andO;Customized sets of commonly used symbols can be created, saved, and reused assubmodels.andM;ConclusionandM;Based on an object-oriented framework, the API consists of a simplified yetpowerful set of functions for creating and activating user interfacecomponents.andP;  The application developer can learn to use these routines withina short time.andP;  The developer is also able to combine the dynamic animationcapabilities of graphics and the flexibility and interactive capabilities ofwidgets to enhance user interfaces for process control applications.andP;  Modelsof physical objects such as machinery and instrumentation can be created toprovide context-specific information that the end user can react to morequickly than with a standard terminal-oriented interface.andM;Mydung Thi TranandM;Software engineer Mydung Tran was responsible for widget development,testing, and native language support for the HP IVI project.andP;  She joined HP'sIndustrial Applications Center in 1988.andP;  Mydung has authored or coauthoredfive technical articles on distributed processing, particle dosimetry, spaceradiation, and nuclear track detectors.andP;  Before joining HP, she was aresearch physicist at the University of California at San Francisco, and agraduate assistant at Lawrence Berkeley Laboratories.andP;  A member of the ACM,her professional interests include computer graphics, parallel processing,and networking.andP;  She received her BS degree in physics in 1975 from theUniversity of San Francisco and her MS degree in computer science from SanFrancisco State University in 1989.andP;  Born in Saigon, Vietnam, she is married,has a son and a daughter, and lives in San Francisco.andM;David G. WathenandM;User interface design, graphics, and artificial intelligence are theprofessional interests of David Wathen, a software engineer who developedenhancements for the HP IVI project.andP;  He joined HP's Industrial ApplicationsCenter in 1989, shortly after he received a BS degree in computer science andapplied mathematics from the University of Colorado at Boulder.andP;  Beforejoining HP, he was a software designer for the National Center forAtmospheric Research (NCAR), where he built an X11 window interface to NCARgraphics.andP;  David was also an advanced interface intern at US West, where heworked on future telephone projects.andP;  Born in Littleton, Colorado, he residesin Sunnyvale, California, where he enjoys Tae Kwon Do, skiing, 4-wheeldriving, backpacking, and traveling.andO;</TEXT></DOC>