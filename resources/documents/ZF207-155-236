<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-155-236  </DOCNO><DOCID>07 155 236.andM;</DOCID><JOURNAL>AI Expert  March 1989 v4 n3 p28(9)* Full Text COPYRIGHT Miller Freeman Publications 1989.andM;</JOURNAL><TITLE>LISP macros for backtracking.andO;</TITLE><AUTHOR>Maxwell, H. John; Riggle, Mark S.andM;</AUTHOR><SUMMARY>Several macros are developed to extend Common LISP and enabledepth-first searching with backtracking while ensuring acomprehensible control structure.andP;  Depth-first search withbacktracking is a useful brute-force search strategy forevaluating a problem that contains a reasonably small number ofstates.andP;  The functional abstraction is available in PROLOG, butLISP has a variety of other useful, powerful abstractions that canenable the development of a depth-first search and backtrackingfacility.andP;  The described macros utilize continuation passing,integrate both deterministic and nondeterministic statements, andprovide a control mechanism for depth-first search andbacktracking.andP;  Details of the development and functions of themacros are described.andM;</SUMMARY><DESCRIPT>Topic:     LISPProgramming InstructionTutorialApplicationsSearchingBacktrackingMacros.andO;Feature:   illustrationtableprogram.andO;Caption:   Language reference. (table)Common LISP solution to N-queens prize. (program)Continuation-passing version of abstract search. (program)andM;</DESCRIPT><TEXT>LISP Macros for BacktrackingandM;The relative merits of LISP and PROLOG for implementing solutions to AIproblems, such as expert systems or natural language understanding, havealready been debated.andP;  Although we do not intend to join the controversy asuncritical advocates of Common LISP, we will present a set of Common LISPmacros that demonstrate the power and flexibility of the Common LISPlanguage.andM;Our macros make the backtracking ability of PROLOG available whileprogramming in the usual functional style of Common LISP.andP;  The macros can beused to great effect in solving AI problems that involve search bydepth-first backtracking.andM;The macros were developed with two objectives in mind: a practical need tosearch with backtracking in a Common LISP-based application while maintaininga comprehensible control structure and an interest in exploring and expandingthe programming power of Common LISP.andM;While working on some problems in natural language understanding, we realizedthat depth-first search with backtracking was necessary to accomplish somephases of our implementation.andP;  PROLOG would have been a natural choice, butwe had already written extensive code in Common LISP and did not want tointerface it with PROLOG.andM;Furthermore, we wanted to see how the abstraction of depth-first search andbacktracking could be built in Common LISP using a clear, useful syntax.andM;SEARCH AND BACKTRACKINGandM;Many traditional problems in AI involve searching for solutions amongnumerous possibilities.andP;  Game playing, planning, natural language, and speechunderstanding are example domains in which the principle problem is to find asolution in a state space that may be very large.andP;  Depending on the problemand the size of the enumerated search space, various search strategies can beemployed in AI problems.andP;  This has been discussed in AI EXPERT's &quot;AIApprentice&quot; columns.andP;  [1]andM;The obvious approach to accomplishing a search is to enumerate everypossibility until a solution is found, but the cost of performing such anexhaustive or &quot;blind&quot; search increases exponentially with the number ofchoices that have to be made.andP;  Nevertheless, if the number of states to beexamined is reasonably small, a brute-force method can suffice.andP;  The mostcommonly used brute-force search strategy is depth-first search withbacktracking, which has been incorporated as a basic abstraction in PROLOG.andM;For some applications, search strategies other than depth-first search may beuseful or necessary.andP;  It may be a requirement for the algorithm to find anoptimal solution in a search space rather than the first available solution.andO;In these cases, such strategies as breadth-first or heuristicbranch-and-bound search may be useful.andP;  More on this topic can be found intexts such as N. Nilsson's.andP;  [2]andM;Algorithms that involve depth-first search with backtracking contain acombination of state-generating and state-testing statements:andM;* Generate a possible successor state to the current one.andP;  If there are no(more) successors, then fail.andM;* Test the new state to see if it is valid.andP;  If it is, continue to the nexttest or generator statement.andP;  If it is not valid, backtrack to the previousgenerator statement.andM;We term the generator statements &quot;nondeterministic&quot; because they may beexecuted many times and produce several results before later statements inthe algorithm succeed as well and a final solution is found.andP;  By contrast,&quot;deterministic&quot; statements, such as simple validity tests, do not generatemultiple results and thus can be skipped when backtracking.andP;  A search cancontain several nondeterministic statements with intervening deterministicstatements.andM;Since an application can benefit from using depth-first search withbacktracking, PROLOG is a natural language to use for solving the problem.andP;  Asimple PROLOG clause can express our abstract generating and testingstatements very conveniently (Listing 1).andP;  In this abstract example, someintermediate states S may be generated from Firststate, and some final statesmay be possible from the intermediate states.andP;  When finaltest verifiesFinalState, the whole predicate succeeds.andP;  To illustrate the clarity ofPROLOG code for backtracking problems, a short solution for the well-knownN-Queens problem is included in Listing 2.andP;  The problem consists of placing Nchess queens on an N-by-N chess board so that no queen can capture any otherqueen.andM;WHY STAY WITH COMMON LISP?andM;PROLOG provides three important programming abstractions: depth-first searchwith backtracking, logical variables and pattern matching, and automaticstorage allocation and reclamation.andP;  PROLOG's logical variables and patternmatching are the most fundamental abstraction of the language.andP;  Backtrackingand automatic storage management are required to support the logicalvariables; that is, to make the logical variables work as desired requiresthat backtracking and automatic storage management be available.andM;Common LISP does not contain backtracking as a basic language abstraction,but it has many other useful and powerful abstractions.andP;  These features areuseful for general LISP programming and important in implementingbacktracking algorithms in LISP:andM;* Automatic storage management, just as is necessary in PROLOG.andM;* A powerful macro facility, which allows the programmer to extend the syntaxof Common LISP in almost unlimited ways.andM;* Functions as first-class objects.andP;  Functions may be passed as arguments,returned as values, and stored as data.andP;  Functions can be bound up with theirenvironment into what are called &quot;lexical closures.&quot;andP;  Using closures, theprogrammer can build continuations--functions that embody the rest of theprogram.andP;  (The use of continuations for backtracking is described more fullylater.)andM;* Catch, throw, and unwind-protect statements allow complex control-flowimplementation without writing complex code.andM;* The package system for partitioning symbols into modular groupings.andM;* A very rich assortment of powerful built-in functions and data structures.andM;If for practical or aesthetic reasons you prefer to code in LISP but want thebacktracking abstraction from PROLOG, you can either give up LISP and usePROLOG, or use macros and the other features of Common LISP to extend it toimplement non-deterministic functions.andM;BACKTRACKING IN COMMON LISPandM;It is not really necessary to extend Common LISP to accomplish backtracking.andO;Search algorithms can be written in LISP, Pascal, C, or any other language aslong as all the bookkeeping work necessary to backtrack and resume executionat a previous program state is encoded.andM;Although this standard programming approach works for a simple problem likeN-Queens, coding becomes more difficult if numerous nondeterministicstatements are found in the search algorithm.andP;  Instead of one stack ofprogram states for the whole problem, one stack would be necessary for eachnondeterministic statement to remember where to resume when backtrackingoccurs.andM;We would like to write search programs that do not simply return when asolution is found.andP;  It would be more useful to have the solutions generatedone by one by repeated invocation of the program.andM;This can be done, albeit rather awkwardly, by maintaining the state of thesearch in explicit global variables so the program can know where to resumewhen called again.andP;  It would be more convenient, however, to have the LISPsystem keep state information on the program stack.andP;  We can accomplish thisby programming with continuations.andM;At any given point in a program, a continuation is the function that embodiesthe execution of the rest of the program from that point on.andP;  It consists ofthe program statements to be executed and the environment (the currentbindings of variables) in which they are to be executed.andP;  In the followingCommon LISP pseudocode, the continuation at the comment consists of theremaining function call in an environment where x = 5 and y = 3:andM;(let ((x 4) (y 4)) (incf x) (decf y) ;; Continuation Point: (* x y))andM;Common LISP makes it very easy to get a lexical closure or continuation byusing the lambda statement.andP;  We can change the previous example to create acontinuation as follows:andM;(let ((x 4) (y 4) (continuation nil)) (incf x) (incf y) ;; ContinuationPoint: (setq continuation #'(lambda () (* x y))))andM;The continuation can then be returned or passed as an argument to anotherfunction and eventually can be invoked by the Common LISP FUNCALL statement.andO;When it is FUNCALL'ed, it will return the product of x and y using theirvalues in the lexically scoped environment in which the continuation wasdefined.andM;Armed with continuations, we can begin to write nondeterministic statementsin Common LISP that preserve their own state through their calling sequenceon the program stack.andP;  Listing 3 shows an abstract example corresponding tothe PROLOG clause in Listing 1.andM;In this continuation-passing version of the abstract search program, thenondeterministic functions generator1 and generator2 are called with acontinuation parameter they should FUNCALL when they have generated the nextstate in the search.andP;  Each continuation takes a new state as a resultparameter that can be tested for validity.andP;  If the generator functions runout of new states, they fail by returning nil, and if the continuations failin their deterministic tests, they also fail by returning nil.andP;  (In this andall subsequent examples, failure at any point in the search is indicated byreturning nil.andP;  This is not the only way to handle failure.andP;  Each generatorfunction could be passed two continuations: one to call when the generatorsucceeds and one when it fails.andP;  In all of our examples, the continuationsused are success continuations.)andM;Finally, if everything succeeds and a solution is found, it is thrown back tothe very beginning and returned.andP;  All the search state information duringexecution is kept on the program stack in the bound variables namednext-state in the generator functions.andP;  In the code provided on the AI EXPERTBulletin Board Service and CompuServe forum we'll present a solution to theN-Queens using continuations instead of an explicitly defined recursivestructure.andP;  The resulting algorithm is more flexible: it can find either theN'th solution or all solutions depending on which continuation is passed tothe generator function.andM;Using continuations can help avoid some of the bookkeeping overhead duringbacktracking, but it does not produce very attractive or readable code.andP;  Theextra continuation parameters, lambda expressions, and catch-throw pairs canbecome unpleasantly messy when applied to more complex problems.andP;  We wouldlike our LISP code to look more like the PROLOG version of our abstractprogram, in which the control flow of the depth-first search and thebacktracking is implicit in the language, not coded explicitly.andM;THE BACKTRACKING LANGUAGEandM;We need a language extension of Common LISP with a simple, readable syntaxfor a sequence of nondeterministic statements, much like the conditions of aPROLOG clause.andP;  The language must incorporate both deterministic andnondeterministic statements, allowing them to be intermixed while maintainingclear semantics that distinguish their meanings.andP;  These Common LISP macrosare designed to fit these requirements.andP;  They implement depth-first searchwith backtracking using continuation passing, but hide the confusing controlstructure from the programmer.andM;Functions and macros in the nondeterministic control language start with a !!andO;prefix, which makes them stand out so we can quickly recognize wherebacktracking may occur when reading the code.andP;  Values produced bynondeterministic functions are returned in variables specified after thekeyword :result in the calling sequence.andP;  Consider(!!my-non-deterministic-call arg1 arg2 :result res1 res2).andP;  This calls thefunction !!my-non-deterministic-call with the arguments arg1 and arg2 andreturns two values to be stored in the variables res1 and res2.andP;  Thevariables res1 and res2 would usually be locally declared.andM;Our abstract search program might be coded using the backtracking macrosthus:andM;(defun search1 (initial-state) (let (s final-state) (!!main (!!generator1initial-state :result s) (initial-test s) (!!generator2 s :resultfinal-state) (final-test final-state) (!!main-return final-state))))andM;The top-level statement in a program containing nondeterministic functioncalls must be a !!main, which causes each statement in it to be excecuted,requires that each statement succeed, and backtracks as necessary when somestatement within it fails.andP;  (Both deterministic and nondeterministicstatements fail by returning nil.)andP;  !!main returns either the :resultparameter of the last non-deterministic function call in it, or a valuespecified explicitly by a !!main-return call, as was done in this example.andM;When !!main calls a nondeterministic function, it passes a hidden parameterto it in addition to the input parameters specified on the call.andP;  The extraparameter is the continuation that the nondeterministic function should callwhen it has generated the next state in the search.andP;  Two nondeterministicfunctions in the abstract search example must still be defined so they calltheir continuations, but we desire a syntax for this that does not require adirect reference to the continuation.andP;  Two macros enable this: !!defun and!!continue-result.andP;  The first generator function can now be written as shownin Listing 4.andM;Suppose the function pick-next-state-some-how1 consists of merely pickingsuccessive members of a list of possible successor states.andP;  We can write thedefinition of the generator function more simply using two more macros, !!andand !!chose-one (Listing 5).andM;The macro !!and is very similar to !!main, except it does not return aresult.andP;  It expects a continuation to be present in its environment, which infact is provided by the !!defun where the !!and clause appears.andP;  Thiscontinuation is called automatically by !!and when the last statement in the!!and succeeds.andP;  However, the continuation can be called with specifiedresults using !!continue-result, as was done here to pass the value ofnext-state to the continuation of !!generator1-b.andP;  This continuation takesthe result and binds it to the :result parameter on the original call to!!generator1-b.andP;  It is not necessary to think about the continuationsgenerated by !!defun and called by !!and when writing non-deterministicfunctions like !!generator1-b.andP;  However, one should keep in mind thatnondeterministic functions do not return results in the usual way--they passresults on to the rest of the program using !!continue-result.andP;  The only timea nondeterministic statement should return at all is when it fails: then itreturns nil.andM;!!chose-one is a nondeterministic function that takes a list of choices as aninput argument and calls its continuation as many times as there are choicesin the list.andP;  Each time it binds the :result argument to a choice in the listuntil they have all been used.andP;  Our implementation of !!chose-one uses theelements in the list in left to right order, but this is not strictlynecessary.andP;  !!chose-one could conceivably try the choices in a random order,in which case it would be a bit more deserving of the term&quot;nondeterministic,&quot; but we have not found such randomness to be useful inpractice.andM;Our definition of !!generator1-b is very simple at this point--so simple thatwe could easily replace any call to !!generator1-b with the !!chose-onestatement in it.andP;  But the generator need not consist merely of making achoice from a list.andP;  It could contain several nondeterministic statements, asin the following definition, where it uses two !!chose-one statements to forma result state by taking elements from the cross product of two lists(Listing 6).andM;For an !!and clause to work correctly, it must be contained in the body of a!!defun.andP;  Likewise, any other nondeterministic statements must be containedwithin the body of an !!and clause (except for !!continue-result, which canappear anywhere in a !!defun).andP;  With these restrictions in mind, standardLISP functions and control structures can be intermixed with the backtrackingcode of !!and clauses.andP;  For example, in our generator function, alternateways of building successor states to the current state might be expressed asbranches of the usual cond statement as in !!generator1-d (Listing 7).andM;This example is cluttered by having redundant calls to !!continue-result.andP;  Weprovide another macro, !!cond, which makes it possible to nest conditionalbranches in the body of an !!and clause while allowing all the branches toshare the same continuation.andP;  !!generator1-d can thus be rewritten as in!!generator1-e (Listing 8).andM;The !!and macro provides for a conjunction of nondeterministic anddeterministic statements corresponding to the conditional elements of aPROLOG clause, but we also need logical disjunction, which we obtain inPROLOG by writing multiple rules with the same head.andP;  Suppose successorstates in our generator function could be created in several ways and eachshould be tried in turn until one succeeds.andP;  This can be coded using our !!ormacro (Listing 9).andP;  !!generator1-f will chose from the first set of successorstates until they are exhausted, then from the second and the third until theoverall search succeeds and no longer backtracks.andM;It may be necessary both to change the values of variables during a searchand restore the former values if backtracking occurs.andP;  For this purpose weprovide the !!update function, a backtracking counterpart to the Common LISPsetf.andP;  When the !!update statement is backtracked over, it undoes the sideeffects it initially performed.andP;  Suppose in our example search program aglobal variable called state-strength should be set to the strength of themost recently generated state.andP;  We could write the generator function using!!update to modify the variable and restore it during backtracking (Listing10).andM;!!update allows multiple side effects to be specified and performs them inthe order given.andP;  Any side effect that can be performed by Common LISP setfcan be specified to !!update.andP;  A parallel version of !!update called!!pupdate performs all of the side effects in parallel.andP;  In addition,!!update will take two keyword parameters, :do and :undo, the values of whichare forms to be evaluated, respectively, when !!update is executed, and whenbacktracking occurs through !!update.andP;  This allows the program to performarbitrarily complex actions or side-effects that cannot be done by setf.andP;  The:do and :undo parameters are optional; either or both can be omitted, whichallows such actions as printing a diagnostic message when backtracking occursthrough the !!update.andM;BACKTRACKING CONSTRUCTSandM;The macros discussed so far are the backbone of our backtracking language.andO;Several other macros and functions are also provided and described in theaccompanying sidebar.andP;  A few of these deserve some extra comment here: thenondeterministic calling statements !!call and !!funcall and the !!cut-throwand !!cut-catch constructs for restricting backtracking.andM;In Common LISP programming, recursion is often used as an alternative or evenin preference to iteration.andP;  Most anything coded with a do loop or a mapcarstatement can be done with a recursive solution.andP;  In !!generator1-j we usetwo new macros, !!labels, which is like the Common LISP labels statement, butallows nondeterministic functions to be defined in it, and !!call, whichallows a nondeterministic function to be called outside an !!and clause,giving it the current continuation (Listing 11).andM;!!generator1-j produces all the successor states to the input state, and&quot;augments&quot; them in the as-yet-undefined function !!augment-state.andP;  The resultfor the generator as a whole is produced when !!genloop recurses to the endof the list of successor states and calls !!continue-result.andM;CONTROLLING BACKTRACKINGandM;To control backtracking and allow more deterministic processing, PROLOGprovides the cut mechanism.andP;  To provide corresponding function, we havewritten the macros !!cut-catch and !!cut-throw, which will halt backtrackingwhen necessary.andP;  Suppose in our generator function we want to produce asuccessor state to a given state, but if backtracking occurs we only want toproduce at most three successors before giving up, even if there may be morethan three possible successors (Listing 12).andM;The first two times !!generator1-k chooses a successor, it increments thecounter new-state-number and continues.andP;  But when the third successor ischosen, !!cut-throw is executed.andP;  It initially continues as was done thefirst two times, but if backtracking occurs, looking for a fourth successorstate, !!cut-throw breaks off the backtracking and throws back to thematching catch tag give-up on the previous !!cut-catch statement.andO;Implementing !!cut-catch and !!cut-throw uses Common LISP catch and throwcalls, which means the scope of the tags is dynamic, not lexical.andO;Consequently, a cut-throw can transfer control to a tag not lexicallyvisible, perhaps jumping across many layers of nested function calls.andO;Furthermore, any !!update calls crossed when executing a !!cut-throw willundo the side effects they have made.andM;The source code for the macros themselves is too long to include in thisarticle (it contains about 500 lines of Common LISP), but it is available onthe AI EXPERT Bulletin Board Service and CompuServe forum.andM;MACRO SOLUTIONSandM;In Listing 13 we show Common LISP solutions to the N-Queens Puzzle usingexplicit data structures and recursion to record all necessary informationneeded for backtracking.andP;  Listing 14 presents a solution to N-Queens thatuses our backtracking macros.andP;  It has a structure reminiscent of the PROLOGsolution in Listing 2.andP;  And just for fun, Listing 15 provides a solution tothe classic missionaries and cannibals problem using our backtracking macros.andM;Although these examples consist of simple puzzles, we have applied ourbacktracking macros on a much larger scale in our current work in naturallanguage processing.andP;  They are extremely flexible, although they do exactsome extra cost in compilation and execution time.andP;  They have beenparticularly useful in prototyping, enabling us to try various approaches inless time than less flexible, but perhaps more efficient, methods wouldrequire.andP;  After initially coding algorithms containing much backtracking,some of the backtracking can be gradually removed as we better understand theproblems we are solving.andP;  Our work demonstrates once again the tremendousflexibility of Common LISP and its usefulness in solving AI problems.andM;REFERENCESandM;[1] Minasi, Mark.andP;  &quot;AI Apprentice,&quot; AI EXPERT, Oct.-Dec., 1988.andM;[2] Nilsson, Nils J. Principles of Artificial Intelligence, Palo Alto,Calif.: Tioga Publishing Company, 1980, pp.andP;  53-97.andM;[3] Steele, Guy L. Jr.andP;  Common LISP, Bedford, Mass.: Digital Press, 1984.andM;H.andP;  John Maxwell, Ph.D.andP;  and Mark S. Riggle are systems developers in the AIdepartment at SAS Institute Inc., a computer software firm in Cary, N.C.andP;  TheSAS software system provides data management, analysis, and presentation.andO;</TEXT></DOC>