<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF109-557-361  </DOCNO><DOCID>09 557 361.andM;</DOCID><JOURNAL>PC Magazine  Nov 13 1990 v9 n19 p526(4)* Full Text COPYRIGHT Ziff-Davis Publishing Co. 1990.andM;</JOURNAL><TITLE>Redefining the programming paradigm: the move toward OOPLs.andO;(object oriented programming languages) (Power Programming)</TITLE><AUTHOR>Duncan, Ray.andM;</AUTHOR><SUMMARY>Object-oriented programming languages (OOPLs) are rapidlyreplacing standard C as the programming language of choice amongsophisticated programmers because graphical user interfaces aredriving a massive shift toward the object-oriented paradigm.andO;OOPLs require programmers to view problems in a radicallydifferent way, visualizing data as moving and routines as staticrather than vice versa.andP;  The first OOPL, Simula, was described in1967; C++, an object-oriented extension of C, was invented byATandamp;T's Bjarne Stroustrup in 1982.andP;  Smalltalk is a well-known OOPLdeveloped in the mid-1970s at Xerox Palo Alto Research Center.andO;The three distinguishing features of object-oriented programmingare encapsulation, under which information is hidden insideentities called objects; polymorphism, which lets a singleoperator manipulate different data types; and inheritance, whichdeals with complexity by letting new classes of objects derivethemselves from existing classes.andP;  The use of OOPLs in Windows andOS/2 programming is discussed.andM;</SUMMARY><DESCRIPT>Topic:     Object-Oriented ProgrammingProgramming LanguagesTrendsProgram Development Techniques.andM;</DESCRIPT><TEXT>Redefining the Programming Paradigm: The Move Toward OOPLs At first glance, Cappears to be riding the crest of a tremendous wave of popularity.andP;  The ANSIand ISO standards for C have passed the final milestones for approval, manyof the most important PC applications either have been or are being ported toC from their original implementation language, and the advertisements forC-oriented tools and libraries in programming magazines outnumber those forall other languages put together.andP;  But I suspect that within a relatively fewyears we'll be discussing ANSI C with nostalgia and its remaining advocateswith amused tolerance--much as many programmers now view COBOL, FORTRAN, andBASIC.andM;This prediction is based on two facts.andP;  First, once a language isstandardized, its evolution is placed at the mercy of ANSI's strictrequirements for political consensus and compatibility with existingpractice, as well as the ANSI five-year review cycle.andP;  The language can nolonger adapt rapidly to changes in programming methodology or the demands ofnew operating environments.andP;  At some point, when the requirements of the realworld diverge enough from the facilities provided by the language, it becomeseasier for programmers to switch to another language or invent a new one.andM;Second, and more importantly, it's clear that a massive shift in programmingparadigms is on the way.andP;  Our tidy little world of traditional proceduralprogramming languages is about to be turned upside down, and the new victorwill be the object-oriented programming languages (OOPLs).andP;  Such upheavalsare not without precedent--the replacement of FORTRAN with modern,block-structured languages such as Pascal, C, and Modula II over the lastdecade comes immediately to mind.andP;  But the transition to OOPLs will have amuch more dramatic impact on programmers than switching from FORTRAN to C.andM;Why?andP;  Because OOPLs require the programmer to look at the problem he istrying to solve in a radically different way.andP;  In traditional languages, youvisualize the data to be worked on as sitting in one place, while variousroutines call upon each other to do things to the data.andP;  In anobject-oriented programming environment, the routines are visualized asstatic--hidden inside little black boxes called objects--and it is the datathat is lively: it flits from one object to another in the form of messages.andO;This has an interesting correspondence with graphical environments such asthe Macintosh's, Microsoft Windows, and OS/2 Presentation Manager, as we'llsee later.andM;THE LINEAGE OF THE OOPLSandM;In spite of the recent fuss and flurry of magazine articles and books aboutobject-oriented programming languages, the OOPLs are not exactly a newinvention.andP;  The prototypal OOPL, Simula, was first described in 1967--itactually predates the C language.andP;  Simula (originally called Simula 67), wasinvented by Ole-Johan Dahl and Krysten Nygaard at the University of Oslo andthe Norwegian Computing Center.andP;  The more widely known Smalltalk language wasdeveloped in the mid-1970s at Xerox's legendary Palo Alto Research Center(PARC) by Adele Goldberg, Alan Kay, Daniel H. H. Ingalls, and others.andP;  Otherearly OOPLs included Object Pascal, DEC's Trellis/Owl, and some LISPderivatives called Loops, Flavors, and Ceyx.andM;The key event in bringing OOPLs to the masses was the invention of C++ abouteight years ago by Bjarne Stroustrup, a researcher at ATandamp;T Bell Labs.andP;  C++,an object-oriented superset of C, quickly found favor among academicians andcertain C systems programmers.andP;  The features of C++ that distinguished itfrom its OOPL predecessors such as Smalltalk were its backward compatibilitywith existing C code--allowing programmers to learn and adopt object-orientedtechniques in an incremental fashion--and its implementation as a truecompiler rather than an interpreter.andP;  A C-based alternative to C++, calledObjective C, was designed by Brad Cox at around the same time as Stroustrup'soriginal work.andP;  But the Objective C extensions were more similar to Smalltalkand less intuitive for C programmers.andP;  Objective C has also been handicappedby its lack of an endorsement from ATandamp;T and now seems to be something of adead issue.andM;Some of the characteristics of Smalltalk and the original C++ compilersillustrate why the OOPLs were regarded as curiosities by the vast majority ofprogrammers for so many years.andP;  A complete Smalltalk environment demands apowerful machine with a high-resolution graphics adapter, megabytes of RAM,and a large, fast, fixed disk.andP;  Only very recently have such machines comewithin the financial reach of the average programmer.andP;  In addition, thestrengths of Smalltalk--an interactive browse-oriented environment, with allsource code on-line and instantly accessible for change--have also proven tobe weaknesses when the language is used for large projects involving manyprogrammers.andP;  There's nothing to stop the creative programmer fromcustomizing the system almost past recognition; indeed, there's nothing tostop him from modifying vital objects in the Smalltalk system in such a waythat the system quits working altogether!andP;  Using Smalltalk is alsoproblematic if the objective is the generation of small, turnkey applicationsthat don't require megabytes of RAM to run.andM;C++ struggled through the 1980s with a reputation for slow, buggy, clumsycompilers that generated bulky, inefficient machine code.andP;  Most C++ compilerssimply translated C++ source code into incredibly tortuous C source code,which was then fed to the system's ordinary C compiler.andP;  Naturally, theoriginal versions of C++ didn't support integrated programming environmentswith class browsers, syntax-directed editors, and all the other goodies of aSmalltalk development system either.andP;  Programmers were skeptical aboutcommitting to C++ for large development projects, because the language wasrapidly evolving, several dialects were floating around from differentcompiler vendors, and the picture was further confused by the existence ofObjective C and the deliberations of the ANSI C committee (which ended upincorporating some C++ features into the C language).andM;Object-oriented programming sputtered along, accumulating a core group ofusers and advocates, but serving primarily as a topic for academic seminarsand graduate student theses, until May of 1989.andP;  During that month, bothBorland and microsoft jumped on the OOPL bandwagon by introducing integratedPascal programming environments with object-oriented extensions.andP;  Thecoincidence of timing and degree of resemblance between the MicrosoftQuickPascal and Borland Turbo Pascal 5.5 announcements was truly uncanny.andO;The two products were released within a week of each other.andP;  Both were 100percent upward compatible from Turbo Pascal 5.0 and included excellentdocumentation, extensive on-line reference materials, windowed multifileeditors, and an integrated debugger.andP;  And both packages reached programmersat street prices of less than $100.andP;  This was truly a milestone, because itput OOPL capabilities in the hands of literally millions of serious andcasual programmers but didn't force programmers to explore those capabilitiesuntil they were ready.andM;In May of 1990, Borland blew the OOPL market wide open when it released TurboC++, a natural evolution of its popular Turbo C product.andP;  Turbo C++ is afully integrated C++ environment that includes a compiler, editor, debugger,browser, profiler, and assembler.andP;  It's upward compatible from ANSI C, sothat the programmer can continue to use all his old source code as he learnsOOPL techniques, and Turbo C++'s user interface, documentation, androbustness are all typical of Borland's high standards.andP;  The arrival of thisproduct guarantees that the Era of OOPL is finally upon us.andM;CHARACTERISTICS OF OOPLSandM;The reversal in viewpoint that you undergo to write programs with an OOPL isvery similar to the painful adaptation that MS-DOS programmers endure whenthey start coding for a windowing environment such as the Macintosh's,Microsoft Windows, or OS/2 Presentation Manager.andP;  MS-DOS programmers areaccustomed to the idea that nothing happens unless their program makes ithappen--for instance, no character arrives from the keyboard unless and untilthe program requests one.andP;  But in a windowing environment, a program must beconstructed much differently, because it is constantly and unpredictablybombarded with unsolicited events ranging from mouse movements to requests bythe operating system to repaint part of the screen.andP;  No matter what otherwork the program might be doing, it's always expected to handle the events ina timely manner.andP;  Similarly, an object in an OOPL is never acting, it'salways reacting.andM;What marks a programming language as truly object-oriented?andP;  The threeclassic features that are always cited in this connection are encapsulation,polymorphism, and inheritance.andP;  Remember these three buzzwords--they'll serveyou well when you're evaluating the claims of language vendors, impressingyour friends at parties, or trying to confound the attempts of your managersto figure out what you are doing.andM;Encapsulation is a fancy term for information hiding.andP;  As we mentioned, whenyou write a program in an OOPL, procedures, their private data, and constantsare enclosed within entities called objects.andP;  Each object &quot;knows&quot; whichmessages it can process, which it should reject, and which it should pass onto another object--but no object can truly know the capabilities of another.andO;Each object is an instantiation of an object type or class; the members of aclass have different names but symmetric capabilities.andP;  The primary goal ofencapsulation is the insulation of a particular object class's internalworkings so that it can be modified and improved without causing harmful sideeffects elsewhere in the system.andM;Polymorphism is similar to the operator overloading you find in C or Pascal,where you can use the same operator to manipulate several different datatypes: the C or Pascal compiler is smart enough to examine the data types andgenerate the appropriate code.andP;  In an OOPL, polymorphism refers to anobject's capability to select the correct internal procedure (called amethod) based on the type of data received in a message.andP;  For example, aPrint object might be sent a message containing a binary integer, a binaryfloating-point number, or an ASCII string; in an OOPL, you have a right toexpect the object to take the appropriate action (or at least failgracefully) even if the contents of the message aren't known at the time youwrite the program.andM;Inheritance is the OOPL's major weapon against complexity, and the featurethat makes it especially appropriate for programming windowing environmentssuch as the Macintosh's or OS/2 Presentation Manager.andP;  A new class of objectsis derived from an existing class by changing one or more of the olderclass's methods and adding one or more new methods.andP;  This process issometimes called subclassing.andP;  The new class need only contain the actualcode for added or changed methods; the code for methods that are &quot;inherited&quot;unchanged from the parent class remains in the parent; messages not handledby a class's unique methods are automatically routed to its parent.andP;  You caneasily imagine how this simplifies coding a program that must control manydifferent types of windows that are minor variants on each other: clientwindows, pull-down menus, dialog boxes, and so on.andM;BEYOND THE VALLEY OF THE OOPLSandM;While the transition to OOPLs may be perplexing and intimidating to most ofus workaday programmers, the eventual triumph of OOPLs in one form or anotherseems inevitable now, since it will be driven by the difficulty ofprogramming graphical user interfaces in traditional, procedural languages.andO;Indeed, at last year's Microsoft Systems Seminar, the speakers took theimpending dominance of OOPLs completely for granted and were talking insteadabout Microsoft's plans for object-oriented file systems and object-orienteduser interfaces!andP;  What in the world can these things be?andM;Well, let's begin with the idea of an object-oriented file system.andP;  In theold, familiar, command-line-oriented MS-DOS file system, you use a&quot;verb-object&quot; approach to manipulation of data files.andP;  First you invoke anapplication program capable of performing certain operations on data that'sin a specific format, then you pick a file of data appropriate to theapplication.andP;  If, perchance, you select the wrong type of data file, mostprograms will display garbage, do something totally unexpected, or evencrash.andM;In contrast, an object-oriented file system uses an &quot;object-verb&quot; paradigm tomanipulate files--first you select a file or files, then an operation (open,print, copy, delete, and so forth).andP;  In OOPL terms, data files are theobjects and application programs are the methods.andP;  Conceptually, a menuselection sends a message to program code associated with a particular classof file, and that code decides whether and how it can carry out the requestedaction.andP;  You can get an idea of how this works by looking at the MacintoshFinder.andP;  In the Finder, you can delete a file by clicking on its icon andthen dragging it to the trash can (in effect, sending the message &quot;deleteyourself&quot; to the file); or double-click on a data file, causing theapplication that originally created the file to be loaded and executed.andM;The High Performance File System (HPFS) of OS/2, Version 1.2, has beenspecifically designed to serve as the platform for an object-oriented filesystem.andP;  The main vehicle for implementing object-oriented characteristics isa new feature called extended attributes (EAs).andP;  EAs can be associated with afile or an arbitrary path and are conceptually similar to environmentvariables, each EA taking the form name=value.andM;In OS/2 1.2, each file can have up to 64K of EAs, which are stored outsidethe file itself.andP;  The important point is that the value of an EA can be anASCII string or binary data.andP;  The binary data might be an icon, an encryptionkey, or even executable code.andP;  For example, a document file created withMicrosoft Word, Version 5.0, might have the following EAs associated with it(among others):andM;ICON=andless;binary bitmapandgt; APP_NAME=Microsoft Word APP_VERSION=5.0 APP_EXE=WORD.EXEandM;The shell could then use the EA ICON= to display an icon that represents thefile on the &quot;desktop&quot;.andP;  When the user requests a detailed directory listing,the shell can use the EAs to display information about the data file's &quot;ownerapplication&quot; without needing to peer inside the file and interpret itscontents.andP;  If the user double-clicks on the document file's icon, the shellcould use the EA APP_EXE= to locate and launch the application program thatknows how to process the data, and so on.andM;Once the framework for an object-oriented file system is in place, Microsoftplans to extend its capabilities throughout networked environments.andP;  The userwon't need to know in which node a data file or application is located, andthe data and the programs will not need to reside in the same network nodeeither.andP;  The file system and network will collaborate to find the data file,move the data where it is needed, run the application on any availablenetwork node that has the required hardware resources, and finally return theresults to the user's node.andM;As for object-oriented user interfaces, Microsoft gave us a preview of what'sin store in this area by demonstrating an experimental user interface toolkitfor Windows 3.0.andP;  The toolkit allows a user to build his own customized shellby visual programming.andP;  Not a line of code need be written; the new shell isdesigned solely by choosing items from menus, by interacting with dialogboxes, and by selecting, dragging, and resizing visual objects such as windowframes, scroll bars, and disk drive icons.andP;  When the appearance of the user'snew desktop is exactly to his liking, he simply saves the configuration andit becomes the default shell for his machine's copy of Windows from thatpoint on.andM;In addition, Microsoft announced intentions to market programming tools thatallow a similar type of visual programming for building Windows andPresentation Manager applications.andP;  User interfaces will be constructed bythe programmer, using an interactive graphical design tool that willautomatically generate the necessary program source code for the applicationprogram's skeleton.andP;  This will eliminate the need to write hundreds of linesof obscure C code just to select fonts, scroll windows, and control menus anddialog boxes, and will allow programmers to concentrate on the core of theapplication rather than the mechanics of the user interface.andP;  The NeXTmachine is already being supplied with these programming tools.andM;Finally, Microsoft discussed its plans to implement and support asystem-level macro language that will allow users to drive applicationprograms &quot;from the outside&quot; and transfer data between them.andP;  Microsoft's newlanguage will apparently be a superset of QuickBasic, with the same sorts ofcontrol structures and operators.andP;  The user will be able to create scripts inthis macro language by instructing the system to &quot;watch me&quot; and then simplycarrying out the desired steps in order.andP;  The user will then be able tofine-tune and elaborate on the scripts with a normal text editor.andP;  A facilitylike this is sorely needed in a graphical environment, where traditionalbatch languages are essentially useless.andM;SOMETHING TO READandM;Perhaps you care to explore the OOPL literature before venturing into theworld of OOPL programming?andP;  I must warn you that the market is swamped withtrade books on the subject, and (to paraphrase a famous statisticalassertion) 90 percent of them are fit only for the recycling bins.andP;  Asurprisingly conspicuous example is Stroustrup's original book, The C++Programming Language (Addison-Wesley Publishing Company, Reading, Mass.,andO;1986, ISBN 0-201-12078-X), which is at one stroke one of the ugliest and mostincomprehensible language primers ever published.andP;  I suppose thatAddison-Wesley was so awestruck by Stroustrup that they didn't even subjectthe manuscript to the usual developmental editing.andP;  They also, unfortunately,allowed the author to do his own book design and typesetting--withpredictable results.andM;If your taste runs to the object-oriented derivatives of C and Pascal, youmight want to take a look at Object-oriented Software Construction, byBertrand Meyer (Prentice Hall, New York, New York, 1988, ISBN 0-13-629049-3).andO;This is a rather formal text, even a bit stuffy at times, but it's veryclearly written.andP;  The primary language used in the book is Eiffel, aninvention of the author, but other OOPLs such as C++, Object Pascal, Simula,and Smalltalk are also surveyed and compared.andM;On the other hand, if you are drawn to the original, pure OOPLs such asSmalltalk, you should browse through the three Addison-Wesley volumes writtenand edited by the original Smalltalk developers: Smalltalk-80; Bits ofHistory, Words of Advice, edited by Glen Krasner (Addison-Wesley, 1983, ISBN0-201-11669-3); Smalltalk-80; The Language and Its Implementation, by AdeleGoldberg and David Robson (1983, ISBN 0-201-11371-6); and Smalltalk-80; TheInteractive Programming Environment, by Adele Goldberg (1984, ISBN0-201-11372-4).andM;THE IN-BOXandM;Please send your questions, comments, and suggestions to me at any of thefollowing e-mail addresses: PC MagNet: 72241,52 MCI Mail: rduncan BIX:rduncan</TEXT></DOC>