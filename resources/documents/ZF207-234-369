<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-234-369  </DOCNO><DOCID>07 234 369.andM;</DOCID><JOURNAL>Microsoft Systems Journal  Jan 1989 v4 n1 p41(35)* Full Text COPYRIGHT The Microsoft Corporation 1989.andM;</JOURNAL><TITLE>Developing applications with common source code for multipleenvironments.andO;</TITLE><AUTHOR>Geary, Michael.andO;AttFile:   MSJ\V04N01\MACSL.ARC;2 Program:  MACSL.ARC  MAC utility.andO;MSJ\V04N01\PMSLEUTH.ARC;2 Program:  PMSLEUTH.ARC  PM/Windows utility.andM;</AUTHOR><SUMMARY>Exchanging programs between the user interfaces of MicrosoftWindows, Presentation Manager and the Apple Macintosh is notimpossible.andP;  However, the Macintosh interface has somecomplications for programmers to consider.andP;  The Macintoshinterface works at a level lower in the system's roots than the PCinterfaces.andP;  As a result, programs that provide greaterflexibility for the user, require far more programming than thoseusing the Windows and Presentation Manager interface.andP;  The MacToolbox, however has some utilities that are not shared by the PCenvironment that make the detail work easier to take.andP;  Thedifferences of various components of the program development tasksare detailed.andM;</SUMMARY><DESCRIPT>Ticker:    MSFT; AAPL.andO;Product:   OS/2 Presentation Manager (Graphical user interface) (usage)Apple Macintosh (Microcomputer) (usage)Microsoft Windows (Graphical user interface) (usage).andO;Topic:     Software MigrationOperating EnvironmentsWindowingApplications Programming.andO;Feature:   illustrationprogram.andO;Caption:   Sleuth code listing. (program)MacPM WinInitialize. (program)MacPM WiCreateMsgQueue. (program)andM;</DESCRIPT><TEXT>Developing Applications with Common Source Code for Multiple EnvironmentsandM;A tale of three systems could easily be told of software written for onesystem and ported to another.andP;  &quot;It was the best of programs, it was the worstof programs...&quot;andP;  Writing a program that will run on more than one kind ofmachine or operating system isn't easy, especially if it's supposed to run onPresentation Manager (hereafter referred to as PM), Windows, and theMacintosh.andP;  Here we have three vastly different windowing/operatingenvironments running on three different operating systems on two incompatiblehardware platforms.andP;  Yet the three have much in common.andP;  Windows andPresentation Manager share a common user interface, and the Mac userinterface is quite similar.andP;  This might lead one to expect--or at least hopefor--some similarities in the programming environment, and there are some.andO;The three systems do provide many of the same general features, but they areimplemented in very different ways.andM;Windows and PM aren't too far apart; even though the detailed coding isn'tthe same between them, PM's ancestry shows quite clearly.andP;  There is a directcorrespondence between many of the functions and messages in the two, andoverall program architecture is, or can be, virtually identical.andP;  There aresome major differences, to be sure.andP;  Presentation Manager applications cantake advantage of all the features of OS/2, including things that have beenon many a Windows programmer's wish list: true preemptive multitasking,multiple threads of execution, named pipes.andP;  But PM doesn't have everyfeature of Windows.andP;  One glaring omission is the multiline edit control.andP;  InWindows you just set a style bit and you get a decent little text editor--thesame one used in Notepad, in fact.andP;  If you want this in Presentation Manager,you'll have to code it yourself.andP;  Still if you stick to their commonfeatures, Windows and PM are similar enough to make it relatively easy toport code between them.andM;The Mac Toolbox (that is, the set of function calls available in the Mac'sROM and System files) is a horse of a different color.andP;  Besides taking adifferent approach to many things, the interface is generally built at alower level than its PC counterparts.andP;  While Mac applications areevent-driven, they don't really have the message-based architecture that isone of the strengths of Windows and PM.andP;  Mac applications have to fuss aroundwith a lot of details to do things that are simple in the other two systems.andO;For example, it's easy to create a standard Mac window complete with a titlebar, close box, and zoom box--but if you want the user to actually be able tomove, size, or zoom the window, or even to close it, you've got some code towrite.andP;  When the mousedown event message comes in, the application mustdetermine where the mouse was pressed (albeit with a simple function call)and then call the proper function to manipulate the window.andP;  In Windows andPM this is done for you by DefWindowProc or the frame window and controlclasses, and the application is notified of the new window status via amessage which can be processed or ignored.andP;  This makes simple programssimpler, while still giving programmers the opportunity to customize thiskind of window handling.andM;This particular difference in architecture complicates the portability issuein more ways than just difficulty of programming.andP;  Some kinds of programs areimpossible to write on the Macintosh except by resorting to kludges thatcan't be guaranteed to work in all cases.andP;  The toughest are utility programsthat manipulate the windows of other applications.andP;  Writing my Tiler programwas a simple job under Windows and would be just as easy under PM(notwithstanding the fact that Tiler's functionality is already part of thePM shell).andP;  All I had to do, after getting the other applications' windowhandles and determining where the windows should be placed, was to callSetWindowPos for every window.andP;  (In PM, just one WinSetMultWindowPos callwould do them all with less screen activity.)andP;  The interesting thing is thatTiler works fine even with applications like Clock, whose window contents aresize dependent.andP;  Their windows receive WM_MOVE and WM_SIZE windows, just asif the user moved or sized them, so any position- or size-dependentcalculations happen as a matter of course.andM;Several Mac applications do have tiling and other window arrangementoptions--but only for their own windows.andP;  I don't know of any general-purposetiling desk accessory for the Macintosh.andP;  The Mac does have MoveWindow andSizeWindow functions, but if a desk accessory turned them loose on anapplication's windows, things would not go as planned.andP;  There is a bigdifference between these functions and their equivalents in Windows or PM.andO;On the Mac, there is no WM_MOVE or WM_SIZE message; in fact, there isn't evena window function that these messages can be sent to.andP;  In the normal courseof events the MoveWindow and SizeWindow functions are called only by theapplication itself, whether because of mouse clicks or a menu item.andP;  The onlyreason the application knows it must deal with a new window size is becausethe application itself just called those functions.andP;  A Tiler on the Mac wouldprobably move the windows correctly, but it would not do any size-relatedcalculations.andP;  For example, scroll bars would remain at their old relativepositions instead of being adjusted to fit the new window size.andM;Even MultiFinder has to resort to various kinds of tricks to get its jobdone.andP;  There is a revealing discussion of these kinds of struggles from aninsider's point of view in Phil Goldman's &quot;MultiFinder Revealed,&quot; in theAugust 1988 BYTE.andM;Mac AdvantagesandM;Just when you think you're involved in too many system details, you discoversome of the Mac's greatest strengths.andP;  For example, the Mac Toolbox has hooksthat let an application substitute its own code for the normal Toolbox code.andO;Windows and PM, of course, have a set of message hook functions, and windowfunctions themselves serve this same purpose.andP;  But on the Mac, the interceptfunctions, called defprocs, are found in many more places.andP;  For example,QuickDraw allows you to replace any of its lowest-level drawing functionswith your own, and you can give the Control Manager a defproc to definespecial controls, like the speaker volume slider in the Control Panel.andP;  TheControl Manager takes care of mouse tracking and other details, calling backto the defproc to do things like draw the slider and its background.andP;  InWindows or PM you would have to implement this kind of control yourself, withmuch less help from the operating environment.andM;The Mac provides a higher level of support in other areas, too.andP;  There areToolbox calls to put up standard file open and save dialogs, a far cry fromthe situation in PM and Windows where each application implements its owndialog for these functions.andP;  This fact made it possible for Apple tointroduce the Hierarchical File System right beside the Mac's old flat filesystem, without breaking too many existing applications.andP;  Imagine thesituation if each application had implemented its own file dialogs; therewould have been no method built into them to switch directories.andP;  Since mostapplications used the standard file dialogs, an update automatically makesthese applications reasonably current.andP;  Furthermore, this paves the way forslick little utilities like Finds-well.andP;  This program adds an extra button tothe standard file dialog in most applications; pressing this button lets thedirectories on a disk be searched for a file name.andP;  Just imagine trying towrite a utility like this for Windows or PM, where each application isburdened with providing its own file open and save dialogs.andP;  No way!andM;As good as the Mac Toolbox is, it just doesn't have either the elegance of amessage-based architecture or OS/2 niceties like threads; Mac programmersfind themselves getting &quot;down and dirty&quot; more often than PM or Windowsprogrammers, I suspect.andP;  This brings out another strength of the Mac: itsmore open architecture and documentation.andP;  Windows and PM prevent dirtyprogramming tricks by not documenting their internal architecture, providingonly high-level functions to manipulate things like window structures.andP;  Thismay keep application programmers &quot;well behaved,&quot; but it makes life difficultwhen the facilities provided don't do the job.andP;  Furthermore, this philosophymakes it hard to debug competently.andP;  The times when my code crashed inWindows, I would have given my eyeteeth to know the details of a windowstructure or the ever-mysterious Burgermaster, just to give me a fightingchance of figuring out what my code was doing wrong.andM;The Mac and its documentation take an entirely different approach.andP;  InsideMacintosh documents nearly all the internal structures used by the MacToolbox, which are closely guarded secrets in PM and Windows.andP;  There are lotsof suggestions concerning what might change in future systems, but at the topof my list is the suggestion that programmers get every bit of informationthat might be useful.andP;  This would bother a traditional operating systemdesigner, because it makes it easy for the application programmer to takecontrol at any level.andP;  It's possible to run wild with this and write aprogram that will break with every new system software release, but on theMac you can dig into a lot of the internal data structures and still be&quot;well-behaved.&quot;andP;  This openness has helped make many Mac applications andutilities possible.andP;  Windows Version 2.03 did open up the Windowsarchitecture considerably, and Presentation Manager continues thatimprovement.andM;Portability IssuesandM;The deeper an application digs into the internal workings of any system, theharder it is to port.andP;  This is true in traditional programming environmentsas well as the complex windowing systems we're dealing with here.andP;  In theworst case, it may be necessary to recode the entire application for eachsystem--a brute force method of porting, but sometimes there is just nochoice.andP;  One situation that can force complete recoding is the lack of acommon programming language.andP;  Fortunately several good C compilers areavailable on the Mac, and C is the language of choice for Windows and PMapplications.andP;  The Mac Toolbox was designed to be called directly fromprograms written in Lisa Pascal, so it follows the calling sequence and dataformats of Lisa Pascal.andP;  Pascal is still very popular on the Mac, but thereare too many differences between the Pascal compilers on the differentmachines to make it a good choice for portability.andM;If C++ were available for developing Windows, PM, and Mac applications, I'duse it instead of C.andP;  With inline functions, classes, and inheritance--andall its other object-oriented facilities--C++ is more than an incrementalimprovement over C for writing portable programs.andP;  Given a good library ofclasses, C++ could hide the underlying environments much more conveniently,and probably more efficiently, than C.andP;  But C++ compilers aren't yetavailable for every system we are considering, so C it is for now.andM;Even though C doesn't help much with the differences in ApplicationProgramming Interfaces (APIs) and application structure, it does a reasonablejob of letting you write code that will run on different systems.andP;  There arestill a few pitfalls, and the Pascal orientation of the Mac Toolbox (and to alesser degree of OS/2 and Windows) introduces additional problems.andP;  The&quot;traditional&quot; portability issues have been well covered in the literature, soI'll just touch on a few.andM;Byte and word ordering.andP;  The Motorola 68000 and the Intel x86 seriesprocessors order their data in opposite directions.andP;  The 68000 is a &quot;bigendian&quot; machine, that is, the high-order byte or word comes before thelow-order one.andP;  The x86 machines are &quot;little endian,&quot; with just the oppositedata ordering.andP;  This affects any binary files meant to be portable betweenmachines, along with data structure definitions and data access macros suchas HIWORD and LOWORD in Windows.andM;Number lengths.andP;  Is an &quot;int&quot; a 16-bit or 32-bit value?andP;  This problem iseasily avoided by never using the native C data types and instead typedefingeverything and using the new types only.andP;  A good convention is to typedef allthe C types with the same name in uppercase, for example, typedef shortSHORT.andP;  Then, for all code that interfaces with the underlying system, useSHORT or LONG instead of INT, where SHORT is 16 bits and LONG is 32 bits.andM;ANSI C vs.andP;  Kandamp;R C.andP;  In the beginning everyone used Kernighan and Ritchie, butnow ANSI is coming into widespread use.andP;  Microsoft C, used for most Windowsand PM applications, is nearly a full ANSI standard compiler (granted thatthe ANSI standard is still in draft form).andP;  None of the Mac C compilers arequite up to speed in this area.andP;  MPW C and Lightspeed C do include some ofthe more useful ANSI features such as prototypes and the wonderful vsprintffunction, but the implementations aren't as complete.andP;  MPW C even has thechutzpah to accept prototypes syntactically but fail to do any of the typechecking implied by them.andP;  Hopefully updates will remedy these kinds ofdeficiencies, but meanwhile it helps to use the newer ANSI featuressparingly.andM;C vs.andP;  Pascal calling sequences.andP;  Since the Mac Toolbox was written to becalled from Pascal, the popular Mac C compilers offer a choice between Pascaland C calling sequences.andP;  Microsoft C also provides both kinds of callingsequences, but its Pascal calling sequence is somewhat different from theMac's.andP;  Both provide for the main difference, parameters being pushedleft-to-right instead of right-to-left as in the C calling sequence, and thepascal keyword is used in each case to switch to the Pascal calling sequence.andO;However, the pascal keyword has to be used in different places.andP;  InLightspeed C and MPW C, you would declare a pascal-sequence functionreturning a long like this: pascal long foo (void); Microsoft C, on the otherhand, requires this: long pascal foo (void);andM;This difference makes the pascal keyword rather useless for porting, unlessyou do something really clunky like this: #ifdef MICROSOFT_C #define P1#define P2 pascal #else /* Macintosh */ #define P1 pascal #define P2 #endifP1 long P2 foo (void);andM;Rather than going to these lengths, it may be best to avoid the Pascalcalling sequence except for code that directly interfaces to the Mac Toolboxor to the PM or Windows API functions.andP;  This should only cause problems incode that assumes one calling sequence or the other.andP;  PMWIN.H, the PM'sheader file, does have a number of structure definitions and macros thatassume the Pascal calling sequence.andM;C strings vs.andP;  Pascal strings.andP;  Nearly all the Mac Toolbox functions expectstrings to be in the Lisa Pascal format: a length byte followed by that manybytes of text.andP;  (Pascal strings are limited to 255 bytes.)andP;  Contrariwise,Windows, OS/2, and the C compilers on both machines use strings in thezero-terminated C format (ASCIIZ).andP;  The Mac C compilers provide various waysof dealing with this, both with conversion functions and, in some compilers,with a 'p' prefix for string constants; &quot;pString&quot; would be the same thing as&quot;String&quot;, but in Pascal format.andP;  Strings loaded from resources are the nativetype for each environment: Pascal on the Mac, C on Windows and PM.andM;User Interface PortabilityandM;When porting code between different windowing systems, the traditionalportability problems are really the least of our worries.andP;  Since programs onthese systems are so API-intensive and the APIs are so different, the codethat talks directly to the underlying environment must change for each system(except for the possibility mentioned above, of using macros to make PM andWindows look more alike).andP;  And the Mac's user interface, though similar toWindows and PM, is not the same, though you can get them them to be assimilar as you want, depending on how much code you want to write.andP;  Afterall, there's a bitmap graphics engine underneath each of these systems, andyou can draw whatever you want on the screen and interact with the userhowever you choose, regardless of whether it fits the user interfaceconventions of the system that you're on.andM;The only reason I mention this is that people have tried it.andP;  Don't.andP;  On theMac, your application should look and feel like a Mac application; on Windowsand PM, it should look and feel like a Windows/PM application.andP;  Then, withinthose constraints, your Mac and Windows/PM versions should be as similar aspossible.andP;  Trust me on this.andP;  Or if you don't trust me, read the reviews ofMac products that are &quot;un-Mac-like,&quot; or of Windows/PM packages that havetheir own ideas about user interaction.andP;  That's not to say that logicalextensions to either user interface aren't worthwhile, but remember that Macusers will also be using other Mac software, just as Windows and PM userswill use other software for those systems.andP;  (Of course, this doesn't apply totrue standalone turnkey applications, where the computer is dedicated torunning specific software.)andM;Child WindowsandM;What differences in these user interfaces do we have to consider? Mostsignificant are child windows, the appearance and features of a standarddocument window, and the use of menus.andM;Windows and PM have child windows that can be nested to any level, overlap,and be manipulated just like top-level windows.andP;  Many applications use theseinvisibly as a programming convenience, but the Multiple Document Interface(MDI) uses child windows visibly and extensively.andM;The Mac has no child windows.andP;  It is possible to build them, but thisinvolves a lot of reinventing the wheel.andP;  Fortunately the Mac's userinterface convention corresponding to MDI doesn't involve child windows.andP;  InMDI, there is an application workspace window that contains the application'smenu bar, and document windows are created as child windows in this window.andO;Mac applications move everything up one level, as it were; they take over thewhole screen, with the application menu bar at the top, and document windowsare top-level Macintosh windows.andP;  There is a straightforward path for portingmultiple-document applications between the Mac, Windows, and PM; use MDI onthe latter two and the standard Mac conventions on the Mac.andM;The Mac does have controls corresponding to all the control window classes inWindows, although not to the new frame controls added in PM.andP;  These are notimplemented as child windows, but through a separate control manager andother pieces of code.andP;  Although they are more difficult to program, thesecontrols are generally more flexible and powerful than the child windowcontrols in Windows or PM.andP;  In particular, the text editor and list managergo far beyond their counterparts in PM and Windows.andM;MenusandM;Menus are quite different among the three systems.andP;  Although Windows andPresentation Manager nominally have the same user interface, some things likemenus really aren't the same; they are just used in the same way byconvention.andM;Under Windows, top-level windows can have menu bars, but child windowscannot, since the child window ID (dialog ID) and the menu handle areoverloaded into the same field in Windows' internal window structure.andP;  Eachitem in the menu bar can be an actual menu item or have a pull-down menuassociated with it, and top-level windows and child windows can each haveControl (System) menu icons, with the associated pull-down menus.andP;  Menu itemsin a menu bar or a pull-down menu can be either text or bitmaps.andM;A Presentation Manager menu is no more than a control window class.andP;  As withany other window class, you can create a menu window at any level of thewindow hierarchy.andP;  Menu bars and pull-down menus are just two variations onthe same menu window class.andP;  The standard frame window in PM creates a numberof different menu windows to implement the standard PM/Windows interface; themenu bar is a menu window, the Control menu icon is another menu window, andthe Minimize/Maximize icons make up a third menu window.andP;  (It seemed strangeto me at first to think of those icons as menus, but after all a menu caninclude bitmaps, and these icons are just like the system menu icon, butwithout pull-down menus.)andP;  The various pull-down menus are themselves menuwindows, invisible (and in fact children of the HWND_DESKTOP window) untilneeded for display.andP;  But PM menus are not limited to this standardusage--except in the user interface guidelines.andM;The Macintosh originally had one menu bar at the top of the screen, with apull-down menu for each menu item.andP;  By convention, the first item of everyapplication is a tiny Apple logo, whose pull-down menu is analogous in spiritif not in function to the Control menu of a Windows or PM application.andP;  Menubar items are text only, in the standard system font (the Apple logo issimply a character in the Chicago font).andP;  Pull-down menus are normally text,but an application can supply a menu defproc to vary a pull-down menu'sstandard appearance.andM;Mac applications generally adhere to this basic menu structure, but over thelast few years the Macintosh menu manager has been enhanced in several ways.andO;Pop-up menus can appear anywhere on the screen, and with a little work thesecan simulate PM menus.andP;  Mac applications have begun to use these, especiallyfor multiple-choice items in dialog boxes.andP;  Hierarchical menus let pull-downmenu items easily call forth an additional complete pull-down menu.andP;  Menustoo long to fit on the screen now automatically scroll as needed during menuselection.andP;  Some new applications, notably HyperCard, have implementedtear-off menus.andP;  Especially convenient for tool or pattern palettes, theseare pull-down menus that can easily be dragged to other screen locations,where they remain visible as separate palette windows.andM;These features are great, but portability in this case leads to a lot of workor to the lowest common denominator--something like Windows crossed with theoriginal Mac menu structure.andP;  Just as multiple-document applications can useeither MDI or the Mac's menu bar, a single-document application in Windowscan take its main window's menu bar and make it the menu bar on the Mac.andO;Windows applications having menus in more than one window require somereworking.andP;  Also, applications can't count on scrolling menus; any menu thatmight be too long, such as a Font menu, must be checked against the screenheight.andP;  If it's not going to fit, a list box or something else should beused.andM;Aside from the menu appearance and location, the actual menu items used canbe very similar between the Mac and both Windows and PM.andP;  An applicationshould have a File menu and an Edit menu, followed by additionalapplication-specific menus.andP;  The standard File and Edit menus are nearlyidentical across systems; the main exception is the different use ofCommand-key and Alt-key shortcuts, which is easily resolved by maintainingseparate resource files for each system.andP;  And in this case that's as easy astrying to convert resource files back and forth.andM;There are some differences in standard menus.andP;  For example, on the Mac, theAbout...andP;  box is at the top of the Apple menu, followed by the deskaccessories and the MultiFinder menu.andP;  In most Windows and PM applications,this migrates to the bottom of the File menu, right below the Exit item thatreplaces the Mac's Quit item.andP;  This Exit item violates the IBM Common UserAccess (CUA) standard, which calls for an Exit menu in the menu bar, withExit and Resume items in its pull-down menu, and frankly, this is oneviolation that is necessary.andM;Document Windows and Dialog BoxesandM;Windows and PM have a common style for standard document windows and dialogboxes, although in each case there are other options.andP;  Modal dialog boxes onthe Mac are virtually identical to their Windows and PM counterparts, butstandard document windows are somewhat different.andP;  The title bar is the same,except a close box replaces the Control menu icon, providing only its Closefunction, and a zoom box replaces only the Maximize icon.andP;  There is nothingto replace the Minimize icon, since Mac application windows do not normallyhave an iconic state.andP;  There is no thick frame for window sizing--just thesize box in the lower right corner.andP;  Scroll bars, if present, workidentically.andP;  Interestingly, none of these differences really affectportability; they affect visual appearance and the exact mouse (or keyboard)interface, but provide essentially the same functionality except for the lackof an iconic state.andM;As to the contents of a document window or dialog box, dialog boxes aresimilar across all three systems.andP;  Although recent Mac dialog boxes havestarted to use pop-up menus and other new interface features, the typicalWindows or PM dialog box would look at home on the Mac and vice versa.andP;  Thisincludes both modal and modeless dialog boxes.andP;  (There is no distinctionbetween system modal and application or window modal on the Mac; underMultiFinder, modal dialog boxes are all system modal.)andM;One feature of Windows and PM dialog boxes not often seen on the Mac is theAlt-letter shortcuts for navigating around the box.andP;  This is one case whereCUA improved on the original Windows and Mac user interfaces; in a largedialog box the Alt-letters can be very convenient.andP;  They are worthimplementing on the Mac, although there isn't any built-in support for them.andM;The content of document windows is for the most part application dependent.andO;Fortunately, the same kinds of user interface techniques are appropriate onall three systems.andP;  Users expect to find virtually the same keyboard andmouse interface on the Mac as in Windows and PM.andP;  Applications for the lattersystems usually have a more substantial keyboard interface since they mustwork without a mouse.andM;Portability TechniquesandM;&quot;Vanilla&quot; applications with relatively standard document windows, dialogboxes, and menus are the easiest to port.andP;  Specialized programs like Tiler,Spellswell--or most Mac desk accessories for that matter--are tougher.andP;  Butin the context of using windows and menus in fairly standard ways, there'sroom to build a competitive, high quality application--vanilla with all thetoppings.andP;  Packages like PageMaker show that it's possible to move lots ofcode among these systems with a high degree of user interface refinement andcompatibility.andP;  It's just a small matter of programming...andM;But wait, we're supposed to design before we code, right?andP;  We had betterfigure out what approach to use.andP;  Coding in C gives us a reasonable degree oflanguage portability, but what's the best way to deal with the different APIsinvolved?andP;  There isn't really one best way; it depends on the situation.andM;Besides maintaining separate source code for each system, another kind ofbrute force technique is to keep common source code but use a zillion#ifdef's to isolate machine specific code.andP;  This is usually a bad bet; itends up harder to read and maintain than separate source.andM;Macros are a fine tool for isolating system dependencies.andP;  It's a pity C'smacro processor is so limited, because it gives just a taste of the kinds ofthings that can be done with macros.andP;  Even with its limitations, the Cpreprocessor lets you define simple text-substitution macros with parameters,and that alone is plenty.andP;  The Presentation Manager Conversion Guide includesa comprehensive example of using macros to port the Cardfile program fromWindows to PM.andP;  C macros don't do the whole job, so the Cardfile example alsohas a fair number of #ifdef's and machine-specific helper functions.andP;  Themacros do reduce the number of #ifdef's enough that they don't hurt thecode's readability very much.andP;  When porting between Windows and PresentationManager, this macro approach works very well, because of the inherentsimilarity of the two systems.andP;  It's also very efficient.andM;When the Mac comes into the picture, the macro scheme starts to fall apart.andO;Because of the radically different architectures, it takes a considerablebody of machine-specific code no matter how you approach the problem.andP;  Thequestion becomes how best to divide the application betweensystem-independent code and system-specific code, and which services thesystem-specific code provides to the rest.andP;  One way to look at this is toview the independent code as running in a virtual operating environment thatis the same on all systems, and the specific code as implementing thatenvironment for each system.andM;The next question is just what that virtual operating environment is.andP;  It canprovide its own unique set of APIs, which are implemented by thesystem-specific code on each system; or it can use the APIs of one of thesystems directly, in which case code on the other systems mimics those APIs.andO;For example, if you were starting with a Mac application and wanted to portit to PM and Windows, it would be very useful to have the same Mac Toolboxcalls available on all three systems.andP;  Barring the existence of somecommercial library providing these functions, there's a lot of codinginvolved in this, to say the least.andP;  It is true that you wouldn't have toimplement every feature of the base system, only those particular featuresthat your application actually uses.andM;Making up new APIs for coding the application is also a valid approach, asAldus did in writing a version of PageMaker that runs on the Mac and Windows(and shortly for Presentation Manager).andP;  As described in &quot;Aldus: PreparingPageMaker for the Move to Windows&quot; MSJ, (Vol.andP;  1, No.andP;  2), Aldus split theproject into &quot;core code&quot; and &quot;edge code.&quot;andP;  The core code is the same on bothsystems, and the edge code interfaces to the target systems, providing acommon set of functions that the core code uses.andM;There is also a commercial product that uses this method to provideportability between the Mac and Windows.andP;  The Extensible Virtual Toolkit(XVT) from Advanced Programming Institute, Ltd. provides a common interfacefor these two systems and is being extended to support Presentation Managerand X Windows as well.andP;  XVT provides a layer on top of each of the targetenvironments, with its own API, its own program structure, and its own userinterface.andP;  XVT uses a &quot;vanilla with all the toppings&quot; user interface likethe one I've been describing.andP;  Windows versions use the Multiple DocumentInterface or a single document window, and Macintosh versions use thestandard Mac multiple window interface.andP;  Dialog boxes and menus work asexpected on both systems.andM;XVT does not provide as comprehensive or flexible an environment as any ofthe native environments, but it provides enough to write a large variety ofapplications.andP;  It doesn't support some features, such as modeless dialogs,but there are plans for it to do so in future releases.andP;  It's possible toimplement features not supported by XVT by directly calling the nativeenvironment, but this is nonportable.andP;  Nonetheless, it's possible to writefairly sophisticated programs using XVT alone; XVT-Draw, a drawing programwritten purely in XVT code, is a full-featured drawing program that shows thepower available.andP;  I'm looking forward to seeing the Presentation Managerversion of XVT.andM;One benefit of XVT's approach is that it's possible to invent an API that issimpler and easier to program than any of the target systems.andP;  Although XVTwas written to facilitate portability, many people have used it as a simplerway to program just one of the target systems.andP;  It also provides veryhigh-level support for a few things commonly used in applications.andP;  Forexample, standard Font and Style menus can be generated simply by setting aflag, and there is a complete Help system that can be built into XVTapplications.andM;As an experiment I took the other approach to portability, picking oneenvironment as the base and writing native code for it, then implementingportions of that environment on the other systems.andP;  Since PresentationManager is my favorite of the three in terms of its APIs presenting thegreatest amount of functionality, I used that as the base system.andP;  I alsowanted a taste of what is involved in implementing an SAA-compatibleprogramming environment.andP;  Although there are now very few applicationswritten to SAA standards, many are coming, and it would be a plus to be ableto run them on hardware other than IBM's.andM;I also expect PM to become the single largest end-user and businessenvironment, so it makes good sense to focus the primary attention there, andto port my application to Windows and the Mac as secondary markets.andP;  Ofcourse this also suggests, and I would certainly like to see, that all thoseexcellent Macintosh applications be ported to Presentation Manager.andP;  (See theaccompanying article, p.andP;  11 which discusses porting Macintosh applicationsto Windows and PM.--Ed.)andM;Taking one system as the base environment simplifies the problem in twoareas.andP;  It eliminates the need to invent common APIs, and it eases debuggingof at least one version of the application, because it runs as native code onthe base system.andP;  It also means that useful features of the base systembecome available on the others.andP;  In the case of PM as the base, this means,for example, that child windows--and window functions in general--becomeavailable on the Macintosh.andP;  When I was first programming the Mac a few yearsago, I had never heard of child windows so I didn't miss them.andP;  But now thatI've had a chance to use them in my Windows and PM programming, I don't knowhow I got along without them.andM;SleuthandM;As a test case for this portability method, I used a souped-up version of aprogram I wrote for Windows some time ago, which I now call Sleuth.andP;  It iswritten as a native OS/2 application using Presentation Manager.andP;  I wrote twolibraries; WinPM for Windows, and MacPM for the Macintosh that provide justenough Presentation Manager functionality to let Sleuth run on those systemswith no change to its source code.andM;Sleuth (see Figure 1 for PM source code) creates a main window that is astandard document window--movable, resizable, and scrollable horizontally andvertically.andP;  In this window, Sleuth lists all existing windows, visible andinvisible, in an outline showing the hierarchical relationship of parent andchild windows.andP;  Each entry in the list shows the basic information about thatwindow: its handle, ID, class name, rectangle, and text.andP;  You candouble-click any entry to show all the information Sleuth can find out abouta particular window, and see the information in a new window that Sleuthopens for each entry you double-click.andP;  You can also use the cursor keys toselect an entry instead and then hit Enter or select the &quot;Show Detail&quot; menuitem.andM;Figures 2-5 show Sleuth running on OS/2 and the Macintosh; note that the OS/2version shows information about more windows than the others.andP;  That's becausethe native version of Sleuth captures information about every window createdby Presentation Manager, regardless of the application that created them.andO;The other versions only know about the windows created by the PresentationManager emulator, either MacPM or WinPM, which essentially means only thewindows created by Sleuth itself.andP;  While Sleuth on its native environment isuseful for looking at how other applications do things, it isn't on the othersystems.andP;  However, if I were implementing a &quot;serious&quot; application on MacPMand WinPM, the Sleuth window is the first thing I would use in debugging therest of the program.andP;  (I would also add a message trace window as inMicrosoft's Spy program; that isn't in this version of Sleuth.)andM;Even as simple as it is, Sleuth uses a lot of Presentation Manager'sfunctionality.andP;  Many of its features--menus, text painting, scrolling--arethe same things that would be used by, say, a simple text editor.andP;  In fact,an interesting thing happened as I was implementing MacPM (Sleuth's firstexcursion into foreign territory).andP;  I had to sweat out a lot of code to get asmall portion of Sleuth running: the event/message manager, window manager,and all sorts of utility functions such as mapping between PM and Maccoordinates.andP;  Big chunks of the PM version of Sleuth were #ifdef'd out for along time while I just tried to get one message through a window functioncorrectly.andP;  Once I got past a certain point, things started coming togethermuch more smoothly.andP;  With the overall framework in place, filling in the bitsand pieces became much easier.andM;MacPMandM;MacPM provides enough of the PM functions and messages to let Sleuth, aswritten for PM, run on the Macintosh.andP;  All that is required is recompilingthe code on the Mac, using MacPM's .H files, and linking it with the MacPMcode.andP;  Only MacPM makes any native Macintosh calls; Sleuth doesn't even knowit is running on a Macintosh.andM;MacPM makes no attempt to completely emulate Presentation Manager.andP;  Itprovides only those portions of PM that Sleuth actually uses.andP;  In many cases,I did try to code MacPM functions and messages the &quot;right&quot; way, even thoughSleuth only uses some of their options, but I did take shortcuts.andP;  The primegoal was to get a particular application running.andP;  With differentapplications, there are different areas you have to concentrate on, but thecentral features--PM-style message and window management--are similar.andP;  Youcan build any degree of compatibility you wish into a library like MacPM, upto virtually 100 percent.andM;The best way to understand MacPM is to follow how it is used by Sleuth.andP;  Ifyou have the MacPM code on your Macintosh, you can trace through it usingLightspeed C's source debugger while you read this description.andM;InitializationandM;As with all good PM programs, Sleuth starts out with calls to WinInitializeand WinCreate MsgQueue.andP;  These functions are in MpmInit.c.andP;  In PM,WinInitialize just initializes the heap- and atom-management functions,leaving the graphics and windowing initialization for WinCreateMsgQueue.andO;MacPM follows the same pattern.andP;  WinInitialize (see Figure 6) does someMacintosh memory management initialization and returns a dummy HAB (anchorblock handle) value.andP;  (I've cheated already.andP;  Not only have I skipped theheap and atom initialization--since MacPM doesn't yet support thosefunctions--but by just pretending to have an anchor, I'm risking getting lostat sea.andP;  Since MacPM is linked in as part of a single application, it can getaway with not really allocating anchor blocks and a few other things.)andM;WinInitialize also opens up a resource file called MacPM.rsrc.andP;  Macintoshresources are used similarly to PM and Windows resources, but there is moreflexibility about where resources are located.andP;  Some resources are found inthe System file or in ROM, others in the application executable file, andstill others are in resource files explicitly opened with OpenResFile.andP;  UnderLightspeed C, it's a common practice to have a separate resource file duringdevelopment.andP;  This helps provide a quick turnaround; there is no need tomerge the resources into the application file.andP;  When the application is readyto ship, a stand-alone application file can be built and the OpenResFile callremoved.andP;  (Or the call can even be left in; it will try to open the file butfail, and we can just ignore the error return code.)andM;WinCreateMsgQueue (see Figure 7) is where the real work begins.andP;  First itdoes the rest of the generic Macintosh initialization that you will find atthe beginning of any Mac application--initializing QuickDraw, the EventManager, the Window Manager, and assorted friends.andP;  Then it calls MpmInitSysValues to initialize the system values that WinQuerySysValue can access.andO;These values are derived from appropriate Macintosh functions orvalues--hardcoded where the corresponding Mac value is an absolute number ofpixels.andP;  For example, the width of a standard Mac vertical scroll bar is 16pixels, now and forever.andP;  This is hard-coded into nearly every Macapplication.andM;Next, WinCreateMsgQueue registers all of the predefined window classes,making a call to WinRegisterClass for each one.andP;  This function is prettystraightforward.andP;  First it checks if the class is already defined, and if notit allocates a block of memory and stores the class information in it.andP;  Thisblock includes a CLASSINFO structure as defined in PM, along with a few otherpieces of information about the class.andP;  The class blocks are kept in a linkedlist so WinCreateWindow can search through them.andP;  In theory, MacPM shouldhave the PM atom-management functions to search for a class name, but I tooka shortcut using a &quot;quick-and-dirty&quot; hashing function.andM;WinCreateMsgQueue wraps up its work by creating two predefined windows: thedesktop and object windows.andP;  Presentation Manager apparently creates thesewindows as special cases; they don't have window classes like other windows.andO;In MacPM, it seemed simpler to make up an additional window class,WC_DESKTOP, and then call WinCreateWindow to create these two windows as itdoes the others.andP;  They are still special cases in that they have nocorresponding Mac windows.andP;  The desktop window lets you write to the entirescreen, just as in PM.andP;  Object windows aren't really implemented in MacPM; itcreates the top level object window but doesn't do much else with it.andM;Creating a WindowandM;With WinCreateWindow (see Figure 8), found in MpmCreate.c, we are gettinginto the real inner workings of MacPM.andP;  As I mentioned earlier, the Macintoshhas nothing corresponding to PM's hierarchy of windows.andP;  There is only asingle window level, corresponding to a main window in PM.andP;  There are nochild windows nor a desktop window.andP;  Nor does the Mac have the concept of awindow function to which messages can be sent.andP;  Macintosh events are a roughsubset of PM message, and the Mac provides functions to find out which windowa message relates to, but the interface is generally at a lower level.andP;  Forexample, there is no WinDefWindow Proc to handle default conditions; if youdon't include code to check for, say, a mouse click in the close box, thenthe user's going to have a tough time closing your window.andP;  Contrast thiswith the WM_SYSCOMMAND/SC_CLOSE message in PM or Windows, which you canhandle specially if you want or just disregard and pass through toWinDefWindowProc.andM;Since all these facilities are so fundamental to PM coding, WinCreateWindowcreates a window structure that can hold the information necessary for a PMwindow--desktop, main (top-level), or child.andP;  There is a window functionpointer, taken from the window class, along with all the WinCreateWindowinformation; style flags, owner and parent window handles (along withnext/previous sibling and first/last child window handles), PM-style windowsize and location, etc.andM;To communicate with the Macintosh world, the structure also holds a pointer(WindowPeek) to the corresponding Macintosh window structure.andP;  All childwindows of a given main window have the same window pointer.andP;  For childwindows that implement button and scroll bar controls, there is also a handle(ControlHandle) to the actual Macintosh control.andM;There is also a Mac adjustment rectangle, rectAdj, to help translate PMwindow coordinates into the proper Macintosh coordinate space.andP;  The PM childwindows (and main window) are all defined the same way they are in the realPM.andP;  Coordinates are always relative to the parent window, and the Ycoordinate counts up from the bottom--unlike the Mac and Windows, where Ycounts from the top down.andP;  Most Mac Toolbox functions expect coordinates tobe relative to the Mac's window client rectangle.andP;  The rectAdj field containsthe displacement (for all four sides) to get from the Mac window rectangle tothe Mac client rectangle.andP;  With this adjustment, it's possible to convert anyPM coordinate to the corresponding Mac coordinate, and vice versa.andP;  The fileMpmMap.c contains several mapping functions that convert points or rectanglesback and forth between Mac and PM coordinates.andP;  As you might guess, thesefunctions are used extensively throughout MacPM.andM;One last field in the MacPM window structure is the &quot;window kind.&quot;andP;  There arefour different kinds of windows as far as MacPM is concerned, soWinCreateWindow saves one of the following values in the window structure andthen takes care of some special processing for each:andM;* WK_OBJECT (object window): No special processing; not really supported inthis version of MacPM.andM;* WK_DESKTOP (desktop window): Save the screen boundaries and a pointer tothe Mac's full-screen graphics port (WMgrPort).andM;* WK_MAIN (top-level Macintosh window): Create a Macintosh window.andP;  The Macprovides several styles of windows, so we choose the best style based on thePM style flags and then call the Mac's NewWindow function to create theactual window.andP;  Not all PM styles are supported; for example, a borderlesswindow will get a border anyway.andP;  It's possible to create a borderless Macwindow, but it takes a more code (in Mac terms, a window defproc), and Sleuthdoesn't need one anyway.andP;  NewWindow returns a WindowPeek pointer to theMacintosh window structure; save that pointer in our window structure.andM;* WK_CHILD (child window): Set up the appropriate &quot;relative&quot; fields--such ashwndNextSibling, hwndTopChild, etc.--for this window and its parent andsiblings.andP;  This wasn't necessary for WK_MAIN windows, since we relied on theMacintosh's window list for main windows.andP;  But for child windows we have todo all this bookkeeping.andM;At this point, the window structure is completely initialized, andWinCreateWindow sends a WM_CREATE message to the window.andP;  Notes that thewindow is invisible at first, regardless of the WS_VISIBLE flag.andP;  Next,WinSetWindowPos is called in order to set the window position and send theWM_ADJUSTWINDOWRECT, WM_MOVE, and WM_SIZE messages.andP;  WinSetWindowPos andWinSetMultWindowPos are interesting functions we'll come back to a littlelater.andM;One final detail and then WinCreateWindow's job is done.andP;  Since the windowwas created invisible, we now check the WS_VISIBLE flag and callWinShowWindow if necessary.andP;  This makes the window visible and sends aWM_SHOW message to the window function.andM;Standard WindowsandM;After WinCreateMsgQueue returns, Sleuth registers its own client window classand then creates its main window with WinCreateStdWindow (see Figure 9).andO;This function, found in MpmFrame.c, is responsible for creating a documentwindow as well as the standard frame control windows and client window.andP;  Itsounds like it needs to do a bunch of WinCreateWindow calls, and that'sbasically what it does.andP;  WinCreateStdWindow assigns a default window size andposition for cases where WS_VISIBLE is specified.andP;  (If WS_VISIBLE isn't set,it creates the window with size and position values zeroed out, under theassumption that the application will position the window before making itvisible.)andP;  Then a WinCreateWindow call creates the frame window itself.andM;Now it's time to create the frame control windows according to the FCF_flagspassed to WinCreateStdWindow.andP;  Here we call an internal function,MpmFrameUpdate, in order to create the proper windows.andP;  MpmFrameUpdate isalso called if the frame window gets a WM_UPDATEFRAME message.andP;  (However, theearly PM documentation I worked with wasn't very clear about how this shouldoperate, so it's unlikely that I implemented it correctly.)andM;When all of this is finished, WinCreateStdWindow creates the client window,and then--if WS_VISIBLE is specified--sends a WM_FORMATFRAME message to theframe window and calls WinShowWindow in order to make it all visible.andO;WM_FORMATFRAME tells the frame window function in MacPM to position all itschild windows according to the current frame window size.andM;Frame Window DetailsandM;Some of the frame window initialization is handled inside WinCreateStdWindow,but as much as possible is parceled out to the individual window functions.andO;In addition to the WM_UPDATEFRAME and WM_FORMATFRAME processing inMpmFnwpFrame, several of the frame controls have special initialization intheir window functions.andP;  Scroll bars have the most work to do, so let's takea closer look at how they are created and positioned.andM;The code for scroll bars and scrolling is in MpmScroll.c.andP;  The scroll barwindow function, MpmFnwpScrollBar (see Figure 10), creates each Macintoshscroll bar control when it receives the WM_CREATE during WinCreateWindow.andP;  Ituses a straightforward call to the Mac's NewControl function, except for onelittle trick.andP;  NewControl does not have a parameter by which you can tell itwhether you want a vertical or horizontal scroll bar.andP;  Instead, it looks atthe scroll bar dimensions, and whichever direction is larger--vertical orhorizontal--is the kind of scroll bar you get.andP;  So, MpmFnwpScrollBar makes upan arbitrary rectangle to insure that NewControl creates the right kind ofscroll bar.andP;  (Remember that the window may be created with zero height andwidth, and the Mac wouldn't know if it should be a vertical or horizontalscroll bar.) If the window is later resized, you might get the wrong kind ofscroll bar if it is sized too small in either direction, but as long aswindow sizing has a large enough minimum bound, this isn't a problem.andM;These &quot;made up&quot; dimensions aren't the correct ones, but that's no problem,because the scroll bar is still invisible.andP;  Before it is displayed, alongcome the WM_MOVE and WM_SIZE messages to clean things up.andP;  Their processingis straightforward, simply calling the Mac's MoveControland SizeControlfunctions.andP;  With the scroll bar now properly positioned, the WM_SHOW messagethat comes along next can call the Mac's ShowControl function to make thescroll bar visible.andM;One subtle point here is that a scroll bar that is created viaWinCreateStdWindow actually gets the WM_MOVE and WM_SIZE messages twice.andP;  Thescroll bar, along with the other frame controls, is created with a zero sizeduring the WM_UPDATEFRAME processing.andP;  The first WM_MOVE and WM_SIZE messagesare sent at that time.andP;  Next the WM_FORMATFRAME processing makes a call toWinSetMultWindowPos to set the actual positions, sending a second pair ofWM_MOVE and WM_SIZE messages.andP;  This is not that uncommon a situation in PM;windows are often created with zero size then sized before being madevisible, and the PM documentation recommends that WM_SIZE processing beskipped if the size is zero.andM;The menu and system menu windows also have their work cut out for them, butit's handled a little differently.andP;  For one thing, they don't occupy anyspace in the Macintosh window--they are child windows only for the sake ofsending and receiving messages, not because they are visible as windows.andP;  Themenu bar, of course, is visible at the top of the Macintosh screen, and itcertainly doesn't look like a child of the frame window.andP;  It really is achild window, however, since WinQueryWindow (hwndFrame, FID_MENU, FALSE) willfind it, and you can send messages to it and your client window will receiveWM_COMMAND and other messages from it.andM;The idea of using an invisible child window--or an invisible window of anykind--may seem strange at first.andP;  Of course, in this particular case, I hadno choice; I wanted MacPM to emulate PM, but with the Macintosh menu style atthe top of the screen.andP;  The invisible child window is about the only way toaccomplish that.andP;  Invisible windows can be very handy in other situations,though.andP;  The mere fact that you can send messages to them and vice versagives you an opportunity to do something approaching object-orientedprogramming.andM;On the menu window code, I really cheated.andP;  In PM there's a full set of menumessages that let you manipulate menus dynamically, most of which would besimple enough to implement on the Mac--with the caveat that the Mac has onlythe single menu bar.andP;  Either the application can have only one window with ameny bar (as an ASSERT in MacPM enforces now), or you would have to come upwith a scheme for merging the various windows' menus into the one menu bar.andO;For that kind of application, the best approach would be to write it as anMDI window.andP;  There's a very convenient parallel between the MDI window withits menu bar and overlapping child windows, and the Macintosh screen with itsmenu bar at the top and overlapping windows below.andP;  In fact, as I write thisI am running MindWrite and Lightspeed C on the Mac, and each one has a&quot;Window&quot; menu at the end, just like MDI.andP;  (The Mac applications actually callit &quot;Windows,&quot; but that's close enough for rock 'n' roll.)andM;Nice as this daydreaming can be, there's none of it in this version of MacPM.andO;Instead, WinCreateStdWindow calls MpmMenuLoad (see Figure 11)--found inMpmMenu.c--if the FCF_MENU flag is set.andP;  MpmMenuLoad does some very simplE,generic Mac menu initialization.andP;  It loads in the menu bar definition fromthe resource file, looks for an Apple menu and adds the desk accessory menuto it, then displays the menu bar.andM;The last frame control with special initialization is the title bar.andP;  If theFCF_TITLEBAR flag is set, WinCreateStdWindow calls WinSetWindowText to passthe pszTitle parameter along to the title bar control.andP;  Next,WinSetWindowText sends a WM_SETWINDOWPARAMS message to the window inquestion, with the WPM_TEXT and WPM_CCHTEXT flags and the correspondingfields in the WNDPARAMS structure set.andP;  The title bar window function,MpmFnwpTitleBar, responds to WM_SETWINDOWPARAMS by calling the Mac'sSetWTitle function to set the displayed window title.andP;  MpmFnwpTitleBar isalso able to respond to WM_QUERYWINDOWPARAMS, getting the window title withthe Mac's GetWTitle function and passing it back to the caller.andM;The only complication in these messages is that the text strings must beconverted back and forth between the C and Pascal string formats.andP;  Macprogrammers working in C quickly get used to this since the Mac Toolboxfunctions all expect (and return) Pascal-style strings, which have no zeroterminator but instead have a length byte at the front.andP;  Lightspeed C doeshave Pascal-style string constants for this situation, but that doesn't helpin this case since Sleuth is pure PM-style C code and passes C-style stringsinto MacPM.andM;The remaining frame controls have no special initialization.andP;  They will havesome work later, when they receive mouse and other messages, but first, wehave to create those messages and get them to their destination.andP;  The codefor doing this is in MpmMsg.c.andM;EventsandM;With MacPM, a message isn't just a message, it's an event.andP;  MacPM, just likeWindows or the real PM, has event messages along with a host of other kindsof messages.andP;  I've discussed several initialization and notificationmessages, which any PM programmer should be familiar with.andP;  These messages godirectly to the destination window function via a WinSEndMsg call.andP;  This isone of the simplest functions in MacPM; other than a validity check on thewindow handle, all it does is make an indirect function call to the windowfunction.andP;  This function address is a cinch to get to and call with theMYWNDOF macro: return ( *MYWNDOF (hwnd) .pfnwp ) ( hwnd, msg, mp1, mp2 );andM;That's WinSendMsg at a glance--rather easy.andP;  Now for the fine print.andP;  AfterSleuth creates its main window and does some other initialization, it fallsinto a typical PM message loop: while ( WinGetMsg ( hab, andamp;qmsg, NULL, 0, 0 )) WinDispatchMsg ( hab, andamp;qmsg );andM;It happens that Mac applications are constructed around a similar main eventloop: while ( TRUE ) [ fMine = GetNextEvent ( everyEvent, andamp;theEvent );MyDispatchEvent ( andamp;theEvent ); ]andM;GetNextEvent is a Mac Toolbox function that returns the next event, very muchlike WinGetMsg.andP;  (The return value from GetNextEvent tells whether the eventoccurred in an application window or in a system window, that is, a deskaccessory.) MyDispatchEvent isn't part of the Mac Toolbox, but a functionthat would be part of this imaginary application to take care of the incomingevents.andP;  Before GetNextEvent picks them up, the Mac events are held in anevent queue much like PM's message queue.andM;The Mac provides events for the following conditions: mouse down and up, keydown and up (and key repeat), window update and activate/deactivate.andP;  These,of course, correspond closely to PM messages.andP;  The Mac has a few other eventsthat don't map well into any PM messages, so MacPM disregards them.andM;For the events that have corresponding messages, things are almoststraightforward.andP;  For instance, when we click the mouse in Sleuth's clientwindow we go into the main message loop, inside the WinGetMsg function.andO;Since WinGetMsg isn't supposed to return until it has a message for us, itsits in its own idle loop: while ( !andP;  WinPeekMsg ( hab, pqmsg, hwnd, msgMin,msgMax, PM_REMOVE ) ) WinWaitMsg ( hab, msgMin, msgMax );andM;Here's the tricky part: WinWaitMsg is the function that is finally supposedto wait for a message; and sure enough, it is indeed waiting in yet anotheridle loop: while ( !andP;  WinPeekMsg ( hab, andamp;qmsg, NULL, msgMin, msgMax,PM_NOREMOVE ) );andM;Note the difference between those two WinPeekMsg calls.andP;  The PM_REMOVE optionin the first one tells WinPeekMsg to pull the message from the queue, becausethat's what WinGetMsg is supposed to do.andP;  The second one has the PM_NOREMOVEoption, because WinWaitMsg is supposed to wait until a message is availableand then return, but with the message still in the queue.andP;  So you can seethat WinPeekMsg gets called somewhat redundantly during the course of asingle WinGetMsg call--first, inside WinWaitMsg to find out that the messageis available, then again inside WinGetMsg to actually pull the message.andO;While this isn't very efficient, it certainly made the coding easier--once Ihad both options of WinPeekMsg debugged, the other message functions felltogether with the simple code you see above.andM;WinPeekMsg is where life becomes interesting.andP;  It helps that Sleuth doesn'tuse the filtering options of WinPeekMsg, with which you can specify theminimum and maximum message numbers along with the window handle you'reinterested in.andP;  The window handle would be no problem, but implementing themessage numbers would be a nuisance.andP;  There is one special case internally inMacPM: WinSetActiveWindow calls WinPeekMsg specifically looking forWM[ACTIVATE messages only so it can have the WM_ACTIVATE sent to the windowat the proper time.andP;  The Mac normally queues this event.andP;  WinPeekMsg handlesthis as a special case, setting a different event mask for the Mac Toolboxcall.andP;  The event mask tells which events you want to receive.andM;Before asking for any events, WinPeekMsg calls the Mac's System Taskfunction.andP;  This yields control to desk accessories (and under MultiFinder, toother applications).andP;  Then WinPeekMsg calls either GetNextEvent orEventAvail, depending on whether you specified PM[REMOVE or PM_NOREMOVE.andO;(EventAVail is the same as GetNextEvent except it leaves the event in thequeue.)andP;  If an event is returned, WinPeekMsg then calls one of severalinternal functions to convert the event into the equivalent PM message, whichthen gets passed back to whatever called WinPeekMsg.andM;Mousing AroundandM;Mouse movement requires special treatment.andP;  The Mac does not have amouse-move event; it has events for mouse-down and mouse-up, but mousemovement doesn't generate an event.andP;  However, when no event is pending atall, GetNextEvent returns a special null event.andP;  Since the mouse position ispassed along with every event, as in PM, whether or not the event has to dowith the mouse, it's not too much trouble for WinPeekMsg to check the mouseposition when it gets a null event.andP;  If the mouse has moved, a WM[MOUSEMOVEmessage is generated.andP;  If not, WinPeekMsg just returns FALSE to indicate nomessage is available.andM;Mouse clicks are easier to handle than mouse movement--single clicks are,anyway.andP;  The Mac provides mouse-down and mouse-up events, so it's simply amatter of passing these through as PM messages.andP;  Double clicks are a littlemore complicated.andP;  Like many things on the Mac, there is no automatic supportfor these; the application must determine whether two mouse clicks are closeenough in time and space to be a double-click.andP;  MacPM should compare the timeand location of each mouse-down event with the most recent mouse-up eventand, if they are close enough, generate a WM_BUTTON1DBLCLK message instead ofa WM_BUTTON1DOWN.andP;  I say &quot;should&quot; because this isn't coded in this version ofMacPM.andM;Each one of these mouse events is passed through the MpmMsgMouse function(see Figure 12), which decides which window gets the message.andP;  First, itdetermines the proper main Mac window with a call to the Mac's FindWindowfunction.andP;  This not only tells which window the mouse was in, but which area,such as the size box or the close box.andP;  It also distinguishes mouse clicks ina system window (that is, a desk accessory) from those on the desktop itself.andO;If the mouse is in one of our windows, the mouse message has to be passed tothe correct child window.andP;  Some return codes from FindWindow indicate thisdirectly, like inGrow, which indicates the mouse is in the size box.andP;  Inthese cases, the proper child window is determined directly from the returncode (for example, the FID[SIZEBORDER window for inGrow).andP;  The inContentreturn code takes a little more work.andP;  The MpmMsgFindChild function does thetrick here; it scans through all the child windows of the main window,looking for a match on the child window rectangles.andP;  The appropriate childwindow then gets the mouse message, or the frame window gets it, if no childwindow matches.andM;In theory, there should be some WM[HITTEST messages flying around at thispoint.andP;  I didn't bother with these since things were working pretty wellwithout them and, to be honest, I wasn't sure from the preliminary PMdocumentation just how WM[HITTEST was supposed to work.andP;  An application usingchild windows in a more complex way might need the WM_HITTEST messages.andM;Keyboard and mouse messages require some translation to convert them to theproper PM form, but this is nothing special.andP;  Mouse messages do needtranslation from the Mac's coordinate system to PM's upside downsystem--which is a minor nuisance, but one that crops up several places inthe code.andP;  The mapping functions in MpmMap.c take care of this wherenecessary.andM;The Active LifeandM;The Mac's concept of active and inactive windows is very much the same asthat in PM and Windows; the topmost visible main window is the active window,and all others are inactive.andP;  All windows in each of these systems are&quot;active&quot; in the sense that the application may display information in them,but the topmost window has a different visual appearance to highlight it.andO;The Mac, however, places greater enphasis on the difference between activeand inactive windows; the scroll bars and size box disappear on inactivewindows, and a mouse click in an inactive window brings the window to the topbut is otherwise disregarded.andP;  Unlike Windows and PM--in which you click inany visible portion of any window, and it does what you expect--the Mac takesa second click to &quot;really&quot; click the mouse in the window.andP;  This is a flaw inthe original Macintosh user interface guidelines, and not all Macapplications follow it; some work like PM and Windows, making all windowsrespond immediately to clicks.andP;  The Finder, for example, works partially thisway.andP;  But I followed the majority and made mouse clicks in MacPM workaccording to the guidelines, even though it's less convenient.andP;  This iscertainly something to consider changing; I don't think Mac users wouldobject if their windows were more responsive.andM;In any case, MpmMsgActivate processes the Mac's activate event, turning itinto a WM_ACTIVATE message with the appropriate activate/deactivate flag.andO;There is a little trick in this function which shows up in several others aswell.andP;  Don't forget that WinPeekMsg can be called with either the PM_REMOVEor PM_NOREMOVE option.andP;  If called with PM_NOREMOVE, then later it will becalled again to pick up the same message with the PM_REMOVE option.andP;  So thelittle trick is that, in the PM_NOREMOVE case, MpmMsgActivate does nothingmore than return the PM message.andP;  When called again with the PM_REMOVEoption, it goes ahead and updates the grow icon and scroll bars to reflectthe new active/inactive state.andM;PaintingandM;Update events are the trickiest ones of all.andP;  These generate WM_PAINTmessages, of course, but an update event pertains to an entire Macintoshwindow; the Mac doesn't know we have child windows inside it.andP;  ThereforeMacPM must parcel out the WM_PAINT messages to the child windows, making sureeach one has the right coordinate system and clipping region.andP;  This is donein MpmPaint.c, and it's where I really started to wonder if child windows areworth it.andP;  To be honest, I could have gotten by with less work on the childwindow painting for this particular application.andP;  But I wanted to find outwhat's involved in emulating the individual WM_PAINT messages that get sentto child windows in PM.andM;MpmMsgPaint is where it all starts, and it's simple enough; it just callsWinUpdateWindow, once it determines that the PM_REMOVE flag was set on theoriginal WinPeekMsg call.andP;  WinUpdateWindow is the beginning of some seriouscheating.andP;  In the real PM, you can call WinUpdateWindow individually on anychild window, and that window will be painted immediately, while any otherpending updates remain deferred.andP;  The problem here is that the Mac hasBeginUpdate and EndUpdate functions that perform the same tasks as thefunctions WinBeginPaint and WinEndPaint in PM.andP;  However, these functionsapply to the entire Macintosh window; they know nothing of child windows.andP;  Icould have mimicked the PM operation exactly, but it was simpler to say thatany WinUpdateWindow call updates the entire Macintosh window, including allchild windows.andM;Given this restriction, WinUpdateWindow does the BeginUpdate, paints the growicon and all controls (for example, the scroll bars) with Mac Toolbox calls,then calls MpmPaintWindow to send WM_PAINT messages to the frame window andall child windows.andP;  Note that these are sent, not posted, since they must allbe mimicked before the EndUpdate call found at the end of WinUpdateWindow.andO;MpmPaintWindow is a simple recursive function that sends a WM_PAINT messageto a window and then calls itself for each first-level child of that window,thus sending WM_PAINT to all child windows at any level of nesting.andM;Now the fun begins.andP;  The WM_PAINT we're most interested in is the one sent toSleuth's client window function.andP;  Like all good WM_PAINT handlers (at leastones using the cached micro-PS), this begins with a WinBeginPaint call, whichreturns the presentation space handle for use in painting.andP;  MacPM has to do abit of work to create this PS, even though a MacPM presentation space barelyqualifies as a nano-PS, much less a micro-PS.andP;  For that matter, MacPM's&quot;cache&quot; of PSs is awfully tiny; only a single presentation space is reusedwhenever WinGetPS (see Figure 13) is called.andM;WinBeginPaint itself is easy enough.andP;  It just calls WinGetPS and thenconverts the Mac's visible region bounding rectangle to PM coordinates.andO;(During update processing, the visible region is clipped down to the formerupdate region.)andP;  Then WinGetPS copies the entire GrafPort structure from thespecified Mac window (or the Mac desktop) into the new PS.andP;  A GrafPort is theMac's structure that corresponds roughly to a device context in PM orWindows.andP;  In addition to copying the structure itself, a couple of CopyRgncalls are required to duplicate the visRgn and the clipRgn from the originalGrafPort.andP;  Once that's done, the visRgn in this new GrafPort must be clippeddown further to take the child window coordinates into account.andP;  (I couldhave left the visRgn alone and modified the clipRgn instead, and perhapsavoided the need to copy the GrafPort, but it seemed simpler and safer thisway.)andM;That's not hard in this version of MacPM, since it doesn't support theWS_CLIPCHILDREN and WS_CLIPSIBLINGS styles.andP;  However, it does supportWS_PARENTCLIP, or more significantly, the absence of WS_PARENTCLIP.andP;  IfWS_PARENTCLIP is set on a child window, the window lacks its own clippingregion, therefore using that of the parent, and it's up to the child windowto avoid drawing outside its boundaries.andP;  When WS_PARENTCLIP is missing, thechild window needs its own clipping region, so WinGetPS takes theintersection of the parent's clipping region and the child window's rectangleand makes that the new clipping region for the child.andM;If WS_CLIPCHILDREN and WS_CLIPSIBLINGS were supported, they would be handlednext.andP;  Each would basically be a loop over the window's children or siblings,subtracting the appropriate rectangles from the window's clipping region.andO;Since Sleuth doesn't use either of these window styles, the easiest way toimplement this was to just say &quot;no&quot;.andM;Now you see why WinGetPS makes a copy of the GrafPort it needs.andP;  With all ofthis modification to the clipping region, as well as other possiblemodifications we would need to make if we wanted to implement additional PMfeatures, the safest thing was to make a private copy of the whole structure.andO;There are probably plenty of optimizations that could be made but, moreimportantly, it works.andM;That's our presentation space such as it is; so now what does Sleuth do withit?andP;  Just two things: a GpiErase and a series of GpiCharStringAt calls.andP;  InMpmGPI.c (see Figure 14) these functions were remarkably simple to implement,because all the dirty work was already done.andP;  GpiErase is nothing more than acall to the Mac function EraseRgn, passing it the visRgn from our modifiedGrafPort in the pico-PS.andP;  GpiCharStringAt breaks down into GpiMove--whichcalls the Mac's MoveTo function--and GpiCharString, which is a simple call tothe Mac's DrawText function.andM;Although they took a lot of work, the simplicity of these GPI functions givesme hope that other simple GPI drawing functions would also be easy toimplement on the Mac.andP;  Some of the fancier GPI stuff would, I suspect, be alot of work since the Mac doesn't have exact equivalents.andM;When Sleuth is done painting its client window, it calls WinEndPaint, whichdoes nothing more than make a call to WinReleasePS, which in turn just freesup the pico-PS by discarding its regions and marking it as no longer in use.andM;One other topic in window painting is invalidation.andP;  Sleuth does call theWinInvalidateRect function whenever it wants to force its client window to berepainted, and this function is very straightforward.andP;  It just converts therectangle to a Mac rectangle and then calls the Mac's InvalRect function.andO;It's then up to the Macintosh event manager to generate an update event.andM;After all of this discussion about WM_PAINT, one strange fact is that none ofthe window functions in MacPM itself provide much in the way of WM_PAINTprocessing.andP;  Since the frame control windows all happen to be Macintosh&quot;controls&quot; as well (or invisible), they were all drawn back at the beginningof WinUpdateWindow, when it called the Mac's UpdtControl function.andP;  Theydon't have to do anything else.andM;The only window function that handles WM_PAINT is the frame window function,MpmFnwpFrame, which does not really paint anything; the Mac Toolbox takescare of the drawing of the window frame.andP;  It does erase the client areabackground, by sending a WM_ERASEBACKGROUND message to the client window.andO;The client window can either erase the background itself on this message andreturn TRUE, or else return FALSE and let the frame window do the erasing.andO;This is done with a GpiErase call, bracketed by WinGetPS and WinReleasePS.andO;This WM_ERASEBACKGROUND processing doesn't really achieve the purpose that itdoes in PM, which is to cause synchronous background erasing in anasynchronously painted client window--because I neatly sidestepped the wholeissue of synchronous vs.andP;  asynchronous painting.andP;  MacPM uses its own strangebrew when it comes to window painting.andM;ScrollingandM;Because Sleuth's windows are scrollable, MacPM must provide the two pieces ofPM window scrolling: scroll bar tracking and messages, and theWinScrollWindow function.andP;  Scroll bars on the Mac are a pain to deal with.andO;Not only must you position them yourself--there's no asking for and getting astandard scroll bar--but your code must get much more involved in trackingthem.andP;  Unlike PM and Windows, in which a scroll bar can track itself and sendmessages to its owner, application code must call the proper trackingfunction (depending on which part of the scroll bar was clicked) and dealwith more of the busywork itself.andP;  Sleuth, being a PM application, doesn'thave to worry about this, but MacPM does.andP;  MpmScroll.c has all the details.andM;When the mouse is clicked in a scroll bar, this sends a WM_BUTTON1DOWNmessage to MpmFnwpScrollBar.andP;  After converting the PM mouse coordinate to aMac point, this calls the Mac's FindControl function, which identifies theMac control containing that point, and which part of the control it is.andP;  Wealready know which Mac control should be returned here, since theWM_BUTTON1DOWN was here initially because it hit this particular childwindow, and MacPM's window structure for a control includes the Mac controlhandle.andP;  So this is a good place for an ASSERT macro to trap out, if for somereason FindControl returned a different control from what we expected.andP;  (Youwill find a lot of ASSERTs in MacPM; they are an invaluable debugging tool.)andM;The piece of information we are really after from the FindControl call is the&quot;part code,&quot; which tells whether the mouse was in the thumb, page up/downarea, or one of the arrows.andP;  We need to know whether the mouse is in thethumb or not because we're about to call the Mac's TrackControl function, oneof the more bizarre functions in the Mac Toolbox.andP;  It does the actual mousetracking, either dragging a gray rectangle for the thumb or monitoring mousemovement and release in the arrows or page areas.andM;TrackControl looks simple enough; you pass it the control handle, mouseposition, and a pointer to a callback function that is called repeatedlyuntil the mouse is released.andP;  The weird thing is that you have to use twodifferent callback functions, one for thumb tracking and one for everythingelse, and they take different sets of parameters.andP;  The arrow and pagecallback is reasonably straightforward; it receives as parameters the controlhandle and part code, and it only gets called if the mouse is inside theproper tracking limit rectangle (that is, the arrow or the page area).andP;  InMacPM this function, MpmTrackScrollBar, just sends a WM_HSCROLL or WM_VSCROLLmessage to its owner, with the SB_command code determined by the Mac's partcode.andP;  Then as in PM it's up to the owner to set the new scroll bar positionand do any needed window scrolling.andM;The thumb tracking callback is where things get difficult.andP;  This function hasno parameters at all; it must figure everything out by reading the mouseposition each time it's called.andP;  The function has to calculate the new scrollbar value itself, based on how far the mouse has moved and on the originalscroll bar value and range.andP;  This isn't a difficult calculation, but it's nottrivial, and it's silly to require the application to calculate it, giventhat TrackControl is capable of calculating the final scroll bar positionwhen the mouse button is released.andP;  It should have made this same calculationduring tracking and passed it to the thumb tracking function as a parameter.andM;But that's not the worst of it.andP;  You've probably noticed that when you drag ascroll bar thumb--on PM, Windows, or the MAC--it will continue to track ifthe mouse is within a certain distance of the scroll bar, but it jumps backto its original position if you move too far.andP;  Move it closer and it resumestracking.andP;  TrackControl takes care of this as far as the visual aspect.andP;  Butdoes the thumb tracking callback know whether tracking is suspended becausethe mouse is too far away?andP;  Well, it can just compare the new mouse positionwith...what?andP;  Dumb question.andP;  I forgot that the thumb tracking callbackdoesn't get told anything.andM;Although I haven't disassembled TrackControl, I suspect it's calling anotherToolbox function called DragGrayRgn, which tracks the mouse and drags a grayoutline of a rectangle or other region.andP;  One of the parameters to thisfunction is a &quot;slop rectangle,&quot; which determines how far the mouse may straybefore tracking is suspended.andP;  This slop rectangle would be just the thingthe thumb callback needs, but it's stored somewhere on the stack, and isinaccessible to the thumb callback.andM;Need I say that after much experimentation I finally gave up on including athumb tracking function in MacPM?andP;  The only harm done is that theSB_SLIDERTRACK notification isn't supported, so Sleuth does not scroll itswindow during thumb tracking, only afterward.andP;  If you've ever wondered whynearly all Mac applications wait until thumb tracking is complete beforeactually scrolling their windows, this is why.andP;  At least 99 percent of theMac programmers in the world came to the same conclusion I did: thumbs down.andM;Even without worrying about thumb tracking, there's one more minorcomplication with the thumb.andP;  When you release the mouse button, TrackControlcalculates the new scroll bar position and sets the scroll bar to thatposition.andP;  However in PM, when the SB_SLIDERPOSITION notification is sent,the new position has not yet been set.andP;  An SBM_QUERYPOS message returns theold position, but it's the responsibility of the application to set the newposition.andP;  MpmFnwpScrollBar handles this by saving the old thumb position ina local static variable at the beginning of thumb tracking, at which time thelocal static flag fTrackThumb is also set, including the moment theSB_SLIDERPOSITION is sent.andP;  Then it's a simple matter for the SBM_QUERYPOScode to check fTrackThumb and return either the old value or the currentvalue (in the normal case).andP;  When Sleuth follows up by sending an SBM_SETPOSmessage, the position has already been set, but the redundant call does noharm.andM;Enough complaining about scroll bars.andP;  The other part of scrolling,WinScrollWindow, is a lot simpler.andP;  Sleuth calls this function when it isready to actually scroll its client window.andP;  WinScrollWindow first checks forchild windows and adjusts their positions if the SW_SCROLLCHILDREN flag isset.andP;  (There aren't any child windows inside Sleuth's client window, so itdoesn't use SW_SCROLLCHILDREN.)andP;  Then it picks up the window rectangle forthe window to be scrolled, converts it to Mac coordinates, and passes theresulting rectangle to the Mac's ScrollRect function.andP;  This function scrollsthe bits in the window and then calculates the invalidated region.andP;  Itdoesn't actually invalidate the region and cause it to be repainted, itmerely calculates it.andP;  So, WinScrollWindow then calls the Mac's InvalRgnfunction to accumulate this region into the window's update region.andM;Movement and SizingandM;Even though the child windows for FID_TITLEBAR and FID_SIZEBORDER aren'tactually visible in MacPM, their window functions (in MpmFrame.c) provide thesame services as in PM itself.andP;  In each case, the WM_BUTTON1DOWN message willcause the appropriate mouse tracking and window movement or sizing.andO;MpmMsgMouse directs this message to the FID_TITLEBAR or FID_SIZEBORDER windowwhen the Mac's FindWindow function returns the inDrag or inGrow window areacode.andP;  For FID_TITLEBAR, the MpmFnwpTitleBar function takes the message andconverts the mouse location back to Mac coordinates, then calls the Mac'sDragWindow function.andP;  This function performs the mouse tracking and actuallymoves the window when the button is released, if the mouse was inside abounding rectangle that was passed to DragWindow.andP;  MpmFnwpTitleBar calculatesthis bounding rectangle somewhat arbitrarily, four pixels inside the actualscreen size (not including the menu bar).andP;  After the button is released,MpmFnwpTitleBar checks to see if the window actually did move, and if so,sends a WM_MOVE message to its owner (the frame window).andM;Window sizing is similar, but a little more complicated.andP;  MpmFnwpSizeBordertakes the WM_BUTTON1DOWN message in this case, and calls the Mac's GrowWindowfunction to do the mouse tracking.andP;  Unlike DragWindow, GrowWindow doesn'tactually resize the window--it just returns the new mouse position.andP;  ThenMpmFnwpSizeBorder picks up the old frame window size and position by usingWinQueryWindowPos and sets the new size and position withwinSetMultWindowPos.andP;  WinSetMultWindowPos is more convenient thanWinSetWindowPos in this particular case, since it takes an SWP structure thatis exactly like the one filled in by WinQueryWindowPos.andP;  WinSetMultWindowPostakes care of sending the WM_MOVE and WM_SIZE messages to the frame window,which in turn sends itself a WM_FORMATFRAME message to reposition the framecontrols and client window.andP;  Before calling GrowWindow, MpmFnwpSizeBordershould send the frame window a WM_QUERYMINMAXINFO message, but instead itmerely sets arbitrary tracking limits: 100-pixel minimum height and width, nomaximum limit.andM;Menu SelectionandM;The menu window function MpmFnwpMenu, located in MpmMenu.c, does triple dutybecause there are three different &quot;menus&quot; to consider: the menu bar, thesystem menu (close box on the Mac), and the minimize/maximize icons (zoom boxon the Mac).andP;  In PM each of these is a true menu and they are all treated thesame.andP;  In MacPM the close box and zoom box are special cases but, to beconsistent with PM, they are all handled in MpmFnwpMenu.andP;  MpmMsgMouse directsthe WM_BUTTON1DOWN message to one of these three frame controls and, sincethey are all of class WC_MENU, MpmFnwpMenu gets the message in each case.andM;For FID_SYSMENU (the close box), it's straightforward.andP;  MpmFnwpMenu simplycalls the Mac's TrackGoAway function and, if that function returns TRUE, thenit sends a WM_SYSCOMMAND message with the SC_CLOSE command to its owner, theframe window.andP;  MpmFnwpFrame passes this command message through to the clientwindow, and Sleuth's client window function merely passes it on toWinDefWindowProc, which posts a WM_QUIT message to the application queue.andM;FID_MINMAX (the zoom box) is almost as simple, but I cheated a little withthis one.andP;  Back in MpmMsgMouse, the FindWindow function returned twodifferent area codes for the zoom box, inZoomIn or inZoomOut, depending onwhether the window is currently zoomed or not.andP;  The Mac provides a simpleZoomWindow function to do the actual zooming or un-zooming, but that functionexpects to receive the inZoomIn or inZoomOut code to tell it which to do.andO;So, I simply passed that code along in the high-order word of mp2 in theWM_BUTTON1DOWN message.andP;  That word happens to be unused in PM, so I was ableto get away with this nonstandard use.andP;  Given that little trick, MpmFnwpMenucalls the Mac's TrackBox function and if the function returns TRUE, sendseither an SC_RESTORE or SC_MAXIMIZE message to its owner, the frame window.andO;MpmFnwpFrame takes over from there, calling the Mac's ZoomWindow function andsending the appropriate WM_MOVE and WM_SIZE messages.andM;There's one more thing that MpmFnwpMenu has to deal with and that is the menubar itself.andP;  When the house button is pressed in the menu bar, MpmMsgMousedirects the WM_BUTTON1DOWN message to the FID_MENU control window.andO;MpmFnwpMenu sends a WM_INITMENU message to its owner, then calls the Mac'sMenuSelect function to do the mouse tracking.andP;  This function returns the Macmenu ID; the high-order word is the resource ID for the pull-down menu, andthe low-order word tells which item was selected on the menu.andP;  Unfortunately,while resource IDs may be chosen as desired, the menu item number in thelow-order word is simply a sequential index into the menu.andP;  This is differentfrom PM or Windows, where you can assign your own menu IDs to each menu item.andO;It means that if you want to move a menu item to a new position, you mustupdate your definitions in the C code and recompile.andP;  For MacPM I could haveset up a way to allow arbitrary menu IDs--the way that Windows and PM allowthem--but it was simpler to just use the Mac's numbering convention,assigning menu IDs in the PM version that would match the Mac's menu IDs.andM;The code in MpmFnwpMenu has to check one more thing.andP;  The Apple menu has alist of desk accessories as well as menu items for the application itself.andO;If the menu selected was a desk accessory, it starts up that desk accessorywith an OpenDeskAcc call.andP;  Otherwise, it sends a WM_COMMAND message to itsowner, the frame window.andP;  The frame window function passes this message alongto the client window, where Sleuth's window function handles it.andM;Header FilesandM;In MacPM I followed the principle that the Presentation Manager C code shouldrun unchanged.andP;  I would have liked to apply this to the .H files as well asthe .C files, because the OS/2 .H files contain all the necessarydeclarations.andP;  However, because of the compiler differences I mentionedearlier, it didn't quite work out this way.andP;  I was able to use the .H filesfrom OS/2 with Lightspeed C, but it took some manual editing to get them tocompile.andP;  Here's what I had to change:andM;Conditional compilation.andP;  ANSI C has a number of new preprocessor featuresthat aren't present in Lightspeed C.andP;  The only one used much in the OS/2 .Hfiles is the #if defined(name) construct.andP;  This serves the same purpose asthe older #ifdef but allows checking for more than one symbol at a time.andP;  TheOS/2 .H files use this in many places, in a form like the following: #if (defined (INCL_WINFRAMEMGR) ! !defined (INCL_NOCOMMON) )andM;Since I didn't care about the check for INCL_NOCOMMON, I edited them to workwith Lightspeed C: #ifdef INCL_WINFRAMEMGRandM;Fortunately most of the conditional compilations were already in the #ifdefform (they only test for a single symbol), so there weren't too many placesthat needed editing.andM;Prototypes for function pointer declarations.andP;  Although Lightspeed C acceptsfunction prototypes, it does not accept them for pointer types, such as:typedef VOID (PASCAL FAR *PFNEXITLIST) ( USHORT );andM;I took care of these with the simple expedient of commenting out theparameter declarations: typedef VOID (PASCAL FAR *PFNEXITLIST) ( /*USHORT*/); NEAR, FAR, and PASCAL keywords.andP;  Since Lightspeed C and Microsoft C bothsupport the &quot;pascal&quot; keyword differently, I decided to forego the use of thePascal calling sequence.andP;  Most uses of the &quot;pascal&quot; keyword in the .H filesare coded as PASCAL (which is #define'd as pascal), so I just changed the#define to make PASCAL an empty string.andP;  The same thing applies for NEAR andFAR, since they aren't relevant in the Mac environment: #define PASCAL#define NEAR #define FARandM;One slightly odd thing is that OS2DEF.H fails to use these #define'd symbolsin several places, falling back to the lowercase names.andP;  This doesn't seemintentional and will hopefully be corrected in a future version of this file.andO;In the meantime, I added two more #define's to effectively disable &quot;near&quot; and&quot;far&quot;: #define near #define farandM;I couldn't do this with &quot;pascal&quot;, since Lightspeed C needs this keyword forits own .H files, which define all the Mac Toolbox entry points.andP;  More manualediting was called for: changing &quot;pascal&quot; to &quot;PASCAL&quot; where it occurred inOS2DEF.H.andP;  The other OS/2 header files didn't have this problem.andM;Different calling sequence (order of parameters).andP;  Deciding not to use thePascal calling sequence led to a complication.andP;  There are several datastructures and macros in PMWIN.H that assume the Pascal calling sequence.andO;The SWP data structure, for example, is defined so that the parameters passedin a call to SetWindowPos can be directly referenced as an SWP structure.andP;  Toallow this, I reversed the order of the fields in these structures, becausethe C calling sequence pushes the parameters in the opposite order from thePascal sequence.andP;  Similarly, I had to change the COMMANDMSG, CHARMSG, andMOUSEMSG macros and their associated structures to work with the C callingsequence.andP;  Using the C calling sequence was a mixed blessing; it led to extrawork but avoided the need to edit every single function declaration to allowfor the different positioning of the &quot;pascal&quot; keyword.andM;WinPMandM;As you can see, getting Sleuth running under MacPM was a lot of work.andP;  Somuch, in fact, that I must confess I didn't get a working WinPM written intime for this article.andP;  In lieu of actual code, let's take a look at some ofthe issues involved in putting together a WinPM, starting with windowclasses.andM;Because Windows resembles PM more than the Mac does, it would be handy to useexisting Windows features.andP;  I would be tempted to use the window classmechanism in Windows instead of coding it from scratch, as in MacPM.andP;  Iwonder, however, if this would be a good strategy.andP;  Window classes under PMare much simpler than under Windows, with many of the items in the WindowsWNDCLASS structure eliminated.andM;Instead, the frame window class and the FCF_ and FS_ options inWinCreateStdWindow handle these items.andP;  For instance, under Windows allwindows of a given class have the same icon, whose handle is stored in theWNDCLASS structure.andP;  Under PM, the window class does not determine the icon;each frame window can have its own icon, and it's normally loaded in from theresource file according to the frame window ID.andM;Depending on the application these differences could be glossed over, butSleuth is a tough cookie with issues like this.andP;  It calls functions likeWinQueryClassInfo, which have no direct counterpart in Windows.andP;  Thisfunction is a particular problem.andP;  Under Windows, there is no direct way toget at the class information given a class name.andP;  You can do it, but you mustcreate an invisible window of the desired class, just to call GetClassWordand GetClassLong to pick up the class information.andM;With problems like this, it may be worthwhile to keep the class support codefrom MacPM.andP;  You would still need to register the window classes withWindows, so there is some redundancy.andM;MessagesandM;Message passing is another place where it's tempting to directly use Windowsfacilities, since window functions are so similar in the two systems.andP;  That'swhat the macro binding system in the Presentation Manager Conversion Guidedoes.andM;The goal of attempting to maintain &quot;pure&quot; PM code seems to lead to too manyproblems.andP;  For starters, a window function in Windows takes a 16-bit windowhandle, and its two parameters are different lengths: 16-bit and 32-bit.andP;  InPM, all these items are 32-bit.andP;  You could fudge the declarations in PMWIN.Hto make everything the same length as in Windows, but this still wouldn'thandle the differing contents of the message parameters.andM;I'd probably leave the PM window functions alone, with 32-bit window handlesand two 32-bit parameters.andP;  Unlike MacPM, where all the message processinghad to be coded from scratch, this could be handled by having WinPeekMsg callthe Windows function PeekMessage and then do the proper conversions.andO;WinDispatchMsg and WinSendMsg would not talk to Windows at all; they woulddirectly call the PM window function, avoiding the problem of differentfunction formats.andM;For messages that are sent from Windows directly to the window functioninstead of being posted to the queue, the problem is a little different.andO;Instead of giving Windows the address of the PM window function, there wouldhave to be a common window function that Windows would call in all cases.andO;This function would convert the parameters appropriately, find the address ofthe correct PM window function (probably using space in the &quot;window extra&quot;data), and call the PM window function.andM;Frame ControlsandM;Window function differences notwithstanding, it makes sense to create childwindows for all the frame controls, just as PM does.andP;  I'd take the sameapproach as in MacPM, where scroll bars are visible child windows in theirexpected positions, but the title bar, menu bar, and other frame controls areinvisible existing only for the purpose of message passing.andP;  Windows, ofcourse, already supports child window scroll bars as well as &quot;standard&quot;scroll bars.andP;  I would forget about using standard scroll bars; the only extraburden for using child window scroll bars is that their size and positionmust be explicitly calculated, which is not difficult.andP;  For the other framecontrols, invisible child windows would make it easy to mimic their operationunder PM.andM;Painting/ScrollingandM;With the limited use Sleuth makes of GPI, it's not hard to provide the samefunctionality by converting the GPI calls into the equivalent GDI calls, theway MacPM does.andP;  Also, the window painting logic is much more straightforwardthan under MacPM.andP;  The various shortcuts I mentioned earlier won't benecessary; Windows generates WM_PAINT messages for child windows andtop-level windows the same way PM does.andP;  A thin layer is needed to take careof the differences in WinBeginPaint vs.andP;  BeginPaint, and then I expect therest would work pretty smoothly.andM;Application or DLL?andM;One simplifying assumption in MacPM was that it had to support only a singleapplication, since the MacPM code is linked in with the application.andP;  InWindows this same approach could be used, but the right way to code a WinPMwould be as a dynamic-link library (DLL), so it could support more than oneapplication.andP;  The mechanics of linking to a DLL are no problem, but acomplicating factor is that WinPM would then have to handle multipleapplications calling it.andP;  This would rule out using some static variables theway MacPM does.andP;  Instead, the proper data structures would have to beallocated as needed.andM;One thing that causes problems in Windows DLLs is that they have no way toautomatically find out when they are being unloaded.andP;  There's a libraryinitialization entry point, but no library termination function.andP;  Fortunatelythe PM API takes care of this with its WinInitialize and WinTerminatefunctions.andP;  On the WinTerminate call--or on WinDestroyMsgQueue--the WinPM DLLcan release any resources it has allocated for that application.andM;A Reader ExerciseandM;Due to publication deadlines, there are several things I left unimplementedin Sleuth and in WinPM and MacPM.andP;  If you would like to try spiffing it up abit, here are some areas you could improve.andM;The detail windows in Sleuth (see Figure 15) don't exist.andP;  To make them work,you'd have to add some code, but this should require little or no change toWinPM and MacPM as far as creating and destroying these windows; the code'salready there for that.andP;  It would take a little work to get double-clickmessages from MacPM.andP;  This isn't hard, but MpmMsgMouse would have to keeptrack of the time and position of the last mouse-up, and check eachmouse-down to see if it looks like a double click.andP;  Then it would simplygenerate a WM_BUTTON1DBLCLK and not a WM_BUTTON1DOWN.andP;  The &quot;Show Detail&quot; menuitem should do the same thing as a double-click.andP;  This means that Sleuthshould have some code for selecting a line with a single click or with thecursor keys.andP;  MacPM has to be able to generate keystroke messages for this.andM;There's an &quot;About Sleuth...&quot; menu item, but it doesn't do anything.andP;  Dialogboxes are an area that I omitted completely from MacPM and WinPM, so it wouldtake some work (and careful thought) to implement them.andM;One little thing in MacPM that you could fix is the group of items on theEdit menu, which should be grayed out when Sleuth's own windows are active.andO;Those items are really there for desk accessories and should be enabled onlywhen a desk accessory is active.andP;  Also, they need to call the SystemEditfunction to make them actually work.andP;  There's some debugging to do with deskaccessories; there are really three different environments they can run in:non-MultiFinder, MultiFinder using the DA Handler layer, and MultiFinderusing the application layer.andP;  (The last choice is what happens if you holdthe Option key down while starting a desk accessory under MultiFinder.)andP;  Igot desk accessories working in some cases but not in all these situations.andM;I had mentioned earlier a couple of places where the WM_QUERYMINMAXINFOmessage should be sent, but MacPM and WinPM just choose arbitrary rectanglesinstead.andP;  There's a bug in MacPM where, if a scroll bar is disabled and youclick in it, the system seems to freeze until you click the mouse somewhereelse ten (yes, ten) times.andP;  Then it suddenly catches up with all thoseclicks.andP;  Finally, if you're feeling really ambitious, you could tryimplementing the SB_SLIDERTRACK message.andP;  You'll find some commented-out codein MacPM where I tried to get this one working.andP;  Have fun!andM;No Free LunchandM;As we've seen, there is no easy solution to the problem of portability acrosswindowing environments as disparate as Presentation Manager, Windows, and theMacintosh.andP;  Is it worth the work?andP;  Perhaps I should ask instead if you canafford not to do it.andP;  Each of these systems represents a large (or in thecase of Presentation Manager, soon to be very large) market, and peoplereally appreciate having the same or similar software available on both theMac and PC.andP;  The approach I've taken with MacPM and WinPM seems like afruitful one, but I sure would have liked it if someone else had done thedirty work for me!andP;  Depending on your application, a toolkit like XVT mightdo a good job for you.andP;  My personal hope is that C++ with some good classlibraries will make porting much easier.andP;  But I suspect that regardless ofhow good the tools get, the old saying will still be true: there's no freelunch.andO;</TEXT></DOC>