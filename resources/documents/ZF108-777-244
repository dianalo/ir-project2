<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-777-244  </DOCNO><DOCID>08 777 244.andM;</DOCID><JOURNAL>Data Based Advisor  August 1990 v8 n8 p72(8)* Full Text COPYRIGHT Data Based Solutions 1990.andM;</JOURNAL><TITLE>The client-server paradigm: making sense out of the claims.andO;(includes related article on what is available in client-serversoftware) (tutorial)</TITLE><AUTHOR>Buzzard, James.andM;</AUTHOR><SUMMARY>The client-server architecture is a special form of distributedcomputing in which the processing of an application is partitionedbetween attached client and server computers depending upon thespecific requirements of each application.andP;  The basic requirementsof a 'true' client-server system are: communication between clientand server, client initiates interactions with server, serverimposes some restrictions on client's ability to request servicesor data, server arbitrates conflicting requests from multipleclients and partitioning of application processing between clientand server.andP;  Benefits of the architecture include ability to uselow-cost, modular computer systems, processing can be kept closeto the data being processed and data base technology is focusingon client-server processing.andP;  Disadvantages and common myths aboutclient-server products are discussed.andM;</SUMMARY><DESCRIPT>Topic:     Client/Server ArchitectureSystem DesignRequirements AnalysisTutorialCost Benefit AnalysisFunctions.andO;Feature:   illustrationchart.andO;Caption:   Host-based architecture. (chart)Client-server architecture. (chart)Peer-to-peer, shared-device, and master-slave architectures.andO;(chart)andM;</DESCRIPT><TEXT>&quot;Client-server.&quot; The term flows slickly off the tongue-a worthy successor tothe last crop of misused terms in market-ese and advertising lingo, such as&quot;relational,&quot; &quot;non-procedural,&quot; and  &quot;object oriented.&quot;andM;Depending on who's been trying to sell  you what, You've probably heard thatclient-server technology on PC networks will ultimately be responsible forturning non-technical staff into developers, eliminating applicationbacklogs, reducing software maintenance costs, and increasing portability,greatly boosting the performance Of existing networks and killing offminicomputers and eventually mainframes as well.andM;However, like most technical concepts mastered by the Humpty Dumptys ofmarketing and advertising, client-server design techniques do providepractical benefits.andP;  While it might not meet all of the claims attributed toit (what does?), applied intelligently, the client-server paradigm  can beuseful, if not essential, to PC database application developers.andM;I'll try to explain (or at least add my voice to the fray), from adeveloper's perspective, what client-server is and how it can benefit PCapplication developers.andP;  I'll also try to address and defend some of theclaims made for client-server products.andM;Client-server and distributed processingandM;Client-server is really just a special form of distributed processing(sometimes, and perhaps more accurately, referred to as &quot;cooperativeprocessing&quot;).andM;Distributed processing involves spreading related tasks across two or morediscrete computer systems.andP;  (I'm restricting the discussion to &quot;discretecomputer systems&quot; to avoid the gray area of multiprocessor computers thatdistribute processing within one tightly integrated computer system).andM;When discussing distributed processing, be aware of the distinction betweenprocessing required by a particular application, such as an inventory orpayroll accounting system, and operating-system-level processing, such asmanaging file I/O or access to peripheral devices.andP;  Distributingoperating-system functions is already common practice (indeed, it's the basisof PC local area networks or LANS), but it fails to provide the benefitspromised by full use of the client-server paradigm.andM;Distributed processing comes in man forms.andP;  One simplification is to take allthe possible combinations and levels of distributed processing and arrangethem in order of least distributed to most distributed.andP;  For clarity's sakeI've defined and labeled several stops along this continuum, including onethat roughly corresponds to the client-server paradigm.andP;  (In real life, ofcourse, there are many products and systems that fall somewhere between or tothe sides of the specific classifications I'm proposing here.andP;  These productsexhibit wide variations in the distribution in different parts of theirdesigns.andP;  As they say, &quot;Such is life.')andM;A distributed processing continuumandM;Host-basedandM;A host-based system consists of one shared computer system with attached dumbterminals without significant processing power.andP;  All application processingis done on the host computer.andP;  In a sense, host-based processing isnondistributed processing-everything happens on one computer (although thehost may have multiple CPUs).andP;  An example of host-based processing is a UNIXor XENIX system with attached terminals.andM;Master-slaveandM;In master-slave processing, slave computer systems are attached to a mastercomputer and run applications only as directed by the master.andP;  The slavecomputer is capable of limited local application processing (for example, itmay be able to manage editing and some local validation of fields on thecurrent screen).andP;  An example of master-slave processing is an IBM mainframeused with intelligent terminals and cluster controllers.andM;Shared-deviceandM;In shared-device processing, PCs are attached to a shared server and requestgeneric, low-level services from the server, usually limited to sharingperipherals such as disk drives, printers, and modems.andP;  Processing performedby the server is limited to servicing peripherals and coordinating requestsfrom PCs.andP;  All application processing is done on desktop PCs.andP;  An example ofshared-device processing is a LAN with dedicated file or printer serversbased on Novell's NetWare or Microsoft's LAN Manager.andM;Client-serverandM;In client-server processing, clients are attached to servers and requestapplication-specific actions or services from the server.andP;  Applicationprocessing is divided (not necessarily evenly) between the client and servercomputer systems and controlled by the client.andP;  An example of client-serverprocessing is a database server, especially one that can actually executeapplication logic on the server, such as Microsoft's SQL Server.andM;Peer-to-peerandM;In peer-to-peer processing, all computers in the network are equals and canrequest (and provide) services (including shared peripherals and processing)from any other peer.andP;  Application processing is done wherever there'savailable computing resources (such as CPU time and memory).andP;  A singlecomputer can concurrently act as both client and server (for one or moreclients, including itself).andP;  In fact, a heavily loaded server could evendistribute a client's request to another server (in effect, becoming a clientof that server).andP;  Few networking products approach this level of distributedprocessing, and it isn't likely that existing PC operating systems (exceptfuture versions of UNIX or OS/2) will completely support this level oftransparent cooperation between computers.andM;Minimum requirements for client-server systemsandM;Having placed the client-server paradigm somewhere in the continuum ofdistributed processing, we can continue to pin it down by specifying someminimal attributes that a piece of software must have to qualify as&quot;client-server.&quot;andM;True client-server processing requires:andM;*  Communication between the client and the serverandM;* Client-initiated interactions with the serverandM;* Restriction by the server over the client's authority to request servicesor data from the serverandM;* Arbitration by the server over conflicting requests from multiple clientsandM;* Division of application processing between the client and the serverandM;* The first four of these attributes are met by most distributed multiuserLAN software currently on the market-even network operating systems, such asNetWare and LAN Manager, meet the first four tests for client-serverprocessing.andM;The fifth test becomes the key issue in deciding whether a particular productreally provides true client-server functionality.andP;  Can you take theapplication's processing logic and divide it so that part is executed by theclient computer and part by the server computer?andM;Database servers are an example of products that are often described assupporting client-server application development.andP;  Most database servers cansupport application-specific processing on the server computer.andP;  With somedatabase servers, the client application must send this application code tothe server each time it's to be executed.andP;  A better solution is provided bydatabase servers that support &quot;stored procedures&quot;-the portion of theapplication code executed by the server is compiled and stored on the server,reducing network traffic and eliminating the overhead of interpreting theapplication code each time it's executed.andM;Communication with the database server is usually limited to Structured QueryLanguage (SQL), a high-level data access and manipulation language.andP;  AlthoughSQL, as originally defined by ANSI and IBM, is generally non-procedural (youdescribe the results rather than the step-by-step procedures to produce theresults), client-server processing usually requires executing some form ofprocedural code on the server.andP;  Because of this, most database server vendorseither support or plan to support procedural extensions to SQL.andM;Some vendors argue that executing server-based procedural code isn't reallyrequired to fit their products into the definition of client-serverprocessing.andP;  Processing high-level SQL statements is equivalent (or superior)to processing procedural application code.andP;  In some cases this may betrue-certainly enforcing the referential integrity of a foreign key (a columnin one database table that must match a value in a column in another table)using a simple SQL declaration is preferable to writing procedural code tosearch for a matching value.andP;  Even database servers that don't supportserver-based procedural code provide query optimization, transactionmanagement, deadlock detection and resolution, and security facilities thatwould otherwise have to be provided by code running on the client computer(and written by the application developer).andM;The benefits of client-serverandM;As I promised, there are benefits to adopting client-server developmenttechniques.andP;  The client-server paradigm is particularly useful with PCsbecause:andM;* It allows you to better use cheap, modular yet limited computing packages(the microprocessors in desktop PCs and servers).andM;You can use it to keep processing work close to the source of the data beingprocessed.andP;  For example, in a client-server database application, the dataprocessing is done on the computer that holds the data.andP;  The user interfaceprocessing is done on the computer that directly interacts with the user.andO;This localization of processing can greatly reduce network traffic,increasing effective throughput and carrying capacity on heavily-loadednetworks.andM;There are also some less concrete benefits to using client-server designtechniques:andM;* For better or worse, most of the development of databaseapplication-enabling technology is being focused on client-server tools.andO;Following the herd lets you benefit from the resources and hard-won knowledgeof others.andM;* If you're a commercial software developer, adopting a product design thatcan be described as &quot;client-server&quot; may boost sales over the next few years(until the market's attention wanders to the next new and improvedtechnowidget).andP;  Pointing this out may seem a bit mercenary, but business isbusiness.andM;Unfortunately, there are also potential disadvantages to using theclient-server paradigm for LAN applications:andM;*  If a significant portion of the application's processing is moved to theserver, the response time from the server degrades at a much faster rate asmore users are added.andP;  This is unavoidable since the server's finiteprocessing resources will be shared among an increasing number of users.andM;* Developing applications that function in two or more pieces can be muchmore complex and costly than monolithic approaches.andP;  Some of this additionalcost is offset by the ability to reduce one large problem (the application asa whole) into several smaller problems (the distributed pieces of theapplication).andM;Common claims for client-serverandM;Some of the claims made about client-server products in the press (and byvendors) have some basis in fact.andP;  Examining each claim individually revealsthat most are somewhat reasonable and, in some instances, probably evencorrect.andP;  Please note that these claims aren't listed in any particular orderand, depending on your situation, the responses I've given may or may notapply.andM;Myth #1: Client-server will turn non-technical users into fully-fledgedsoftware developers.andM;Ultimately, with the right tools, a person with little formal training willbe able to develop quite a few minor or peripheral applications used in mostbusinesses (the proliferation of HyperCard stacks is a forerunner of thisuser-based development trend).andP;  In some sense, this migration of developmentwork from computer specialists to business specialists will be aided by theformal and well-defined separation in the client-server paradigm of whathappens on the client (the front end) from what happens on the server (theback end).andM;However, even with the best tools, professional analysts and developers willstill be needed to design and implement critical business applications.andP;  Mostbusinesses have key or critical applications whose scope covers the entirecompany's operations.andP;  Most users, on the other hand, only have expertise inone area of the company.andP;  Given this discrepancy, there will still be a needfor people who are technical specialists and business generalists (as well aspolitically &quot;neutral&quot; in interdepartmental conflicts).andM;Also, some of the underlying products used to support client-serverimplementations, such as database servers, require an in-depth understandingof technical issues.andP;  Even as these products become much more intelligent(for example, self-tuning database servers that request their own hardwareupgrades and suggest improvements in the client software), some areas, suchas translating user interviews into a database design, will still requirespecialized technical skills.andM;Myth #2: Client-server will eliminate application backlogs.andM;If the first claim were true, then this would likely follow.andP;  Given thatprofessional development talent will still be needed to develop criticalapplications for the foreseeable future and that such talent is (and will be)in short supply, the application backlog in most companies is unlikely todisappear.andM;Myth  3: Client-server will reduce software maintenance costs.andM;Whether this claim is true or not depends on what you consider a significantreduction in costs.andP;  Client-server may help reduce internal maintenance costsif an existing system is replaced with one using tools and technologies (suchas database servers) purchased from outside vendors.andP;  For example, if anexisting system based on an internally-developed file management system isreplaced with a client-server system using a database server, such as NetWareSQL or Gupta's SQLBase, the cost of maintaining the file management systemwill be replaced with the (presumably) lower cost of training developmentstaff to use the database server.andM;Myth  4: Client-server will increase software portability.andM;Since client-server involves splitting an application into at least twoparts, the issue of portability is also split into two equivalent issues-theportability of client or front-end applications and the portability of theserver or back-end software.andM;In some cases, the claim of increased portability rings true for clientapplications.andP;  If the front-end tools used to develop the client applicationare available (and fully compatible) on other client platforms, theapplication can be moved to any of these platforms-providing a connection isavailable to the server.andP;  For example, an application developed entirely inOracle's SQL*Forms can be moved without changes from a PC under DOS to a UNIXsystem or a VAX running VMS.andM;For server or back-end software, the picture isn't so bright.andP;  even where apublished standard exists for the communication protocol between client andserver (such as ANSI SQL for database servers), vendors often add proprietaryextensions to supplement deficiencies in the standard.andP;  Even movingtransparently between equivalent products from the same vendor may not bepossible.andP;  For example, IBM produces four different SQL database systems ondifferent hardware platforms, each with slight variations in their SQLdialect.andM;Myth #5: Client-server will greatly boost the performance of existingnetworks.andM;Because processing of data, like searching a database, is concentrated on thecomputer where the data resides, client-server dramatically reduces networktraffic.andP;  If the volume of network traffic forms a bottleneck in your system,switching to a client-server design may substantially improve performance.andM;If you have a large installed base of low-performance machines (such as8088-based PCs and XTs), a client-server design might improve yourperformance by allowing you to off-load some processing to a more powerful,shared server computer.andM;Myth #6: Client-server will kill off the minicomputer and eventuallymainframes as well.andM;Actually, exactly the opposite of this claim is likely to be true.andP;  As moreapplications (including those currently running on minicomputers andmainframes) are converted to the client-server paradigm, the load placed onserver computers will increase to the point that minicomputer processing andI/O performance (or their equivalent) will be required.andP;  These requirementswill produce a new level of server which, although perhaps not called aminicomputer, will provide equivalent facilities.andP;  The Compaq SystemPro andspecialized server machines from IBM and NetFRAME are the first of these newservers.andP;  There are certainly still opportunities for establishedminicomputer vendors to enter and even dominate these markets provided theyact quickly.andP;  In the short term, not supplying client-server solutionsprobably won't  kill off' these companies-though it'll certainly put somedents in their bottom line.andM;I'm afraid the claim that mainframes are seriously threatened by PC networksseems unlikely at best.andP;  Even given major advances in client-servertechnology and development tools, I see little economic benefit to mostcompanies in replacing existing mainframes with distributed processing onPCs.andP;  Recent benchmarks put the top transactions-per-second (TPS) rate of PCdatabase servers at about 10 to 15 versus a TPS rate of several hundred forequivalent software running on a mainframe.andP;  Until basic technical problemsin distributed databases and coordinating processing resources are solved,systems made up of many small processors (such as PC networks) won't be ableto outperform systems consisting of a few big processors (a top-of-the-linemainframe, for instance).andP;  It is conceivable, however, that portions ofmainframe applications will be distributed to the desktop, using PCs asclients and a mainframe as the server.andP;  At most, the growth rate of newmainframe installations will slow as more new and re-engineered applicationsare moved to client-server systems.andM;Ready for client-server?andM;Should you build your next application using the client-server paradigm? Yes,if it'll improve your application's reliability and performance.andP;  However,you should be prepared to pay for any benefits with increased developmenttime and a steeper learning curve.andP;  Even with the improved development toolsavailable (or those that should ship within the next year), developingclient-server applications will still require more effort and a detailedunderstanding of the application's design.andM;A change to a client-server system will usually also involve a change in someof the other parts of your development environment.andP;  For example, if you planto move from a PC database management system like DBASE to a database server,you face the challenges of learning about relational databases, OS/2 orLTNIX, and SQL in addition to deciding how to distribute your application'sprocessing.andM;You might be tempted to pull out a chainsaw (or text editor) and whack anexisting application into two pieces and stick one of the parts on theserver.andP;  Without planning and carefully analyzing which functions belong onthe client and which on the server, the result will almost certainly be lessthan optimal (if it works at all).andP;  Don't forget the old carpenter's saying,&quot;Measure twice, cut once.&quot;andM;James Buzzard owns a database and application design consulting firm,Hammerhead Systems.andP;  His industry experience includes four years as V.P.andP;  ofEngineering at SBT Corp. and a background in finance and accounting.andP;  You cancontact him via MCI Mail (JBUZZ) or on the Data Based Advisor ReadersExchange, (619) 270-2042.andM;&quot;There's glory for you!&quot;andM;&quot;I don't know what you mean by' glory,&quot;' Alice said.andM;Humpty Dumpty smiled contemptuously.andP;  &quot;Of course you don't-until I tell you.andO;I meant 'there's a nice knock-down argument for you!...andM;&quot;But 'glory' doesn't mean 'a nice knock-down argument,&quot;' Alice objected.andM;&quot;When I use a word,&quot; Humpty Dumpty said, in rather a scornful tone, &quot;it meansjust what I choose it to mean-neither more nor less.&quot; &quot;The question is,&quot; saidAlice, &quot;whether you can make words mean so many things.'andM;&quot;The question is,&quot; said Humpty Dumpty, &quot;which is to be master-that's all.&quot;andM;Through the Looking Glass, Lewis CarrollandM;What's Available?andM;Although the client-server paradigm may be the technology of the future, youcan buy it today-and  be using some form of it.andP;  Listed below are someexamples of available client-server products: Database servers Most databaseservers provide some level of client-server functionality.andP;  Some go beyondproviding data management and security services to clients and actuallysupport server-based execution of procedural code (which is preferable, sincethe procedures are stored on the server).andP;  Examples of database servers areMicrosoft's SQL Server, Oracle Server, and Gupta's SQLBase.andM;X Windows serversandM;X Windows is a device-independent user-interface management system originallydeveloped at MIT.andP;  It's usually implemented on UNIEK workstations.andP;  X Windowservers implement the opposite of the typical client-server model.andP;  The usersits at the server rather than the client.andP;  Clients are processes running onthe same or another workstation; they use the server for displays and userinteraction services.andP;  While X Windows is being adopted in the UNIXworkstation world, it faces stiff competition in the desktop PC marketplacefrom proprietary systems such as Microsoft Windows, Presentation Manager, andMacintosh GUIs.andP;  Mall servers Mail servers are a combination of a simpledatabase server (with a fairly limited repertoire-it uses a  database&quot; tostore and forward the mail) and, in some cases, a communications server (usedto connect to remote sites).andP;  Examples include remote mail servers, such asNetwork Courier from Consumers Software.andM;Compute servers These are generally not used in PC networks.andP;  This type ofserver performs computation-intensive tasks for a client.andP;  It differs fromother forms of servers in that the nature of the processing is almostentirely determined by the client (more like a peer-to-peer relationship),and there's usually no coordination between requests from multiple clients(the server process only does work for a single client).andP;  Compute servers aretypically used to compile source code on a network (for example, on a networkcomposed of Sun Microsystems workstations and servers).andM;The Distributed Processing ContinuumandM;Type of         Controlled   Application      Level ofandM;processing      by           processing       distributionandM;Host-Based      Shared       Shared           NoneandM;Master-Slave    Shared       Shared/Desktop   LOWandM;Shared-device   Desktop      Desktop          LOWandM;Chent-Server    Desktop      Shared/Desktop   MediumandM;Peer-to-Peer    Desktop      Desktop          HighandM;Note: The following definitions apply to the table above:andM;Desktop--Physically located with the user, for example, the desktop PCattached to a network or a terminal attached to a centralized host machine.andO;Typically, desktop systems receive services from a shared system (see below).andO;Shared-Located on a computer that usually provides services to a number ofconcurrent users.andP;  Peer-to-peer systems don't include distinct shared anddeaktop systems since all the systems are shared.-James Buzzard</TEXT></DOC>