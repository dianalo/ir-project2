<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-450-762  </DOCNO><DOCID>07 450 762.andM;</DOCID><JOURNAL>Data Based Advisor  July 1989 v7 n7 p136(3)* Full Text COPYRIGHT Data Based Solutions 1989.andM;</JOURNAL><TITLE>Clipper memory management, part 1. (part one of two) (technical)</TITLE><AUTHOR>Brentnall, Savannah.andM;</AUTHOR><SUMMARY>The management of memory for Clipper applications is the key topower.andP;  The article discusses memory management.andP;  The variousparameters are discussed, including symbols, memory variables,arrays, macros and memory.andP;  Each memory variable is given a22-byte space in the variable table.andP;  Literal macros replaceconstants (character strings, file names) and expression macrosreplace expressions.andM;</SUMMARY><DESCRIPT>Product:   Clipper (Program development software) (computer programs).andO;Topic:     Memory ManagementProgrammingProgramming Instruction.andO;Feature:   illustrationchart.andO;Caption:   Clipper default memory allocations. (chart)andM;</DESCRIPT><TEXT>Clipper Memory Management, Part 1andM;Clipper programmers are developing increasingly sophisticated applications,and the number of people writing software in Clipper is constantly growing.andO;Unfortunately, developers are finding their complex applications outgrowingtheir operating systems or hardware.andM;In an ideal world, your applications would work immediately and they'd workforever.andP;  In the real world, with real world limitations, you're forced tooptimize your applications as much as possible.andM;Clipper allows you to tailor the memory management of applications.andP;  Thistwo-part article will explain how to manage memory in clipper (Summer 1987version).andP;  Use it as a guide to the &quot;tailoring&quot; process.andM;Default allocationandM;Clipper divides working memory into several areas (see Fig.andP;  1): the Vregion, used for the memory variable table; the R region, reserved for indexbuffers and external programs executed using the RUN command; and the freememory pool, the general purpose memory &quot;reservoir&quot; used by executing Clipperoperations.andP;  If SET CLIPPER isn't used, your memory is allocated in thissequence:andM;1.andP;  The executable load module is loaded into memory above DOS.andM;2.andP;  24K is reserved for the free memory pool.andM;3.andP;  20 percent of the remaining memory is allocated for the memory variabletable (44K maximum).andM;4.andP;  33 percent of the remaining memory is allocated for RUN commands andindex buffers (16K minimum).andM;5.andP;  The remaining memory is added to the 24K free memroy pool for programprocessing.andP;  Usage of the free pool typically includes storing charactervariables and arrays.andM;To run an application, you need a minimum of 24K of free pool memory, 16K forindex buffers, and whatever memory you need to allocate for memory variables.andO;The default allocations are shown in Fig.andP;  1.andM;If you have expanded memory, Clipper automatically reserves 16K (to a maximumof 512K) for index buffers.andP;  The memory allocated in step 4 will then be usedonly for RUN commands.andM;SymbolsandM;A symbol is a name that Clipper finds when it compiles a program.andP;  If canrefer to a memory variable, procedure function, field name, or an alias.andO;When you compile your application, Clipper stores these symbols in a &quot;symboltable.&quot;andP;  Every name in the program has one 16-byte entry in the symbol tablethat is kept in the space used by the EXE file.andM;The first thing Clipper does when you run an application is search throughthe symbol table.andP;  For each unique name it finds, it builds an 18-byte&quot;symbol node&quot; in the free pool.andP;  One symbol node is created for each name.andO;If two items have the same name, they'll share a symbol.andM;Each symbol node contains pointers to and from the symbol and memory variabletables (Fig.andP;  2).andP;  Its 18-byte space in the free pool is never released, butyou can use it for something else with the same name.andM;Memory variablesandM;As each memory variable is created, it's given a 22-byte space in the memoryvariable table.andP;  Each PRIVATE, PUBLIC, and PARAMETERS statement will alsodesignate an entry in this table.andP;  The space is allocated only once, notevery time the variable is accessed.andM;The first six bytes of the reserved space are used to store the variable'stype, length, and number of decimals.andP;  The next eight store the systeminformation and a pointer to the symbol node.andP;  The use of the remaining eightbytes depends on the variable's type.andP;  If it's a numeric, date or logicalvariable, the remaining eight bytes are enough to store the actual value.andP;  Ifit's a character variable, it could be up to 64K, so the eight-byte spaceholds two things: a pointer to the position in free pool memory where thedata resides and the size of that data (as in Fig.andP;  2).andM;When a memory variable is released, the space used by its data is returned tothe free pool.andP;  The 22-byte space in the memory variable table isn't releaseduntil the program RETURNs from the level where the variable was created.andP;  The18-byte symbol node isn't released, but it is used again by any other itemwith the same name.andM;In the example below, a variable called &quot;x&quot; is created: Procedure MainProg DOProc1 RETURN Procedure Procl x = 5 DO Proc2 RETURN Procedure Proc2 RELEASE xRETURNandM;The entry for x in the memory variable table isn't released until theapplication exits Proc1 and RETURNs to MainProg.andP;  The space isn't availableto the free pool--it's still part of the V area and can only be used by othermemory variables.andM;ArraysandM;Arrays are handled like character memory variables.andP;  The 22-byte entry in thememory variable table contains a pointer to a block of free pool space.andP;  Inthe case of arrays, this space contains a table like the memory variabletable.andP;  For each element in the array, there's an entry in the table thattakes up 14 bytes (see Fig.andP;  3).andM;The formula used to calculate the amount of memory needed for an array is: 22+ (14 x number of elements) + andless;size of dataandgt;andM;The next example shows the differences between 1,000 memory variables and a1,000-element array: 1 memory variable = 22 + andless;size of dataandgt; 1,000 memoryvariables = 22,000 + andless;size of data for each variableandgt; 1,000 element array =22 + (14 x 1,000andgt; + andless;size of dataandgt; = 14,022 + andless;size of data for each elementandgt;andM;When an array element is released, the space used by its data is returned tothe free pool.andP;  When the entire array is released, the data and array tablespace are returned to the free pool.andP;  The 22-byte entry in the memoryvariable table is released for other variables as soon as the program RETURNsfrom the level where the array was created.andP;  As with memory variables, the18-byte symbol node isn't released but is used by any other item with thesame name.andM;MacrosandM;Macros fail into two categories: literal macros and expression macros.andO;Literal macros are used to replace literal constants such as characterstrings or file names.andP;  Expression macros replace expressions.andM;For example: USE andamp;x where x is a file name (liteal).andP;  x = &quot;5/3&quot; ? andamp;x In thiscase, x is an expression.andM;When Clipper first encounters a macro, it expands it.andP;  Clipper looks up thevalue of the variable the macro refers to and expands any nested macros.andP;  Thenext step depends on the type of macro.andM;If the macro is a literal macro, the expansion gives the final value.andP;  In theexample above, it's the name of the USEd file.andP;  This is the faster of the twotypes of macros but still slower than a constant.andM;When an expression macro has been expanded, Clipper invokes the expressioncompiler, compiles the expression, and executes it.andP;  That's why using thistype of macro can slow down your applications.andM;Literal macros can usually be replaced by extended expressions, as we'll seelater.andM;Using macros to create memory variablesandM;When a memory variable is created using a macro, Clipper won't know its nameat compile time, so there's no entry for it in the symbol table.andP;  The firstthing a Clipper application does when it's loaded is search the symbol table,creating a symbol node for each unique name.andP;  If no symbol table entry existsfor a name, no symbol node is created.andP;  In the case of macro-createdvariables, Clipper works around this by allocating a 16-byte block of freepool space and treating it as though it were the symbol table entry (Fig 4).andM;In the example below, y is created using a macro: x = &quot;y&quot; andamp;x = 5andM;If the name y exists, no overhead is incurred, because the symbol node andthe 16-byte space in the symbol table exist.andP;  If y is a new name, the symbolnode and symbol table entries must be created.andP;  These are never released, andthe space is lost until the user exits the application.andM;Accessing a nameandM;Whenever your application accesses a name (by storing a value to a memoryvariable, for example), Clipper searches the symbol table for its entry,which points to the correct symbol node.andP;  In most cases, Clipper can tell aname's type by its context in the source code.andP;  For instance, when followedby parentheses, it's a function.andP;  The two exceptions to this rule are memoryvariables and fields.andM;When you use commands such as @...SAYs, Clipper doesn't know whether you'retrying to access a memory variable or field (fields usually take preference).andO;Clipper searches for a field with that name.andP;  If it can't find a match, itsearches for a memory variable.andP;  The overhead for this search is very slightand can be eliminated altogether by prefixing the memory variable name with&quot;M-andgt;&quot;.andP;  This tells Clipper that the name is a memory variable, so it doesn'tsearch for a field.andM;RUN CommandsandM;When you RUN an external program, Clipper releases all the memory allocatedto the &quot;R&quot; area and a second version of COMMAND.COM is loaded (approximately22K).andP;  Although this amount of memory is needed initially, all but 3K isreleased once the new version of COMMAND.COM is in place.andP;  When you exit theexternal routine, the 3K is also released.andP;  Clipper tries to reallocate acontiguous block of memory equal in size to the original &quot;R&quot; space, and yourapplication will continue.andM;This is one reason why it's not a good idea to RUN memory resident programs.andO;We'll talk about the next month.andM;MEMORY(0)andM;MEMORY(0) calculates the amount of available memory by trying to allocate asmuch as possible.andP;  It first tries to allocate 64K blocks.andP;  When thateventually fails, it tries 48K blocks, then 32K blocks and so on until itreaches 4K blocks.andP;  When allocating 4K blocks fails, all of the memoryallocated is returned.andM;This has two disadvantages:andM;* MEMORY(0) doesn't tell the programmer how large the largest contiguousblock of memory is.andM;* Blocks of memory smaller than 4K aren't included in the calcualtion.andP;  Thismeans that if 100 3K memory blocks exist, MEMORY(0) will still return zero.andM;MEMORY(0) should only be used to estimate the amount of memory remaining onthe system.andP;  One thing's certain: If MEMORY(0) returns zero, there is verylittle contiguous memory left--certainly not enough to perform a largeoperation like MEMOEDIT().andM;ConclusionandM;Now that I've covered the basics of Clipper memory management, next monthI'll continue with a discussion of troubleshooting techniques--steps you cantake to reduce your memory overhead.andM;This article was written with contributions from the following people: ReneeGentry, Steve Hillbourne, Fred Ho, Rich McConnell, David Morgan, GrantNesheim, Deborah Ridolfo, Brian Russell, Christopher White, and Timothy Wong.andM;Savannah Brentnall is a member of Nantucket's Technical Information Group.andO;Her experience includes positions as Nantucket Technical Support Technician,Analyst/Programmer for two London software houses, and owned of a consultingcompany in England.andO;</TEXT></DOC>