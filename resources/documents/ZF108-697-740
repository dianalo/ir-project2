<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-697-740  </DOCNO><DOCID>08 697 740.andM;</DOCID><JOURNAL>Dr. Dobb's Journal  August 1990 v15 n8 p94(7)* Full Text COPYRIGHT Mandamp;T Publishing 1990.andM;</JOURNAL><TITLE>Collections in Turbo C++: a full C++ 2.0 implementation makeswriting collection classes a breeze. (Software Review) (BorlandInternational Turbo C++ compiler) (evaluation)</TITLE><AUTHOR>Eckel, Bruce.andM;</AUTHOR><SUMMARY>Borland International's (Scotts Valley, CA) Turbo C++ is 'thefinest implementation of a C++ compiler,' providing fullcompliance with the ATandamp;T's C++ 2.0 Draft Reference Manual as wellas the full ANSI C compatibility of Borland's Turbo C 2.0.andP;  TheC++ 2.0 compliance is illustrated by Turbo C++'s support formultiple inheritance, type-safe linkage, pointers to members(useful to creating 'collection' classes for counting keywords andidentifiers in C++ programs), and abstract classes.andP;  Other TurboC++ features include a library of useful classes, source code foreverything, the ability to generate assembly language output, theTurbo C library, VROOM overlay manager for using EMS/disk overlaysto generate large programs, an Integrated Development Environment,Turbo Editor Macro Language and Compiler, and debugger.andP;  Turbo C++is $199.95, while Turbo C++ Professional is $299.95.andM;</SUMMARY><DESCRIPT>Company:   Borland International Inc. (products).andO;Product:   Turbo C++ (Compiler)Turbo C++ Professional (Compiler).andO;Topic:     CompilersC Programming LanguageSpecificationsEvaluationStandardizationObject-Oriented Languages.andO;Feature:   illustrationprogram.andO;Caption:   Collection example, with multiple inheritance and pointers tomembers. (program)Stepping through a typical collection. (program)Macro that puts void at the beginning of a line. (program)andM;</DESCRIPT><TEXT>Collections in Turbo C++andM;According to the unwritten rules of implementing C++, compiler vendors havethe option of saying &quot;sorry, not implemented&quot; when a language feature iseither too difficult to implement or when the implementor feels that theprogrammer really doesn't need a particular feature.andP;  Most implementors haveinvoked this rule at one time or another, even ATandamp;T with its cfronttranslator.andP;  Furthermore, vendors sometimes implement features for which acompiler may accept the syntax but not enforce it; const and volatile memberfunctions are good examples of this.andP;  In such cases, you may think you'regetting the benefit of a feature when in fact you aren't.andM;Borland's Turbo C++ is the finest implementation of a C++ compiler I haveseen.andP;  This article examines how successful Borland was in implementing C++,using as example C++ 2.0 features such as multiple inheritance and pointersto members to create a &quot;collection&quot; class that counts keywords andidentifiers in a C++ program.andM;Surveying the Turbo C++ LandscapeandM;Turbo C++ provides full ANSI C compatibility of Turbo C 2.0 and is fullycompliant with the C++ 2.0 Draft Reference Manual (see the accompanying textbox for a description of C++ 2.0, 2.1, and the ANSI C++ committee).andP;  Ofparticular interest is Turbo C++'s support for multiple inheritance,type-safe linkage, pointers to members, and built-in support for abstractclasses.andP;  Borland has also implemented the ATandamp;T C++ 2.0 iostream package, aswell as the older C++ 1.0 streams (for backward compatibility with old code)and the complex class.andM;Turbo C++ comes with a library of classes intended to help you buildprograms, including useful classes such as Dictionary and HashTable.andP;  Classlibraries address the common complaint among C++ programmers (to wit: &quot;Fine,C++ makes code reuse easier.andP;  Where's the code to reuse?&quot;).andP;  However, Borlandmade the assumption that what was good design for Smalltalk would be gooddesign for C++.andP;  Thus we have the ponderous Smalltalk-like hierarchy, whereeverything is derived from a base class Object (no use is made of multipleinheritance), the sometimes irritating Smalltalk names such as theQueue andhashValueType (they've also made the assumption that you should be able toask any object what type it is, rather than letting the object worry aboutit's own behavior), and some rather strange-looking syntax (definitely notfor novices).andP;  I would have liked it better had Borland followed ATandamp;T's leadand included a task library instead.andM;On the positive side, there's source code for everything, the manual is ondisk, and, of course, you aren't forced to use the libraries.andP;  Simpleexamples show how to use some of the classes (a sorted directory listingprogram, for instance).andM;Other FeaturesandM;You can easily generate assembly output with Turbo C++.andP;  This can be veryhelpful, especially if you want to hand-optimize code or create your ownassembly language routine to link into a C++ program.andP;  The name-manglingscheme used is very easy to read (an aside: When you get linker errormessages, the names are automatically unmangled for you.andP;  Nice!).andM;The Turbo C library is available in Turbo C++.andP;  You can link with assemblylanguage and other libraries, including all those created for the Borlandenvironment (that is, Turbo Pascal and Turbo Assembler) or with Microsoft C.andO;Paradox Engine code can be linked in with Turbo C++, providing a frameworkfor some powerful C++ database applications.andP;  And I understand you can evenlink to Turbo Prolog object modules (even though Turbo Prolog has reverted tothe Prolog Development Center, its original creator).andP;  As usual, Borlandencourages third-party support.andM;The asm( ) directive in C++ is supported in Turbo C++; this allows inlineassembly code.andP;  You have full control of the expansion of inline C++functions; you can turn inlining off if you want (very convenient if you gocrazy with inlines and later come to your senses).andP;  The compiler mergesliteral strings to generate smaller programs.andP;  You have full control of theway virtual tables are generated.andP;  Borland has been careful not to doanything to prohibit embedding Turbo C++ code.andM;Turbo C++ uses the VROOMM overlay manager for building big programs usingEMS/disk overlays.andP;  Sadly, it doesn't support the equivalent ofZortech's__handle pointers (see &quot;Getting a Handle on Virtual Memory,&quot; byWalter Bright, DDJ, May 1990) to do the same thing for data.andP;  I think the__handle pointer is one of Walter Bright's more terrific ideas.andP;  I'm hopingBorland will add this in the future.andM;The ability to set the library, include information, and command-line flagsin the TURBOC.CFG file is excellent!andP;  This immediately eliminates all thepath collision and environment-space problems you have when running more thanone C++ compiler on your machine (I do this when I want to test correctness).andO;Turbo C++ will also swap the symbol table to extended memory or EMS forcompilations.andM;Although (as with all C++ implementations) there are limitations on what theC++ compiler will actually inline, there are far fewer restrictions on whatthe compiler will accept in an inline statement.andP;  For instance, Turbo C++would accept static variables and &quot;embedded&quot; return statements (those thataren't at the end of the function) in inline functions, while Zortech andcfront wouldn't.andM;Programmer's PlatformandM;A Borland language product wouldn't be complete without the IntegratedDevelopment Environment (IDE).andP;  The IDE includes everything you need to edit,compile, link, and debug programs.andP;  This time, however, the IDE has beencompletely reworked with multiple overlapping windows you can reshape andmove around the screen.andP;  Other features include a hypertext-style helpsystem, the ability to copy code fragments from the help system to theeditor, and more.andP;  For those of you who can't seem to get by without rodents,there's full mouse support.andP;  And, a nice interactive tour teaches you how touse the IDE features.andM;The &quot;Turbo Editor Macro Language&quot; (TEML), a very readable scripting languagethat looks like a bastardization of Pascal and C, lets you use macro scriptsto write customizations.andP;  For instance, you can rebind all your keys when theeditor starts up, grab class names and member function prototypes, pop toanother file and append the class name to a :: and the function prototype tocreate a definition stub, and so on.andP;  The macros are compiled with the &quot;TurboEditor Macro Compiler&quot; (TEMC), which avoids many of the speed problemsassociated with interpreted macro languages.andP;  You can create named macros(with arguments) and you can bind those macros to keys; you can also just tiea set of statements to a key without a name.andP;  There are over 140 built-incommands to work with.andP;  Example 1 shows a simple example of a macro whichputs void at the beginning of a line, then returns to the point where youinvoked it.andP;  Unfortunately, it is difficult to determine from thedocumentation the limitations of TEML.andM;The IDE also has a built-in, small version of the Turbo Debugger, whichdisplays C++ source code as you've typed it in (no messes from name mangling)and allows you to perform various debugging feats.andM;Turbo ProfessionalandM;The full-blown debugger (provided with the Turbo Professional, or soldseparately with the Turbo Debugger and Tools package) is a step forward indebugger technology.andP;  It's better than anything I've seen (although I admit Inever had the patience to figure out CodeView).andP;  I didn't need to use themanual much at all, since the menus and help system are so good.andP;  Thedebugger can use 80386 protected mode by loading a special device driver;this allows viewing assembly language after a hard crash.andP;  I particularlylike the traceback feature; you can use the animation feature toautomatically step until the program crashes, then trace back and see itslast thoughts (although it would be nice if you could speed up animation inthis process by eliminating screen updates).andP;  The display of class hierarchyis fine, but it isn't much use by itself; perhaps the debugger is the wrongplace for it -- you want to see hierarchies while you're writing code, notwhile you're debugging it.andM;The Turbo Profiler (also part of the professional package) should alleviateany concerns you have about potential performance differences with C.andP;  Itseems to me the benefit of optimizers is overstated.andP;  An optimizer doesn'thave enough information to make a large difference in execution speed.andP;  Ifyou can find the place where your program is spending all its time, you cango in and optimize that section by hand, rather than letting the compilersprinkle potentially useless speed improvements throughout the program.andP;  Youcan think of the profiler as attacking the problem from the opposite end, andthe improvements in speed are potentially far more dramatic than what youwill see with an optimizer.andP;  Don't underestimate the value of this tool.andM;Taking Up A CollectionandM;The code presented in this section demonstrates several concepts programmersnew to C++ should understand.andP;  These concepts include:andM;* Collections, which support a dynamic style of programming;andM;* Multiple inheritance, so that classes can be derived from more than onebase;andM;* Pointers to members, which let you delay the selection of a member(function or data) until run time.andM;The classes created here are simple but powerful.andP;  The example thatillustrates them is used to count the keywords and identifiers in a C++source file.andM;A collection is an object which holds an arbitrary number of other objects.andO;Basically, it's just a bag you can throw things into and fish them out later.andO;The reason collections are so important is that they support a dynamic styleof programming.andP;  You can't always determine how many and what type of objectsyou need while you're writing a program (although you may be in the habit oftrying to figure it out).andP;  In the general case, these things can only beestablished at run time.andP;  Thus, objects must be created and destroyedon-the-fly, using dynamic object creation (via the operators new and delete).andO;While you're working with these objects, you need some place to stash them --that's where the collection comes in.andM;You're probably familiar with linked lists, stacks, queues, and trees; theseare all prototypical collections in non-object-oriented languages.andP;  Thecollection in Listing One, page 132, looks vaguely like a singly-linked list.andO;I like it precisely because it is so simple, but you may have to stare at ita while to figure out exactly how it works.andM;The first definition is a struct called item, which only contains a virtualdestructor.andP;  Any object you want to put into a collection should be derivedfrom item so that collection can &quot;own&quot; the items it holds: When it wants todestroy the item, the proper destructor is called (note that ownership isn'talways so clear cut -- in some situations an object is contained in more thanone list).andM;A collection is a chain of holder objects.andP;  Each holder is a link in thechain; it has a pointer to an item and a pointer to the next holder.andO;Initializing a holder is simply setting its two pointers.andP;  Note that althoughstruct holder is defined inside class collection, holder is a global name inC++ 2.0 (but hidden in C++ 2.1).andM;A collection object just contains two holder pointers -- one called head,which points to the top of the list, and one called cursor, which movesthrough the list and points to the holder we're currently interested in.andO;Initializing a collection means setting its two pointers to NULL (to indicatethe list is empty).andP;  Cleaning up the list is more complex; we must go to thehead and move through the list until it's empty, deleting each item andholder in the list.andP;  Here you'll need to ponder the code and the comments,imagining what's going on.andP;  Sometimes it helps to draw pictures.andM;Adding a new item to a collection is the slickest part of the whole class.andO;Make a new holder using the current head pointer and the new item pointer asarguments.andP;  The value returned by new (the address of the newly createdholder) becomes the new value for head.andP;  In one statement list expands, justlike yeast budding a new cell (this is the add( ) function).andP;  Because add( )is inline, adding an element is amazingly fast.andM;Stepping Through a CollectionandM;You step through a collection using the reset( ) and next( ) commands, eachof which returns a pointer to the current item, or NULL if we're at the endof the list.andP;  For a collection c, use the commands as shown in Example 2.andP;  Ifthe list is empty, reset( ) returns NULL and the while loop is never entered.andO;Note that in both reset( ) and next( ), we must take care not to return an[item.sup.*] if cursor is NULL; this is taken care of by the ternary if-elsestatement (? and :).andP;  In next( ), we must not move forward if cursor is NULL.andM;Multiple InheritanceandM;In a &quot;pure&quot; object-oriented language such as Smalltalk, everything is anobject.andP;  All objects have as their base the same class (called &quot;object&quot; or&quot;root&quot; or something like that).andP;  Collections in Smalltalk are usually part ofthe existing system; you don't have to make them yourself.andP;  They are designedto hold any type of object, thus they usually hold root objects, or somethingclose to root in the inheritance tree.andM;The need for multiple inheritance is not obvious in a system like this;multiple inheritance allows you to combine the characteristics of two or moreclasses, but in Smalltalk all objects already have a lot of things in common.andO;Now, consider C++ where classes are often made from scratch instead of beinginherited from some master root class.andP;  What happens if you have twopredefined classes (which you can't or don't want to change) that must becombined into one?andP;  As an example, consider a relatively simple class thatholds a word and compares it to text strings, incrementing a counter if thereis a match.andP;  Since we're defining the word class right here we could haveinherited it from item, but imagine it has been created by someone else andis much more complicated.andM;Now suppose you want to make a collection of word objects.andP;  Anything thatgoes in a collection must be derived from item so the collection can &quot;own&quot; itand properly destroy it.andP;  But word has already been created, so it can't bederived from item.andP;  What we need is a way to derive a new type from word anditem at the same time.andP;  That's where multiple inheritance is essential inC++.andP;  You can see it used in the creation of class worditem, which is a wordthat can also be stored in a collection.andP;  The first main( ) in Listing One isa simple demonstration of a collection of worditems.andM;Counting WordsandM;If we want to count instances of words instead of just adding each word tothe list, we need to modify the collection class by inheriting it into a newclass called wordcounter.andP;  This class is first customized so that add( ) onlyaccepts worditem pointers, and reset( ) and next( ) only return worditempointers.andP;  Although this may look as if you're adding code, there's actuallyno overhead -- the compiler does all the work by enforcing type checking.andP;  Wethen add a new function, add_or_count( ), to class wordcounter.andP;  This willtest a string against each word in the list; if it finds a match, that wordgets incremented; if not, it adds the word to the list.andM;Pointers to MembersandM;Finally, we add a function called apply, which uses pointers to members.andO;These are particularly useful for collections -- in apply( ), the functionargument is applied to each member of the list.andP;  Note that a pointer to amember function looks a lot like a pointer to a function; it just has theclass name and the scope resolution operator added.andP;  The apply( ) function isdemonstrated in the second main( ).andM;You can imagine a more powerful construct: Consider an array of pointers tomember functions.andP;  You could index into this array to select the desiredmember.andP;  Pointers to members can also be used to change the behavior of a&quot;call back.&quot;andP;  For example, with a mouse event that might cause the system tochange state, the next mouse event should cause something different tohappen.andM;Counting Identifiers and KeywordsandM;Now that we have the desired class and the desired collection, let's use themto count the identifiers and keywords in a C++ source code file (I tested iton Listing One).andP;  The trick is simply to remove all the quoted strings,operators, comments, and constants and put the remaining words into ourwordcounter collection by using add_or_count( ).andP;  This is accomplished byusing the ANSI C library functions strchr( ), which finds the first instanceof a character in a string, strstr( ), which finds the first instance of astring within a string, strtok( ), which breaks a string up into tokensaccording to the delimiters of your choice, and strcspn( ), which counts thecharacters in the initial length of a string that doesn't consist ofcharacters from your chosen string; this is used to determine if a string isa numerical constant.andP;  Look these up in your ANSI C library reference forfurther details.andM;I'm using standard I/O here instead of bothering to open and close files.andO;You have to redirect input and output on the command line, but it makes theexample simpler.andM;In running TEST3, notice that the results of the analysis are printed tostandard output as the destructors are called for the worditem objects (theprint statement is in the word destructor).andM;You can easily create a second type of list to hold keywords.andP;  Initializethis list with the C++ keywords, then test each new word against this listbefore conditionally adding it to the symbol_table list.andP;  This way you canseparate keywords and identifiers.andM;Note that parts of Listing One will compile with Zortech C++ 2.06 (if youremove the pointers to members, the whole thing will compile).andP;  However, theTEST1 code shows a place where Zortech C++ 2.06 has a bug (it works properlywith cfront 2.0 and Turbo C++).andM;I believe Borland will capture the C++ market in much the same way they didthe Pascal market.andP;  They are just out of the blocks with Turbo C++ andalready far ahead of everyone else.andP;  Other C++ vendors will have to come upwith something pretty spectacular for me to pry my clenched fingers fromTurbo C++.andM;Bruce is the author of Using C++ (Osborne/McGraw-Hill, 1989), a voting memberof the ANSI C++ committee (X3J16), and the owner of Revolution2, a firmspecializing in C++ training and consulting.andP;  He is the C++ editor/columnistfor The C Gazette and was a contributing writer for MicroCornucopia magazinefor four years.andP;  Portions of this article are based on the as-yet-unpublishedThe Tao of Objects, by Bruce Eckel and Gary Entsminger.andO;</TEXT></DOC>