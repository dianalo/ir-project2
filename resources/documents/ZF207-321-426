<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-321-426  </DOCNO><DOCID>07 321 426.andM;</DOCID><JOURNAL>Computer Language  May 1989 v6 n5 p87(7)* Full Text COPYRIGHT Miller-Freeman 1989.andM;</JOURNAL><TITLE>Interfaces and fourth generation languages.andO;</TITLE><AUTHOR>Rapaport, Matthew.andM;</AUTHOR><SUMMARY>The right interface can make different types of software easy touse.andP;  Each application type chooses from different ease-of-userules.andP;  Interface design is not just screen layouts, user prompts,or display output.andP;  It is about general modularization philosophy.andO;Modular techniques are used for separating internal functions ofan application system, as well as partitioning large-scale systemcharacteristics.andP;  Illustrated here is a simple example of how I-Ocan be divided from a program.andP;  Borland International's Paradoxand Revelation Technologies' Advanced Revelation are two productsthat represent two very different approaches to developerinterface management.andP;  Paradox has the most natural userinterface.andP;  Advanced Revelation facilitates the creation of entireapplications by setting up all necessary I-O screens.andM;</SUMMARY><DESCRIPT>Product:   Paradox 2.01 (Data base management system)Advanced Revelation 1.1 (Data base management system) (usage).andO;Topic:     InterfaceTutorialFourth GenerationProgramming LanguagesModularity.andO;Feature:   illustrationchart.andO;Caption:   (Various logic and operation flowcharts). (chart)andM;</DESCRIPT><TEXT>Interfaces and fourth generation languages User-interface design typicallyconjures up images of screen layouts, decisions about full-screen vs.andO;horizontal menus, use of function keys, and choice of command languages.andO;Many principles are derived from the ergonomic research and common sense thatgovern the particulars of an application's user dialogue.andP;  Some themes occurin application interfaces.andP;  Different kinds of software are best expressedthrough an interface set that has the ability to make the application easy touse.andP;  Spreadsheet interfaces may differ from one another but have somethingin common when compared to word processors, debuggers, or accountingpackages.andP;  Each application type selects from different ease-of-use rules.andM;Interface design is not limited to screen layouts or prompting users to inputor display output.andP;  On a deeper level, it involves general modularizationphilosophy.andP;  Modular techniques not only apply to separating internalfunctions of an application system but to partitioning large-scale systemcharacteristics; in this case, segregating user I/O facilities from the restof the processing logic.andM;Figure 1A is a simple illustration of how I/O can be diveded from a program.andO;It is simple because it is sometimes necessary to include some processingpower in the I/O facilities.andP;  This power usually involves various datavalidation capabilities illustrated in Figure 1B.andM;Multiuser and multitasking systems with reentrant, shared programs suffersevere performance penalties if the common code performs all data validation.andO;The issue of how much data manipulation to embed in the user dialogue mustalso be addressed by an interface designer.andM;The user-interface level of decision is always invisible to the user exceptin performance considerations.andP;  Sometimes this level of design is notcontrolled by the applications developer.andP;  In these cases, the designereither has no choice and is constrained to the choice given by the tools inuse or has multiple choices for some limited range of validation types.andP;  Thedegree of choice is inversely proportional to the language level, with a lotof intralevel variation as well.andM;Modern DBMS philosophy is based on data validation by the DBMS, which liesbelow shared application code containing processing logic, as shown in Figure2.andP;  The application language used on top of a DBMS system supports datavalidation directly in the interface, even if only through the language'snormal screen-manipulation facilities.andP;  Programming standards may prohibitputting such logic in the interface if the underlying DBMS can handle thevalidation.andM;Often in integrated environments, the development platform provides somevalidity-checking in the dat directionary and some in the conversational partof the software.andP;  Occasionally, functional overlap can be found in thedata-checking functions of the DBMS and user I/O facilities.andP;  In this case,where to put validation logic depends on shop standards, processingarchitecture, maintenance considerations, and performance requirements.andP;  Someprocessing logic must be present in the interface or main code to test DBMSerror return codes and then interpret them intelligently.andM;This theory is perfectly good for DBMSs.andP;  It simplifies both I/O logic andthe intermediary computation system.andP;  All modern DBMS engines are beginningto support such validations.andP;  Masks, range checks, uniqueness constraints,and referential tests are starting to be controlled by DBMS dictionarysystems or other software tools designed to manage file I/O.andM;Object-oriented methods push this technique to vlatile storage byencapsulating all data inside their procedures.andP;  This encapsulation is shownin Figure 3 and is usually logical but treated as physical by the programmerbecause the data-procedure objects must intelligently interpret requests andreturn results in a form interpretable by the calling software.andP;  Thisinterface level is never visible to the user.andP;  It must be used by theapplication developer in object-oriented environments.andP;  However, its designis relegated to the builder of the object language employed.andM;In many systems, interpreting error messages returned from the DBMS requiresas many lines of code as to validate the data initially.andP;  Cincom Inc.'s SUPRAreturns three error code levels.andP;  The first level informs the program thatsomething went wrong with a file or DBMS I/O operation.andP;  The second informsthe user of the error's severity, such as rule-checking, integrityconstraints, or physical I/O failure.andP;  The third level details the individualattributes involved if any are relevant.andM;Interrogating all error levels and displaying the messages intelligently tothe user or passing them up the line to higher-level dialogue managers takessubstantial code.andP;  However, this logic is invoked only if an error occurs,saving the processing code or user-dialogue logic from repeatedly testingdata before handing it to the DBMS.andP;  This procedure is generally aperformance advantage in systems where file I/O operations are at leastpartly separated from the performance of the data-processing logic and userinterface.andM;Although the broad notion of a fourth-generation language does notspecifically include dealing with user interfaces, the perceived productivityenhancements associated with contemporary fourth generation systems often hasa lot to do with the evolution of modern user interfaces.andP;  The developer'sview of application-generation systems, such as RBASE, DataFlex, andInformix, falls in this category.andP;  In James Martin and Carmon McClure'sSoftware Maintenance, the definition of a fourth generation language includesconditions of association with a language-integrated DBMS.andM;Two other criteria, user-friendliness and accessibility to nonprofessionalprogrammers are often associated with user-interface facilities incontemporary application developement platforms.andP;  While the notion of afourth generation language has some validity independently of a userinterface, it is usually more realistic to speak in terms of a fourthgeneration development environment as something encompassing languages, adatabase, and facilities for easy implementation of user input and outputrequirements.andM;About a year ago, one of the CompuServe CONSULT Forum members soughtinformation about DBMS development environments that facilitated windows,pulldown menus, and other such facilities.andP;  This query prompted me to askwhether user demands for windowed environments were causing consultants toreject products with superior DBMS kernels in favor of slick-lookinginterfaces.andP;  A heated debate ensued over the importance of the user interfacein application development.andP;  One view held that since a consultant'slivelihood depends on client satisfaction, a client's insistence on windowsis sufficient to reject any product that doesn't support them.andP;  Another viewheld that the question was really moot since the vast majority of developmentplatforms do support windowing.andP;  As a result, few products should be rejectedfor lack of windows alone.andM;The second view illustrates the predominant attention most vendors give aDBMS's interface facility.andP;  Light-bar horizontal menus and pull-down orpop-up windows are frequently associated with contemporary user interfaces.andO;The former was first popularized by Lotus 1-2-3, while the latter becamepopular with the arrival of the Apple Corp.'s Macintosh.andP;  In the past twoyears, most vendors have released versions supporting windows or improved onexisting window support.andP;  Windowing is supported directly in the DBMSenvironment and is used not only for user input and output, but as a part ofdevelopment tools provided by DBMS vendors.andP;  Dictionary and directorydisplays are windowed, as well as screen and report builders, code editors,and debuggers.andM;Outside the DBMS arena, products exist that only support data entry throughwindows and hand off the data to various processing engines, displayingretrieved data through these same devices.andP;  Window-support libraries haveappeared for languages like C, Pascal, Modula-2, BASIC, and COBOL, ranging inprice from a few hundred to a few thousand dollars.andP;  The data-entry systemsinterface is illustrated in Figure 4.andP;  Notice how the data-entry system'sarchitecture is basically the same as the model shown in Figure 1B.andM;Two products, Borland International's Paradox and Revelation Technologies'Advanced Revelation, illustrate very different approaches to developer (anduser) interface management.andP;  Both products are elaborate fourth generationapplication development environments.andP;  The tool sets are used for developmentof other software and are intimately associated with the finished, runningapplication.andP;  In both products a language (PAL in Paradox and R/BASIC inAdvanced Revelation) is used to write algorithms that are applied to datamoving between the user interface and the DBMS facilities.andM;Paradox has the most natural user interface for a product with an underlyingrelational database.andP;  Relations are tables that behave according to certainrules.andP;  Paradox I/O can be displayed and received on normal screen forms, butcan also display data in tables much like those found in spreadsheets.andM;The relational model has been criticized for being hard to understand, butthe concept of data relationships represented in common domains oftwo-dimensional tables is not that hard to grasp, especially with Paradox'svisual metaphor.andP;  Data between tables is connected by marking join columnsand coding conditions in a dialogue.andP;  This function conveys the structure ofthe joined tables and renders them as two or more tables in overlappingwindows.andM;Paradox tables can be manipulated much like spreadsheets.andP;  Columns and rowscan be expanded; a single cell can fill the whole screen if necessary, rowscan be rearranged, and so on.andP;  Data can be input and updated through thesetables, and all keystroke sequences used to perform these actions can remainfunctional in a screen evoked by application code.andM;The processes or function-key sequences used to update or output selecteddata can be recorded or coded as scripts that can be saved and reexecuted.andO;The proper dialogue facilities can also be recorded in the script.andO;Applications are made up of scripts that call other scripts and controllogic, such as conditional looping.andP;  Variables can be assigned based on userinput or other conditions, and these variables may determine script executionsequences and data displayed or accepted from the running I/O facilities.andM;Input-trapping not only includes data, but function-key sequences thatfurther modify the application's execution.andP;  Screens are not passed data somuch as they are given action sequences or formulas that require the DBMS toretrieve required data.andP;  Alternatively, PAL applications might use Paradoxfacilities invisibly to the user and display results using the same facility.andM;Data validation can take place in the screen independently of PAL code, DBMSdictionary (Paradox supports entity and referential integrity in thedictionary), or PAL logic if necessary.andP;  Error detection may occur at allthree levels of the system.andP;  User interpretation of the error isautomatically generated in high-level I/O systems if the screen or DBMSdetects the error; for example, an attempt to update a record locked byanother user.andP;  These same screen systems can display messages from PALindefinable regions and react in a prearranged fashion, responding tosubsequent user input.andP;  The application code is completely free of errorcorrection logic if the code is not responsible for corrections.andM;In Advanced Revelation, entire applications can be built by setting up allrequired I/O screens and placing hooks in the screens that execute any amountof R/BASIC code.andP;  Data entry and display screens look like other entryscreens, but behind the screen and prompt is a set of hooks that may be usedfor data validation and formatting.andP;  Advanced Revelation windows have astandard action set initiated by function keys.andP;  Any hook can be trapped anddiverted to other Advanced Revelation facilities or developer-generatedroutines.andM;The ultimate hook is the ability to execute R/BASIC code in response to anychange in data on the screen or in response to keystroke and function keycombinations.andP;  Such code can be evoked either by the whole screen or anyaction on the screen data.andP;  For example, an elaborate data-processingactivity might be triggered by a field update on a screen when the record isleft for the next screen.andP;  The same screen might contain an equally elaborateactivity that triggers when some field on the screen is bypassed withoutupdate.andP;  While PAL applications are largely a collection of commands thatevoke menus and screens, Advanced Revelation applications are sets of menusand screens that evoke underlying processing logic.andM;Applications can also be written in native R/BASIC code.andP;  In this case, thecode generates windows with calls to various window-producing subroutines.andO;Windows created by the high-level development system, complete with their setof validation routines, can also be called from application code.andP;  Thecalling code determines the immediate form of a window (for example, itslocation and size) and what data should appear in it.andP;  PAL evokes a tool andpasses actions to it, while Advanced Revelation evokes a window driver,possibly overriding some of its defaults, and passes data to it.andM;Advanced Revelation provides so much flexibility that strong consistencycontrols must be imposed on applications or they become difficult tomaintain.andP;  PAL's language cannot override rules embedded in I/O dialogue usedfor data input or DBMS integrity rules.andP;  In Advanced Revelation, it ispossible and easy for code to write anything to the database in any fieldregardless of how the dictionary or screen validation logic respond.andO;Advanced Revelation's physical files will accept everything in any field.andO;However, the DBMS can return no error other than to report problems with fileaccessing.andP;  A change to a record's primary key will result in either theautomatic generation of a new record or overwriting of the record whose keythe edited record now matches.andP;  This change is often not what a userintended.andM;Programs can read a file's dictionary and use it for validation purposes,including run-time determination of what validation-code to execute.andO;Dictionary metadata can be used to perform automatic output formatting ofcomputed data.andP;  A program can, if required, reference the dictionary of anyfile, not only the one for which the data is destined to be written.andO;Screen-triggered R/BASIC procedures can also access these dictionaries andevoke other windows, producing endless combinations or layers of data controllogic.andP;  If not treated respectfully, this elasticity may totally blur thedistinction between dialogue and processing logic.andP;  It may also nullify thevalue of having some intelligence embedded in the user-dialogue screens.andM;An interesting note: Advanced Revelation's new environmental-bondingcapabilities allow enhancement of dialogue screen managers for other vendorhsDBMS of file systems.andP;  Suppose a shop maintains a large application or set ofapplications written in dBASE.andP;  Advanced Revelation can now be used as aninterface and application-development cap on top of the dBASE native filesthrough an intermediary base-filling system driver.andP;  dBASE data is not portedto Advanced Revelation, but the environment reads and writes native dBASEfiles along with other dBASE applications still being used.andP;  Drivers nowexist for AutoCAD and Sybase SQL, with more in the works.andP;  When enoughdrivers exist, third-party developers will be able to work consistently inthe Advanced Revelation environment and attach their applications to DBMSfiles produced by multiple vendors.andO;</TEXT></DOC>