<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-406-588  </DOCNO><DOCID>07 406 588.andM;</DOCID><JOURNAL>Systems Integration  July 1989 v22 n7 p34(5)* Full Text COPYRIGHT Cahners Publishing Co. 1989.andM;</JOURNAL><TITLE>Real-time RISCs. (reduced instruction-set computers)</TITLE><AUTHOR>Simpson, David.andM;</AUTHOR><SUMMARY>Real-time reduced instruction-set computers (RISC) are growing inpopularity as system software becomes available, but these systemshave a number of inherent drawbacks.andP;  RISC processors rely heavilyon cache memory for real-time applications, which undermines thegoal of deterministic response time because the system does notknow whether an individual instruction or data reference is in thecache.andP;  The large number of registers in RISC chips causesproblems during context switches because RISC processors have morecontext to store than conventional processors.andP;  These drawbacksmake it difficult for software vendors to port operating systemsand kernels to RISC platforms.andP;  RISC processors are unsuited forapplications requiring a high degree of determinism but work wellfor non-event-driven applications such as embedded controllers forlaser printers.andM;</SUMMARY><DESCRIPT>Topic:     Systems SoftwareReal-Time SystemsReduced-Instruction-Set ComputersSystem SelectionCache MemoryImplementationProcess ControlRegistersCritique.andO;Feature:   illustrationphotographtable.andO;Caption:   A real-time RISC software sampler. (table)RISC vs. complex instruction-set computers. (table)andM;</DESCRIPT><TEXT>Real-Time RISCsandM;Bacon and eggs.andP;  Abbot and Costello.andP;  RISCs and real time.andP;  Some things justseem to go together.andP;  The benefits that RISCs (reduced instruction setcomputers) bring to conventional computing are, at least for  some types ofapplications, even more pronounced in the realm of  real-time computing.andO;Unfortunately, one ingredient has been missing: software.andP;  Now, however, ahandful of real-time operating systems and/or kernels exist for the leadingRISC chips, and a few more will be available by the end of the year (see, &quot;AReal-Time RISC Software Sampler&quot;).andM;Real-time software and speedy RISC processors seem to be a perfectcombination.andP;  But the developers and systems integrators who have to managethe difficult chore of integrating these register-rich chips and their large,cumbersome caches into products face some programming woes.andM;For real-time applications, one drawback to RISC processors is their heavyreliance on cache memory.andP;  Although both CISCs (complex instruction setcomputers) and RISCs benefit from the use of caches, the high speed of RISCsalmost demands the use of high-speed caches.andM;However, because the goal of real-time processing is deterministic, orpredictable, response times, caches pose a problem: An individual instructionor data reference may or may not be in the cache.andP;  &quot;You can't really getaround that problem,&quot; admits Larry Weber, vice president of softwaredevelopment at Mips Computer Systems Inc.andP;  &quot;What you do is rely on the factthat a great percentage of the references do use the cache.&quot;andP;  As result,overall performance, or speed, will be better with RISC chips than with CISCchips, as might be expected.andM;Real-time response times, however, must be predicted on worst-case events.andO;For processors using caches--whether RISC or CISC--that means  determiningcontext-switch times by assuming that everything is not in the cache.andP;  &quot;THus,in worst-case scenarios you might lose most of the advantages of RISC,&quot;concludes Weber.andM;&quot;Performance goes up with RISC, but real-time performance does not scale inproportion,&quot; says Inder Singh, president of Lynx Real-Time Systems Inc.andO;Singh doubts that overall performance will actually be worse with RISCs thanwith CISCs.andP;  Lynx plans to port its LynxOS real-time operating system tovarious RISC processors, but has not announced schedules.andM;One way to address the cache drawback, in applications that require a highdegree of determinism, is to run the RISC chip in &quot;uncached mode&quot; for thesections of application code that demand absolute predictability, orguaranteed response times.andP;  Running in uncached mode is possible with mostRISC chips.andP;  In such a scenario, the application gains the speed advantagesof RISC for those portions of the code that do not rely on deterministicresponses, but it loses that speed advantage for the code portions that dorely on deterministic responses.andP;  Conversely, developers can lock portions ofcode that have to be high speed and deterministic into the cache.andP;  Althoughthis approach guarantees high-speed, deterministic responses, the bulk of thecode will probably not require rigorously precise responses.andP;  That code willnot benefit from the speed of a cached RISC.andM;As a general rule, systems integrators or software developers with highlydeterministic applications should think twice before embracing the RISCapproach to real-time processing, because the more cache, the lessdeterminism.andM;As a result, some observers think that a viable option is to use a RISC chipwithout caches.andP;  &quot;RISC without cache may well run faster than the fastestavailable CISC chip,&quot; says Andrew Allison, a Los Altos Hills, Calif.,andO;independent consultant and editor of the RISC Management newsletter.andM;Another drawback to the use of RISCs for real-time processing is that mostRISC chips are rich in registers, i.e., circuits that hold addresses,instructions and data.andP;  Advanced Micro Devices Inc.'s Am29000, for example,weighs in at 192 registers (64 global, 128 local).andP;  A large number ofregisters can present problems during key real-time functions such as contextswitches.andP;  The reason: RISC processors, compared to CISC processors, havemuch more context to store.andM;&quot;Having a lot more registers allows faster code, but you've got more contextto save.andP;  That's the trade-off,&quot; says Ed Rathje, president of JMI SoftwareConsultants, which is porting its C Executive real-time operating systemkernel to a variety of RISC processors.andM;However, application developers can alleviate the context-saving delaysassociated with a large number of registers.andP;  For example, the Am29000 allowsdevelopers to specify how many registers they want to save.andM;However, controlling registers is not a trivial task.andP;  &quot;It's true that withthe 29000, application developers have some control over how many registersto save,&quot; says Alfred Chao, president of Software Components Group Inc.andO;(SCG), &quot;but it's important to note that in that case you're tuning thesoftware through several layers of other vendors' software, which is verydifficult.&quot;andP;  Those layers would include the compiler and the operatingsystem.andP;  (SCG is porting its pSOS+ real-time kernel to the Am29000 andMotorola Inc.'s 88000 RISC chip set.andP;  Motorola licenses pSOS and bundles thesoftware with its own board-level products.)andM;Rich Blomseth, strategic marketing manager at Ready Systems, says, &quot;In thecase of the 29000, we give a range of context-switch times, depending on howmany of the registers you choose to save.&quot;andP;  Ready has ported its VRTXreal-time kernel to the Am29000 and is in negotiations with other suppliersof RISC processors.andM;Coping with interruptionsandM;&quot;We segregate the notion of a context switch from what we call a lightweightinterrupt,&quot; explains AMD's Ron Waters, director of Am29000 products.andP;  &quot;Withthe 29K, when you do an interrupt, it's not necessary to save the total stateof the machine to do a full context switch.&quot;andP;  Application developers decidewhat they want to save.andP;  According to Waters, the Am29000 can perform alightweight interrupt, such as servicing a timer or keyboard, in as little asseven cycles.andM;Similarly, Andreas Schreyer, product manager for RISC products at Motorola,says that it is not necessary to save the entire machine state when doingcontext switches with Motorola's 88000: &quot;There's a misconception about RISCsbecause they're register-oriented architectures.andP;  You don't have to save theentire register contents whenever you have an exception.&quot;andM;Two other features of the 88000 are key in terms of context-switch times: Forone, the chip set has relatively few registers--32.andP;  Second, the 88000 usesregister scoreboarding, a technique by which hardwired logic in the chipallows all instruction units to share the register file.andP;  As a result,developers don't have to save the registers as often.andM;Yet another drawback to RISCs is that, at the low levels of the operatingsystem kernel, certain real-time operations are not handled automatically.andO;For example, when an interrupt occurs on a Motorola 680X0 CISC processor, theentire system state is automatically pushed onto the system stack.andP;  On a RISCmachine, in contrast, programmers have to write code to save the state of themachine.andM;All of the drawbacks to RISCs, relative to real-time implementations, make itdifficult for software vendors to port operating systems and kernels fromCISC to RISC platforms.andP;  Although RISC vendors would have you believe that,&quot;Porting is roughly the same between RISC and CISC as it is from CISC toCISC,&quot; as Mips Computer's Weber contends, software companies doing theporting know better.andP;  &quot;It's much more difficult to port from CISC to RISCthan from CISC to CISC,&quot; reports Bernard Mushinsky, president of IndustrialProgramming Inc. (IPI), which is porting its MTOS real-time operating systemto a variety of RISC processors.andM;Although architectural features such as caches and large register sets posechallenges for developers of real-time operating systems and kernels, thosefeatures are for the most part transparent to application programmers.andP;  Inother words, a real-time operating system on a RISC platform will look thesame as it would on a CISC platform: The programmer interface is the sameacross various architectures.andP;  As a result, application developers should beable to take, say, a C program written for a CISC-based machine, recompileit, and run it on a RISC machine running the same operating system--withoutmaking changes to the source code.andM;However, code portability does not guarantee performance portability.andM;Comparing RISC and CISC in real-time implementations depends on a variety offactors: Which CISC?andP;  Which RISC?andP;  What type of application?andP;  In fact, it'spractically impossible to compare the two without actually bench-markingspecific applications.andM;The two companies in the best, or at least most objective, position tocomment on the RISC vs.andP;  CISC debate are Motorola and Intel Corp..andM;Motorola's Schreyer claims that the 88000 provides a linear increase inperformance, compared to the 680X0 line, in terms of key real-time tasks suchas interrupt-response times, exception-handling times, and overall executionspeed.andP;  Schreyer claims that the performance increases roughly parallel thedifference in MIPS rating between the two chips.andM;Motorola's claims may be misleading, because the comparison isapplication-dependent, but Intel's RISC/CISC strategy is certainly moreconfusing.andP;  Intel's Buzz Schadel, product marketing manager, explains thatIntel's i860 RISC processor is targeted at workstations and is not optimizedfor real-time processing.andP;  The 80960 processor, on the other hand, targetsembedded real-time processing.andM;In comparing the '960 to the 80386, Schadel says that the '960 isconsiderably faster and cheaper and therefore better suited for embeddedreal-time control tasks.andP;  The '386, in contrast, is more suited to CPU-levelreal-time processing applications.andP;  To further confuse Intel's RISC/CISCproduct mix, Schadel says that it's more appropriate to compare the 80376with the '960.andP;  The '376 is basically a stripped-down '386 that doesn'tinclude features such as demand paging and other functions that aren'trequired by embedded real-time applications.andM;Not surprisingly, chip vendors solely committed to the RISC market (i.e.,andO;those that don't offer CISC chips) tout the absolute superiority of RISCs inreal-time applications.andP;  For example, Mips Computer's Weber says, &quot;Real-timeperformance advantages will most likely parallel non-real-time advantages ofRISC over CISC.&quot;andM;Unfortunately, largely because RISC chips are relatively new and very littlereal-time software exists to take advantage of them, benchmarks are few andfar between.andP;  Ready Systems reports that preliminary comparisons show thatthe Am29000 delivers better context-switch times than the 68020.andP;  &quot;Even inthe worst case, the 29K is faster than a typical CISC,&quot; claims Ready'sBlomseth.andP;  Ready reports that, when running its VRTX real-time kernel on theAm29000, a full context switch takes 16 microseconds, which is three to fourtimes faster than VRTX on typical CISC processors.andM;JMI's Rathje provides more detailed comparisons: When running JMI's CExecutive on a 20-MHz Am29000, the time required to write a system call to anull device is 9 microseconds.andP;  On a 25-MHz 68020, it takes 29 microseconds.andO;However, the context-switch time on the 68020 is 17 microseconds; on the29000 it's 29 microseconds.andM;Mix 'n matchandM;Because of the problems associated with large register sets and caches, somepeople question the suitability of RISCs for real-time implementations.andP;  Forexample, SCG's Chao says that, because of the potential drawbacks of RISCarchitectures, &quot;RISC may be better suited for compute-intensive environmentsthan for event-driven environments, where there are a lot of contextswitches.&quot;andM;In fact, the suitability of RISCs for real-time applications depends on thedegree of determinism required by the application.andP;  As such, RISCs may bevery good processors for real-time applications such as embedded controllersfor laser printers, an application that is not highly event-driven.andP;  Incontrast, RISCs may be less suitable for, say, telecommunicationsapplications, which are highly event-driven.andM;The programming hassles that are required to avoid the cache and registerdrawbacks may not be worth the effort for many systems integrators andapplication developers.andP;  &quot;If you have to do all that to get around a problem,why not just use a chip that doesn't have that problem?&quot; says RISCManagement's Allison.andM;Because of the relative advantages and disadvantages of RISCs and CISCs inreal-time processing--and in part, perhaps, because of the confusion--there'sa trend toward combining the two architectures in single systems.andP;  In such asystem, CISC processors might be used as I/O processors while RISCs are usedfor number-crunching tasks.andP;  Similarly, designers could partition codeaccording to degrees of required determinism and then divide the processingof that code between appropriate architectures.andM;Regardless of how developers choose to implement real-time RISC, it'sinteresting that almost all of them are focusing on the Big Five RISC chipsuppliers (AMD, Intel, Mips, Motorola, Sun Microsystems Inc.) when, in fact,they may be ignoring the best RISC chips for real-time tasks.andP;  Consider thefact that both Inmos International Plc and VLSI Technology Inc. (VTI) eachsold more RISC chips for embedded-control applications last year than did allof the Big Five combined.andP;  That's according to Allison.andP;  He adds that VTI'sVL86C010 Acorn RISC exhibits extremely fast interrupt-response times.andP;  Inaddition, the Acorn uses shadow registers, which reduce context-switch times.andM;So why aren't software developers porting to those processors, or to otherRISC-like processors such as Harris Semiconductor's RTX2000?andP;  The mostconsistent response is, &quot;We're driven by customer demand.&quot;andP;  And the softwarevendors' customers are asking for ports to the Big Five chips.andP;  The secondmost consistent response is, &quot;We're just not as familiar with those chips.&quot;andM;In any case, developers should not ignore RISC chips that don't get thepublicity and press.andO;</TEXT></DOC>