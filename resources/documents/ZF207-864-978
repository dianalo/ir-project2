<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-864-978  </DOCNO><DOCID>07 864 978.andM;</DOCID><JOURNAL>Communications of the ACM  Nov 1989 v32 n11 p1352(7)* Full Text COPYRIGHT Assn. for Computing Machinery, Inc. 1989.andM;</JOURNAL><TITLE>The adaptable user interface. (learning different dialogue modeswith microcomputers) (technical)</TITLE><AUTHOR>Kantorowitz, Eliezer; Sudarsky, Oded.andM;</AUTHOR><SUMMARY>It is sometimes helpful for a computer user to have availabledifferent dialogue modes, such as pointing with a mouse and typingon the keyboard, within the same command.andP;  To meet this need, thearticle introduces the concept of the adaptable user interface(AUI), which integrates different dialogue modes into one userinterface.andP;  Depending on their level of experience, differentusers can adapt the dialogue modes to their needs.andP;  Whilebeginners start out by using menu modes, more experienced userscan take advantage of the faster command language modes, switchingback to the menu mode when needed.andM;</SUMMARY><DESCRIPT>Topic:     AdaptabilityUser InterfaceUser-FriendlinessUser NeedsScientific ResearchTechnologyMicrocomputersComputer LearningMenusCommand-Driven User Interfaces.andO;Feature:   illustrationchart.andO;Caption:   The graphic representation of RTN states and transmissions.andO;(chart)Screen layout for guide-developed application. (chart)LEXEDIT's icon editor screen. (chart)andM;</DESCRIPT><NOTE>Only Text is presented here; see printed issues for graphics.andO;</NOTE><TEXT>The adaptable User InterfaceandM;THE AUI CONCEPT Software systems interact with users in a large variety ofways (dialogue modes).andP;  These methods may be classified as the menu-type andthe command-language-type.andP;  In a menu-type-dialogue mode (MM), the usercontrols the system solely through the selection of options from a number ofchoices presented.andP;  It is assumed that only choices that makr sense arepresented to the user, and that it is, therefore, not possible to selectoptions that are not permitted.andP;  In a command-language-type dialogue mode(CLM), the user controls the system by instructions given in a certaincommand language.andP;  The user must know this language in order to use thesystem.andP;  In contrast with an MM, whre the user is guided by menus and canonly enter legal choices, the user of a CLM may enter erroneous instructions.andO;A CLM should, therefore, be designed to detect improperly formulatedinstructions and to correctly recover from their effects.andM;The advantages of an MM over a CLM are well known.andP;  Since the users do nothave to learn any command language, they may become productive with a newsystem after a very short time.andP;  A new user may explore the operationsprovided by a system simply by browsing through the menus.andP;  If such a systemalso provides adequate help for every menu option, the user may operate thesystem without ever needing a manual.andM;Menu systems may, however, be less satisfactory for frequent users who haveto work through a large number of menus to get their work done.andP;  Waiting fora menu to appear on the screen, finding the right menu entry, and making theselection can take time.andP;  Proficient users who do not need guidance tend toprefer a concise CLM where a few keystrokes, entered at full typing speed,achieve the same effect as a number of relatively slow menu selections.andO;Isaki and Schneidermann observed in [7] that &quot;Knowledgeable users oftenremark that they would prefer to type commands and believe that they can workmore rapidly by just typing commands.&quot;andM;Realizing the different needs of beginners and experts, many systems providetwo distinct user interfaces: a menu interface and a command-languageinterface.andP;  In these systems, the user has to select in advance (in thebeginning of the session or before each command) one of these two interfacesthat is best suited to the task.andP;  If a user wants to change the dialoguemode, the current command must be completed first, and then the user mustrequest that the system switch to the desired user interface.andP;  There arecases, however, when it is useful to change the dialogue mode in the middleof a command.andP;  To demonstrate this, we will employ an example command fordrawing a black box with the lower left corner at (0,0) and the upper rightcorner at (1,1):andM;BOX BLACK (0,0) (1,1)andM;The first case to be discussed is that of a user who is neither a beginnernor an expert but is somewhere betwen these two extremes.andP;  Such a user mayrealize that he or she has forgotten some command language element while inthe middle of composing a command and may need the assitance of menus [3,5].andO;Assume that the user has typed the word BOX of the example command and isuncertain about what colors are available.andP;  Shifting to an MM will facilitatecolor selection from a menu.andP;  A similar situation occurs when the user hasmade a mistake, e.g., entered a color that does not exist.andP;  After reading theerror message, the user can switch to a menu of colors in order to select anavailable color.andM;The need to assist users who cannot complete a command is realized in currentsystems, which enable commands to be programmed such that users are promptedfor missing parameters.andP;  These systems, however, do not give the users thefreedom to employ at any time the dialuge mode that is most productive fortheir level of expereince.andP;  The users' freedom in changing dialogue modessolves another class of problems which we will discuss next.andM;One of the criteria for deciding whether to use a CLM or an MM is the natureof the input data and the physical properties of the I/O devices.andP;  In ourexample, the coordinates of the corners are known by their exact numericalvalues ((0,0) and (1,1)), and it is, therefore, appropriate to enter them bytyping them at the keyboard (a CLM).andP;  If a corner is only known by itsposition on the screen, however, it must be entered by moving the cursor witha mouse or another locating device.andP;  By our definition, this method forentering coordinates is an MM, where the points of the screen are the choicesand the selection is made with the mouse.andP;  We observe that depending on thenature of the actual input data, the same command is sometimes entered in aCLM and, in other cases, in an MM.andP;  Sometimes it is required to employ twodifferent dialogue modes within the same command.andP;  For instance, one of thecorners of the box is known by its position on the screen (and must,therefore, be entered by pointing at it) while the other corner is known bythe numerical values of its coordinates (and should be entered through thekeyboard).andM;Is is sometimes useful to have more than one MM or more than one CLM.andP;  As anexample, let us consider a system with two different CLMs for the samecommand language: a voice-input mode and a keyboad-input mode.andP;  Voice inputis preferred when the user has to operate away from the terminal or isotherwise occupied.andP;  On the other hand, keyboard input may be quicker or lesserrror prone in noisy environments.andM;We propose an adaptable user interface (AUI), which will allow the user toswitch dialogue modes in the middle of a command.andP;  An adaptable userinterface is defined as an interface that:andM;* supports a number of different dialogue modes.andP;  More than two modes may beprovided;andM;* allows the user to switch between dialogue modes at any time, i.e., even inthe middle of a command;andM;* makes the switch between dialogue modes smoothly and naturally;andM;* makes it easy for the user to learn how to use the different dialoguemodes, especially the CLMs, which usually require a longer training period.andM;In order to enable simple and natural switching between dialogue modes, anumber of assumptions and requirements are proposed.andP;  The central assumptionis that all the dialogue modes of an AUI are different representations of asingle underlying dialogue language.andP;  This common language is assumed to beconstructed of a number of elementary syntactic components, to be calledtokens.andP;  Every token is required to have a distinct representation in each ofthe dialogue modes.andP;  In an MM, a token is represented by a single menuselection, while the corresponding representation in a CLM is an atom of thecommand language.andP;  For example, in the GUIDE system, to be described later,CLM tokens are represented by character strings.andP;  Each token may be enteredin any one of the available dialogue modes, independent of the modes employedfor the other tokens.andP;  Two subsequent tokens may thus be entered in twodifferent modes.andM;Beginners and casual users will employ the AUI in an MM.andP;  As they become morefamiliar with the system, they will gradually learn the CLM instructions thatthey need.andP;  A user can exploit the CLM commands already learned and employ anMM for all the other commands.andP;  Users will not have to learn CLM commandsthat are rarely used since they may be entered in an MM.andM;Additionally, each token can be entered in the most suitable way.andP;  Forexample, in the BOX command, each of the two corners is given by a singletoken.andP;  One corner of the box may be entered using a mouse while the oppositecorner can be entered by typing its coordinates.andP;  The implementation of auser interface is usually a major effort.andP;  This is especially true for anAUI, in which several input devices must be monitored simultaneously.andP;  It is,therefore, desirable to have a user interface management system (UIMS) [10,11, 15, 16] that automatically generates AUIs.andP;  Nonetheless, none of theexisting UIMSs seem to allow the easy production of AUIs.andP;  Most systems canonly generate single-dialogue-mode user interfaces.andP;  In systems that offerseveral modes, the end user is usually required to select a single dialoguemode at the beginning of the session.andP;  The Workspaces system [1] allows onlypartial adaptability (keyboard parameters must be entered first, followed bythe parameters given by other input devices).andP;  The IOT [16], Switchboard[14], and Sassafras [6h systems may possibly be extended by the userinterface designer with code that supports several dialogue modes; however,writing such code is a difficult task that requires insight in parallelprogramming of I/O devices.andM;THE GUIDE SYSTEMandM;In order to test the practicality of AUIs and of their automatic generationby a UIMS, the GUIDE (Graphic User Interface Design Environment) system wasimplemented [13].andP;  Further design goals for GUIDE were:andM;* specification and modification of a user interface should be simple andrequire no programming skills.andP;  This will enable the system to be used byhuman factor experts who are not necessarily programmers.andP;  The ability toeasily modify the user interface is important since human behavior may not beprecisely predicted, and some debugging may be required;andM;* exending the user interface with the new I/O devices and associateddialogue modes should be easy and require only minimal modification of thesystem.andM;An application program developed with GUIDE has three main modules called thelexical, syntactic, and semantic components.andP;  The lexical componentidentifies the tokens in the stream of input events.andP;  The syntactic componentanalyzes the stream of tokens it receives from the lexical component andinvokes the semantic component when required.andP;  The semantic component is thecollection of application routines written by the application programmers insome ordinary programming languages.andM;The syntactic and lexical components constitute the user interface of theapplication program.andP;  GUIDE generates this user interface from specificationsgiven through interactive graphic design tools.andP;  The user interfacespecifications do not cause the generation of any code; rather, they arestored in a relational database and are later interpreted by a run-timeenvironment.andP;  The code of this run-time environment is identical for allGUIDE-developed applications; only the database and the semantic componentare different.andP;  A change in the user-interface specifications only requires amodification of the database.andP;  The effect of such a change can be seenimmediately, since no compilation and linkage are required.andP;  This facilitiesrapid prototyping of user interfaces since the designer can try severalalternative solutions within a short time.andM;The Syntactic ComponentandM;The syntactic component of the user interface employs a recursive transitionnetwork (RTN) as the definition of the dialogue language.andP;  An RTN interpreterexecutes this definition when it analyzes the stream of input tokens.andP;  RTNswere chosen for the syntax representation because they are as powerful asdeterministic, context-free grammars yet easier to use than BNFrepresentation, especially for nonprogrammers [2, 4, 8].andP;  An overview andcomparison of current methods for specification of the syntax of dialoguelanguages is found in [16].andM;An RTN is constructed from a number of subnets.andP;  Each subnet is representedby a directed graph.andP;  The following kinds of states (nodes) and transitions(edges) may appear in a subnet (see Figure 1):andM;* initial state--the state in which the execution of subnet begins;andM;* return state--causes control to return to the calling subnet;andM;* subnet call state--causes control to pass to another subnet (or,recursively, to the same subnet);andM;* application call state--causes an application routine to be executed;andM;* input state--causes control to wait for the reception of a token from thelexical component.andP;  A menu may be associated with this state; if required,this menu will be displayed automatically when this state is reached;andM;* output state--causes the display of a message to the end user;andM;* plain transitionandM;* retain transition-appears after an application call state and is traversedif the routine has returned the return code associated with this transition;andM;* option transition--appears after an input state and is traversed if theuser has selected the menu option associated with this transition;andM;* parameter transition--appears after an input state and is traversed if theuser has picked an object of the type associated with this transition.andM;It is noted that a subnet may recursively call another subnet or itself.andO;This enables the grammar of the dialogue language to be defined in a modularway in much the same way as a program is constructed from subroutines.andM;Figure 2 shows an example of an RTN subnet called PickNode.andP;  The execution ofthis subnet by the RTN interpreter starts at the initial state S1 and thenimmediately passes to the input state S2.andP;  A menu called NodeMenu isassociated with this state.andP;  The user has now to select one of the twooptions in this menu.andP;  If, for instance, the option named Del is selected,the option transition T2 will be traversed, and the application call state S3will be reached.andP;  The semantic procedure DNode associated with ths state willbe called by the RTN interpreter.andP;  Finally, the return state S5 will beencountered, and the execution of the subnet will terminate.andM;GUIDE provides an interactive graphic editor called SYNEDIT.andP;  This editorallows the user interface designer to construct the RTN which defines thesyntax of the dialogue language.andP;  A SYNEDIT screen is shown in Figure 2.andO;SYNEDIT checks the consistency and completeness of the RTN to make sure thatit can be executed.andP;  The user interface for SYNEDIT itself was generated byGUIDE.andM;The Lexical ComponentandM;The lexical component of a GUIDE-generated user interface manages all theinput and output of the program.andP;  The output consists of text messages,menus, icons, and links.andP;  A link is a line that connects two icons.andP;  Iconsand links may be used to represent the different objects on which theapplication operates.andP;  They can, for instance, be employed to show the nodesand edges of the graphs that appear in some applications.andM;GUIDE's lexical component is called by the RTN interpreter (the syntacticcomponent) when it encounters an input or output state.andP;  The lexicalcomponent currently supports two dialogue modes.andP;  Every menu, icon, or linkcan, therefore, be selected in one of two ways: by pointing with a mouse (anMM) or by typing the option's or object's name (a CLM).andP;  Text typed at thekeyboard appears in a special CLM text area at the bottom of the screen (seeFigure 3 and the examples in Figures 2 and 7).andP;  If the user employs themouse, the name of the selected menu option or object will be copied by GUIDEinto the CLM area as if the user has typed them in.andP;  The CLM area will,therefore, in all cases show the command language representation of thecommand being entered.andP;  This helps the user to learn the command language.andO;Note again that each of the tokens in the command may be entered in adifferent dialogue mode.andP;  Furthermore, note that the user does not have totell the system to switch between dialogue modes--but simply uses whicheverdevice (mouse or keyboard) wanted.andM;The different dialogue modes are managed solely by the lexical component.andO;When the RTN interpreter receives a token from the lexical component, it hasno knowledge of the mode in which this token was entered.andP;  This makes thesystem relatively easy to adapt to future dialogue modes and input devices(e.g., a speech recognizer) since only the lexical component will have to bechanged, while the syntactic and semantic components will remain unchanged.andM;GUIDE includes a program called LEXEDIT that allows the user interfacedesigner to define icons, links, menus, and messages.andP;  In the icon editorscreen (see Figure 4) the icon is drawn using graphic primitives and textfields.andP;  The icon is shown twice: life-sized in the corner of the screen andenlarged in the main window.andP;  In the link editor screen (see Figure 5), thedesigner can specify th attributes of the link: line style, arrowheads, andlink shape.andP;  Text fields can be placed along the link.andP;  In the menu editorscreen(see Figure 6), the menu's graphic appearance is drawn.andP;  The name andthe rectangular region occupied by each option in the menu can be defined.andO;The designer has a choice of three menu styles: static, pop-up, andpull-down.andP;  This choice of facilities allows the implementation of many ofthe currently popular user interface styles.andM;EXAMPLES OF GUIDE-DEVELOPED APPLICATIONSandM;In order to test the applicability of GUIDE in various areas, user interfacesfor three differnt applications were constructed.andP;  The applications are:andM;* a directed graph editor,andM;* a specification program for management information systems (MISs), andandM;* the RTN editor of the GUIDE system.andM;The directed graph editor is a small program.andP;  It was implemented as a simpleexample for the GUIDE user's manual.andP;  The program lets the end user edit adirected graph interactively.andM;The entire user interface for this application was developed in less than twohours.andP;  The user interface designer used LEXEDIT to define the shape of theicons which represents the nodes of the graph, the link which represents theedges, and the menus.andP;  The designer used SYNEDIT to construct an RTN withcommands to add, move, and delete nodes and edges.andP;  Figure 2 shows one of thesubnets of the RTN being edited.andP;  The resulting user interface, as it appearsto the end user, is shown in Figure 7.andM;The use of AUIs can be illustrated with this directed graph editor.andP;  Supposethe end user wants to add an edge from node v to node w.andP;  One way to do it isto type at the keyboard the command:andM;AddEdge v wandM;If the user has forgetten the command named AddEdge, however, selection canbe made from the pop-up menu as shown near the upper left-hand corner ofFigure 7 and then point at the nodes v and w with the mouse.andP;  Entering a nodename at the keyboard may, however, be preferred when the node is notcurrently visible because scrolling has moved it off the screen.andP;  In fact,there are 2[sup.3' = 8 possible ways to enter the three tokens of thiscommand.andM;A second application developed with GUIDE is a program to assist analysts inthe development of design specifications for MISs.andP;  It was developed by D.andO;Reider at the computer science department at Technion [12].andP;  The programsupports a top-down design methodology combining data modeling and structuredanalysis.andP;  The system analyst employs three kinds of tools: an organizationalstructure diagram, an entity-relationship diagram (ERD) (see Figure 8), anddata-flow diagrams (DFDs).andP;  Each of these diagrams is composed of differentkinds of icons and links.andP;  The design methodology requires that certaincomplex relationships be maintained between the different diagrams.andM;The application lets the user construct these diagrams with an interactivegraphics editor.andP;  The consistency and completeness of each diagram and therelationships between the diagrams are checked automatically.andP;  The diagramsare stepwise-refined and are, therefore, changed frequently.andP;  The resultingdiagrams can be quite complex and would be difficult to manage manually.andP;  Theuser interface for this application was developed in about forty hours.andM;A third application is the RTN editor SYNEDIT, which is employed in GUIDE tospecify the syntax of dialogue languages (see the section &quot;The SyntacticComponent&quot; and Figure 2).andP;  The RTN states (shown in Figure 1) are representedas icons, while the transitions are displayed as links.andP;  The editor isemployed to construct the subnets which constitute the RTN and to check thecorrectness of the RTN.andP;  Since SYNEDIT could not be used to enter thespecifications of its own RTN, these data had to be entered manually into thespecification database.andP;  The rest of the specifications for SYNEDIT wereinput with LEXEDIT.andM;IMPLEMENTATIONandM;GUIDE was implemented on an IBM PC AT-compatible computer.andP;  Most of thesoftware was written in the dBASE III PLUS database programming language andcompiled with the Clipper compiler.andP;  The use of a relational database tostore user interface specifications allowed rapid an simple development ofGUIDE.andP;  Since the dBASE language cannot be fully compiled, however, thesystem is somewhat slow.andP;  A reimplementation of GUIDE in a compilableprogramming language is expected to result in satisfactory performance.andM;conclusionsandM;It has been argued that it is sometimes useful to employ a number ofdifferent dialogue modes (such as typing text at the keyboard and pointingwith a mouse) within the same command.andP;  This cannot be achieved in thecurrent systems that provide different dialogue modes by applying anessentially separate user interface for each dialogue mode.andP;  In order to meetthese needs, this article introduces the adaptable user interface (AUI)concept which integrates a number of dialogue modes into a single userinterface.andM;The freedom of the AUI user to adapt dialogue modes to actual needs is usefulat all levels of experience.andP;  A novice user starts by using menu modes (MMs)where guided by choices presented by the system and gradually learns how toutilize the command language.andP;  An experienced user employs the faster commandlanguage modes (CLMs) but can switch to menus in the middle of a command ifuncertain about how to finish it.andP;  An AUI also enables the user to choose thedialogue mode that is most suitable for the nature of input data and theworking environment.andM;The implementation of the GUIDE system suggests that both AUIs and a UIMSwhich generates AUIs are practical on personal computers.andP;  It also shows thatall dependencies on I/O devices and dialogue modes can be isolated in thelexical component of the user interface.andP;  This facilities future additions ofany number of new dialogue modes to the user interface of an already existingapplication.andM;User interfaces for three different applications were implemented relativelyquickly and conveniently using GUIDE.andP;  In these applications, switchingbetween different dialogue modes appears natural gives the user a new degreeof freedom in exploiting the system.andM;Acknowledgments.andP;  We thank David Reider for his kind help in system analysisand in the development of one of the examples.andM;REFERENCESandM;[1] Enderle, G.andP;  The flexible configuration of interaction environments usingGKS and Workspace.andP;  In Proceedings of the Seeheim Workshop on UIMS.andO;Springer-Verlag, New York, 1985.andM;[2] Green, M. Report on dialogue specification tools.andP;  In Proceeding of theSeeheim Workshop on UIMS.andP;  Springer-Verlag, New York.andP;  1985.andM;[3] Grimes, J. D. A knowledge oriented view of user interfaces.andP;  InProceedings of the 12th Hawaii International Conference on System Sciences,Vol.andP;  I (Honolulu, Hawaii, Jan. 4-5.)andP;  ACM, New York, 1979, pp.andP;  158-163.andM;[4] Guest, S. P.andP;  The use of softeare tools for dialogue design.andP;  Int.andP;  J.andO;Man-Machine Studies 16, (Apr.andP;  1982), 263-285.andM;[5] Heffler, M. J.andP;  A human-computer interface that provides access to adiverse user community.andP;  In Proceedings of the 14th hawaii InternationalConference on System Sciences (Honolulu, Hawaii, Jan. 8-9).andP;  ACM/IEEE, NewYork, 1981, pp.andP;  601-610.andM;[6] Hill, R. D.andP;  Supporting concurrency, communication, and synchronizationin human-computer interaction--The Sassafras UIMS.andP;  ACM Trans.andP;  Graph.andP;  5, 3(July 1986), 179-210.andM;[7] Iseki, O., and Shneiderman, B.andP;  Applying direct manipulation concepts:Direct Manipulation Disk Operating System (DMDOS).andP;  Softw.andP;  Eng.andP;  Notes 11, 2(Apr.andP;  1986), 2-26.andM;[8] Kacob, R. J. K.andP;  Using formal specifications in the design of ahuman-computer interface.andP;  Commun.andP;  ACM 26, 4 (Apr.andP;  1983), 259-264.andM;[9] Myers, B. A.andP;  User-interface tools: Introduction and survey.andP;  IEEE Softw.andO;(Jan.andP;  1989), 15-23.andM;[10] Olsen, D. R., Jr., et al.andP;  ACM SIGGRAPH workshop on software tools foruser interface management.andP;  Comput.andP;  Graphics 21, 2 (Apr.andP;  1987), 71-174.andM;[11] Pfaff, G. E., Ed.andP;  User interface management.andP;  In Proceedings of theSeeheim Workshop on UIMS.andP;  Springer-Verlag, New York, 1985.andM;[12] Reider, D., Kantorowitz, E., and Raz, T.andP;  Specification of managementinformation systems combining data modeling and structured analysis.andP;  InProceedings of the 4th Israel Conference on Computer Systems and SoftwareEngineering (Tel Aviv, Israel, June 5-6.)andP;  IEEE-CS, New  York 1989, pp.andO;34-44.andM;[13] Sudarsky, O.andP;  A user interface management system adaptable to varioususer experience levels.andP;  Thesis, Dept.andP;  of Computer Science, Technion-IsraelInstitute of Technology, Haifa, Israel, 1988.andM;[14] Tanner, P. P., et al.andP;  a multitasking switchboard approach to userinterface management.andP;  In Proceedings of SIGGRAPH '86: 13th Annual Conferenceon Computer Graphics and Interactive Techniques (Dallas, Tex., Aug. 18-22.)andO;ACM/SIGGRAPH, New York, 1986, pp.andP;  241-248.andM;[15] Thomas, J. J., and Hamlin, G.andP;  Graphical Input Interaction Technique(GIIT) workshop summary.andP;  Comput.andP;  Graphics 17, 1 (Jan.andP;  1983), 5-30.andM;[16] van den Bos, J., Plasmeijer, M. J., and Hartel, P. H. Input-Outputtools: A language facility for interactive and real-time systems.andP;  IEEETrans.andP;  Softw.andP;  Eng.andP;  SE-9, 3 (May 1983), 247-259.andM;CR Categories and Subject Descriptors: D.2.2 [Software Engineering]: Toolsand Techniques--user interfaces; D.2.6 [Software Engineering]: ProgrammingEnvironments--interactive; D.2.m [Software Engineering]: Miscellaneous--rapidprototyping; D.3.4 [Programming Languages]: Processors--interpreters,run-time environments; H.1.2 [Information Systems]: User/MachineSystems--human factors; I.3.6 [Computer Graphics: methodology andTechniques--interaction techniques, languagesandM;General Terms: Human Factors, LanguagesandM;Additional Key Words and Phrases: Dialogue languages, recursive transitionnetworks, user interface management systems, user interfacesandM;E.andP;  KANTOROWITZ is currently a professor at the Computer Science Departmentat Technion-Israel Institute of Technology and an ACM member.andP;  His researchinterests are in adaptable user interfaces, fault tolerant distributeddatabase systems, and he is involved in the design of an industrialdatabase-oriented ship design system.andP;  Author's Present Address: ComputerScience Department, Technion-Israel Institute of Technology, Haifa 32000,Israel.andP;  KANTOR@TECHSEL.BITNETandM;O.andP;  SUDARSKY recently completed his Master of Science studies and is an ACMmember.andP;  His research interest are adaptable user interface managementsystems.andP;  Author's Present Address: 11 Mishmar HaYarden St., 18412 Afula,Israel.andO;</TEXT></DOC>