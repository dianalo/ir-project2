<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-444-990  </DOCNO><DOCID>08 444 990.andM;</DOCID><JOURNAL>Microprocessor Report  May 2 1990 v4 n8 p12(2)* Full Text COPYRIGHT MicroDesign Resources Inc. 1990.andM;</JOURNAL><TITLE>Computer Architecture: A Quantitative Approach. (Book Review)</TITLE><AUTHOR>Wakerly, John F.andM;</AUTHOR><DESCRIPT>Topic:     BooksReview.andO;Feature:   illustrationtable.andO;Caption:   (Table of contents). (table)andM;</DESCRIPT><TEXT>Computer Architecture: A Quantitative ApproachandM;This new book by two gurus of computer architecture is highly recommended foranyone who is designing high-performance microprocessor systems or writingsystem software for them.andP;  The book is used in first-year graduate courses oncomputer architecture, but it also provides an extremely valuable perspectiveand a timely update for working professionals.andM;This is an architect's book, focusing on the high-level choices made by acomputer designer.andP;  It is full of engineering wisdom and teaches the readerhow to evaluate the cost/performance consequences of architectural (andsometimes implementation) choices in computer design.andM;Although few readers will ever be in the position of designing a new computerarchitecture, this book can help any reader make an informed choice whenselecting among existing microprocessor architectures for an application.andO;Note, however, that this book is not an implementor's guide: it does notcontain detailed circuits or design considerations (e.g., how to make fastregister files, caches, or main memories; pitfalls of specific circuit orpackaging technologies).andM;You don't need to read this book from cover to cover to get a lot out of it,since it is logically organized and quite accessible to the average reader.andO;It has a comprehensive index, so after as initial skimming it will continueto be a valuable reference.andM;Table 1 lists that text's contents.andP;  The first chapter sets up consistentdefinitions for the rest of the text.andP;  It also introduces quantitativeprinciples of computer design, such as Amdahl's Law (the performanceimprovements provided by a feature are limited by how often the feature isused) and notions of cost/performance.andM;Chapter 2 continues with an exposition of topics in cost and performance.andO;Cost is discussed at both the VSLI IC and systems levels.andP;  In the performancearea, Hennessy and Patterson seem to agree witht he poplar theme that thereare &quot;lies, damned lies, and benchmarks,&quot; as they concisely explain MIPS,MOPS, and MFLOPS and what is wrong with them.andP;  They believe that &quot;the onlyconsistent and reliable measure of performance is the execution time of realprograms,&quot; where &quot;real programs&quot; are quite different from toy benchmarks likeQuicksort and synthetic benchmarks like Whetstone.andM;Instead of providing a dry taxonomy of computer instruction sets, Chapter 3emphsizes performance characteristics that result from instruction-setchoices, and includes a variety of architectural measurements.andP;  The goals ofinstruction-set design are explained in the context of modern compilertechnology.andM;Patterson and Hennessy believe that the computer-architecture field &quot;haschanged from one that can only be taught with definitions and historicalinformation, to one that can be studied with real examples and realmeasurements.&quot;andP;  In Chapter 4, they focus on four examples: VAX, 360/370,8086, and &quot;DLX&quot; (see below).andP;  The instruction-set architecture of eachmachine is briefly described, and then addressing-mode and instruction usageof each machine is measured quantitatively.andP;  The results give the readers afeel for what is and is not important in instruction-set architecture.andM;&quot;DLX&quot; is a hypothetical, generic load/store machine that bears a closeresemblance to RISC machines introduced over the last five years.andP;  In fact,DLX is so generic that Appendix E is able to concisely describe thearchitectures of four popular RISC machines (i860, MIPS, M88000, and SPARC)in a few pages each, simply by showing their differences from DLX.andM;Despite Hennessy and Patterson's fame in the RISC world, their book is not asoapbox for RISC.andP;  In fact, Chapter 5 looks at traditional processorimplementation methods.andP;  Examples include both hardwired and microprogrammedcontrol units for DLX.andM;Only in Chapter 6 do the authors get into pipelining, presenting a simple,pipelined, &quot;RISC&quot; implementation for DLX.andP;  Register scoreboarding, branchprediction, and superscalar and VLIW approaches are discussed later in thechapter.andP;  The VAX 8600 pipeline is also described.andP;  Chapter 7 describes thearchitecture and performance of pipelined vector machines, including ahypothetical DLXV and the Cray X-MP.andM;Chapter 8 covers memory-hierarchy design, emphasizing the performanceconsequences of design choices such as cache size, organization and writepolicy, and main-memory width and interleaving.andP;  This chapter also introducesregister windows, virtual memory, two-level caches, and cache coherency.andM;The &quot;orphan of computer architecture,&quot; input/output, is the topic of Chapter9.andP;  Following the rest of the book's theme, this chapter describes I/O mainlyin terms of performance, including a nice comparison of five standard I/Obuses (VME, Futurebus, Multibus II, IPI, and SCSI).andP;  Cost/performancecharacteristics of both a hypothetical SCSI-based I/O subsystem and the IBM3990 I/O subsystem are examined.andM;The brief final chapter introduces standard models of parallel computationand discusses &quot;the roads to El Dorado&quot;: how we might ultimately arrive atcomputing systems that contain thousands or millions of processors, eachexecuting billions of instructions per second.andM;Appendix A, written by David Goldberg, includes a nice overview of the IEEEfloating-point standard as well as a description of hardware methods forspeeding up arithmetic operations.andM;Repeated FeaturesandM;Each chapter of the book has a &quot;putting it all together&quot; section showingexamples of real machines embodying the chapter's ideas.andP;  Examples throughputthe book are highly relevant, including processors such as DEC VAX, IBM 360,Cray X-MP, Intel 80X86 and i860, Motorola 68000 and 88000, MIPS R2000 andR3000, Sun SPARC, and AMD 29000; and other topics such as Dhrystone,Whetstone, Linpack, and SPEC benchmarks.andM;A &quot;fallacies and pitfalls&quot; section in each chapter offers valuable insights.andO;These nuggets of wisdom point out everything from the mistakes of naiveproject leaders (&quot;ignoring the inexorable progress of hardware when planninga new machine&quot;) to commonly held misbeliefs that the authors refute(&quot;synthetic benchmarks predict performance&quot;).andP;  My favorite among thefallacies they refute is &quot;hardware is always faster than software.&quot;andP;  Anotheris &quot;an architecture with flaws cannot be successful.&quot;andP;  I bet Intel especiallylikes this one, since Patterson and Hennessy kindly use the IBM 360 as thecounterexample.andM;Another section repeated in each chapter is &quot;historical perspectives andreferences.&quot;andP;  The references go well beyond the academic, and are quiterelevant, practical, and complete.andP;  Also interesting are the historicaltidbits.andP;  Did you know that the original IBM 360 architecture included 32-bitaddressing, but that IBM programmers blew it by storing junk in the eighthigh-order bits that were &quot;unused&quot; in early models?andP;  This and many topicswith more significance (such as why a &quot;VAX MIP&quot; is only 0.5 million nativeVAX 11/780 instructions per second) are discussed.andM;About the AuthorsandM;In the early 80s at UC Berkeley, David Patterson led the architecture anddetailed design of the RISC I, probably the first VLSI processor embodyingRISC design principles.andP;  His research produced several generations of RISCsand became the foundation of Sun's SPARC architecture.andP;  Patterson is still aprofessor at UC Berkeley, and also consults for Sun.andM;Also in the early 80s, John Hennessy started the MIPS project at Stanford.andO;Building on his research on optimizing compilers, he showed how to designsimpler, faster, pipelined processors by putting explicit knowledge of thepipeline into the compiler.andP;  Hennessy took a short leave of absence toco-found MIPS Computer Systems; he is still a professor at Stanford, and alsoserves as chief scientist at MIPS.andM;Who is the primary author of this biik?andP;  Both or neither.andP;  Patterson andHennessy say they came up with the book's ideas and organization together,and then individually each wrote half of the chapters.andP;  (To evidence theirequal contributions, the authors decided to alternate the ordering of theirnames in the book and in advertisements!)andP;  The collaboration worked justfine; the book's organization and writing is consistently well done.andP;  Takinga cue from Hennerson and Pattessy's success, perhaps MIPS and Sun could gettogether on their processor architectures to produce the &quot;MIPSPARC&quot;!andM;ConclusionandM;Hennessy and Patterson were assisted by the suggestions, reviews, andhistorical perspectives of more than 100 people, ranging from the best andbrightest new computer researchers in the universities, to the mostexperienced (and famous) architects in industry.andP;  Reading the book's six-pabeacknowledgements section, as well as the main text itself, you really get thefeeling that this is &quot;the voice of the industry&quot; speaking.andM;Every serious computer system designer should own this book.andP;  For anyoneevaluating RISC architectures, Appendix E Alone is worth the price.andP;  I'd goso far as to say, &quot;This is the book you'll wish you had in college,&quot; exceptthat I'm saving that slogan for an advertising campaign for one of my ownbooks...andO;</TEXT></DOC>