<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-265-880  </DOCNO><DOCID>08 265 880.andM;</DOCID><JOURNAL>PC Magazine  April 10 1990 v9 n7 p317(5)* Full Text COPYRIGHT Ziff-Davis Publishing Co. 1990.andM;</JOURNAL><TITLE>Getting acquainted with the latest version of OS/2: 1.2 (part 2).andO;(Power Programming) (column)</TITLE><AUTHOR>Duncan, Ray.andM;</AUTHOR><SUMMARY>The major changes that are incorporated into OS/2 1.2 affect thefile system rather than graphics.andP;  The new version of OS/2introduces a powerful and innovative concept called installablefile systems.andP;  OS/2 1.2 can perform tasks such as filepreallocation, multiple date and time stamps on files anddirectories, installable file systems, free-form filenames,extended attributes, extensive security mechanisms, peer servers,distributed name services and automatic data replication.andP;  WithOS/2 1.2, IBM and Microsoft are obviously setting the stage forobject-oriented file systems, user interfaces, and system-widecontrol of macro languages.andM;</SUMMARY><DESCRIPT>Company:   International Business Machines Corp. (products)Microsoft Corp. (products).andO;Ticker:    IBM; MSFT.andO;Product:   OS-2 1.2 (Operating system) (design and construction).andO;Topic:     Operating SystemsFile ManagementPerformance ImprovementOS-2Tutorial.andO;Feature:   illustrationtablechart.andO;Caption:   OS/2 standard extended attributes. (table)The .TYPE standard extended attributes. (table)The physical structure of an extended attribute. (chart)andM;</DESCRIPT><TEXT>Getting Acquainted with The Latest Version of OS/2: 1.2 (Part 2) Thepioneering OS/2 software developers have had a rough row to hoe.andP;  There havealready been three major releases of the operating system in less than twoyears, and still another is due about the time this column is published.andO;Each new version has required programmers to make drastic changes in theircoding style to take full advantage of the system's capabilities.andP;  The joltshave probably been greatest for developers who learned their trade in DOS butmanaged to ignore Windows.andP;  Yet OS/2 has produced interesting challenges evenfor those with a Unix or Macintosh background.andM;Most OS/2 programmers probably thought the worst was over after they made thetransition to Version 1.1 and the Presentation Manager (PM).andP;  Drasticrestructuring was needed to make applications run cooperatively in anevent-driven environment based on windows, menus, dialog boxes, and messages.andO;That was the price developers had to pay to benefit from the PM'shardware-independent graphical user interface.andP;  Worse yet, programming toolsthat let PM applications be designed and implemented in a natural way weren'teven part of the package.andP;  Instead, prospective programmers were handed a Ccompiler and a three-volume reference for some 900 OS/2 function calls.andM;OS/2 1.2 has now arrived, and it is evident once again that the days ofmarathon coding sessions followed by long nights of debugging are not overfor that dedicated little band of OS/2 developers.andP;  The major changes in 1.2affect the file system rather than graphics, but they are much morechallenging than most of us expected.andP;  The system's new capabilities includefile preallocation, multiple data and time stamps on files and directories,installable file systems, free-form filenames, extended attributes, and (ifthe network is running) extensive security mechanisms, peer servers,distributed name services, and automatic data replication.andP;  Overhaulingapplications to implement these capabilities properly will be no trivialmatter.andM;More important, OS/2 holds harbingers of upheavals yet to come.andP;  It isclear--from the characteristics, generality, and power of the extendedattribute mechanism, for example--That Microsoft and IBM are rapidly layingthe foundation for object-oriented file systems, user interfaces, andsystem-wide control of macro languages.andP;  At this point, when we ponder themutations in the OS/2 API we can see only dimly what Microsoft and IBM planfor the future.andP;  But we can feel pretty confident that OS/2 will continue tobe a moving target for at least several more years.andM;WHAT IS A FILE SYSTEM?andM;File systems are the central issue in OS/2 1.2.andP;  The phrase &quot;file system&quot;itself can be rather confusing, however, for it has two common but distinctlydifferent meanings.andP;  When a physical storage medium is being discussed, thephrase refers to the manner in which data is formatted, organized, andindexed on the medium.andP;  The file system is the sum of the tables,directories, files, and other structures that allow data to be stored andretrieved by name.andP;  The file system also includes the ability to track andallocate the remaining free space on the medium.andP;  The key point is that aphysical file system, often called a &quot;volume,&quot; is both self-consistent andself-sufficient.andM;When file system is used with respect to software, it refers to the module ofthe operating system that translates requests from an application program--toopen, create, read, write, or close a directory or named file--into requeststhat the low-level disk device driver can understand.andP;  That is, thefile-oriented, logical requests are transformed into one or more commands tothe disk driver to read and write specific disk sectors.andP;  The software filesystem performs this translation with the aid of the tables, structures, anddirectories found in the physical file system.andM;So far, we're on pretty familiar ground.andP;  The OS/2 1.2 innovation is apowerful new concept called installable file systems.andP;  In OS/2 1.0 and 1.1(and in nearly every other operating system in existence, for that matter),the software file system was embedded within the operating system kernel.andO;The file system could not be modified or replaced without rebuilding theentire operating system.andP;  In OS/2 1.2, however, file-system code is logicallysegregated from the rest of the kernel code and is interfaced to the kernelthrough a dynamic link interface.andP;  Consequently, the file system can bealtered or replaced as an isolated entity.andP;  Indeed, multiple, dissimilar filesystems can be in use simultaneously!andM;As part of its support for installable file systems, OS/2 1.2 defines a newtype of executable file, called an installable file system driver (FSD).andP;  AnFSD resides on the disk in a file that is structured like a dynamic linklibrary (DLL).andP;  It is in many ways analogous to a device driver.andP;  Typically,it has an .SYS or .IFS extension and is loaded during system initializationby IFS= statements in the CONFIG.SYS file.andP;  IFS= directives are processed inthe order they are encountered and are sensitive to the order of DEVICE=statements for hardware device drivers.andP;  This lets you load a device driverfor a nonstandard device, then load a file system driver from a volume onthat device, and so on.andM;Once an FSD is installed and initialized, the kernel communicates with it interms of logical requests for file opens, reads, writes, seeks, closes, andso on.andP;  The kernel remains oblivious to the physical layout andcharacteristics of the storage medium, just as a properly behaved applicationprogram does.andP;  As we would expect from our general understanding of a filesystem's responsibilities, the FSD translates the logical requests intorequests for sector reads and writes, for which it can call special kernelentry points called File System Helpers (FsHlps).andP;  The kernel passes thedemands for sector I/O to the appropriate device driver and returns theresults to the FSD.andM;Not content with providing only a mechanism for installing new file systems,Microsoft and IBM went on to actually design and implement an installablefile system, known as the High Performance File System (HPFS).andP;  The HPFS'scache strategies, lazy writes, means of data recovery, and use ofsophisticated data structures such as B-trees and B+ trees will be discussedin future columns.andP;  For now, suffice it to say that the HPFS is a watershedin the evolution of microcomputer software.andP;  It represents both a new way oforganizing a physical storage medium for maximum performance and a softwarefile system that uses very trick in the book to minimize CPU demand whilemaximizing throughput.andM;The impact of OS/2's support for installable file systems on applicationprograms is much more far-reaching than it might appear at first glance.andP;  TheOS/2 application program interface (API) represents each file system as asingle set of file manipulation capabilities.andP;  It does so in the form of theentry points for the functions DosOpen, DosChgFilePtr, DosRead, and so on.andP;  Aparticular file system is selected by the application's explicit designationof a logical driver or by its default selection of the &quot;current&quot; drive.andP;  Atthis level, the OS/2 1.2 file system is a superset of the previous versions;all of the API functions from OS/2 1.0 and 1.1 are supported, some of the oldcalls have added functionality, and there are a variety of new function callsto learn.andM;Here's the rub.andP;  At any one time, a running OS/2 1.2 system can have two,three, or even more radically different types of physical file systemsmounted, each controlled by a different software file system.andP;  For example,even at this early stage in the history of installable file systems, myapplication might simultaneously be accessing files on FAT (file allocationtable) diskettes, both FAT and HPFS disk partitions, a CD-ROM, and aLAN--each of which has a vastly different organization, directory structure,and naming and storage conventions and limitations.andP;  In such a situation, thesame API function, called with the same parameters, may behave quitedifferently on different logical units.andM;DOSOPEN AND DATE/TIME STAMPSandM;From the very beginning, OS/2's DosOpen function (which is used both to openand to create files) has had a 32-Bit parameter specified as &quot;initial fileallocation.&quot;andP;  The intent of this parameter is to allow a program to reservecontiguous space for a file when creating it, assuming the program knows howmuch space the file will eventually need.andP;  It's a nice idea, and it couldlargely eliminate the need for disk defragmentation utilities.andM;In OS/2 1.0 and 1.1, which supported only FAT file systems, the space wasindeed allocated, but there was no guarantee that it could be contiguous.andO;Moreover, because there was no room in FAT directory entries to maintain thefile preallocation and actual size separately, a program could peek at thecontents of previously erased files.andP;  It would pull this trick off simply bypreallocating a very large file and then reading in records that it had neverwritten.andM;In OS/2 1.2's HPFS, the DOsOpen preallocation parameter has finally becometruly useful.andP;  First, the HPFS knows how to preallocate files so that theyare maximally contiguous.andP;  It will search for a sufficiently large number ofcontiguous sectors; that failing, it will search for two strings ofcontiguous sectors that are half the size of the requested preallocation, andso on.andP;  Second, the HPFS can keep track of file size and file preallocationseparately.andP;  It maintains a &quot;high-water&quot; mark for write operations to thefile and returns zeros when a program attempts to read a record that hasnever been written.andM;Again, from the earliest versions, the OS/2 API has also allowed for threedate-and-time stamps on each file: creation, last access,and lastmodification.andP;  Since FAT directories didn't have room for more than one dateand time per file, however, only the date and time of the last modificationwere actually stored; the remaining capability went unused.andP;  The creation andlast-access dates and times were undefined on a &quot;get&quot; function and wererequired to be 0 on a &quot;set&quot; function.andP;  Files stored in an HPFS, on the otherhand, can make full use of the triple date-and-time stamp capability.andP;  Otherstorage media types (such as Unix) can also make use of all three dates andtimes.andM;LONG FILENAMESandM;OS/21.0 and 1.1 supported filenames only in the historic 8.3 format--eightcharacters for the filename and three characters for the extension, with twocomponents separated by an implicit dot delimieter (the dots were notactually stored in the directory entries).andP;  This severely limited format waspreserved for historical reasons and because the previous versions of OS/2supported only the DOS-style FAT.andM;In OS/2 1.2, however, the traditional filename limitations found in DOS andearlier versions of the OS/2 environment have been removed.andP;  In general, thefile API functions in OS/2 1.2 support long, free-form filenames withembedded spaces, mixed case, and multiple dot (.) delimiters.andP;  Because of theinstallable file system capability, however, naming limitations may vary fromone logical drive to another.andP;  A FAT volume on an OS/2 1.2 system, forexample, still has the same old 8.3 naming limitations, while an HPFS volumeallows filenames up to 254 characters long.andP;  CD-ROM and Unix storage mediamay have restrictions that are altogether different.andM;An environment in which naming restrictions are not homogeneous across allstorage volumes is going to present some interesting new problems forapplication developers.andP;  A truly friendly application program will have totake an unprecedented amount of responsibility as it screens and processesfilenames entered by the user.andM;Imagine, for example, that the user, after entering data for a while, selects&quot;Save As .andP;  .  .&quot; and specifies a 20-character name for storage on an HPFSvolume.andP;  Naturally, the file-save operation is successful, and he continueswith his work.andP;  After typing in a few more lines, however, he decides to savethe file to a different volume, one that happens to be a FAT diskette.andP;  Thename is now illegal, but what is the most appropriate response by theapplication?andM;Bear in mind that most users won't have the vaguest notion of why the longname in valid on one volume and an error on another volume.andP;  Nor will theyappreciate their file having two different names on different drives.andO;Furthermore, they will probably insist that the original long name shouldstill be kept around somewhere, just in case the file is eventually copied toyet another volume that can handle the full name.andM;EXTENDED ATTRIBUTESandM;In OS/2 1.2, file attributes are information about a file that is maintainedby the operating system outside the file's storage area.andP;  This information isnormally accessible by applications with open, read, and write operations.andO;The simple attributes supported in FAT file systems--and thus in OS/2 1.0 and1.1 and in all versions of DOS--are very different; they have a lineage thatgoes back to Digital Research's CP/M operating system and before.andP;  These&quot;attributes&quot; are essentially bit flags, stored in each file's directoryentry, that indicate whether the file is hidden, system, read-only, orarchived.andP;  The DOS-style file attributes are inspected or modified by specialfunction calls and are not accessible through the normal file open, read, andwrite calls.andM;For the sake of upward compatibility, OS/2 1.2 still supports the attributesof the FAT file system.andP;  But Version 1.2 also supports a new form offile-associated highly generalized information called Extended Attributes(EAs).andP;  Each EA is conceptually similar to an environment variable.andP;  It takesthe formandM;name=valueandM;except the value portion can be either a null-terminated (ASCIIZ) string,binary data, or both.andP;  Each file or directory can have as much as 64K of EAsattached to it--an upper limit that may be lifted still higher in a laterrelease of OS/2.andM;The OS/2 kernel provides functions to query, add, and change the EAsassociated with files or directories, but it does not inspect the contents ofEAs or take any action on their &quot;values.&quot;andP;  The interpretation of the namesand values of EAs is thus strictly within the province of the system'sshells, utilities, and application programs.andP;  In theory, software developersare free to use EAs in any manner and for any purpose they can dream up.andP;  Tokeep the EA situation from degenerating into total chaos, however, Microsoftand IBM have established a few simple EA guidelines.andM;EA mnames that begin with the characters., $, @, andamp;, and + are reserved to thedesigners of the operating system.andP;  EA names beginning with a period (.) areknown as &quot;standard EAs&quot; (SEAs), and a number of these have already beenpredefined for communication among the PM shell, PM File Manager, andapplications.andP;  The names of the SEAs that either are documented in thepreliminary OS/2 1.2 toolkit or are visible by poking around in the systemappear in Figure 1.andP;  The names of application-specific EAs should be prefixedby the names of the software vendor and the application; for instance: MSEXCEL.WKSHT VERSION.andM;For data files, the most important SEAs are .TYPE and .ICON.andP;  These describea file's contents and provide an icon for display by the File Manager,respectively.andP;  The use of .TYPE EAs is intended to replace the old conventionof &quot;typing&quot; a file by its filename extension.andP;  It relieves the user of theresponsibility for remembering the proper extension, allows him additionallatitude in file naming, and eliminates the probelm that arises whenapplications from different vendors use the same extension for files withdifferent internal formats.andP;  Microsoft and IBM have predefined a fairly longlist of generic .TYPE values, which are shown in Figure 2.andO;Application-specific .TYPE values can also be used, but these should bedifferentiated from the system's generic .TYPEs by including the names of thesoftware vendor and the program.andP;  For example, Microsoft Excel might assign.TYPE EAs to its data files using the values &quot;Microsoft Excel Wroksheet&quot; or&quot;Microsoft Excel Chart&quot;.andM;The other standard EAs (.HISTORY, .SUBJECT, .KEYPHRASES, and so on) areprimarily intended for use by future file browsers and as documentation aids.andO;The maintenance of standard EAs attached to data files is the responsibilityof all application programs that create and access those files, but most ofthe standard EAs can be modified directly by the user with the aid of theFile Manager's Properties dialog or with the EAUTIL utility.andM;For executable programs, the most important EAs are .ICON, .APPTYPE, and.ASSOCTABLE.andP;  The .andP;  ICON EA provides an icon for use by the PM Shell in theProgram Starter menu when the program's window is minimized or when it isrunning in a background screen group.andP;  The .ICON EA overrides any icon datathat might be present as a program &quot;resource&quot; or might be contained in a filewith an .ICO extension.andP;  The .APPTYPE EA contains the same information foundin the &quot;application type&quot; field of the &quot;new EXE&quot; file header.andP;  That is, itindicates whether the program is a true PM app or windowable, nonwindowablefull-screen, or real-mode only.andM;The .ASSOCTABLE EA is particularly interesting, because it provides the firstglimmerings of Microsoft support for an object-oriented user interface.andP;  The.ASSOCTABLE EA is in the multi-item, multivalue EA class.andP;  It lists the .TYPEEA &quot;values&quot; and filename extensions for data files that the application&quot;owns&quot; and for other files that the application program does not &quot;own&quot; butknows how to process.andP;  This EA can also contain icon data for the &quot;owned&quot;data files.andP;  Unlike other EAs, the .ASSOCTABLE EA is defined by a series ofstatements in a resource source file, in much the same manner as diaglogboxes, menus, and string tables.andP;  It is bound to the executable program bythe resource compiler utility (RC.EXE).andM;Here's how the .ASSOCTABLE EA is used.andP;  Each time the PM shell accesses anexecutable file, it looks for the .ASSOCTABLE EA.andP;  If the EA is found, theinformation in the EA is added to a global table of executable programs,associated data file types, and data file icons that is stored in OS2.INI.andO;When the File Manager is invoked, it retrieves this table from OS2.INI anduses it in two ways.andM;First, the File Manager relie on the .ASSOCTABLE information collected inOS2.INI as part of its icon display strategy.andP;  In the case of a data file,the File Manager first looks for a .ICON EA attached directly to the file anduses that icon data if it exists.andP;  If the data file does not have its own.ICON EA, the File Manager then looks in OS2.INI to see if any applicationclaiming to own the data file type has supplied an icon for that type.andP;  Ifthe File Manager can't come up with an icon for the data file by either ofthese methods, it substitutes a &quot;generic&quot; data icon.andM;Second, the file Manager exploits the collected .ASSOCTABLE information toimplement an &quot;automatic application launch&quot; facility similar to one found inthe Macintosh Finder.andP;  If the user double-clicks on a data file's name oricon, the File Manager searches OS2.INI for the name of the first programclaiming ownership of files with a matching.andP;  TYPE EA or--if the data filedoesn't have any EAs--a matching filename extension.andP;  If such a program isfound, it is executed and passed the name of the data file.andP;  If no &quot;owner&quot;application program is identified, then the File Manager looks in OS2.INI forall programs that know how to process files with the same .TYPE EA orextension.andP;  The File Manager then presents the user with a list of theseprograms, leaving it to the user to choose one of the programs for executionor cancel the whole operation.andM;BINARY FORMAT OF EAsandM;While EAs are conceptually similar to environment strings, their physicalrepresentation is completely different.andP;  The fundamental structure of an EAis shown in Figure 3.andP;  It consists of a flags byte, the 8-bit length of theASCIIZ name (not including the terminal null), the 16-bit length of thevalue, the ASCIIZ EA name itself, and lastly the EA value.andP;  At the currenttime, only bit 7 of the flags byte is significant; it is set (1) for a&quot;critical EA&quot; and cleared (0) otherwise.andP;  (&quot;Old&quot; applications are not allowedaccess to files with critical EAs; we'll discuss this issue in more detailnext time.)andM;The EA value typically consists of a number of fields.andP;  By convention, all EAvalues begin with a 16-bit type indicator as listed in Figure 4.andP;  Forsingle-valued EAs, the type word is followed by a 16-bit length and then bythe actual binary or ASCII data that is meaningful at the application programlevel.andP;  Naturally, multivalued EAs are considerably more complex, but theyessentially use the formats of the single-valued EAs as building blocks.andP;  Byway of illustration, Figure 5 shows the .TYPE EA that the Icon Editorattaches to .ICO files it creates or modifies.andM;In the next installment, I'll discuss the new API functions that allowinspecting or manipulating EAs, and I'll provide some guidelines for usingEAs in your own application programs.andM;THE IN-BOXandM;Please send your questions, comments, and suggestions to me at any of thefollowing e-mail addresses:andM;PC MagNet: 72241, 52 MCI Mail: rduncan BIX: rduncan</TEXT></DOC>