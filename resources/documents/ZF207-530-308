<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-530-308  </DOCNO><DOCID>07 530 308.andM;</DOCID><JOURNAL>Microprocessor Report  August 1989 v3 n8 p10(4)* Full Text COPYRIGHT MicroDesign Resources Inc. 1989.andM;</JOURNAL><TITLE>Guidelines for 486 software design. (microprogramming Intel 80486chips)</TITLE><AUTHOR>Wharton, John H.andM;</AUTHOR><DESCRIPT>Product:   Intel 80486 (Microprocessor) (usage).andO;Topic:     MicroprogrammingTutorialCompatibilitySoftware MigrationCircuit DesignGuidelines.andO;Feature:   illustrationtable.andO;Caption:   486 instruction set additions. (table)andM;</DESCRIPT><TEXT>In previous articles, we've given an overview of the Intel 486 architectureand implementation, how its bus interface works, and details of its internalexecution pipelines (see Microprocessor 4/89, 5/89, and 6/89).andP;  This articlecovers two key programming concerns:compatibility and portability among 80x86family members, and code generation techniques for optimum performance.andM;Software Compatibility The issue of software compatibility involves threemigration paths of interest:andM;* Executing existing 8088/86 or 286 programs onandM;a 486-based systemandM;* Porting 386 software to the 486andM;* Downward migration of 486 code to 386 CPU's Each path is discussed below.andO;The latter two have been split according to whether the migrating softwareinvolves just user-mode application programs, or supervisor-mode operatingsystem software as well.andM;Other possible migration paths are of lesser interest.andP;  Execution of 486software on an 8088/86 or 286 would be pointless; performance would drop byorders of magnitude.andP;  It is also technically infeasible.andP;  The earlier devicessupport only a reduced-width subset of the 486 CPU registers, and have nohooks for detecting and trapping the new opcodes, addressing modes, andextended arithmetic precision of the basic 386 architecWre.andP;  Code for the 286can run on a 386, but - OS/2 notwithstanding - too little 286-specificsoftware exists for this migration path to be significant.andM;Executing 8088/86 SoftwareandM;The first migration path is a breeze.andP;  The 486 handles 8086 code quitenicely.andP;  The chief concern of the 486 designers was compatibility with DOSsoftware.andP;  This point was made repeatedly by 486 press releases, brochures,and other introductory materials.andP;  Intel says PC users have spent $15 zillionon DOS applications software.andP;  At the 486 roH-out in Chicago, the strongest(and essentially the only) point made by the introductory video was that the486 would preserve this investment.andM;On reset, the 486 defaults to &quot;real mode&quot; operation, which is directlycompatible with the original 8088/86 architecture.andP;  The instruction set,instruction semantics, register size, arithmetic precision, addressing modes,logical address space, segmentation scheme, and so for all work as before.andP;  A486-based system with peripheral hardware comparable to the PC/XT could (intheory) boot itself from the original BIOS PROMs, load standard PC-DOS, andrun good old Wordstar.andM;Pure virgin 8086 code would waste 486 resources, of course: addressabilitywould be limited to the standard DOS 640 Kbytes, and without newinitialization code the on-chip cache would remaindisabled.andP;  Even so,performance would be enhanced considerably.andP;  Speeddependent applicationprograms - those that contain software delay loops - may need to be adjustedto compensate for the higher instruction execution rate, but the vastmajority of existing commercial application programs would require nosoftware changes.andM;Operating system or BIOS software would normally use real mode only toconfigure system hardware, initialize system data structures, enable thecache, and tben switch the 486 into &quot;native mode&quot; to allow 32-bit operations,virtual memory management, and interprocess protection mechanisms.andM;At that point the 486 (like the 386) supports a far more flexible form of8088/86 software emulation.andP;  A task may be dispatched by the operating systemto run in &quot;virtual 8086 mode.&quot; This re-establishes an environment in whichthe processor behaves like an 8088/86.andP;  Virtual memory translation and pagingare still in effect, so each virtual-8086-mode program may be assigned itsown local address space anywhere within the 4-gigabyte physical addressspace.andP;  The OS may allocate a full megabyte of physical memory to eachvirtual8086-mode task, or may assign it a much smaller area and swap datainto physical memory pages as needed.andM;An arbitrary number of tasks can thus execute simultaneously in a 486microprocessor-based system, some in virtual 8086 mode, others in nativemode.andP;  With each assigned its own memory region, each is protected from thecorrupting influences of the others.andP;  The processor reenters the native,32-bit protected mode when a task signals an exception or when a hardware orsoftware interrupt occurs.andP;  Execution returns to virtual 8086 mode when theexception handler routine is done.andM;The 486 in real mode or virtual 86 mode will properly execute new instructionprefixes and opcodes not defined by the 8088, so old programs can be patchedto perform 32-bit math and 4-gigabyte addressing.andP;  An actual 8088, on theother hand, would interpret the new opcodes differently, perhaps erratically.andO;This doesn't imply incompatibility: existing 8088 programs would not containthese instructions, and iVs okay if buggy programs fail differently ondifferent CPUs.andM;Porting 386 Applications to the 486andM;This path, too, is trivial.andP;  All resources visible to usermode 386 programs,including those within the 387 math coprocessor, are dircetly supported by486 hardware.andP;  Tbe proof of the pudding will be actually to see AutoCAD/386,Paradox/386, Windows/386, and so forth running on 486 boxes, but until thenwe must assume they will.andP;  With Intel this strongly committed tocompatibility, any significant problems that might crop up will have to befixed in later chip steppings.andM;Downward Migration of 486 ApplicationsandM;Newly developed application programs for the 486 should, for the most part,port gracefully back to the 386 world.andP;  Registers new to the 486 are hiddenfrom user-mode programs, and won't be a factor.andP;  The chief concern would besix new instructions added to the 486 instruction set.andP;  Three work only insystem mode, and won't affect user-mode applications.andP;  The rest, whichfacilitate interprocessor communication s in multiprocessing applications,may be troublesome.andM;Most general-purpose applications have no occasion to manipulate processsemaphores.andP;  Intel recommends that application programs that do usesemaphores or access shared data bases should be designed not to execute thenew instructions directly.andP;  Instead, such programs should call run-timesupport routines consisting of individual 486 opcodes or 386 instructionsequences, depending on the host CPU.andP;  (The same trick is sometimes used toconfigure floating-point software.)andM;Still, the possibility exists that otherwise-valid 386 programs could containthe new 486 opcodes.andP;  Even then, there is an acceptable fix.andP;  The 386 isdesigned to trap whenever it encounters an undefined opcode.andP;  Trap handlerroutines within future 386 operating systems could detect the special casesrepresented by the new 486 opcodes, and dispatch 386 instructionsequences toemulate the corresponding operation.andP;  Execution speed would suffer, sincegetting in and out of trap handlers involves considerable overbead, but atleast the software could still run.andM;Porting 386 Operating Systems to the 486andM;Compatibility of OS code is slightly less straightforward.andP;  The 486implements several new control bits that are undefined by the 386 controlregisters and memoryresident page descriptor tables.andP;  For example, controlregister CRO in the 486 contains several new bits.andP;  Control software mustinitialize two of the bits before the on-board cache can work.andO;Memory-management software must also initialize bits within register CR3 andthe page directory and page table entries to define the cacheabilitycharacteristics of external memory.andM;In theory, these changes were supposed to be compatible with existing OScode.andP;  For some time the 386 data sheet has warned OS programmers toinitialize register fields with zeroes; thereafter &quot;registers...may bereloaded&quot; with previously-saved values.andP;  Unfortunately, the warning isambiguous: the word &quot;may&quot; should have been &quot;must.andP;  &quot;andM;Whatever the warnings meant to imply, it was a bad assumption that existingsoftware would faithfully preserve all configuration and status flags.andP;  Infact, many 386 programs rewrite the control registers quite regularly, andgenerally dear the undefined bits when they do.andP;  On the first 486 devicestepping, this disabled cache fills and write-throughs, resulting indisappointingly poor performance and occasional program malfunction s.andO;(Existing software also clears the page descriptor flags, but here a zeroentry leaves the cache enabled.)andM;A hardware fix for the cache problem is currently underway.andP;  On futuresteppings the logical sense of CRO control bits CE (cache enable) and WT(write-through) will be reversed.andP;  Henceforth these bits will be designatedCD (cache disable) and NW (not write-through).andP;  Both will default to ones onreset, and must now be cleared for the cache to work.andP;  386 programs thatimproperly clear these bits will continue to work properly, but fifteenthousand 486 data sheets are now obsolete.andM;Even with the hardware changes, OS vendors are advised to re-examine all codethat references or manipulates the augmented 486 resources, and make sure bitstates are preserved as per current Intel guidelines.andP;  Fortunately, programfragments that may need review and correction should be relatively isolatedand easy to find.andP;  Instructions that may corrupt system resources can occuronly within the OS code.andP;  Potentially eff ant instructions can be found bysearching source files for the mnemonics of the affected registers.andP;  (Whenseveral OS vendors received first samples of 486 silicon, it appeared theparts didn't work.andP;  Intel suggested they double-check portions of the programthat maintained configuration flags.andP;  The vendors were then able to bring uphand-patched versions of the OS within hours.)andM;Downward Migration of 486 OSsandM;The presence of new control bits in the 486 might seem to preclude runningidentical copies of OS software on both CPUs.andP;  Not true, at least not from atechnical standpoint.andP;  It turns out the 486 control flags that were undefinedby the 386 architecture were unimplemented by the 386 device as well.andO;Operating system software may configure the cache control bits in CRO and thecacheability flags in the descriptor table however it wishes, withoutaffecting 386 operation.andP;  The extra instructions that preserve and restorethese flags across a 486 context switch execute safely on the 386 as well,and the performance degradation resulting from the extra instructions wouldbe negligible.andM;However, there are still the three new system-level instructions to contendwith.andP;  Two of these invalidate (flush) internal and external cache datavalues; tbe third invalidates cached TLB entries.andP;  Also, two new testregisters let the cache and TLB logic be tested and exercised under softwarecontrol.andP;  OS code that includes these instructions or references theseregisters will befuddle a 386 CPU.andM;Aside from initial system hardware verification, ivs not clear how thesefacilities would ever be used by an OS; chip designers concede the newinstructions were included &quot;just to be safe.&quot; Nevertheless, if a genericoperating system needs to flush tbe cache, for example, it may first examinethe CPU configuration registers, determine whether it is running on a 386 or486, and execute only the instructions appropriate for that CPU.andM;The ability of software to determine the CPU type could open the door tounified OS and application code, and let vendors sell shrink-wrapped softwarecompatible with either chip.andP;  Ironically, it could also do the opposite.andO;Vendors could market a slightly different program for each CPU.andP;  The cheaperversion, targeted strictly for 386 systems, could include extra codeartificially to prevent execution on 486 machines.andP;  Aversion configured for486s could then cost extra, and could contain tests to preclude 386 usage.andM;Software OptimizationandM;The second concern of the 486 designers, after DOS compatibility, wasperformance.andP;  In discussing performance optimization strategies, though, it'suseful to draw a contrast between the 486 approach and that of recentlyannounced RISC processors.andM;With most RISC architectures, software performance is strongly dependent onhow well it has been optimized.andP;  Simple, straight-forward code emitted by anon-optimized compiler or a human programmer does not exploit a RISCmachine's full potential.andP;  Major instruction rearrangement is needed to filloperand load-, store-, and branch-delay slots.andP;  Still further rearrangementmay reduce pipeline stalls and resource collisions.andP;  Through suchstate-of-the-art optimization techniques as loop unrolling, in-line codereplacement, and global register coloring, truly excellent RISC compilers canperhaps double the performance of unoptimized code.andM;The 486 designers couldn't &quot;Relegate the Impossible Stuff to Compilers,&quot; norcould they sacrifice binary compatibility.andP;  The multi-zillion-dollar pool ofexisting 8088 software had already been shipped.andP;  Intel could not askprogrammers retroactively to advance operand load instructions or fill branchdelay slots.andP;  Instead, the 486 designers concentrated on acceleratingisolated instructions and reducing instruction interactions (see ILPR6/89 p.andO;13 for pipeline details).andP;  Execution inefficiencies that do occur aregenerally because a particularly inopportune instruction pairing stalls thepipeline while the instructions vie for a shared resource.andM;Thus, optimization techniques for the 486 are not nearly as critical toperformance as those for RISC machines.andP;  Put another way, even bad 486 coderuns 80%-90% as fast as the best-tweaked version of the same routine.andP;  In thedog-eat-dog world of workstation marketing, though, the last 10% is critical,so Intel has prepared alist of instructions and instruction combinations forprogrammers and compilers to avoid.andM;The following sections summarize these situations.andP;  Fortunately, each of thehazards lends itself to local (&quot;Peep-hole&quot;) detection, and the recommendedsubstitutions should be simple to incorporate into future compilers.andP;  Foradditional details concerning code optimization consult Intel's i486Microprocessor Programmer's Reference Manual, due out soon.andM;Select the Faster InstructionsandM;Sometimes an operation can be done in different ways.andP;  For example,register-indirect and simple indexed addressing do tbe same thing, but thelatter always takes one extra clock.andP;  Use base addressing for the best speed.andM;Not all instructions received as much attention from 486 designers as didloads, stores, and common ALU operations.andP;  In several cases, a single,complex instruction takes longer to execute than a sequence of simpler,optimized instructions that do the same thing.andP;  For example, a specialinstruction can push a memorybased operand onto the stack in four clockcycles, but a sequence to load the operand into a register and then push theregister takes just two clocks total.andP;  The 486 also has special instructionsthat adjust the frame and stack pointer registers on entering (ten clocks) orleaving (five clocks) a subroutine.andP;  In each case a series of discreteinstructions with the same net effect consumes three fewer clocks.andP;  Stringinstructions are also faster it done in separate steps.andM;Coincidentally (or perhaps not, many of the less efficient instruction formswere added by the 286 and 386 architectures.andP;  Thus, existing 8088/86 programsare less affected by the extra cycles.andM;Watch Outfor Address Generation StallsandM;The timing of the 486 pipeline is such that a memory reference instructionmust begin its address computation before the previous instruction hasfinished computing its result.andP;  If an address calculation uses a baseregister modified by the preceding instruction, the calculation must stalluntil th e new value is known.andM;A bypass gate from the ALU to the segmentation unit reduces this stall to onecycle.andP;  To avoid tbe stall entirely, programs should avoid updating a baseregister immediately before it is used by rearranging the instructionsequence to interpose an unrelated instruction.andP;  At times, base registerusage is implicit.andP;  For example, the stack pointer should be reloaded orrestored at least one instruction before a pop or return.andP;  As a special case,back-to-back pushes or pops do not stall the pipe: special logic incrementsor decrements the stack pointer through a dedicated register port one clockearlier than the standard execution pipeline.andM;Leave the Prefetcher Room to BreatheandM;Undernormal conditions, instruction prefetch logic will initiate a new16-byte cache request several clocks before the new instruction code isneeded, while the prefetch queue still contains several unprocessedinstructions.andP;  If the ALU requests cached data simultaneously, the prefetchcycle is deferred until the cache would otherwise be idle.andP;  A sequence ofconsecutive load instructions could keep the cache busy continuously; intime, the prefetch queue would run dry, force a prefetch, and stall the ALUuntil the prefetch is done.andP;  To avoid th is delay, don't fill an entire16-byte paragraph of the instruction space with single-clock loads.andM;Avoid Worst-Case Instruction AlignmentandM;When the target of a jump or call instruction is fetched, its entire opcodefield (up to three bytes) must be retrieved before the instruction decodingcan begin.andP;  If the opcode field crosses a 16-byte cache line, two successivecache cycles must occur, consuming a total of three clock cycles.andP;  Ifexternal fetch cycles must be performed, a badly aligned multibyte opcodewill take up to nine clock cycles to retrieve, plus five sets of memorywait-states.andM;Code generators should take into account the alignment effects ofinstructions that are likely targets of program redirection.andP;  (Note that thisincludes any instruction after a call.) To minimize instruction bus trafficon entry, and to use the burst-mode wrap-around sequence to best effect,align subroutines to begin at 16-byte boundaries.andP;  Alignment is less criticalfor branch targets, since cache hits are much more likely within a loop, butit is still best for the opcode field of a branch target instruction not tocross cache lines.andM;Pick the Best NOPandM;When shifting the position of an instruction within a subroutine body, avoidpadding the program with a series of simple NOPs.andP;  The NOP mnemonic maps ontothe single-byte opcode for the &quot;XCHG AXAY instruction.andP;  This instructionoriginally took a relatively slow three clocks (see the special April 1supplement, PPR, 4/89), but will decrease to a single clock cycle as part ofthe next-stepping redesign.andP;  There are also a variety of single-cyclemultibyte instructions that effectively do nothing.andP;  A series of single-byteNOPs could be replaced with one of these instructions for greater speed.andM;One of the more arcane features of the 486 instruction encoding scheme isthat often an operation can be encoded in several different ways, each with adifferent length, that take the same amount of time.andP;  Instructions cansometimes be aligned for free (time-wise) by expan ding precedinginstructions into a less-dense form.andM;(An amusing though perhaps apocryphal anecdote concerns one compiler vendor'searly attempts to optimize code for the 486 by focusing on the code alignmentissue.andP;  They reworked their code generator to align all potential branchtargets to 16-byte boundaries, simply by inserting NOPs as needed.andP;  This tookon average eight one-byte NOPs, and added 24 clock cycles to programexecution time, by far outweighing all other gains.andP;  The &quot;optimized&quot; codeperformed abysmally.)andM;Optimization Effects on 386 SpeedandM;The above 486 optimization s should generally have very little effect on 386programs.andP;  Base-register and simple indexed addressing are equally fast onthe 386.andP;  Execution time for the 386 CPU is independent of instruction order,so separating base register update instructions from dependent memoryreferences would not affect 386 performance.andP;  Neither would the reordering ofinstructions that might starvet be 486 prefetcher.andM;Other 486 optimizations could actually help 386 speed.andP;  Aligning code on16-byte boundaries would reduce 386 instruction fetch bandwidth as well, butno more so than alignment along any other four-byte boundary.andP;  Thesingle-byte NOP is also relatively inefficient on the 386, and shouldlikewise be avoided.andP;  Because of this, Intel is encouraging compiler vendorssimply to target all code for the 486 whatever the CPU; Intel fears a 386/486optimization mode switch might cloud the family-compatibility message.andM;Yet some 486 enhancements degrade 386 operation, albeit slightly.andP;  Thespecial instructions to push memory, enter and leave subroutines, and performstring operations are faster on a 386 than those they replace - that's whytheyre there.andP;  Replacing individual opcodes with multi-instruction sequencesor padding instructions to align with memory boundaries cannot help butincrease code size.andP;  On the (uncached) 386, this too would hinderperformance.andM;Perhaps new compilers will adjust for CPU type indirectly, as part of otheroptimization options.andP;  Most compilers can already optimize a module eitherfor size or for speed; it would not be unreasonable for the high-densityoption to favor constructs that help the 386, while the high-speed optionwould be tailored for the 486.andO;</TEXT></DOC>