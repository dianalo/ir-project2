<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-002-878  </DOCNO><DOCID>08 002 878.andM;</DOCID><JOURNAL>AI Expert  Jan 1990 v5 n1 p5(2)* Full Text COPYRIGHT Miller Freeman Publications 1990.andM;</JOURNAL><TITLE>A meeting of minds. (artificial-intelligence languages)(editorial)</TITLE><AUTHOR>Chapnick, Philip.andM;</AUTHOR><DESCRIPT>Topic:     Artificial IntelligenceProgramming LanguagesNonprocedural LanguagesLISPPROLOGProgram Development Techniques.andM;</DESCRIPT><TEXT>A Meeting of MindsandM;It's more than a historical accident that LISP and PROLOG are the languagesmost closely associated with AI.andP;  LISP, invented in the 1950s by JohnMcCarthy at Stanford University, is one of the oldest high-level languagesaround.andP;  PROLOG is of more recent vintage, invented in the late 1970s byAlain Colmerauer and his group in France.andP;  LISP's interpretive nature andpowerful extensibility rapidly earned the favor of AI researchers buildingwhat eventually became large, complex, poorly specifiable programs.andP;  PROLOGwas more explicitly invented as a symbolic-manipulation language based onlogic.andP;  Much of its presence in the United States, where it has always playedsecond fiddle to LISP (the not-invented-here syndrome?), was generated byBorland's introduction of Turbo PROLOG at $99 and the highly publicizedJapanese decision to use PROLOG as the language of the fifth-generationproject.andM;At their foundations, LISP and PROLOG are computationally equivalent to eachother and any other robust programming language.andP;  In fact, you can prove theyare both equivalent to a universe of incredibly simple cellular automata asper John Conway's game of life.andP;  (Perhaps, but I wouldn't want to build anatural-language parser or an accounting system by positioning glider guns ona monstrous, two-dimensional universe of simple cellular automata.)andM;However, though the computational scope of these languages is basically thesame, their practical reach may be quite different.andP;  For people there areintimate connections between language and thought, whether the language benatural or artificial.andP;  The structure of a language affects the ease withwhich various problems can be represented and the way a problem isconceptualized and ultimately solved.andP;  For instance, dynamic problems can beexpressed using either Polar or Cartesian coordinates; mathematically precisemappings can be defined between the two systems with relative ease.andP;  Yetproblems involving rotational dynamics are more simply expressed, and solved,using Polar coordinates than Cartesian ones.andP;  Of course, skilled programmerscan accomplish an astonishingly wide variety of tasks using many differentlanguages: object-oriented simulations have been written in assembly languageand expert-systems shells in COBOL.andP;  Nevertheless, the fact that symboliclanguages make certain types of representations more natural is an importantfactor in their success in AI-oriented domains requiring reasoning, judgmentand heuristic problem solving.andM;What sets LISP and PROLOG apart from mainstream languages like C, Pascal, andCOBOL is that both use declarative rather than procedural constructs as thebasic paradigm of program construction.andP;  Both are denotational languages: the output results are specified directly in terms of the inputs.andP;  Thisfeature contrasts with operational languages in which a sequence ofoperations is explicitly specified to compute the output.andP;  This distinctionbetween the declarative and procedural programming styles is what makes LISPand PROLOG difficult for programmers who learned their trade using procedurallanguages.andM;When you learn a foreign language you tend to translate it mentally into yournative language; the same is true of programming languages.andP;  Novice LISP orPROLOG programmers tend to write highly procedural code at first; learning tothink declaratively takes diligent practice.andP;  This shift from a procedural toa declarative approach requires a corresponding shift in the programmer'smindset.andM;What distinguishes LISP from PROLOG is that LISP is based on the concept offunction while PROLOG is based on the concept of relation.andP;  A LISP programtakes a list of arguments to a funtion, evaluates the function, and returnsits value.andP;  A PROLOG program instantiates variables contained in relations toprove a goal statement.andP;  Functional programs must carefully distinguishbetween the input (arguments) and the output (value of the function given thearguments).andP;  PROLOG does not use this distinction; given any part of arelation it can compute an answer.andP;  A PROLOG program is a set of axioms andfacts, and a PROLOG computation is a proof of the goal statement from thoseaxioms and facts.andM;If you listen carefully you can still hear sanctimonious LISP vs.andP;  PROLOGdebates at AI conferences.andP;  Although language xenophobes may like to spendtheir time on this false dichotomy, each language has its strengths andweaknesses.andP;  The ability to build high-level functions easily fromlower-level ones makes LISP powerful; PROLOG's simple way of handlingrecursion and its input and output symmetry allow for very compact programstatements.andP;  According to Robert Mueller and Rex Page, authors of SymbolicComputing with LISP and PROLOG (John Wiley and Sons, 1988): &quot;No one yet knowswhich system, functional programming or relational programming, presentsgreater advantages.andP;  History favors less computationally specific languagesas eventual winners in computational speed as well as expressive power.andO;Because LISP and PROLOg both have advantages of this kind that the otherlanguage lacks, it seems reasonable to guess that some combination of theideas of both languages will find their way into the denotational programminglanguages of the future.&quot;andM;If you're interested in computability theory and computational complexity,Gregory Chaitin's Algorithmic Information Theory (Cambridge University Press,1987) belongs on your bookshelf.andP;  It will be especially interesting to LISPfans because Chaiton believes that &quot;Pure LISP is in precisely the same rolein computational mathematics that set theory is in theoretical mathematics,in that it provides a beautifully elegant and extremely powerful formalism,which enables concepts such as that of numbers and and functions to bedefined from a handful of more primitive notions.&quot;andM;Chaitin develops a pure form of LISP and uses it to create and prove anexplicitly computational, and very strong, version of Godel's incompletenesstheorem: &quot;My hope is that this monograph will convince mathematicians thatrandomness and unpredictability not only occur in nonlinear dynamics andquantum mechanics, but even in rather elementary branches of numbertheory....In conclusion, we see that proving whether particular exponentialdiophantine equations have finitely or infinitely many solutions isabsolutely intractable.andP;  Such questions escape the power of mathematicalreasoning.andP;  This is a region in which mathematical truth has no discerniblestructure or pattern and appears to be completely random.andP;  These questionsare completely beyond the power of human reasoning.&quot;andO;</TEXT></DOC>