<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-486-466  </DOCNO><DOCID>07 486 466.andM;</DOCID><JOURNAL>Data Based Advisor  August 1989 v7 n8 p18(3)* Full Text COPYRIGHT Data Based Solutions 1989.andM;</JOURNAL><TITLE>Smooth intrusions. (Revelation Expert) (column)</TITLE><AUTHOR>Gunther, John.andM;</AUTHOR><SUMMARY>Advanced Revelation (AR) offers a powerful facility for leaving acurrent operation, executing another task, and returning to theoriginal one.andP;  This 'recursive re-entrancy' can be utilized inseveral ways: in RBASIC programs, through the use of EXECUTE andPERFORM commands, and the CATALYST subroutine offers CODE ANDCOMMAND facilities to enable such AR tools as WINDOW and MENU tointerrupt current operations and execute others.andP;  Details of theuse of these commands are described.andP;  Instructions and code forautomatically generating RBASIC EQU records are also provided.andM;</SUMMARY><DESCRIPT>Product:   Advanced Revelation (Data base management system) (computerprograms).andO;Topic:     TutorialProgramming InstructionRelational DBMSBASICSubroutinesInterrupt Handling.andO;Feature:   illustrationprogram.andO;Caption:   Subroutine used to sort field list in Revelation. (program)andM;</DESCRIPT><TEXT>Smooth IntrusionsandM;Let's tie up one of the loose ends I left lying about.andP;  In October, I talkedabout one of AREV's most advanced and unusual features: its ability tointerrupt a current operation and perform any other task before going back tothe original one.andP;  &quot;Recursive re-entrancy,&quot; is its technical name.andP;  Almost noother application program or environment provides this, and most operatingsystems haven't gotten there yet.andM;I'll call it &quot;Level switching,&quot; to give it a simpler name.andP;  This feature isso great that, as comedian Soupy Sales would say, &quot;it makes your brains fallout.&quot;andP;  The authors of AREV, knowing a good thing when they design it, builtin a number of ways to take advantage of level switching.andP;  The fundamentalones are used in RBASIC programs; but true to its &quot;high-level tools&quot;philosophy, there are many places to use level switching without writing aline of RBASIC code.andP;  Even if you don't know anything about switching, youcan generate powerful data entry windows (with PAINT), database queries (withQUERY), columnar reports (with RLIST or EasyWriter), and page-orientedreports (with FORM and MERGE).andP;  But to create database applications thatleave users open-mouthed, you have to learn the switching options and how toapply them.andM;Let's review the RBASIC techniques first, then move on to the higher-levelfacilities.andP;  Two RBASIC statements, EXECUTE and PERFORM, allow you to loadthe AREV command processor (TCL for &quot;The Command Level&quot;) and run any AREVcommand from within an RBASIC program.andP;  The syntax for these is: EXEUTE [isless than]command.line[is greater than] PERFORM [is less than]command.line[isgreater than]andM;The [is less than]command.line[is greater than] is any RBASIC command youcould type directly at the colon prompt in the TCL window.andP;  The maindifference between EXECUTE and PERFORM is that EXECUTE ignores any currentlyactive SELECT list of record keys when it operates on the records in a file.andO;PERFORM uses and then clears an active SELECT list.andP;  The following is asimple exaple.andP;  (If you haven't used RBASIC, you should know that the singlequotes enclose literal strings; FILENAME is a variable; and the colon is thestring concatenation operator.) 1 INPUT FILENAME 2 PERFORM 'SELECT ':FILENAME: ' WITH STATE = &quot;AK&quot;' 3 PERFORM 'COUNT ' :FILENAME 4 ENDandM;Line 1 prompts the user to type in a file name from the keyboard.andP;  Line 2causes a level switch.andP;  During the level switch an active SELECT list is madeof all the record keys in that file whose STATE field contains AK.andP;  Line 3causes another level switch that uses that list to display a message tellinghow many records the list contains.andP;  Line 3 also clears the list.andP;  Theoriginal execution level is restored at the end of each PERFORM statement.andM;Using EXECUTE in line 2 would have created the SELECT list; but since anEXECUTE level switch ends without passing the active select list to theparent level, the list would have been immediately lost.andM;Using EXECUTE in line 3 would have caused the COUNT statement to count allrecords in the file, rather than the selected ones.andP;  An EXECUTE level ignoresthe SELECT list that's active at the parent level.andP;  At the end of theprogram, the select list created in line 2 would still be active.andM;Using EXECUTE in both statements would have caused several things to happen:the SELECT list would have been created and immediately lost; COUNT wouldhave counted all records in the file; and it would have left no select listactive at the end of the program.andM;The program above is equivalent to typing the following two lines at thecolon prompt: SELECT [is less than]filename[is greater than] WITH STATE =&quot;AK&quot; COUNT [is less than]filename[is greater than]andM;The [is less than]filename[is greater than] represents the name of the file.andO;You can see that the RBASIC expression must be exactly the command you'dtype.andP;  For example, if I had left out the space after SELECT or before WITHin line 2, the command line would not have executed correctly.andM;Using EXECUTE and PERFORM allows you to run high-level commands from withinan RBASIC program easily, but the best is yet to come.andP;  The third levelswitching facility incorporates these two options and many more!andP;  Rather thanan RBASIC command, this third option is a system subroutine--named CATALYST.andO;One unique aspect of AREV's tools, such as WINDOW, MENU, etc., is that theyallow extensive customization, without sacrificing the non-procedural way youcan use them.andP;  This is implemented using CATALYST.andP;  With CATALYST, you canmodify a tool's operation without having to throw out the whole tool andduplicate its function in RBASIC.andP;  The idea of &quot;user books&quot; to customize aprewritten procedure has been around since the System/360 days, but it'snever been as powerful as in AREV.andM;In an RBASIC program CATALYST is simple to invoke: CALL CATALYST (CODE,COMMAND)andM;You determine what CATALYST does with the values of its two arguments, CODEand COMMAND.andP;  CODE determines the type of operation; COMMAND containsparameters detailing how or where.andP;  The various CATALYST CODEs and COMMANDsare explained pretty well in Chapter 16 of the Using Advanced Revelationmanual.andP;  At some point I'll amplify that documentation.andP;  Please refer to it,so we can move on to some examples of how to use CATALYST.andM;Within AREV tools, particularly WINDOW, there are many points at which youcan specify the CODE and COMMAND used by the tool in a CATALYST call.andP;  EachCATALYST call executes some process.andP;  These processes may happen before,after, or instead of some function of the tool.andP;  Others are tied to specifickeys and act whenever their associated key is pressed.andP;  Some CATALYST usesare very sophisticated, and I hope to cover them eventually; but let's startwith the most fundamental--menus.andM;The AREV menu processor depends on the CODE/COMMAND pairs to specify whataction is associated with each menu selection.andP;  Each menu is merely a datarecord in the SYS.MENUS or MENUS file.andP;  WINUS, an RBASIC subroutine, readsthat record and displays the menu selections.andP;  When you choose one, the CODEand COMMAND associated with your selection are used as arguments for aCATALYST call.andM;If the ANCHOR field in the menu's record is set true, you return to the menuat the end of the CATALYST process.andP;  If ANCHOR is false, you return to thepoint where the menu was called, typically TCL or the last anchored menu.andM;You should be aware of another implication of anchored menus.andP;  In an anchoredmenu, WINUS actually executes the CATALYST call when a selection is made.andP;  Inan unanchored menu, WINUS merely passes the selection's CODE and COMMAND backto the calling program.andP;  The caller normally executes the CATALYST call then,but it doesn't have to.andP;  In fact, in an unanchored menu, you can have CODEsand COMMANDs that CATALYST won't recognize, as long as the calling programintercepts them and doesn't call CATALYST with them.andM;Now let's go through the process of creating and running a menu using avariety of simple CATALYST calls.andP;  From the Main Menu, choose Design, thenMenu.andP;  This will present you with the Make Menu window (or at TCL, type CWMAKEMENU).andP;  Fill it out as shown in Fig.andP;  1, then press F9 to save the menu.andM;Now Esc back to the Main menu, choose Access, then Menu, then enter SAMPLE atthe Menu Name prompt (or at TCL, type RUNMENU SAMPLE).andP;  Our Sample menushould be displayed at the top of the screen.andP;  Because we specified it asanchored, we come back to it after the processes of each selection arecompleted.andP;  All the entries are straightforward--if you refer to the CATALYSTdocumentation I mentioned earlier.andP;  The Execute selection displays the reocrdfor SAMPLE in the MENUS file.andP;  Here's where you can see how all thisinformation is stored by WINUS (or any other program that cares to accessit).andP;  Despite the variety of CATALYST calls I've shown, we've only scratchedthe surface.andP;  We'll explore more next month.andM;Call for helpandM;I'd like to publish a list of AREV information resources.andP;  To do that, I needyour help.andP;  Please let me know about AREV books, newsletters, bulletinboards, user groups, consultants, and add-on products.andP;  Subjective commentson the quality or special features of these will also be welcomed.andP;  In answerto many reader inquiries, I'd also like to publish a list of books ondatabase design principles.andP;  The ones I'm looking for will strike a balancebetween the highly-theoretical, academic approach and the strictly vocationalor product-specific approach.andP;  Let me know which ones you're familiar with.andO;Responses can be sent to me via mail, phone, or the Data Based AdvisorReaders Exchanges BBS, (619) 270-2042.andM;Generating automatic EQU recordsandM;AREV provides two ways to designate data fields in a record: byphysical-sequence number or by name.andP;  The correspondence between these isdefined in the file's dictionary.andP;  While using field numbers in programs ismore efficient, names are easier to understand.andP;  I always use names despitethe additional overhead.andP;  The bad news is: important RBASIC fieldmanipulation statements (READV, WRITEV, INSERT, DELETE and EXTRACT) requirefield numbers.andP;  The good news is: the RBASIC EQU statement allows you toequate field names (or anything else) to field numbers.andP;  By $INSERTing a listof EQU statements for each record being manipulated, the source code canrefer to field numbers using field name equivalents.andP;  The problem is to keepthe $INSERT records up to date as field names are added to the dictionary orfield numbers are changed during development.andM;The following program, MFS*DICTINSERT, makes this task considerably easier,and it's a good example of a simple Modified Filing System (MFS).andP;  Itintercepts data written to records; when field definitions are added,changed, or deleted, it updates a custom dictionary record named $INSERT%.andO;The MFS maintains a list of EQU statements, equating each field name to itscorresponding field number.andP;  It also puts a comment line into the list namingeach symbolic field.andM;Note the undocumented system subroutine (V119) for sorting the field list.andO;I'll cover how to use this routine in a future column.andP;  After compiling andcataloging (MAKEVOC), the MFS should be installed for each DICTionary fileusing the following procedure: ATTACH [is less than]volume[is greater than]REVMEDIA FILECOPY REVMEDIA EDIT REVMEDIA [is less than]file[is greaterthan]*[is less than]account[is greater than]andM;In the editor, insert MFS*DICTINSERT as the first value in line (field) 2 ofthe record.andP;  For example, if field 2 is empty, type MFS*DICTINSERT.andP;  If field2 is QUICKDEX.MFS, the new value should be MFS*DICTINSERT\QUICKDEX.MFS (where\ stands for a value mark--ASCII 253).andP;  Save the record and exit the editor.andO;Then reattach the data file: ATTACH [is less than]volume[is greater than] [isless than]file[is greater than]andM;To use the record, place the following line in your RBASIC program: $INSERTDICT.[is less than]file[is greater than], $INSERT%andM;In the procedure above, which installs the DICTionary file, [is lessthan]volume[is greater than] is the name of the volume containing the dataand DICT files, [is less than]file[is greater than] is the name of the datafile, and [is less than]account[is greater than] is the account that owns thedata file.andP;  A typical line in the $INSERT% record might be: EQU NAMES$ to 3andM;This means the field named NAME is field 3 in the record.andP;  By convention, weappend a $ to EQU names, to distinguish them from true variables in theprogram.andP;  For example, instead of referring to @RECORD[is less than]3[isgreater than], write @RECORD[is less than]NAME$[is greater than].andP;  If thefield number for NAME ever changes (which is rare), the $INSERT% record willimmediately reflect that change.andP;  But all programs that refer to NAME$ willstill have to recompiled.andP;  A more sophisticated MFS would keep track of everyprogram that refers to the $INSERT% record and would keep a log of whichprograms need to be recompiled because of field number changes.andP;  SUBROUTINEBFS (CODE, BFS, HANDLE, NAME, FMC, RECORD, STATUS) *Creates a $INSERT recordafter each dict change.andP;  DECLARE SUBROUTINE V119; *used to sort the fieldlist *The only operation trapped by this MFS is a write to the *%FIELDS%record, since it's modified by DICT.MFS every *time an F, S, or G typedictionary record is added, *deleted, or updated.andP;  $INSERT UTILITY.PROGS,FILE.SYSTEM.EQUATES $INSERT UTILITY.PROGS, LOCAL BEGIN CASE CASE INDEX ('/READ.RECORD/READO.RECORD/DELETE.RECORD/ [rightarrow]LOCK.RECORD/UNLOCK.RECORD/SELECT/READNEXT/ [rightarrow]CLEARSELECT/CLEARFILE/OPEN.FILE/CREATE.FILE/ [rightarrow]RENAME.FILE/MOVE.FILE/DELETE.FILE/','/':CODE:'/',1) GOSUB NEXT.MFS CASEINDEX ('/OPEN.MEDIA/CREATE.MEDIA/READ.MEDIA/WRITE.MEDIA/ [right arrow]GROUP.NUMBER/','/':CODE:'/',1) STATUS = FALSE CASE INDEX ('/UNLOCK.ALL/FLUSH/INSTALL/LOCK.SEMAPHORE/ [rightarrow]UNLOCK.SEMAPHORE/SEMAPHORE/FLUSH.CACHE/ [right arrow]',1/':CODE:'/',1)STATUS = TRUE CASE CODE = RECORD.COUNT STATUS = FALSE GOSUB NEXT.MFS CASECODE = WRITE.RECORD IF NAME='%FIELDS%' THEN SS='' S1=RECORD[is less than]4[isgreater than]; *multivalued list of field types S2=RECORD[is less than]5[isgreater than];*multivalued list of corresponding [right arrow]field numbersS3=RECORD[is less than]3[is greater than]; *multivalued list of corresponding[right arrow]field names POS1=1 POS2=2 POS3=1 N=0 LOOP; *Rearrange the datato prepare for building EQU lines REMOVE TYPE FROM S1 AT POS1 SETTING FLGREMOVE FMC FROM S2 AT POS2 SETTING FLG REMOVE FNAME FROM S3 AT POS3 SETTINGFLG IF INDEX('FS', TYPE, 1) THEN *If the record is data or symbolic, add itto the new list SS:=TYPE:@FM:FMC:@FM:FNAME:@RM N+=1 END WHILE FLG REPEATS1='' IF SS THEN CALL V119 (' S', '', |AA', ' LR', SS, '');*Sort the new listCONVERT @FM TO '' IN SS SS[-1,1'='' POS1=1 LOOP;* Build the EQU (for data) orcomment [right arrow] (for symbolic) lines REMOVE S2 FROMandP; SS AT POS1 SETTINGFLG CONVERT '' TO @FM IN S2 IF S2 [1,1]='F' THEN S1:='EQU ' :SI[is lessthan]3[is greater than]: '$ TO ' :S2[is less than]2[is greater than]: @FM ENDELSE S1:='* ' :S2[is less than]3[is greater than]:' formula'  :@FM WHILE FLGREPEAT S1 [-1,1]='' END FD.=FIELD (BFS, @SVM, 2, 32767) :@VM:HANDLE WRITE S1TO FD.,'$INSERT%';*Write the new $INSERT% record END GOSUB NEXT.MFS END CASERETURN *===== NEXT.MFS: FS = DELETE (BFS,1,1,1) NEXTFS = FS[is lessthan]1,1,1[is greater than] CALL @NEXTFS (CODE, FS, HANDLE, NAME, FMC,RECORD, STATUS) RETURN *=====andM;John Gunther owns a broad spectrum consulting firm with particular strengthsin networking, applications development, and third-party support.andP;  He invitescomments and can be contacted at Bucks vs Bytes Computer Consulting, 28Central Avenue, Rosendale, New York 12472-9638, phone (914) 658-8203.andO;</TEXT></DOC>