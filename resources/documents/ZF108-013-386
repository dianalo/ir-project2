<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-013-386  </DOCNO><DOCID>08 013 386.andM;</DOCID><JOURNAL>EXE  Dec 1989 v4 n7 p12(5)* Full Text COPYRIGHT Process Communications Ltd. (England) 1989.andM;</JOURNAL><TITLE>The man who is C++. (Bjarne Stroustrup) (interview)</TITLE><AUTHOR>Smith, Paul.andM;</AUTHOR><SUMMARY>Bjarne Stroustrup's experience in writing a distributed systemssimulator at Cambridge University taught him that a proper toolmust cope with complexity and help ensure correctness of theprograms written.andP;  A proper tool must also be portable andaffordable in terms of hardware resources.andP;  Lacking such a tool,Stroustrup built what was eventually called C++.andP;  In seeking tomake C++ portable, efficient and compatible with a large number oftools, systems, language and design approaches, Stroustrup optedto omit such features as exception handling that requiresnon-trivial loader and run-time support.andP;  C++ has been used towrite Unix System V utilities.andP;  ANSI is set to beginstandardization of C++ in Dec 1989.andM;</SUMMARY><DESCRIPT>Product:   C++ (Program development software) (product specifications).andO;Topic:     InterviewProgramming LanguagesSoftware DesignSoftware ComplexityProgramming.andO;Feature:   illustrationportraitprogram.andO;Caption:   Bjarne Stroustrup. (portrait)Exception handling using the 'try block' scheme. (program)Person:    Stroustrup, Bjarne (interviews).andM;</DESCRIPT><TEXT>The Man who is C++ I got my Masters degree at the University of Aarhus inDenmark.andP;  Aarhus is my home town.andP;  I specialised in Operating Systems andmachine architecture, doing things like instruction set design andmicroprogramming (the programming of a machine's fundamental instructions atthe register transfer level).andP;  I got my PhD from Cambridge [University,England], where I worked on architectural support for distributed systems.andO;My major tool for experimentation was a distributed systems simulator that Iwrote.andP;  PhD students did not have seven-processor systems to play with inthose days, and anyway, controlled experiments are very hard to do on realsystems with people doing real work.andP;  The simulator was initially written inSimula67.andP;  This language is one of the most beautiful and most innovativeever designed.andP;  From this stems most of the key concepts of what has becomeknown as 'Object-oriented programming.'andP;  Simula67 provided classes and classhierarchies (also known as 'inheritance'), virtual functions and strong typechecking.andP;  I think that it was Tony Hoare who commented that 'Simula was notonly a major improvement on all of its predecessors but also on most of itssuccessors', I'll second that!andM;There was a major problem, though.andP;  Having gone through the unusuallypleasant experience of designing and debugging this simulator in Simula67, Icould not afford to run it.andP;  Simula67 provides the essential mechanisms forexpressing a design (classes) without which I couldn't even have conceived ofthe final program and the strong (static) type checking without which I couldnever have gotten the bugs out that easily.andP;  However, it was very demandingof run-time resources: both time and space.andM;I had very few choices: I could leave Cambridge (without a PhD), I could wait6 years for hardware to get cheap and fast enough for me to afford it, Icould get a very rich sponsor, or I could rewrite the simulator into alanguage that would run fast on a small machine.andP;  Only the last alternativeseemed feasible, so I rewrote the simulator in BCPL and ran it on theexperimental CAP computer.andM;It was a most unpleasant experience; BCPL makes C look like a very high levellanguage.andP;  However, the basic fact was that after a lot of work, I got mydata.andP;  I swore that I would never again approach a project of thiscomplexisity without proper tools.andM;My idea of a proper tool for such projects had gone through a significanttransformation as a result of this experience.andP;  Such a tool (a language plusits related compilers and so on) must help cope with complexity and helpensure correctness of the programs written.andP;  In other words, I insist onstrong type checking and classes.andP;  It must also be affordable in terms ofhardware resources (both run-time and space), it must be 'open' in the sensethat it must be easy (and cheap) to use other peoples' software from it (suchas FORTRAN libraries, C graphics systems, databases).andP;  Also, since I work onmany kinds of computers, the implementation of this tool must be veryportable, and it must be possible for me to write very portable programs init.andM;Unfortunately, such a language did not exist.andP;  That left me in an awkwareposition when I later (1979) needed to start another demanding project atBell Labs.andM;C++ is bornandM;I then decided to build such a tool; this became first 'C with Classes' andthen C++.andP;  During this design and implementation phase a couple more 'rulesof the game' were formulated.andP;  I wanted a language that could be efficientlyimplemented on traditional hardware by someone with limited time for the job(me) and without the need for really clever implementation tricks (which Imight never get right); this could also be seen as a corollary to theportability requirement.andM;I decided on C++ being 'as close as possible to C- but not closer' to ensurethat I did not risk designing unexpected limitations into the language, sothat I could apply C tools (such as linkers, profilers, editors and so on) toC++ programs, and to decrease significantly the burden of teaching the 'newstuff'.andP;  I also observed that C was basically OK when it came to expressingcomputation; its deficiencies are in the area of program organisation andsupport for good design and programming -- those then became my areas ofwork.andM;It might be worth mentioning that C is often unfairly maligned for notsolving problems it was never designed to solve.andP;  C was designed to raise thelevel of language used in systems programming, to enhance portabilitysignificantly, and to eradicate assembly language programming in mostbranches of systems programming.andP;  In this, it succeeded beyond allexpectations.andP;  Many of the things we take for granted these days are directresults of C's success in these areas.andM;I had no wish to 'improve' C in such ways that these achievements wereendangered.andP;  To my mind there is little advantage of using a language that isso 'high level and clean' that it forces people to use assembler on a regularbasis.andP;  Consequently, C++ is designed to span a larger spectrum ofprogramming tasks than most languages.andM;How long was the development of C++ 2.0, and how many people were involved?andM;Essentially, 2.0 was grown over the years after release 1.0 in 1985.andP;  We hadmultiple inheritance, the feature people most directly associate with 2.0,working in May of 1987, but the final push that produced 2.0 was done fromlate 1988 until June of '89.andP;  There were about a hundred people involved inthe reference manual review, dozens of people took part in activities such asbug-report screening, documentation, arguing with me over features, tryingout early versions and so on.andP;  The core group consisted of Stan Lippman andme, who did almost all of the coding, Pat Philips, who handled integration,Andy Koenig who did testing and Barbara Moo, who coordinated the variousefforts.andM;In your book The C++ Programming Language (Addison-Wesley 1986), you say 'C++was designed to be used in a rather traditional compilation and run-timeenvironment, the C programming environment on the UNIX system.andP;  Features suchas exception handling or concurrent programming that require non-trivialloader and run-time support are not included in C++.andP;  consequently, a C++implementation can be very easily ported.'andP;  Do you now regret these designdecisions?andM;I strongly believe that those were correct decisions.andP;  Some people seem tothink that a pragmatic view precludes principles.andP;  That is not the case.andP;  Iknow my principles of programming languages and of programming about as wellas anyone else, but I am very reluctant to let theory dominate my thinking.andO;Far too often we have seen notions of religious purity blinding people tohard facts of life and imposing preposterous constraints on people.andP;  Apragmatic view and an understanding of the problems of the users areessential -- as is the need to consider every language feature in a largercontext so that a language doesn't simply become a random collection of 'neatfeatures' but has an internal consistency and logic.andP;  The 'shopping listapproach to design' simply doesn't work and C++ was certainly not designedthat way.andM;My ideal for the design of C++ is an organic growth from a solid base guidedby both principles and experience.andP;  I think that is what has happened up tillnow and I see that continuing for a while longer.andM;Naturally, some aspects of C are a pain in the nect.andP;  Departing from themwould have made the design of C++ cleaner and its implementation and useeasier.andP;  For example, the C declarator syntax is an experiment that failedand some aspects of the C array concept are beyond repair.andP;  However, Iconsider these issues second order compared with such matters as efficiency,portability, compatibility and the ability to co-exist with an unbelievablediverse set of tools, systems, languages, design approaches and so on.andM;Is C++ going to become standardised, with a committee sitting to determinethe language definition and C++'s features?andP;  Would you be happy to see C++'move upstairs' in this fashion?andM;The ANSI standardisation of C++ starts in December.andP;  A formal standardisationprocess can bring a lot of good in terms of clarity of definition, agreementon details, stability for use, and providing a stable base for furtherevolution.andP;  I hope that is what is going to happen and I think we can makethat happen.andP;  On the other hand, some standards committees have turned intolanguage design committees and become vehicles for rampant featurism,'design' by vote of anyone who cares to turn up and horse trading ('if youvote for my feature, I'll vote for yours').andP;  Such a horror show must beavoided.andM;Do you regard version 2.0 of the language as the beginning of a move awayfrom its roots?andM;Not at all.andP;  If you look at my book you will see multiple inheritance,parameterised types and exception handling mentioned as areas where we neededimprovements, but where I did not at the time know of solutions that met myrather stringent criteria for inclusion into C++.andP;  Only when we have all ofthose features will C++ have expanded to fill its original scope.andM;C++ versus ANSI C: has the development of the C language split into twoseparate threads, or will C++ and ANSI C merge again in a future 'super C'?andM;I think C++ already is such a 'super C.'andP;  Many ANSI C features have beenadopted--as many as could be safely absorbed without damaging the typesystem.andP;  It is also worth noting that the ANSI C committee's work on thestandard C libraries can be directly adopted by C++.andM;Conversely, ANSI C adopted variants of C++'s function argument type checkingand type conversion, the C++ function definition syntax, and a variant ofC++'s const.andP;  C++ is already closer to ANSI C than most people think.andM;How would you characterise the significance of version 2.0 of C++, from thepoint of view of the original designer of the language?andP;  What in version 2.0is most important?andM;Release 2.0 of C++ was made generally available by ATandamp;T on June 30, 1989.andO;Release 2.0 is the first major revision of the C++ language and will providea base for formal standardisation and further evolution of C++.andM;The most important thing about release 2.0 is not the new features itprovides, but the improved quality of the compiler, the libraries, thedocumentation and, in particular, the C++ reference manual.andM;The manual is the result of much work within ATandamp;T and of a review by about ahundred people from very diverse organisations world-wide.andP;  Experienced C++users from academia, industry, and government and C++ compiler develoeprsfrom many organisations (that usually compete vigorously) all helped.andM;After a further minor revision and clean-up, I plan to publish this manualtogether with additional information about implementation techniques andreasons for design decisions as a book.andP;  It should be finished near the endof this year.andM;The definition of C++ 2.0 now provides a common base for all C++ compiler andtools writers and will become the starting point for ANSI standardisation ofC++.andP;  Release 2.0 removes all non-essential incompatibilities with ANSI Cleaving C++ for most practical purposes a superset of ANSI C.andM;Most new features in 2.0 take the form of removal of restrictions.andP;  Togetherthey allow for much cleaner code, a more natural programming style andeliminate many common programmer errors.andM;It might be worthwhile pointing out that I still control the definition ofC++.andP;  I designed every one of the 2.0 features, wrote the manual sections forthem, and did the initial implementation of them.andM;Taking exceptionandM;Do you still believe that exception handling belongs outside the language?andM;I have pointed out before, in various papers, that we need a better mechanismfor handling errors.andP;  However, we cannot accept a mechanism that would damagerun-time efficiency, portability, or the ability to use C++ in mixed languageprogramming.andM;So, though we have acknowledged the need for years, we have had no acceptablesolution, let alone a proper design.andP;  This is changing.andP;  On October 6, AndrewKoenig and I presented a paper 'Exception Handling for C++' to the C++ atWork conference in Boston.andM;The scheme is based on the notion of a 'try block', in the style of theModula-2+ and Modula-3 syntax, with the distinct C++ touch of havingexceptions be objects of a class exception.andP;  This enables us to bring all thepower of the language to bear on exceptions in areas such as type-checking,lexical scope, and extensibility of the exception concept.andP;  (Since exceptionis a class, users can derive their own variants of the class from it.andP;  SeeFigure 1.)andM;It is important to realise that this exception handling mechanism is designedas a proper language facility so that it allows several alternativeimplementations.andP;  In particular, we can implement it using setjm( )/longjmp(), thus getting the portability we need.andP;  Initial measurements show that thisstyle of implementation is likely to be unacceptably slow in some contexts.andO;To alleviate this, we also have a second technique that yields zero run-timeoverhead when an exception is not raised.andP;  This technique cannot beimplemented in a portable way, though.andP;  We imagine that people will use theportable, but relatively slow, implementation until a variant of theefficient implementation becomes available on their particular system.andM;This exception handling mechanism is not available from anybody and I expectit will remain experimental and under discussion for some time.andM;ATandamp;T's implementation of C++ comprises of a Cfront preprocessor to a standardC compiler.andP;  Is it satisfactory to require an extra preprocessing step beforecompilation?andM;Describing Cfront as a 'preprocessor' is completely misleading.andP;  It never wasa preprocessor in the same sense as the C preprocessor or RATFOR.andP;  Cfront isa classical compiler that does a complete syntax and semantic analysis beforeproducing output.andP;  It produces C simply because C is a very widely availableinterface to good code generators.andP;  If you call Cfront a preprocessor, youshould for consistency also call an assembly code-generating C compiler apreprocessor.andM;One would expect code generated from Cfront to be less efficient than codegenerated by a compiler without the intermediate C step.andP;  Until now, this has-- surprisingly even to me -- not been the case.andP;  The speed and space recordson all machine architectures are still held by some Cfront/C-compilercombination.andP;  I expect and hope that the 'native' C++ compilers will soonprogress to the stage where they beat Cfront in generated code quality, butdon't expect spectacular improvements over Cfront because theCfront/C-compiler combinations already out-perform many C compilers for the Csubset of C++.andM;Doesn't this dependence on a C compilation step limit the design of C++?andM;The C++ language does not depend on a C compilation step, the Cfrontimplementation of the C++ language does, and no, the Cfront two-pass compilertechnology has not constrained the design of C++.andP;  I have always known thedistinction between a language and its implementations.andP;  The initialimplementation of C++ (Cfront) has not been allowed to constrain the designof the C++ language.andP;  The constraints on the C++ design has been Ccompatibility and the generally poor state of linker technology -- and thenof course the first order design criteria of type-safety, low-levelefficiency, and ability to fit into traditional run-time environments.andM;People sometimes point to debugging as an area that shows that C++ isdeficient because of the Cfront implementation technique.andP;  The appearance ofC++ level source language debuggers for C++ implemented using Cfront fromApollo, HCR, Sun, Apple and ParcPlace should put this issue to rest.andP;  The C++debuggers used inside ATandamp;T have not been for sale.andM;Actually, C compatibility in general and the Cfront technique of generating Cas our assembly code has been very important.andP;  C compatibility allowed me tohave a complete language, a very large set of libraries (the C libraries),and high quality code generators immediately.andP;  Also, because C was widelyknown, the burden of education was greatly diminished.andP;  In all, this allowedme to support users within six months of starting enhancing C.andP;  It seems thatI started a trend.andP;  People are now providing C generating compilers forlanguages such as Modula-3, Ada, and Common Lisp.andP;  C is becoming theuniversal intermediate language for people interested in portability.andM;Is it then the case that C++ is, from an implementation point of view, quiteindependent of C; that you have made it compatible by choice, and that thereis nothing in C++ that has to be there simply because of your use of C asintermediate code between the C++ compiler and the final object code?andM;Exactly!andP;  100% correct.andP;  If you need an added argument for that position:there exist at least four available and five almost complete C++ compilersthat do not use C as an intermediate form.andM;Do you agree that C++ should have had proper generic classes, not a #definebodge?andP;  If so, why didn't you supply them?andM;I certainly agree that generic classes are desirable.andP;  However, you mustremember that C++is one of the languages that had to work hard for a livingduring its childhood.andP;  In this, it resembles FORTRAN and C (both of which Ihave the greatest respect for) and differs from languages such as Ada,Algol68, and PL/1, that came into existence as complete -- if unimplemented-- designs.andP;  My book was written adn release 1.0 of Cfront was done notbecause C++ was perfect, but because C++ had reached a plateau of itsdevelopment where it was reasonable to allow more people to use it.andP;  Therewas quite a clamour for it at the time (as there has been ever since) andthere seemed no reason to keep C++ our of usesimply because it could be evenbetter.andM;Throughout its early life, C++ was a very low budget operation that had topay off immediately in terms of benefits to real users.andP;  I know that thisdoes not conform to the view some people have of ATandamp;T as a huge organisationcapable of throwing endless time, money and manpower at prolems, but it doesactually fit well with the way work is done in the computer science researchcentre at Bell Labs.andP;  Note that you have never seen an ATandamp;T advert for C++.andO;The current popularity of C++ was achieved as a grass-roots movement withoutexpensive commercial hype.andM;Also, and most importantly, I believe that languages ought to grow guided byboth general principles and experience.andP;  Without users there cannot berelevant experience and without principles you get nothing but a mess.andP;  SoC++ evolved through stages: First C with Classes in 1980, then Release E in1984, and release 1.0 in 1985.andP;  The current release 2.0 builds directly onthese.andP;  The 'generic classes' you ask for will most likely become the nextmajor step together with exception handling.andP;  (See example in Figure 2.)andM;Another reason for leaving templates out of release 1.0 was that at the timewe were not sure that we understood the compilation process well enough tobuild something that both ran fast enough and produced sufficiently goodcode.andM;It is worth noting that among the so called object-oriented languages, C++ isunique in taking efficiency seriously to the point on meeting C and FORTRANhead on.andP;  Most other languages rely on quality, productivity improvements,and/or glitz to overcome a burden of inefficiency compared to C; C++ hasalways had to be equal to or better than C.andP;  This affects C++ strongly.andP;  Forexample, C++ has genuine static and automatic (ie on stack) variables whereother 'object oriented' languages rely on pointers to objects to free store.andO;This saddles these languages with an overhead of memory management andpointer chasing that is avoided in C++.andP;  The flip side of this is a bit morework for the C++ programmer and quite a lot more work for the C++ compilerwriter.andP;  The result is pleasing, though.andP;  The difference in run-timeefficiency is usually measured in factors -- not fractions!andM;C++ and UNIXandM;A recent rumour suggested that C++ was being used to write parts of the nextrelease of ATandamp;T UNIX.andP;  Is C++ displacing C as the UNIX systems programminglanguage already?andP;  If not, how soon do you expect it to do so?andM;Well, the rumour was definitely true, but I don't know if it still is.andP;  Therewas, and maybe there still is, a joint ATandamp;T/Sun project to evolve UNIX SystemV.andP;  It was/is being done in C++.andP;  Whatever is going on with that particularproject -- which is of course mostly dependent on grand corporate politics --there are definitely active UNIX kernel projects that use C++.andM;Yes, C++ is already displacing C as the UNIX systems programming language insome places.andP;  However, it would be plain silly to expect C to go away any daysoon.andP;  After all, one of the principles of reuse is 'if is ain't broke, don'tfix it'.andP;  Since UNIX by and large is not broken, we shouldn't start messingaround with it simply to convert it to C++.andP;  Only if we want to replace orperform surgery on some subsystem would we start using C++.andM;If you are talking of System V.4, which I believe is soon to be released,then the answer is that no kernel work was done in C++; but I believe thatsome utilities (sdb springs to mind) are C++ programs.andM;Once you have C++ 2.0 out of the way, and you have finished your new book onthe subject, what do you plan to do next?andM;Have a long vacation!andP;  Seriously, though, I have to write two books (anannotated C++ Reference Manual and a revision of my book) and there is stillexception handling and parameterised types to do.andP;  That should keep me busyfor quite some time.andP;  The ANSI standardisation of C++ will also demand workand then there are users to help.andP;  I think it is a bit early to speculateabout 'what next'.andO;</TEXT></DOC>