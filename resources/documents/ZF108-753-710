<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-753-710  </DOCNO><DOCID>08 753 710.andM;</DOCID><JOURNAL>Microprocessor Report  August 8 1990 v4 n13 p10(6)* Full Text COPYRIGHT MicroDesign Resources Inc. 1990.andM;</JOURNAL><TITLE>Why programmers hate the 8086 and 286; architect's plans don'tmatch programmers actions. (Intel's 8086 and 80286microprocessors) (technical)</TITLE><AUTHOR>Levine, John.andM;</AUTHOR><DESCRIPT>Product:   Intel 80286 (Microprocessor) (usage)Intel 8086 (Microprocessor) (usage).andO;Topic:     MicroprocessorsProgrammingSegmentation.andO;Feature:   illustrationchart.andO;Caption:   Segmented addressing mechanism of the 8086/8088. (chart)Addressing mechanism used by the 286 in protected mode. (chart)Segment descriptor format for the 286. (chart)andM;</DESCRIPT><TEXT>The 8086 architecture and its descendants, the 286, 386, and 486, nowdominate personal computing and show every sign of continuing to do so wellinto the 1990s.andP;  Everyone knows the 8086s segmented addressing model hascaused much grief, and the 286 is  brain damaged&quot; - but relatively few peopleunderstand exactly what this means.andP;  In this article, we look at theevolution of the addressing model from the 8080 to the 8086 and the 80286,and examine why the 8086 and 80286 segmented programming model is so hard touse.andP;  In part two (next issue), we'll look at the 386 and 486, and see whatproblems the extension to 32 bits did and did not solve.andM;The 8086 ArchitectureandM;Intel designed the 8086 and its descendants with a firm model in mind of theway the chips would be programmed.andP;  In many cases, Intel's expectationsmatched what programmers have done.andP;  In others they were completely wrong.andO;Data and code addressing, in particular, have evolved quite differently fromwhat they expected, and have become the bane of a generation of programmers.andM;In the late 1970s, Intel needed a 16-bit successor to the 8-bit 8080.andP;  The8080 is capable of addressing 64K bytes, which seemed like a lot of memoryfor a microprocessor in the 1970s.andP;  Its addressing scheme is linear, thoughsome of the addressing modes are clumsy.andP;  A programmer treats memory as asingle array of bytes with addresses running from 0 to 64K (The later 8085 islargely identical to the 8080 from a programmer's point of view.)andM;When Intel designed the 8086 and the identically programmed 8088, they wantedthe new chip to be as program- and data-compatible with the popular 8080 aspossible.andP;  On the other hand, they needed a larger address space to give themheadroom for the future.andP;  The 8086 achieved both of these goals quiteeffectively.andM;Ib meet the compatibility goal, Intel's designers made the 8086's registersand instruction set mostly a superset of the 8080.andP;  Although not directlyprogram-compatible with the 8080, the 8086 is similar enough that 8080assembler source can be translated mechanically, line by line, to 8086source.andP;  The result will work with minimal hand tweaking.andP;  Most early IBM PCsoftware was created in this way.andP;  (Compare this approach to the later NECV20/V30 which actually does run 8080 code in a compatibility mode, though bythe time the V20 came out few users cared about running 8080 code on a PC.)andM;Achieving the addressing goal was more difficult.andP;  One possibility would havebeen to go directly to a 20-bit or greater address as they did on the 8089I/O processor.andP;  That would have caused several problems.andP;  Since the 8086 has16-bit registers, it handles 16-bit addresses much more efficiently thanlonger ones.andP;  Also, 8080 programs compute 16-bit data addresses in 16-bitregisters, so translated programs would be much less likely to work if 8086addresses were a different size.andP;  Various bank switching schemes had beendevised to multiplex more than 64K of memory into the 8080's address space,but none was entirely satisfactory.andM;Intel's designers handled the addressing problem by using segmented memory,which until then had been a mainframe technique used on the Burrougbs B5000(now the Unisys A series) and the GE (later Honeywell) 645 Multics machine.andO;The 8086 treats memory as a large number of 64K-byte address spaces.andP;  Fortranslated 8080 code and other programs for which 64K is enough, a single 64Ksegment suffices and all addresses lie within that segment.andP;  For programsgreater than 64Y,, code and data have to be divided into chunks of 64K orless, and new segment manipulation instructions and segmented addressingmodes let the program address different segments as needed.andM;At any moment, a program can address four segments via four segmentregisters, as shown in Figure 1.andP;  The CS register defines the code segment,from which instructions are fetched.andP;  The SS register defines the stacksegment, in which stack (push and pop instructions) and stack frame dataaddresses are resolved.andP;  The DS register defines the default segment fornon-stack data addresses, and the ES register defines an &quot;extra&quot; segment usedfor a few data addresses such as the destination of a string move.andP;  Most datareferences can also be made to the ES, SS, or CS rather than the default DSor SS by preceding the instruction with a segment override prefix.andP;  Segmentregisters other than the CS can be loaded from a general register or frommemory.andP;  The CS is changed only by jump, call, and return instructions, andby interrupts.andM;Segments are mapped to memory addresses in a simple way.andP;  The base address ofthe segment is the segment number shifted left by four bits, e.g.andP;  segmentOx1234 starts at address Ox12340.andP;  Since segment numbers are 16 bits,shifting them four bits to the left gives a 20-bit physical memory address.andO;The possible segment starting addresses are spaced 16 bytes apart; the16-byte unit is called a paragraph.andP;  This segment mapping scheme is carriedover to the 286, 386, and 486, when operating in what is called &quot;real mode.&quot;andM;Programming the 8086andM;The 8086 architecture facilitates the writing of assembler programs andsimple compilers for higher level languages.andP;  A hardware stack supportssubroutine nesting and the stacked memory allocation used by most Algol-likelanguages such as Pascal and C. Dedicated stack and frame pointers make stackaddressing straightforward.andP;  There are also six general-purpose 16-bitregisters, four of which can be used as pairs of byte registers.andP;  Most of thebasic instructions allow various mixtures of memory and register operands.andO;One-, two-, and four-byte operands are addressed in a uniform way.andP;  Thismight seem obvious, but the PDP-11 has a different order for 32-bit numbersthan for 8- and 16-bit numbers.)andM;More sophisticated compilers, however, are much harder to write.andP;  The 8086favors particular translations of common program idioms.andP;  For example, if youwant to repeat a section of code some number of times, and you put the repeatcounter in the CX register, and you count down to zero rather than countingup, and the loop fits in less than 256 bytes, then you can use the loopcontrol instructions.andP;  Otherwise, you have to use separate increment andbranch instructions which are longer and slower.andP;  Of the six generalregisters, only three can be used as index registers, and only four can beused as byte registers.andP;  Some instructions such as string move, multiply, andarithmetic shift require that one or both operands be in specific registers.andO;Other instructions allow any register as an operand but have a shorterencoding for some registers than for others.andP;  In fact, no two registers onthe 8086 are treated the same.andP;  All of this asymmetry makes it difficult fora compiler, or for that matter a human programmer, to identify the shortestor fastest set of instructions for a given task.andM;the INC instruction, for example, adds one to a register or memory word.andP;  Ifyou want to increment the BL byte register, which is the low half of the BXword register, and you don't care about the contents of the high half of theBX, then the best instruction is INC BX because it is the same speed as, butshorter than, INC BL.andP;  This kind of information is hard to build into acompiler, and no compiler I have ever seen tries to deal with it.andM;Another difficulty that is not unique to the 8086 architecture, but isnonetheless tedious to deal with, is that complex instructions are oftenslower than the equivalent simple ones.andP;  The 286 ENTER instruction, whichsets up the stack frame for a procedure, takes 11 cycles, while theequivalent push, move, and subtract instruction sequence takes only 6 cycles.andO;Multiplication by 12 using the MUL instruction takes 21 cycles, while theequivalent shifts and adds take 10.andP;  These differences become even greater onthe 386 and 486; on the latter ENTER takes 14 cycles and the simpleinstructions only three.andM;Segmented 8086 programmingandM;The aspect of the 8086 architecture that causes by far the most complicationis segmented addressing.andP;  First we'll look at how it affects code and dataaddressing in the 8086.andP;  Later we'll see what extra complications arise onthe 80286.andM;Code segmentation on the 8086 turns out not to be much of a problem fortypical programs.andP;  Generally, the object code for each source module in aprogram is compiled into a single segment.andP;  Calls and jumps within the moduleuse fast and short ` near' (intra-segment) addresses, while calls to routinesin other modules use ` far' (inter-segment) addresses.andP;  In most programs,jumps within a module are much more common than calls to other modules, sothis scheme works well.andP;  The 64K segment size limit is rarely a problem,since in most languages a single source module would need to be over 10,000lines long to require more than 64K of code.andP;  If two modules refer frequentlyto each other, it is straightforward, in many languages, to combine theirobject code into a single segment so long as their total size is not morethan 64KandM;Segmented data addressing in large programs is much more difficult.andP;  As soonas any of a program's data grows larger than 64Y% either all of the dataaddressing code has to pass around segment numbers as part of addresses, orelse the program has to distinguish between inter-segment and intra-segmentdata addresses.andP;  The first option makes all of the data addressing abouttwice as large and twice as slow as single-segment code; the second forcesthe programmer to distinguish between near pointers and far pointers in theoriginal program.andM;Making the distinction between near and far addresses in high-level languagesis surprisingly difficult.andP;  Segmented addressing is supposed to encourage theprogrammer to divide the program's data into logical units, each of which canbe stored in a segment.andP;  In practice on the 8086, it doesn't work that way.andO;Since near addresses are so much faster, programming language implementationstry to make as many references as possible near rather than far.andP;  Ccompilers, for example, usually use a ` data group' segment that containsmost of the global data, strings, and the stack, and leave the DS and SSregisters pointing at that segment.andP;  Static data are at the low end of thesegment.andP;  The stack grows down from the high end, and the heap grows up abovethe static data.andM;Data in the data group can be addressed quickly, and data anywhere else canbe addressed by loading the ES first to point to the appropriate segment.andO;(This scheme is known as the small model if all of the code fits in onesegment, or as the medium model if the code is in multiple segments.) As soonas there is more than 64K bytes in the data group, this scheme fails,typically with a cryptic linker error or mysterious failures when the stackand heap collide.andP;  To remedy this situation, the programmer has to pick itemsto move out of the data group, adjusting the source code appropriately, orelse use far addresses for everything (the large model) and accept the sizeand speed penalty.andM;Up to this point,  segmented addressing seems awkward, but can be dealt within a straightforward manner.andP;  It becomes a serious liability when a structureor array grows larger than 64K and does not fit in a single segment.andM;Knowledge of the mapping from segment numbers to linear addresses is supposedto be buried in the operating system, to give the system more flexibility inmemory allocation and to allow for the different mapping scheme introduced inthe 286.andP;  If the segment registers were handled entirely by the operatingsystem, then the evolution from the 8086 to the 286 would have required amodified operating system, but application programs would have been able torun unmodified.andP;  Unfortunately, the 8086 architecture lacks the concept of asupervisor mode.andP;  It does not restrict access to segment registers, enablingapplication programs to modify them directly at will.andP;  Furthermore, MS-DOSdoes not provide adequate facilities for allocating segments, and there arefundamental problems with using the segment registers in the way Intel hadenvisioned.andM;For example, to implement a 10,000-element array of 12-byte entries in thepure large model, the program keeps three segment numbers obtained from theoperating system, each identifying a 64K segment.andP;  Each time it needs tocompute a subscripted address, it divides the subscript by 5461 (the numberof 12-byte entries that fit in a 64K segment,) looks up the appropriatesegment number, and uses the remainder of the division times 12 as the offsetin that segment.andP;  Division by 5461 is extremely slow, taking about 150 clockcycles on the 8086, so the performance loss is severe.andM;Most MS-DOS programs handle large data structures by considering memory as alinear array.andP;  The program computes the linear address of an item, and thendivides that address by 16 to get the segment number.andP;  The remainder fromthis division is used as the offset in the segment.andP;  (This is called hugemodel addressing.) Since this calculation is still slow (two or three timesas slow as computing a near address) it is common to use a hybrid of huge andnear addresses, calculating the base of a group of data as a huge address,and subsequent manipulations as pseudo-near addresses, changing only theoffset within the segment.andM;Although this is the only reasonable way to handle large arrays, it is amajor perversion of the way that segmented addressing systems are supposed tobe used.andP;  MS-DOS, the standard operating system for 8086-based PCs, uses thearray of paragraphs model itself, and encourages programs to do the same.andO;When it starts a program, it finds the largest contiguous piece of freememory, loads the program at the base of it, and passes to the program thebase paragraph number and size in paragraphs of its area.andP;  Any suballocationis up to the application.andP;  It is possible for the program to give back thememory beyond the end of its data, and to ask DOS to allocate small datasegments as needed.andP;  Nobody does that, both because it is slow and becauseDOS imposes a significant memory overhead of one paragraph (16 bytes) perallocated chunk.andM;286 ArchitectureandM;When Intel designed the 80286, they optimistically assumed that most 8086programs would handle address segmentation in the 'correct' way, and designeda new protected address mapping scheme that is quite compatible with puresegmented addressing and totally incompatible with the array of paragraphsmodel.andP;  Because the 286 changes the way the segment registers work, andbecause the segment registers are a programmer-visible resource that can beused in any way the programmer desires, most 8086 programs cannot rununmodified on a 286 operating in its native &quot;protected&quot; mode.andP;  As Figure 2shows, the segment registers in a 286 operating in protected mode are notused directly as base addresses (as in the 8086), but instead are used assegment selectors, which point to descriptors that provide base addresses andother information.andM;On the 286, a protected-mode operating system contains a set of processes anda set of memory segments.andP;  Some segments are global, available to everyprocess, while others are local to a single process.andP;  One bit of the segmentselector (the pointer in the segment register) distinguishes between localand global segments.andP;  The global descriptor table (GDT) describes segmentsavailable to every process, and a per-process local descriptor table (LDT)describes segments private to that process.andM;Each descriptor table entry is 48 bits long (actually 64 bits with 16reserved bits), as shown in Figure 3.andP;  Each entry identifies the 24-bit baseaddress and 16-bit length of a segment in physical memory, the segmentprivilege level, and attributes such as readable, writable, present, andaccessed.andP;  Code and data segments are different; to execute data loaded intoa data segment, the operating system has to create an aliased code segmentdescriptor, pointing at the same address as the data segment descriptor butwith different type bits.andM;In some ways, the 286 privileged mode is an improvement over real mode.andP;  Thephysical address space is increased from 20 to 24 bits, and the virtualaddress per process is increased to 29 bits (a 13-bit local segment index anda 16-bit offset.) A segment can be marked as not present, in which case anyattempt to reference it traps to the operating system.andP;  This permitssegment-based virtual memory, which is used by early versions of OS/2 andsome 286 versions of Unix.andM;Every time a program loads a new value into a segment register, the 286 readsthe selected descriptor table entry (in memory) to find the actual startingaddress, size, and type of the segment.andP;  This lookup is transparent toapplications but it is very slow.andP;  Moving a new value into a segment registerin real mode takes two cycles.andP;  In protected mode the move takes 17 cycles.andO;Since most other instructions are much faster than on the 8086, the speedpenalty for large model code is even greater than it is on the 8086.andM;Huge model code is also more difficult to write, since segments are disjointrather than overlapped.andP;  On the 8086, once you compute a huge address, youcan address a fairly large structure or string beyond that address withouthaving to worry about running off the end of the segment, since the segmentoffset the remainder from dividing the linear address by 16) is always lessthan 16.andP;  In protected mode, the offset of a huge address can be anywhere inthe segment.andP;  That means the segment number of each element in an array mustbe recalculated if the array might cross a segment boundary.andP;  A string orstructure copy might also have to cross a segment boundary, at a considerablecost in speed and complexity, compared to the simple block-move instructionone can use if the structure lies entirely within a single segment.andM;Real and Protected ModesandM;Given the huge investment in MS-DOS (8086) programs, every protected-modeoperating system has to provide some sort of real-mode compatibility.andP;  Anobvious approach would be to set up the segment mapping to mimic real-modeoverlapping segments, but for some unfathomable reason Intel arranged thebits in the segment registers in a way that made this impossible.andM;By far the most peculiar thing about the 286's addressing is Intel's choiceof bit layout in the segment register, which holds the segment selector.andP;  Theway the 286 is designed suggests that its designers actively wanted todiscourage people from emulating real mode in protected mode, perhapsbelieving that would force programmers to use the chip as intended.andM;As shown in Figure 4, the 16-bit segment selector is composed of three parts:the local/global segment table indicator (TI) bit, the requested privilegelevel (RPL), and the segment index for the descriptor table.andP;  Intel put theprivilege level in the low two bits of the segment selector and thelocal/global bit as the next lowest bit.andP;  This means that segment selectors100, 101, 102, and 103 actually refer to the same segment at potentiallydifferent privilege levels.andP;  It also means that segments 100 and 104 are indifferent segment tables, with 100 being global and 104 being local.andM;Had Intel put the privilege and local/global bits at the high end of thesegment selector, consecutive segment selectors would map to differentsegments, and it would be possible to set up the segment tables to implementreal-mode style addressing, with each segment starting 16 bytes after theprevious one.andP;  Although the addressing wouldn't be identical to real mode, itwould be close enough that it would have been far easier to write programsthat run both in real and protected mode.andP;  If it were possible to run mostprograms in either mode, users could have migrated gradually to aprotected-mode operating system, continuing to use their real mode software,instead of switching all at once - or, as is currently most common, not atall.andM;As it is, to be DOS compatible, a 286 operating system bas to run partly inreal mode and partly in protected mode.andP;  It must operate in real mode forcompatibility with existing application programs, but it must operate inprotected mode to access memory beyond 1 Mbyte.andP;  (Actually, it is possible toaccess memory beyond 1 Mbyte from real mode by using the 'secret' LOADALLinstruction.andP;  See;[micro]PR 10/87 p. 12 for details on this instruction,which is widely used despite Intel's refusal to document it publicly.)andM;Getting from real mode to protected mode is easy enough, involving onlysetting up the segment tables and then flipping the protected mode bit in astatus register.andP;  There is no way, however, short of a complete processorreset, to get back to real mode.andP;  This is one of the key oversights in the286 architecture.andP;  In IBM AT-compatible designs, it is possible to reset theprocessor by writing to a keyboard I/O port.andP;  After the reset, the startupROM consults a special location in the nonvolatile configuration RAM to seeif the system was just turned on, or whether it was just returning fromprotected mode.andM;This kludge works, but it is very slow and causes interrupt latency problemssince no interrupts are serviced during the reset sequence.andP;  These problemsoccur even in DOS systems, because it is common to put a RAM disk in memoryaddressed above 1 MB.andP;  The only way to address that memory (without usingLOADALL) is to switch into protected mode, read or write it, and then resetback to real mode.andM;OS/2 and some versions of 286 Unix do the necessary tricks to allow DOSprograms to run in real mode and to switch back and forth, but this'compatibility box' is not very satisfactory, both because of the interruptproblems and because only one DOS program at a time can be run.andP;  Also, theDOS program, running unprotected in real mode, can crash the entire system.andO;(As we will see in part 2, the 386 deals with this problem by adding anentirely new mode to nm DOS programs in protected mode.)andM;Shared Code SegmentsandM;Protected-mode operating systems make it possible to run many programs atonce.andP;  One of the major performance gains promised by the 286 segmentationscheme is shared libraries.andP;  That feature lets many different programs use asingle copy of library code rather than linking separate copies of parts ofthe library into each program.andP;  Unfortunately, the way programs handlesegment numbers makes shared libraries much harder to implement than theyshould be.andM;Since different programs are of different sizes and use differentcombinations of libraries, mapping shared libraries to different segmentnumbers in different processes would be useful.andP;  Although the segmentationhardware makes that easy enough to do, in most cases a library will not workunless it uses the same segment numbers in each process in which it ismapped.andP;  the problem is that the 286 instruction set embeds segment numbersin pure code.andM;Most far CALL instructions have the segment number of the called routinein-line in the instruction.andP;  When addressing data that are not in the defaultDS segment, programs commonly load the segment number of the data from anin-line constant.andP;  This means that if shared library A calls library B orrefers to shared data C, then the calls in library A's code will be bound tothe particular segment numbers where B and C reside at the time that A isfirst loaded.andP;  Thus, every process that shares A bas to put B and C at thesame addresses as the first process did.andP;  Keeping track of the complete listof dependencies is impossibly complex, so in OS/2, the only major operatingsystem supporting 286 shared libraries, whenever a shared library is in usein any process, the segment numbers it uses are reserved in every otherprocess that doesn't use the library.andM;One would think that getting the segment numbers out of pure code andallowing segments to be mapped anywhere shouldn't be too hard.andP;  the problemis hardly new.andP;  Multics and TSS/360 (early virtual-memory timesharingoperating systems) both solved it before 1970, and the 286 makes it possibleboth to make calls via indirect references in unshared data segments, and toload data segment numbers from memory rather than from in-line code.andP;  Thereseem to be two reasons why nobody does that.andP;  the first is inertia: everyMSDOS compiler puts segment numbers in-line, and if you changed it now all ofthe libraries would break.andM;The other, more subtle, reason is the data address bootstrap problem.andP;  Thereis no obvious way to tell a procedure the segment number of the unsharedsegment containing the procedure's segment numbers.andP;  This has been solved inmany ways on other systems - some have a reserved data segment containing anarray of data segments indexed by code segment number, and some have modifiedthe calling sequence so that the caller can find the data segment and pass itto the callee.andP;  Either of these would be possible on the 286, but nocompilers, assemblers, or linkers support them, so OS/2 has no alternativebut to fix and reserve the segment numbers.andM;This isn't an awful problem, but it does suggest that the 286 segmentationscheme wasn't as well thought out as it seemed to Intel's designers.andM;Other 286 Odds and EndsandM;There are other problems in the 286 design.andP;  It is possible to set up the 286to perform a task switch on an interrupt, so an interrupt routine can run inits own address space, and have its context all set up at interrupt time.andO;When the interrupt returns, the interrupt task context is saved, and on thenext interrupt, the interrupt process continues where it left off.andM;This is almost - but not quite - adequate to allow an interrupt routine to bewritten as a coroutine, with the interrupt process written as a main program,rather than the traditional but less convenient method of calling aninterrupt service routine each time the interrupt occurs.andP;  In an interruptcoroutine, there is typically a Dismiss() routine that dismisses theinterrupt and resumes the next time the device interrupts.andP;  Unfortunately,the only way to dismiss a 286 interrupt process is to return from the toplevel routine.andP;  You can't dismiss an interrupt from an inner routine.andP;  Itwould not have been architecturally difficult to provide a `jump out ofinterrupt' instruction, but for some reason Intel didn't.andP;  Again, it's a nicefeature implemented badly.andM;SummaryandM;All this goes to show why the 286 was in some sense (certainly not afinancial one) a failure.andP;  Nearly every 286 is used as a faster 8086, and theconsiderable part of the chip that implements protected mode is completelyunused.andM;In part 2, we'll look at the 386 architecture and see how its new features,particularly 32-bit addressing, paging, and virtual 8086 mode, do and do notaddress the problems in the 80286.andM;(Figures Omitted)</TEXT></DOC>