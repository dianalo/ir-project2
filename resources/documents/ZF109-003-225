<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF109-003-225  </DOCNO><DOCID>09 003 225.andM;</DOCID><JOURNAL>EXE  May 1990 v4 n11 p34(5)* Full Text COPYRIGHT Process Communications Ltd. (England) 1990.andM;</JOURNAL><TITLE>Razor sharp. (OCCAM programming language)</TITLE><AUTHOR>Wexler, John.andM;</AUTHOR><SUMMARY>Occam is a procedural imperative language with variables that canbe assigned values and sequences of instructions.andP;  Data can beused of integer, Boolean, byte and real types.andP;  Extra features areprovided by occam for concurrent and real-time programming.andP;  Thesefeatures include allowing the programmer to specify that severalprocesses be performed concurrently rather than sequentially, andtimers for control of delays.andP;  Conceptually, occam is a process,such as the assignment of a new value to a variable.andP;  Occam cangroup several processes into one larger process, repeatedly up tothe desired depth.andP;  When used with systems that have severalconcurrent processes, occam can use a different channel for eachline of cummunicaiton.andP;  This multi-channel configuration can posea problem in real-time, however.andP;  In comparison with Pascal, occamhas two main restrictions: there is no recursion and all storageallocation is static.andM;</SUMMARY><DESCRIPT>Topic:     Program Development ToolsComparisonPASCALProgramming LanguagesMultiuser SoftwareParallel Processing.andO;Feature:   illustrationcartoonprogram.andO;Caption:   The triangle problem. (program)andM;</DESCRIPT><TEXT>Razor sharp Let's plunge in at the deep end.andP;  Take a look at my solution tothe Triangle Problem, shown in Figure 1.andP;  There you are: a fragment of anoccam program.andP;  There are plenty of recognisable features - the words IF, ANDand FOR; strings enclosed in double quotes; procedure calls, with parametersenclosed in parentheses; arrays subscripted using [ and ]; and declarations,each followed by a colon :, prefixed to the body of the text.andP;  In fact, itprobably does not look as strange as you expected of 'that odd language thatthey use with transputers'.andP;  Clearly it is a tidily laid out program, in afamiliar imperative language, and not at all weird like Prolog (declarativelogic) or Eiffel (object-oriented) or SML (functional) or LISP (listprocessing).andP;  'No surprises, no complications' are the guiding principles ofoccam - and this is how it came by its name.andP;  The fourteenth-century Englishphilosopher, William of Occam, coined the motto which is known as Occam'sRazor: non sunt multiplicanda entia preater necessitatem ('never multiplyentities unnecessarily' ie 'keep it simple').andM;OriginsandM;These principles were not selected for fun, academic interest, or even loveof Latin.andP;  They were essential for the commercial success of a very majorproject: the development and marketing of the transputer.andP;  To attractattention, the product had to be revolutionary, it had to be targeted atseveral different markets, and it had to work better than its competitors.andO;The 'revolutionary' aspect would lie in its unprecedented support forconcurrency and multiprocessor working.andP;  Diversity of marketing sectors meantthat it had to suit applications from single processor embedded systems to1000 processor supercomputers.andP;  As for quality, it had to be very goodindeed, and it had to be right first time.andP;  All of that meant that it couldnot be left solely in the hands of hardware engineers.andP;  Alongside the inputsfrom manufacturing technology, market analysis, logic design and so on, thedesign process had to accept a major contribution from the software side:system designers, compiler writers and, above all, theoreticians.andM;The chosen approach was to decide first which functions were required, andthen to devise a machine-independent language which could express those veryprecisely.andP;  Only after that would the processor be designed, to implementthat language as efficiently as possible.andP;  In this way, it was hoped toembody 'concept' in silicon with guaranteed correctness.andP;  The language, ofcourse, became occam.andM;Now, up to this point, the idea of end users actually writing realapplications in occam has not been mentioned; but a language which is simple,precise and susceptible to analysis is rather attractive for seriousprogramming, especially if the user is also having to come to grips with thenovel and tricky ideas of concurrency.andM;Inmos marketed the transputer and occam as a package.andP;  With hindsight, it iseasy to see that this put some people off transputers, and made it easy forothers to ignore occam.andP;  Fortunately, however, both have survived, and thingslook different now.andP;  Ironically, the turn-around has been much helped by thecreation of transputer compilers for other languages, such as C, FORTRAN andPascal.andP;  Occam depends on the transputer; the transputer needs to supportconventional languages to succeed; hence occam's survival is partiallyattributable to the likes of C.andM;The languageandM;Occam is procedural imperative language with variables to which you canassign values (using the : = symbol), sequences of instructions to be obeyedone after another, procedures and functions, and so on.andP;  It handles data ofinteger, Boolean, byte (character) and real types.andP;  You can have literals,named constants, variables and arrays (a string is handled as an array ofbytes).andP;  It provides extra features for concurrent and real-time programming:primarily for specifying that several processes can be performed concurrentlyrather than in sequence, and for passing messages between them.andP;  There aretimers for controlling delays.andP;  All in all, there are very few basic ideas,and they are all very simple.andP;  Thus the official definition of occam isexceptionally compact, and even lucid.andP;  However, the ideas can all becombined, limited only by the programmer's ingenuity, to make up acomprehensive set of facilities for general as well as concurrentprogramming.andM;To many programmers in C and Pascal, the oddest thing about occam is that youcannot write it in free format.andP;  The indentation of each line of text is veryimportant, and affects the meaning of the program.andP;  These indentation rulesactually ensure that a program's layout is significant to the human reader aswell as to a compiler.andP;  In effect, the programmer is forced to follow what,in Pascal, would be 'good practice'.andP;  Furthermore, there is a 'foldingeditor' for occam, which understands and supports these 'indentation rules',so it is not difficult to follow them.andP;  Incidentally, this is one of manycases where what is 'good practice' in other languages is made obligatory inoccam.andM;At the heart of the occam is the concept of a 'process'.andP;  An example of avery simple process is the assignment of a new value to a variable is.andP;  Justas other languages have simple 'statements' which can be grouped together tomake 'compound statements' - perhaps between BEGIN and END - so occam cangroup several processes into one larger process (and so on, to any desireddepth).andP;  As in Pascal, you can ask for the processes to be performed oneafter another in a particular order.andP;  You write the word SEQ (for 'sequence')instead of BEGIN, followed by the processes in order.andP;  C programmers, whosnear at Pascal for its surfeit of BEGINs and ENDs, will be impressed by thefact that the indentation of source text shows which processes are controlledby the SEQ, so there is no need for an END.andM;ConcurrencyandM;There are, however, other ways to group processes.andP;  You can ask for severalof them to be performed in parallel, simply by writing PAR instead of SEQ.andO;That means that they can be done in any order, or perhaps by doing a bit ofone and a bit of another until they have all been completed.andP;  If you havemultiple processors, of course, they can be genuinely concurrent.andP;  Thequestion then arises of how information can be shared between concurrentprocesses.andP;  In occam, they cannot share variables, but they can pass datafrom one to another through 'channels'.andP;  In fact the only primitiveprocesses, apart from assignment, are the message-passing 'input' and'output'.andM;CHAN OF INT forward: PAR INT x: SEQ x := 12 forward ! x INT y, z: SEQ forward? z y := z + 1andM;Here we have two processes, to be performed concurrently (they are writtenafter the PAR).andP;  Each of the two consists of a SEQuence of smaller processes.andO;The first contains an assignment, followed by an output, denoted by the !andO;symbol.andP;  The other consists of an input (marked by ?) followed by anassignment.andP;  On the first line, forward is declared as a channel which cancarry messages consisting of single integers.andP;  forward is in scope throughthe whole of the 'parallel' construct.andP;  'Declarations are prefixed to aprocess, and apply to the whole of that process, but no further.andP;  Similarly,the single integer variable x is in scope for the three lines beneath itsdeclaration.andM;What will happen when we run this?andP;  The interesting part is the input/outputpair.andP;  When one process does forward ! x and the other does forward ? z, thevalue of x is transmitted from one process to the other and stored in z.andP;  Theeffect is like an assignment z :=x.andP;  However, we could not write z :=x,because x belongs to one process and z to the other, and processes may notshare variables.andP;  We could, perhaps, describe the effect of the input and theoutput as a 'distributed assignment.'andM;The first SEQ forces x :=12 to take place before the output forward ! x.andO;Similarly, forward ? z will happen before y :=z + 1.andP;  But will x :=12 startbefore or after forward ? z?andP;  It's impossible to say!andP;  This is one of thedifficulties with concurrency - you never know exactly in what order thingswill happen.andP;  Then how can I claim that occam is precise and unambiguous?andP;  Itturns out that is simply does not matter which one start first.andP;  Regardlessof when forward ? z starts, it cannot finish until the other process has doneforward ! x.andM;There is a momentary synchronisation between the two processes.andP;  Whicheverprocess comes first to attempt an input or an output, that process will besuspended until the other participant performs the complementary input oroutput.andP;  (Putting it another way, the channel does not buffer messages.)andM;Multi-channelandM;In systems of many concurrent processes, it often happens that one processhas to communicate with a number of others.andP;  This is easily done in occam, byusing a different channel for each line of communication.andP;  In real systems,however, there is a complication: a process which has to be able to handleinput from several others may not 'know' which one is going to offer inputnext.andP;  It must, therefore, attempt an input for more than one channel.andP;  Itcannot use the ? operator in a SEQ compound process, so occam provides forthis with a construction marked by the word ALT (for 'alternative').andM;ALT fromTom ? a x := a + 1 fromDick ? a x := a - 1 fromHarry ? b SEQ x := x +b a := 1andM;After ALT, you list all of the possible inputs, following each one with theprocess that is to be performed if that input is received.andP;  The whole ALTprocess will accept just one of the inputs, and perform the one correspondingprocess.andP;  Which of the inputs will be chosen?andP;  Whichever one becomesavailable first.andP;  If more than one is ready when the ALT is started, then anyof them will be chosen; the others will remain available, and can be acceptedsome time in the future.andM;The strange thing about ALT is that it introduces a non-determinacy into thelanguage.andP;  If a program contains even one ALT, it is impossible to predicthow it will behave!andP;  And do I still claim that occam is precise andunambiguous?andP;  I do - but not, perhaps, in the sense which sequentialprogrammers would like.andP;  A degree of non-determinacy is unavoidable inconcurrent systems.andP;  Occam confines it to one very clear and simple part ofthe language, and gives you the best chance of understanding it and copingwith it - it is as good as you can get in a difficult situation.andM;Besides SEQ and PAR and ALT, occam offers two more groupings of processes -WHILE and IF.andP;  On the whole, these behave pretty much what you would expect,although IF does differ from the norm.andP;  In most languages, the basic IFconstruction says 'If condition THEN do this ELSE do that'.andP;  You build upmore elaborate control structures by compounding 'IFs within IFs'.andP;  In occam,IF can be followed by a list of as many conditions as you please, with aprocess corresponding to each condition.andP;  The list of conditions is scanned,until one is found which is TRUE; the process which corresponds to thatcondition is performed.andP;  This means that there is less need for nested IFs.andO;However, you do have to write 'IF condition THEN do this ELSE do nothing'when you just mean 'IF condition THEN do this'.andP;  It looks like this:andM;IF a=0 x := x + 1 TRUE SKIPandM;SEQ, PAR, ALT, and IF can all be followed by any number of processes.andP;  Thisleads to an interesting generalisation of the loop, which is called a'replication' in occam:andM;SEQ i=0 FOR 3 x := x + p [i]andM;which is equivalent toandM;SEQ x := x + p [0] x := x + p [1] x := x + p [2]andM;which is just like a conventional loop.andP;  You can also writeandM;PAR i=0 FOR 3 out [i] ! idandM;to do three processes in parallel - in this case, sending the same data outthrough three different channels (out is an array of channels).andP;  Naturally,you can apply replication to IF in exactly the same way, like this:andM;IF i=0 FOR 3 name [i] andless;andgt;pattern [i] mismatch := iandM;meansandM;IF name [0] andless;andgt;pattern [0] mismatch := 0 name [1] andless;andgt;pattern [1] mismatch := 1name [2] andless;andgt;pattern [2] mismatch := 2andM;which scans two arrays, and assigns the index of the first non-matchingelements to mismatch.andP;  In other languages, this would be a construction whereyou would be tempted to use GOTO to get out of the loop when the firstmismatch had been found; or you would find some other more of less subtlemechanism to express what is really quite a simple requirement.andP;  None of thatis necessary in occam; in fact, given that there is also WHILE construction(and a CASE), occam needs no GOTO at all.andP;  It simply is not in the language!andM;The absence of GOTO is one feature which makes it possible to analyse occamprograms with logic.andP;  Another is a total ban on side-effects of all kinds.andO;All storage allocation is on the stack; there is no heap, and no equivalentof C's malloc ().andP;  Pointer variables are not used, but there is somethingcalled an 'abbreviation', which serves some of the same purposes without anyrisk of such notorious pointer-related bugs as 'dangling references' and'conflicting usage'.andP;  Occam is extremely rigorous about data types, and willnever do a type conversion unless the user explicitly asks for it.andP;  There arecomprehensive rules forbidding potentially risky sharing of data channelsbetween concurrent processes.andP;  All of this means the occam programs can beextensively checked during compilation, saving a great deal of debugginglater.andM;RestrictionsandM;Occam 2 has two principle restrictions, by comparison with (say) Pascal: ithas no recursion, and all storage allocation is static (that is, alladdresses can be calculated at compile time, or at least before the programis loaded).andP;  There are two reasons for this.andP;  First, it is very hard to dorecursion and dynamic storage allocation on behalf of a number of processeswhich are running concurrently and asynchronously, and current transputersgive no hardware support to make that any easier.andP;  Second, if one allowedthem, 'running out of store' could happen at any time, unpredictably, andthat would make it impossible to guarantee the behaviour of real-timesafety-critical systems.andM;Occam also lacks 'unions', 'structures', 'records' or the like and in fact ithas no way for the programmer to define new 'types' of data.andM;Now we can look back at the 'triangle program'.andP;  The main program iscontrolled by SEQ.andP;  Within that, there are three procedure calls on Readn toaccept the input, followed by a replicated SEQ - a loop - for printing outthe three given numbers, and finally an IF to apply the tests.andP;  This IF hasfour separate tests for the four conditions: 'not a triangle', 'equilateral','isosceles' and 'scalene'.andP;  Two of those conditions - 'not a triangle' and'isosceles' - are themselves implemented by replicated IFs.andP;  There areabbreviations a, b and c for the elements of the side array which illustratethe use of this technique.andP;  I also use the abbreviation (sic) OTHERWISE forTRUE to clarify the final condition in an IF process.andM;John Wexler works at the Edinburgh University Computing Service, where he isconnected with the Edinburgh Concurrent Supercomputing Project, which has aMeiko Computing Surface comprising of around 500 transputers.andM;If you want to find out more about occam, he recommends his own bookConcurrent Programming in occam 2 (pub Ellis Horwood, ISBN 0-7458-0394-6) andalso the occam 2 Reference Manual (pub Prentice Hall, ISBN 0-13-629312-3).andO;If you prefer a really heavy read, he suggests getting a book on Ada instead.andM;If you have a favorite, non-mainstream language, and you would like to writeabout it for 'The Third Side' series, please write to The Editor, at theaddress given on page 2, for a copy of the guidelines.andO;</TEXT></DOC>