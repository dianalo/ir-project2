<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-585-454  </DOCNO><DOCID>07 585 454.andM;</DOCID><JOURNAL>Microsoft Systems Journal  Sept 1989 v4 n5 p1(13)* Full Text COPYRIGHT Microsoft Corp. 1989.andM;</JOURNAL><TITLE>Design goals and implementation of the new High Performance FileSystem. (includes related article on B-Trees and B+ Trees)</TITLE><AUTHOR>Duncan, Roy.andM;</AUTHOR><SUMMARY>The High Performance File System (HPFS) enhancement to OS/2Version 1.2 solves all the problems of the File Allocation Table(FAT) file system and is designed to meet the demands expectedinto the next few decades.andP;  HPFS not only serves as a way toorganize data on random access block storage devices, but is alsoa software module that translates file-oriented requests fromapplications programs to device drivers.andP;  HPFS is also an exampleof an installable file system, which makes it possible to accessseveral incompatible volume structures on the same OS/2 systemsimultaneously.andP;  Excellent throughput is achieved by the use ofadvanced data structures such as intelligent caching, read-aheadand write-behind.andP;  Disk space is managed more economically by theuse of sectoring.andP;  HPFS also includes greatly improved faulttolerance.andP;  Applications programs need only simple modificationsto make use of extended attributes and long filenames.andM;</SUMMARY><DESCRIPT>Product:   OS-2 Extended Edition 1.2 (Operating system) (productenhancement).andO;Topic:     OS-2File ManagementEnhancementsData StructuresDisk Space AllocationSectoring.andO;Feature:   illustrationtablechart.andO;Caption:   Comparison of FAT and High Performance File System. (table)Overall structure of an HPFS volume. (chart)Overall structure of an Fnode. (chart)andM;</DESCRIPT><TEXT>THE HPFS IS A WAY OF ORGANIZING DATA ON A RANDOM ACCESS BLOCK STORAGE DEVICE.andO;IT IS ALSO A SOFTWARE MODULE THAT TRANSLATES FILE-ORIENTED REQUESTS FROM ANAPPLICATION PROGRAM INTO MORE PRIMITIVE REQUESTS THAT A DEVICE DRIVER CANUNDERSTAND.andM;The High Performance File System (hereafter HPFS), which is making its firstappearance in the OS/2 operating systemVersion 1.2, had its genesis in thenetwork division of Microsoft and was designed by Gordon Letwin, the chiefarchitect of the OS/2 operating system.andP;  The HPFS has been designed to meetthe demands of increasingly powerful PCs, fixed disks, and networks for manyyears to come and to serve as a suitable platform for object-orientedlanguages, applications, and user interfaces.andM;The HPFS is a complex topic because it incorporates three distinct yetinterrelated file system issues.andP;  First, the HPFS is a way of organizing dataon a random access block storage device.andP;  Second, it is a software modulethat translates fi Ie-oriented requests from an application program into moreprimitive requests that a device driver can understand, using a variety ofcreative techniques to maximize performance.andP;  Third, the HPFS is a practicalillustration of an important new OS/2 feature known as installable filesystems.andM;This article introduces the three aspects of the HPFS.andP;  But first, it putsthe HPFS in perspective by reviewing some of the problems that led to thesystem's existence.andM;FAT File SystemandM;The so-called FAT file system, which is the file system used in all versionsof the MS-DOS&quot;' operating system to date and in the first two releases ofOS/2' (Versions 1.0 and 1.1), has a dual heritage in Microsoft's earliestprogramming language products and the Digital Research(R) CP/M(R) operatingsystem-software originally written for 8080-based and Z-80-basedmicrocomputers.andP;  It inherited characteristics from both ancestors that haveprogressively tumed into handicaps in this new era of multitasking, protectedmode, virtual memory, and huge fixed disks.andM;The FAT file system revolves around the File Allocation Table for which it isnamed.andP;  Each logical volume has its own FAT, which serves two importantfunctions: it contains the allocation information for each file on the volumein the form of linked lists of allocation units (clusters, which arepower-of-2 multiples of sectors) and it indicates which allocation units arefree for assignment to a file that is being created or extended.andM;The FAT was invented by Bill Gates and Marc McDonald in1977 as a method ofmanaging disk space in the NCR version of standalone Microsoft* Disk BASIC.andO;Tim Paterson, at that time an employee of Seattle (R) Computer Products(SCP), was introduced to the FAT concept when his company shared a booth withMicrosoft at the National Computer Conference in 1979.andP;  Paterson subsequentlyincorporated FATs into the file system of 86-DOS, an operating system forSCP's S-100 bus 8086 CPU boards.andP;  86-DOS was eventually purchased byMicrosoft and became the starting point for MS-DOS2 Version 1.0, which wasreleased for the original IBM&quot; PC in August 1981.andM;When the FAT was conceived, it was an excellent solution to disk management,mainly because the floppy disks on which it was used were rarely larger thanI Mb.andP;  On such di s, the FAT was small enough to be held in memory at alltimes, allowing very fast random access to any part of any file.andP;  This provedfar superior to the CP/M method of tracking disk space, in which theinformation about the sectors assigned to a file might be spread across manydirectory entries, which were in turn scattered randomly throughout the diskdirectory.andM;When applied to fixed disks, however, the FAT began to look more like a bugthan a feature.andP;  It became too large to be held entirely resident and had tobe paged into memory in pieces; this paging resulted in many superfluous diskhead movements as a program was reading through a file and degraded systemthroughput.andP;  In addition, because the information about free disk space wasdispersed across many sectors of FAT, it was impractical to allocate filespace contiguously, and file fragmentation became another obstacle to goodperformance.andP;  Moreover, the use of relatively large clusters on fixed disksresulted in a lot of dead space, since an average of one-half cluster waswasted for each file.andP;  (Some network servers use clusters as large as 64Kb.)andM;The FAT file system's restrictions on naming files and directories areinherited from CP/M.andP;  When Paterson was writing 86DOS, one of his primaryobjectives was to make programs easy to port from CP/M to his new operatingsystem.andP;  He therefore adopted CP/M's limits on filenames and extensions sothe critical fields of 86-DOS File Control Blocks (FCBs) would look almostexactly like those of CP/M.andP;  The sizes of the FCB filename and extensionfields were also propagated into the structure of disk directory entries.andP;  Indue time, 86-DOS became MSDOS and application programs for MS-DOSproliferated beyond anyone's wildest dreams.andP;  Since most of the earlyprograms depended on the structure of FCBs, the 8.3 format for filenamesbecame irrevocably locked into the system.andM;During the last couple of years, Microsoft and IBM have made valiant attemptsto prolong the useful life of the FAT file system by lifting the restrictionson volume sizes, improving allocation strategies, caching pathnames, andmoving tables and buffers into expanded memory.andP;  But these can only beregarded as temporizing measures, because the fundamental data structuresused by the FAT file system are simply not well suited to large random accessdevices.andM;The HPFS solves the FAT file system problems mentioned here and many others,but it is not derived in any way from the FAT file system.andP;  The architect ofthe HPFS started with a clean sheet of paper and designed a file system thatcan take full advantage of a multitasking environment, and that will be ableto cope with any sort of disk device likely to arrive on microcomputersduring the next decade.andM;HPFS Volume StructureandM;HPFS volumes are a new partition type-type 7-and can exist on a fixed diskalongside of the several previously defined FAT partition types.andO;IBM-compatible HPFS volumes use a sector size of 512 bytes and have a maximumsize of 2199Gb (2&quot; sectors).andP;  Although there is no particular reason whyfloppy disks can't be formatted as HPFS volumes, Microsoft plans to stickwith FAT file systems on floppy disks for the foreseeable future.andP;  (Thisensures that users will be able to transport files easily between MS-DOS andOS/2 systems.)andM;An HPFS volume has very few fixed structures (Figure 1).andP;  Sectors 0-15 of avolume (8Kb) are the BootBlock and contain a volume name, 32-bit volume ID,and a disk bootstrap program.andP;  The bootstrap is relatively sophisticated (byMS-DOS standards) and can use the HPFS in a restricted mode to locate andread the operating system files wherever they might be found.andM;Sectors 16 and 17 are known as the SuperBlock and the SpareBlockrespectively.andP;  The SuperBlock is only modified by disk maintenance utilities.andO;It contains pointers to the free space bitmaps, the bad block list, thedirectory block band, and the root directory.andP;  It also contains the date thatthe volume was last checked out and repaired with CHKDSK/F.andP;  The SpareBlockcontains various flags and pointers that will be discussed later; it ismodified, although infrequently, as the system executes.andM;The remainder of the disk is divided into 8Mb bands.andP;  Each band has its ownfree space bitmap in which a bit represents each sector.andP;  A bit is 0 if thesector is in use and I if the sector is available.andP;  The bitmaps are locatedat the head or tail of a band so that two bitmaps are adjacent betweenalternate bands.andP;  This allows the maximum contiguous free space that can beallocated to a file to be 16Mb.andP;  One band, located at or toward the seekcenter of the disk, is called the directory block band and receives specialtreatment (more about this later).andP;  Note that the band size is acharacteristic of the current implementation and may be changed in laterversions of the file system.andM;Files and FnodesandM;Every file or directory on an HPFS volume is anchored on a fundamental filesystem object called an Fnode (pronounced &quot;eff node&quot;).andP;  Each Fnode occupies asingle sector and contains control and access history information usedinternally by the file system, extended attributes and access control lists(more about this later), the length and the first 15 characters of the nameof the associated file or directory, and an allocation structure (Figure 2).andO;An Fnode is always stored near the file or directory that it represents.andM;The allocation structure in the Fnode can take several forms, depending onthe size and degree of contiguity of the file or directory.andP;  The HPFS views afile as a collection of one or more runs or extents of one or more contiguoussectors.andP;  Each run is symbolized by a pair of doublewords-a 32-bit startingsector number and a 32-bit length in sectors (this is referred to asrunlength encoding).andP;  From an application program's point of view, theextents are invisible; the file appears as a seamless stream of bytes.andM;The space reserved for allocation information in an Fnode can hold pointersto as many as eight runs of sectors of up to 16Mb each.andP;  (This maximum runsize is a result of the band size and free space bitmap placement only; it isnot an inherent limitation of the file system.) Reasonably small files orhighly contiguous files can therefore be described completely within theFnode (Figure 3).andM;HPFS uses a new method to represent the location of files that are too largeor too fragmented for the Fnode and consist of more than eight runs.andP;  TheFnode's allocation structure becomes the root for a B+ Tree of allocationsectors, which in tum contain the actual pointers to the file's sector runs(see Figure 4 and the sidebar, &quot;BTrees and B+ Trees&quot;).andP;  The Fnode's root hasroom for 12 elements.andP;  Each allocation sector can contain, in addition tovarious control information, as many as 40 pointers to sector runs.andO;Therefore, a two-level allocation B+ Tree can describe a file of 480 (12*40)sector runs with a theoretical maximum size of 7.68Gb (12*40*16Mb) in thecurrent implementation (although the 32-bit signed offset parameter forDosChgFilePtr effectively limits file sizes to 2Gb).andM;In the unlikely event that a two-level B+ Tree is not sufficient to describea highly fragmented file, the file system will introduce additional levels inthe tree as needed.andP;  Allocation sectors in the intermediate levels can holdas many as 60 internal (nonterminal) B+ Tree nodes, which means that thedescriptive ability of this structure rapidly grows to numbers that arenearly beyond comprehension.andP;  For example, a threelevel allocation B+ Treecan describe a file with as many as 28,800 (12*60*40) sector runs.andM;Run-length encoding and B+ Trees of allocation sectors are a memory-efficientway to specify a file's size and location, but they have other significantadvantages.andP;  Translating a logical file offset into a sector number isextremely fast: the file system just needs to traverse the list (or B+ Treeof lists) of run pointers until it finds the correct range.andP;  It can thenidentify the sector within the run with a simple calculation.andP;  Run-lengthencoding also makes it trivial to extend the file logically if the newlyassigned sector is contiguous with the file's previous last sector; the filesystem merely needs to increment the size doubleword of the file's last runpointer and clear the sector's bit in the appropriate freespace bitmap.andM;DirectoriesandM;Directories, like files, are anchored on Fnodes.andP;  A pointe to the Fnode forthe root directory is found in the SuperBlock.andP;  The Fnodes for directoriesother than the root are reache through subdirectory entries in their parentdirectories.andM;Directories can grow to any size and are built up from 2Kb directory blocks,which are allocated as four consecutive sectors on the disk.andP;  The file systemattempts to allocate directory blocks in the directory band, which is locatedat or near the seek center of the disk.andP;  Once the directory band is full, thedirectory blocks are allocated wherever space is available.andM;Each 2Kb directory block contains from one to many directory entries.andP;  Adirectory entry contains several fields, including time and date stamps, anFnode pointer, a usage count for use by disk maintenance programs, the lengthof the file or directory name, the name itself, and a B-Tree pointer.andP;  Eachentry begins with a word that contains the length of the entry.andP;  Thisprovides for a variable amount of flex space at the end of each entry, whichcan be used by special versions of the file system and allows the directoryblock to be traversed very quickly (Figure 5).andM;The nuniber of entries in a directory block varies with the length of names.andO;If the average filename length is 1 3 characters, an average directory blockwill hold about 40 entries.andP;  The entries in a directory block are sorted bythe binary lexical order of their name fields (this happens to put them inalphabetical order for the U.S.andP;  alphabet).andP;  The last entry in a directoryblock is a dummy record that marks the end of the block.andM;When a directory gets too large to be stored in one block, it increases insize by the addition of 2Kb blocks that are organized as a B-Tree&quot;B-Trees andB+ Trees&quot;).andP;  When searching for a specific name, the file system traverses adirectory block until it either finds a match or finds a name that islexically greater than the target.andP;  In the latter case, the file systemextracts the BTree pointer from the entry.andP;  If there is no pointer, thesearch failed; otherwise the file system follows the pointer to the nextdirectory block in the tree and continues the search.andM;A little back-of-the-envelope arithmetic yields some impressive statistics.andO;Assuming 40 entries per block, a two-level tree of directory blocks can hold1640 directory entries and a three-level tree can hold an astonishing 65,640entries.andP;  In other words, a particular file can be found (or shown not toexist) in a typical directory of 65,640 files with a maximum of three diskhits-the actual number of disk accesses depending on cache contents and thelocation of the file's name in the directory block B-Tree.andP;  That's quite acontrast to the FAT file system, where in the worst case more than 4000sectors would have to be read to establish that a file was or was not presentin a directory containing the same number of files.andM;The B-Tree directory structure has interesting implications beyond its effecton open and find operations.andP;  A file creation, renaming, or deletion mayresult in a cascade of complex operations, as directory blocks are added orfreed or names are moved from one block to the other to keep the treebalanced.andP;  In fact, a rename operation could theoretically fail for lack ofdisk space even though the file itself is not growing.andP;  In order to avoidthis sort of disaster, the HPFS maintains a small pool of free blocks thatcan be drawn from in a directory emergency; a pointer to this pool of freeblocks is stored in the SpareBlock.andM;Extended AttributesandM;File attributes are information about a file that is maintained by theoperating system outside the file's overt storage area.andP;  The FAT file systemsupports only a few simple attributes (read only, system, hidden, andarchive) that are actually stored as bit flags in the file's directory entry;these attributes are inspected or modified by special function calls and arenot accessible through the normal file open, read, and write calls.andM;The HPFS supports the same attributes as the FAT file system for historicalreasons, but it also supports a new form of fileassociated, highlygeneralized information called Extended Attributes (EAs).andP;  Each EA isconceptually similar to an environment variable, taking the formandM;name- -valueandM;except that the value portion can be either a null-terminated (ASCIIZ) stringor binary data.andP;  In OS/2 1.2, each file or directory can have a maximum of64Kb of EAs attached to it.andP;  This limit may be lifted in a later release ofOS/2.andM;The storage method for EAs can vary.andP;  If the EAs associated with a given fileor directory are small enough, they will be stored right in the Fnode.andP;  Ifthe total size of the EAs is too large, they are stored outside the Fnode insector runs, and a B+ Tree of allocation sectors can be created to describethe runs.andP;  If a single EA gets too large, it can be pushed outside the Fnodeinto a B+ Tree of its own.andM;The kernel API functions DosQFileInfo and DosSetFileInfo have been expandedwith new information levels that allow application programs to manipulateextended attributes for files.andP;  The new functions DosQPathInfo andDosSetPathInfo are used to read or write the EAs associated with arbitrarypathnames.andP;  An application program can either ask for the value of a specificEA (supplying a name to be matched) or can obtain all of the EAs for the fileor directory at once.andM;Although application programs can begin to take advantage of EAs as soon asthe HPFS is released, support for EAs is an essential component inMicrosoft's long-range plans for object-oriented file systems, Information ofalmost any type can be stored in EAs, ranging from the name of theapplication that owns the file to names of dependent files to icons toexecutable code.andP;  As the HPFS evolves, its facilities for manipulating EAsare likely to become much more sophisticated.andP;  It's easy to imagine, forexample, that in future versions the API might be extended with EA functionsthat are analogous to DosFindFirst and DosFindNext and EA data might getorganized into B -Trees.andM;I should note here that in addition to EAs, the LAN Manager version of HPFSwill support another class of file-associated information called AccessControl Lists (ACLs).andP;  ACLs have the same general appearance as EAs and aremanipulated in a similar manner, but they are used to store access rights,passwords, and other information of interest in a networking multiuserenvironment.andM;Installable File SystemsandM;Support for installable file system has been one of the most eagerlyanticipated features of OS/2 Version 1.2.andP;  It will make it possible to accessmultiple incompatible volume structures-FAT, HPFS, CD ROM, and perhaps evenUNIX(R)--on the same OS/2 system at the same time, will simplify the life ofnetwork implementors, and will open the door to rapid file system evolutionand innovation.andP;  Installable file systems are, however, only relevant to theHPFS insofar as they make use of the HPFS optional.andP;  The FAT file system isstill embedded in the OS/2 kernel, as it was in OS/2 1.0 and 1.1, and willremain there as the compatibility file system for some time to come.andM;An installable file system driver (FSD) is analogous in many ways to a devicedriver.andP;  An FSD resides on the disk in a file that is structured like adynamic-link library (DLL), typically with a SYS or IFS extension, and isloaded during system initialization by IFS= statements in the CONFIG.SYSfile.andP;  IFS= directives are processed in the order they are encountered andare also sensitive to the order of DEVICE= statements for device drivers.andO;This lets you load a device driver for a nonstandard device, load a filesystem driver from a volume on that device, and so on.andM;Once an FSD is installed and initialized, the kernel communicates with it interms of logical requests for file opens, reads, writes, seeks, closes, andso on.andP;  The FSD translates these requests-using control structures and tablesfound on the volume itself-into requests for sector reads and writes forwhich it can call special kemel entry points called File System Helpers(FsHlps).andP;  The kemel passes the demands for sector 1/0 to the appropriatedevice driver and retums the results to the FSD (Figure 6).andM;The procedure used by the operating system to associate volumes with FSDs iscalled dynamic mounting and works as follows.andP;  Whenever a volume is firstaccessed, or after it has been locked for direct access and then unlocked(for example, by a FORMAT operation), OS/2 presents identifying informationfrom the volume to each of the FSDs in tum until one of them recognizes theinformation.andP;  When an FSD claims the volume, the volume is mounted and allsubsequent file 1/0 requests for the volume are routed to that FSD.andM;Performance IssuesandM;The HPFS attacks potential bottlenecks in disk throughput at multiple levels.andO;It uses advanced data structures, contiguous sector allocation, intelligentcaching, read-ahead, and deferred writes in order to boost performance.andM;First, the HPFS matches its data structures to the task at hand:sophisticated data structures (B-Trees and B+ Trees) for fast random accessto filenames, directory names, and lists of sectors allocated to files ordirectories, and simple compact data structures (bitmaps) for locating chunksof free space of the appropriate size.andP;  The routines that manipulate thesedata structures are written in assembly language and have been painstakinglytuned, with special focus on the routines that search the freespace bitmapsfor patterns of set bits (unused sectors).andM;Next, the HPFS's main goal -its prime directive, if you will- is to assignconsecutive sectors to files whenever possible.andP;  The time required to movethe disk's read/write head from one track to another far outweighs the otherpossible delays, so the HPFS works hard to avoid or minimize such headmovements by allocating file space contiguously and by keeping controlstructures such as Fnodes and freespace bitmaps near the things they control.andO;Highly contiguous files also help the file system make fewer requests of thedisk driver for more sectors at a time, allow the disk driver to exploit themultisector transfer capabilities of the disk controller, and reduce thenumber of disk completion interrupts that must be serviced.andM;Of course, trying to keep files from becoming fragmented in a multitaskingsystem in which many files are being updated concurrently is no easy chore.andO;One strategy the HPFS uses is to scatter newly created files across thedisk-in separate bands, if possible-so that the sectors allocated to thefiles as they are extended will not be interleaved.andP;  Another strategy is topreallocate approximately 4Kb of contiguous space to the file each time itmust be extended and give back any excess when the file is closed.andM;If an application knows the ultimate size of a new file in advance, it canassist the file system by specifying an initial file allocation when itcreates the file.andP;  The system will then search all the free space bitmaps tofind a run of consecutive sec tors large enough to hold the file.andP;  Thatfailing, it will search for two runs that are half the size of the file, andso on.andM;The HPFS relies on several different kinds of caching to minimize the numberof physical disk transfers it must request.andP;  Naturally, it caches sectors, asdid the FAT file system.andP;  But unlike the FAT file system, the HPFS can managevery large caches efficiently and adjusts sector caching on a perhandle basisto the manner in which a file is used.andP;  The HPFS also caches pathnames anddirectories, transforming disk directory entries into an even more compactand efficient inmemory representation.andM;Another technique that the HPFS uses to improve performance is to prereaddata it believes the program is likely to need.andP;  For example, when a file isopened, the file system will preread and cache the Fnode and the first fewsectors of the file's contents.andP;  If the file is an executable program or thehistory information in the file's Fnode shows that an open operation hastypically been followed by an immediate sequential read of the entire file,the file system will preread and cache much more of the file's contents.andO;When a program issues relatively small read requests, the file system alwaysfetches data from the file in 2Kb chunks and caches the excess, allowing mostread operations to be satisfied from the cache.andM;Finally, the OS/2 operating system's support for multitasking makes itpossible for the HPFS to rely heavity on lazy writes (sometimes calleddeferred writes or write behind) to improve performance.andP;  When a programrequests a disk write, the data is placed in the cache and the cache bufferis flagged as dirty (that is, inconsistent with the state of the data ondisk).andP;  When the disk becomes idle or the cache becomes saturated with dirtybuffers, the file system uses a captive thread from a daemon process to writethe buffers to disk, starting with the oldest data.andM;In general, lazy writes mean that programs run faster because their readrequests will almost never be stalled waiting for a write request tocomplete.andP;  For programs that repeatedly read, modify, and write a smallworking set of records, it also means that many unnecessary or redundantphysical disk writes may be avoided.andP;  Lazy writes have their dangers, ofcourse, so a program can defeat them on a per-handle basis by setting thewritethrough flag in the OpenMode parameter for DosOpen, or it can commitdata to disk on a perhandle basis with the DosBufReset function.andM;Fault ToleranceandM;The HPFS's extensive use of lazy writes makes it imperative for the HPFS tobe able to recover gracefully from write errors under any but the most direcircumstances.andP;  After all, by the time a write is known to have failed, theapplication has long since gone on its way under the illusion that it hassafely shipped the data into disk storage.andP;  The errors may be detected by thehardware (such as a &quot;sector not found&quot; error returned by the disk adapter),or they may be detected by the disk driver in spite of the hardware during aread-after-write verification of the data.andM;The primary mechanism for handling write errors is called a hotfix.andP;  When anerror is detected, the file system takes a free block out of a reservedhotfix pool, writes the data to that block, and updates the hotfix map.andP;  (Thehotfix map is simply a series of pairs of doublewords, with each paircontaining the number of a bad sector associated with the number of itshotfix replacement.andP;  A pointer to the hotfix map is maintained in theSpareBlock.) A copy of the hotfix map is t written to disk, and a wamingmessage is displayed to let the user know that all is not well with the diskdevice.andM;Each time the file system requests a sector read or write from the diskdriver, it scans the hotfix map and replaces any bad sector numbers with thecorresponding good sector holding the actual data.andP;  This lookasidetranslation of sector numbers is not as expensive as it sounds, since thehotfix list need only be scanned when a sector is physically read or written,not each time it is accessed in the cache.andM;One of CHKDSK's duties is to empty the hotfix map.andP;  For each replacementblock on the hotfix map, it allocates a new sector that is in a favorablelocation for the file that owns the data, moves the data from the hotfixblock to the newly allocated sector, and updates the file's allocationinformation (which may involve rebalancing allocation trees and otherelaborate operations).andP;  It then adds the bad sector to the bad block list,releases the replacement sector back to the hotfix pool, deletes the hotfixentry from the hotfix map, and writes the updated hotfix map to disk.andM;Of course, write errors that can be detected and fixed on the fly are not theonly calamity that can befall a file system.andP;  The HPFS designers also had toconsider the inevitable damage to be wreaked by power failures, programcrashes, malicious viruses and Trojan horses, and those users who tum off themachine without selecting Shutdown in the Presentation Manager Shell.andO;(Shutdown notifies the file system to flush the disk cache, updatedirectories, and do whatever else is necessary to bring the disk to aconsistent state.)andM;The HPFS defends itself against the user who is too abrupt with the Big RedSwitch by maintaining a Dirty FS flag in the SpareBlock of each HPFS volume.andO;The flag is only cleared when all files on the volume have been closed andall dirty buffers in the cache have been written out or, in the case of theboot volume (since OS2.INI and the swap file are never closed), when Shutdownhas been selected and has completed its work.andM;During the OS/2 boot sequence, the file system inspects the DirtyFS flag oneach HPFS volume and, if the flag is set, will not allow further access tothat volume until CHKDSK has been run.andP;  If the DirtyFS flag is set on theboot volume, the system will refuse to boot; the user must boot OS/2 inmaintenance mode from a diskette and run CHKDSK to check and possibly repairthe boot volume.andM;In the event of a truly major catastrophe, such as loss of the SuperBlock orthe root directory, the HPFS is designed to give data recovery the bestpossible chance of success.andP;  Every type of crucial file object-includingFnodes, allocation sectors, and directory blocks-is doubly linked to both itsparent and its children and contains a unique 32-bit signature.andP;  Fnodes alsocontain the initial portion of the name of their file or directory.andO;Consequently, CHKDSK can rebuild an entire volume by methodically scanningthe disk for Fnodes, allocation sectors, and directory blocks, using them toreconstruct the files and directories and finally regenerating the freespacebitmaps.andM;Application Programs and the HPFSandM;Each of the OS/2 releases thus far have carried with them a majordiscontinuity for application programmers who learned their trade in theMS-DOS environment.andP;  In OS/2 1.0, such programmers were faced for the firsttime with virtual memory, multitasking, interprocess communications, and theprotected mode restrictions on addressing and direct control of the hardwareand were challenged to master powerful new concepts such as threading anddynamic linking.andP;  In OS/2 Version 1.1, the stakes were raised even further.andO;Programmers were offered a powerful hardware-independent graphical userinterface but had to restructure their applications drastically for anevent-driven environment based on objects and message passing.andM;In OS/2 Version 1.2, it is time for many of the file-oriented programminghabits and assumptions carried forward from the MS-DOS environment to fall bythe wayside.andP;  An application that wishes to take full advantage of the HPFSmust allow for long, free-form, mixed-case filenames and paths with fewrestrictions on punctuation and must be sensitive to the presence of EAs andACLs.andP;  After all, if EAs are to be of any use, it won't suffice forapplications to update a file by renaming the old file and creating a new onewithout also copying the EAs.andM;But the necessary changes for OS/2 Version 1.2 are not tricky to make.andP;  A newAPI function, DosCopy, helps applications create backups-it essentiallyduplicates an existing file together with its EAs.andP;  EAs can also bemanipulated explicitly with DosQFileInfo, DosSetFileInfo, DosQPathInfo, andDosSetPathInfo.andP;  A program should call DosQSysInfo at run time to find themaximum possible path length for the system, and ensure that all buffers usedby DosChDir, DosQCurDir, and related functions are sufficiently large.andO;Similarly, the buffers used by DosOpen, DosMove, D o s G e t M o d N a m e ,DosFindFirst, DosFindNext, and like functions must allow for longerfilenames.andP;  Any logic that folds cases in filenames or tests for theoccurrence of only one dot delimiter in a filename must be rethought oreliminatedandM;The other changes in the API will not affect the average application.andP;  Thefunctions DosQFileInfo, DosFindFirst, and DosFindNext now retum all threesets of times and dates (created, last accessed, last modified) for a file onan HPFS volume, but few programs are concerned with time and date stampsanyway.andP;  DosQFsInfo is used to obtain volume labels or disk characteristicsjust as before, and the use of DosSetFsInfo for volume labels is unchanged.andO;There are a few totally new API functions such as DosFsCtl (analogous toDosDev IOCtl but used for communication between an application and an FSD),DosFsAttach (a sort of explicit mount call), and DosQFsAttach (determineswhich FSD owns a volume); these are intended mainly for use by disk utilityprograms.andM;In order to prevent old OS/2 applications and MS-DOS applications running inthe DOS box from inadvertently damaging HPDS files, a new flag bit has beendefined in the EXE file header that indicates whether an application isHPFS-aware.andP;  If this bit is not set, the application will only be able tosearch for, open, or create files on HPFS volumes that are compatible withthe FAT file system's 8.3 naming conventions.andP;  If the bit is set, OS/2 allowsaccess to all files on an HPFS volume, because it assumes that the programknows how to handle long, free-form filenames and will take theresponsibility of conserving a file's EAs and ACLs.andM;SummaryandM;The HPFS solves all of the historical problems of the FAT file system .Itachieves excellent throughput even in extreme cases-many very small files ora few very large files-by means of advanced data structures and techniquessuch as intelligent caching, read-ahead, and write-behind.andP;  Disk space isused economically because it is managed on a sector basis.andP;  Existingapplication programs will need modification to take advantage of the HPFS'ssupport for extended attributes and long filenames, but these changes willnot be difficult.andP;  All application programs will benefit from the HPFS'simproved performance and decreased CPU use whether they are modified or not.andO;This article is based on a prerelease version of the HPFS that was stillundergoing modification and tuning.andP;  therefore, the final release of the HPFSmay differ in some details from the description given here--Ed.andM;B- Trees and B+ TreesandM;Most programmers are at least passingly familiar with the data structureknown as a binary tree.andP;  Binary trees are a technique for imposing a logicalordering on a collection of data items by means of pointers, without regardto the physical order of the data.andM;In a simple binary tree, each node contains some data, including a key valuethat determines the node's logical position in the tree, as well as pointersto the node's left and right subtrees.andP;  The node that begins the tree isknown as the root; the nodes that sit at the ends of the tree's branches aresometimes called the leaves.andM;To find a particular piece of data, the binary tree is traversed from theroot, At each node, the desired key is compared with the node's key; if theydon't match, one branch of the node's subtree or another is selected based onwhether the desired key is less than or greater than the node's key.andP;  Thisprocess continues until a match is found or an empty subtree is encountered(see Figure A).andM;Such simple binary trees, although easy to understand and implement, havedisadvantages in practice.andP;  If keys are not well distributed or are added tothe tree in a non-random fashion, the tree can become quite asymmetric,leading to wide variations in tree traversal times.andM;In order to make access times uniform, many programmers prefer a particulartype of balanced tree known as a B-Tree.andP;  For the purposes of thisdiscussion, the important points about a B-Tree are that data is stored inall nodes, more than one data item might be stored in a node, and all of thebranches of the tree are of identical length (see Figure B).andM;The worst-case behavior of a B-Tree is predictable and much better than thatof a simple binary tree, but the maintenance of a B-Tree is correspondinglymore complex.andP;  Adding a new data item, changing a key value, or deleting adata item may result in the splitting or merging of a node, which in tumforces a cascade of other operations on the tree to rebalance it.andM;A B+ Tree is a specialized form of B-Tree that has two types of nodes:internal which only point to other nodes, and external, which contain theactual data (see Figure C).andM;The advantage of a B+ Tree over a B- Tree is that the internal nodes of theB+ Tree can hold many more decision values than the intermediate-level nodesof a B-Tree, so the fan out of the tree is faster and the average length of abranch is shorter.andP;  This makes up for the fact that you must always follow aB+ Tree branch to its end to get the data for which you are looking, whereasin a B-Tree you may discover the data at an intermediate node or even at theroot.andO;</TEXT></DOC>