<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-734-216  </DOCNO><DOCID>07 734 216.andM;</DOCID><JOURNAL>Release 1.0  Sept 22 1989 v89 n9 p1(5)* Full Text COPYRIGHT EdVenture Holdings 1989.andM;</JOURNAL><TITLE>Object-oriented database roundup.andM;</TITLE><DESCRIPT>Company:   Houston Lighting and Power (data processing).andO;Topic:     Object-Oriented Data BasesOffice AutomationData StructuresCase StudyMaintenance ApplicationsTheory of Computation.andM;</DESCRIPT><TEXT>Since our review of object-oriented databases last year (Release 1.0, 88-12,and also 87-8 and 88-9) the playing field has enlarged considerably.andP;  Inseveral cases, databases and applications are co-evolving, as corporatepartners (the new name for beta customers) work with pre-production modelsbecause they don't want to wait.andP;  Currently, several new vendors arepreparing to join pioneers Servio Logic, Ontologic and Symbolics in theobjectoriented database sweepstakes.andP;  (Another pioneer, Graphael, no longeranswers its phone.) Each reflects its developers' backgrounds -- commercialor research, database or engineering, tools or substrate.andP;  Call our previousdiscussion a set of requirements; here are the specifications, with updateson individual players.andM;Right now, few people take this market seriously because no one expects togive up DB2 or Oracle or dBASE for the next pretty object-oriented face thatcomes along.andP;  But that's beside the point.andP;  Object-oriented databases are notgoing to replace regular ones anytime soon.andP;  Instead, they will replace filesystems and provide database support to a new class of applications: CAD/CAM,electronic publishing and other design/configuration processes with intricatedata structures, multiple users and multiple applications.andM;This is an accumulation of technologies, not a replacement cycle: from batchprocessing with relational predecessors Codas I and network databases- torelational-based interactive databases for ad hoc queries and analysis andeven transaction-processing; and on to objectoriented databases for designand configuration tasks, where you can easily use and navigate the structureas well as the data in a database while maintaining integrity.andM;While the OODB market once appeared limited to traditional designapplications, it is becoming increasingly clear that it will also supportoffice automation in general and task automation in particular.andP;  In fact,task automation can be seen as realtime design of a work product -- whetherit's generating an answer to a customer's question, a work schedule, anitinerary or a policyandM;credence, both from people who understand them and from those who do not.andO;Once seen as a tool only for engineers, object-oriented databases are nowdeemed an appropriate back-end for storage and manipulation of documents,diagrams and other rich data -- the role H-P's Iris will play for its NewWaveand that IBM's DB2-based Repository (page 25) will play for many CASE tools.andO;However, Index Technology, after thoroughly examining the question, hasdecided that it needs nothing less than the real thing -- a databaseobject-oriented all the way down - -and is working closely with Ontologic toshape its Ontos for use as the foundation of Index's nextgeneration CASE toolsuite.andP;  Kodak is using MCC's Orion prototype in-house to supportconfiguration of systems for customers.andM;We believe many other vendors and users will make the same decision for toobject-oriented all the way down,&quot; for both performance and functionality.andO;It's clear that economics, need and culture make engineering the first andeasiest market to crack.andP;  But in the long run, competition for engineeringand design will raise the appeal of newer markets, where customers will berunning Lotus 1-2-3 Release 6 in eight dimensions, Word 7 and GroupSupport 2under OS/4 on 686 machines and Unified UNIX X.3 on 100-MIPS RISC machines.andM;Not by relational aloneandM;But first, what do we need object-oriented databases for? Aren't relationalones good enough? Unfortunately, no.andP;  In theory, you can do everything with arelational database; call it a Turing data store.andP;  You can keep pointers toobjects in it, and you can keep the links in it, and assemble whatever datastructures you want as you need them.andP;  But that's like saying you can keep acar in a file cabinet because you can file the engine components in files inone drawer, and the axles and things in another, and keep a list of howeverything fits together.' You can, but you wouldn't want to.andP;  Nor do youwant to keep everything in a pile in the garage (a single file) that has tobe assembled each time you want to use it or even just a part of it.andM;True, if all you want is little pieces of data findable by values (Alice'ssales vs.andP;  quota for 1988, say), you're better off with a relationaldatabase; and if you want to do the same thing to thousands of pieces of data(raise everyone's salary 10 percent, say), you're better off with atraditional ISAM database.andP;  An object-oriented database comes into its ownwhen Alice wants to assemble an itinerary based on current pricing andproduct availability while Juan over in marketing keeps on proposing newcustomers and the finance department keeps on changing travel restrictions.andM;A database does more than just store (representations of) things; itmanipulates them and maintains their integrity.andP;  As with regular data but 20years later, there will be a proliferation of applications and tools based onricher data structures that need a shared database on the back-end, with avariety of applications and users on the front-ends.andP;  At present theseapplications simply load entire files and then recreate the structures inmemory -- Objectivity president Bob Field calls them file-suckers.andP;  With anobject-oriented database, these applications could select the components oftext or data or images or diagrams they need from shared, structured datathat can be used concurrently by other users or applications.andP;  Theseapplications and their users need the same assurances of integrity acrossapplications and the same multi-user access as a relational database offersfor more &quot;regular&quot; data,andM;Objective benefitsandM;Relational databases derive a virtual structure at execution time by&quot;relating&quot; sets of data based on values, while object-oriented databasescontain explicit structure and assign objects and instances (types and data,so to speak) immutable IDs.andP;  The structure as well as the data is permanent(albeit malleable), and needn't be reconstructed at runtime.andP;  A &quot;view,&quot; afamiliar database construct consisting of data selected from multiple tablesby &quot;relating&quot; values at runtime and loaded into a single table, has ananalogy in object-oriented databases, where a subset network of relationshipsis selected by traversing pointers from object to object (ideally withinclusters) within a larger, incomprehensible web.andM;This means that there's a lot more information in an object-orienteddatabase.andP;  Both data and transactions are defined to/in/by the database, andif you follow the rules you can't fool around with the data (encapsulated inobjects) or the structure without the database's &quot;knowledge.&quot; In atraditional database, as a user, all you can do is add or delete records andchange values (in general); in an object-oriented database, you are dealingwith explicit relationships and inheritance schemes and methods, and managingdiscrete transactions on discrete attributes of objects.andP;  The database itselfcan determine on a fine-grained level which transactions conflict and whichcan co-occur without breaching integrity, For example, design rules could beenforced within the database, not by an after-the-fact separate application.andM;Objective challengesandM;The bad news is that storing and providing easy access and concurrencycontrol for data and code that are linked and constrained by an intricate webof orthogonal relationships is much tougher than what a typical database doesnow.andP;  That gives object-oriented databases a reputation for slowness andoverhead, but the question is, &quot;compared to what?&quot; They handle a task nothandled before, and use a web of indexes and caching algorithms (never seenby users or even most developers) to make the whole system work.andM;In any database, data is stored for efficiency.andP;  In a relational database, anitem is put in the table or file it &quot;belongs&quot; to; applications are separate.andO;In an object-oriented database, data typically &quot;belongs&quot; in many places, andyou store not just the item but the related behavior (the equivalent ofapplication code).andP;  So you store data (or a pointer to it, akin to a foreignkey) in many places, using unique object identifiers for each object (orinstance, depending on terminology).andP;  With each object are stored itsattributes, properties such as age or color, which have no independentexistence (in the database) away from the object that possesses them.andP;  Alsoalong with each object are stored pointers to other objects it hasrelationships with (actually, object IDs) and pointers to the code thatimplements its behavior.andP;  The co-location of the data most likely to be usedtogether is called clustering, and is a key factor in database performance.andM;As happened with relational databases during their low-performance infancy,much of the OODB work of the past and the next few years will focus onpractical techniques for performance: They include indexing and efficientclustering of objects (by class hierarchy or with the other objects they'rerelated to; i.e., do you store sales employees together, along with the salesemployee class which contains relevant code, or with the company each oneworks for?).andP;  In addition, clever caching allows you to maintain performanceand efficiency regardless of previous physical storage decisions.andP;  Forexample, once the user has loaded a single employee instance along with theemployee behavior (retrieved automatically), most caching systems wouldretain the employee behavior in the expectation that the user or applicationwould turn itsattention to another employee instance.andM;Object story: Statice in actionandM;Houston Power andamp; Light, for example, is using Symbolics' Statice to store andmanipulate data for power-plant maintenance schedules (one of very fewreallive production uses of an object-oriented database we could find, butmany more are in development).andP;  Some data come from a mainframe payrollsystem that does 3000 to 4000 transactions per day; each schedule contains2000 to 10,000 discrete activities.andP;  Scheduling requires manipulation ofteams of individual workers each having a unique set of skills, pay rates andwork schedules; physical considerations such as distances from one plant toanother; kinds of work needed for each component of a generating unit(several per plant); and specific repairs required at each plant.andP;  Each powerplant has a unique set of equipment, but each instance of that equipmentshares many characteristics with others in its class, and some pieces ofequipment work together.andP;  Do you store all the like equipment together, orall of a plant's components together? (In this case, you keep the plantcomponents together, because plants are scheduled one by one, but the answermight be different in other circumstances.)andM;Some of the attributes of an object are relationships to other independentobjects, such as tools, parts, equipment a particular class of worker isqualified to repair, and groups of items (such as work teams), or complexobjects.andP;  When an object is selected, the system loads the object ID (aunique number) and the OIDs of the other objects it has relationships with,according to the use the user or application specifies.andM;How do you combine all these permutations to generate effective schedules?andO;Houston Pandamp;L did it so effectively with Statice (plus an expert system) thatovertime dropped by $442,000 (38 percent) year-to-year.andP;  It used to takethree hours to load a file to start scheduling one plant (out of 25), but itnow takes five minutes because the system is able to load only the specificobjects necessary.andM;The overall process used to take five days (of elapsed time) and now takesjust a few hours because the impacts of hypothetical changes can be whatiffedand reflected that much more quickly.andP;  The expert system restructures onlythe relevant data instead of recompiling it all each time a change is made.andO;But the real benefits that scheduling and controls supervisor Steve Gellerhopes for aren't yet visible: He expects better maintenance to lead to fewerblackouts and less &quot;unscheduled maintenance&quot; in the future.andM;A kaleidoscope for the mindandM;Object-oriented databases offer a new way of using and thinking aboutdatabases.andP;  Where applications once used to call data from the database, nowthey rely on both data and processes in the database, using definedtransactions as well as defined data.andP;  The database plays an active insteadof a passive role.andP;  While object-oriented programming is frequently thoughtof as hierarchies of data types or objects or &quot;nouns with verbs attached,&quot; infact what defines those objects is their relationships with other objects(attributes that are other objects instead of primitive strings or values)and their behaviors -- or allowed transactions.andP;  What makes a sales employeedifferent from a generic employee? Not his name (data), but his behavior, orthe code routines the object employs.andP;  The data is incidental.andO;Objectoriented programming is not the creation of data hierarchies but ratherthe creation and modification of behavior (read application) hierarchies.andO;The class hierarchy provides a convenient way of organizing and linking codemodules (through inheritance) to the data it acts upon.andP;  The database holdsthem together and allows you to take them out a piece at a time.andM;If you're so smart, how come....andM;Wonderful as object-oriented databases are, they can't overcome reality: Theymodel complex items and relationships, and representing those is never goingto be as simple as modeling a flat vanilla table of names and addresses orchecking-account transactions.andP;  The achievement of objectoriented databasesis to make the impossible possible, rather than to make the possibleautomatic.andP;  Object-oriented programming doesn't guarantee reusable code: Itprovides a framework for it.andM;It's not what you don't know; it's what you know that ain't so.andO;Interoperability at a technical level doesn't necessarily meaninteroperability at the modeling-reality level.andP;  Objects that mean one thingin one application may have quite different meanings (or underlyingassumptions) in another.andP;  This will become an increasingly important problemas we move from the current examples of computer-oriented objects -- screenicons and buttons, files and data types -- to objects that attempt to mirrorreality, such as priceearnings ratios, vice president, workday, and thephrase &quot;let's have lunch.&quot; All these items would be defined quite differentlyby different people.andP;  Yes, there is a cost for this lunch, too.andO;</TEXT></DOC>