<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-559-226  </DOCNO><DOCID>08 559 226.andM;</DOCID><JOURNAL>EXE  June 1990 v5 n1 p55(4)* Full Text COPYRIGHT Process Communications Ltd. (England) 1990.andM;</JOURNAL><TITLE>A religious war. (software development tools)</TITLE><AUTHOR>Ince, Darrel.andM;</AUTHOR><SUMMARY>Arguments abound between proponents of dynamic analysis tools andproponents of static tools.andP;  The more formal static analysis toolsfor software development are pitted against a relaxed developmentmethod preferred by testers.andP;  Tools for software test, validationand verification have been in existence much longer than the nowprolific Computer Aided Software Engineering (CASE) tools.andO;Dynamic tools rely on execution of the system, as opposed tostatic analysis tools that carry out a surface scan of the programcode text.andP;  Symbolic execution systems, neither static or dynamic,execute a system and produce a symbolic expression.andP;  These systemsare useful for debugging and generation of test data.andP;  Dynamicanalysis tools may be used increasingly for non safety criticalapplications.andP;  A combination of the two development processes maybe necessary for safety critical applications.andM;</SUMMARY><DESCRIPT>Topic:     Program Development ToolsStatic SystemsDynamic ProgrammingTest Data GeneratorsSoftware EngineeringAnalysis.andO;Feature:   illustrationchartgraph.andO;Caption:   Dynamic analyser architecture. (chart)Histogram produced by a program instrumentor. (graph)Test data generator architecture. (chart)andM;</DESCRIPT><TEXT>A Religious War There is an interesting struggle going on in the softwaredevelopment industry, particularly in he real-time area.andP;  This is theconflict between the adherents of formal methods of software develoment andthose who believe that more relaxed development methods, combined withrigorous testing, will achieve the same results as the high-tech,mathematical approach.andM;This difference is exemplified by the software tools which each side prefer.andO;The formalists are currently pushing static analysis tools, while the testerstend to support the use of dynamic software tools.andP;  This article looks, insome detail, at the tools supported by each side, examines the pros and cons,and attempts to makes some sense out of a situation which is rapidly becominga dangerous exercise in counting angels on pinheads.andM;Software ToolsandM;Software tools are now a major growth area.andP;  (A 'software tool' is a computerprogram intended to automate a particular software development task, such asdesign or testing.)andP;  The biggest growth has been in PC-based tools, whichenable a system developer to specify the functions of a system, and thendesign a system in terms of graphical notations.andM;Five years ago, such Computer Aided Software Engineering (CASE) tools couldbe counted on the fingers of two hands.andP;  Now there are literally hundreds,and they are beginning to contribute to major productivity gains on modernsoftware probjects.andP;  What is not realised is that tools for the validation,verification and testing of software systems have been in existence for muchlonger than conventional CASE tools, and can offer similar increases inproductivity.andM;Dynamic testing tools have the longest pedigree.andP;  They are software toolswhich rely on the execution of the software system which they are checking.andO;The architecture of a typical dynamic analyser is shown in Figure 1.andP;  Itconsists of an instrumentor or profiler, which instruments the test programwith software probes.andP;  Each probe is a call to a subroutine which issuesinformation to a history file.andP;  Here is part of an instrumented program:andM;If wind_speed [is greater than] max_speed THEN BEGIN Oldspeed:=0;Newspeed:=0; probe (34) END ELSE BEGIN Oldspeed := min; probe (35) END;andM;It shows that the IF statement has been instrumented with two probes whichare calls on the subroutine probe.andP;  This procedure takes one parameter,normally a unique identification of some control feature of the program beinginstrumented, such as a branch.andP;  In my example, branches 34 and 35 have beeninstrumented.andM;The probe subroutine writes the parameter number to a file, known as thehistory file.andP;  When the execution of the instrumented system is complete, thehistory file will contain a sequence of numbers that represented the parts ofthe instrumented program that have been executed.andP;  This file is thenprocessed, and an execution profile displayed usually in the form of ahistogram.andP;  The histogram in Figure 3 represents the results from executing amodule containing 20 'probed' statements.andP;  The horizontal scale shows thestatement numbers, the vertical scale shows the frequency of execution.andP;  Asyou can see, statements 10 and 15 were not executed at all, whereas statement13 was executed the most frequently.andM;The tool that I have described, often known as a program instrumentor, hasmultiple uses.andP;  First, it can be used to check test thoroughness.andP;  Adeveloper, or rather his quality assurance department, could lay downstandards which specify that all the statements in a program, and aparticular percentage of branches, are to be executed.andP;  The tool would beused by programmers to produce reports which show that these standards arenot being violated.andM;Another application is to enable staff to carry out optimisation.andP;  Manydevelopers are faced with a major problem during system testing: their systemdoes what is required of it, but its response time is laggardly.andP;  There are anumber of techniques which can be used to speed it up, but the developeroften has difficulty in identifying which parts need to be optimised.andP;  Theoutput from a program instrumentor enables tuning staff to home in on thepart of a system which requires optimisation - so-called 'hot spots' - andcarry out local optimisations.andP;  Many industrial developers have reporteddramatic speed-ups using this technique.andP;  In one extreme example, a systemwhich originally took three days to complete its processing, was successfullytweaked to do the same work in a few minutes.andM;There are many different program instrumentors.andP;  The best known are probablyLogiscope, marketed by the French company, Verilog, and TestBed from ProgramAnalysers Ltd.andP;  Logiscope supports many programming languages includingCOBOL, FORTRAN, Modula-2, C, Pascal and Intel 80 series assembler.andP;  It isavailable on a wide variety of mainframe and minicomputers.andP;  TestBed, whichis probably the most flexible of the dynamic analysis tools, was developed byLiverpool Data Research Associates, and also handles languages such as COBOL,PL/M 86, PL/1, Ada, C and Coral 66.andM;Be AssertiveandM;Another useful dynamic tool is the assertion processor.andP;  As those who havestudied the ANSI C function library will already know, an assertion is astatement which is embedded in a program at a point where the condition inthe assertion is true.andP;  The fragment of Pascal shown in Figure 2 contains aread statement, which obtains two integers that are less than 20 followed byan assertion statement, which 'asserts' that each of the values are less than20.andP;  If they are not, an error message is produced, as shown in Figure 2.andM;Assertion processors are used to support defensive programming.andP;  Defensiveprogramming is as much a state of mind as a technique.andP;  A programmer whoemploys defensive programming belives that the code that he is developingwill, almost invariably, contain errors and should, consequently, containdebugging statements which monitor this error.andP;  An assertion processor allowsthe programmer to insert complex assertions very easily.andP;  The assertion belowstates 'all the elements of the array A, which has 20 elements, are greaterthan 100'.andP;  If this is not the case, then a subroutine error, supplied by theprogrammer, will be executed, shown below.andM;Assert (Forall i in 1..20* A{i}andgt;100, errorandM;Such assertions can be placed in a program at a number of critical points: atthe start of a subroutine, at the end of a subroutine, after a particularlycomplex calculation, and after data has been readin from the outside world.andM;Assertion processors can be employed throughout the software probject.andP;  Theycan be used by the individual programmer when constructing a subroutine.andO;However, they come into their own when integration and system testing takesplace.andP;  A common problem when carrying out testing is the system which diessuddenly, leaving the operator staring at a blank screen.andP;  Little informationis produced from the test which helps in debugging.andP;  However, a system whichhas been instrumented with assertions may be able to produce an audit trailwhich indicates almost exactly where the error was first detected.andP;  Probablythe best assertion processor is PET, developed by Boeing Computer Services.andO;It features an exceptionally powerful language for specifying assertions andthe actions that occur when an assertion is violated.andM;Static SceneandM;Static analysis tools are more sophisticated than dynamic tools.andP;  They do notrely on an execution of a system, but just carry out a surface scan of theprogram code text.andP;  The static analysis tool which promised the most forformal software developers was the program prover.andP;  This is a program whichhas two inputs: a specification, written in discrete mathematics, and aprogram, which purports to implement the specification.andP;  The theorem proverthen checks whether the program is correct.andP;  It does this by breaking theprogram down into its components and developing a mathematical description ofthat program's function.andP;  This is then compared with the input specification.andM;Program provers were a very hot topic during the early 1970, particularly inthe United States.andP;  Large amounts of money and other resources were given toresearchers trying to build fast program provers.andP;  However, the technologyhas yet to match its initial promise.andP;  The problem seems to be complexity:program provers generate a large volume of mathematics when they attempt togenerate the exression which describes the program being proved.andP;  Foranything but the smallest program, the quantity of mathematics generated isso large that it overwhelms the program prover; this is often manifested interms of memory problems.andP;  Program proving as a formal development techniqueis now quite discredited.andP;  There is only one software tool commerciallyavailable for this form of software development: the Stanford PascalVerifier.andM;However, there are several more pragmatic static analysis tools that areavailable, many of them British.andP;  Probably the best known are MALPAS,marketed by RTP (formerly called Rex Thompson and Partners), and SPADE,marketed by Program Validation Ltd.andP;  These products have a long history andwere rooted in the early 70s when software developers were beginning todiscover some of the drawbacks of primitive languages such as FORTRAN.andP;  Theearliest static analysis tools were aimed at FORTRAN programmers, anddetected errors such as the use of uninitialised variables.andM;Such static analysers supply an extremely powerful set of functions.andP;  Forexample, they are able to detect data anomalies.andP;  Consider the case where avariable is initialised in one sectionof code.andP;  There then follows more code,in which the variable is not used.andP;  The variable is then assigned anothervalue-so the initial assignment is wasteful.andP;  Considering that theintermediate code might include a large number of calls to procedures whichuse the variable as a parameter, this form of processing is rather complex toimplement.andM;Another facility offered by such tools is the detection island code.andP;  This isa section of a system which is incapable of ver being executed.andP;  The fragmentof Pascal below includes a section of code which is executed only when x isgreater than 10, and when x is less than 10; that is, never.andM;IF x [is greater than] 10 THEN BEGIN .andP;  .  IF x [is less than] 10 THEN BEGIN(* Island code *) .andP;  .  END ENDandM;It is surprising how much of a system can contain island code.andP;  It is usuallyfound in applications which have endured considerable software maintenance.andM;Yet another function is the ability to declare calculation dependencies whichspecify how variables depend on each other.andP;  A programmer can write astatement like this: (* tax_value calculated from salary, tax_rate *)andM;This states that the variable tax_value depends on the variables salary andtax_rate, in that they are used to calculate its value.andP;  A static analyser isable to read such statements, process the program code of a system and checkwhether this dependency actually holds.andP;  This facility is vital duringmaintenance, where erroneous changes can affect these dependencies.andP;  One ofthe most powerful facilities offered by static analysers is the ability towrite a specification using a mathematical language, and detect anynon-compliance of the code with this specification.andP;  A programmer can writemathematical statements which describe what part of a system is to do, andthe static analyser examines the program code and checks whether the programcode correctly implements this statement.andM;Halfway HouseandM;Sitting on the fence between static and dynamic analysers are symbolicexecution systems.andP;  These systems execute a system, but, instead ofgenerating numerical output, they produce a symbolic expression.andM;s := 0; FOR i:= 1 TO 4 DO s := s+a[i]andM;For example, when the section of Pascal program code shown above has bensymbolically executed, this symbolic expression is displayed:andM;a[1]+a[2]+a[3]+a[4]andM;Such symbolic execution systems have various applications.andP;  One of these isin debugging; symbolic output tells the programmer much more than a set ofnumbers.andP;  However, symbolic executors are at their most useful whenincorporated into tools for the generation of test data.andP;  As well asproducing symbolic output, the software can generate an expression known as apath predicate.andP;  This is an expression which must be true if a particularpath through a piece of code is to be executed.andP;  For example, consider thisPascal fragment:andM;a:=c; b:=d; IF a = b THEN BEGIN a := 2*C; b:= a+b+c; IF a [is less than] bTHEN .andP;  .  .andM;If the path followed takes the two TRUE branches of the IF statements, thenthe path predicate which must be true for this to happen is c=d and 2*c [isless than] 3*c+d which can be simplified to c=d and 0 [is less than] c+dandM;This path predicate can be found by symbolic execution.andP;  It becomes a trivialtask to feed this expression into an automatic numerical equation solver tofind values for the variables which cause the path predicate to be true, andhence force the path to be executed.andP;  In the example above, any positivevalues for c and d which are equal would result in the path being executed.andM;The architecture of a sophisticated test data generator is shown in Figure 4.andO;The path extractor reads in the source text of the software under test andextracts an internal representation of the flow of control of execution ofthe software.andP;  The tool then asks the user whether he wants test data for aspecific path to be derived, or whether he wants test data which satisfiessome particular test metric, such as a specified percentage or branches to beexecuted.andP;  If the former is required, then the system uses the internalrepresentation to carry out a symbolic execution, form the path predicate andpass it to a numerical equation solver.andP;  However, if the second option isrequired, the processing is a little more sophisticated.andP;  The control flowgraph is examined and a set of paths is extracted which satisfies thecoverage metric.andP;  The system then generates a path predicate for each path,as before, and uses the numerical solver to generate the test data.andM;There are several drawbacks to such systems of automatic test generation.andP;  Animportant problem is that the path predicates are often very complex, andcannot be solved by the numerical equation solver.andP;  To get around this, mostsystems generate random values of test data, and stop when a set is generatedwhich satisfies the path predicate.andP;  This is a simple solution but,unfortunately, it is a rather time-consuming one.andM;State of the BattleandM;In the United Kingdom the struggle between those who wish us to adopt dynamictools, and those who prefer static tools, has reached an intensly only reallyassociated with religious questions.andP;  Until recently, the proponents ofdynamic testing tolls were in the ascendacy.andP;  Static analysis was regarded asrather an academic thing to do.andP;  Combined with the fact that the trainingcosts for such tools can be quite high, many commentators were led to markthe technology down as one for the next century.andM;However, a recent defence standard for software overturned thsi completely.andO;DefStan 0055, which was intended to address the development ofsafety-critical defence software, was issued last year.andP;  It was the mostradical software document issued in the 1980s.andP;  It advocated the use offormal methods of software development, automated means of keeping track ofchanges on a software project, the use of advanced software developmentmethodologies, the use of risk analysis strategies and the employment ofstatic analysis tools.andP;  In its first draft there was little, if any, mentionof dynamic analysis.andP;  This was rectified in later versions of the standard,but the impression gained by industry watches is that the MOD still regardstatic analysis as the more important technique of the two.andM;The new defence standard was greeted with general disdain by the softwareindustry, which concentrated on criticising the formal methods aspect of thestandard.andP;  They pointed out that such methods were still immature, did nothave very much tool support and were untried.andP;  Reports from the MOD suggestthat formal methods will be downplayed considerably in the future.andO;Consequently, the prospect for static analysis tools which, at the beginningof the year, seemed to have a bright future because of their reliance onformal methods of software development, have dimmed a little.andM;It is always difficult to make accurate predictions.andP;  However, my guess isthat dynamic analysis tools will increasingly be used for non safety-criticalapplications, and that a combination of the tools will be employed forsafety-critical applications.andP;  I can imagine a scenario where static analysistools would be used by the individual programmer, who could then provide ahigh level of assurance of individual modules.andP;  Dynamic analysis tools wouldcome into play at project level; being used to monitor execution thoroughnessduring integration testing, system testing and acceptance testing,pin-pointing parts of a system which remain unexecuted or combinations ofevents which have not been initiated.andP;  What is surely certain is that iftechnology like this is not employed, there will be a disaster.andP;  Thecomplexity of safety-critical systems seem to grow at an alarming rate and,sooner or later, the rather ad hoc techniques used by software developerswill result in the loss of large numbers of lives.andM;In this respect the arguments between proponents of both technologies are adangerous irrelevance.andP;  A view which I am sure is shared by the jet pilot,who test-fired a missile from his plane, only to find that the softwarecontrolling the release of the missile was slightly out of step with thefiring of the missile.andP;  As a result, his plane developed an extra, ratherunstable, engine on one of its wings.andP;  Happily, the pilot escaped - but theplane crashed.andM;Darrel Ince is a Professor of Computing Science at the Open University, wherebe was the acting head of the computing department until recently.andO;</TEXT></DOC>