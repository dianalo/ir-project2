<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-788-098  </DOCNO><DOCID>07 788 098.andM;</DOCID><JOURNAL>Microsoft Systems Journal  Nov 1989 v4 n6 p19(15)* Full Text COPYRIGHT Microsoft Corp. 1989.andM;</JOURNAL><TITLE>Emulating the UNIX RS-232 general serial I/O interface under DOS.andO;(includes glossary of serial communications terms)</TITLE><AUTHOR>Chase, Michael J.andO;AttFile:   MSJ\V04N06\CONFIG.SYS;2 Program:  CONFIG.SYS  Serial communications demo.andO;MSJ\V04N06\MSJTTY01.SYS;2 Program:  MSJTTY01.SYS  Serial communications demo.andO;MSJ\V04N06\README.DOC;0 Program:  README.DOC  Serial communications demo.andO;MSJ\V04N06\STTY.EXE;2 Program:  STTY.EXE  Serial communications demo.andO;MSJ\V04N06\UNIXBSC.EXE;2 Program:  UNIXBSC.EXE  Self-extracting archive.andM;</AUTHOR><SUMMARY>Portable device control software using the RS-232 serial I/Ointerface in both general and embedded applications under bothUnix and DOS are presented.andP;  In Unix, the serial interface isindependent of hardware.andP;  In DOS, programmers cannot use the COM1or COM2 serial device interfaces because they lack buffering andXON/XOFF handshaking support and are not interrupt driven.andO;Third-party communications libraries are too time consuming tolearn and may not port to Unix-based systems or another vendor'sDOS communications libraries.andP;  RS-232's many usable features arepresented, including buffering, XON/XOFF handshaking, watchdogtimers, parity control, exception handling and line disciplines.andO;Communications software design issues such as buffer sizes,communications attributes and error recovery are discussed.andM;</SUMMARY><DESCRIPT>Topic:     Programming InstructionUNIXMS-DOSI-O RoutinesSerial InterfaceSoftware DesignCommunications SoftwareType-In ProgramsEmulation.andO;Feature:   illustrationchartprogram.andO;Caption:   I/O paths. (chart)Program to send a request message to an attached I/O device.andO;(program)Raw and canonical input queues. (chart)andM;</DESCRIPT><TEXT>Emulating the UNIX[R] RS-232 General Serial I/O Interface Under DOSandM;One popular means of transferring information between DOS (1) or UNIX[R]applications and terminals or control devices is the use of RS-232 serialcommunication.andP;  This article focuses on writing applications that rely onRS-232 serial communication under both DOS and UNIX.andP;  We will explore thegeneralized serial I/O interface provided under UNIX and a device driver thatemulates it under DOS.andM;UNIX programmers have a general interface for asynchronous serial devicesthat is independent of hardware; it has many useful features and, onceunderstood, is very easy to work with.andP;  Programmers working in the DOSenvironment, however, usually can't use the COM1 or COM2 serial deviceinterfaces because they are not interrupt driven and do not support bufferingor XON/XOFF handshaking.andP;  Third-party communications libraries are oftencalled upon to help, but most require the C programmer to learn at least 20function calls to a proprietary interface--20 more than most people wouldprefer to have to learn.andP;  Moreover, third-party communication code usuallywill not port to UNIX-based systems or to another vendor's DOS communicationlibraries.andM;Documentation for the generalized UNIX serial device seems incredibly terseand hard to read if you are not familiar with the many details surroundingasynchronous communications.andP;  After some explanation, however, the serialdevice interface becomes easy and convenient to use.andP;  Usable features(buffering, XON/XOFF handshaking, watchdog timers, parity control, exceptionhandling, line disciplines, and so on) of this general interface arepresented so that portable device control software can be written for generaland embedded applications under both UNIX and DOS.andP;  Trade-offs incommunications software design (buffer sizes, communication attributes, errorrecovery, and so on) are also discussed.andM;Communication Device DriversandM;A major goal of all device drivers is to provide a logical software interfacefor applications that isolates them from physical hardware.andP;  The physicalhardware can differ; however, the logical software interface to the hardware(device) remains the same.andP;  This is true for block-oriented devices (diskinterfaces) as well as character-oriented devices (serial port interfaces).andM;Both UNIX and DOS provide block and character device drivers that allow Cprograms to read and write bytes by using standard library calls through thefile system.andP;  Familiar I/O function calls such as open, read, write, andclose (level 1 functions) or stream-buffered functions such as fopen, fread,fscanf, fwrite, fprintf, and fclose (level 2 functions available in thestandard library) can be used to communicate with a file or a serial device.andO;These functions afford programmers writing serial I/O software in UNIX andDOS portability across many hardware platforms.andM;There is one problem though.andP;  The default asynchronous device driver shippedwith DOS is not very powerful because it does not allow you to change speed,parity, buffer control, handshaking, and so on, independent of the hardware.andO;To control a serial device from a C program, calls to the BIOS must bemade--a serious impediment to portability.andP;  Fortunately there are threeviable methods you can use to write serial I/O software for the DOSenvironment: you can build your own communications software, use linkablecommunications libraries provided by a third party, or use a device drivercapable of emulating the popular UNIX serial I/O interface under DOS.andM;Building SoftwareandM;Building a communications functions library from scratch has certainadvantages.andP;  It gives you control over exactly what you need, it helps youlearn about communication port hardware, and it gives you ownership of sourcecode.andM;By and large, though, you will be reinventing the wheel.andP;  You will need ahardware debugger and/or a logic analyzer to catch the most subtle bugs,especially those found in interrupt logic.andP;  You will also need to invest agreat deal of time in supporting, updating, and maintaining the software--inother words, you will become your own technical support staff.andM;Third-Party LibrariesandM;Third-party add-on communication libraries may help you write serial I/Oprograms by providing a C language interface for controlling deviceattributes.andP;  Your C code, however, will be married to these typicallynongeneral interfaces under DOS.andP;  Therefore, you must weigh both theadvantages and disadvantages of this scheme.andM;An advantage of third-party libraries is their highly granular control overspeed, parity, stop bits, XON/XOFF, buffer management, and so on.andP;  Anotheradvantage is not having to install a device driver, since device drivers haveto be loaded when a system is booted and then remain part of the operatingsystem.andP;  I/O functions loaded with your programs, however, are not residentin the operating system, do not consume any space when your program exits,and do not incur operating system overhead to pass information through thefile system.andM;One disadvantage is that the interface to a third-party library is notthrough the file system; another is that calls to fopen, fread, fscanf,fwrite, fprintf, and fclose will not work.andP;  You must devote the time to learna new set of interface functions supported by a given vendor.andP;  Someinterfaces are unnecessarily complex; one commercial vendor, for example,boasts more than 125 serial communication function calls.andP;  Anotherdisadvantage is that simple command line (or batch file/shell script)redirection is not supported.andP;  For example, under DOS the simple command lineandM;C[is greater than] dir [is greater than] \device\tty01andM;will not work.andP;  Further, the logical interface is vendor specific; C codethat is portable between DOS and UNIX is nearly impossible to write.andO;Finally, some third-party libraries are designed as terminate-and-stayresident (TSR) and consume memory.andM;If you only develop for DOS and portability is not an issue, or if you onlyneed a serial device interface for DOS that emulates the widely accepted UNIXserial interface, the advantages probably outweigh the disadvantages.andP;  Inthat case, and with the bridging of the UNIX and DOS worlds, this optiondeserves consideration.andM;Emulating UNIX Serial I/OandM;A UNIX-compatible serial device driver under DOS provides a number of usefuladvantages.andP;  First, it gives you sufficient control over speed, parity, stopbits, XON/XOFF, buffer management, and so on.andP;  Second, C code that controlsserial I/O is portable between DOS and UNIX.andP;  UNIX programmers need not learna new serial I/O interface for DOS and vice versa.andP;  Third, the interface isthrough familiar file system calls (such as fopen and fprintf) so commandline (and batch/shell) redirection is possible.andP;  In fact, the interface is sogeneral that it allows any language-supporting file I/O (C, Assembler,Pascal, Clipper, and so on) to use the serial device.andP;  Fourth, thecontrolling interface is via one standard function call, namely IOCTL.andP;  It isthe same under both UNIX and DOS.andP;  Fifth, standard DOS-critical errorhandlers can be used to trap run-time exceptions.andM;Emulation, however, presents its own set of problems.andP;  Since device driversare only loaded once, at boot time, and DOS supports no explicit resourcemanagement, an existing application (a TSR, for example) could corrupt thedevice driver by competing for the same communication port hardware.andP;  (Add-oncommunication function libraries can also suffer the same dilemma.)andM;The device driver always consumes memory, even though it may not be used.andO;The sample DOS serial device driver accompanying this article emulates theUNIX driver by consuming almost 8Kb, excluding buffers.andP;  (Code for the devicedriver may be downloaded from any MSJ bulletin board--Ed.)andP;  Furthermore,applications depending on the driver cannot load it before executing,although they can test for its absence and recover.andP;  Microsoft[R] documentsno formal mechanism (that is, a DOS function call) for dynamic device driverloading, except for its mouse driver.andM;Finally, since DOS is not reentrant, and must be entered to gain access tothe device driver, buffers cannot be resized at run time.andP;  They must be sizedat boot time and remain fixed.andM;Of the three methods you can use to write serial I/O software in the DOSenvironment, the best one is emulation of the UNIX serial I/O device driver.andO;It is the most general solution for a given need; which means it best meetsthe goals of providing transportable code, a standard interface, andminimization of the learning curve.andP;  The issues you will need to address whendeveloping serial I/O devices are discussed next.andM;Blocking andandM;Nonblocking I/OandM;Normally when a function call is made requesting information from a blockdevice (a disk), the function call will return only when the request issatisfied or when an error occurs.andP;  For example, the following call to readwill wait until 10 characters are transferred or an error occurs:andM;if (read(fd, buffer, 10) !=10) { /* process the error */ }andM;If the read is from the disk, the request is usually not satisfied until thedisk access is complete.andP;  Under the DOS operating system, the applicationprogram waits for DOS to service the request completely.andP;  Under a preemptivemultitasking system such as UNIX, the program (or process) is put to sleep(that is, the program blocks) until the request is satisfied; then it isawakened (or unblocked) and is eligible to run.andP;  Note that while the processis asleep, the operating system can serve other processes.andP;  DOS, however, isa single-tasking system, so a program must patiently block until DOS returnscontrol--nothing else can run.andM;If you have a serial communications link with the same read calling for 10characters, and no other characters are available, your process will blockunder both UNIX and DOS.andP;  If nothing shows up, the DOS program may blockforever.andP;  The UNIX program also blocks, but other programs can run.andP;  Both DOSand UNIX, however, can be convinced not to block if nothing is available.andO;Several issues related to blocking and nonblocking I/O must be addressed: Theminimum amount of time and/or number of characters for which a read requestwaits to be assembled before being partly or fully satisfied; the number of mcharacters (if available) with n requested (m[is less than]n), that should bepicked up; whether the request is free-form and just asks for a completedline (that is, whether all characters are up to a '\n' or some other linedelimiter); whether or not line editing is available so that mistakes can becorrected; and how the EOF condition will be detected and handled.andP;  Theseissues are explored in later examples; as it turns out, they are all optionsthat can be configured through a general interface.andM;Asynchronous DriverandM;There is one general interface for controlling serial I/O parameters underUNIX--the IOCTL system call.andP;  Its interface specification is shown in Figure1.andP;  If you have worked with DOS, you know that there is a similar, but notequivalent, DOS function call (44H) named IOCTL.andP;  Unfortunately, there is nodocumented evidence that lets you use IOCTL to control COM1 or COM2attributes such as bps, parity, and hardware handshaking.andP;  (Note that the DOSIOCTL call allows several operations to be performed other than thosediscussed here, especially on block devices.)andP;  BIOS calls must be used.andM;Microsoft borrowed the UNIX device driver philosophy for DOS, but did notgeneralize the DOS asynchronous serial I/O device interface as they did thedisk drive interface.andP;  As a consequence, you must use one piece of serialhardware, the 8250 UART, mapped at a fixed address through the BIOS.andM;To get around that, DOS device drivers that use the general UNIX serial I/Ointerface are available; they replace the COM1 and COM2 drivers provided withDOS.andP;  The UNIX terminal interface serves as an excellent model for DOS, ashave many other UNIX features (such as the hierarchical file system, the I/Osubsystem, redirection, pipes, and environment variables).andM;Before using the generalized UNIX serial I/O interface, you must know thefollowing: the bit rate, character data length, parity, and stop bit(s)requirements for communications; the scheme to be used to manage the flow ofinformation in both the transmit and receive directions (XON/XOFF, RTS/CTS,DTR/DSR); how the device handles exceptions such as loss of modem carrier, abreak signal, or andless;C; the kind of input or output post-processing, if any,that needs to be done (for example, CR-andgt;NL, NL-andgt;NL/CR, convert cases, expandtabs); whether DOS programs should use binary or text mode when communicatingwith a device driver; and how parity, framing, and overrun errors should bedetected and handled.andM;Getting StartedandM;Just as you must open a disk file (with open or fopen) to modify it, you alsomust open a serial device, so that it can be written to, read from, oradvised of new operation attributes.andP;  You can use either method shown inFigure 2; both level 1 and level 2 file I/O functions are provided in thestandard C library.andP;  Note that in the call to fopen, &quot;rwb&quot; advises the I/Osystem not to insert CR/LF translations within the data and to pass the andless;Z(1aH) character as binary data.andM;The advantages of level 1 are that there is no buffering overhead in thestandard library and that information specific to the operating system suchas locking and networking, can be communicated.andP;  Level 1 provides morecontrol for character-at-a-time reading and writing.andP;  A disadvantage of level1 is that only read and write are available for I/O.andP;  The process can requirea costly context switch to the operating system kernel for each read or writefunction call.andM;Level 2 allows the use of fprintf, fscanf, fgets, fputs, and so on, for I/O.andO;These are more portable between different operating system environments.andO;Buffers can be flushed (reset) in the standard library.andP;  Context switching tothe operating system for I/O is only necessary when output buffers areflushed or when input buffers are replenished, not for each call to fread orfwrite.andM;A problem with level 2 is that there may be too much buffering overhead.andP;  Thedevice, operating system, and standard library all maintain buffers.andO;Furthermore, stream buffer overhead for character-at-a-time I/O is morebeneficial for block devices (disks) than character devices (serial I/Oports).andP;  See Figure 3 for more information about I/O paths.andM;Despite the disadvantages of using level 2 file I/O, it is the best choicefor the application discussed here because of the convenience provided by theprintf and scanf functions.andP;  Also, the standard library can be convinced thatthe stream buffer it maintains for a file stream is of length 1 with a callto setbuf.andP;  Buffering overhead is reduced to approximately that of level 1I/O, and fflush need not be called after each fwrite or fprintf transaction.andM;Once a device has been opened, it can immediately be read from or written to.andO;For now, assume that either the device has been initialized or its defaultattributes will suffice.andP;  You can therefore communicate with the serialdevice, as in Figure 4.andM;Changing ParametersandM;Next, consider the mechanism for changing serial device attributes.andP;  Asstated earlier, the IOCTL function is used to get or set device attributespassed in a C structure.andP;  To use the IOCTL function call, the device must beopened with the open function, and a valid file descriptor (a DOS filehandle) must be obtained.andP;  If the standard library function fopen is used,the file descriptor can be derived from the file pointer with the filenomacro found in stdio.h.andP;  One C structure, termio, is used to set or getattributes for all asynchronous devices under UNIX; it is found in theinclude file termio.h.andP;  Members of the termio structure contain informationon input modes, output modes, control modes, line disciplines, and an arrayof eight special control characters.andP;  The termio structure is shown in Figure5.andM;Each flag in the termio structure is actually a collection of several flagsthat produce a bit pattern fitting into an unsigned short.andP;  The flags havethe effects listed below.andM;c_iflag Instructs the device how to react to received input.andP;  Break, paritygeneration, parity checking, bit stripping, carriage return to new linemapping, uppercase to lowercase mapping, and XON/XOFF software handshakingcan be set.andM;c_oflag Instructs the device how to process output.andP;  Mapping of case, newline translation, fill characters, and delays for CR, HT, NL, and BS can beset.andM;c_cflag Allows the setting of speed (bps), character size, stop bits, parityoptions, and control of data terminal ready (DTR), request to send (RTS), anddata carrier detect (DCD) RS-232 control signals.andM;c_lflag Enables exception handling, input-queue processing, echoing, lineediting, buffer management, and mapping of special characters.andM;c_line Selects a line discipline; usually set to 0.andP;  The line disciplineselects a mode of mapping (filtering) characters from a raw input queue to acanonical input queue (this will be explained later).andP;  This filter mechanismallows line editing, conversion of lowercase to uppercase, expansion of tabs,and so on.andP;  Most UNIX systems support only one well-established linediscipline, but other disciplines have been implemented (for example, forhandling synchronous data links supporting SDLC types of communications).andM;c_cc[NCC] An array of eight characters that can be assigned to represent theinterrupt and quit signals (such as andless;C, DEL, and BREAK), the erase character,EOF, and EOL.andP;  Some of the c_cc[] positions have dual meanings that depend onother flags, specifically the c_cc[4] (EOF, MIN) and c_cc[5] (EOL, TIME)positions.andM;All of the flags of the termio structure are set by using the bitwise AND(andamp;)and OR(|) operators with the constants provided in the termio.h include file.andO;Figure 6 describes many of the possible flags.andP;  They are fully documented inthe manual pages under termio(M) (Xenix) and termio(7) UNIX System V and byvendors of equivalent drivers for DOS.andM;The fragment of code shown in Figure 7 demonstrates how to open and obtainthe current attributes for the device /dev/tty01.andP;  Flags are assembled tochange the speed to 9600 bps, to change the number of data bits to 7, and toenable reading.andM;Once the flags are configured, a call to IOCTL is made to set the attributes.andO;Set all values of the termio structure to valid values so the driver will notconfigure randomly.andP;  Also check return codes from library calls (discussedlater).andM;Data AcquisitionandM;Computer-to-terminal communications is a simple, general, and easily testedform of data acquisition.andP;  The program in Figure 8 will send a requestmessage to an attached I/O device and expect a 10-byte response back within 2seconds.andP;  If the expected response is received in time, data received backfrom the device is written to a log file: otherwise error recovery isstarted.andP;  Most, but not all, data acquisition devices request responses in asimilar way.andP;  If an unsolicited response arrives, it will be buffered for thenext read and is not lost.andP;  Selected attributes for the device, which aregiven below, are stored in the termio structure.andM;c_iflag IGNBRK advises the driver to ignore the break sequence completely ifthe break signal is received.andP;  The driver could otherwise cause an interruptsignal to be sent to the application.andP;  IGNPAR states that any receivedcharacters containing detected parity errors are ignored.andP;  IXON enablessoftware flow control on the output stream; IXOFF enables the same on theinput stream.andM;c_oflag No flags are selected and all features represented by this flag aredisabled.andM;c_cflag B4800 selects the bit rate of both the transmit and receive channels.andO;CS8 advises that 8 data bits be sent and received.andP;  CREAD enables the readsystem call to transfer characters from the device driver's buffer.andP;  HUPCLdrops the DTR signal on the last close of the device (the device can beopened more than once).andP;  CLOCAL advises the device not to examine the CDCsignal as a qualifier when the driver opens the device.andM;c_lflag No flags are selected, and all features represented by this flag aredisabled.andM;c_line The default line discipline is O.andM;c_cc[0] (VINTR) Not used since the ICANON | ISIG flags are not set.andM;c_cc[1] (VQUIT) Not used since the ICANON | ISIG flags are not set.andM;c_cc[2] (VERASE) Not used since the ICANON | ISIG flags are not set.andM;c_cc[3] (VKILL) Not used since the ICANON | ISIG flags are not set.andM;c_cc[4] (VEOF/MIN) Since the ICANON flag is not set, c_cc[4] contains theminimum number of characters that must be collected by the driver before aread call is satisfied.andP;  Otherwise it would represent the EOFcharacter.c_cc[4] can be used in tandem with c_cc[5].andM;c_cc[5] (VEOL/TIME) Since the ICANON flag is not set, the c_cc[5] attributecontains the number of 0.10 second increments the driver should wait forbefore returning from a read.andP;  Otherwise it would represent the EOLcharacter.andP;  c_cc[5] is a watchdog that will wait until the requested (orminimum) number of characters is available or the timer has expired,whichever comes first.andP;  This feature allows application programmers tospecify the amount of time to wait for an attached serial device to sendsomething (for example, after a query has been sent to it).andP;  c_cc[4] andc)cc[5] let you specify the minimum number of characters that must becollected and/or the maximum amount of time to wait for the characters; notiming loops are required in the application.andM;c_cc[6] Reserved.andM;c_cc[7] (SWITCH) Not used.andM;Note that the stream buffers for the tty_stdin and tty_stdout have been setto length 1.andP;  This example can be adapted to work with almost any I/O devicethat is request/response driven.andP;  As characters arrive, they are buffereduntil the next read call is satisfied.andP;  tx_block and rx_block are simplecharacter arrays; they could be structures containing more detailedinformation about what is sent and received.andM;A Also note that the path name of the device is /dev/tty01.andP;  This is astandard pathname to a UNIX device driver residing in the /dev directory.andO;Curiously enough, /dev/tty01 is also a valid path under DOS to the devicetty01.andP;  The Microsoft C run-time library translates the forward slash (/) tothe back slash (\) in file or device pathnames on calls to file systemroutines.andP;  However, \dev\tty01 must be used at the DOS command line (batchfile) level.andM;Input and Output QueuesandM;Once the serial device attributes have been selected and set and the devicehas been opened, I/O may begin.andP;  Three queues are maintained by the UNIXserial device driver--the output queue, which can be written to, and the rawand canonical queues, which can be read.andP;  (Do not confuse these queues withstdin, stdout, and stderr.)andM;Characters that are written to the device are copied to the output queue fortransmission.andP;  Depending on flag settings, delays and/or translations may beperformed as characters are transmitted.andP;  Figure 9 shows the relationship ofthe raw and canonical input queues.andP;  An application can choose to readcharacters from either.andP;  The raw input queue is simple: anything received(excluding parity errors and break sequences) is buffered and passed directlyto the application.andP;  When reading from the raw queue, it is possible toconfigure the driver to implement a watchdog timer or specify a minimumnumber of characters that must be available before a read completessuccessfully.andP;  The size of the raw queue is limited by a shared pool ofbuffers; these buffers, called clists under UNIX, are dynamically allocatedand released.andP;  There is no pool of clists under DOS; buffers are usuallyfixed, because the device driver is accessed through the DOS file system.andO;Remember that DOS is not reentrant, so it is nearly impossible to performdynamic memory allocation of clists inside any DOS device driver.andM;The canonical input queue obtains its characters from the raw queue via aline discipline.andP;  The line discipline is analogous to a filter; as acharacters are obtained from the raw queue, they may be translated to othersequences.andP;  For example, CR can translate to NL (ICRNL flag).andP;  The canonicalinput queue is enabled with the ICANON flag, which also advises the devicedriver to look for the special characters in the c_cc[] array and takeappropriate action in accordance with the IBRK and ISIG flags.andM;Interactive TerminalsandM;Interactive programming requires a special style of coding.andP;  People are muchless predictable than machines, so special care must be taken when promptingand handling responses (valid or invalid).andP;  This example assumes that thereis a dumb terminal or PC connected to the serial port, either directly orthrough a modem.andM;The program in Figure 10 is trivial if input is from and output is to the DOSconsole device.andP;  During an interactive session at a remote terminal on aserial link, however, special precautions must be taken.andP;  When the terminalattached to the serial link is prompted for an integer, there are threepossible responses: correct, incorrect, or no response.andP;  The enclosed switchstatement handles these three cases.andP;  This example sets up a terminal withmany of the features that a shell might use for command line interpretation,notably line editing, character echoing, and abort sequences.andM;Selected attributes for the device, given below, are stored in the termiostructure.andP;  Note that the buffers for the streams tty_stdin and tty_stdouthave been set to length 1.andM;c_ifla IGNBRK advises the driver to ignore the break sequence completely ifthe break sequence is received; otherwise, the driver could cause aninterrupt signal to be sent to the application.andP;  IGNPAR states that anyreceived characters containing detected parity errors are ignored.andP;  IXONenables software flow control on the output stream.andP;  IXOFF enables softwareflow control on the input stream.andP;  CLOCAL disables modem control; DCD isignored when opening the device.andP;  ICRNL specifies that the CR character isconverted to the LF ('\n') character on input.andM;c_oflag OPOST enables the post-processing of output.andP;  ONLCR converts the '\n'(LF) character to the CR/LF characters on output.andP;  OCRNL converts the CRcharacter to the LF ('\n') character on output.andP;  TAB3 expands the horizontaltab character to spaces up to the next tab stop.andP;  Tab stops usually occurevery eight characters.andM;c_cflag B4800 selects the bit rate of both the transmit and receive channels.andO;CS8 advises that eight data bits are sent and received.andP;  CREAD enables theread system call to transfer characters from the device driver's buffer.andO;HUPCL drops the DTR signal when the device is closed for the last time.andO;CLOCAL advises the device not to examine the DCD signal as a qualifier inopening the device.andM;c_lflag ICANON enables the processing of character filtering from the rawinput queue to the canonical input queue.andP;  Line editing and character echoingis now performed by the device driver.andP;  The watchdog for a timer and/or aminimum number of characters seen in the last example is no longer active.andO;c_cc[4] and c_cc[5] now contain characters representing EOF and EOL,respectively.andP;  ISIG tells the driver to check each input character againstthe special characters designated in the c_cc[] array for INTR, QUIT, andSWTCH.andP;  If any of these characters are found in input, the appropriate actionis taken (that is, signals are sent).andP;  ECHO echoes all characters received tothe output queue.andP;  ECHOE echoes the designed erase character as BS-SP-BS,thus erasing the character in error.andM;c_line Selects a line discipline; usually set to 0.andM;c_cc[0] (VINTR) If matched on input, the interrupt signal is sent to thecontrolling process.andP;  Under DOS, the current process is killed.andP;  Note thatthe ICANON | ISIG flags are set in c_cflag.andM;c_cc[1] (VQUIT) If matched on input, the quit signal is sent to thecontrolling process.andM;c_cc[2] (VERASE) If matched on input, the last valid character entered iserased.andM;c_cc[3] (VKILL) If matched on input, whatever has been assembled in thecurrent line is erased.andM;c_cc[4] (VEOF/MIN) This is the designated EOF character, typically andless;Z (DOS)or andless;D (UNIX), although any character will work.andM;c_cc[5] (VEOL/TIME) represents the EOL character; typically '\n'; anycharacter will work, however.andP;  This character is the anchor used by the linediscipline routines to mark the end of a line.andP;  Typically lines are assembledand edited by the user.andP;  When the EOL character (stored in c_cc[5]) isreceived, the line is available for reading by the application.andM;c_cc[6] Reserved.andM;c_cc[7] (SWTCH) Not used.andM;Serial LinkandM;The examples of data acquisition and request/response communicationsdiscussed in Figures 8 and 10 demonstrated important and useful features whenusing the UNIX (or compatible) serial I/O device driver.andP;  All I/O wasperformed with familiar calls to the C standard library.andP;  Many usefulfeatures of the UNIX serial I/O device driver can save the C programmer manyheadaches--features such as watchdog timeouts, buffering in both the TX andRX directions, CR and LF translation on both input and output streams, lineediting, tab expansion, and XON/XOFF software handshaking.andP;  One commoninterface, IOCTL, is used to adjust device parameters using a standard systemcall.andP;  Serial I/O software is portable between UNIX and DOS systems.andM;There are other modes of serial link communications and other programmingcontexts, but they are usually variations of one of the examples presented.andO;Advanced techniques of serial communication programming might address any ofthe following topics.andM;Advanced Modem Control If the CLOCAL flag is cleared, the device will waitfor the DCD line to become active for an open call to complete.andP;  This allowsthe application to block for a modem connection before the device driveropens.andP;  UNIX programmers can set the O_NDELAY flag when performing an openoperation.andP;  The open function will then use errno to return immediately,indicating success (DCD present) or failure (DCD absent) in opening thedevice.andM;Reacting to Interrupt Signals Under UNIX, the reception of DEL or andless;\(changeable defaults in the c_cc[ ] array) sends the signals interrupt orquit, respectively.andP;  Reception of a BREAK sequence will also send theinterrupt signal.andP;  If the flags ICANON | ISIG are set, a signal is sent tothe controlling process.andP;  Under DOS, some device drivers provide an option tokill the currently executing process by issuing DOS interrupt 4BH.andM;Sending the BREAK Character Calls can be made to IOCTL to send the BREAKcharacter.andP;  See the IOCTL command TCSBRK.andM;Forcing the Driver XON/XOFF State Calls can be made to IOCTL to suspendoutput and restart suspended output.andP;  See the IOCTL command TCXON.andM;Handling Parity Errors If parity checking is enabled by setting the PARENBand PARMRK flags and clearing the IGNPAR flag, a character (X) received witha parity error is passed as a special sequence ('\x7F', '\0', X) to identifythe character in error.andP;  The character '\x7F' is then read as '\x7F','\x7F'.andM;Recovering from DOS Critical Errors DOS will translate critical errors tointerrupt vector 24H.andP;  If the application traps this interrupt, all criticalerrors encountered by a device driver should trap the user's exceptionhandler with sufficient information (device name and type of critical error)to recover.andM;Command Line InterfaceandM;As mentioned earlier, an advantage to performing serial I/O with a devicedriver is having access through the file system.andP;  Command line redirection(and batch/shell files) can communicate with the device.andP;  For example, underDOS the commandandM;C[is greater than]dir [is greater than] \dev\tty01andM;sends a directory listing to a serial device.andP;  Note that no mention has beenmade of how to change device attributes from the command line.andP;  This isaccomplished with the UNIX command stty.andP;  The stty command is also capable ofobtaining the current attributes of a device and displaying them.andP;  The samecommand is available with DOS serial device drivers; however, DOS requiresthe device path to be \dev\tty01.andP;  Refer to Figure 11 for an example of sttyunder both DOS and UNIX.andM;In the examples in Figure 11, the stty program reopens its standard input,the serial device /dev/tty01, and sets its attributes to 9600 bps, evenparity enabled, 7 data bits per character, XON/XOFF software handshakingenabled, and modem control enabled.andP;  This configuration allows communicationwith a popular laser printer over the serial link.andP;  In the two commands shownin Figure 12, file_1 is sent through a PostScript[r] preparation filter andfinally to a printer attached to /dev/tty01.andM;System InterfaceandM;There are some intrinsic features of the operating system that concern bothUNIX and DOS programmers that you should be aware of when opening a serialdevice for I/O.andP;  The first concern is how the blocking (or processsuspension) is handled.andP;  Under DOS, there is no facility to suspend a processon the assumption that it will resume running when some event has occurred(or has not occurred).andP;  Under UNIX, a terminal driver can cause thesuspension of a process if there are no characters to read or a line has notyet been completely assembled via a selected canonical line discipline.andP;  Oncecharacters are ready or a line has been assembled, a suspended (or blocked)process is awakened to run.andP;  Since DOS has no facility that suspends aprocess to wait for I/O, any request to a device driver should returnimmediately (after checking for set watchdog timers), whether characters (orlines) are ready or not.andP;  If nothing is available, EOF can be returned.andM;The second concern is that there are differences in the treatment of EOFindications.andP;  DOS supports two access modes for reading and writing characterdevices--ASCII text mode and binary mode.andP;  If the character 1aH ([and]Z) isread, the input from a file or device opened in text mode is terminated (shutdown) and an EOF indication is returned.andP;  Even if there are characterspending, any and all read requests from this point forward are ignored andthe EOF indication is always returned.andP;  If the file were opened in binarymode, the EOF character ([and]Z) would be passed to the application, andfurther requests for characters would be honored.andM;Text mode also insists on translating LF to CR/LF on output and CR/LF to LFon input, so I/O in text mode could add characters or delete them.andP;  Binarymode reads and writes exactly what is requested.andP;  These features areintrinsic to DOS.andM;DOS device drivers should return EOF if there is nothing to read (afterchecking for set watchdog timers).andP;  A device driver could block the processattempting the read; the application might then hang forever waiting for acharacter.andP;  If EOF is returned, the application can do something else andattempt another read later.andP;  Anything that arrives between reads will bebuffered.andM;When the EOF character, designated by c_cc[4], is received by a UNIXcharacter device driver, all characters waiting to be read are immediatelypassed to the application without waiting for a new line, and the EOF isdiscarded.andP;  Thus if no characters are waiting in the input queue--that is, ifEOF occurred on the beginning of a line--no characters will be passed back tothe application; this is a standard EOF indication under UNIX.andM;The third concern is the difference in the treatment of signals.andP;  The signalmechanism available under the UNIX operating system is not available underthe DOS operating system, although most C run-time libraries, most notablyMicrosoft C 5.10, have mechanisms that perform similar functions.andM;The signal() function call allows the UNIX and DOS programmer to catchspecial messages sent to processes when exceptions such as floating pointoverflow, [and]C, and modem disconnect occur.andP;  Async device drivers underUNIX are also able to send signals to related processes.andP;  These signals aretypically INTR, QUIT, HANGUP, and BREAK.andP;  DOS does not provide the signalmechanism that UNIX does, although DOS drivers can be designed to havesimilar functions.andM;ConclusionandM;This article explored how to write portable serial I/O software, usefulfeatures of a general serial I/O device interface operating under both UNIXand DOS.andP;  UNIX and its many hybrids all share the same serial I/O interface.andO;With ATandamp;T, Digital Equipment, Hewlett-Packard, IBM, Microsoft, and othercompanies, embracing UNIX as a standard product offering, it simply cannot beignored by the professional programmer.andM;(1) As used herein, &quot;DOS&quot; refers to the MS-DOS and PC-DOS operating systems.andM;Michael Chase is a principal of the Boulder Software Group, which providescontract programming services and instruction on C and UNIX to ATandamp;T, DEC, andIBM.andP;  He is also a faculty member in the Univ.andP;  of Colo.andP;  M.S.andO;Telecommunications program.andO;</TEXT></DOC>