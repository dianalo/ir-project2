<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-039-696  </DOCNO><DOCID>08 039 696.andM;</DOCID><JOURNAL>Communications of the ACM  Jan 1990 v33 n1 p70(11)* Full Text COPYRIGHT Association for Computing Machinery 1990.andM;</JOURNAL><TITLE>DATAPLEX: an access to heterogeneous distributed databases.andO;</TITLE><AUTHOR>Chung, Chin-Wan.andM;</AUTHOR><SUMMARY>Standardizing on a single DBMS is difficult for largeorganizations because different units have diverse requirements,because each DBMS can run only on certain machines, and becausetransition from one to another is costly.andP;  Heterogeneousdistributed databases solve these problems, letting each datacenter select the best DBMS for its own needs.andP;  General MotorsResearch Laboratories' DATAPLEX heterogeneous distributed DBMS isdescribed.andP;  DATAPLEX consists of 14 modules and provides a datadictionary manager, data security, and error handling.andP;  It offerscontext-dependent access control and uses a time-out method todetect global deadlocks when updating information.andP;  The datatranslation process always loses some information aboutnon-relational data definitions; this information must be storedin the translation table.andP;  A prototype DATAPLEX system is nowbeing tested.andM;</SUMMARY><DESCRIPT>Topic:     Data base management systemsMultivendor SystemsDistributed Data BasesTechnologyQuery Processing.andO;Feature:   illustrationchart.andO;Caption:   DATAPLEX and other elements in a heterogeneous DDS. (chart)The data structure diagram of the entity relationship. (chart)Relationship between data definition and transaction translation(chart)andM;</DESCRIPT><NOTE>Only Text is presented here; see printed issues for graphics.andO;</NOTE><TEXT>DATAPLEX: An Access to Heterogeneous Distributed Databases In a typicaldata-management environment of the manufacturing industry, there are a numberof engineering, manufacturing, and business data centers run by variousgeographically dispersed units.andP;  The choices of database management systems(DBMSs) by these data centers are diverse.andP;  Furthermore, there can be severaldifferent DBMSs in a data center.andM;Currently, there are no effective means to share these heterogeneousdatabases.andP;  The lack of effective data sharing causes inefficient engineeringand manufacturing activities and business operations.andP;  Duplicated data atdifferent locations results in data inconsistency.andP;  The development of thesame applications in different data manipulation languages used by differentDBMSs incurs unnecessary human cost.andM;One way to solve this problem is to standardize on a single DBMS.andP;  In a largeorganization, however, it is difficult to standardize on a single DBMS forthe following reasons:andM;* The requirements of the DBMS from different units are diverse.andP;  Some DBMSsare better than others in processing a particular class of applications.andO;There is no single DBMS that satisfies all these requirements.andM;* Each DBMS can run only on certain computers.andM;* Transition from one DBMS to another is extremely expensive because ofdatabase and application conversion.andP;  Initial standardization requires a highconversion cost.andP;  Also, technology is rapidly changing.andP;  If a new standardDBMS is chosen to replace an old one in order to take advantage of newtechnology, all the data and applications in the organization have to beconverted.andM;Consequently, coexistence of many different DBMSs is a way of life in largeorganizations.andP;  In light of diverse DBMSs and the existence of cooperatingautonomous components in an organization, the heterogeneous DDS is aneffective means of sharing data.andP;  The heterogeneous DDS can facilitate thefollowing.andM;* Each data center can select the best DBMS for its environment because theheterogeneous DDS allows the co-existence of different DBMSs.andM;* When a DBMS of a data center is obsolete, the DBMS can be changed withoutimpacting other data centers.andM;* When a DBMS has to be changed, the old DBMS and the new one can communicateas members of the heterogeneous DDS until the conversion process is complete.andO;This allows a phased conversion for a certain period, and it makes a smoothtransition.andM;Although there has been some work on the heterogeneous DDS [1, 2, 12, 13,15-17], this area is relatively new and there is no proven solution for manytechnical problems.andM;DATAPLEXandM;DATAPLEX is a heterogeneous distributed database management system (HDDBMS)being developed by General Motors Research Laboratories.andP;  The key concept ofits approach is to use the relational model as a common data model and theStructured Query Language (SQL) as a standard query language.andP;  This allows usto take advantage of the merits and wide acceptance of SQL and the relationalmodel and to use results from the research on the homogeneous relational DDS.andM;The architecture of DATAPLEX is an open architecture which provides awell-defined interface that can be extended to any DBMS and file system.andP;  Aprototype system has been developed that interfaces a relational DBMS and anon-relational DBMS using the DATAPLEX approach.andP;  The prototype systemprocesses all the test transactions correctly, and the performance of thesystem is reasonable.andP;  Based on the success of the prototype system.andP;  GeneralMotors Research Laboratories have initiated the development of afull-function DATAPLEX.andP;  This article presents the architectural design ofDATAPLEX and a prototype system that validates a major portion of itsarchitecture.andM;ARCHITECTUREandM;The architecture of DATAPLEX consists of fourteen functionally-independentmodules.andP;  This architecture is based on the relational model of data.andO;Different data models used by unlike database systems structure datadifferently.andP;  The data definition used by each database system is called thelocal schema.andP;  The data definition of all the sharable databases in theheterogeneous DDS is transformed to an equivalent relational data definition.andO;This common relational data definition is called the conceptual schema.andP;  Theconceptual schema will include the relational data definition of only thestored data objects and local views.andP;  Each user's view of data in theheterogeneous DDS is called the external schema which consists of a subset ofthe conceptual schema and the global views derived from the data objects inthe conceptual schema.andM;The relational model has been selected for the conceptual schema and theexternal schema for the following reasons:andM;* The relational model is easy for users to understand, and it supportshigh-level query languages.andM;* A relational transaction can be translated to a program in a low-levelnon-relational data manipulation language (DML) whereas the reversetranslation is very difficult.andM;* The derivation of global views and the translation between the externalschema and the conceptual schema are simple.andP;  These can be done in the sameway as existing relational DBMSs do them.andM;* Relational DBMSs are wide-spread.andP;  For relational DBMSs, the translationbetween the conceptual schema and the local schema is trivial.andM;Since we use a common data model for the external schema, a uniform userinterface can be provided.andP;  Among several relational query languages, we havechosen SQL as the uniform user interface because SQL is widely used and thereis a movement to make SQL a standard relational query language.andM;Transaction will be translated at the location of the computer in which thedata referenced by the transaction is stored (data location) rather than thelocation of the computer from which the transaction is originated (userlocation).andP;  The translation at the data location makes it possible toreplicate only the crucial information such as the conceptual schema and thelocation of data in the DATAPLEX dictionary at every location.andP;  The detailedinformation necessary for transaction translation and query optimization canbe stored at the data location.andP;  A query involving data a multiple locationsis decomposed at the user-location into sub-queries each of which referencesdata from a single location.andM;The above strategies establish the architecture of DATAPLEX.andP;  Figure 1 showsDATAPLEX and other elements in a heterogeneous DDS.andP;  The names and functionsof the fourteen modules that constitutes the architecture are as follows:andM;* Controller--sequences and invokes necessary modules to process atransaction depending on the type of the transaction.andP;  This module suppliesnecessary parameter values to each of the other modules and processesmultiple transactions at the same time by means of multitasking.andM;* User Interface (basic user interface)--prompts a user to issue SQL queriesin a line or full-screen mode and returns messages and/or results to theterminal.andM;* Application Interface--sets up communication between an application andDATAPLEX.andP;  This module identifies SQL statements in the application andrecords an SQL transaction in the transaction log as an attemptedtransaction.andP;  It returns messages and/or data to the application and updatesthe status of a completed transaction as a successful transaction.andM;* SQL Parser--scans and parses SQL statements to check syntactic errors.andP;  Itchecks whether a query references correct names of relations and attributes.andO;It transforms a query that references global views to a query that referencesonly stored data objects and local views.andM;* Data Dictionary Manager--provides facilities to create a DATAPLEXdictionary.andP;  It provides facilities to query or update information in theDATAPLEX dictionary including the location of referenced data.andM;* Security Manager--enforces the content-independent access control using theglobal data object names andandM;the userid.andP;   It enforces the content-dependent accessandM;control using the views as protection objects.andM;* Distributed Query Decomposer--decomposes a distributed retrieval query intolocal queries and user-location queries which merge local results.andP;  (A localquery references data from a single location which may be a remote location.)andO;It decomposes a distributed update query into a distributed retrieval partand a distributed update part.andP;  It decomposes the distributed retrieval partas above and generates a set of local update queries (one for each relationto be updated).andM;* Distributed Database (DDB) Protocol--interfaces the underlyingcommunication protocol (or medium).andP;  This module should be easily adaptableto different communication protocols.andP;  It exchanges commands and data withthe remote DDB Protocol using the file and message transfer facilities of theunderlying communication protocol.andP;  It provides necessary functions of thesefacilities that are not provided by the communication protocol.andP;  It detectsand reports any problem associated with the accessing of remote data.andM;* Translator--translates an SQL transaction to another relational transactionor a non-relational database program using a syntax transformation table fromSQL to another relational query language, a set of rules to transform anon-relational data definition to an equivalent relational data definition,and stored information that can be lost during the transformation of anon-relational data definition to a relational data definition.andP;  Ittranslates between global names and local names when they are different.andP;  Itperforms any necessary conversion of field formats such as the data type andthe field length.andM;* Local DBMS Interface--interfaces a local DBMS.andP;  It passes the translatedtransaction and obtains the result.andM;* Distributed Query Optimizer--collects data-volume information andstatistical information of local results from the locations involved in adistributed query and schedules an optimal data reduction plan.andP;  It executesthe data-reduction plan by sending commands to the involved locations.andM;* Distributed Transaction Coordinator--requests both locks and lock releaseson local data in a manner to correctly process a distributed transaction.andP;  Itdetects and handles global deadlocks.andP;  It enforces update atomicity inprocessing a distributed update and an update for multiple copies of datafiles in case of local system or communication network failures.andM;* Relational Operation Processor--is capable of processing relationaloperations for merging local results, reducing data during distributed queryoptimization, and further manipulating intermediate results locally.andM;* Error Handler--corrects recoverable errors, aborts the transaction, andcleans up the system for a non-recoverable error.andP;  It sends an appropriatemessage to a user and records it in the transaction log.andM;The way of packaging the above modules into processes depends on the detaileddesign consideration.andP;  In this section, we assume that DATAPLEX is oneprocess for simplicity.andP;  DATAPLEXs at the user location and the datalocation(s) communicate through the DDB Protocol.andP;  The modules Translator andLocal DBMS Interface are not used at the user location unless the userlocation is the same as the data location.andP;  Similarly, the modules UserInterface, Application Interface, SQL Parser, and Distributed Query Optimizerare not used at the data location.andM;This architecture is independent of the local data system except for themodules Translator and Local DBMS Interface.andP;  Any data system can beinterfaced to DATAPLEX by developing these two modules for it.andP;  Also,different communication protocols can be used by adapting the DDB Protocol tothem.andP;  The solutions to technical problems, developed for some of themodules, are described next.andM;Distributed RetrievalandM;Our query decomposition generates local queries in SQL in a textual formrather than other equivalent representations used by some relational DDBMSs.andO;This is an important consideration in a heterogeneous DDS because thetranslation is basically the text manipulation.andP;  Also, some of the majornon-relational DBMSs will provide an SQL interface soon.andP;  SQL allows nestingof a query within another query.andP;  A nested query can be processed as asequence of non-nested queries by processing the inner queries in the nestfirst.andP;  Also, the nesting can be eliminated by transforming a nested query toan equivalent non-nested query [11].andP;  A non-nested query is transformed intoa set of aggregate-free conjunctive queries.andP;  The part of the non-nestedquery requiring aggregate operations (e.g., set functions, GROUP BY, ORDERBY) forms a separate query which performs aggregate operations on the resultof the remaining aggregate-free query.andM;A non-conjunctive query is decomposed into a set of conjunctive queriescontaining only AND Boolean operators:andM;(1) NOT's are eliminated by using DeMorgan's Law and negating relationaloperators such as equals to (=) and greater than (andgt;).andM;(2) OR's and parentheses are eliminated by transforming the predicate into adisjunctive normal form and processing each conjunctive term as a separatequery.andM;The result of the non-conjunctive query is the union of the results producedby the conjunctive queries.andP;  Each distributed conjunctive query istransformed to a query graph with relations as nodes and qualification termsas edges.andP;  Using the location information, the edges that correspond toglobal join terms are deleted from the query graph, and the global join termsare assigned to the qualification of the user-location query.andP;  Consequently,the query graph is decomposed into connected sub-graphs that are transformedback to local queries.andP;  The algorithm that decomposes a distributedconjunctive query into a set of local queries and a user-location query andthe proof of the correctness of the algorithm are shown in [4].andM;If there are multiple data systems in a computer, a local query to thiscomputer has to be further decomposed into a set of queries.andP;  Each mustreference data from a data system.andP;  In this case, the location becomes thesystem identification of a data system.andP;  Our query-decomposition method canalso be used for this case without any modification.andP;  Our data-reduction planfor distributed query optimization [5] is a sequence of semi-joins whichconsists of local data-reduction operations and data moves among computers.andO;The plan generated by the distributed query optimizer significantly reducesthe amount of data moved among computers in processing a distributed query.andM;Distributed Data SecurityandM;The data security enforcement of DATAPLEX is a content-dependent accesscontrol (CDAC).andP;  In a CDAC, access rules can include a predicate whose truthdepends on the content of data; whereas, in a content-independent accesscontrol (CIAC), access rules are defined only on the types of data.andP;  Sincenot all DBMSs support CDAC it must be handled by DATAPLEX.andP;  A CDAC in aheterogeneous DDS is described in [16, 17].andP;  Our access control is similar tothe above one in that views are used as protection objects [3]; however, itdiffers from the above one in that DATAPLEX does not materialize views astemporary relations.andP;  In a DATAPLEX environment, the security is enforced intwo steps: 1) first by DATAPLEX and 2) then by local DBMSs.andP;  The accesscontrol by DBMSs preserves the local autonomy.andM;A global database administrator (GDBA) creates a DATAPLEX dictionary andgrants to users access privileges to global data objects in the dictionary.andO;The GDBA may create a view that contains a predicate to enforce a CDAC.andP;  Whenthe GDBA grants access to a global data object to a user, the followinghappens:andM;(1) If the global data object corresponds to a local data object managed by alocal DBMS (this may be a local view if the DBMS supports views), the userbecomes an authorized user of the local data object at the location of thedata object.andM;(2) If the global data object is a global view defined on one or more localdata objects (these may have been created by different users possibly atdifferent locations), DATAPLEX becomes an authorized user of the local dataobjects at the location of the data objects.andM;When a user issues a query to DATAPLEX, the user-location DATAPLEX performs acontent-independent security check using the userid and the global dataobjects referenced in the query.andP;  The processing of the query continues onlyif the check succeeds.andP;  If the global data objects in the query are all localdata objects, the query and the userid are sent to the location of the dataobjects where a local DBMS checks the security.andP;  In case of a distributedquery, the query is decomposed and subqueries are sent along with a userid.andM;If the query references a global view, the query is modified [14] using thedefinition of the view.andP;  The resulting query references only local dataobjects and contains the predicate, if any, in the view definition thatenforces a CDAC.andP;  The modified query is sent to the location of the localdata objects along with DATAPLEX (i.e., security code of DATAPLEX) as auserid rather than the original userid.andP;  Since DATAPLEX is authorized toaccess the local data objects as described above in (2), the modified querypasses the local security check.andP;  In this method DATAPLEX becomes a superuser to a local DBMS.andP;  This is similar to the situation in which a DBMSbecomes a super user to a file system so that a user's access, checked by theDBMS, will not be checked again using the userid by the access control of theunderlying file system.andP;  The user's request becomes an access by the DBMS tofiles.andM;Distributed UpdateandM;There are three problems associated with the distributed update: distributedconcurrency control, distributed deadlock handling, and distributed datarecovery.andP;  Since these problems require more research, we only outline ourapproach.andP;  Local DBMSs provide concurrency control, deadlock handling, andrecovery for local databases.andP;  We assume that local concurrency control isbased on the locking, which is true for most, if not all, commerciallyavailable DBMSs.andP;  Our method for distributed concurrency control is toglobally perform the two-phase locking [9].andP;  Since local DBMSs perform thetwo-phase locking locally, an additional task of DATAPLEX is to prevent localDBMSs from releasing locks until update processing at other involvedlocations is complete.andM;DATAPLEX will initially use the time-out method to detect global deadlocks.andO;In this method, no response from a target DATAPLEX within a pre-arranged timeis regarded as a global deadlock.andP;  Therefore, the method is based on anecessary condition for the deadlock.andP;  The advantage of the time-out method,however, is that it is simple and applicable to both the homogeneous DDS andthe heterogeneous DDS.andM;A basic method for recovery is the two-phase commit to enforce the updateatomicity.andP;  The two-phase commit consists of a prepare-to-commit (PTC)followed by an actual commit.andP;  Once a DBMS reaches a PTC state, the recoveryto this state or to the initial state prior to an update processing ispossible.andP;  The distributed two-phase commit can be done if local DBMSsprovide the PTC state at the request of DATAPLEX.andP;  DBMSs currently do notprovide an external interface to perform PTC.andP;  They internally perform a PTCfollowed by a commit in response to an external commit request.andP;  Therefore,this is an open problem that requires more research, and it is an importantarea for standardization of DBMSs to provide an external interface for PTC.andO;Since the distributed two-phase commit forces local DBMSs to commit andrelease locks only after all DBMSs involved in a distributed update areprepared to commit, this automatically satisfies the distributed concurrencycontrol by enforcing global two-phase locking.andM;TRANSLATIONandM;In a heterogeneous DDS, different local DBMSs use different data models andprovide different DMLs.andP;  The translation of data definition and DML isnecessary to provide the relational model as a common data model and SQL as auniform user interface.andM;Non-relational data models that require the data definition translation arethe hierarchical model and the network model.andP;  The major difference betweenthe relational data model and the non-relational data model is the way ofmodeling relationships among entities.andP;  The relational model represents therelationship between two entities using a relation (data table); whereas, thenetwork model and the hierarchical model represent the relationship using anaccess path (pointer).andM;Two related entities have either a one-to-many relationship or a many-to-manyrelationship.andP;  These relationships are modeled in the hierarchical or networkmodel as below.andP;  The data structure diagram of the division record and theplant record and their one-to-many relationship is shown in part (a) ofFigure 2.andP;  An example of the many-to-many relationship is the relationshipbetween the frame and the part.andP;  The many-to-many relationship is modeled byidentifying two one-to-many relationships using an intersection data.andP;  Thedata structure diagram representing the many-to-many relationship between theframe and the part is shown in part (b) of Figure 2.andM;Our basic method for translating a non-relational data definition to anequivalent relational data definition is the use of the key in the ownerrecord as a foreign key in its member records.andP;  This is intended to produce asimple and normalized set of relations.andP;  The data definition depicted inFigure 2 is translated as follows:andM;One-to-many relationshipandM;DIVISION  (DIV#, DNAME) PLANT  (DIV#, PLT#, STATE)andM;Many-to-many relationshipandM;FRAME  (FR#, FNAME) ASSEMBLY  (FR#, P#, QTY) PART  (P#, MTRL)andM;The navigation through access paths in non-relational databases can beaccomplished by equi-joining relations in an equivalent relational datadefinition.andP;  For example, the access to part data used in certain frames isthe same as joins by FRAME.FR# = ASSEMBLY.FR# and ASSEMBLY.P# = PART.P#.andM;A repeating group in a non-relational data definition can he translated to anadditional relation or to sets of attributes (the number of the sets is themaximum number of repetitions).andP;  Therefore, an equivalent relational datadefinition is always in first normal form, a prerequisite for using arelational query language.andP;  Relations in higher normal forms, however, cannotbe generated unless the existing non-relational data definition isnormalized.andP;  Non-relational databases also have anomalies withoutnormalization.andP;  This situation is illustrated in the following example:andM;Consider an IMS database with one segment SUPPLY (S#, CITY, P#, QUANTITY)where the key consists of S# and P#.andP;  If a record is inserted with only thevalues o S# and CITY specified, the values of P# and QUANTITY areunpredictable.andP;  Therefore, the data for a supplier in a city cannot beinserted until the supplier supplies a part.andP;  An equivalent relational datadefinition of SUPPLY, which is the same as the IMS segment definition, is notin second normal form because CITY functionally depends on S# which is apartial key.andP;  The correct design of the IMS database consists of twosegments:andM;A parent segment: SUPPLIER (S#, CITY) with S# as a key A child segment:SUPPLY (P#, QUANTITY) with P# as a keyandM;This design does not have the above insertion anomaly.andP;  An equivalentrelational data definition of the two segments consists of two relationsSUPPLIER (S#, CITY) and SUPPLY (S#, P#, QUANTITY).andP;  They key of SUPPLIER isS# and the key of SUPPLY consists of S# and P#.andP;  These relations are in fifthnormal form because all the functional dependency is on the keys, and thereis neither multi-valued dependency nor join dependency.andM;One the conceptual schema is set up in relational data definitions, externalschemas are created from the conceptual schema, and users can formulate SQLtransactions.andP;  DATAPLEX must translate an SQL transaction that referencesrelations in the conceptual schema to a transaction in another relational DMLor a non-relational DML.andP;  Since the translation among different relationalDMLs is straightforward, we will only consider the translation tonon-relational DMLs.andM;The relational data model and the non-relational data model represent thesame information differently.andP;  The DML used to formulate requests oninformation is tightly coupled with the particular representation of theinformation.andP;  Therefore, two basic components for generating a transaction ina particular DML are the semantics of the information request (whatinformation is requested?) and the data definition which results from datamodeling.andM;In order to translate an SQL transaction to a non-relational databaseprogram, the semantics of the information request and the non-relational datadefinition of the data referenced by the transaction must be obtained.andP;  Thesemantics of the information request can be obtained from the SQLtransaction.andP;  In fact, SQL is specifically designed to represent thesemantics of an information request.andP;  The semantics include relation names,attribute names, and conditions on attribute values.andP;  In addition, accesspaths in the non-relational data definition can be partially derived from theSQL transaction.andP;  This can be achieved by applying an inverse of the datadefinition translation to the join terms of the SQL transaction because theaccess path in the non-relational data definition has been translated tojoining attributes in the relational data definition.andM;Nonetheless, some information about the non-relational data definition islost in the process of data definition translation.andP;  For example, the jointerm identifies the existence of an access path between the two records butcannot determine which one is the owner record.andP;  Also, an attributecorresponding to a foreign key in a relation may not exist in thecorresponding record.andP;  This misplaced attribute can also hide an actualaccess path.andP;  Therefore, the information that can be lost in data definitiontranslation must be stored in the translation table and used in thetransaction translation.andP;  This discussion is illustrated in Figure 3.andM;It is possible that the name of a record or a relation in a local database isused in another local database.andP;  Each relation in the conceptual schema mustbe distinctly named.andP;  Therefore, the names of relations in the conceptualschema can be different from those of the corresponding records or relationsin the local schema.andP;  In this case, the names in the conceptual schema haveto be translated to the corresponding local names in the local schema.andP;  Whenthe result is sent to the user location, the reverse translation isnecessary.andP;  In addition, the format and/or name of a field may need to betranslated when the format and/or name of the same field is defineddifferently at different locations.andM;The location of the transaction translation is important from the performanceand system-maintenance standpoint.andP;  We select the data location to translatetransactions for the following reasons:andM;* The translation at the user location would require each DATAPLEX to storetranslators and the translation tables for shared database at all locations.andO;Any change of the translation table to incorporate local data definitionchange would have to be propagated to all the locations.andM;* The size of a non-relational database program is generally much larger thanthat of an equivalent SQL transaction.andP;  Therefore, the user-locationtranslation incurs a higher communication cost.andM;* The data-location translation increases parallel processing for distributedtransactions.andM;PROTOTYPE SYSTEMandM;The prototype DATAPLEX interfaces IMS hierarchical DBMS on IBM/MVS and INGRESrelational DBMS on DEC/VMS.andP;  The prototype system allows users andapplications to retrieve data from IMS and/or INGRES with a single SQL queryfrom DEC/VMS such that the location of data is transparent to requestors.andO;The unique features of the prototype system are as follows:andM;(1)  SQL queries to IMSandM;(2)  Distributed SQL queries to IMS and INGRESandM;(3)  Distributed SQL queries embedded in a C language programandM;The following data formats are supported for IMS and INGRES databases:andM;* CharactersandM;* Text (variable length) fields with maximum 2000 bytesandM;* Integers in 2 bytes or 4 bytesandM;* Floating point numbers in 4 bytes or 8 bytesandM;* Packed decimal numbers, supported only the IMSandM;Since rapid prototyping was required to show the feasibility beforedeveloping a full-function DATAPLEX, the update of IMS data and the fullquery optimization were not implemented in the prototype system.andP;  Inaddition, the system supports a subset of SQL defined to have the followingsyntax:andM;SELECT  list of target attributes and set functions FROM  list of relationsWHERE  qualification ORDER BY  attributesandM;where set functins are MAX, MIN, SUM, COUNT, AVERAGE, and the qualificationcontains andgt;, andgt;=, andless;, andless;=, =, andless;andgt;, AND, OR, NOT, and parentheses.andM;DevelopmentandM;The core of the prototype system was structured in four processes as follows:andM;(1) User Interface (UI)--this process corresponds to the DATAPLEX modules:User Interface and Application Interface.andM;(2) Distributed Query Manager (DQM)--this process performs four majorfunctions.andM;* Distributed data dictionary managementandM;* Query parsingandM;* Decomposition and generation of an execution plan of distributed queriesandM;* Execution of query plans through communication with local DBMSsandM;This process corresponds to the DATAPLEX modules: SQL Parser, Data DictionaryManager, Distributed Query Decomposer, and a part of Distributed QueryOptimizer.andM;(3) IMS Interface--this performs the following functions:andM;* Receives queries from the Distributed Query Manager at the user locationand sends back resultsandM;* Translates SQL queries to DL/1 programs processable by IMSandM;* Local interface to IMS to submit DL/1 programs and return IMS dataandM;This process corresponds to the DATAPLEX modules: Translator and Local DBMSInterface.andM;(4) DDB Protocol--program-to-program communication is required to support thelogical interface between the IMS Interface on IBM/MVS and the DQM onDEC/VMS.andP;  A DECnet/SNA GATEWAY [7] from DEC was used to connect IBM's SystemsNetwork Architecture (SNA) network and DEC's DECnet.andP;  The primary functionsprovided by the DDB Protocol are as follows:andM;* Establishment of a session between DQM and IMS InterfaceandM;* A file transfer facility between DQM and IMS Interface to exchange SQLqueries and resultsandM;* Data format conversion between IBM 370 and DEC VAXandM;* Interface to the software used by the DECnet/SNA GATEWAYandM;The overall architecture of the prototype system is shown in Figure 4.andP;  On aDEC computer, DDB Protocol provides communication among the processes of UserInterface, DQM, and INGRES.andP;  DDB Protocol also provides the interface viaDECnet and the DECnet/SNA GATEWAY to the DDB Protocol running on the IBMside.andP;  Some modules on IBM/MVS were implemented in IBM assembler.andP;  The Clanguage was used to implement all other modules.andP;  The data security islocally enforced.andP;  The prototype system sends a query to a DBMS with auserid.andP;  INGRES enforces a CDAC; whereas, the IMS Interface enforces CIAC bychecking whether a user is authorized to access IMS data at a segment levelusing the userid.andM;Test BedandM;A test bed has been established at General Morots Research Laboratories.andP;  IMSis installed on an IBM 4381 MODEL 14.andP;  The IBM 4381 is a departmental testmachine which runs three MVS/XAs on top of VM.andP;  INGRES is installed on a DECVAX 11/785.andP;  Users run the prototype system through the VAX/VMS.andP;  A testdistributed database and test transactions were created.andP;  The testdistributed database consists of two IMS databases and an INGRES database.andO;The two IMS databases are named VEHICLE database and INVENTORY database.andP;  Thedatabase definitions and field definitions for application programs for thetwo IMS databases are represented in the data-structure diagram in Figure 5.andO;The underlined fields are the key fields of the segments.andM;An equivalent relational data definition of the IMS databases is given below.andO;The data type and format of each attribute is shown in the parenthesisfollowing the attribute name.andP;  C denotes a character data type, I an integer,F a floating point number, and TEXT a variable-length character string.andP;  Thelength of a field is specified in number of bytes following the data type.andM;VEHICLE (VID(C3), CARGROUP(C3), MILEAGE(F8), PRODVOL(14)) ENGCHA (VID(C3),CHGNUM(C5), CHGDATE(C8), DESIGNER(C15), DESCRIPT(TEXT MAX 50)) COMP (VID(C3),CNUM(C3), CATEGORY(C10), PRODDATE(C8)) ASSEMBLY (VID(C3), CNUM(C3), PNUM(C3),QTY(I2)) PART (PNUM(C3), MTRL(C10), PRICE(F8)) INVENTRY (PNUM(C3), WHNUM(C3),QOH(14))andM;This definition is derived using the method explained earlier.andP;  The INGRESdatabase consists of the following two relations:andM;SUPPLIER (S NUM(C3), LOC(C10), STATUS(C1)) SUPPLY (S NUM(C3), P NUM(C3),QTY(14))andM;Users formulate requests based on the relational view of the distributeddatabase which consists of the above eight relations.andP;  The location and thetype of the actual database are transparent to users.andP;  The sizes of thedatabases are small so that the correctness of the results of test queriescan be checked easily.andP;  The number of rows in each relation is between fiveand fifty.andM;ResultsandM;Twenty test transactions are formulated to check various functions of theprototype system: fourteen SQL queries to IMS databases, five distributed SQLqueries, and an embedded distributed SQL query in a C program.andO;Representative queries are listed in Appendix A.andP;  The prototype systemprocesses all the test transactions correctly.andM;The efficiency of the prototype system is measured and analyzed in tems ofquery processing time.andP;  The time is the clock time because the CPU time doesnot include the data transmission time in a communication network.andP;  Theaverage query response time is about 37 seconds when the prototype systemruns on an IBM 4381 and a DEC VAX 11/785.andP;  If an IBM 4381 is replaced by anIBM 3090, the average response time is estimated to be 12 seconds.andP;  It isobserved that the IMS Interface is the bottleneck of the prototype system forprocessing queries against small or medium-sized databases.andM;Production IMS data is used to test the effect of the size of the database onefficiency.andP;  The data is from the Maintenance Management Information System(MMIS) running at a car assembly plant.andP;  The size of the MMIS database isabout 1,000 times larger than that of the test IMS database.andP;  Three SQLqueries are executed against a part of the MMIS database whose data structurediagram is shown in Figure 6.andP;  An equivalent relational data definition ofthe MMIS database in Figure 6 and the SQL queries are listed in Appendix B.andM;The requests formulated as the three SQL queries were also programmed inPL/I, and the PL/I programs are executed locally on the IBM 4381 against theMMIS database.andP;  The processing time of the SQL queries by the prototypesystem and by the corresponding PLI programs is tabulated in Table I.andP;  Sincethe clock time varies considerably for different executions, Table I providesthe average time for five executions of the test queries and programs.andP;  Theresult in Table I shows that the prototype system incurs overhead comparedwith the access using PL/I programs.andP;  As the database size grows, thefraction of the overhead to the total processing time decreases.andM;A TSO interface to the IMS Interface is developed to issue SQL queriesdirectly from a TSO terminal.andP;  Since all processing for such queries isperformed on an IBM 4381, the CPU time can be measured.andP;  Three samplerequests for retrieving the MMIS data are obtained from plant data-processingpersonnel.andP;  These requests are formulated in SQL queries and PL/I programs,and they are executed three times locally on the IBM 4381.andP;  In contrast tothe variance of the clock time, the variance of the CPU time is very small.andO;The SQL queries are listed in Appendix B, and the average execution time isgiven in Table II.andM;The execution of Request 6 is very fast because the data is searched using anindex on einvkey attribute.andP;  The test result shows that the performance ofthe IMS Interface is reasonable, and its overhead consists of a fixedoverhead and the overhead proportional to the amount of disk I/O.andP;  Thisoverhead can be further reduced by developing an efficient IMS Interface.andM;SUMMARY AND CONCLUSIONSandM;Heterogeneous distributed database systems have advantages over centralizeddatabase systems and homogeneous distributed database systems for a largeorganization with diverse requirements.andP;  In addition, the flexibleintegration of diverse databases through the heterogeneous distributeddatabase system provides a smooth migration path in the current environmentalwhere the technology is rapidly changing.andM;The architecture of DATAPLEX consists of fourteen functionally-independentmodules.andP;  This architecture is modular and is an open architecture thatprovides facilities for easy interfaces to additional data systems.andO;Functionality and performance can be increased with this architecture.andM;A DATAPLEX prototype has been developed that interfaces an IMS hierarchicalDBMS on DEC/VMS.andP;  The capability an INGRES relational DBMS on DEC/VMS.andP;  Thecapability of the prototype system shows the feasibility of the conceptsunderlying the DATAPLEX approach to solving the problem of transparentlysharing data in a diverse database environment.andP;  The performance of theprototype system indicates that DATAPLEX can be used in a realdata-management environment.andM;Acknowledgements.andP;  I would like to thank George Dodd and John Joyce forsupporting this project.andP;  The prototype system was jointly developed withRelational Technology, Inc.andP;  I appreciate Kenneth McCloskey's participationin the implementation of the prototype system.andP;  I also wish to thank thethree anonymous reviewers for many valuable comments.andM;REFERENCESandM;[1] Breitbart, Y. J., and Hartweg, L. R. RIM as an implementation tool for adistributed heterogeneous database.andP;  In Proceedings of IPAD II Symposium onAdvances in Distributed Database Management for CAD/CAM (Denver, Co., Apr.andO;17-19).andP;  NASA, Hampton.andP;  VA., 1984, pp.andP;  155-164.andM;[2] Cardenas, A. F., and Pirahesh, M. H. Database communication in aheterogeneous database management system network.andP;  Inf.andP;  Syst.andP;  5, 1980,55-79.andM;[3] Chamberlin, D. D. et al.andP;  Views, authorization, and locking in arelational database system.andP;  In proceedings of the National ComputerConference (Anaheim, Calif., May 19-25).andP;  AFIPS, Montvale, N. J., 1975, pp.andO;425-430.andM;[4] Chung, C. W. Design and implementation of a heterogeneous distributeddatabase management system.andP;  In Proceedings of the IEEE INFOCOM '89 8thAnnual Joint Conference of the IEEE Computer and Communications Societies(Ottawa, Ont., Canada, Apr. 25-27).andP;  IEEE, New York, 1989, pp.andP;  356-362.andM;[5] Chung, C. W., and Irani, K. B.andP;  An optimization of queries in distributeddatabase systems.andP;  J. Parallel and Distrib.andP;  Comput.andP;  3, 2 (June 1986),137-157.andM;[6] Dayal, U., and Goodman, N. Query optimization for CODASYL databasesystems.andP;  In Proceedings of ACM SIGMOD International Conference on Managementof Data (Orlando, Fla., June 2-4).andP;  ACM/SIGMOD, New York, 1982, pp.andP;  138-150.andM;[7] Digital Equipment Corp. Networks and Communications Buyers Guide,Maynard, Mass., 1986.andM;[8] Elmagarmid, A. K. A survey of distributed deadlock detection algorithms.andO;ACM SIGMOD Record 15, 3 (Sept.andP;  1986), 37-45.andM;[9] Eswaran, K. P. et al.andP;  The notions of consistency and predicate locks ina database system.andP;  Commun.andP;  ACM.andP;  19, 11 (Nov.andP;  1976), 624-633.andM;[10] Gligor, V. D., and Luckenbaugh, G. L. Interconnecting heterogeneousdatabase management systems.andP;  Comput.andP;  (Jan.andP;  1984), 33-43.andM;[11] Kim, W.andP;  On optimizing an SQL-like nested query.andP;  ACM Trans.andP;  DatabaseSyst.andP;  7, 3 (Sept.andP;  1982), 443-469.andM;[12] Landers, T., and Rosenberg, R. L.andP;  An overview of multibase.andP;  InDistributed Data Bases.andP;  North-Holland, Amsterdam, 1982, pp.andP;  153-184.andM;[13] Rahimi, S. K. et al.andP;  A structural view of Honeywell's distributeddatabase testbed system: DDTS.andP;  Database Eng.andP;  5, 4 (Dec.andP;  1982), 283-287.andM;[14] Stonebraker, M. Implementation of integrity constraints and views byquery modification.andP;  In Proceedings of ACM SIGMOD International Conference onManagement of Data (Anaheim, Calif., May 19-23).andP;  ACM/SIGMOD, New York, 1975,pp.andP;  65-78.andM;[15] Su, S. Y. W. et al.andP;  The architecture and prototype implementation of anIntegrated Manufacturing Database Administration System.andP;  In Spring COMPCON,1986.andM;[16] Wang, C. Y., and Spooner, D. L. Access control in a heterogeneousdistributed database management system.andP;  tech.andP;  Rep.andP;  86-1, RensselaerPolytechnic Inst., 1986.andM;[17] Wang, C. Y. Discretionay access control in a heterogeneous distributeddatabase management system, Ph.D.andP;  Thesis, Rensselaer Polytechnic Inst.,andO;1986.andM;[18] Zaniolo, C. Design of relational views over network schemas.andP;  InProceedings of ACM SIGMOD International Conference on Management of Data(Boston, Mass., May 30-June 1).andP;  ACM/SIGMOD, 1979, pp.andP;  179-190.andM;CHIN-WAN CHUNG is currently a staff research scientist in the ComputerScience Department at General Motors Research Laboratories.andP;  His researchinterests include distributed databases, object-oriented databases, andexpert database systems.andP;  Author's Present Address: Computer ScienceDepartment, General Motors Research Laboratories, Warren, MI 48090-9057.andO;CSNET: CHUNG@GMR.COM</TEXT></DOC>