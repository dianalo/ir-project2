<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-429-866  </DOCNO><DOCID>08 429 866.andM;</DOCID><JOURNAL>Communications of the ACM  May 1990 v33 n5 p506(14)* Full Text COPYRIGHT Association for Computing Machinery 1990.andM;</JOURNAL><TITLE>Typographic style is more than cosmetic.andO;</TITLE><AUTHOR>Oman, Paul W.; Cook, Curtis R.andM;</AUTHOR><SUMMARY>There are differing viewpoints concerning the importance and roleof typographic style in program comprehension, particularly sourcecode formatting and commenting.andP;  Typographic style provides visualclues to the underlying structure of the code and supports avariety of code access strategies.andP;  The book format forimplementing typographic styles is a collection of informationorganized to provide easy understanding and a variety of accessmethods.andP;  The book format paradigm includes all of the elements ofa book, including the preface, table of contents, chapters, andtype style, which are all designed to promote rapid informationaccess and transfer.andM;</SUMMARY><DESCRIPT>Topic:     TypesettingFontsCodesInformation ProcessingAccess MethodsInformation Theory.andO;Feature:   illustrationtableprogram.andO;Caption:   Experiment 1: code writing ability. (table)Experiment 1: ability to identify procedure calls. (table)Experiment 3: C code excerpts. (program)andM;</DESCRIPT><NOTE>Only Text is presented here; see printed issues for graphics.andO;</NOTE><TEXT>Program comprehension plays an important role in many programming tasks.andP;  Forexample, about one half of a maintenance programmer's time is spent studyingthe source code and related documentation.andP;  Maintenance programmers citeunderstanding the intent and style of another programmer's code as the majordifficulty in making a change [4].andP;  Unfortunately, in many instances the onlyreliable description of a program is the source code itself.andM;The contribution of typographic style (source code formatting) to theunderstandability of the program is not clear.andP;  Ledgard and Tauer [7] believethat code &quot;should speak for itself&quot; and that code formatting is &quot;not windowdressing, but a visible display of the meaning&quot; of the program.andP;  On the otherhand, in their classic book on programming style, Kernighan and Plauger [5]state that &quot;if the code is clear and simple to begin with, formatting detailsare of secondary importance.&quot; They illustrate each of their style rules bydescribing the shortcomings of an example code segment, rewriting the examplein a better style, and drawing the general rule from the specific case.andP;  Itis interesting to note that virtually all of their rewritten versions containimplicit changes in typographic style.andM;Experimental studies of typographic factors have also been inconclusive.andP;  Forexample, most programmers believe that programs with indentation are easierto comprehend than programs without indentation.andP;  Shneiderman and McKay [15],however, found no significant differences between subjects who were asked tolocate and correct an error in the indented and unindented versions of thesame program.andP;  Also, Love [9] tested the impact of indentation and controlflow complexity on program comprehension and found no significant differencesbetween indented and unindented code.andP;  A later experiment by Miara et al.andO;[10], however, showed significant differences between indentation levels.andO;Subjects were tested with programs that contained one of four differentmethods of indentation: no indentation, two-space indentation, four-spaceindentation, and six-space indentation.andP;  They found that indentation does aidprogram comprehension and that the optimal level of indentation is betweentwo and four spaces.andM;In light of these disagreements about the importance of typographic style,Sheil [13] noted that &quot;the existence of both positive and negative resultssuggests a search for some set of principles which indicate how and whenformatting techniques will be effective.&quot; in this direction, Baecker [2] hasdeveloped a framework for &quot;program visualization&quot; based on principles ofeffective graphics design.andP;  His approach is to enhance the source codethrough the use of multiple fonts, variable character widths, proportionalcharacter spacing, and gray-scale tints; the enhanced source code is outputon high-resolution, bit-mapped displays and laser printers.andP;  He found atwenty-five-percent increase in the readability of an enhanced source text ofC programs as measured by comprehension quiz scores.andM;In this article we present a set of principles for program formatting thatare based in program comprehension theory.andP;  We then introduce the bookformat, an implementation of these principles, and show, through a series ofexperiments, that the book format significantly improves programcomprehension.andP;  The major difference between our work and Baecker's is thatour principles are based on results from program comprehension studies andhis are based on principles of graphic design.andP;  He concentrates on improvingthe appearance of the source code while we concentrate on providing the cluesand access mechanisms used by programmers to understand a program.andM;TYPOGRAPHIC STYLE PRINCIPLESandM;We define typographic style as the set of style characteristics concernedwith the formatting and commenting of source code.andP;  By definition,typographic style does not impact the execution of the program.andP;  We havefound it convenient to divide typographic style into macro and microsubclasses [12].andP;  Macro-typographic style factors include overall programformatting, global and intermodule commenting, module separation conventions,identifier-naming conventions, and conventions for special-case font or typestyles.andP;  Micro-typographic style factors include statement formatting,indentation and embedded spacing, use of blank lines, and intramodulecommenting.andM;Our typographic style principles for when and how to format and commentsource programs are based on results from programmer comprehension studies.andO;All programmer comprehension studies support the existence of:andM;(1) Mental schemata or plans that guide the programmer'sandM;comprehension of code [1, 16].andP;  ProgrammersandM;acquire and modify these plans through experience;andM;they are an integral part of long term memory.andM;(2) Chunks or meaningful units of information that programmersandM;use to organize and remember code [1].andM;(3) Beacons or highlighted semantic clues that are usedandM;to direct the review and recognition of code [3].andM;Beacons are used for searching, chunking, and hypothesisandM;checking.andM;(4) Multiple strategies and access paths used by programmersandM;when working with non-trivial programsandM;[8].andP;  Strategies are guided by a variety of plans andandM;conjectures depending upon individual differences,andM;application domains, and the implementation of theandM;code and supporting system.andM;Using these four results, we identified several principlesandM;of macro- and micro-typographic style.andP;  For example,andM;macro-typographic principles are used to:andM;(1) Make the components and organization of the programandM;obvious.andP;  This means that code areas for globalandM;definitions, the main program, support routines, andandM;included code segments should be easily identified.andM;Module separation should also be obvious.andM;(2) Identify the purpose and use of each component.andM;(3) Make the execution control and information flowandM;between components readily apparent.andP;  HighlightandM;beacons indicating intermodule control flow andandM;communication.andM;(4) Make the program readable and easy to browseandM;through by providing different access paths into theandM;code.andP;  That is, clues should be provided to enableandM;non-linear code traces (e.g., top-down, bottom-up,andM;focused, and browsing).andM;Some example micro-typographic principles are usedandM;to:andM;(1) Make the sections and organization of the moduleandM;obvious.andP;  This means dividing modules into easilyandM;recognizable parts (e.g., constants, data declarations,andM;and code body) by highlighting beacons that delimitandM;sections.andM;(2) Identify the purpose and use of each section.andM;(3) Make the underlying control and information flowandM;within the module obvious.andP;  This means control andandM;information constructs should be separated into easilyandM;recognizable chunks.andP;  Highlight beacons indicatingandM;changes in control flow.andM;(4) Make statements readable and easy to scan by providingandM;spatial clues and white space to indicateandM;statement grouping and separation.andM;We emphasize that these are general principles of good typographic style.andP;  Wedo not claim that these are complete lists; rather, we provide these examplesto demonstrate the separation of principle and implementation.andP;  Withoutconcern for implementation techniques, we have enumerated several principlesof good typographic style consistent with all models of programcomprehension.andP;  Note that all of the above principles may be implemented vianumerous typographic factors.andP;  For instance, commenting, naming, blank lines,and embedded spacing can all serve to separate modules, sections, chunks, andstatements.andM;BOOK FORMAT PARADIGMandM;Programmers use multiple strategies and access paths when working withprograms.andP;  A book is a collection of information organized in a way thatpermits easy comprehension and a variety of access methods.andP;  The componentsof a book (preface, table of contents, indices and pagination, chapters,sections, paragraphs, sentences, punctuation, type style, and character case)are all designed to facilitate rapid information access and transfer.andP;  Thereare obvious parallels between the information contained in a book and that ofprogram source code.andP;  The major difference is that the typographic style of abook provides simple and immediate clues to aid the reader in locating andrecognizing the parts of a book.andP;  Traditional methods of program formattingdo not always provide these typographic clues.andP;  Hence, the book format is amore appropriate form for representing program source code.andM;Selected pages from a book format program listing are shown in Figure 1.andP;  Theprogram is a portion of the X-Windows system, originally from MIT, rewritteninto book form.andP;  (For a more complete description, see Experiment 4 in thenext section.) Implementation techniques for most of our typographicprinciples can be seen in this example.andM;The book format paradigm of source code formatting incorporates both macro-and micro-typographic style factors.andP;  Macro-typographic factors used in thebook format paradigm include creation of a preface, table of contents,chapter divisions, pagination, and indices.andP;  The preface is a block ofcomments, which identify author, system, dates, and so forth.andP;  The table ofcontents is a high-level map to the structure of the program (or system).andP;  Itcan be generated automatically by a cross-referencing utility that recognizeschapter breakdowns.andP;  Chapters can be created for global declarations, themain program module, support routines accompanying the main program, andincluded code.andP;  Note that the chapter division accommodates many styles ofprogramming as chapters can be defined in object-oriented units by functionalbreakdown, by implementation, or by any number of considerations.andP;  Indicescan also be generated automatically.andP;  Indices for module definition andusage, global variables, and virtually all other identifiers could be createdby a simple symbol table management and cross-referencing program.andM;Micro-typographic factors used in the book format paradigm includeidentification and/or creation of code segments, code paragraphs, sentencestructures, and intramodule comments.andP;  To do this, micro-typographic factorssuch as blank lines, embedded spaces, type styles, and in-line comments areused to achieve our desired principles of good micro-typographic formatting.andO;Code sections can be separated into easily recognizable units by usingblanks, beacons, alignment, and in-line comments to show the beginning andend of the code sections.andP;  For example, the Pascal Const and Var sectionscould be delimited by placing those reserved words in boldface (or allcapitalized letters) on separate lines preceded by a blank line.andP;  This isanalogous to section headings in a book.andM;Code paragraphs can be separated into easily recognizable chunks by using thesame typographic factors.andP;  Blank lines can separate chunks; alignment andembedded spacing (which includes indentation) can provide spatial clues aboutthe content of the chunks.andP;  Statements can be written as sentences (by thiswe are suggesting a preference of horizontal statement formatting, e.g.,andO;several statements per line, over vertical statement formatting), andcharacter case and type styles can be used to highlight important constructswithin sentences (in some languages).andM;All of these implementation techniques could be automated.andP;  For example, asyntax-directed editor could:andM;(1) add in-line comments indicating the end of controlandM;structures,andM;(2) boldface or italicize procedure calls,andM;(3) align conditional structures (e.g., IFs and CASES)andM;into spatially tabular structures,andM;(4) place blank lines before and after programming constructsandM;that span more than a few lines,andM;(5) highlight well-defined code segments like data declarationandM;areas, andandM;(6) highlight globally defined identifiers.andM;Organizing program source code into book formatandM;provides programmers with:andM;(1) a familiar document paradigm,andM;(2) high-level organizational clues about the code,andM;(3) low-level organizational chunks and beacons, andandM;(4) multiple access paths via the table of contents andandM;indices.andM;EXPERIMENTSandM;This section presents four studies that demonstrate the benefits of the bookformat paradigm of source code formatting.andP;  These studies show that:andM;(1) our principles of macro-typographic style reduceandM;maintenance effort and improve programmer performance,andM;(2) our principles of micro-typographic style aid comprehensionandM;of both Pascal and C source code, andandM;(3) the book format paradigm is an easy and naturalandM;representation of source code that improves programmerandM;comprehension and performance.andM;Experiment 1: Testing Macro-Typographic Principles This experiment tested ourassertion about macro-typographic principles.andP;  We measured each student'sability to perform a maintenance task using two versions of a Pascalprogram-one a traditional listing and the other a book format listingincorporating only macro-typographic features.andM;A line-oriented text editor program, written in Pascal, was taken fromSchneider and Bruell [14].andP;  The original 1,543-line program was modified byremoving the Skip_blanks procedure and the five calls to it.andP;  The Skip_blanksprocedure skips over leading blanks when the editor command input line isbeing parsed.andP;  The resulting modified program still worked; it was justincapable of handling free-form command inputs.andP;  The program was then reducedto 1,011 lines by removing procedures unrelated to the command parsing.andP;  Thiswas done to reduce the program to a size that could be managed by studentprogrammers in one hour.andM;The modified program was then ported to Lightspeed Pascal and printed withpagination.andP;  This listing was version 1; it represents the traditional mannerin which Pascal source code is formatted.andP;  Version 2 was a macro-typographicrearrangement of version 1 as defined by our book format paradigm.andP;  That is,the code was separated into chapters and a table of contents and module indexwere added.andP;  There were no other changes made to the code.andM;Fifty-three senior and graduate level computer science students volunteeredto be subjects in the experiment.andP;  They were randomly assigned into twotreatment groups: the twenty-eight subjects in one group received version 1while twenty-five subjects in the other group received version 2.andP;  Allsubjects received the same instructions.andP;  No special instructions orexplanations were given to subjects receiving the book format listing.andP;  Thiswas deliberately done to test whether subjects could naturally use the bookformat listing (i.e., without training).andM;The TaskandM;Subjects were given one of the program versions, asked to read theinstructions, study the code, write a Skip_blanks procedure that would enablefree-form command inputs, and indicate where (on the listing) the procedurewould be called.andP;  Thus, the task was a maintenance exercise to implementfree-form command processing without having any knowledge of the originalSkip_blanks procedure.andP;  In order to do this, subjects first had to understandthe command line record structure and then understand the execution flow ofthe routines that manipulated the command line.andP;  Then, and only then, couldthey begin to recreate the Skip_blanks procedure and its calls.andM;Dependent measures for each subject were:andM;* ability to write the Skip_blanks procedureandM;* ability to identify where it was called  five locations)andM;* the time required to complete the maintenance task.andM;Subjects were given fifty-five minutes to complete the maintenance task.andM;The ResultsandM;The code-writing portion of the maintenance task was scored by tallying thesubjects' responses into four categories:andM;(1) Skip_blanks routines similar or identical to the oneandM;that was removed,andM;(2) functionally correct but dissimilar Skip_blanks routines,andM;(3) incorrect Skip_blanks routines, andandM;(4) those who could not complete the task (i.e., gave upandM;or could not get started).andM;We originally expected that at least fifty percent of each group would beable to complete the task, but results from the code-writing portion shown inTable 1 indicate that the book format listing group outperformed thetraditional listing group by approximately two correct answers to one.andP;  AChi-Square analysis of the results, assuming an equal probability across allfour cells, indicates that these differences are significant X = 10.45, p andless;0.025, d.f.andP;  = 3).andM;Group differences can also be seen by combining the two correct categoriestogether (exactly correct plus functionally correct) and combining the twoincorrect categories together (wrong plus not finished).andP;  A Chi-Square testfor independence on the resulting 2 by 2 design, using Pearson's computedexpectancy values, indicates a significant difference between the two groups X = 4.09, p andless; 0.05, d.f.andP;  = 1).andP;  The total correct is fifty-two percent forthe book format listing versus twenty-five percent for the traditionallisting.andP;  That is, twenty-seven percent more got it right when working withthe book format.andP;  Also note that subjects in the traditional listing groupwere twice as likely to quit or not even start writing code.andM;The procedure call portion of the maintenance task was scored only for thosesubjects who wrote a correct Skip_blanks procedure.andP;  Results are shown inTable 2.andP;  For the traditional listing group, the seven subjects whosuccessfully completed the routine correctly identified an average of 1.71places where the procedure would be called.andP;  In contrast, the average for thethirteen subjects in the book format group was 2.38 correct identifications.andM;No significant differences in time were observed between the two groups.andP;  Theaverage time for the traditional group was 53.5 minutes and 52.2 minutes forthe book format group.andM;DiscussionandM;Results from this experiment show the benefit of using the book formatparadigm for macro-typographic style.andP;  We emphasize that the only differencebetween version 1 (traditional listing) and version 2 (book format listing)was that the code was divided into chapters and indexed by a table ofcontents and a module index.andP;  There were no micro-typographic differencesbetween the two versions.andP;  It should also be emphasized that subjects usingthe book format listing performed better without any explanation,description, or justification of the book format listing.andM;Experiment 2: Testing Micro-Typographic Principles in PascalandM;To demonstrate that our micro-typographic style is better than traditionalmethods of Pascal code formatting, we conducted an experiment comparing ourbook format style with traditionally formatted industrial code.andM;Two procedures (ninety-four lines of code) were extracted from a commerciallyavailable pascal toolbox.andP;  The original code from the toolbox was formattedin the traditional manner of Lightspeed Pascal.andP;  This was version 1.andP;  Version2 was a typographic rearrangement of that code using our book formatprinciples of micro-typographic style to guide the formatting.andP;  Specifically,section headings were highlighted, sections and control constructs wereseparated by blank lines, statements were written as sentences when possible,procedure calls were highlighted, and related clauses were aligned and/orchunked together.andP;  Excerpts from the two versions are listed in Figure 2.andP;  Weemphasize that the difference between versions 1 and 2 is entirely themicro-typographic arrangement: indentation, embedded spacing, alignment, andthe use of character case and type style.andM;Thirty-six intermediate computer science students volunteered to be subjectsin the experiment.andP;  They were randomly assigned into two treatment groups ofeighteen subjects.andP;  Subjects in each group received one of the two codeversions (traditional or book format).andP;  Both groups received the sameinstructions.andM;The TaskandM;Subjects were given one of the two code versions and asked to complete ashort comprehension test using the code listing.andP;  The test consisted of tenmultiple choice and short answer questions.andP;  Some of the questions hadseveral parts; consequently, there were fourteen answers for the tenquestions.andP;  Subjects were asked to complete the test and then subjectivelyrate the readability of the code.andP;  Subjects were given ten minutes to answerthe questions.andM;Dependent measures for each subject were: score  0 to 14 points), timerequired to answer the questions (1 to 10 minutes), performance score (numberof correct answers per minute), and a subjective readability rating on afive-point, forced-choice scale (1-very poor, 5-very good).andM;The ResultsandM;Average scores, time, performance indexes, and ratings for both groups areshown in Table 3 and Figure 3.andP;  In support of our micro-typographicprinciples, averages for all four measures-scores, time, correct answers perminute, and ratings-improve with the book format listing.andP;  Univariateanalysis of variance showed significant differences for score (F = 10.57, p andless;0.005, d.f = 1, 34), performance (F =  8.57, p andless; 0.01, d.f  = 1, 34), andreadability rating (F  = 4.45, p andless; 0.05, d.f.andP;  = 1, 34).andP;  Although it wasobserved that time improved with the book format, the difference was notsignificant, so we cannot say with any degree of certainty what is causingthe effect.andM;Group differences can also be seen in score and performance ranges.andP;  Scoresranged from 3 to 12 in the traditional listing group and from 6 to 14 in thebook format group.andP;  Similarly, the average correct answers per minute rangedfrom 0.3 to 1.40 for the traditional group and from 0.6 to 2.33 for the bookformat group.andM;DiscussionandM;Group differences can be seen by calculating the percentage differencebetween them.andP;  An average score of 7.39 for the traditional listing grouprepresents an accuracy rate of fifty-three percent while the average score of10.39 for the book format group represents an accuracy rate of seventy-fourpercent.andP;  The increase in accuracy is twenty-one percent.andP;  Similar ratios forthe time measure, although not significantly different between groups,suggest that the book format group was more accurate and at the very least noslower than the traditional listing group.andM;Experiment 3: Testing Micro-Typographic Principles in CandM;To further test our assertions and to demonstrate language independence, werepeated the micro-typographic experiment using two different versions of Csource code.andM;A reverse-Polish desk calculator program written in C was taken fromKernighan and Ritchie's book, The C Programming Language [6].andP;  Version 1 wasthe original code taken from the textbook.andP;  It is formatted in thetraditional method of writing C source code, which is commonly used byprofessional programmers and is frequently referred to as the &quot;Kernighan andRitchie style.&quot; Version 2 was a typographic rearrangement of that code usingour book format principles of micro-typographic style to guide theformatting.andP;  Excerpts from the two versions are listed in Figure 4.andP;  Again,we emphasize that the difference between versions 1 and 2 is entirelytypographic: indentation, embedded spacing, alignment, and the use ofboldface font.andM;Forty-four advanced computer science students volunteered to be subjects inthe experiment.andP;  They were randomly assigned into the two treatment groups oftwenty-two students; subjects in each group received one of the two codeversions (traditional or book format).andP;  Both groups received the sameinstructions.andM;The TaskandM;Except for the materials, the procedures used in this experiment wereidentical to those used in the previous experiment.andP;  The comprehension testcontained nine questions, one of which had a two-part answer for a total often answers.andM;The ResultsandM;Average scores, time, performance indexes, and ratings for both groups areshown in Table 4 and Figure 5.andP;  As expected, averages for the scores, time,and number of correct answers per minute are better for the book formatlisting.andP;  Analysis of the data showed significant differences for score (F =9.40, p andless; 0.005, d.f.andP;  = 1, 42) and performance (F = 11.41, p andless; 0.005, d.f.andO;= 1, 42).andP;  Again, the trend is for time to improve with the book format, butthis difference is not significant.andM;Group differences can again be seen in score and performance ranges.andP;  Scoresranged from 4 to 9 in the traditional listing group and from 6 to 10 in thebook format group.andP;  Average correct answers per minute ranged from 0.4 to 1.0for the traditional group and from 0.6 to 1.54 in the book format group.andM;The slight difference between readability ratings of the two groups isinteresting.andP;  We speculate that this is because subjects were informed thatthe code was taken from Kernighan and Ritchie's book, which is considered themodel of good C programming style.andM;DiscussionandM;The results from the two micro-typographic experiments provide strongevidence that our principles are compatible with programmer comprehensionand, in fact, improve comprehension of small code segments.andP;  We point outthat both traditional listings were formatted in well-known and widelyaccepted styles (Lightspeed Pascal formatting and Kernighan and Ritchie'sstyle of C).andP;  We emphasize that the book format versions were obtained fromsimple micro-typographic rearrangements of the original code.andM;Experiment 4: Complete Book Format ListingandM;Thus far we have demonstrated the value of our book format paradigm formacro- and micro-typographic style in separate studies.andP;  In this experiment,we test the complete book format listing (both macro- and micro-typographicprinciples) with professional programmers working on an industrial programcontaining just over 1,000 lines of C.andM;A portion of the X-Windows package was obtained from an internationalcomputer firm.andP;  X-Windows is a window and mouse management system originallydeveloped at MIT and now bundled with minicomputer UNIX [RegisteredTrademark] systems.andP;  The C code we obtained was the X_Windows Informationprogram, which consists of the XWININFO.C main program file and two of itsinclude files, DSIMPLE.H and DSIMPLE.C.andP;  There were 1,057 lines of commentedC code in the three files.andP;  Two printed listings of the X-Windows Informationprogram were created.andP;  Version 1 was the original as received from thecompany except that it was laser printed with pagination for readability.andO;Version 2 was our typographic rearrangement of the code using the book formatparadigm for both macro- and micro-typographic style to guide thereformatting.andP;  The result was a listing that consisted of 1,098 lines ofcommented C code including the table of contents and index (see Figure 1).andO;Although the table of contents and index added 269 lines of comments to thesource file, the micro-typographic rearrangement sufficiently compressed theoriginal source code such that the result was a listing that was onlyforty-one lines longer than the original code !andP;  Twelve professionalprogrammers, each with at least two years of C programming experience,volunteered to serve as subjects.andP;  The twelve programmers were paired byexperience and job function, so each member of a pair had approximately thesame experience with UNIX, C, and X-Windows.andP;  For each of the six pairs, onemember was assigned to work with version 1 while the other worked withversion 2.andP;  The version assignment was determined by the flip of a coin.andO;Subjects were tested one at a time in a closed room with only theexperimenter present.andM;Two of the subjects were deliberately chosen because they were highlyexperienced programmers responsible for portions of the X_Windows system.andO;Both were familiar with the XWININFO.C program and had previously studied theDSIMPLE files.andP;  These two subjects represent experts already familiar withthe code to be studied and were used to establish top-line performance forthe dependent measures.andP;  None of the other subjects had prior experience withthe code to be studied, but they did have varying degrees of UNIX systemsexperience.andP;  Background characteristics for the subjects appears in Table 5.andO;The subject pairs are listed in decreasing order of UNIX and C experience.andO;The first, labeled X[.sub.t] and X[.sub.b], are the two X_Windows experts.andM;The TaskandM;Subjects were given one of the two code versions and asked to complete athree-part comprehension/maintenance exercise consisting of:andM;(1) a thirty-minute study period with think-aloudandM;protocols,andM;(2) a seven-question (10-point) oral comprehension test,andM;andandM;(3) a pen-and-paper exercise to complete a call graphandM;for the program.andM;The test took approximately two hours and was recorded on audio tape.andM;As in our other experiments, the independent variable was the typographicstyle of the code (traditional listing and book format listing).andP;  Dependentmeasures for each subject were:andM;* comprehension test score  O to 10 points)andM;* time required to answer the test questions (1 to 30 minutes)andM;* call graph score  O to 39 points, one for each node and edge)andM;* time to complete the call graph (1 to 30 minutes).andM;The think-aloud protocols were used as a data-gathering device to check forbehavior patterns between and within groups.andP;  We emphasize that all subjectsreceived exactly the same instructions; that is, subjects working with thebook format listing received no explanation or justification cation about it.andO;Each subject was given a test booklet containing written instructions (andtest questions) for each of the three parts.andM;In the think-aloud protocols subjects were given one of the program listingsand told to imagine a scenario where the person responsible for maintainingthis program had just left the company and the responsibility was transferredto the subject.andP;  It was their task to become familiar with the program withinthirty minutes because the person who had left would be coming in to answerquestions.andP;  Further, subjects were instructed to think aloud as they studiedthe program so their progress could be recorded on tape.andM;This scenario was first used by Pennington [11] as a means of establishingthe motivation to study programs in a non-goal-directed manner.andP;  That is, theprogrammers studying the code are not addressing a specific maintenance task;rather, they are trying to get a feel for the program in a short amount oftime.andM;&quot;Thinking out loud&quot; for thirty minutes, the subjects then studied the codelisting.andP;  The experimenter's role was to remain unobtrusive so as not toguide or interfere with the subject's study.andP;  The experimenter's interactionwas limited to answering questions about the test procedure, asking forclarification on incomplete or garbled verbalizations, and prompting thesubjects about noticeable behavior changes not accompanied by verbalizations.andM;Protocol Results The twelve subjects showed a variety of study patterns.andP;  Allsubjects were in agreement on some points.andM;(1) They all initially reported that the code seemedandM;well-structured and consistent.andP;  Later they pointedandM;out areas where the overall organization and theandM;(detailed) code could be improved.andM;(2) They all had a browsing phase where they quicklyandM;scanned through the entire listing.andP;  This phase, however,andM;did not always come at the beginning of theandM;study period.andP;  There were no recognizable group-specificandM;browsing patterns.andM;(3) They had distinct browsing behavior intermixedandM;with detailed code studying throughout the studyandM;period.andM;(4) They all directed and pruned their analysis of theandM;code on the basis of module name and/or location.andM;All subjects skipped certain modules on the basis ofandM;name (e.g., &quot;Get_Error, I can ignore that&quot;) or locationandM;(e.g., &quot;Oh, this is the DSIMPLE include file, IandM;don't need to look at these&quot;).andM;(5) They all studied the main program and its supportandM;routines prior to studying the include files.andM;(6) They all scattered or separated the code listing intoandM;various piles, stacks, and groups.andP;  The most commonandM;ordering was distinct piles for the main programandM;body, the support routines, and the include code.andM;Differences between the version 1 group (traditional listing) and the version2 group (book format listing) were that subjects receiving the book formatlisting reported the following items.andM;(1) They noticed and commented on the &quot;documentation&quot;andM;provided by the table of contents andandM;module index.andP;  All traditional listing subjects expressedandM;a desire to have a cross-reference map, yetandM;the book format listing subjects commented that itandM;was a  luxury&quot; to have one included in the code.andM;(2) They made extensive use of the table of contentsandM;and module index while browsing and studyingandM;detail.andM;(3) They maintained separate piles of code pages withandM;the index in one pile and the table of contents face-upandM;off to the side.andM;(4) They noticed and commented on the use of italicsandM;and boldface to highlight module names (e.g., &quot;Gee,andM;that's a great idea.andP;  I wish I could do that&quot;).andM;Interestingly, four of the six programmers receivingandM;the traditionalandM;listing went through and highlighted moduleandM;names by underlining and/or circling them.andM;(5) They noticed and commented on the use of horizontalandM;statement spacing rather than vertical  e.g.,andM;&quot;See here, it's not all strung out the way KerriganandM;[sic] and Ritchie do it&quot;).andM;(6) They commented that the code was better-writtenandM;than their own.andP;  None of the traditional listing subjectsandM;made this claim.andM;Oral Comprehension TestandM;For this part of the experiment subjects were given a written instructionpage that contained seven questions.andP;  Three of the questions had two-partanswers, so there was a total of ten points on the test.andP;  The questionsranged from high-level general questions to low-level specific questions.andM;The questions were read out loud with the subjects verbally answering eachquestion before going on to the next.andP;  Subjects were allowed to keep thewritten instruction sheet and could refer to it as often as desired.andP;  Theexperimenter's role was limited to reading the questions and prompting formore detail (if necessary) to achieve either a clearly right answer or aclearly wrong answer.andP;  When a definite right or wrong answer was obtained theexperimenter responded with &quot;O.K.&quot; and moved to the next question.andP;  Nofeedback was given on the correctness of answers.andP;  The oral comprehensiontest was timed from the reading of the first question to the answering of thelast.andP;  Hence, the independent variable for the task was the listing version,and the dependent variables were score  0 to 10 points) and time (1 to 30minutes).andM;Comprehension Test ResultsandM;The comprehension test results are presented in Figure 6.andP;  Inferentialstatistics comparing the two groups would be of questionable value because ofthe relatively small sample size; so we have deliberately omitted any suchanalyses.andP;  It is easy to see, however, that, for every pair, the programmerworking with the book format listing scored higher and at a faster rate thanthe programmer working with the traditional listing.andP;  There were nonoticeable patterns in the ability to answer specific questions.andM;Note that there is little difference between the two experts and that theyrepresent the top-line performance (for their groups).andP;  Also note that allother subjects working with the book format listing performed nearly as wellas the two experts, but none of the subjects working with the traditionallisting did.andP;  The separation between the groups reflects the improvedcomprehension afforded by the book format listing.andM;Call Graph ExerciseandM;For the third task, subjects were given a written instruction page and anincomplete call graph and were asked to complete the call graph.andP;  Prior tothe task the experimenter read the instructions out loud and traced throughthe code for the main routine, pointing out the relationship between the codeand the incomplete call graph.andP;  All subjects reported that they understoodthe exercise and the call graph before beginning the task.andM;The incomplete call graph consisted of twelve nodes and eleven edges; itrepresented the top-level calls from main to support routines.andP;  The completedcall graph had twenty-three nodes and thirty-nine edges, so the task was tofind and add the missing eleven nodes and twenty-eight edges.andM;The experimenter's role was limited to reading the instructions, tracingthrough the incomplete call graph, and indicating when a node was a dead-endbecause its code was not included in the listing.andP;  (The program makes anumber of calls to various X-Windows libraries.) The call graph exercise wastimed beginning with when the subjects started looking at the code to whenthey indicated that they were finished.andP;  Score for the exercise was the totalnumber of new nodes and edges they successfully added to the call graph.andO;Hence, the independent variable was the listing version, and the dependentvariables were score (0 to 39) and time (1 to 30 minutes).andM;Before starting the exercise, five of the six subjects working with theversion 2 listing indicated that they could use the index to complete thecall graph without looking at the code.andP;  They were told it was an exercise incode reading and they were to build the call graph from the code, not theindex.andP;  They were permitted to use the index and table of contents only tofind modules when tracing the execution of the code they were reading.andM;Call Graph ResultsandM;The call graph exercise results are presented in Figure 7.andP;  Again,inferential statistics have been omitted.andP;  In general, the programmersworking with the book format listing scored higher, and did so faster, thantheir counterpart working with the traditional listing.andP;  (The one exceptionis E[.sub.t], who methodically traced every procedure call he found and usedthe entire thirty minutes to do so.) On the average, subjects working withthe book format listing scored higher and took less time than those workingwith the traditional listing.andP;  And, as in the comprehension test, thesubjects working with the book format listing performed as well or betterthan the two experts.andM;DiscussionandM;As a group, the programmers working with the book format listing outperformedthose working with the traditional listing.andP;  Further, all subjects in thebook format group performed as well as or better than the two expertprogrammers already familiar with the code.andP;  This is in sharp contrast to thesubjects working with the traditional listing who performed noticeably worsethan the two experts.andP;  In every matched pair the subject working with thebook format listing scored better or worked faster than their counterpartworking with the standard listings.andM;CONCLUSIONSandM;This article identifies principles of typographic style and demonstratesthrough empirical studies that typographic characteristics significantlyimpact program comprehension.andP;  Typographic style can provide visual clues tothe underlying structure of the code and can support a variety of code accessstrategies.andM;The book format, an implementation of these typographic style principles, wasintroduced.andP;  Our four experiments with the book format for source codeformatting show that:andM;(1) our macro-typographic implementation aids inandM;maintenance tasks on programs of about 1,000 linesandM;of code,andM;(2) our micro-typographic implementation aids in theandM;comprehension of Pascal and C code segments, andandM;(3) professional programmers can benefit from the bookandM;format model.andM;Furthermore, the book format model seems very natural and convenient to usebecause it takes advantage of the subjects' familiarity with structure andorganization of a book.andP;  Also note that subjects given the book formatlistings were not given any introduction or instructions on how to use it.andM;Our research has direct application to code formatters such as prettyprintersand syntax-directed editors.andP;  These code formatters are designed to improvethe readability of source code by formatting it in a consistent manner.andO;Present-day, code-formatting tools, however, follow different sets of sourcecode layout rules, which are selected by the developer.andP;  These rules reflectthe subjective judgment of the developer and are rarely (if ever) supportedby empirical evidence showing that they aid program comprehension.andP;  Ourresearch provides the principles and a foundation for formatting rules thataid program comprehension.andM;Our research also has application in programming language design andprogramming teaching practices.andP;  In language design, programming languageconstructs should be compatible with the way programmers view code.andP;  (Forinstance, syntactic constructs can be beacons or unnecessary distractions.)andO;In programming instruction, the teaching of specific style rules may becounterproductive.andP;  While there may be no single best way to format a sourceprogram, teaching beginning programmers language independent typographicstyle principles (rather than specific layout rules) will make them aware ofthe purpose of particular style rules.andP;  This will provide them with a solidbasis for the source program layout guidelines they choose.andM;REFERENCESandM;1.andP;  Adelson, B. Problem solving and the development of abstract categories inprogramming languages.andP;  Mem.andP;  Cognition 9, 4 (1981), 422433.andM;2.andP;  Baecker, R. Enhancing program readability and comprehensibility withtools for program visualization.andP;  In Proceedings of the Tenth InternationalConference on Software Engineering  Raffles City, Singapore, Apr. 11-15).andO;ACM/SIGSOFT and IEEE/CS, New York, 1988, pp.andP;  356-366.andM;3.andP;  Brooks, R. E. Towards a theory of the comprehension of computer programs.andO;Int.andP;  1.andP;  of Man-Machine Stud.andP;  18, 6 (june 1983), 543-554.andM;4.andP;  Fjeldstad, R. K., and Hamlen, W. T. Applications program maintenancestudy: Report to our respondents.andP;  In Tutorial on Software Maintenance, G.andO;Parikh and N. Zvegintzov, Eds.andP;  IEEE/CS Press, Silver Spring, Md., 1983, pp.andO;13-27.andM;5.andP;  Kernighan, B. W., and Plauger, P. J. The Elements of programming Style.andO;McGraw-Hill, New York, 1974.andM;6.andP;  Kernighan, B. W., and Ritchie, D. M. The C Programming Language.andO;Prentice-Hall, Englewood Cliffs, N. J., 1978.andM;7.andP;  Ledgard, H., and Tauer, J. Professional Software, Vol.andP;  II ProgrammingPractice.andP;  Addison-Wesley, Reading, Mass., 1987.andM;8.andP;  Littman, D., Pinto, I., Letovsky, S., and Soloway, E. Mental models andsoftware maintenance.andP;  In Empirical Studies of programmers.andP;  E. Soloway andS. Iyengar, Eds.andP;  Ablex Publishing, Norwood N. J., 1986, pp.andP;  80-98.andM;9.andP;  Love, T. An experimental investigation of the effect of program structureon program understanding.andP;  ACM SIGPLAN Notice 12, 3 (Mar.andP;  1977), 105-113.andM;10.andP;  Miara, R. J., Musselman, J. A., Navarro, J. A., and Shneiderman, B.andO;Program indentation and comprehensibility.andP;  Commun.andP;  ACM 26, 11 (Nov.andP;  1983),861-867.andM;11.andP;  Pennington, N. Stimulus structures and mental representations in expertcomprehension of computer programs.andP;  Cognitive Psychol.andP;  19, 2  (Feb.andP;  1987),295-341.andM;12.andP;  Oman, P., and Cook, C. R. A taxonomy for programming style.andP;  InProceedings of the Eighteenth Annual Computer Science Conference (WashingtonD.C., Feb. 22-23.) ACM, Now York, 1990, pp.andP;  244-250.andM;13.andP;  Sheil, B. A. The psychological study of programming.andP;  Comput.andP;  Surv.andO;13, 1 (Mar.andP;  1981), 101-120.andM;14.andP;  Schneider, G., and Buell, S. Advanced Programming and Problem SolvingWith Pascal.andP;  John Wiley andamp; Sons, New York, 1981.andM;15.andP;  Shneiderman, B., and McKay, D. Experimental investigations of computerprogram debugging and modification.andP;  In Software Psychology.andP;  WinthropPublishers, Cambridge, Mass., 1980, pp.andP;  72-74.andM;16.andP;  Soloway, E., and Ehrlich, K. Empirical studies of programming knowledge.andO;IEEE Trans.andP;  Softw.andP;  Eng.andP;  SE-10, 5 (Sept.andP;  1984), 595-609.andM;CR Categories and Subject Descriptors: D.2.2 [Software Engineering]: Toolsand Techniques; D.2.3.andP;  [Software Engineering]: CodingandM;Key Words and Phrases: Code formatting, coding style, programming style.andO;</TEXT></DOC>