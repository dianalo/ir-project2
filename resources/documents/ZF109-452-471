<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF109-452-471  </DOCNO><DOCID>09 452 471.andM;</DOCID><JOURNAL>Communications of the ACM  Sept 1990 v33 n9 p104(21)* Full Text COPYRIGHT Association for Computing Machinery 1990.andM;</JOURNAL><TITLE>Surveying current research in object-oriented design.andO;</TITLE><AUTHOR>Wirfs-Brock, Rebecca J.; Johnson, Ralph E.andM;</AUTHOR><SUMMARY>Academic and industrial object-oriented programming research inthe US and Europe is examined emphasizing obscure projects andignoring such well-known ideas as those of Coad and Meyer.andO;Object-oriented design research can focus on describing a designprocess, finding rules for good designs or building tools tosupport design, but most of the research described here involvesall three topics.andP;  Among the work described is that being done byAlan Snyder at Hewlett-Packard on developing a common frameworkfor object-oriented terminology; Dennis de Champeaux's work at HPon developing a model for object-based analysis; RebeccaWirfs-Brock's work at Tektronix; and Trygve Reenskaug's work atthe Senter for Industriforskning in Oslo, Norway, on prescribingthe design process; and Ralph Johnson's work at the University ofIllinois on object-oriented frameworks and large-design reuse.andM;</SUMMARY><DESCRIPT>Topic:     Object-Oriented ProgrammingResearch and DevelopmentSoftware DesignNew TechniqueIndustry-Sponsored ResearchColleges and Universities.andO;Feature:   illustrationchart.andO;Caption:   Phases of design: exploration and analysis. (chart)An index card with collaborations. (chart)The client-server contract. (chart)andM;</DESCRIPT><NOTE>Only Text is presented here; see printed issues for graphics.andO;</NOTE><TEXT>SURVEYING CURRENT RESEARCH IN OBJECT-ORIENTED DESIGN The state ofobject-oriented design is evolving rapidly.andP;  This survey describes what arecurrently thought to be the key ideas.andP;  Although it is necessarilyincomplete, it contains both academic and industrial efforts and describeswork in both the United States and Europe.andP;  It ignores well-known ideas, likethat of Coad [6] and Meyer [34], in favor of less widely known projects.andM;Research in object-oriented design can be divided many ways.andP;  Some researchis focused on describing a design process.andP;  Some is focused on finding rulesfor good designs.andP;  A third approach is to build tools to support design.andO;Most of the research described in this article does all three.andM;We first present work from Alan Snyder at Hewlett-Packard on developing acommon framework for object-oriented terminology.andP;  The goal of this effort isto develop and communicate a corporate-wide common language for specifyingand communicating about objects.andM;We next look into another research activity at Hewlett-Packard, led by Dennisde Champeaux.andP;  De Champeaux is developing a model for object-based analysis.andO;His current research focuses on the use of a trigger-based model forinter-object communications and development of a top-down approach toanalysis using ensembles.andM;We then survey two research activities that prescribe the design process.andO;Rebecca Wirfs-Brock from Tektronix has been developing an object-orienteddesign method that focuses on object responsibilities and collaborations.andO;The method includes graphical tools for improving encapsulation andunderstanding patterns of object communication.andP;  Trygye Reenskaug at theSenter for Industriforskning in Oslo.andP;  Norway has been developing anobject-oriented design method that focuses on roles, synthesis, andstructuring.andP;  The method, called Object-Oriented Role Analysis, Syntheses andStructuring, is based on first modeling small subproblems, and then combiningsmall models into larger ones in a controlled manner using both inheritance(synthesis) and run-time binding (structuring).andM;We then present investigations by Ralph Johnson at the University of Illinoisat Urbana-Champaign into object-oriented frameworks and the reuse oflarge-scale designs.andP;  A framework is a high-level design or applicationarchitecture and consists of a suite of classes that are specificallydesigned to be refined and used as a group.andP;  Past work has focused ondescribing frameworks and how they are developed.andP;  Current work includes thedesign of tools to make it easier to design frameworks.andM;Finally, we present some results from the research group in object-orientedsoftware engineering at Northeastern University, led by Karl Lieberherr.andO;They have been working on object-oriented Computer Assisted SoftwareEngineering (CASE) technology, called the Demeter system, which generateslanguage-specific class definitions from language-independent classdictionaries.andP;  The Demeter system includes tools for checking design rulesand for implementing a design.andM;Common TerminologyandM;Hewlett-Packard is involved in many activities that involve object-orientedtechnology.andP;  In addition to object-oriented programming [4, 15, 52], theseactivities include object-oriented databases [13], user interfaces [18],application architectures [19], application integration platforms [39],distributed systems [2], and network management architectures [20].andP;  Eacharea has an associated external technical community, and many have associatedstandards activities.andP;  These areas differ in both the forms in whichobject-oriented concepts appear and the terms used to refer to the concepts.andO;This diversity has caused serious communication problems and has hampered theconvergence of these technologies to provide comprehensive and consistentobject-based solutions.andM;To address this issue, representatives from the various technologies werebrought together to exchange information and develop a shared understanding.andO;The first step in developing the glossary of common terminology was toidentify and define a set of core concepts that could be used to characterizeand contrast the various object-oriented technologies familiar to the taskforce members.andP;  These concepts were defined in a general way to apply to thewide variety of technologies under consideration.andP;  Each core concept that wasidentified had a term selected for it.andP;  The result was the abstraction of theessential common core concepts of object-oriented technology, and a commonterminology.andP;  This common terminology has been endorsed by the management ofthe computer business within Hewlett-Packard and is being promoted withincorporate training programs.andM;The essential concepts are summarized as follows:andM;* An object embodies an abstraction.andP;  It provides services to its clients.andO;This principle emphasizes that an object is not just a collection of data.andO;It explicitly embodies an abstraction that is meaningful to its clients,which may be programs or users.andP;  The services are computations that areappropriate to the abstraction.andM;* Clients request services from objects.andP;  Clients respect the abstractionsembodied in an object.andP;  Objects are encapsulated: clients are prevented frommaking direct access to the data associated with an object.andP;  Instead, clientsissue requests for services that are performed by objects.andP;  Performing arequest involves executing some code, a method, on the associated data.andP;  Arequest identifies the requested service (the operation), as well as theobjects that are to perform the service.andP;  These object can be identifiedunambiguously and reliably (this is called object reference).andP;  Requests mayinclude other parameters, and may return results.andP;  The set of services thatan object provides may be described in the form of an interface description.andM;* Requests can be generic.andP;  A client can issue the same request to differentkinds of objects that provide similar services.andP;  Specifically, performing arequest may involve the execution of different code depending upon theobjects identified in the request.andM;* Objects can be classified in terms of the services they provide.andP;  Thisclassification may be based on explicit interface descriptions.andP;  An objectcould provide a subset of the services provided by another object, leading tohierarchical classification and an interface hierarchy.andM;* Objects can share implementations.andP;  Mechanisms are generally provided thatallow multiple objects, called instances, to share the same implementation(often called a class).andP;  Also, mechanisms are often provided by which theimplementation of one object cannot just share the implementation of anotherobject, but can also extend or refine it (implementation inheritance ordelegation) [48].andM;There are several commonly used terms that have been frequent sources ofconfusion and miscommunication within Hewlett-Packard.andP;  The term that causesthe most confusion is encapsulation.andP;  Encapsulation has three possiblemeanings: the enforcement of abstraction barriers; the act of integratingforeign components into a system; and the mechanism for controlling access toservices by different users.andP;  (The recommended terms identified by the taskforce for these three concepts are encapsulation, embedding, and protection.)andO;Another confusing term is inheritance.andP;  Inheritance has two primary meanings:a mechanism by which object implementations can be organized to sharedescriptions; and a classification of objects based on common behavior orcommon external interfaces.andP;  (The recommended terms for these concepts areimplementation inheritance and interface hierarchy.)andP;  Other confusing termsare type and class, whose multiple meanings refer to either the externalinterfaces of objects or the implementations of objects.andM;Snyder has found that the distinctions between multiple meanings can besubtle, even to people who are familiar with basic concepts.andP;  The results ofthe common object terminology effort are available in two technical reports[49, 51].andP;  In addition to providing a definition for each concept, thereports identify synonyms, give examples, state the importanc of the concept,and present the rationale for the choosing the recommended term.andM;Rather than develop a comprehensive terminology, the most important conceptsand those with multiple meanings or ambiguous terms were identified anddefined.andP;  The terms were selected to be broadly applicable to multipledomains, and were not restricted to programming terminology.andP;  This ledresearchers at Hewlett-Packard to adopt, in some cases, terminology that isdifferent from the more commonly used object-oriented programmingterminology.andP;  Adoption of the terminology has been the result of personalinitiative and leadership by members of the original task force.andP;  Forexample, the terminology has been adopted in the architectural documents forHewlett-Packard's NewWave Computing Architecture, the company's strategicinitiative for its computer business.andM;We present the entry from the HP technical report for the term genericrequest to illustrate the complete descriptions that were developed.andM;Generic RequestandM;Definition:andM;A request is a statement that specifies a service to be carried out byobjects.andP;  A request has a name, identifies the objects that are to providethe service (the providers), and may take arguments and produce results.andP;  Ageneric request is a request that may be issued to different objects thatprovide (similar) services with different implementations and possiblydifferent behaviors.andP;  The request itself does not determine how the serviceswill be performed.andP;  When a request is issued, a selection process determinesthe actual code to be executed to perform the service.andP;  More than one objectcan participate in providing a service in response to a request.andM;Example:andM;A print request can be made to any printable object (e.g., a document orspreadsheet).andP;  The request may also specify a device object where thedocument will be printed.andM;Importance:andM;Generic requests are a major factor in the reusability of object-orientedprograms.andP;  Code written in terms of generic requests can be used fordifferent purposes when the requests are sent to objects that interpret themdifferently.andP;  In object-oriented user interfaces, generic requests allowmultiple applications to share a common interaction style, improving ease ofuse.andM;Synonyms and Related Terms:andM;In the Iris database, issuing a generic request is called functioninvocation.andP;  In C+++ it is called virtual members function invocation.andP;  Ingeneral, a request may designate multiple objects to provide the service.andP;  Amessage is a generic request for a service issued to a single object; issuingsuch a request is called message sending.andP;  The ability to support genericrequests is also called polymorphism and function overloading.andM;Rationale:andM;The use of the word generic highlights the feature that a single request maydenote a range of related services.andP;  We de-emphasize the traditional termmessage for two reasons: One is the common misconception that message sendingimplies concurrent execution by the sender and the receiver.andP;  The other isthe implication that a message is sent to a single location at which it ishandled.andP;  Although in traditional object-oriented systems, services areprovided by individual objects, systems like the Iris database and the CommonLisp Object System (CLOS) have begun to explore more general models in whichthe implementation of a single service is provided jointly by multipleobjects.andP;  While the integration of this concept with the traditionalobject-oriented model is not yet clear, it is clear that the more generalmodel is needed to handle certain real problems.andP;  A classic example is theproblem of printing a document on a printer, the implementation of which maydiffer based on both the kind of document and the kind of printer.andM;Common terminology within a single organization is only an intermediatesolution.andP;  The ultimate goal is consensus within the technical community atlarge.andP;  As a step in this direction, Hewlett-Packard is participating in theObject Management Group (OMG), an industry consortium chartered to promotethe widespread adoption of object technology.andP;  The OMG is actively working toinfluence the future directions of object-oriented technology, specificallythrough the adoption of a platform-independent object-oriented applicationsenvironment.andP;  The work described above has been incorporated and extended bythe OMG technical committee in creating a &quot;standards manual&quot; to guide theformulation of and responses to requests for technology.andM;An &quot;abstract object model&quot; [50] has been defined which provides an organizedand more detailed presentation of concepts and terminology.andP;  This abstractobject model also partially defines a model of computation.andP;  The partialnature of this description is in keeping with the OMG's policy of adoptingexisting technologies rather than designing new ones.andP;  Any existingtechnology submitted to the OMG will likely define its own concrete objectmodel based upon this abstract object model.andP;  The abstract object modelprovides a framework for such concrete object models.andP;  A concrete objectmodel would elaborate upon the abstract object model by making it morespecific, for example, by defining the form of a request, and would populatethe abstract object model by introducing specific instances of object modelentities, such as specific operations.andM;To illustrate the evolution of terminology, here is the definition forrequest from the abstract object model:andM;Clients request services by issuing requests.andP;  A request is an event (i.e.,andO;something that occurs at a particular time during the execution of thecomputational system).andP;  The information associated with a request consists ofan operation and zero or more (actual) parameters.andP;  Operations are(potentially) generic, meaning that a single operation can be requested ofobjects with different implementations, resulting in observably differentbehavior.andP;  Operations are created by explicit action; each such actioncreates an operation that is distinct from operations created previously orin the future.andP;  a value is anything that is a possible (actual) parameter ina request.andP;  A value may identify an object, for the purpose of performing therequest.andP;  A value that identifies an object is called an object name.andP;  Ahandle is an object name that unambiguously identifies a particular object.andO;Within certain pragmatic limits of space and time, a handle will reliablyidentify the same object each time the handle is used in a request.andP;  Arequest causes a service to be performed on behalf of the client.andP;  Oneoutcome of performing a service may be that some results are returned to theclient.andP;  The results associated with a request may include values as well asstatus information indicating that exceptional conditions were raised inattempting to perform the requested service.andM;There is a subtle change in this new description from the original.andP;  In theearlier definition the request was called generic.andP;  In the newer terminology,it is the operation that is called generic.andP;  This change resulted from makingthe definition of request more formal.andP;  Several possible meanings wereconsidered: the form issued by the user (for example, an invocation form in aprogram text), the information provided (the operation and the actualarguments), or the computational event itself.andM;The last option was chosen both for its utility, since the results areassociated with the event, and ease of formalization, since the syntacticform cannot easily be formalized in an abstract form.andP;  The originaldefinition of generic request assumed the first meaning.andP;  With the newmeaning, it no longer made sense: the same request (event) cannot be issuedto different objects.andP;  Therefore, the concept of generic was associated withoperation.andM;Efforts are continuing within Hewlett-Packard and elsewhere to further refinethese concepts and the abstract object model and to work toward consensuswithin the technical community.andM;Object-Oriented AnalysisandM;Another research activity at Hewlett-Packard addresses the object-orientedparadigm for analysis.andP;  The goal of this research is to develop an analysismethod that can be integrated with object-oriented design.andP;  A primaryobjective of this research is to develop a method that does not assumesequential computation.andP;  [9].andM;The analysis method should allow for what de Champeaux terms unlimitedformalization.andP;  The method should not impose formalization on the analyst.andO;However, if validation of the implementation is required, it should beverifiable against the results of analysis.andM;The object-oriented paradigm classically has its roots in sequentialprogramming languages.andP;  Object interaction in such a context is toosimplistic: the sender passes an operation name and arguments to thereceiver.andP;  Control is initially passed to the receiver.andP;  The receiver nextexecutes the desired operation and sends the result back to the sender.andO;Finally, control is returned to the sender.andP;  This model of control andinformation flow is not rich enough to describe all the causal connectionsbetween objects an analyst needs to model.andM;Shlaer and Mellor have developed an object-oriented process model that relieson data flow diagrams from Structured Analysis to describe the actions intheir state models [47].andP;  In their model, interaction between objects isdescribed indirectly via the occurrence of an external data store in a dataflow diagram.andM;De Champeaux is exploring whether triggers provide a more direct mechanismfor modeling causal interactions between objects.andP;  A trigger does not carrydata, the initiator is not suspended, and it does not expect a return value.andO;The only effect of a trigger is to initiate a state change by the recipient.andM;Another subtlety that must be modeled is how to deal with a trigger thatcannot be handled by the recipient, perhaps because an additional conditionfor a triggered transition is not satisfied.andP;  Should the trigger be lost,buffered, or signal an error condition?andP;  Each of these responses isappropriate under certain circumstances.andP;  This suggests tha a richerinterobject interaction model than a trigger is necessary.andM;This has led to consideration of additional object interaction forms, suchas:andM;trigger-and-wait-for-acknowledgment (where the intiator waits foracknowledgment of receipt of the trigger),andM;send-no-wait (where data and the trigger are simultaneously transmitted),andM;send-and-wait-to-acknowledge-of-reception (where the initiator triggers atransition, while transmitting a value that will be consumed by an action onthe transition; the sender blocks until it receives acknolwedgement that thetrigger and value have arrived), orandM;send-and-wait-for-reply (similar to the above example except for the senderis blocked until a value is returned).andM;Determining an appropriate set of additional forms to describe interobjectinteractions is a current research topic.andM;EnsemblesandM;An analyst using traditional structured analysis techniques obtains atop-down view of a system.andP;  Process decomposition is a well-known technique.andO;Similar mechanisms are needed for objects.andM;For example, in analyzing a banking application, an interest rate, a branchoffice, a teller machine, a corporate account, a loan officer, or a monthlystatement are all candidate objects to model during analysis.andP;  However, theyobviously represent different layers in the problem domain.andM;De Champeaux is investigating an appropriate abstraction layering anddecomposition technique for selecting objects during analysis thatfacilitates such a layered analysis.andP;  Currently he is exploring ensembles asa technique for creating and analyzing objects in an ordered fashion.andM;Ensembles represent a cluster or bundle of less abstract entities which areeither objects or lower-level objects.andP;  Ensembles, like objects, can bemodeled by attributes and optionally a state-transition machine, can interactwith other objects or ensembles, and have an interface model.andP;  A majordistinction between ensembles and objects is that an ensemble has internalparallelism, while an object is a finite state machine.andM;The main purpose of an ensemble is to hide details of a set of objects orsubensembles that are irrelevant outside the ensemble.andP;  Like classes ofobjects, classes of ensembles can be modeled.andP;  An important part of anensemble's information model is a description of its constituent objects andsubensembles.andP;  Additional ensemble attributes may model features that applyto an ensemble's constituents as a whole.andP;  For example, consider a fleet ofships represented as an ensemble.andP;  The individual ships share the directionin which they are going.andP;  Thus, we can model direction as an attribute of afleet.andP;  Summary information may also be modeled such as the number of shipsin the fleet.andM;When an ensemble has nonconstituent attributes, it is often appropriate todevelop a state-transition model for it.andP;  Inter-ensemble or objectinteractions can then be described.andP;  A major difference between an object andan ensemble is that ensembles have a forwarding mechanism for triggers andmessages that mediates between external entities and ensemble constituents.andO;From outside an ensemble, it may appear as if messages to an ensembledirectly cause ensemble constituents to change state.andP;  For example, thereturn-to-port transition causes the direction of all ships in the fleet tochange.andP;  When we look inside the fleet ensemble, we see a differenttriggering and messaging pattern that actually achieves these consequences.andO;Introducing ensembles thus allows low-level mechanisms to be hidden fromhigher-order functionality.andM;Research in ResponsibilityandM;Driven DesignandM;Over a period of six years, Tektronix developed one of the largest and mostexperienced groups of Smalltalk programmers and produced several majorcommercial and internal applications [12, 35, 57].andP;  Much experience wasgained in the process.andP;  In the last few years a number of individuals havefocused on developing and teaching a method for designing object-orientedapplications [59].andP;  Past experience in Smalltalk development led to a strongsense of what constitutes good design.andP;  The result is a design process thathas been applied to a number of small and medium-sized engineering endeavorsat Tektronix and elsewhere [60].andM;In developing a method for object-oriented design the following goals wereset:andM;1.andP;  Develop a model that encourages exploration of alternatives early in thedesign process, and that provides a structure for analyzing and improvinginitial design decisions.andM;2.andP;  Develop simple tools that help a design team to reason about a design.andO;It should be easy to record and modify design decisions.andM;3.andP;  Develop language-independent methods and guidelines.andM;Responsibility DrivenandM;DesignandM;Responsibility-driven design models an application as a collection of objectsthat collaborate to discharge their responsibilities.andP;  Responsibilities are away to apportion work among objects that comprise the application.andP;  Thisapproach stresses focusing on what actions must be accomplished and whichobjects will accomplish them.andP;  How each action is accomplished is deferreduntil after a model of objects and the interactions is created andunderstood.andM;Responsibilities include two key items:andM;* the knowledge an object maintains, andandM;* the actions an object can perform.andM;Responsibilities are meant to convey a sense of the purpose of an object andits place in an application.andP;  Responsibilities represent the publiclyavailable services defined by objects.andP;  Note that responsibilities have beendefined for objects, not classes, though the responsibility of a class can bedefined as the responsibilities of its instances.andM;Focusing on the responsibilities of objects maximizes information hiding andencapsulation.andP;  Information-hiding distinguishes the ability to perform someact from the specific steps taken to do so.andP;  An object reveals its abilitiespublicly, but it does not tell how it knows or does them.andP;  An object may needto know and do other things in order to fulfill its public responsibilities,but those things are considered private to the object.andM;The responsibilities of an object are all the services it provides for allobjects that communicate with it.andP;  Objects fulfill their responsibilities inone of two ways: by performing the necessary computation themselves, or bycollaborating with other objects.andM;ExplorationandM;The process of design can be partitioned into two distinct phases, as shownin Figure 1.andP;  To start, object-oriented design is exploratory.andP;  The designerlooks for classes of objects, trying out a variety of schemes in order todiscover the most natural and reasonable way to abstract the system.andP;  Duringthe initial exploratory phase of design the primary concern is to build amodel of the key classes that will fulfill the overall design objectives.andP;  Inthis phase the major tasks are toandM;* discover the classes required to model the application,andM;* determine what behavior the system is responsible for, and assign theseresponsibilities to specific classes, andandM;* determine what collaborations must occur between classes of objects tofulfill those responsibilities.andM;Modeling is the process by which the logical objects in a problem space aremapped to the actual objects in a program.andP;  These steps produce a set ofcandidate classes for an application, a description of the knowledge andoperations for which each class is responsible, and a description ofcollaborations between classes (i.e., between instances of those classes).andM;Recording The Initial DesignandM;Beck and Cunningham [3] have found that index cards are a simple tool forteaching object-oriented concepts to designers.andP;  The responsibility-drivendesign method uses index cards to capture initial classes, responsibilitiesand collaborations.andP;  They also record subclass-superclass relationships andcommon responsibilities defined by superclasses.andM;Index cards work well because they are compact, easy to manipulate, and easyto modify or discard.andP;  Index cards can be easily arranged on a tabletop and areasonable number of them viewed at the same time.andP;  They can be picked up,reorganized, and laid out in a new arrangement to amplify a fresh insight.andM;Each candidate class is written on an index card, as shown in Figure 2.andP;  Eachidentified responsibility is succinctly written on the left side of the card.andO;If collaborations are required to fulfill a responsibility, the name of eachclass that provides necessary services is recorded to the right of theresponsibility.andP;  Services defined by a class of objects include those listedon its index card, plus the responsibilities inherited from its superclasses.andM;Improving the Initial DesignandM;Once an initial model has been constructed, it is crucial to turn a critic'seye on the design.andM;Without such attention, it is difficult to obtain the reusability andrefinability benefits touted by object-oriented technology.andP;  It isparticularly important to construct properly structured hierarchies, toidentify abstract classes, and to simplify interobject communications.andO;During this second, highly analytical phase of design the primary activitiesare toandM;* factor the responsibilities into hierarchies to get maximum reusabilityfrom class designs,andM;* model the collaborations between objects in more detail to betterencapsulate subsystems of objects, andandM;* determine the protocols and complete a specification of classes, subsystemsof classes, and client-server contracts.andM;Paying careful attention to structuring abstract and concrete classes, first,before improving object collaborations, reduces rework required during laterstages.andM;Factoring HierarchiesandM;A design is most extensible when a class inherits from another class only ifit supports all of the responsibilities defined by that other class.andO;Inheritance should model &quot;is-kind-of&quot; relationships: every class should be aspecific kind of its superclasses [17, 26].andP;  Subclasses that support all ofthe responsibilities defined by their superclasses are more reusable becauseit is easier to see where a new class should be placed within an existinghierarchy.andP;  A corollary of this principle is that if a set of classes allsupport a common responsibility, they should inherit it from a commonsuperclass.andM;An important distinction to be made when designing a class is the primarypurpose of abstract and concrete classes.andP;  Abstract classes are designed tobe inherited.andP;  They exist solely to specify behavior that is reused byinheritance.andP;  Instances of abstract classes are never created as the systemexecutes.andP;  Concrete classes are designed to be instantiated.andP;  Although it isoften useful to inherit from a concrete class, concrete classes are usuallynot designed to be reusable by inheritance, but as components.andM;One way to factor responsibilities higher in a class hierarchy is to designas many abstract classes as possible.andP;  In general, the more concretesubclasses of an abstract class, the more likely the abstraction is to standthe tests of time and software enhancements.andP;  Only one responsibility isneeded to define an abstract superclass, but at least two specific subclassesof it are required before one can hope to design a generally usefulabstraction.andP;  Defining many abstract superclasses as possible means that muchcommon behavior has been factored into reusable abstractions.andM;Tools for UnderstandingandM;Object InteractionsandM;Analyzing an exploratory design requires global understanding.andP;  Bothgraphical and conceptual tools are used to gain that understanding.andM;ContractsandM;A contract is a set of related responsibilities defined by a class.andP;  Itdescribes the ways in which a given client can interact with a server.andP;  Acontract is a list of requests that a client can make of a server.andP;  Both mustfulfill the contract: the client by making only those requests that thecontract specifies, and the server by responding appropriately to thoserequests.andP;  The relationship is shown in Figure 3.andM;Responsibilities found in the exploratory phase are the basis for determiningthe contracts supported by a class.andP;  Not all responsibilities will be part ofa contract.andP;  Some responsibilities represent behavior a class must have tosupport the fulfillment of contracts but which are not directly exposed toother objects.andP;  These are private responsibilities.andM;A class can support one or more distinct contracts.andP;  The word &quot;contract&quot; isnot just another name for a responsibility.andP;  A responsibility is somethingone object does for other objects, either performing some action orresponding with some information.andP;  A contract defines a cohesive set ofresponsibilities that a client can depend on.andP;  The cohesion betweenresponsibilities is a measure of how closely those responsibilities relate toone another.andM;For example, all classes of numbers support a contract to perform arithmeticoperations.andP;  That contract includes responsibilities to perform addition,subtraction, multiplication and division.andP;  For example, let us say a newclass defines the responsibility for its instances to know how to addthemselves to other instances of the class.andP;  These new objects cannot be usedas servers in places where some type of number is expected.andP;  The new classdefines the addition responsibility, but it does not support the entire setof responsibilities defined by the arithmetic contract.andM;Often a class supports only a single contract.andP;  However, when a class hasmultiple roles or when its services can be factored into sets that are usedby distinct clients, it will support multiple contracts.andM;Subsystems of ClassesandM;An application is composed of more than just classes.andP;  A complex systemrequires many levels of abstraction, one nested within the other.andP;  Classesare a way of partitioning and structuring an application for reuse.andP;  But adesign often has groups of classes that collaborate to fulfill a largerpurpose.andM;A subsystem is a set of such classes (and possibly other subsystems)collaborating to fulfill a common set of responsibilities.andP;  Althoughsubsystems are not directly supported by existing object-oriented languages,they are an important way of thinking about large object-oriented systems.andO;One way to test if a group of classes form a subsystem is to try to name thegroup.andP;  If the group can be named, the larger role they cooperate to fulfillhas been named.andP;  A subsystem is not just a bunch of classes, it should form agood abstraction.andM;Collaborations GraphsandM;A collaborations graph helps analyze paths of communications and identifypotential subsystems.andP;  It graphically displays the collaborations betweenclasses and subsystems.andP;  The graph can be used to identify areas ofunnecessary complexity, duplication, or places where encapsulation isviolated.andP;  Collaborations graphs represent classes, contracts, andcollaborations.andP;  In addition, collaborations graphs show superclass-subclassrelationships.andM;A subclass in a responsibility-driven design should support all the contractsdefined by its superclass.andP;  Therefore, in a collaborations graph, asuperclass represents the contracts supported by all of its subclasses.andP;  Thisidea is represented by graphically nesting subclasses within the bounds oftheir superclasses.andM;One example of a subsystem, shown in Figure 4, is the printing subsystemencapsulating the classes Print Server, Printer, and its subclasses DotMatrix Printer and Laser Printer.andP;  Together, these classes can be viewed ascollaborating to print files.andP;  Although the Print Server collaborates withQueue, Queue is not part of the Printing Subsystem, because instances of theclass Queue are used by classes outside the Printing Subsystem.andP;  A class ispart of a subsystem only if it exists solely to fulfill the goals of thatsubsystem.andM;Subsystems simplify a design.andP;  A large application is made less complex byidentifying subsystems within it and treating those subsystems as classes.andO;An application can be decomposed into subsystems, and those subsystems can inturn be modeled until all required richness and detail have been specified.andO;Ultimately, software is composed of classes, but to ignore the possibility ofsubsystems is to ignore one of the most fruitful aspects of the structure ofan application.andM;Subsystems are only conceptual entities; they do not exist during execution.andO;They therefore cannot directly fulfill any of their contracts.andP;  Instead,subsystems delegate each contract to a class within them that actuallysupports the contract.andM;Because clients use the functionality of a subsystem through a clearlydefined set of contracts, subsystem functionality can be extended withoutdisrupting the rest of the application.andP;  A new contract can be defined, or anexisting contract can be extended to provide access to the additionalfunctionality.andP;  For example, we could extend the Printing Subsystem by addingthe ability to print at a specified time or to print a specified number ofcopies.andP;  Existing contracts would adequately deal with the new functionality;the Printing Subsystem would still print the contents of a file (the oldcontract), but would do so in different ways (the new functionality).andM;Guidelines for SimplifyingandM;InteractionsandM;Subsystems are identified in order to simplify the patterns of collaboration.andO;Without such simplification, the communication paths could flow from nearlyany class to any other, with only the slenderest of justifications and nocoherent structuring.andP;  Such anarchic flow leads to spaghetti code--the sameproblem that structured programming was designed to avoid.andP;  The problem isevident when one looks at a collaborations graph for such an application.andO;The graph itself looks like spaghetti; it cannot be understood, and theapplication it represents is consequently impossible to maintain or modifysensibly.andM;Simplifying the patterns of collaboration translates into a simplification ofthe collaborations graph.andP;  Places where the graph is complex are areas thatlikely need to have collaborations simplified.andP;  Often collaborations graphsare drawn repeatedly to test simplification alternatives.andM;Basic guidelines are used to simplify patterns of collaboration for thefollowing purposes:andM;* Minimize the number of collaborations a class has with other classes orsubsystems.andM;* Minimize the number of classes and subsystems to which a subsystemdelegates.andP;  Another way of stating this principle is that the classes withina subsystem should be encapsulated whenever possible.andM;* Minimize the number of different contracts supported by a class or asubsystem.andM;Implementing AbstractandM;ClassesandM;Abstract classes are an important part of an object-oriented design becausethey not only define behavior that is shared by many classes, they provide areusable design for their subclasses.andP;  An implementation of an abstract classwill use three kinds of methods to describe the contract between subclass andsuperclass, and between superclass and subclass.andP;  These are termed basemethods, abstract methods and template methods.andM;Base methods provide behavior that is generally useful to subclasses.andP;  Thepurpose of base methods is to implement in one place behavior that can beinherited by subclasses.andM;Abstract methods provide default behavior that subclasses are expected tooverride.andP;  The behavior does not do anything particularly useful, andsubclasses are expected to reimplement the entire method.andP;  The purpose ofabstract methods is to fully specify the subclasses responsibilities.andP;  Thus,the designer of a subclass uses the abstract methods as a specification.andM;For example, the abstract class Displayable Object might define the methoddisplay as an abstract method.andP;  The method might, perhaps, display a blackbox the size of the object's bounding box.andP;  In order for any element todisplay itself accurately, all subclasses of Displayable Object mustreimplement the method display to provide accurate, reasonable displaybehavior for the particular kind of Displayable Object.andM;Template methods provide step-by-step algorithms.andP;  Each step can invoke anabstract method, which the subclass must define, or a base method.andP;  Thepurpose of a template method is to provide an abstract definition of analgorithm.andP;  The subclass must implement specific behavior to provide theservices required by the algorithm.andM;For example, the abstract class Filled Element, a subclass of DisplayableObject, might define the method display as a template method with thisalgorithm:andM;drawBorder drawInteriorandM;This alters responsibilities of its subclasses from the abstract operationspecified in Displayable Object.andP;  Each subclass of Filled Element mustimplement the methods drawBorder and drawInterior in such a manner that theyprovide reasonable behavior.andM;An abstract class and its methods therefore serve as a minimal specificationof each of its subclasses.andP;  An important part of specifying an abstract classis specifying the behavior for each method that is inherited by itssubclasses.andP;  Specification of methods for an abstract class should statewhether the method is an abstract method that must be overridden, or a baseor template method that should be directly inherited.andM;Defining Class StructureandM;The implementation of a class hierarchy should push details about a class'sstructure as low as possible in the hierarchy.andP;  Subclasses can overrideinherited behavior, but not structure, so it is better to delay designdecisions about structure as long as possible.andM;A responsibility is a statement of intent.andP;  It is general; it says nothing ofhow a responsibility is supported--details of structure on algorithms.andP;  If asuperclass supports its responsibilities in the most generic way possible,there will not be any implementation details to impede a creation of a newsubclass that wishes to inherit its responsibilities.andP;  Each subclass is freeto implement the responsibilities in a way most appropriate for it.andM;Abstract classes define default implementations for some methods in order tomake it easier to create subclasses.andP;  If they must depend on implementationdetails, those details should be accessed by sending a message to the objectitself [58].andP;  Messages sent to the object can easily be overridden bysubclasses, allowing subclasses to provide a mapping from the abstractimplementation assumed by the superclass to the concrete implementation theysupport.andM;For example, consider an abstract class Point with two concrete subclasses,Cartesian Point and Polar Point.andP;  The addition of two points can beabstractly defined in terms of adding the x and y coordinates.andP;  If the x andy coordinates are accessed through a message send, each subclass can thensupply its own implementation of these messages based on its internalrepresentation.andM;Object-OrientedandM;Software EngineeringandM;For the past 10 years, the group at Senter for Industriforskning (SI) hasbeen developing highly interactive, flexible and personalized workenvironments for executives and other professionals in public service,commerce and industry.andP;  The power of object orientation has been critical totheir success.andP;  All their efforts in software engineering have been aimed atproviding improved leverage for their development efforts.andM;When the group started development work in 1983, there was a conflict betweenfunctional specifications (which clearly indicated that Smalltalk-80 was thepreferred development environment), and the requirements for reliability andmaintainability (which clearly indicated a well-proven software engineeringenvironment based on a traditional programming language).andP;  The group at SIopted for the Smalltalk-80 environment because of its object orientation,development environment and rich class library.andP;  Over the years they havedeveloped a personal work environment based on Smalltalk to augment theinitial system.andM;This personal work environment consists of a Smalltalk image containing akernel module and a number of optional function modules that can beconfigured to suit an individual user's requirements.andP;  There are also anumber of background services such as a persistent object store, that aremainly written in C.andP;  There are approximately 100,000 lines of Smalltalk-80source code.andM;The group at SI believes that the key to program quality is simplicity:simple models, simple designs, simple code.andP;  They also believe that if aproblem is really understood, a simple solution can be found.andP;  Their strategyhas been to develop methods and tools that first permit the modeling of smallsubproblems until they are fully understood, then to combine the small modelsinto larger ones in a controlled manner.andM;They term their method OORASS, Object-Oriented Role Analysis, Synthesis andStructuring, because of its three critical operations [41].andP;  These operationsare based on the encapsulation, inheritance and dynamic binding properties ofobject orientation.andP;  Analysis describes subproblems by encapsulating behaviorin the objects of an object model, which is termed a Role Model.andP;  Synthesisdefines composite objects by inheriting behavior from several simplerobjects.andP;  Structure Specification prescribes how objects can be boundtogether in an actual instance of a system.andM;The goal of the OORASS research is to help people create an organizedstructure of collaborating objects and to represent such a structure in acomputer.andP;  They believe that three distinct abstractions of objects areneeded if the full benefits of object orientation are to be attained: thehow, the what, and the why of objects.andP;  The how is the class of the object,describing its internal implementation.andP;  The what is the type of the object,describing its external behavior.andP;  The why is a new concept call Role, whichrepresents the task of the object within the organized structure of objects.andM;The method developed at SI consists of five main parts.andP;  Each part representsa systems development phase as well as part of the total description of theapplication under development.andP;  Objects are at the center of attention at alltime; each part provides some information about the application objects ortheir structures.andM;The Role Model part separates the problem domain into more or lessoverlapping areas of concern.andP;  Each such area is modeled as a structure ofinteracting objects.andP;  Each object is abstracted into a Role according to itspurpose in the Role Model structure.andM;The Object Specification part integrates the individual Role Models byletting a single composite object play different Roles in different models.andM;The Class Implementation part provides programs for all required objects.andM;The Structure Specification provides a kind of grammar or Meta Model thatdescribes the possible collaborations between objects, (i.e.andP;  how they can beconfigured).andP;  This process is like multi-dimensional dominoes, where anypiece may be attached to any other piece if they both have free andcompatible interfaces where they can be joined.andM;Finally, the Object Instantiation part creates objects and interconnects themaccording to the prescriptions given in the Meta Model, and as instances ofclasses programmed in the Class Implementation part.andM;Role ModelingandM;Modeling consists of two subparts: analysis for modeling subproblems, andsynthesis for joining small models into larger ones.andP;  The task inobject-oriented design is to describe patterns of interactions and to assignresponsibility to individual objects in such a way that the total system ofobjects is as simple as possible.andP;  An object that is to play a certain Rolein an object structure must understand certain messages (e.g., have certainbehavior).andM;Analysis: Simple RoleandM;ModelingandM;There is a many-to-many correspondence between Role and Behavior.andP;  Forexample, consider a document modeled as a structure of objects.andP;  Suppose thatthe documents tree has a document object as its root, and a number ofsub-objects as shown in Figure 5.andM;This example has nine different Roles, but several objects may be givenidentical behavior.andP;  There are only three kinds of object behaviors: ageneral TreeObject that can play the Roles of document, title page, section,and figure; a TextObject that can play the Roles of title, author, paragraph,and caption, and a PictureObject that can play the Role of picture.andP;  Thus,considerable code reuse has been achieved by separating the concepts of Roleand Behavior.andP;  Furthermore, programs can be written to implement a greatvariety of document structures: many different Role Models may be constructedfrom a toolkit containing a limited selection of three different objectbehaviors.andM;Each Role in a Role Model is given a name.andP;  Its responsibilities aredescribed to determine which other Roles it needs to know about and whatmessages it sends to these collaborators.andP;  While during execution the originof a certain message is irrelevant to an object, the right to send a certainmessage is a very important part of the privileges that are assigned toobjects in design.andM;The diagrams used for Role Models are very simple.andP;  Computer-based toolssupport drawing Role Model diagrams, and more detailed information is alwaysimmediately available to the designer through a direct manipulation toolinterface.andM;For example, the document Role Model describes what is meant by a document inobject-oriented terms.andP;  Objects that serve the same purpose in the model, forexample section objects, have been abstracted into Roles.andP;  Attributes to thesymbols in the diagram give further information, such as a description of theresponsibility of the objects for each Role, and details about messages thatobjects may send to collaborators.andM;Synthesis: Composite RoleandM;ModelingandM;Typical designs are usually too large to be comprehended as a whole.andP;  Bysubdividing into subareas of concern, and creating Role Models for eachsubarea, a problem can be decomposed.andP;  This reduces modeling to manageableproportions, but creates a new problem of integrating smaller models into amodel of the entire system.andM;This problem can be simply solved in the few cases where the problem can beconsidered hierarchical.andP;  What appears as one object on the higher level isthen represented by its own Role Model on a lower level.andM;However, problems are usually more complex.andP;  If one model is not justdetailing the internals of a single object in another model, a Role Synthesisconstruction mechanism is needed to integrate models.andP;  For example, given anumber of Role Models A,B,...andP;  with Roles A1, A2, A3,..., B1, B2, B3,..., aComposite Role AnBm.. can be created such that the newly created Role objectmay simultaneously play Role n from Model A, Role m from Model B, and so on.andM;Thus a many-to-many correspondence between Role and Object exists, because anobject may play several different Roles, and a given Role may be played bydifferent objects.andP;  For example, a person object may play the Role of amaterials provider in a manufacturing Role Model, and the Role of a buyer ina materials purchasing Role model.andP;  The person object then acts as anintegrator between the two Role models, using knowledge about the market inits materials provider Role, and knowledge about manufacturing in its buyerRole.andP;  Another example is illustrated in Figure 6.andM;Role Synthesis makes it possible to reuse Role Models.andP;  Consider the documentexample.andP;  The document Role could inherit properties of the parent Role inthe Tree Model, the titlePage, section and figure Roles could inherit bothparent and child, and the leaf nodes title, author, paragraph, picture andcaption could inherit the child Role.andM;The advantages of Role Synthesis are threefold.andP;  First, a tree structure doesnot need to be reinvented every time one is needed.andP;  Second, if treestructures need additional properties then it can be added in only one place,namely the Role Model of a primitive tree.andP;  Third, classes for the parent andchild Roles could be implemented; the document objects and all other used oftree structures could then be programmed as subclasses of these.andP;  Thisprovides a mechanism for describing a class library on the abstraction levelof modeling and design.andM;Object SpecificationandM;Role Modeling studies objects and their interactions.andP;  To create an ObjectSpecification, the focus changes from the overall structure of objects to asingle object and its immediate collaborators.andP;  Again, synthesis may be usedto create specifications for objects that may play multiple Roles.andM;For example, consider the paragraph Role in a document.andP;  There could be twovery different kinds of objects that could fill this Role.andP;  A PlainText couldcontain text local to the current document.andP;  A DatabaseText could representthe latest version of some text record existing in a database.andP;  Every timethe document was printed or inspected, the latest version of this recordwould be inserted.andP;  And, if a user were allowed to edit such a text, thedatabase should immediately be updated.andM;A DatabaseText object would need to play some Role such as database record ina Role Model describing a database system.andP;  It would, of course, also have toplay the Role of paragraph in the document Role Model.andP;  These two Role Modelscould be combined into one, but this would create unnecessary complexity.andM;Instead, a better solution is to specify DatabaseText as an object that canboth play the Role of paragraph in the document Role Model and databaserecord in a database Role Model.andP;  This specification defines the object bydescribing all the Roles it must be able to play and all its interaction withits collaborators.andP;  This is illustrated in Figure 7, where the object beingspecified is shown in the center of the diagram with its collaborators aroundit.andM;Interdependencies between Role Models must also be considered.andP;  In theDataBaseText example, messages in the document domain having to do withgetting and putting text will presumably have to perform some databaseoperations.andP;  Conversely, if the database content is changed, some actionshould be taken in the document domain to reflect the new values.andP;  Suchinterdependencies are recorded in relevant message descriptions.andM;Class ImplementationandM;The word class, in OORASS, is used in a very restricted sense: a class is aprogram that implements a certain object specification.andP;  The class is theonly place where the internal structure of an object is seen.andP;  Just as aclass can implement objects that play several roles, many different classescan implement objects that play a particular role (i.e., there is amany-to-one relationship between classes and roles).andP;  The object beingspecified in an Object Specification is often synthesized as a composite ofseveral Roles.andP;  This inheritance structure gives important hints as to apossible class hierarchy in a program.andP;  Specifically, reusable Role Modelsshould be implemented as reusable class libraries.andM;Structure SpecificationandM;The Object Specification part defines the external properties of an object insufficient detail to decide whether objects should be connected.andP;  Any objectthat satisfies the assumptions an object makes about a collaborator may beconnected to that object and play the Role of its collaborator.andM;Given a reasonably rich and generic set of Object Specifications with atleast one class implemented for each, clearly a variety of correct objectstructures can be built.andP;  Only some will be meaningful in the user domain.andO;For example, in our document, the programs will tolerate title pages thatcome between two sections in the middle of the document.andP;  However, this isnot typically what the user expects.andM;Therefore, the Meta Model describes the subset of workable objectcombinations that have meaningful structures in the user domain.andP;  Thisdescription is used during Object Instantiation to control the generation ofan actual object structure [36].andP;  The Meta Model can contain otherinformation, such as number restrictions, parameters to initialize theattributes of an instance to adapt it to play a certain Role, accessrestrictions, default display and formatting information, in addition to purestructural information.andM;System InstantiationandM;The System Instantiation part creates an actual object structure by matchingclasses defined in the Object Implementation with the prescriptions of theMeta Model.andP;  This is typically a dynamic process where new objects are beingcreated and unused ones are garbage collected throughout the lifetime of theapplication.andM;An object may collaborate with any other object that has the desired behaviorregardless of implementation.andP;  For maximum flexibility, the binding of classto collaborator is postponed until the moment that new objects are actuallycreated.andP;  The program needing the new object knows the name of its ClassSpecification, a run-time mechanism matches this name to its preferredimplementation and creates an instance of the corresponding class.andP;  This issimilar to the LaLonde's use of exemplars [26].andM;Further WorkandM;The OORASS method has been evolving over several years.andP;  Successful programshave been developed exploiting the class Implementation, StructureSpecification and Object Instantiation tools.andP;  A number of different systemshave been generated from an identical program base by defining different MetaModels.andP;  New capabilities have been added by just programming the new classesand including them in a Meta Model.andM;Currently, a group consisting of people from SI, Taskon A/S and theUniversity of Oslo is developing a method for systems analysis and modeldescription, employing message scenarios and formal protocol definitions asan extension to the Role Models.andP;  They also are integrating their CASE toolsto provide a seamless model of all information.andP;  This will also include anextension of their literate programming facility, so that formal and informalinformation can be intermixed [42].andP;  They hope that their method will providea high-level model description of reusable classes that could become thetechnical foundation for a marketplace of reusable class libraries.andM;Frameworks--ReusableandM;DesignsandM;One of the main advantages of object-oriented programming is that it supportssoftware reuse.andP;  It is easy to see how object-oriented programming makesprogram components more reusable, but in the long run the reuse of design isprobably more important than the reuse of code.andP;  Although abstract classesprovide a way to express the design of a class, classes are too fine-grained.andO;A framework is a collection of abstract and concrete classes and theinterfaces between them, and is the design for a subsystem.andP;  Abstract classesare fairly well understood, but much less has been written about frameworks,and there is much less of a consensus on them.andM;The first widely used framework was Model/View/Controller, the Smalltalk-80user interface framework [25].andP;  It showed that object-oriented programmingwas ideally suited for implementing graphical user interfaces.andP;  MacApp is alater user interface framework designed specifically for implementingMacintosh applications [46].andP;  It is actually a framework for all aspects ofMacintosh applications, such as printing and storing documents on the disk.andO;Recently there have been a number of user interface frameworks fromuniversities, such as the Andrew Toolkit from Carnegie Mellon University[38], InterViews by Mark Linton at Stanford [32, 54] and ET++ from theUniversity of Zurich [55, 56].andP;  Each of these frameworks improves the stateof the art in user interface framework design in some way, building on thesuccesses and lessons of earlier systems.andM;Frameworks are not limited to user interfaces, but can be applied to any areaof software design.andP;  They are one of the main reasons that object-orientedprogramming has such as a good reputation for promoting reuse.andP;  However,frameworks are different from simple class libraries, and require more workto design.andM;FrameworksandM;The idea and terminology of frameworks were developed at Xerox PARC by theSmalltalk group.andP;  Peter Deutsch describes frameworks in [11] (and lessthoroughly in [10]).andP;  He emphasizes that the most important aspect of aframework that is reused is the interface or specification of the components.andO;Although frameworks reuse implementation as well, reuse of interface designand functional factoring is more important because they constitute the keyintellectual content of software and are far more difficult to create orre-create than code.andP;  This is the key insight behind frameworks.andM;Just as an abstract class is the design of a concrete class, a framework isthe design of a subsystem.andP;  It consists of a number of abstract and concreteclasses.andP;  (Deutsch uses the term &quot;single class frameworks&quot; and &quot;multiclassframeworks&quot;, but we instead say &quot;abstract class&quot; and &quot;framework&quot;).andP;  Part ofthe definition of each abstract class is its responsibilities.andP;  In addition,a framework consists of the collaborations between the objects in itsabstract classes.andM;Like a subsystem, a framework is a mixture of abstract and concrete classes.andO;It differs from a subsystem by being designed to be refined.andP;  It can berefined by changing the configuration of its components or by creating newkinds of components (i.e., new subclasses of existing classes).andP;  A matureframework will have a large class library of concrete subclasses of eachabstract class, so that most of the time an application can be &quot;pluggedtogether&quot; from existing components.andP;  Even when new subclasses are needed,they are easy to produce because the abstract superclasses provide theirdesign and much of their code.andM;For example, the user interface subsystem of a Smalltalk-80 application isalmost always produced with the Model/View/Controller user interfaceframework.andP;  It will be built by connecting views and controllers together andparameterizing them with menus, messages to send on particular events, etc.andO;Even when an application requires one or two new user interface classes, mostof the classes in the user interface will come from the standard classlibrary.andM;Brad Cox has likened reuse in an object-oriented system to integratedcircuits and has advocated the use &quot;software ICs,&quot; which are black-boxcomponents that can be used in a variety of contexts [7].andP;  However, designinga framework is more like designing a family of chips or a logic family.andP;  Theindividual components are less important than the standard interfaces theyshare, and designing the interfaces is harder than designing individualcomponents.andM;Most frameworks will be domain dependent.andP;  Although most of the publicizedframeworks focus on user interfaces, frameworks can be used for much morethan just user interfaces.andP;  User interface frameworks are popular in partbecause they are relatively domain-independent, are useful to mostprogrammers, and correspond to a traditional computer science area ofspecialization.andP;  However, most subsystems will be application-dependent, sothe frameworks that generate them will be too.andP;  Good examples are frameworksfor VLSI routing algorithms [16], or for controlling real-timepsychophysiology experiments [14].andP;  Thus, most frameworks will be of interestonly to application programmers working in a particular area.andM;There are several projects at the University of Illinois at Urbana-Champaignto design frameworks.andP;  The TS optimizing compiler for Smalltalk has aframework for code generation and optimization [23].andP;  Code optimizations arenever completely machine-independent; a framework for code optimizationallows the compiler designer to easily build a customized optimization phase.andO;The FOIBLE framework for visual programming environments provides acustomizable graphics editor to which a visual language designer can add aninterpreter, resulting in a visual programming language [21].andM;Choices is an object-oriented operating system written in C++ at theUniversity of Illinois under the direction of Roy Campbell.andP;  It is more thanjust an operating system; it is an operating system framework.andP;  It consistsof interlocking frameworks for file systems [33], virtual memory [44],communication [61], and process scheduling [43].andP;  The file system frameworkshown in Figure 8, which was developed primarily by Peter Madany, has beenused to implement a number of different file systems, including BSD andSystem V, MSDOS, a log-based file system an object store, and archive files.andM;The Inner File SystemandM;FrameworkandM;One of the central classes of the file system framework in Choices isMemoryObject.andP;  A MemoryObject is a sequence of identically sized blocks.andP;  Itis responsible for reading and writing its contents one or more blocks at atime.andP;  It also is responsible for maintaining the number of blocks that itcontains.andP;  Thus, the key operations provided by MemoryObjects are read,write, and size.andP;  Many parts of a file system are MemoryObjects, such asfiles and disks.andP;  MemoryObjects are the part of the file system frameworkthat is most used by the rest of the operating system.andP;  In particular, thevirtual memory system also uses MemoryObjects, so they act as an interfacebetween the file system and the virtual memory system.andP;  Files are stored ondisks, but both files and disks are MemoryObjects.andM;ObjectContainers keep track of partitioning a large MemoryObject into a setof smaller MemoryObjects, (i.e., a disk into a set of files).andP;  For example,the Unix i-node table is an ObjectContainer.andP;  ObjectContainers can create newMemoryObjects, delete old ones, and can return the i-th MemoryObject that itstores.andP;  Thus, its operations are create, delete, and open.andM;A BlockAllocator manages the free blocks of a MemoryObject that ispartitioned by an ObjectContainer.andP;  Of course, some MemoryObjects have fixedpartitions and so have no free blocks, but most file systems allow files tobe created and deleted dynamically.andP;  Files use allocators to acquire, andrelease blocks of the MemoryObject on which they are stored.andP;  The onlyoperations defined by BlockAllocator are allocate and free.andM;MemoryObject, ObjectContainers, and BlockAllocators provide the foundation ofany file system.andP;  Some of the components of a file system will be reusedunchanged from the class library.andP;  For example, a disk can be partitioned byan ObjectContainer into a fixed number of fixed-sized file systems.andP;  Othersare subclasses of standard abstract classes.andP;  For example, a Unix System Vfile system will consist of a subclass of ObjectContainer (SysVContainer) toimplement the System V i-node table, a subclass of MemoryObject (SysVInode)to implement System V i-nodes, and a subclass of BlockAllocator to implementthe System V free list.andM;Since a System V file system has a subclass for every abstract component ofthe framework, it might seem that the framework is not helping very much.andO;However, not only is it very helpful for the designer to start with ahigh-level design that describes the components and their interfaces, butsome of the concrete classes inherit a lot of code from their abstractsuperclasses.andP;  In particular, SVIDContainer inherits operations fromObjectContainer to manage a table of open MemoryObjects and from itssuperclass UnixContainer to read and write disk inodes, while SVIDInodeinherits most of its operations from UnixInode.andM;Outer File SystemandM;FrameworkandM;MemoryObject, ObjectContainer, and BlockAllocator are only the core of thefile system framework.andP;  There is another layer that represents an applicationprogram's view of the file system.andP;  An ObjectDictionary (e.g., directory)converts a logical file name into the index of the file in anObjectContainer.andP;  Its operations are open, create, and delete.andP;  A Directorydiffers from an ObjectContainer because a MemoryObject can be in only oneObjectContainer, but can be in many directories.andP;  Directories are usuallyassociated with a single ObjectContainer, and are usually stored on the sameMemoryObject that the ObjectContainer partitions.andM;There are currently two separate but compatible user views of files.andO;FileStream provides a Unix-like interface to a file, with a current positionand a seek operation, in addition to a read and a write.andP;  There is also aPersistentObject class that supports the transparent storage and retrieval ofobjects from the disk.andP;  Like FileStreams, PersistentObjects are based onMemoryObjects.andP;  They differ from FileStreams in that they can refer directlyto other PersistentObjects.andM;Other parts of the file system include MountTable, SymbolicLink,FileSystemInterface (which keeps track of a current directory), and anauthentication system.andM;This layering of frameworks is common, and is similar to other ways thatsoftware designs are layered.andP;  Some of the classes in the file systemframework are used in other parts of Choices.andP;  MemoryObject is used by thevirtual memory system, while FileSystemInterface and the user views of filessuch as FileStream and PersistentObject are used by application programs.andO;BlockAllocators and ObjectContainers are usually private.andP;  The user of a filesystem does not need to know about the private classes, but the designer of anew type of file system does.andM;The Choices file system has gone through many versions, and each version ismore general and reusable than the previous ones.andP;  The core classes have beenstable for some time, while the outer classes are newer and still changing.andO;This is typical of reusable designs.andP;  Reusing the early versions points outdesign weaknesses that must then be corrected.andP;  A framework's designer can beconfident of its reusability only after it has been successfully reusedseveral times.andM;In the fall of 1987, before the file system framework had been designed, adozen students in an operating system course built a System V compatible filesystem for Choices.andP;  In the fall of 1989 two teams: a one-person team, and atwo-person team, each built a log-based file system for Choices using theframework.andP;  The System V file system specification was simpler and muchbetter documented than the log-based file system, but the students using theframework were more successful than the earlier students who did not use it.andO;This experience not only increased confidence in the reusability of the filesystem framework, it illustrates why frameworks are so important.andM;Research on FrameworksandM;Designing a framework is itself research.andP;  The designer must understand thepossible design decisions and must organize them in a set of classes relatedby the client/server, whole/part, and subclass/superclass relationships.andO;Thus, the designer is developing a theory of the problem domain andexpressing it with an object-oriented design.andM;There are three main research areas related to frameworks.andP;  The first isdesigning frameworks: what are the characteristics of a good framework andhow is one designed?andP;  The second is using frameworks: how does one configurea particular application based on a framework.andP;  The third is describingframeworks: what notation is needed, other than that applicable toobject-oriented design in general?andM;Designing FrameworksandM;Most people realize they need a framework when they notice similarities inexisting applications.andP;  These do not have to be object-oriented systems;designers with extensive experience in an application domain often can tellwhich frameworks would be useful for their applications.andP;  Subsystems also mayevolve into frameworks as they are reused.andP;  Designing a good framework ismore than just extracting the abstract classes from a subsystem.andP;  A subsystemonly has to work for one application, but a framework must work for manyapplications.andP;  Thus, a framework is a generalization of the subsystems thatcan be built from it.andM;Good frameworks are usually the result of many design iterations and a lot ofhard work.andP;  Designing a framework is like developing a theory.andP;  The theory istested by trying to reuse the framework.andP;  Unsuccessful experiments require achange in the theory.andP;  Lack of generality in a framework shows up when it isused to build applications, so its weaknesses cannot be found until after itis designed and reused.andP;  Thus, iteration seems necessary.andM;Since iteration is necessary, it should be performed as early in the designlife cycle as possible.andP;  Many iterations can be done on paper before any codeis entered in the computer.andP;  However, the proof of the adequacy of a designis whether it can be implemented well.andM;Changes made to a framework during its design tend to fall into certainpatters [22].andP;  Responsibilities are moved from one class to another.andO;Responsibilities (or even classes) are broken into smaller components, sothat one part can be changed independently of another part.andP;  Sometimesseparately designed classes are given a common superclass, which is usuallyfollowed by migrating functionality up into the new superclass and precededby renaming operations on the different classes so that they will share moreof their interface.andP;  These changes are an important part of the process ofdesigning frameworks.andM;The Software Refactory project (William Opdyke and Ralph Johnson) at theUniversity of Illinois is developing tools to manage changes that occurduring design iteration [37].andP;  Refactorings are the changes to frameworksthat do not add functionality, but instead redistribute and reorganize it.andO;Refactorings are time-consuming and error-prone when done by hand, but theSoftware Refactory project is designing tools to automate them.andP;  Thus, aprogrammer will just perform the &quot;break class into components&quot; operation andboth the class and its clients will be modified.andP;  This would make iterationmuch easier and would let the designer think about changes to a design at ahigh level.andP;  Moreover, changes to a framework can be propagated to theapplications that use it.andP;  The result is that changes to a framework willcost less and have a larger benefit.andM;Using FrameworksandM;Using a framework is typically comprised of two activities:andM;* defining any new classes that are needed, andandM;* configuring a set of objects by providing parameters to each object andconnecting them.andM;Ideally, no new classes are needed.andP;  Frameworks are seldom ideal; mostapplications must define new classes within the framework.andP;  However, evenwhen new classes are needed, most of the work of using a framework is&quot;plugging&quot; or configuring objects together.andM;Programs that configure a set of objects are very stylized.andP;  First, a set ofobjects is created and each object is initialized.andP;  Then, operations areperformed on the objects to connect them.andP;  These programs are so similar toeach other that it is natural to think that they can be writtenautomatically.andP;  Several of the user interface frameworks have tools that willautomatically write the code to configure a user interface.andP;  Glazier wasdeveloped at Tektronix to build subsystems based on Model/View/Controller[1].andP;  The NeXT Interface Builder is a much more powerful tool that buildsuser interface subsystems from the NeXT user interface framework [53].andM;Although specialized tools for configuring applications for particularframeworks are valuable, what is really needed are tools that can configureapplications for any framework.andP;  Scripting languages, which are compactnotations for constructing applications from existing software components,are a proposed solution to the problem.andP;  An object-oriented scriptinglanguage can serve the same role for a framework that a shell or a jobcontrol language can serve in a conventional environment.andP;  Twoobject-oriented scripting languages have been developed at the University ofGeneva, the Visual Scripting Tool [24] and TEMPO [8].andP;  TEMPO is specializedfor applications that deal with concurrent activities and temporalrelationships between them.andP;  The Visual Scripting Tool is a visualprogramming language (i.e., it is based on pictures instead of text).andM;Describing FrameworksandM;Since most object-oriented programming languages provide no direct supportfor either abstract classes or subsystems, it is not surprising that there isno good notation for describing frameworks.andP;  Frameworks are more than justthe classes that they contain, but include instructions for making subclassesand for configuring applications from the frameworks.andP;  The ITHACA project isan Esprit II project involving a number of European companies, researchorganizations, and universities to design and build an integrated applicationdevelopment and support environment based on the object-oriented programmingapproach [40].andP;  One of the goals of the project is a formalization offrameworks.andM;The goal of the ITHACA project is to reduce the long-term costs ofapplication development for standard applications from selected applicationdomains.andP;  Besides a kernel of object-oriented languages and compilers, itwill have an application development environment consisting of a set ofprogramming tools and an object-oriented software information base.andP;  Only thesoftware information base is tailored to a particular application domain.andO;Initially there are four target domains: public administration, officeautomation, financial applications, and chemistry.andM;A key idea in the ITHACA project is the generic application, which is similarto what we have called a framework.andP;  The software information base containsgeneric applications and other software components, as well.andP;  Users of theITHACA environment will have two kinds of roles: that of the applicationengineer who tailors an ITHACA environment to an application domain, and thatof the application developer who generates specific applications using thecomponents in the information base created by an application engineer.andP;  Theapplication engineer is concerned with all phases of software developmentfrom requirements analysis to coding and validation, but does so for genericapplications rather than specific ones.andP;  The application developer startswith a generic application and configures the final application from theavailable software components to meet application-specific requirements.andM;The software information base is more than just a class library because itcontains and organizes the application domain model, requirements,specifications, software components, and documentation.andP;  The primarymechanism for organizing the software information base is the frame, whichcollects and organizes all information pertaining to an application, whethergeneric or specific.andP;  Generic applications are also specified with frames.andO;There is a hierarchy of frames, from generic to specific.andP;  An applicationsdeveloper builds frames for specific applications by selecting a genericapplication frame and filling in the missing information, such as newrequirements and the resulting design choices.andM;An important part of the expected life cycle is to reevaluate genericapplication frames to improve their reusability.andP;  This might require that newsoftware components be added to the software information base.andP;  Thiscorresponds closely to the way that frameworks tend to be designed.andP;  In fact,generic applications are quite similar to frameworks, with the primarydifferences being that the ITHACA project is trying to explicitly capturerequirements and specifications, while these typically are describedinformally in the documentation of most frameworks.andP;  The iterative nature ofobject-oriented design is addressed in work on recognizing class hierarchies,leading to algorithms that automatically restructure a class hierarchy uponintroduction of one or more classes [5].andM;DemeterandM;The goal of the Demeter project, led by Karl Lieberherr at NortheasternUniversity, is to develop CASE tools and their theoretical foundations toimprove the productivity of object-oriented designers and programmers [31].andO;One of the key ideas is the class dictionary, which is similar to a grammar.andO;Class dictionaries describe the part-of and inheritance relationships betweenclasses.andP;  They can be interpreted as class definitions, type definitions, orgrammars.andP;  Different tools within the Demeter system use differentinterpretations of class dictionaries to automatically construct variouskinds of programs, such as class definitions, customized print routines foreach class, and parsers that can read object descriptions from a text fileand convert them into objects.andM;A class dictionary defines the structure of a class; a class module addsinterface definitions.andP;  Class dictionaries are language independent, butmethod definitions in class modules are written in particular language.andO;Demeter automatically produces programs from class modules.andP;  It creates theclass definitions, printers and parsers and adds the code in the classmodules to them.andP;  Demeter currently produces either Flavors or C++ programs.andM;Class DictionariesandM;Demeter classes fall into three categories: construction classes; repetitionclasses; and alternation classes.andP;  A class dictionary can be parametrized byother classes and can inherit from other classes.andP;  For example:andM;CLASS Basket HAS PARTS content: Sequence(Fruit) weight: Number END CI ASSBasket.andM;defines a construction class named Basket with components content and weight.andM;An example of a repetition class is class Sequence.andP;  Sequence has a classparameter; S.andP;  A Sequence contains zero or more parts of the specified class:andM;CLASS Sequence(S) IS LIST REPEAT {S} END CLASS Sequence.andM;An example of an alternation class is class Fruit:andM;CLASS Fruit IS EITHER Apple OR Orange COMMON PARTS weight: Number HASINTERFACE VIRTUAL cost() RETURNS Number END CLASS Fruit.andM;where apple and Orange are probably simple construction classes.andP;  Analternation class is always an abstract class.andP;  Thus, there is no need togenerate functions to construct objects for it.andP;  For example, in thedefinition of cost, the keyword VIRTUAL means that cost may be redefined inan Apple or Orange.andM;Software EvolutionandM;Demeter takes advantage of its grammar-based foundation to provide tools thathelp plan the evolution of software [29].andP;  Class modules are usuallyimplemented according to a growth plan that is determined by a classdictionary.andP;  A growth plan for a class dictionary D is a sequence ofincreasingly larger subclass dictionaries starting with a smallest subclassdictionary of D.andM;Each implementation phase completes the method definitions for some subset ofthe classes specified in the class module and provides a test suite fordebugging the code.andP;  The order of the phases and the classes involved in aphase are chosen in a way that each phase is an extension of the previousone.andP;  Each phase can successfully execute test cases for earlier phases.andO;Method definitions are added incrementally until the application iscompletely implemented.andP;  Thus, a growth plan provides for many smallsteps inthe development process, and each step can run all the tests of the first.andM;Another way to think of this approach is that each phase corresponds to anincreasingly detailed prototype.andP;  At each phase, the prototype works on atleast some of the objects.andP;  Later phases should work on all the objects thatearlier phases worked on.andP;  Lieberherr has shown that the growth plan problemis NP-hard, but has also developed useful heuristics for it that aresatisfactory in practice [28].andM;Constructing ClassesandM;AutomaticallyandM;One of the advantages of the similarity of grammars and class dictionaries isthat Demeter can infer class dictionaries from object descriptions [27].andO;Currently Demeter can abstract recursive class dictionaries from objectdescriptions.andP;  This problem is in general NP-hard, but for the special caseof single-inheritance class dictionaries Lieberherr's group has developed anefficient algorithm.andP;  Objects must be hierarchical and cannot have cycles.andO;For example, a particular basket of fruit might be:andM;andless;Basketandgt; content: (andless;Appleandgt; weight: 12, andless;Orangeandgt; weight: 4) weight: 16.andM;The task of constructing class dictionaries then becomes finding a grammarthat accepts the object descriptions.andP;  The class dictionary must accept onlyobject descriptions that are similar to the input set (i.e., the grammar thataccepts every object description is not useful).andP;  Moreover, the classdictionary should be as small as possible, which prevents it from simplylisting the original object descriptions.andM;The main motivation for constructing classes from examples is that specificexamples are easier to invent than general classes.andP;  In the same way,parametrized classes are harder to think about than classes without classparameters.andP;  The Demeter system can automatically build parametrized classesfrom non-parametrized ones.andP;  Often the need for parameterized classes is notobvious until after the classes have been written, so tools to automaticallyparametrize classes are valuable for both design and maintenance.andM;The Law of DemeterandM;A common problem in object-oriented design is collaboration graphs that aretoo complex, that is, too strong of a coupling between classes.andP;  The Law ofDemeter is a rule of good programming style that simplifies collaborationgraphs and minimizes coupling between classes [30, 31].andP;  Stated briefly, theLaw of Demeter says that one should not retrieve a part of an object and thenperform an operation on that part, but should instead perform the operationon the original object, which can implement the opration by delegating it tothe part.andP;  The result of following the Laws of Demeter is that a methoddepends only on the interfaces of its arguments and its instance variables,but it does not depend on their structure.andM;The Law of Demeter increases information hiding.andP;  Ideally, a class hides itsimplementation, but it is common for programmers todefine an interface thatlets clients of a class depend on its implementation details.andP;  As an extremeexample, the only methods defined by a class might be accessing methods thatsimply read or write the instance variables.andP;  A more common situation iswhere a client can ge a pointer to an array of components or to an internalhash table.andP;  Changing the representation of the class will then requirechanging all its clients.andP;  The Law of Demeter will not completely eliminatethis, because it does not prevent a method from rtrieving a component andthenusing it as an argument to another method, it just prevents the componentfrom being the direct receiver of a message.andM;The Law of Demeter can be enforced; the Demeter system contains tools thatwill check whether a design follows the Law of Demeter.andP;  It reducesunnecessary object coupling and helps new programmers learn good programmingstyle.andP;  This does not reduce thepower of object-oriented programming, becauseany program can be transformed into a program that follows the Law ofDemeter.andM;The Law of Demeter minimizes the coupling between classes and makes it easierto change a class interface.andP;  It increases information hiding by ensuringthat one class cannot depend on the implementation of another.andP;  The Law ofDemeter localizes type iformation.andP;  Thus, programs are easier to understandbecause each method depends on only a few interfaces.andP;  There are somedisadvantages to the Law of Demeter [45], but it is an important contributionto object-oriented design rules.andM;The Demeter project is trying to find other rules of good design.andP;  Objectinteractions imply dependencies between the classes of the objects.andP;  Thesedependencies affect the reusability of classes and the costs of futuredevelopment and maintenance of the software.andP;  Thus, rules like the Law ofDemeter can have a big impact on the cost of developing software.andM;ConclusionandM;One indication that the work on standardizaton of terminology by the group atHewlett-Packard is needed is the differences in terminology seen here.andO;However, the fact that different groups ar forced to invent terminology forthe same concepts indicates that the concepts are important.andM;One set of similar concepts is interface description, contracts, and role.andO;These phrases all describe looking at an object by its specification.andP;  Thisis important because (as the Hewlett-Packard definition clearly states)classes are really implementation, and designers emphasize the way objectsbehave instead of how they are constructed.andP;  Thus, object-oriented designersneed ways of talking about specification.andP;  &quot;Contract&quot; differs from the othertwo phrases because both the client and the server are included in thecontract, while &quot;interface description&quot; and &quot;role&quot; emphasize the view of theserves.andP;  This difference might not be very important, since clients willrefer to servers by their specification and not their class.andM;The Hewlett-Packard ensembles seem to be the same a the Tektronix subsystems.andO;These phrases describe groups of objects that are designed to work together.andO;This is important because it shows that classes alone do not provide enoughstructure for large systems.andP;  Therefore, additional structure is needed toorganize how objects work together.andP;  None of the existing object-orientedprogramming languages or programming environments provide very good supportfor describing how groups of objects work together.andM;Scripting languages have the same purpose as the Structure Specifications andObject Instantiation of OORASS, and may indeed be the same.andP;  They emphasizethe fact that an important part of creating an object-oriented applicationisconnecting objects to eachother and providing them with parameters.andP;  Thiswill be an important area of research in the future, since the emergence offrameworks will mean that a larger fraction of programming will beconfiguring existing components.andM;Each design method described here differs from the others significantly.andP;  TheTektronix process has two main phases, exploration and a detailed designphase.andP;  The exploration phase uses modeling to find classes, responsibilitiesfor each class, and collaborations between objects of different classes.andP;  Theexploration phase is very iterative; finding a new responsibility might leadto new collaborations or classes.andP;  The detailed design phase determinesinheritance, subsystems, and contracts, and focuses on building a design thatwill be as reusable as possible.andM;OORASS looks at a much larger part of the life cycle.andP;  It has five stages,and the first two, finding roles and object specification, cover the samepart of the life cycle as the Tektronix method.andP;  It does not seem to provideas good a mechanism for automatically finding faults in the design as theTektronix design process.andP;  However, the Tektronix design method couldprobably be adapted for use as the first two steps in the SI design process.andO;On the other hand, OORASS not only includes class implementation (the thirstage), but the structure specification stage and the object instantiationstage describe how applications are configured from preexisting parts.andM;The Demeter design process is to construct class dictionaries, convert theminto class modules by adding interface specifications, and then to build andfolow a growth plan to implement the classes.andP;  This differs from the othertwo design processes in emphasizing the structure of classes.andP;  Also,inheritance is emphasized from the beginning.andP;  Although all three designprocesses emphasize looking at examples, the Demeter system provides tools toautomatically construct concrete classes from examples, and abstract classesfrom concrete classes.andP;  Thus, it is even more example-driven than the othertwo.andM;Although each of these methods has its own unique characteristics, they aremore complementary than they are competing.andP;  Differences in vocabulary hidetheir similarities.andP;  As object-oriented design methods mature, they willborrow ideas from one another.andP;  The design methods of the future willintgrate and expand on these ideas to support larger-scale design andcomposition at all levels and help object-oriented programming live up to itspotential to make software more reusable and hence less expensive and morereliable.andM;ReferencesandM;[1] Alexander, J.H.andP;  Paneless panes for Smalltalk windows.andP;  In Proceedings ofOOPSLA '87.andP;  SIGPLAN Not.andP;  (ACM) 22, 12 (Oct.andP;  1987), 287-294.andM;[2] Apollo Computer.andP;  Network Computing System, Tech.andP;  Rep.andP;  I-27, 1987.andM;[3] BEck, K. and Cunningham, H. A laboratory for teaching object-orientedthinking.andP;  In Proceedings of OOPSLA '89.andP;  SIGPLAN Not.andP;  (ACM) 24, 10 (NewOrleans, Louisiana, October 1989), 1-6.andM;[4] Bobrow, D.G., DeMichel L.G., Gabriel, R.P., Keene, S.E., Kiczales, G.,andO;Moon, D.A.andP;  Common Lisp object system specification X3J13.andP;  In SIGPLAN Not.andO;(ACM) 23, 9.andP;  (1988).andM;[5] Casais, E. Keorganizing an object system.andP;  In Object-OrientedDevelopment, D. Tsichritzis, Ed.andP;  Centre Universitaire d'Informatique,Universite de Geneve, 1989.andP;  pp.andP;  161-189.andM;[6] Coad, P. and Yourdon, E. Object-Oriented Analysis.andP;  Prentice-Hall,Englewood Cliffs, NJ, 1990.andM;[7] Cox, B. Object-Oriented Programming: An Evolutionary Approach.andO;Addison-Wesley, Reading, Mass., 1986.andM;[8] Dami, L., Fiume, E., Nierstrasz, O., and Tsichritzis, D. Temporal scriptsfor objects, Active Object Environments, D.C.andP;  Tsichritzis, Ed.andP;  CentreUniversitaire d'Informatique, Universite de Geneve, June 1988, pp.andP;  144-161.andM;[9] De Champeaux, D. and Olthoff, W. Towards an object-oriented analysistechnique.andP;  In Proceedings of the Pacific Northwest Software QualityConference (September 1989) pp.andP;  323-338.andM;[10] Deutsch, L. P.andP;  Levels of reuse in the Smalltalk-80programming system.andO;In Tutorial: Software Reusability, P. Freeman, Ed.andP;  IEEE Computer SocietyPress, Washington, D.C., 1987.andM;[11] Deutsch, L. P.andP;  Design reuse and frameworks in the Smalltalk-80 system.andO;In Software Reusability, Vol.andP;  II, T.J.andP;  Biggerstaff and A. J. Perlis, Eds.andO;ACM Press, pp.andP;  57-7., 1989.andM;[12] Ewing, J.J.andP;  An object-oriented operating system interface.andP;  InProceedings of OOPSLA '86 Conference Proceedings.andP;  SIGPLAN Not.andP;  (ACM) 21, 11(portland, Oregon, November 1986), pp.andP;  46-56.andM;[13] Fishman, D.H.andP;  et al.andP;  Iris: An object-oriented data base system.andP;  ACMTransactions on Office Information Systems, 5-1 (1987), 48-69.andM;[14] Foote, B. Designing to facilitate change with object-orientedframeworks.andP;  Master's thesis.andP;  University of Illinois at Urbana-Champaign,1988.andM;[15] Goldberg, A. and Robson, D. Smalltalk-80 talk-80: The Language and itsImplementation.andP;  Addison-Wesley, 1983.andM;[16] Gossain, S. and Anderson, D.B.andP;  Designing a class hierarchy for domainrepresentation and reusability.andP;  In Proceeding of Tools '89.andP;  (Paris, France,November 1989) pp.andP;  201-210.andM;[17] Halbert, D. and O'Brien, P.andP;  Using Types and Inheritance inObject-Oriented Languages.andP;  IEEE Software (Sept.andP;  1987) 71-79.andM;[18] Hewlett-Packard.andP;  HP NewWare Reference Guide.andP;  August 1989.andM;[19] Hewlett-Packard.andP;  HP builds framework Electronic Engineering Times.andO;June 10, 1989.andP;  73-74.andM;[20] ISO.andP;  Information, retrieval, and transfer management for OSI, draftproposal.andP;  Part I: Management and Information Model.andP;  ISO/IEC JTC1/SC21 N.andO;May 1989.andM;[21] Jindrich, W.A.andP;  FOIBLE: A framework for visual programming languages.andO;Master's thesis, Univ.andP;  of Illinois at Urbana-Champaign, 1990.andM;[22] Johnson, E. and Foote, B. Designing reusable classes.andP;  J. ofObject-Oriented Program.andP;  1, 2 (June/July 1988), 22-35.andM;[23] Johnson, R. E., Graver, J.O.andP;  and Zurawski, L.W.andP;  TS: An optimizingcompiler for Smalltalk.andP;  In Proceeding of OOPSLA '88, SIGPLAN Not.andP;  23, 11(San Diego, Ca., September 1988) 18-26.andM;[24] Kappel, G., Vitek, J., Nierstrasz, O., Gibbs, S., Junod, B., Stadelmann,M., Tsichritzis, D.andP;  An object-based visual scripting environment.andP;  In ObjectOriented Development, Tsichritizis, Ed.andP;  Centre Universitaire d'Informatique,Universite de Geneve, 1989.andP;  pp.andP;  123-142.andM;[25] Krasner, G.E.andP;  and Pope, S.T.andP;  A cookbook for using themode-view-controller user interface paradigm in Smalltalk-80.andP;  J. ofObject-Oriented Program.andP;  1, 3 (August/Sept.andP;  1988), 26-49.andM;[26] LaLonde, W. Designing families of data types using exemplars.andP;  ACMTransactions on Programming Languages and Systems, 11, 2 (April 1989),212-248.andM;[27] Lieberherr, K.J., Berstein, P. and Silva-Lepe, I. From object toclasses: Algorithms for object-oriented design.andP;  Tech.andP;  Rep.andP;  Demeter-3,Northeastern University, January 1990.andM;[28] Lieberherr, K.J.andP;  and Holland, I.andP;  Assuring good style forobject-oriented programs.andP;  IEEE Software, (September 1989), 38-48.andM;[29] Lieberherr, K.J.andP;  and Holland, I.andP;  Tools for preventive softwaremaintenance.andP;  In Conference on Software Maintenance.andP;  (October 16-19, 1989),IEEE Press, Miami Beach, Florida, pp.andP;  2-13.andM;[30] Lieberherr, K.J., holland, I., and Riel, A.J.andP;  Object-orientedprogramming: an objective sense of style.andP;  In Proceeding of OOPSLA '88Conference.andP;  SIGPLAN Not.andP;  (ACM) 23, 11, (San Diego, Ca., September 1988)323-334.andM;[31] Lieberherr, K.J.andP;  and Riel, A.J.andP;  Demeter: a {CASE} study of softwaregrowth through parameterized classes.andP;  J. of Object-Oriented Program: 1, 3(August/September 1988), 8-22.andM;[32] Linton, M.A., Vlissides J.M.andP;  and Calder, P.R.andP;  Composing userinterfaces with Interviews.andP;  Computer 22, 2 (Feb.andP;  1989), 8-22.andM;[33] Madany, P.W., Campbell, R. H., Russo, V.F.andP;  and Leyens, D.E.andP;  A. ClassHierarchy for Building Stream-Oriented File Systems.andP;  In Proceedings of the1989 European Conference on Object-Oriented Programming.andP;  (July 1989,Nottingham, UK) S. Cook, Ed., Cambridge University Press.andP;  311-328.andM;[34] Meyer, B. Object-Oriented Software Construction.andP;  Prentice-Hall, 1988.andM;[35] Miller, M.S., Cunningham, H., Lee, C., Vegdahl, S.R., The ApplicationAccelerator Illustrator System.andP;  In OOPSLA '86 Conference Proceedings SIGPLANNot.andP;  (ACM) 2, 11 (Portland, Oregon, November 1986), 294-302.andM;[36] Nordhagen, E., Generic Object Oriented Systems.andP;  In Proceedings of Tools'89.andP;  (Paris, France, November 1989) pp.andP;  131-140.andM;[37] Opdyke, W. and Johnson, R. Refactoring: An aid in designing applicationframeworks.andP;  In Proceedings of the Symposium on Object-Oriented ProgrammingEmphasizing Practical Applications, September 1989.andM;[38] Palay, A.J., Hansen, W.J., Kazar, M.L., Sherman, M., Wadlow, M.G.,andO;Neuendorffer, T.P., Stern, Z., Bader, M. and Peter, T.andP;  The AndrewToolkit--An Overview, USENIX Association Winter Conference, Dallas, 1988.andM;[39] Paseman, W. The Atherton Software Backplane: An Architecture for ToolIntegration.andP;  Unix Rev.andP;  (April 1989).andM;[40] Profrock, A.K.andP;  Tsichritzis, D., Muller, G., and Ardez, M. ITHACA: Anintegrated toolkit for highly advanced computer applications.andP;  InObject-Oriented Development.andP;  Tsichritzis, D., Ed.andP;  Universite de Geneve,1989, pp 321-344.andM;[41] Reenskaug, T. and Nordhagen, E. The Description of ComplexObject-Oriented Systems: Version 1.andP;  Senter for Industriforskning, Oslo,Norway, 1989.andM;[42] Reenskaug, T. And Skaar, A.L.andP;  An Environment for Literate SmalltalkProgramming.andP;  In Proceedings of OOPSLA '89 SIGPLAN Not.andP;  (ACM) 24, 10.andP;  (NewOrleans, Louisiana) October 1989.andP;  337-346.andM;[4o] Russo, V. And Campbell, R.H.andP;  Process Scheduling in MultiprocessorOperating Systems using Class Hierarchical Design.andP;  In Proceedings of OOPSLA'88 SIGPLAN Not.andP;  (ACM) 23, 11 (San Diego, California, Oct. 1988).andM;[44] Russo, V. and Campbell, R.H.andP;  Virtual Memory and Backing StorageManagement in Multiprocessor Operating Systems using Class HierarchicalDesign.andP;  In Proceedings of OOPSLA '89 SIGPLAN Not.andP;  24, 10, (New Orleans,Louisiana Sept. 1989) 267-278.andM;[45] Sakkinen, M.andP;  Comments on the law of Demeter and C++.andP;  In SIGPLAN Not.andO;(ACM) 23, 12 (December 1988), 38-44.andM;[46] Schmucker, K.andP;  Object Oriented Programming for the Macintosh, Hayden,Hasbrouck Heights, New Jersey, 1986.andM;[47] Shlaer, S. and Mellor, S.andP;  Object-Oriented Systems Analysis.andP;  YourdonPress, 1988.andM;[48] Snyder, A.andP;  Encapsulation and inheritance in object-oriented programminglanguages.andP;  In Proceedings of OOPSLA '86 Conference.andP;  SIGPLAN Not.andP;  (ACM) 21,11 (Portland, Oregon, November 1986), 38-45.andM;[49] Snyder, A.andP;  The essence of objects.andP;  Rep.andP;  STL-89-25.andP;  SoftwareTechnology Laboratory, Hewlett-Packard Laboratories, Palo Alto, CA.andM;[50] Snyder, A.andP;  An abstract object model for object-oriented systems.andO;STL-90-22, Software Technology Laboratory, Hewlett-Packard Laboratories, PaloAlto, CA.andM;[51] Snyder, A., Hill, W. and Olthoss, W.andP;  A glossary of commonobject-oriented terminology.andP;  Rep.andP;  STL-89-26, Software TechnologyLaboratory, Hewlett-Packard Laboratories, Palo Alto, CA.andM;[52] Stroustruo, B.andP;  The C++ Programming Language.andP;  Addison-Wesley, 1986.andM;[53] thompson, T.andP;  The NeXT Step.andP;  Byte 14, 3 (March 1989), 265-271.andM;[54] Vlissides, J.M.andP;  and Linton, M.A.andP;  Unidraw: A framework for buildingdomain-specific graphical editors.andP;  In Proceedings of the ACM User InterfaceSoftware and Technologies '89 Conference (November 1989).andM;[55] Weinand, A., Gamma, E. and Marty, R. ET++-An object oriented applicationframework in C++.andP;  In Proceedings of OOPOSLA '88 SIGPLAN Not.andP;  (ACM) 23, 11(San Diego, CA., September 1988), 46-57.andM;[5l] Weinand, A., Gemma, E., and Marty, R. Design and implementation of ET++,a seamless object-oriented application framework.andP;  Structured Program.andP;  10, 2(1989), 63-87.andM;[57] Wirfs-Brock, R.J.andP;  An Integrated Color Smalltalk-80 System.andP;  InProceedings of OOPSLA '88 SIGPLAN Not.andP;  (ACM) 23, 11, (San Diego, CA.,andO;September 1988) 71-82.andM;[58] Wirfs-Brock, A. and Wilkerson, B. Variables Limit Reusability.andP;  J.andO;Object-Oriented Program.andP;  2, 1 (May/June 1990), 34-40.andM;[59.andP;  Wirfs-Brock, R. and Wilkerson, B. Object-Oriented Design: AResponsibility-Driven Approach.andP;  In Proceedings of OOPSLA '89 Conference.andO;SIGPLAN Not.andP;  (ACM) 24, 10, (New Orleans, Louisiana, October 1989), 71-76.andM;[60] Wirfs-Brock, R. Wilkerson, B., and Wiener, L. Designing Object-OrientedSoftware.andP;  Prentice-Hall, 1990.andM;[61] Zweig, J. and Johnson, R. Conduits: A communication abstraction in C++.andO;To be published in the USENIC C++ Conference, 1990.andM;Following is a list of contact names and addresses for the associatedsections of this article.andM;Common TerminologyandM;Contact: Alan Snyder Hewlett-Packard Laboratories P.O. Box 10490 Palo Alto,CA 94303-0971 snyder@hplabs.hp.comandM;Object-Oriented AnalysisandM;Contact: Dennis de Champeaux Hewlett--Packard Laboratories P.O. Box 10490Palo Alto, CA 94303-0971 champeaux@hplabs.hp.comandM;Research in ResponsibilityandM;Driven DesignandM;contact: Rebecca Wirfs-Brock Tektronix, Inc. P.O. Box 500, Mail Station47-720 Beaverton, Oregon 97077 rebeccaw@tekig5.pen.tek.comandM;Object-Oriented SoftwareandM;EngineeringandM;contact: Trygve Reenskaug Senter for Industriforskning P.O. Box 124 Blinden0314 Oslo 3, Norway.andM;Frameworks--ReusableandM;DesignsandM;contact: Ralph E. Johnson Department of Computer Science University ofIllinois at Urbana-Champaign 1304 West Springfield Ave. Urbana, Illinois61801-2987 johnson@p.cs.uiuc.eduandM;DemeterandM;contact: Karl Lieberherr Northeastern University, College of Computer ScienceCullinane Hall, 360 Huntington Ave., Boston, MA 02115lieber@corwin,CCS.northeastern.EDUandM;REBECCA J. WIRFS-BROCK is a principal software engineer at Tektronix, Inc.,andO;and coauthor of Designing Object-Oriented Software (Prentice-Hall, 1990).andO;She has spent 15 years designing software and managing software products.andO;She managed the development of Tektronix Color Smalltalk, and has developedand taught courses on object-oriented design.andM;RALPH E. JOHNSON is an assistant professor in the Department of ComputerScience at the University of Illinois at Urbana-Champaign.andP;  He has extensiveexperience with object-oriented programming in both C++ and Smalltalk, havingbeen involved with medium-sized applications, such as operating systems andan optimizing Smalltalk compiler.andO;</TEXT></DOC>