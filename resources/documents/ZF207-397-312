<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-397-312  </DOCNO><DOCID>07 397 312.andM;</DOCID><JOURNAL>Hewlett-Packard Journal  June 1989 v40 n3 p6(12)* Full Text COPYRIGHT Hewlett Packard 1989.andM;</JOURNAL><TITLE>A data base for real-time applications and environments. (HP'sReal-Time Data Base) (technical)</TITLE><AUTHOR>Fatehi, Feyzi; Givens, Cynthia; Hong, Le T.; Light, Michael R.;andO;Liu, Ching-Chao; Wright, Michael J.andM;</AUTHOR><SUMMARY>Hewlett-Packard's HP Real-Time Data Base (HP RTDB) is a databasemanagement system (DBMS) for developing, managing and interactingwith a real-time data base.andP;  Real-time databases must store burstsof data quickly and efficiently and provide that informationwithout delay in real-time environments such as factory flooroperations.andP;  HP RTDB's features include: database definitionfunctions; write and query operations; backup functions; highperformance; access to multiple databases; dynamicreconfiguration; security features; and programming aids.andP;  Themajor modules are divisible into user-callable and internaldatabase routines.andP;  Details of HP RTDB's data structures, dataaccess, database configuration and design, locking and concurrencycontrol, security, querying and other features are described.andP;  HPRTDB runs under HP-UX on an HP 9000 Series 300 or 8000 computer.andM;</SUMMARY><DESCRIPT>Company:   Hewlett-Packard Co. (products).andO;Ticker:    HWP.andO;Product:   Real-Time Data Base (data base management system) (design andconstruction).andO;Topic:     Data Base Management SystemsSpecificationsSystem DesignReal-Time SystemsApplicationsSoftware Packages.andO;Feature:   illustrationcharttable.andO;Caption:   An overview of the HP Real-Time Data Base System. (chart)A table structure in HP RTDB consisting of six tuples and fivecolumns. (table)HP RTDB module hierarchy. (chart)andM;</DESCRIPT><TEXT>A Data Base for Real-Time Applications and EnvironmentsandM;A REAL-TIME ENVIRONMENT deals with current phenomena rather than past orfuture events.andP;  If information is lost, it is lost forever since there israrely an opportunity to reclaim it.andP;  A typical real-time situation is afactory floor where a computer is monitoring the status of machines andmaterials and constantly checking to make sure that everything is workingproperly.andP;  Frequently, the data from these checks can be discarded once it isdetermined that all is indeed satisfactory, although some data might beretained for statistical purposes.andP;  If the checking process reveals somethingamiss, a real-time process might be invoked to correct the situation, such asrejecting a flawed part or shutting down an entire assembly line if a machineis overheating.andP;  Data from such incidents is frequently saved for lateranalysis (e.g., statistical quality control).andM;A real-time environment needs to respond reliably when an action must betaken quickly within a brief predetermined span of time, such as receivingand storing a satellite data transmission.andP;  If the process of receiving andstoring the data can always be expected to finish within 80 milliseconds,then the satellite can reasonably transmit every 100 milliseconds withoutfear of losing any data.andM;Data capture in a real-time environment may involve sampling large amounts ofraw information with data arriving unexpectedly in bursts of thousands ofbytes or even megabyte quantities.andP;  A real-time data base must be capable ofefficiently storing such large amounts of data and still support theexpectations of the user for reliable and predictable response.andM;When a real-time process requests data, it should be given that dataimmediately, without any unreasonable delay.andP;  Whether or not the data isconsistent may be less of a concern than that it is the most current dataavailable.andP;  Given sufficient urgency, a real-time application may not requireguarantees of either consistency or integrity of data.andP;  An applicationdesigner must be aware of the risks and should only violate normal dataintegrity rules when absolutely necessary.andP;  A real-time data managementsystem must tolerate such violations when they are clearly intentional.andM;Finally, a real-time data base must be scalable to the needs of differentusers.andP;  This means that users should be able to implement or eliminatefunctionality according to the needs of the application.andP;  The performanceimpact of unused functionality must be minimal.andM;Traditional Data BasesandM;Traditional data bases are generic and flexible, intended to support thewidest possible range of applications.andP;  Most traditional data bases usemagnetic disc as the primary data storage medium because of its largecapacity, relatively high-speed access, and data permanence.andP;  Disc-based databases in the gigabyte range are now possible.andM;However, traditional data bases are too slow for most real-time applications.andO;Disc access speeds are still two to three orders of magnitude slower thandynamic random access memory (DRAM) access.andP;  Even when the average speed of atraditional data base is acceptable, its worst-case speed may be totallyunacceptable.andP;  A critical need of real-time systems is the ability to providea predictable response time.andP;  Traditional data bases support transactionoperations, which may require commit protocols, logging and recoveryoperations, and access to disc.andP;  They also define data access methods thatrigidly enforce internal rules of data consistency and integrity.andP;  Given alarge number of simultaneous transactions, it becomes nearly impossible toguarantee predictable response time.andP;  For example, data that is modified aspart of an update transaction may not be available to a reader process untilthe entire transaction is committed.andP;  If the reader in this case were areal-time assembly line control process, it could be disastrously delayedwaiting for a process of much less importance to complete.andM;Real-Time Data BasesandM;Because of extremely high performance requirements, real-time data bases areoften custom-designed to the particular needs of a given application.andP;  Thislimits their usability for other applications and causes portability problemsif their performance relies upon any hardware characteristics.andP;  They are alsousually expensive to program and maintain.andM;Real-time data bases have taken two common approaches, acting either as avery fast cache for disc-based data bases or as a strictly memory-residentsystem which may periodically post core images to disc.andP;  Real-time data basesacting as a high-speed cache are capable of quickly accessing only a smallpercentage of the total data kept on disc, and the data capacities of purelymemory-resident data bases are severely limited by the amount of availablereal memory.andP;  In either case, real-time data bases must coexist withdisc-based data bases to provide archival and historical analysis functionsin real-time applications.andP;  Eventually, a portion of real-time data isuploaded to a disc-based data base.andM;Data transfer between real-time and disc-based data bases requires commonlyunderstood data types, and may require reformatting or other treatment tomake it digestible to the target data base.andP;  Frequently, data is transferredover a network interface as well.andP;  The problems of interfacing real-time databases with disc-based data bases are often further complicated by thecustomized, nonstandard nature of most real-time data bases.andM;HP Real-Time Data BaseandM;HP Real-Time Data Base (HP RTDB) is one of the Industrial Precision Toolsfrom HP's Industrial Applications Center.andP;  The Industrial Precision Tools aresoftware tools intended to assist computer integrated manufacturing (CIM)application developers by providing standard software solutions forindustrial and manufacturing applications problems.andP;  The HP Real-Time DataBase is the data base tool.andP;  HP RTDB is a set of software routines andinteractive query commands for creating and accessing a high-performancereal-time data base.andP;  It is designed for the specific needs of real-timesystems running on HP 9000 Series 300 and 800 Computers.andM;Fig.andP;  1 shows an overview of the HP Real-Time Data Base system.andP;  Access tothe data base for the user is through the query commands or an applicationprogram written in C that uses the HP RTDB routines.andP;  The HP RTDB routinesprovide the application developer with the ability to:andM;* Define or change the data base schemaandM;* Build the data base in memoryandM;* Read or write data from or to the data baseandM;* Back up the schema and data.andM;The query commands provide an interactive facility for configuring anddebugging the data base, and for processing scripts in batch mode and on-linewithout writing a program.andP;  The configuration file is automatically createdwhen the user defines the data base.andP;  It contains the system tables andcontrol structures for the data base.andM;Besides the two interfaces to the data base, HP RTDB also provides thefollowing features:andM;* Performance.andP;  HP RTDB supports predictable response time, and to ensurespeed, HP RTDB is entirely memory-resident.andP;  Several design alternatives werechosen to ensure this high performance, such as preallocation of all database memory to minimize memory management overhead, alignment of data onmachine word boundaries, simple data structures, and the extensive use ofin-line macros to reduce the overhead of function calls.andP;  The designalternatives chosen produced performance results that exceed initial goals.andO;For example, performance tests showed that 66,666 56-byte records can bedirectly retrieved from an HP Real-Time data base in one second.andM;* Multiple Data Base Access.andP;  HP RTDB resides in shared memory so thatmultiple processes can access the data base concurrently.andP;  Also, one processcan access multiple data bases.andM;* Simple Data Structures.andP;  Data is stored in HP RTDB in two forms: tables andinput areas.andP;  A table is an array of columns and rows (tuples) that containrelated information (see Fig.andP;  2).andP;  Input areas are areas in the data basedesigned to receive large blocks of unstructured data.andP;  Often this data comesfrom high-speed data acquisition devices.andM;* Data Access.andP;  Retrieval routines are constructed so that any specified datacan be accessed directly, sequentially, or by hash key values.andP;  Direct accessis available to a tuple (row) of a table and to an offset in an input area.andM;* Dynamic Reconfiguration.andP;  Tables and input areas can be added or deletedquickly without having to recreate the data base.andM;* Security.andP;  HP RTDB provides three levels of password protection: data baseadministrator access, read-write access, and read-only access.andM;* Backup and Recovery.andP;  The schema (data base structure), and optionally theuser's entire data base can be saved to a disc file.andM;* Locking.andP;  HP RTDB provides tables and input area locking.andP;  This means thatan application can exclusively access a table or input area until it decidesto release the lock.andP;  If the application requires, read-through and/orwrite-through locks are allowed.andM;* Scalability.andP;  HP RTDB is scalable.andP;  If some features are not required theycan be eliminated to improve performance.andM;* Documentation Aids.andP;  HP RTDB is supplied with a self-paced tutorialcomplete with a query/debug script to build the data base that is used in thetutorial examples.andP;  There is also an on-line help facility for theinteractive query/debug utility.andM;* Programming Aids.andP;  HP RTDB programming aids include:andM;* A standard C header file defining the constants and data structuresrequired to use the HP RTDB subroutinesandM;* Prototyping and debugging capabilities of the query/debug utilityandM;* On-line access to explanations of HP RTDB error codesandM;* User-configurable error messages, formats, and hooks for user-written errorroutinesandM;* Native language support which includes 8-bit data, 8-bit filenames, andmessage catalogs.andM;HP RTDB ModulesandM;The HP Real Time Data Base modules can be grouped into two main categories:user-callable routines and internal data base routines (see Fig.andP;  3).andP;  Theuser-callable routines include the following functions.andM;* Administrative FunctionsandM;* Define the data base including its name, passwords, and system limits(MdDefDB)andM;* Build or rebuild the data base in memory (MdBuildDb)andM;* Remove a data base from memory (MdRmDb)andM;* Change data base system limits or passwords (MdChgDb, MdChgPwd).andM;* Data Definition FunctionsandM;* Define a table or input area (MdDefTbl, MdDefIA)andM;* Define or add column(s) to a user table (MdDefCol)andM;* Define an index on column(s) in a defined table (MdDeflx)andM;* Remove a table or an input area (MdRmTbl, MdRmIA)andM;* Remove an index from a table (MdRmIx).andM;* Session Begin or End FunctionsandM;* Open the data base and initiate a session (MdOpenDb)andM;* Close the data base and terminate a session (MdCloseDb).andM;* Data Manipulation FunctionsandM;* Open a table or input area for access (MdOpenTbl, MdOpenIA)andM;* Get a tuple by sequential search (MdGetTplSeq), hash key index(MdGetTplIx), or tuple identifier (MdGetTplDir)andM;* Compare a tuple value with a set of expressions (MdCompare)andM;* Add or remove a tuple to or from a table (MdPutTpl, MdRmTpl)andM;* Update a tuple (MdUpdTpl)andM;* Get or put a value from or to an input area (MdGetIA, MdPutIA)andM;* Lock or unlock a table or an input area (MdLock, MdUnlock).andM;* Utility FunctionsandM;* Save the data base schema and optionally the entire data base to disc(MdTakeImage)andM;* Release resources held by prematurely terminated processes (MdCleanup)andM;* Provide information on the columns of a table (MdColInfo)andM;* Provide information on the minimum data base and schema size in bytes(MdDbSizeInfo)andM;* Provide information on all or one specific user table, index on a table, orinput area (MdTblInfo, MdIxInfo, MdIAInfo)andM;* Provide information on system tables and session use (MdSchInfo).andM;The internal data base routines are used by either the user-callable routinesor other internal routines.andP;  They are implemented as C functions or macros.andO;The macro implementations are used for small pieces of code.andP;  The resultingcode is slightly larger but faster.andP;  The functions performed by the internaldata base routines include:andM;* System Table Manager.andP;  These routines handle the tables that define theschema and configuration of the data base.andM;* Index manager.andP;  These routines handle hashing, index manipulation, andformulation of hash index key values.andM;* Concurrency Manager.andP;  These routines handle locking operations and controlconcurrent processes using the data base.andM;* Storage Manager.andP;  These routines handle memory management, which includeskeeping track of allocated and available shared memory.andM;* Operating System Interface.andP;  These routines provide a clean and consistentinterface to the HP-UX operating system.andM;* Table and Tuple Manager.andP;  These routines handle functions related to tuplesand tables such as copying, adding, or deleting tuple values.andM;Data StructuresandM;The data structures in HP RTDB are divided into two categories: those thatmanage and control access to the data base and define the schema, and thosethat contain the user data.andP;  Fig.andP;  4 shows an overview of these structures inshared memory.andP;  The data structures in the schema and control section areautomatically created when the data base is defined.andP;  The data structures inthe user area are added later when the data base is built.andP;  Only two of thesedata structures are visible and accessible to the user--user tables and inputareas.andM;* Main Control Block.andP;  The main control block contains the data base status,limits, and pointers to other data structures in the schema and controlsection of the data base.andP;  It also contains information used by the storagemanager, such as pointers to the beginning and end of free memory storagespace, a pointer to the list of free storage blocks, and the total amount offree storage left.andM;* Session Control Blocks.andP;  A session control block is allocated to eachprocess accessing the data base.andP;  Each block contains a session identifier, apointer to the main control block, and other information about the process,such as the user identifier (HP-UX uid) and the process identifier (HP-UXpid).andP;  The session identifier is returned to the user when the data base isopened, and is used in subsequent calls to access the data base.andP;  The numberof session blocks determines the number of users that can have access to thesame data base at any one time.andP;  This number is determined when the data baseis created.andM;* Semaphore Control Blocks.andP;  There is a semaphore control block for eachlockable object in the data base (i.e., user tables and input areas).andP;  Theseblocks contain HP-UX semaphore identifiers.andM;* Locks-Held Table.andP;  Each entry in the locks-held table indicates whether alock is being held by a session on a certain data base object (user table orinput area), and if so, what type of lock.andM;* Index Tables.andP;  Index tables contain the data for performing fast access(i.e., hash indexing) to system and user tables.andM;* System Tables.andP;  System tables contain the schema (structure) of the database and information about the locations and attributes of all data baseobjects, including themselves.andM;* User Tables and Input Areas.andP;  The application data managed by the user iscontained in the user tables and input areas.andM;Tables.andP;  The table, which is a two-dimensional array consisting of rows(tuples) and columns, is the fundamental data structure in HP RTDB.andP;  Thereare three types of tables: system tables, user tables, and index tables.andP;  Alltables, whether they are system, index, or user tables, have the samestructure, called a table block (see Fig.andP;  5).andP;  A table block is divided intotwo sections: control structures and data.andP;  Control structures contain theinformation needed to locate, add, or delete data in a table.andP;  The dataportion of the table contains the system or user data.andP;  The information inthe control structures includes:andM;* Table Block Header.andP;  The header contains information needed to accessinformation within the table, such as data offsets and table type (i.e.,andO;system, index, or user).andM;* Slot Array.andP;  Each entry in the slot array indicates whether a tuple in atable is filled or vacant.andP;  The slot array is accessed when adding ordeleting tuples, and when searching sequentially.andM;* Column Descriptor Array.andP;  The entries in the column descriptor arraydescribe the columns in the data portion of the table block.andP;  Each columndescriptor defines the column type (i.e., character, byte string, integer,float, input area offset, etc.), the column length, and the column offset inbytes from the start of the tuple (see Fig.andP;  6).andM;The data in each type of table is stored in tuples.andP;  The tuple format, whichis the number, length, and type of columns, must be the same for all tuplesin any one table.andP;  However, the tuple format may be different for each table.andO;The number and size of tuples in a table are limited only by the amount ofreal memory available.andP;  Each tuple and all columns within a tuple areword-aligned.andP;  Variable-length columns and null columns are not supported.andO;To support only fixed-length data and columns may seem wasteful of realmemory, but this scheme more than offsets the increased size and complexityof code needed to support variable-length data, and the resulting performancedegradation.andP;  Another benefit is that the size of a table has little effectupon the speed of accessing any given tuple.andP;  Since all tuples in a table arethe same length, a tuple's location is fixed and can be quickly determinedwith one simple calculation.andP;  Once located, copying the tuple's data betweenthe data base and a user buffer can be done by words (four bytes at a time)rather than one byte at a time, since all data is aligned on machine wordboundaries.andM;Data in user tables can be any supported C data type or an offset into aninput area.andP;  Users can also store and retrieve unsupported data types intable columns defined as a byte string type.andP;  Using the byte string type, theuser can store pointers to other tuples in the same or any other table.andP;  Datacompression, alignment of values in tuples, and verification of data types isleft to the user's application, where these functions can be done moreefficiently.andP;  HP RTDB routines store user data exactly as its is received andretrieve user data exactly as it is stored.andP;  A positive side effect of thisis that the storage and retrieval integrity of 16-bit data (e.g., Katakana orChinese text) can be guaranteed without special routines.andM;Because all table types have the same table block structure, the same codecan be used to perform operations on system, index, and user tables.andO;However, system table access is so critical to performance that operations onsystem tables are often performed by special code that takes full advantageof the known, fixed locations and formats of system tables.andM;Tuple Identifiers.andP;  A tuple identifier or tid uniquely identifies each tuplein every table in the data base including system tables, index tables, anduser tables.andP;  Tuple identifiers are used by the user to access user tablesand by internal HP RTDB routines to access all the tables in the data base.andO;A tuple identifier is returned to the user when a tuple is added to a table(MdPutTpl) or after a successful table search (MdGetTplSeq) or after asuccessful indexed access (MdGetTplIx).andP;  Once obtained, a tuple identifiercan be used in subsequent calls to provide extremely fast, direct access tothe same tuple for rereading, deletion, or update.andP;  Directed access by tupleidentifier is by far the fastest access method in the HP RTDB data base.andM;The data type for a tuple identifier is called tidtype and contains threeelements: a table number, a tuple number, and a version number.andM;* The table number is the tuple number for a tuple in a system table thatdescribes the table associated with the tuple identifier.andP;  Fig.andP;  7 shows thetid for a user table and the use of the table number and tuple numberentries.andP;  For system and user tables, the system table containing the tuplesof table descriptions is called a table system table, and for index tablesthe system table is called an index system table.andP;  System tables aredescribed in detail later in this article.andM;* The tuple number indicates the rwo in a table containing the tuple data.andM;* The version number is used to ensure that a tuple being accessed directlyby a tid is the same tuple that was accessed when the tid was first obtained.andO;For example, suppose user A adds a tuple to table X and saves the returnedtid for subsequent rereading.andP;  If user B accesses table X and deletes thetuple added by user A and then adds another tuple to table X, it is possiblethat the tuple added by user B could occupy ty same location as the tupleoriginally added by user A.andP;  When user A attempts to use the same tid ontable X for reading the tuple that was changed by user B, the version numberswon't match and user A will be prevented from accessing the tuple andnotified of the problem.andM;Tuple identifiers can be used to chain tuples logically.andP;  Users can buildlogical relationships between tuples by inserting the tuple identifier of onetuple as a column value of another tuple.andP;  This concept is illustrated inFig.andP;  8, where tidA4 and tidB2 are tuple identifiers.andP;  The tuple identifieris designed to that its value remains constant across data base restarts anddynamic schema changes.andP;  Thus relationships of tuples, whether system-definedor user-defined, are not lost when a data base is shut down and restarted.andM;System and User Tables.andP;  The system tables contain the schema for the database, and the user tables and input areas contain the user's applicationdata.andP;  The relationship between these data structures is shown in Fig.andP;  9.andO;There are four types of system tables:andM;* Table System Table.andP;  The table system table contains information on all theuser tables and system tables in the data base including itself.andP;  One sectionof the table describes system tables and another section describes usertables.andP;  Each tuple in the table system table describes one table, and thecolumns contain relevant information about the attributes of the tabledescribed by the tuple (e.g., table name, tuple length, number of columns,and so on).andP;  Fig.andP;  10 shows a portion of a tuple in the table system tablefor a user table (Usertbl02).andP;  The entry CSTtid is the tuple identifier forthe starting tuple in the column system table assigned to Usertbl02, and theentry ISTtid is the tuple indentifier for the starting tuple in the indexsystem table assigned to Usertbl02.andP;  The entry FstBlkOff is an offset inbytes to the first block of storage for Usertbl02.andP;   When the user adds ordeletes a table, the table system table is updated accordingly.andP;  Likewise,when certain changes (e.g., add indexes) are made to the user table thesechanges are reflected in the associated tuple in the table system table.andM;* Column System Table.andP;  The column system table contains information on allcolumns in a user table.andP;  Each tuple describes one column in a user table.andO;Some of the information kept in the column system table includes column type,length, and offset for each user table column.andP;  This same information is keptin the column descriptor array of the user table control block describedearlier.andP;  The reason for having this data in two places is that it eliminatesone level of indirection when accessing data in user table columns.andP;  A newtuple is added to the column system table when a new column is added to auser table.andM;* Index System Table.andP;  The index system table contains information on theindexes for system and user tables.andP;  Each tuple in the index system tabledescribes an index defined on a system or user table.andP;  Indexes on systemtables are predefined by HP RTDB and indexes on user tables are defined onlyby the user.andP;  Indexes are described in more detail later in this article.andM;* Input Area System Table.andP;  The input area system table contains informationon user-defined input areas.andP;  Each tuple contains the input area name, theinput area size, and the offset (in bytes) of the beginning storage locationallocated to the input area.andM;Indexes.andP;  Indexes are defined on tables to provide faster access to a datatuple.andP;  HP RTDB provides hash indexing.andP;  Fig.andP;  11 shows the organization ofthe hash indexing scheme employed in HP RTDB.andP;  In this scheme a key value,which is composed of one or more columns in a table, is sent to a hashfunction that computes a pointer into a table of tuple identifiers.andP;  Once thetuple identifier is known, the desired tuple can be accessed.andM;The columns that are used for the key value are designated in the indexsystem table described earlier.andP;  Fig.andP;  12 shows the relationship between theindex system table and the columns in a user table designated for key values.andO;These columns are specified when an index is defined for a table.andP;  In manyhashing schemes the hashing function transforms a key value into a storageaddress where the user's data is stored.andP;  HP RTDB does not use hashing forboth storage and retrieval of tuples, but only as a very fast retrievalmechanism.andM;The process of inserting a new tuple into a table with a hash index takes thefollowing steps:andM;* The tuple is inserted in the first available slot in the user table withoutregard to any index defined on the table.andM;* A location is found in the index table by applying the hash function to thekey value of the tuple.andP;  This location is called the primary location for thetuple.andP;  If the hash function returns a primary location that is already inuse, a secondary location is found and linked to the primary location using asynonym chain.andM;* The tuple identifier of the inserted tuple is stored in the designatedprimary (or secondary) location in the index table.andM;The process of retrieving an existing tuple from a table using the tuple'skey value takes the following steps:andM;* The hash function is applied to the key value to obtain the primarylocation for the corresponding tuple identifier in the index table.andM;* If the primary location has no synonyms, the tuple addressed by the tupleidentifier in the primary location is accessed and returned.andM;* If synonyms exist, then each one is accessed in turn until one is foundwith a key value that matches the unhashed key value of the requested tuple.andO;If the hash index is defined with the option to allow duplicate key values,then each tuple with a matching key value will be returned in the orderfound.andM;Independence of retrieval from storage provides HP RTDB with some majoradvantages:andM;* Multiple hash indexes.andP;  Each table can have multiple hash indexes definedfor it, allowing the same table to be searched with any number of differentkeys as shown in Fig.andP;  12.andM;* Constant tuple identifiers.andP;  A hash index can be rehashed without causingany data migration (the data tuple locations do not change).andP;  This means thatapplications can use direct access by tuple identifier and never by concernedthat rehashing might cause a tuple identifier to change.andP;  This feature alsosignificantly improves the performance of applications that frequently updatetable columns used for key values.andM;* Dynamic hash index definition.andP;  Unlike direct hashing algorithms, hashindexes can be added to or removed from existing tables.andM;* Fixed space overhead.andP;  The space overhead incurred because of defining ahash index is a direct function of the number of tuples in a table and doesnot depend on the number of columns, so it does not increase as new columnsare added to a table.andM;However, no matter how carefully a hash function is designed, it cannotguarantee that collisions will not occur when the function is applied todiverse and unpredictable sets of keys.andP;  Therefore, when a collision doesoccur, there must be a means of specifying an alternate location in the indextable where the new tuple identifier can be stored.andP;  HP RTDB uses a form ofseparate chaining in which each hash index consists of two segments, aprimary segment and a secondary segment (see Fig.andP;  13).andM;The primary segment contains the tuple identifiers of all keys that hash toan unused primary location.andP;  To reduce the probability of collisions, thenumber of locations in the primary segment can be configured by the user tobe more than the maximum number of tuples in the data table.andP;  For example, ifthe number of primary segment locations is 1.25 times the number of tuples inthe data table (primary ratio), then the load factor (packing density) ofeach primary segment cannot exceed 80 percent.andP;  When this means is that for atable with eight tuples the number of primary segments is 10 (1.25 X 8), andif there are no collisions, at most eight of the tuples in the primarysegment will be occupied.andP;  A higher primary ratio will reduce the probabilityof collisions but will increase the primary segment size.andP;  Users can adjusteach index's primary ratio to achieve the best performance and minimum memoryconsumption.andM;The secondary segment contains the tuple identifiers of all data values thehash to a primary location that is already in use.andP;  This segment provides aseparate overflow area for secondary enttries (synonyms), thus eliminatingthe problem of migrating secondaries (existing synonyms that must be moved tomake room for a new primary entry).andP;  The secondary segment is allocated basedupon the number of tuples in the data table and is guaranteed to be largeenough for even a worst-case index distribution.andP;  After a collision occurs ata location in the primary segment, the primary location becomes the head of alinked-list synonym chain for all secondaries that hash to the primarylocation.andM;Input Areas.andP;  Input data in a real-time environment may be expected orunsolicited, and can arrive in streams, small packets, or large bursts.andP;  Thisdata may also involve complex synchronization of processes to handle thedata.andP;  In all cases, there is a need to respond to the arrival of the newdata within a predictable time before it is too old to be of value, or isoverwritten by the next arrival.andM;Input areas provide highly efficient buffering for receiving and storingunstructured data into the data base.andP;  Users can configure a data base withany number of input areas of any size up to the limits of available sharedmemory.andP;  Values in input areas can be read or updated either using offsets ina named input area or, for even higher performance, using an input area'sactual address as if it were a local array variable.andP;  Like tables, inputareas can be explicitly locked and unlocked for control of concurrent access.andM;Data AccessandM;Traditional data base transactions are not supported in HP RTDB because eachaccess to the data base is considered a transaction, and each access isguaranteed to be serialized and atomic.andP;  However, a system designer can stilldefine and implement an application transaction as a set of two or more database accesses, which will complete or fail as a group.andM;The general data access flow in HP RTDB is shown in Fig.andP;  14.andP;  The sequenceof events to access the data base to update a tuple would be:andM;* Obtain the address of the main control block using the session identifier(SessID).andP;  The session identifier is returned to the user when the data baseis opened and is used in subsequent calls to access the data base.andM;* Obtain the address of the table system table from the main control block,and using the table identifier (TblTid) obtain the tuple of the user tablefrom the table system table.andP;  The user is given a table identifier when thetable is opened.andM;* Obtain the entries in the locks-held and semaphore control blocks and lockthe user table.andP;  The addresses for these entries are obtained from the maincontrol block.andM;* Finally, obtain access to the tuple in the user table using the user tableaddress obtained from the table system table and the tuple identifier (tid).andM;This process is the same for input areas, except that the input area systemtable is accessed rather than the table system table, and the input areaoffset is used instead of the tuple identifier.andM;Performance tests to assess the data access performance characteristics ofthe HP Real-Time Data Base routines were run on an HP 9000 Model 825.andP;  Thebenchmark for these tests consisted of 56-byte tuples.andP;  During the tests,shared memory was locked into physical memory.andP;  The results of theseperformance tests are summarized in Fig.andP;  15.andM;Table Access.andP;  There are three methods of locating tuples in user tables.andO;Tuples can be read using sequential access, hashed key index access, ordirect tuple identifier access.andP;   However, updates and deletions of tuplescan only be done by direct tuple identifier access.andP;  This means that toupdate or delete a tuple, it must first be located by one of the three readaccess methods.andP;  Sequential access starts at the beginning of a table andreturns each tuple in the order in which it is encountered.andP;  Since tuples canbe inserted or deleted at any location, the physical order of tuples in anactive table is unpredictable.andP;  The user can set up search conditions forsequential searching, such as the number of comparisons, columns to use,comparison operator (e.g., EQ, NE, etc.), and ASCII type (e.g., hexadecimal,octal, etc.).andP;  If the search conditions are specified, then only those tuplesthat meet the conditions are returned.andP;  Sequential access is the slowest modeof access, but for very small tables of 10 to 15 tuples, the speed ofsequential searching is comparable with indexed searching.andP;  Sequential accessis most appropriate for serially processing most or all of a table's data,since it does not use additional memory for index tables.andM;Indexed access, which uses the indirect hashing technique discussed earlier,is much faster than sequential access, but still slower than direct access bytuple identifiers.andP;  Index keys can consist of up to five contiguous ornoncontiguous table columns of mixed data types and any number of indexes canbe defined for a single table.andP;  Although there is no hard limit as to howmany indexes can be defined for a table, each index requires additionalmemory for index tables and additional processing time to create or updateeach index key defined.andP;  Indexed access is best for applications that needfast, unordered access to data and that mainly perform reads and updatesrather than insertions and deletions.andM;The HP RTDB tuple update routine allows three alternative courses of actionwhen columns that make up an index key value are about to be updated.andP;  Oneoption specifies that the indexes should be modified (that is, rehashed) toreflect the update.andP;  A second option is to deny the update and return anerror when an index key value is about to be changed.andP;  For top performance,there is an option to update a tuple and bypass checking for indexmodification.andP;  This option should only be used if the user's application canensure that a tuple's index key values are never changed after its initialinsertion into a table.andM;Direct access by tuple identifier is by far the fastest form of access.andP;  Atuple's tuple identifier is returned when it is first added to a table andalso when the tuple is accessed by a sequential or indexed search.andP;  Thereturned tuple identifier can then be used to update, delete, or reread thesame tuple directly any number of times since tuple identifiers do notchange, even when a table is rehashed.andP;  This feature offers spectacularbenefits when a small set of tuples is repeatedly accessed.andP;  The tupleidentifier can be obtained once, stored internally, and then used to accessthe same tuples directly in all subsequent operations.andM;Input Area Access.andP;  Data in input areas can only be read or updated.andP;  Sinceinput areas are usually updated by being overwritten with new input data, HPRTDB does not provide separate routines for deleting and inserting dataelements in input areas.andP;  Nor are these functions really needed, sinceupdating an element to a null or non-null value accomplishes the same end.andM;Since the structure and content of input areas are application dependent andcan change at any time, HP RTDB does not try to map input areas as it doestables.andP;  Data elements in input areas are accessed by naming the input areaand specifying the element's offset and length, HP RTDB then locates thestart of the input area, adds the offset, and reads or updates the selecteddata element.andP;  For maximum performance, the input area may optionally beaddressed directly as if it were a local array, but this access mode bypassesHP RTDB's address validity checking and concurrency control mechanisms andshould only be used if the extra performance is critical.andP;  The applicationmust then ensure correct addressing to avoid data base corruption.andM;Users can also associate a table column with an input area data element bydefining the column's data type as a pointer to an input area and thenassigning the data element's offset as the column's value.andP;  The input areaoffsets shown in Fig.andP;  8 are input area pointer types.andM;Configuration and CreationandM;Much effort was made to keep the process of configuring and creating a database as simple and flexible as possible.andP;  The final definition of data baseobjects intended for future implementation can be deferred until they areactually needed, and other data base objects can be added and/or removedafter the data base is created.andP;  Also, all data base configuration andmaintenance functions can be done with the interactive HP RTDB query/debugcommands as well as by calling HP RTDB subroutines.andP;  This allows users toprototype and test data base designs without writing a single line of programcode.andM;Defining the Data Base Schema.andP;  The first step in creating an HP RTDB database is to define the system limits of the data base, that is, the data basename, the configuration file name, the maximum number of tables, input areas,indexes, columns, and sessions that will be accommodated by the data base atany time.andP;  The user may choose to defer the actual definition of some database objects until a later time, but must inform HP RTDB of how many of eachobject may eventually be defined.andP;  This information is used to ensure thatthe system tables and control structures for the data base are as large asthe maximum requested.andP;  Preallocation of continuous storage for the maximumsize of the data base objects instead of allocating on an as-needed basiseliminates the overhead of checking for available space when adding tuples toa table.andP;  It also eliminates the overhead associated with dynamicallyallocating and deallocating blocks in a multiuser environment.andM;When the system limits are defined, a skeleted schema and control structuresare generated in shared memory and saved on disc in the configuration file.andO;At this point the data base schema can be filled out with the definition ofuser tables, columns, input areas, and indexes either through query/debugcommands or by calls to the HP RTDB subroutines (MdDefTbl, MdDefCol, MdDeflx,and MdDeflA).andP;  As these other data base objects are defined, the informationabout them is entered into the system tables and the schema grows morecomplex.andP;  However, no storage is allocated for newly defined data baseobjects until the data base is built.andP;  The user can at any time save a copyof the current memory-resident schema to the configuration file.andP;  When thedata base is fully operational and contains data, the data as well as theschema can be saved in the same file.andM;Building a Data Base in Memory.andP;  Once the system limits of the data base areset and the schema defined, the data base can be built.andP;  First, the schemamust be loaded into memory.andP;  The schema will already be in memory if the database is newly defined.andP;  Otherwise, the schema file on disc is opened andloaded into memory (MdOpenDb).andP;  Using the memory-resident schema data, the HPRTDB build routine (MdBuildDb) allocates shared memory to each data baseobject builds and initializes any data or control structures associated withthe objects, and sets up the logical links between the structures.andP;  HP RTDBalso provides routines to calculate the minimum memory needed to build thedata base from the schema.andP;  Additional memory may optionally be allocated toallow for future implementation of data base objects that are not yet definedin the schema.andP;  After a data base is built, it is ready to be initializedwith application data.andM;Locking and Concurrency ControlandM;There are three components to the synchronization of concurrent access to adata base: session management, lock management, and semaphore management.andP;  Aseach new user process opens the data base, HP RTDB allocates a sessioncontrol block for the new process and the process becomes attached to thedata base.andP;  A session identifier is returned to the process for use insubsequent calls to access the data base, and the session control block isfilled with information about the process such as the HP-UX processidentifier (pid) and user identifier (uid).andP;  The session identifier is usedto index into the locks-held table.andP;  With this and other data the sessionmanager is able to perform its role in controlling concurrent access to thedata base.andM;Locking in HP RTDB is provided only at the table and input area level ratherthan at the tuple and data item level.andP;  This coarse granularity of locking isacceptable because in a memory-resident data base, locks are normally heldfor very short periods of time.andP;  Each object (user table and input area) inthe data base is owned by a specific semaphore.andP;  Locking of data base objectsis accomplished by acquiring the object's semaphore and associating it withthe process's session identifier.andP;  The lock is released by freeing thesemaphore and breaking the link between the semaphore and the sessionidentifier.andM;HP RTDB controls the locking and unlocking of semaphores, but all queuing andrescheduling of blocked processes is handled by the HP-UX operating system.andO;This gives HP RTDB a simple, efficient, and reliable concurrency controlmechanism that is guaranteed to be compatible with other HP-UX features.andP;  Forexample, a user could easily integrate HP RTDB and the HP real-time extensionfeatures to implement real-time priorities in an application.andP;  HP real-timeextensions are additions to HP-UX that allow users to set high priorities forcertain processes.andM;If the application does not explicitly lock a data base object before tryingto access it, the HP RTDB routine called to do the access will normally applyan implicit lock of the object by default.andP;  There are options to allow usersto read and write through locks, but these options may compromise theintegrity of the data base and should be used with caution when higherperformance is critical.andP;  A read-through lock allows a high-priority processto access data in the data base that may be in the process of being updatedby another process.andM;SecurityandM;HP RTDB provides three levels of security through the use of passwords.andP;  Apassword is required to access the data base.andP;  The password level, which canbe data base administrator, read-write, or read-only, determines the user'saccess authorization.andP;  The data base administrator password allows a userprocess to perform any operation on the data base supported by HP RTDBsubroutines or by the query/debug commands.andP;  the read-write password allows auser process to read, modify, and delete data in the data base, but not toperform any of the data base definition functions, such as adding or removinga table or index.andP;  The read-only password allows a user only to read data inthe data base, but not to delete or modify data, or perform any data basedefinition functions.andM;In addition to the password security, the data base administrator (or theroot user) can also alter the access permissions of the schema file on discor the data base's shared memory segment to limit access to the data base.andM;Backup and RecoveryandM;Memory-resident data bases are particularly vulnerable to power failures andoperating system failures because both types of failures usually destroy thecontents of main memory.andP;  Battery backup power systems can provide excellentprotection against power failures, but system failures pose a problem thatreally has no good solution.andM;The traditional backup methodology of logging all changes to a disc filecannot be used if high performance is desired; yet there is no other way tokeep a secure backup with close parallel to the state of memory.andP;  HP RTDBprovides a &quot;snapshot&quot; backup which allows each application to choose anacceptable trade-off between performance and secure backup.andM;At any time, the application can call an HP RTDB routine to save an image ofthe data base schema or the schema and data to a disc file.andP;  For a data baseof 34,000 bytes consisting of 6 tables and 2 input areas, a single snapshottakes about 0.5 second on an HP 9000 Series 825.andP;  Snapshots can be taken asoften or as rarely as the user application chooses, and can be triggeredperiodically or by specific events.andP;  Users who can afford the overhead cantake more frequent backups while users who require top performance may rarelyor never take a backup.andP;  In some real-time applications, there is littlepoint in taking a backup since the data would be obsolete long before thesystem could be restarted.andP;  Data base recovery is also very fast but a database can only be recovered to the point where the last snapshot was taken.andO;either the schema or the schema and the data can be recovered.andP;  Recovery ofthe schema only would create an empty data base which could then bereinitialized with data by the application.andM;Query/Debug UtilityandM;The query/debug utility is included as part of the HP Real-Time Data Basesoftware to provide real-time application developers with a tool to:andM;* Assist with prototyping, testing, and debugging applicationsandM;* Create, modify, and maintain HP RTDB data bases in both development andproduction environmentsandM;* Use as a simple and flexible HP-UX filter, which when combined with otherHP-UX commands and utilities, can provide useful application functions to HPRTDB users without the need for additional code.andM;The query/debug utility supports nearly all of the functionality of the HPRTDB subroutines.andP;  However, it is highly generalized and is designed to besafe and friendly rather than fast.andP;  Therefore, most query/debug functionsare significantly slower to execute than equivalent subroutine calls.andM;The query/debug command syntax is modelled after the Structured QueryLanguage (SQL), an ANSI industry-standard relational interface.andP;  Thisresemblance to SQL is intended only to make it easier for users who arealready familiar with SQL.andP;  The query/debug utility is not intended tosupport the SQL standards of inquiry or reporting functionality.andM;The query/debug utility was designed as an HP-UX filter and conforms to theconventions for filters in its use of HP-UX input/output files stdin, stdout,and stderr.andP;  This allows it to be used with input and output redirection,pipes, and so on.andP;  Output can optionally be produced without headings toenable clean output data to be piped directly into other filters oruser-written programs.andM;Query/debug commands can be entered interactively for ad hoc work, or can beread from ordinary disc files for repetitive tasks.andP;  For example, thecommands to define and initialize a data base could be saved in a disc fileto ensure that the data base is always recreated the same way.andP;  Likewise,simple reports can be generated using query/debug command files or bycombining query/debug command files with HP-UX shell scripts and utilities.andM;The query/debug commands provide the following functionality:andM;* Define, reconfigure, build, remove, and back up a data baseandM;* Change passwords and shared memory security permissionsandM;* Initialize table and input area values in a new data baseandM;* Display data base configuration and status informationandM;* Generic add delete, update, and select of tuple values based upon indexedor sequential searchesandM;* Display or print all or selected data from all or selected tuples in atable in either tabular or list formatandM;* Generic update, select, and display of input area valuesandM;* Load or store data base values from or to disc filesandM;* Debugging aids such as hexadecimal data display, a &quot;peek&quot; function, and anerror trace option for tracing all errors that may occur during anyquery/debug processing of the user's data baseandM;* On-line help facility for all query/debug commandsandM;* Built-in octal, decimal, and hexadecimal integer calculatorandM;* Execution of HP-UX commands without leaving query/debug.andM;ConclusionandM;The goal of a high-performance data base drove many of the design decisionand implementation techniques for HP Real-Time Data Base.andP;  The performancegoals were met and exceeded with simple data structures (tables and inputareas), programming techniques such as macros, and options that allow usersto eliminate features that affect performance.andP;  The result is a set ofroutines that enables real-time application developers to create custom databases for capturing and retrieving the diverse data structures found inreal-time environments.andM;AcknowledgmentsandM;The authors wish to thank Marie-Anne Neimat, Ming-Chien Shan, and Bob Pricefor their assistance in the design of RTDB, and Mark Butler for his directionin the creation of RTDB.andO;</TEXT></DOC>