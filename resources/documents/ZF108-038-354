<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-038-354  </DOCNO><DOCID>08 038 354.andM;</DOCID><JOURNAL>Dr. Dobb's Journal  Winter 1989 v14 n159 p8(9)* Full Text COPYRIGHT Mandamp;T Publishing 1989.andM;</JOURNAL><TITLE>From C to C+: Interviews with Dennis Ritchie and BjarneStroustrup. (interview)</TITLE><AUTHOR>Stevens, Al.andM;</AUTHOR><SUMMARY>Dennis Ritchie and Bjarne Stroustrup discuss their respectiveroles in the development of the C programming language, the Unixoperating system and the object-oriented extension to C known asC++.andP;  Ritchie discusses problems encountered in the ANSIstandardization process, such as facility design and aliasing, aswell as such problems as the nature of the const function and thestandardization of input-output routines.andP;  He stresses that C is alow level language that deals with single-dimension arrays andbasic tasks, and does not feel that it was designed to be ateaching language.andP;  Stroustrup traces the design of C++ to hisgoal of building greater modularity into distributed systems.andP;  Hediscusses the portability problem and the impending development ofC++ compilers.andP;  He also gives his views on Concurrent C and otherparallel processing operations, as well as the possibilities ofperformance analysis.andM;</SUMMARY><DESCRIPT>Topic:     InterviewUNIXC Programming LanguageNetwork Operating SystemsSoftware EngineeringSource CodeStandardizationObject-Oriented ProgrammingObject-Oriented Languages.andO;Feature:   illustrationportrait.andO;Caption:   Dennis Ritchie. (portrait)Bjarne Stroustrup. (portrait)Person:    Ritchie, Dennis (attitudes); Stroustrup, Bjarne (attitudes).andM;</DESCRIPT><TEXT>From C to C++andM;Dennis Ritchie is the designer of the C language and is the &quot;R&quot; in Kandamp;R, thenickname for The C Programming Language, co-authored by Brian Kernighan.andP;  Heis a member of the Computing Science Research Center at ATandamp;T BellLaboratories in Murray Hill, New Jersey.andM;Dennis did his undergraduate and graduate work in physics and appliedmathematics at Harvard University.andP;  Since joining Bell Lab's Computer ScienceResearch Center in 1968, he has worked on the design of computer languagesand oerating systems.andP;  Along with others at Bell Labs, Dennis created theUnix operating system, and designed and implemented the C language.andP;  Hiscurrent research is concerned with the structure of operating systems.andM;DDJ: As the designer of the c language, you are no doubt the world's veryfirst C programmer in a world where the number of C programmers isinestimable and growing fast.andP;  Yet, certainly C was not your first language.andO;When did your programming career begin and with what systems?andM;DR: I started when I was in college in 1961.andP;  I was a physics major.andP;  Therewas no  so much thing as a Computer Sciences curriculum then.andP;  The CompCenter at Harvard offered an informal course in programming on the Univac I,and I went to the IBM office and got manuals.andP;  In graduate school in 1963 Iwas the teaching fellow for the introductory programming course.andP;  For a whileI worked at Project MAC at MIT.andP;  My graduate work was theoretical inrecursive function theory.andP;  I lost interest in that aspect of things when Ifinished there, and I've been spending most of my time programming eversince.andM;DDJ: do you actively program now?andM;DR: It depends what you mean by programming.andP;  There's a fair amount oflooking at stuff and deciding how it should work.andP;  These days there's morebureaucratic stuff.andP;  I'm not in management, but I write memos, look atproposals, complain to the X3J11 C committee, and things like that.andP;  I'mdefinitely still involved in the technical aspects of things.andM;DDJ: The ANSI X3J11 committee has been five-plus years in arriving at aproposed standard for the C language.andP;  How long did it take you from the timeyou had your original idea for a C language until you had the first compilerrunning?andM;DR: The C language grew out of an earlier language.andP;  The syntax of the earlyC language was essentially that of B.andP;  Over the period of a couple of yearsit grew into something like its current form.andP;  The most significant milestonein the growth of the language was when the Unix system was rewritten in C.andM;DDJ: How long did that take?andM;DR: Mostly it was done in the summer.andP;  There were two tries at it.andP;  This wasin 1973.andP;  The summer before, Ken Thompson tried to do it, and gave up.andP;  Thesingle thing that made the difference was the addition of structures to thelanguage.andP;  When he first tried there were no structures.andP;  They were in by thenext summer, and this provided a way of encapsulating or describing the datastructures within the operating system.andP;  Without that it was too much of amess.andM;DDJ: You mentioned complaining to the ANSI X3J11 C committee.andP;  What was theextent of your participation in the development of the ANSI C standard?andM;DR: My participation in the committee was really quite minimal.andP;  i sent thema couple of letters.andP;  One was to point out the consequences and difficultiesof the path they were taking with the new style function definitions anddeclarations.andP;  It's clear that the new style -- function prototypes, as theycall them -- is a good thing.andP;  The language is better for having it, and itshould have been done that way the first time.andP;  The problem, however, is inthe interval before prototypes are universally accepted, while you still havebot the old ad new styles.andP;  I pointed out that with that approach there willbe confusion and the possibility of errors.andP;  For example, if you think thatthere's prototype in scope, you might call the function and expect that thearguments are going to be coerced as they would be in regular ANSI C.andP;  But itmight not happen.andM;DDJ: In the Raionale document, X3J11 has paved the way to eventually do awaywith the old style of function declaration and definitions.andP;  Will that solvthe problem?andM;DR: Yes, but in this interval there is a sticky situation.andP;  There arecomplicated rules for what happens when you mix the new and old styles.andP;  Theycovered all the bases when they made the rules, but the rules are messy, andmost people couldn't reproduce them or explain what they mean.andP;  The letter Iwrote was to suggest than maybe they should think about not doing it if onlybecause it's too late, or as an alternative they should consider requiring anANSI compiler to have the new style only.andM;My second letter was related to this &quot;no alias&quot; business that came up about ayear and a half ago.andP;  I felt more strongly about this isued because I feltthey were about to make a bad mistake, and I was willing to spend a lot oftime getting them to reverse it.andM;Around December 1987, when they were intending to produce the penultimatedraft, the one that had all the technical things in it (with possibly somelanguage polishing needed, but nothing important), something that had beensimmering a long time came to the boil.andP;  Some people wanted to put in amechanism that would reduce the problems that optimizers have with aliasing.andM;Here's the problem.andP;  Suppose you have a single function that has two pointersas arguments, and the function can never be sure that the pointers might notpoint to the same thing.andP;  Or, suppose one of the pointers points to someexternal place.andP;  The function cannot tell where the pointers are going toclash.andP;  According to the language rules, this kind of thing is possible, andoptimizers have to be very conservative about it.andP;  In most functions it mightnever happen, and so the conservative compiler will generate worse code thanit would otherwise.andP;  Languages such as Fortran have an easier job of thisbecause such aliasing is simply forbidden.andP;  There's no enforcement, ofcourse, but the compiler can take an optimistic point of view.andP;  If yourprogram doesn't work, someone can pull out the standard and say you shouldn'thave done that.andP;  Aliasing was a plausible thing for the committee to thinkabout.andP;  It does, in fact, make C somewhat harder to optimize.andP;  The mistakethey made was in trying to design a facility to allow the programmer say thata particular function has no aliasing problem.andP;  But they actually blew it.andO;The language rules that they developed, even after many sessions of hardwork, really just weren't correct.andP;  Their specification for how you say &quot;noalias&quot; was broken and would have been much more dangerous than not having it.andO;If this had happened three or four years ago, people would have seen thatthis was wrong, fiddled with it, and either thrown it out or fixed it one wayor the other.andP;  But this was supposed to be the next to the last draft, andall the technical requirements were supposed to be aleady done, and it wasjust broken.andM;That December 1 drafted a long and strongly worded letter to them saying thatthis just won't do, and pointed out the problems that I'd found.andP;  I even wentto the meeting, the first X3J11 meeting I'd been to, and argued against it.andO;What got me worried and annoyed was that this had happened when it did.andP;  Ifthe thing had gone ahead it would have been a real bug in the specification.andO;On the other hand, fixing it essentially meant a technical change, animportant, non-editorial change, and they would need another long publicreview period.andP;  The point of view that I advanced was to get rid of it.andP;  Ifigured that my argument had to be simple to understand.andP;  If I had said,&quot;This 'no alias' is broken, here's another thing that you should do instead,&quot;I could see us getting bogged down endlessly worrying about the technicaldetails, so I figured it was better to argue that they should just throw itout altogether.andM;That was the only really detailed involvement I had with X3J11.andP;  The outcomewas that there is no specification for &quot;no alias.&quot;andP;  They voted it out.andO;Except for some slight fiddles, the draft that is now before X3 istechnically identical to what it was nearly two years ago.andM;Aside from those two issues, I left them alone for two reasons.andP;  One is thatto take part in a standardization effort is an enormous amount of work.andO;There are three one-week meetings a year all over the world, a lot ofdetailed reading, and I really didn't have the heart to do that.andP;  The secondreason is that it became clear elary in the proceedings that the committeewas on the right track themselves.andP;  Their character was to codify and tostandardize the language as it existed.andP;  They decided in advance to do thatand that is what they did.andP;  They did add some new things.andP;  The functionprototypes are by far the most obvious, and there are a lot more minorthings, but mainly they stuck to their charter.andM;I think they did a very good job, particularly when compared to the thingsthat are happenning in the Fortran comittee, X3j3, where there are wideswings back and forth about the strange new things they're adding in, takingout, and putting back in.andP;  They have great political arguments betweencustomers and vendors, Europeans versus North Americans, and it really seemsto be a free-for-all.andP;  Even though some wrangling went on in the C committee,with the people involved seeming fairly fierce when you looked at it fromoutside, it's obvious that X3J11 was a comparatively tranquil and technicallywise group.andM;The upshot is that I think they did a good job.andP;  Certainly, though, if I'dcontinued to work on things, some of the details would have been different.andM;DDJ: Are there any major areas where you disagree with the standard as itexists now?andM;DR: There are some obvious weaknesses.andP;  For example, they have never workedout what const really means.andP;  One of its intents is to say that this is somedata that can be put into some read-only storage because it's never going tobe modified.andP;  The definition that they have now is sufficient for that.andP;  Butthey also had other ideas about what it should mean, having to do withoptimization, for example.andP;  The hope was that const is somehow a promise thatthe compiler could assume that the data item wouldn't change underfoot.andM;If you have a pointer to a const, one might hope that what is const is notgoing to suddently change secretly.andP;  But, unfortunately, the way the rulesread that's not actually true.andP;  It can change, and this wasn't just anoversight.andP;  In fact, they are potentially overloading the meaning of const.andO;There are ideas involved other than what people hoped to get, and they neverreally worked out exactly which ones they wanted and which ones they didn'twant.andP;  It's a little confusing.andM;It's generally recognized that the standardization of the library was asimportant as the standardization of the language.andP;  Among Unix systems thereare few variations on what's available in the library.andP;  Most things arepretty much the same.andP;  In recent years, the use of C has spread far outsideof Unix systems, and the libraries supplied with compilers tend to vary alot, although many of them were based on what was available on Unix.andP;  So thestandardization of the library is important.andP;  On the other hand, I've heardlots of complaints, both from users and implementors, that what theystandardized and some of the rules and interfaces for library routines werenot very well worked out.andP;  There may be more there than is necessary.andP;  Thingsgot too complicated.andM;DDJ: What was the rationale behind the decision to leave out the read, write,open, close, and create functions?andM;DR: Those functions are viewed as being quite specific to the Unix system.andO;Other operating systems might have great difficulty in supplying things thatwork the same way those do.andP;  The idea of the original pre-ANSI standard I/Olibrary was to make it possible to implement those I/O routines in a varietyof operating systems.andP;  It took us a couple of tries to reach that particularinterface.andP;  The machines we had here were the PDP-11 running Unix, aHoneywell 6000 running GECOS, and some IBM 360s running variuos IBM systems.andO;We wanted to have standard I/O routines that could be used in all theoperating systems, even those that didn't have anything like Unix's read andwrite.andP;  The committee felt that it was better to let the IEEE and other Unixstandardization groups handle that.andP;  They specifically avoided putting thingsin the C library that were Unix-specific unless they had meaning in othersystems.andM;They did another thing that people don't quite understand.andP;  They explicitlylaid out the name space that a standard compiler is allowed to usurp orclaim.andP;  In particular, the guarantee is that there is a finite list of namesthat the compiler and the compiler system take up.andP;  These are simple names,beginning with underscore, and are listed in the back of the standard,something like keywords.andP;  You are allowed to use any name that isn't on thislist.andP;  In an ANSI-conforming world, you are allowed to define your ownroutine called read or write and even run it on a Unix system.andP;  It'sguaranteed that this will be your routine and that your use of the name doesnot conflict with any I/O that the library itself does on your behalf.andP;  TheUnix library authors will be constrained to have an internal name for readthat you can't see so that if you bring a C implementation from a big IBMmachine or from an MS-DOS machine and you happen to use the name read foryour own routine, it will still compile and run on a Unix system even thoughthere's a system call named read.andP;  They have circumscribed the so-called namespace pollution by saying that the system takes these names and no others.andM;DDJ: How can they be sure that an implementor won't need other than thosespecific names from the list?andM;DR: There are rules for how the internal people can generate names, namelythese underscore conventions.andP;  The end user is not allowed to use underscorenames because any of these might be used internally.andP;  There is a problem,though.andP;  They made a list of things and said they'll do this and no more, andthat helps.andP;  But there is still a problem for the writer of a ilbrary whowants to sell or distribute it.andP;  You're in a bind because you don't know allthe underscore names that all the implementations are going to use.andP;  If youhave your own internal names, you can't be sure that they're not going toconflict somewhere.andP;  If they have underscores, they might conflict with theunderlying implementation.andP;  If they don't, then they might conflict withthings that your end users are going to use.andP;  The C committee did not solvethe problem that other languages have tackled explicitly.andP;  There are otherways of controlling the name space problem.andP;  They made a convention thathelps, but it certainly didn't solve the real problem.andP;  It solved it enoughto improve the situation.andP;  The basic problem with an uncontrolled name spaceis that if you write a program, and it just uses some name that you made up,it may be actually difficult to find out that this is not the same name assome random routine that's used internally by your system library.andO;Unfortunately, we here at Bell Labs are in a bad position to notice this anddo something about it because in our group we've simultaneously developed thecompiler and the library and the Unix system, and so people here tend to knowthe names.andM;So, to summarize X3J11, the two largest things the committee did werefunction prototypes and the standardization of the library.andP;  It was more workthan anybody expected, but I'm perfectly happy with what they did.andP;  The onlyproblem was it took twice as long as the thought.andM;DDJ: Do you see a potential for other standard extensions to C, beyond thoseadded by X3J11?andM;DR: One of the major excuses they give for not doing something is thatthere's no practice, no prior art.andP;  So obviously people will try to createprior art for the things they'd like to have happen.andP;  One such group is theNumerical C Extensions Group.andM;There are people who have strong views about what should happen.andP;  The idea isto get together with this group and agree that these are the things we needto have, so let's make some rules so that when people try things out, we'llall be trying it the same way, and we'll have a coherent story to tell, ifthere are going to be these extensions.andM;Most of them have to do with IEEE arithmetic issues, exceptions and such, forexample.andP;  There's a core of things that are more general, and one thatinterests me is variable arrays with adjustable sizes.andP;  One of the things Cdoes successfully is deal with single-dimension arrays that can be variablein size, but it doesn't deal with multi-dimensioned arrays that are variableat all.andP;  This is an important lack for numeric types, because it makes ithard to write library routines that manipulate arrays.andP;  Multiplying twoarrays is a bit painful in C if the arrays are variable in size.andP;  You can doit but you have to program it in detail and the interface doesn't lookpleasant.andP;  That's an obvious need, and I volunteered to look at how it mightbe done.andM;The NCEG will probably try to become official.andP;  They will affiliatethemselves either with X3J11 or as an IEEE standardization organization.andO;This would give them more clout.andP;  Also, many of the companies involved worryabout legal issues.andP;  Companies who are members of informal groups decidingstandards worry about anti-trust, whereas if they are members of official,blessed standards organizations, then they can contribute.andP;  They worry aboutbeing accused of going off into a corner and doing things behind otherpeople's backs.andP;  It's better to do it in the open.andP;  This may be just somelawyer's nightmare.andP;  NCEG will probably become a subcommittee of X3J11.andM;DDJ: One non-ANSI extension to C is C++, a superset language that surrounds Cwith disciplines and paradigms that go beyond its original intent as aprocedural language.andP;  Can you comment on how appropriate that is and howsuccessful it has been?andM;DR: Let me confess at the start that I know less about C++ than I probablyshould.andP;  C is a very low-level language on a variety of fronts.andP;  The kinds ofoperations that it performs are quite basic.andP;  The control over names andvisibility is basic.andP;  The defects or limitations of C in this area are mostevident when you get into a large project where you need strong standards,rules, and mechanisms outside the language.andP;  Language developments such asC++ are trying to supply some of the structure within the rules of thelanguage for controlled visibility of name space and are trying to encouragevarious kinds of modularization.andP;  This is good, I suppose.andM;C was designed in an environment where modularity was encouraged not so muchby the language but by the kinds of programs we wrote.andP;  In the Unix system,the tradition is for small utilities that work together as tools, and theinterfaces between them were set by the conventions and rules of theoperating system, i.e., pipelines and so forth.andP;  The complexity of the pieceswas kept low by custom.andP;  Commands tend to be simple.andP;  In the world today,there's a certain amount of admiration for that point of view.andP;  Certainly theappreciation for that style is part of the reason for the growth of Unix.andO;People now are undertaking the building of much bigger systems, and thingsthat we handled by convention ten or fifteen years ago must be handled bymore explicit means.andP;  C++ is one such attempt.andM;Bjarne decided to design a compatible superset of C and to translate the C++language into C code.andP;  That approach is not without its problems.andP;  First,having decided that C++ is going to be largely compatible with C, every timehe departs from that he's under pressure either because of some accident orbecause ANSI changed something.andP;  Or because he feels that there's somethinghe has to differ in, people are going to complain and get confused.andP;  Second,he is constrained by the choice to make a C++ to C translator possible, thatis, he is constrained, as C was, by the existing tools of the varioussystems.andP;  The whole separate compilation business in C++ is made a lot harderby the desire to make it work with existing tools.andP;  If he could have simplydesigned a language and implemented it, then a lot of the anguish would havebeen avoided.andM;DDJ: Rumor is that within Bell Labs, C++ is now called C, and C is called&quot;old C.&quot;andP;  Any truth in that?andM;DR: I've asked Bjarne not to say &quot;old C,&quot; and, as far as I know, he hascomplied with that request.andM;DDJ: Colleges and universities have started offering courses in C.andP;  Some Ctutors have observed that many instructors either don't understand C wellenough or they don't understand teaching well enough to insulate the novicestudent from the kinds of things you can do in C, things that the studentcannot grasp.andP;  In light of that, and as compared to Pascal, how do you view Cas a potential teaching language?andM;DR: Obviuosly, C was never designed to be a teaching language.andP;  It wasdesigned as a tool to express the kind of programs that we were trying towrite at the time.andP;  And it's fairly low level in that concepts, likepointers, have a prominent role.andP;  I would not argue that C is a particularlygood language for teaching programming.andP;  As Pascal was explicitly designedfor that.andM;Pascal's main fault is that you cannot use Pascal originally designed toexpress all the things you need to, certainly not in a systems environment,and not for general applications either because of explicit constraints thatare built into the language.andP;  C was, from the very start, designed to do allthe things that we found necessary in order to express ourselves, and littledesign thought was given to preventing people from using its powerfulfeatures.andM;Nevertheless, it's possible to teach C in a way that's reasonably safe if youstart with parts of the language that are similar to other procedurallanguages.andP;  Then you can teach C's more unusual aspects -- pointers, forexample -- as cliches or set ways of expressing array manipulations and soforth.andP;  Later you can gradually widen out into the more general thingspossible with pointer manipulations.andM;I have not had the experience that the tutors have had.andP;  Part of thedifficulty with being in a position like this is that you have very littleopportunity to see what the novice really feels.andP;  But perhaps the reasonthere are not better instructors is that things have grown fast, and theremight be people teaching C who only recently took the introductory course onthe language themselves.andM;DDJ: Would you attempt a prediction for the future of the C languages?andM;DR: I think the period of C's largest growth is over, although it will beincreasingly used and it probably will not change very fast.andP;  The newlanguage developments based on C will be on successors such as C++ or perhapssome things we haven't heard of.andP;  In terms of what C tried to do, I think itsucceeded fairly well.andP;  The goals were reasonably modest.andP;  There's stillplenty of work to be done finding languages that have the touch of realitythat C has, work where you handle read problems in real environments asopposed to dealing with elegant creations that can't be used.andP;  Sometimesthings can't be used just because the compilers don't exist on the machinespeople have.andP;  Sometimes it's because there are simply flaws in the design,not from the language point of view, but from the point of view of what thelanguage ends up doing in the real world.andP;  And in that respect, C seems tohave worn fairly well.andM;Bjarne Stroustrup is the creator of C++, the object-oriented extension to theC language.andP;  He is a researcher at the ATandamp;T Bell Laboratories ComputingScience Research Center where, in 1980, he began the development of the C++extensions that add data abstraction, class hierarchies, and function andoperator overloading to C.andP;  The C++ language has undergone several versions,and the latest is Version 2.0.andP;  Dr. Stroustrup maintains an active presencein all matters concerning the development, advancement, standardization, anduse of C++.andM;DDJ: Many experts are predicting that C++ will be the next dominant softwaredevelopment platform, that it will essentially replace C.andM;BS: They're not alone.andP;  People were saying that five years ago.andM;DDJ: When you conceived the idea of C++ as an extension to the C language,were you thinking about object-oriented programming in the way it's come tobe known, or were you looking to build a solution to a specific programmingproblem that would be supported by the features that you built into C++?andM;BS: Both.andP;  I had a specific problem.andP;  All good systems come when there is agenuine application in mind.andP;  I had written some simulations of distributedcomputer systems and was thinking about doing more of them.andP;  At the same timeI was thinking about the problem of splitting Unix up to run on many CPUs.andO;In both cases I decided that the problem was building greater modularity toget fire walls in place, and I couldn't do that with C.andP;  I had experiencewith Simula, writing rather complex simulations, so I knew the basictechniques of object-oriented programming and how it applied.andM;To solve the problem I added classes to C that were very much like Simulaclasses.andP;  That, of course, was the solution to a particular problem, but itincluded a fair amount of general knowledge about techniques, thoughts aboutcomplexity and management, complexity of modularity and the all baggage thatyou get from Simula.andP;  Simula is not ad hoc, especially not when it comes tothe class concept, which is what I was interested in.andM;DDJ: Are you familiar with any of the PC ports to C++, specifically ZortechC++, Guidelines C++, and Intek C++?andM;BS: Only from talking to people and listening to discussions about them.andO;They all sound good.andP;  The CFRONT ports, Intek and Guidelines, have theadvantage of having the same bugs advantage of having the same bugs andfeatures that you have on the bigger machines all the way up to the Cray,whereas Zortech has the advantage of being native to the PC world.andM;I walked around back in 1985 explaining why the current implementation of C++couldn't be put on a PC.andP;  I designed the language under the assumption thatyou had one MIPS and one Meg available.andP;  Then one day I got fed up withexplaining why it couldn't be done and did it instead.andP;  It was a pilotimplementation, and it wasn't ever used, but I proved that it was possible,and people went and did the real ports.andP;  All the implementations arereasonably good, and they could all be better.andP;  Given time, they will be.andM;DDJ: Do the PC ports accurately implement C++ the way you have it designed?andM;BS: We do have a problem with portability from one machine to another.andP;  Ifyou have a large program of ten to twenty thousand lines, it's going to takeyou a day to move from one independent implementation to another.andP;  We'reworking on that.andP;  Standardization is beginning.andP;  We're all sharing languagemanual drafts, and so it's trying to pull together.andP;  But a large program portwill still take a day as compared to the ANSI standard ideal where you takesomething from a PC to a Cray and everything works.andP;  Of course, you neverreally get to that point even after full standardization.andM;DDJ: There are lots of rumors about Borland and Microsoft coming out with C++compilers.andP;  Has any of this come to your attention?andM;BS: I've talked to people both from Microsoft and from Borland.andP;  They're bothbuilding a C++ compiler, and it sounds as if they're building it as close tothe 2.0 specification as they jolly well know how to.andP;  Naturally, for theirmachines they'll need something like near and far, which is not standardlanguage, but that's pretty harmless.andM;Both asked for a bit of advice and Microsoft asked for the reference manuals.andO;I've talked to the Borland guys.andP;  I'm sad to say they didn't ask for amanual, but maybe they got one from other sources.andP;  The PC world is prettycut-throat.andP;  Maybe people get the impression everybody is cut throat.andP;  That'snot quite the case.andM;DDJ: One of the advantages of languages such as C and C++ is that they can beimplemented on a wide range of machines ranging from PCs to Crays.andP;  With moreand more people using PCs in their work, it's widely believed that acceptancein the PC world is what spelled the overwhelming success of C as the languageof choice.andM;BS: That's widely believed in the PC world.andP;  In the minicomputer world it'swidely believed that the PDP-11 and the VAX spelled the success of C and thatis why the PC world picked it up.andP;  One of the reasons C was successful isthat it was able to succeed in very diverse environments.andP;  There are enoughlanguages that work in the PC world, enough that work in the minicomputerworld, enough that work on the large machines.andP;  There were not very manylanguages that worked on all of them, and C was one of them.andP;  That's a majorfactor.andP;  People like to have their programs run everywhere without too manychanges, and that's a feature of C.andP;  And it's a feature of C++.andM;DDJ: Do you see the PC as figuring as prominently in the acceptance of C++?andM;BS: Definitely.andP;  There are probably as many C++ users on PCs as on biggersystems.andP;  Most likely the number of PC users will be growing the fastestbecause the machines are smaller.andP;  People who would never use a PC for theirprofessional work -- there are still a lot of those -- nevertheless like toplay with things on a PC to see what it is, and that is where PCs come in.andO;Similarly, if you are working on a PC, sooner or later you run into a biggermachine, and it's nice to be able to carry over your work.andP;  I'm very keen onportability.andM;DDJ: Do you have opinions as to whether preprocessing translators, such asthe CFRONT implementation on Unix, have advantages over native compilers suchas Zortech C++?andM;BS: It depends on what you're trying to do.andP;  When I built C++ I felt that Icouldn't afford to have something that was hard to port, meaning it mustn'ttake more than a couple of days.andP;  I though if I built a portable codegenerator myself, it would be less than optimal everywhere.andP;  So, I thought ifI generate C, I could hijack everybody else's code generators.andM;For the last 40 years we've been looking for a universal intermediatelanguage for compilation, and I think we've got it now, and it's called C.andO;So, what I built was something that was a full compiler, full semantic check,full syntax check, and then used C as a intermediate representation.andP;  Inessence I built a traditional two-pass compiler.andP;  And two-pass compilers havegreat advantages if you've got lots of code generators sitting around forthem, and I had.andP;  They have the advantage that they tend to find errorsfaster than one-pass compilers because they don't start generating code untilthey have decided that the program looks all right.andP;  But they tend to be slowwhen they actually generate code.andP;  They also tend to be slightly larger andslightly slower throughout the whole process because they have to go throughthe standard intermediate form and out again.andM;And so, the advantages for the translator technology are roughly where youhave lots of different machines and little manpower to do the ports.andP;  I seethe one-pass compilers, the so-called native compilers, useful for machinesand architectures where the manpower available for support and development issufficient to make it worthwhile, which is when you've got enough users.andM;The two-pass strategy for translators was essential in the early days andwill remain essential as long as new systems come on the market so that youneed to get a compiler up and running quickly.andP;  As the C++ use on a givensystem matures, you'll see the translators replaced by more specificallycrafted compilers.andP;  On the PC, for example, CFRONT likes memory too much; itwas built for a system where memory was cheap relative to CPU time.andP;  So onceyou know you are working for a specific architecture, you can do intelligentoptimizations that the highly portable strategy that I was using simplymustn't attempt.andM;DDJ: Are there different debugging considerations when you are using apreprocessing translator?andM;BS: One of the things that people have said about the translators is that youcan't do symbolic debugging.andP;  That's just plain wrong because the informationis passed through to the second pass and you can do debugging of C++ at thesource level.andP;  Using the 2.0 transaltor we're doing that.andP;  The 1.2 versionsdidn't have quite enough finesse to do it, and people didn' invest enough inmodifying debuggers and the system-build operations to give good symbolicdebugging.andP;  But now you have it.andM;DDJ: Can you estimate the worldwide C++ user base today?andM;BS: Fifty thousand plus, and growing fast, and that is a very conservativeestimate.andM;DDJ: Have you formed plans to rewrite any or all of Unix with C++?andM;BS: Unfortunately, I haven't despite that being one of my original thoughts.andO;I've been bitten trying to write software that was too complex for the toolsI had.andP;  When thinking about rewriting Unix, I decided that C wasn't up to thejob.andP;  i diverted into tool building and never got out of that diversion.andP;  Iknow that there is an operating system written in C++ at the University ofIllinois.andP;  It has a completely different kernel, but it runs Unix and you canmake it look like System V, USD, or a mixture of the two by using differentpaths through the inheritance trees in C++.andP;  That's a totally object-orientedsystem built with C++.andP;  I know that ATandamp;T and Sun have been talking about UnixSystem V, Release 5, and that there are projects working on things likeoperating systems rewrites, but whether they become real or not depends moreon politics and higher corporate management than anything else.andP;  Why shouldwe guess?andP;  All we can do is wait and see.andM;DDJ: Is what you do now primarily related to the development of C++ or theuse of it?andM;BS: Both.andP;  I write a fair bit bit of code, still.andP;  I do a lot of writing, andI coordinate people, saying &quot;Hey, you need to talk to that guy over there,&quot;then getting out of the loop fast.andP;  I do a fair bit of thinking about whatelse needs to be done with C++ and C++ tools, libraries and such.andM;DDJ: C is a language of functions, and a large part of the ANSI C standard isthe standardization of the function library.andP;  C++ has all that as well andadds classes to the language.andP;  Is there a growing library of C++ classes thatcould eventually become part of a standard?andM;BS: The problem is there are several of them.andP;  We use some inside ATandamp;T, andseveral of the other purveyors of C++ compilers and tools have their ownlibraries.andP;  The question is to what extent we can pull together for astandard library.andP;  I think that we can eventually get to a much largerstandard library and much better than what is available and possible in C.andO;Similarly, you can build tools that are better than what is possible with Cbecause there is more information in the programs.andM;But people, when they say standards, tend to think about intergalacticstandards, about things that are available in any implementation anywhere,and I think that they think too small.andP;  There are good reasons fordifferences between the ideal C++ environment for a Cray and the ideal C++environment for a PC.andP;  The orientation will be different as will the emphasison what is available.andP;  So we will see many standards, some for machinearchitectures, some over ranges of machines, some national standards.andP;  Youcould imagine the French having a whole series of libraries and tools thatwould be standard for people doing French word processing, for instance.andP;  Youwill see national standards, international standards, industry standards,departmental standards.andP;  A group building things like telephone operatorcontrol panels would have the standard libraries for everybody in thecorporate department doing that kind of work.andP;  But a token standardization ofeverything, you won't see.andP;  The world is simply too big for that.andP;  But we cando much better than we're doing now.andM;DDJ: To the programmer, there is an event-driven or object-orientedappearance to the graphical user interfaces (X Windows, the Macintosh,Presentation Manager, MS-DOS Windows, and so on).andP;  These seems to be anatural fit for the class hierarchies of C++.andP;  How would these facilities bebest implemented, and do you know of any recent efforts in these areas?andM;BS: Some people have the idea that object-oriented really means graphicsbecause there is such a nice fit.andP;  That has not been my traditional emphasis.andO;The examples people have seen of object-oriented programming andobject-oriented languages have, by and large, been fairly slow.andP;  Therefore,their use has been restricted to areas where there's a person sitting andinteracting.andP;  People are relatively slow.andM;My first aims were in areas where you had complex programs that had a veryhigh demand on CPU and memory, so that's where I aimed first.andP;  But peoplehave been building very nice toolsets for doing user interfaces with C++.andO;There is one from Stanford called &quot;Interviews.&quot;andP;  Glockenspiel, in cooperationwith Microsoft, is selling Common Views, which is a C++ toolset that looksand feels exactly the same whether you are under Presentation Manager, MS-DOSWindows, or on a Mac.andP;  There are C++ libraries for Open Look.andM;The problem with all these so-called standards is that everybody seems tohave their own standards, and then you start wondering how you can gettoolsets that give platform independence across all of these.andP;  I think thathsone place where C++ comes in.andP;  Most of the differences between the majorsystems in the areas of text handling -- as opposed to high-performancegraphics -- seem to be quite manageable as a common set of classes that couldbe standardized at the language level.andP;  It's certainly something that's worthexploring because the world is getting more fragmented.andM;DDJ: Are you familiar with Objective C, a C language extension that appearsto do at least a subset of what C++ does, and how do the two languagescompare?andM;BS: Vaguely.andP;  The company that sells it will claim that it does a superset ofwhat C++ does, and that whatever C++ does that it does not, is not asimportant, naturally, I disagree.andP;  There is much higher emphasis in C++ onstatic type checking and on coherence of the type system.andP;  C++ is a ratherlarge affair with multiple purveyors and multiple libraries, where ObjectiveC is a corporate language from a corporation that wants to make its fortuneout of it.andP;  That places a different emphasis on everything.andM;DDJ: Concurrent C and Concurrent C++ are, like C++, extensions to thelanguage.andP;  They add parallel processing operations to C and C++ for thedevelopment of multitasking programs that are portable among multitaskingplatforms.andP;  Do you have any comments on Concurrent C++?andP;  is there a need forportable parallel processing, and do you think that Concurrent C++ fills thatneed?andM;BS: I don't like the idea of putting ADA tasking into C or C++.andP;  I think itsolves the issues dealing with concurrency at the wrong level, sort of amedium-level thing.andP;  It doesn't give the transaction processing view andtransaction logging that you need in databases.andP;  It doesn't give themachine-near world that you need when you write an operating system kernel ora real-time application.andP;  Personally, I don't like that approach at all.andP;  TheApproach I've taken with C++ is to provide concurrency in the form oflibraries.andP;  We have the Task Library that provides a much lower-level systemthat allows you to write multi-threaded programs.andP;  I've used it forsimulations where I needed a couple of thousand processes or tasks and I wantthem to run with fairly minimal overhead.andP;  It has been used for robotics andsuch.andP;  I much prefer the library route ovr the route of adding syntax to thelanguage.andP;  I think it serves more people better.andM;DDJ: Let's discuss the future of C++ and what programmers can expect in thenext decade.andP;  The immediate future of C++ is, of course, 2.0, which addsmultiple inheritance to the language.andP;  Can you summarize the other featuresadded by version 2.0?andM;BS:  It's a reworking of the language, polishing off the little roughcorners, the unnecessary restrictions, and the problem areas we found.andP;  Evenmultiple inheritance can be seen as removing a little odd restriction, whichwas that you couldn't have more than one base class.andP;  We can argue how majoran extension it is.andP;  Some people think it's major.andP;  I think it's sort ofmedium.andP;  It allows you to do things that you could do with C++ but noticeablycleaner and easier.andP;  I don't think it allows you to do anything radicallynew, and most of the other features I've added to 2.0 are of that ilk.andP;  It'smeant to stabilize the language, it's meant to increase the quality of theimplementations, and it's meant to remove unnecessary restrictions withoutdestroying run-time or space efficiencies.andM;So, in version 2.0 you have the multiple inheritance, you have a moresensitive and better overloading resolution mechanism, you have type-safelinkage to make sure you can link larger programs together more effectively,and you have abstract classes.andP;  The list is fairly long but not radical.andP;  Wehave a lot of users, and we have to make sure there is a certain stability inthe growth.andM;DDJ: Are you planning specific features for C++ beyond 2.0?andM;BS:  We've been talking about exception handling and parameterized types fora long time.andP;  It's universally agreed that we need them.andP;  We have areasonably good design for parameterized types that I presented at the lastUSENIX C++ conference, and that needs to be refined a little bit.andP;  Exceptionhandling is one stage behind that, but we need it badly.andP;  When you go to C++,you get more ambitious.andP;  You want to have larger libraries, you want to usemore of other people's code, and so you need more support.andP;  That's what we'retrying to provide as quickly as we can without just throwing in everything atrandom.andP;  The language has to be kept coherent.andM;DDJ: The Integrated Development Environment with its integrated editor,compiler, and debugger has become the chosen software development suite insmall systems.andP;  Turbo C, QuickC, Turbo Pascal, etc., are examples.andO;Standalone symbolic debuggers that deal specifically with objects like C++classes are beginning to appear as well.andP;  Are such environments appropriatefor C++, and do you know of any current developments?andM;BS: Oh yes.andP;  They'll come.andP;  Some people will use them, and I believe you canbuy one from ParcPlace now.andP;  I'll assume that since Microsoft is working onC++, they'll be working on a suitable environment.andP;  Borland is playing thesame game they'll be doing it, too.andP;  I know of several other people who arethinking along those lines.andM;The thing that one has to seek is code portability across the differentplatforms.andP;  Certainly you can provide better tools for a specific platform, abetter compiler, better compile times, a better program developmentenvironment.andP;  Unless, however, you are able to take your programs out oftheir environment and export them to something else, you have paintedyourself into a corner.andM;DDJ: To date there is no standard for C++.andP;  Hewlett-Packard formallyrequested the ANSI X3J11 committee to undertake that standardization as acompatible superset of ANSI C, but the committee was ambivalent about it,failing to vote to begin the task.andP;  One reason for the request was to avoidthe time-consuming overhead of setting up a new committee.andP;  Opponents to theidea pointed out that you are still in the process of the C++ definition and,as such, are not ready for standarization.andP;  Do you see the committee's actionas an impediment to the acceptance of C++?andP;  Is C++ ready for standardization?andM;BS: Life isn't easy.andP;  Clearly we would like a fully standardized language,and equally clearly we don't know how to do that.andP;  There are still somefeatures that we need to design.andP;  There were discussions that included me,other people at ATandamp;T, and people from Hewlett-Packard and Microsoft.andP;  Wheredo we go from here, we asked?andP;  How can we get the most stable environment thefastest without freezing the language at a level where everybody has toextend it themselves?andP;  If we standardized C++ simply as it was, everybodywould build their own exception handling and parameterized types.andM;I don't think that the ANSI committee would be at all a suitable forum forstandardizing C++.andP;  First of all, they are not C++ users.andP;  They may be Cexperts, but they are not C++ experts.andP;  We might as well say that since thePascal committee did a good job on Pascal, let them do C++.andP;  We need a newcommittee composed of people with C++ experience.andP;  We clearly need a standardas soon as possible, but we simply have to figure out what &quot;as soon aspossible&quot; means.andM;We need a C++ that's as compatible with ANSI C as possible, but it can't beone hundred percent compatible without destroying every C++ program everwritten.andP;  When ANSI turned down the proposal, Hewlett-Packard went to SPARC,the policy committee for ANSI, with a new request to start a new ANSI C++committee with the charter for standardizing C++, a committee composed ofpeople who know the problems of exception handling and parameterized types,and who know that one hundred percent compatibility with ANSI C is notdesirable--as close as possible but no closer.andP;  That was accepted by SPARC,and they have sent a recommendation to X3 to start an ANSI C++ committee.andO;Presumably the first meeting of that will be next spring.andM;DDJ: &quot;As close as possible to C but no closer.&quot;andP;  That was the title of apaper by you and Andrew Koenig wherein you identified the differences betweenANSI C and C++.andP;  The tone of the paper was that those differences are properand necessary given the different purposes of the two languages.andP;  The paperalso stresses the inconsequential nature of most of the differences.andP;  Do yousee those differences as proof that C and C++ can not be combined?andP;  Shouldthey be combined?andM;BS: I don't think the two languages should be reconciled further than theyare.andP;  The differences are quite manageable by conditional expressions.andP;  Ifyou are writing C++, you use the new keywords and it isn't ANSI.andP;  If you arewriting ANSI C you could have an option in your compiler that suppresses theC++ subset, and it will not affect the way you write code.andP;  It's much more anissue for language lawyers than it is for programmers.andP;  The whole thing canbe exhaustively discussed on two pages and the differences can be listed onabout ten lines.andM;DDJ: Will you rewrite your book, the C++ Programming Language, to reflect thenew features of version 2.0?andM;BS: I will as soon as I get time.andP;  But it's more important to get thelanguage stabilized, and so I'm working on a new language definition, a newmanual.andP;  I am working on a book, as well, with Margaret Ellis that explainswhat C++ is, not, as the first book does, how you go about using it.andP;  Thebook states what the language is, what the implementation techniques are thatmake sensible implementations of certain parts, and why certain decisionswere made.andM;This is a &quot;what&quot; book, not a &quot;howto&quot; book.andP;  In theory, it's a book forexperts.andP;  If you have a question about what the language is, the answershould be there.andP;  Lots of people prefer to learn languages from suchexplanations.andP;  You never know who would want something like that.andP;  I learnedALGOL 60 but of the ALGOL 60 Revised Report.andP;  I'm not the only one who issort of semimasochistic in the way I read things.andM;DDJ: When will this new book be available?andM;BS: It's supposed to happen in December or January.andP;  The question is whetherI can make it.andP;  The manual work itself is taking longer than it should.andP;  It'sabout twice the size of the original manual, not because version 2.0 is twicethe language as version 1.0, but because I need to go into much greaterdepth.andM;If you can assume your reader's culture, you can take shortcuts inexplanations, and there are certain words that you can forget to definewithout getting into trouble.andP;  C++, however, is breaking out of the C ghetto.andO;People who were brought up with Pascal and wouldn't touch C with a barge poleare getting on board with C++.andP;  They come in and they try to read some of thestandard C++ literature.andP;  When you get their comments, you learn whatassumptions you  made without explaining them.andP;  Such things must not be donein the manuals we are working on.andP;  It's getting harder to write a manualbecause the audience is becoming more diverse.andM;DDJ: One of the problems we've observed when function-oriented programmersattempt the transitionto object-oriented systems is that there doesn't seemto be any way to describe the new paradigm to them in a way that they canlearn it without actually using it.andM;BS: We'll eventually do better.andP;  The first books on C++ just said what thelanguage was, put a thin veneer on top of it, or described it primarily as abetter C. Lipmann's book and Dewhurst and Stark's book go beyond that anddemonstrate how things are done.andP;  We have a major education problem on ourhands.andP;  I've been saying that for years.andP;  You can write Fortran in anylanguage, and if you only use C++ as a better C, you'll see improvements inyour programs and productivity, but you won't get anywhere near what you cando or what we have seen demonstrated with greater degrees of data abstractionand object-oriented programming.andM;DDJ: The function-oriented programmer does not understand intuitively whatthe advantage of that is.andM;BS: It's hard to explain how to bicycle.andP;  I can talk myself hoarse and stillyou go up to a bicycle, and you fall off the first time.andP;  A certain amount ofpractice must be done.andP;  Programming is an art like riding a bicycle.andP;  It'slearned by doing it.andP;  But you can certainly help the process.andP;  You don't justsay to somebody, &quot;Here's a bicycle.andP;  Ride.&quot;andP;  Similarly we need bettereducation on how to use a language like C++ for object-oriented programming.andO;You can write better articles, use videotapes, put training wheels on the newprogramming environments, help programmers get started.andP;  It can be managed.andO;It will be managed.andP;  The gains in doing so have been demonstrated oftenenough.andM;DDJ: Programmers have been told that they must unlearn what they have learnedin order to use object-oriented programming, and thy reject that.andM;BS: That's not what I am telling them.andP;  C++ is a better C, and it supportsdata abstraction, and it supports object-oriented programming, and, yes, youcan forget all you have learned and jump into the deep end.andP;  but lots ofpeople do it differently.andP;  They start out using it like a better C, theyexperiment on the side with the techniques they don't quite understand.andO;Follow the literature so that you know the syntax, the basic semantics, andyour tools before you take that big leap.andP;  Then try to focus on classes for anew project.andM;One of the advantages of C++ is that you can take some of the preliminarysteps without a paradigm shift from function to object-oriented programming.andO;You can learn the tools, the language, the basics, how to use debuggers,whatever it takes.andP;  And then one day when you find the right project, you cantry the next step.andP;  We've seen that done quite a few times.andM;There are people who enthusiastically read all the literature, go to C++conferences, and then go straight in, design huge class hierarchies, andprogram them.andP;  I'm always amazed when it works, but it does quite often.andO;There are people who can write perfectly standard designed C programs, goaway and wait two months and come back and write their first program in C++,truly object-oriented with tens of thousands of lines, and, lo and behold, itworks.andP;  By all laws, it oughtn't.andP;  But it's happened.andM;Of course, I'm sure there are also people out there who have gotten burnttrying to do that.andM;DDJ: Would you offer your comments about the future of programming.andP;  Whatkinds of things do we need to understand in order to deal with softwaredevelopment inthe near future.andM;BS: I think we'll see much more emphasis on the design of classes and theformal interfaces between parts, and an increase in the reuse of existingprograms and libraries of classes.andP;  We will need tools that help us do thisand draw structure or draw inference on what the structure is.andP;  Things likeperformance analysis and coverage testing will all be available.andP;  It's worthremembering that it's not a solitary activity -- not just one guy sittingthere with one machine; many of the key activities are social.andM;We'll also need to develop ways of talking about programs that are ahead ofwhat we are doing today.andP;  It's no good if we can compose programs ancomponents out of classes if we can't talk about that activity in a sensibleway.andP;  We don't have the vocabulary.andP;  It would be nice if we knew whatobject-oriented design was.andP;  By and large, we don't know it yet.andP;  But thatwill emerge in five years and will be virtually accepted almost universallyafter that.andO;</TEXT></DOC>