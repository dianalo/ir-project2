<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-169-170  </DOCNO><DOCID>07 169 170.andM;</DOCID><JOURNAL>Computer Language  April 1989 v6 n4 p34(7)* Full Text COPYRIGHT Miller-Freeman 1989.andM;</JOURNAL><TITLE>Bit strings in C.andO;</TITLE><AUTHOR>Gray, John.andM;</AUTHOR><SUMMARY>Many high-level languages have difficulty manipulating logicallyencoded data.andP;  On most computers data is treated as charactersrather than bits, and the result of storing and accessing suchdata as full words is a loss of storage space.andP;  In the programminglanguage C, manipulation of bit data is restricted by severalfactors.andP;  The technique of declaring bit strings as an array ofunsigned integers is described and a short program included.andO;Functions discussed include Clear, GetBit, PrintBit, SetBit,ResetBit, and Testbit.andM;</SUMMARY><DESCRIPT>Topic:     C Programming LanguageBit ManipulationNew TechniqueMemory ManagementProgrammingTutorial.andO;Feature:   illustrationtableprogram.andO;Caption:   Truth table. (table)Demonstration of use of bit strings in C. (program)andM;</DESCRIPT><TEXT>Bit Strings in C One of the main functions of a computer is to process data.andO;Data can be defined as the representation of information in a formalizedmanner suitable for interpretation and processing.andP;  Data can be representedin many formats; one of the most basic is logical encoding.andM;Logically encoded data is represented by a string or series of bits set toeither 1 (TRUE, present) or 0 (FALSE, absent).andP;  If, for example, we wererepresenting the colors of the rainbow (red, orange, yellow, green, blue,indigo, and violet), we could represent the presence of the color red by thestring 1000000, where the leftmost bit is set to 1, indicating the presenceof the color red.andP;  Extending this approach, a combination of colors such asred, blue, and violet would be represented by the string 1000101.andP;  With thistechnique, we can encode 2 to the power of n permutations of 0s and 1s, wheren is the number of the bits in the string.andM;Logically encoded data can be employed in a number of practical applications;for example, true-false tests, surveys, and other types of data where it isimportant to know whether an indicated item is absent or present.andM;Unfortunately, many high-level computer languages have great difficultymanipulating information at the bit level.andP;  The way data is manipulated isoften directly tied to how the data is represented internally.andP;  For example,if we are working in a language lacking a bit-type declaration and we chooseto represent each data element as a single character with the letter T fortrue and the letter F for false, each data element would be of typecharacter.andP;  Internally, when character data is stored using an extended ASCIIformat, each character is represented by a unique 8-bit (1-byte) string ofbinary digits.andP;  Thus, 256 characters (decimal values 0-255) can berepresented in 1 byte.andM;However, on most computers, character data is stored and accessed using afull word.andP;  The word size of most computers (commonly from 8 to 64 bits inlength) normally exceeds the 8-bit character representation requirement.andP;  Theloss of storage space is tolerated since the majority of computers are mostefficient when manipulating a full word rather than a portion of the word.andO;Thus, a string of characters representing the colors of the rainbow using theword sizes noted could be anywhere from 56 to 448 bits in length.andP;  For someapplications, such inefficient storage techniques cannot or need not betolerated.andM;In C, a predefined bit-type declaration is not available.andP;  However, bitfields can be defined in C as structure members using a specified field-widthdescriptor.andP;  Certain restrictions apply when using this approach.andM;First, field widths to be implemented efficiently should not be wider thanthe word size of the underlying machine.andP;  Second, each nonfield member of astructure begins on an address boundary of the defined type.andP;  An array ofstructures, with each structure consisting of a single unsigned integermember with a field width of 1, would exhibit a loss of storage space due toalignment.andP;  Third, access to individual structure members must be done usinga selected component notation similar to record notation used in Pascalwithout a corresponding with statement.andM;Fortunately, an alternate approach to declaring bit strings can beimplemented.andP;  The bit string can be stored and manipulated as an array ofunsigned integers.andM;This article addresses the alternate approach.andP;  The declaration of the bitstring as well as the functions needed to manipulate individual bits(clearing, setting, resetting, and testing) will be discussed.andP;  A short Cprogram is included for illustration (Listing 1).andP;  I leave it to the readerto expand the code where necessary to provide for more practicalapplications.andM;Bit-string allocationandM;The bit string to be manipulated is stored as an array of unsigned integers.andO;The unsigned integer data type is specified to avoid any machine-specificimplementations for shifting in high-order sign bits.andM;The total length of the bit string to be allocated is determined by twofactors.andP;  The first is the actual number of bits needed for the programmingapplication.andP;  For example, for 35 data items, you need a minimum of 35 bits.andO;Second, the number of bits allocated must be a multiple of the number of bitsused to store one element of the unsigned integer array.andP;  While this secondfactor sounds formidable, the sizeof operator greatly simplifies the task.andM;The sizeof operator will return the number of bytes used to store thespecified data type argument.andP;  For example, on many machines, sizeoff(unsigned) will return the value 2, indicating that an unsigned integer isstored in 2 bytes.andP;  While the number of bits in a byte is undefined by thelanguage, most existing implementations of C use the space required to storea character as the byte size (normally 8 bits).andP;  Therefore, in this example,the unsigned integer is stored in 16 bits (2 bytes 8 bits/byte = 16 bits).andM;Returning to the 35-bit example, we find that dividing 35 bits by 16 androunding up to the nearest whole integer (finding the ceiling) yields 3;thus, 3 unsigned integers (each containing 16 bits for a total of 48 bits)should be allocated.andP;  While storing 35 bits in a sapce that can accommodate48 bits leaves 13 bits unused, it is not as wasteful as using 35 bytes (35bytes * 8 bits/byte = 280 bits) to store each bit field as an 8-bitcharacter.andM;Listing 1 was developed on an ATandamp;T UNIX PC (7300).andP;  The program resides in asingle file.andP;  It was tested and found to execute without modification withthe DeSmet C Development Package on an IBM PC using PC-DOS v. 2.1.andM;PreliminariesandM;Looking at the initial portion of Listing 1, we find several control linesthat communicate with the preprocessor.andM;The control the #define HEX1 ((unsigned) (0x1)) defines a symbolic constantHEX1, which is equated with the value of an unsigned hexadecimal 1.andP;  For anunsigned integer of 16 bits, the binary representation is 0000000000000001.andO;The control lines: #define BITSperBYTE (8) #define SIZE (sizeof(unsigned)*BITSperBYTE)andM;are used to calculate the number of bits of storage required for an unsignedinteger.andP;  The definition of the symbolic constant BITSperBYTE as 8 indicatesthat this implementation uses 8 bits per byte.andP;  If your compiler uses adifferent number of bits to represent 1 byte, this value should be changedaccordingly.andM;The second definition directs the preprocessor to replace all occurrences ofthe identifier SIZE with the corresponding expression.andP;  SIZE corresponds tothe number of bits used to store an unsigned integer assuming 8 bits perbyte.andP;  Defining SIZE in this manner rather than as a constant increases theportability of the program.andM;The control lines: #define SCRNsize (80) #define LIMIT (SCRNsize / SIZE)#define ARRAYlen(x) ((x) / SIZE) assign the maximum length of the bit-stringarray based on the width of the screen in characters.andP;  Note that 80 is anartificial restriction and was chosen to facilitate the display of the bitstring as a series of 1s and 0s on a single line of the screen.andP;  If yourdisplay can support more characters or line wrap is not a concern, changethis value accordingly.andM;All occurrences of the identifier LIMIT will be replaced by the correspondingexpression.andP;  This expression calculates the maximum number of array elements,based on SIZE (bits per array element), needed to store SCRNsize number ofbits.andP;  It is important to note that the value stored in LIMIT is the resultof integer division.andM;The final control line, #define BITrangeERR printf(&quot;\n\7Bit out of range 1 -%d \n&quot;, value), directs the preprocessor to replace all occurrences of theidentifier BITrangeERR with the corresponding token string.andP;  This stringcontains a call to the predefined standard output function printf.andP;  Thefunction printf is passed a format string containing the newline characterfollowed by the bell character and an appropriate message.andM;The variable value, the number of bits requested by the user, is definedexternal to all functions.andP;  Functions that require access to value use animplicit declaration.andM;MainandM;The function main contains additional variable definitions.andP;  The variables iand j are used as integer indices.andP;  The variable max is used to store themaximum number of array elements.andP;  The variable ch, an integer, will containthe next character of input returned by the function getchar.andP;  The initialprintf statement displays a prompt to the user requesting the number of bitsneeded.andP;  User input is returned by the function scanf and the maximum indexof array elements is calculated and assigned to the variable max.andP;  If thevalue entered by the user falls within the specified range, processingcontinues.andP;  Otherwise, a statement indicating the requested value is out ofrange is displayed and the program terminates.andM;The declaration unsigned BitString [LIMIT] declares an array of unsignedintegers.andP;  If LIMIT contained a value, such as 5, the subscripts of the arrayBitString would be referenced using the values 0-4.andM;The working bit-string array is then cleared (reset to all 0s) by a call tothe function Clear.andP;  Clear is passed the address of the bit-string array andthe maximum number of array elements.andM;The string CMDandgt; is displayed to prompt for user input.andP;  Input entered by theuser is evaluated by the test within the while statement.andP;  If end-of-file hasnot been generated, the input is tested further by a switch statement.andP;  Avalid input character is one of the letters in the string CEPRST in eitherupper or lower case.andM;Invalid character input causes the display Usage: C-clear, E-exit, P-print,R-reset, S-set, T-test to remind the user of the valid characters and theirrelated functions.andM;ClearandM;Clear is declared as static, only defined within this file, and void, notreturning a value via a return statement.andP;  The formal parameters bs and m aredeclared as pointers to an unsigned integer and an integer, respectively.andO;The variable bs will contain the address of the bit-string array passed and man integer that is the maximum number of array elements.andP;  For the sake ofefficiency, the index variable i is declared as a local register variable.andO;The body of the function Clear consists of a for statement that uses theexclusive-OR (XOR) operator to reset all the bits in each array element to 0.andM;Table 1 is the truth table for XOR.andP;  XOR indicates that a true (1) isobtained only if one value (P or Q) is true and the other false.andP;  Thus, aseries of bits exclusive-ORed with a copy of itself will always return all0s.andP;  While this function does not use the return statement, it does cause oneof the original arguments to be modified.andP;  Clear changes the contents of thearray elements at the address passed in the variable bs in the initialargument list.andM;GetBitandM;GetBit is called by the functions that set, reset, and test bits.andP;  GetBitobtains user input concerning the bit position to be manipulated.andP;  Thefunction is declared as static and returns an integer value via the returnstatement.andM;The formal parameters for the function GetBit, index and offset, are declaredas pointers to integers.andP;  The variable index will reference the subscript ofthe appropriate array element (a value in the range of 0 to LIMIT).andP;  Thevariable offset references the bit position within the specified arrayelement (a value in the range of 1 to SIZE).andM;Two additional local variables, bit and ok, are also employed.andP;  The contentsof the variable ok will be the value returned by function GetBit via thereturn statement.andP;  The variable ok is initially set to 0 (false).andP;  The useris prompted, via the function printf, to enter the bit number.andP;  Within thefollowing if statement, the function scanf is used to obtain user input andassign it to the variable bit.andM;The control string for scanf contains a format field %d for numeric input.andO;The remainder of the control string, %*s, directs scanf to ignore anytrailing sequence of input characters.andP;  The function scanf, by definition,will also return the number of successful conversions made, which, in thiscase, will be either 0 or 1.andP;  This value is logically ANDed with the resultobtained by the range test and then assigned to the variable ok.andP;  If userinput is valid and the requested bit is within range, the values for indexand offset are calculated and assigned.andP;  The value assigned to ok, either 0or 1, allows the calling function to determine the validity of the datareturned to it at the addresses referenced by the parameters index andoffset.andM;For example, if the user wanted to manipulate bit-42 and each bit-stringelement contained 16 bits, index would be assigned the value 2 (the floor of(42 - 1)/16)).andP;  Keep in mind that array subscripts begin at 0.andP;  The variableoffset would be assigned the value 10.andP;  This value is obtained by testing therequested bit number stored in the variable bit, modulus the number of bitsper element and then applying the conditional operator?:.andP;  If the requestedbit is not evenly divisible by SIZE, the result of the modulo division (theremainder) is assigned to offset.andP;  Otherwise, the requested bit is at thelast position within the given array element (at position SIZE) and offset isassigned the value SIZE.andM;PrintbitandM;The function PrintBit displays the working bit string.andP;  It is callediteratively by main via a for statement.andP;  The for statement begins with themaximum element index, max, of the bit-string array down to the 0th elementin steps of -- 1.andM;Each element and its subscript are passed to PrintBit.andP;  Passing PrintBit themaximum index first causes the most significant bit of the working bit stringto be displayed in the leftmost position on the screen.andM;Within Printbit, a second for statement is used to process each bit in thearray element.andP;  Each bit position, starting with the leftmost position, istested before printing.andP;  This test eliminates the display of bit positionsthat may have been allocated but are not within the specified range.andM;If the calculated bit position is within range, a character 0 or 1 isdisplayed.andP;  The appropriate character is determined by the expression inprintf.andP;  In this expression, the HEX1 value is shifted left (i -- 1) places(note that a left shift of 0 causes no alteration of the initial value).andP;  Thevariable i, which ranges from SIZE down to 1, is the index value of the forstatement.andP;  As the value HEX1 is shifted left, low-order bits are replaced by0s.andP;  The results of the left shift are ANDed bitwise with the originalelement.andP;  The conditional operator is then used to determine if the resultingexpression is TRUE (a 1 was present at that position) or FALSE and generatesthe corresponding characer to be printed.andM;SetBITandM;The function SetBit will turn on (set to 1) a bit at a specified position.andO;The formal parameters of this function, element and offset, are declared as apointer to an unsigned integer and an integer, respectively.andP;  The variableelement is the address of an element of the bit-string array, while offset isthe position of the bit within the array element.andP;  A bit is set by shiftingthe HEX1 value left (offset -- 1) places, inclusive-ORing the result with theoriginal value, and assigning this new value back to the original location.andM;For example, if the original location contained the value 0000100100000000and the bit position was 5, the value of HEX1 shifted left four places,inclusive-ORed with the initial value, would be 0000100100010000.andP;  In otherwords: 000010010000000  initial value 0Red 0000000000010000  HEX1 shiftedleft ----------------  4 places 0000100100010000  resultandM;If the specified bit position was a 1 to start with, the property of theinclusive-OR (a true (1) is obtained if either value is a true or both valuesare true) ensures the proper result.andM;ResetBitandM;The function ResetBit will reset a bit at a specified position.andP;  The formalparameters for this function are the same as SetBit.andP;  Resetting bit isimplemented using a construct commonly called a mask.andP;  An unsigned integermask that has a 1 in every bit position except the position to be reset iscreated.andP;  This mask is then ANDed bitwise with the original value.andP;  All bitpositions will maintain their original settings except for the position to bereset, which will be set to 0.andM;For example, if we had an initial arbitrary 4-bit string of 1110 and wantedto reset bit 3, we would have the following sequence: 1110 AND 1011 --- 1010andM;This is accomplished by declaring mask as an unsigned integer with a value ofHEX1.andP;  In keeping with our original element size, mask initially would havethe value 0000000000000001.andP;  The next statement reassigns mask the initialmask value shifted left (SIZE -- 1) places.andP;  The levt shift moves the 1 tothe leftmost bit position, filling low-order bits with 0s.andP;  The variable maskwould now have the value 1000000000000000.andP;  The value in mask is then shiftedright to the specified bit position.andM;This new value, which has a 1 in the correct bit position and a 0 everywhereelse, is the mirror image of the desired value.andP;  Therefore, the 1'scomplement operator is applied to obtain the correct value for mask.andP;  The 1'scomplement operator will invert its bit-string argument; all 0s will become1s, and 1s will become 0s.andP;  The variable mask, which now has 1s in allpositions except the position to be reset, is ANDed bitwise with the initialarray element and assigned back to the original location, which is in turnpassed back to the calling fuction.andM;TestBitandM;The function TestBit will test a specified bit position.andP;  The functionreturns a 1 if the position is a 1; otherwise, it returns a 0.andP;  The formalparameters for TestBit are the bit-string array element and the bit positionwithin the specified element.andM;The bit position is tested by shifting the contents of the array element.andO;Working with the contents of the array element is permissible in this casesince we are actually working with a copy of the array element.andP;  Therefore,modifications to the array element made by the function TestBit will not bereturned to the calling function.andM;The array element is first shifted left (SIZE -- offset) places and thenshifted right (SIZE -- 1) places.andP;  The purpose of the shifting is to replaceall the bits to the immediate left and right of the specified bit positionwith 0s.andP;  This leaves only the bit to be tested in its initial state.andM;The resulting value obtained by shifting is returned to the calling function,where it is tested via the conditional operator within the function printf.andO;Any nonzero result returned indicates that the bit was set, and the characterT is assigned to the %c format field; otherwise, the character F is assigned.andO;</TEXT></DOC>