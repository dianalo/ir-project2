<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-646-884  </DOCNO><DOCID>07 646 884.andM;</DOCID><JOURNAL>Communications of the ACM  Sept 1989 v32 n9 p1051(5)* Full Text COPYRIGHT Assn. for Computing Machinery, Inc. 1989.andM;</JOURNAL><TITLE>Literate programming: weaving a language-independent web.andO;</TITLE><AUTHOR>Van Wyk, Christopher J.andM;</AUTHOR><SUMMARY>A solution for using WEB to check code correctness in a programwritten in SSL is presented.andP;  WEB implementations are normallyavailable in Pascal and C. Silvio Levy's implementation of WEB inC is modified to read and write SSL code.andP;  SPIDER, a program thatturns language descriptions into C code, is developed.andP;  SPIDER isa WEB generator, similar to parser generators.andP;  SPIDER's majordrawback is the necessity of learning another language, its majorbenefit is the ease of building new WEBs.andP;  SPIDER should make WEBavailable to a larger audience.andM;</SUMMARY><DESCRIPT>Topic:     Programming LanguagesCompilersParsingCode Generation.andO;Feature:   illustrationcharttable.andO;Caption:   Processing a C web file. (chart)Building and using an instance of WEB (for language X). (chart)Table inversion. (table)andM;</DESCRIPT><NOTE>Only Text is presented here; see printed issues for graphics.andO;</NOTE><TEXT>literate programmingandM;WEAVING A LANGUAGE-INDEPENDENT WEB In the fall of 1987 I started planning theimplementation of a suite of tools for building verified Ada programs [5].andO;The first tool to be built was a verification condition generator, which wasto be formally defined using the typed lambda calculus.andP;  I was eager toinclude the definition with the code so that it would be easy to check thecode's correctness.andP;  Using WEB would have made this easy, but, unfortunately,the target programming language was SSL (a language for specifying structureeditors), and the only languages for which WEB implementations were availablewere Pascal and C.andM;Writing a new WEB from scratch did not make sense, so I decide to modifySilvio Levy's implementation of WEB in C [3h, to get a WEB that would bewritten in C, but would read and write SSL code.andP;  From my previousexperiences modifying WEB, I knew that the most time-consuming job would befine-tuning the grammar that WEAVe uses to prettyprint code.andP;  I believed Icould make debugging that grammar a lot less painful if, instead of trying tomake dozens of small modifications by hand, I wrote a simple program, perhapsan AWK script, that would read a description of the grammar and generate Ccode for WEAVE.andP;  That AWK script became SPIDER, a program that turns languagedescriptions into C code for TANGLE and WEAVE.andP;  I have used SPIDER togenerate WEBs for C, AWK, SSL, Ada, and a couple of other languages.andP;  I willnot go into the details of SPIDER; instead, I will try to describe whatSPIDER does to accomplish its mission, or h ow to take the &quot;essence of WEB&quot;and make it language-independent.andM;When using WEB, a programmer writes a single source file, foo.web, that holdsboth code and documentation.andP;   TANGLE and WEAVE read that file.andP;  TANGLEextracts the code from the WEB file and rewrites it in a form suitable forcompiling.andP;  WEAVe passes the documentation parts to a document formatter[(T.sub.E.X)], and prettyprints the code parts.andP;  The whole process is shownin Figure 1, for C programs written in WEB.andP;  The * represents files that haveto be written by hand.andP;  Slant type is used for the names of executableprograms.andP;  CTANGLE and CWEAVE are the C-language versions of TANGLE andWEAVE, cc is a C compiler, and ld is a loader.andM;SPIDER is used to construct instances of TANGLE and WEAVE, and theseinstances are used to process programs as shown in Figure 1.andP;  Code for thelanguage-dependent parts of these instances is generated by SPIDER when itreads a language description file written by a WEB designer.andP;  Figure 2 showshow instances of TANGLE and WEAVE are generated.andP;  SPIDER converts ahand-written description of a programming language into C WEB code for thelanguage-dependent parts of TANGLE and WEAVE.andP;  In Figure 2 the targetprogramming language is a hypothetical &quot;X,&quot; and the description file iscalled &quot;x.spider.&quot; CTANGLE combines the code SPIDER writes with the &quot;mastercopies&quot; of tangle.web and weave.web, which contain the language-independentparts of TANGLE and WEAVE.andP;  The result is C source code for XTANGLE andXWEAVE.andP;  After that code is compiled and loaded with WEB's I/O code, theresulting executable versions of XTANGLE and XWEAVE can be used to processX-language programs written in WEB format, as shown around the periphery ofFigure 2.andM;The master copies of tangle.web and weave.web are about 1800 and 3200 lineslong, respectively.andP;  About one-third of these lines are comments.andP;  Toillustre the other sizes, suppose X is the Ada programming language.andP;  Theada.spider file is about 260 lines long, and from it SPIDER generates about1400 lines of ADA-TANGLE and ADAWEAVE.andP;  About one-tenth of these lines arecomments.andP;  It is typical for SPIDER to generate between 5n and 6n lines of CWEB code from an n-line language description.andM;A WEBB program is a collection of &quot;section,&quot; each of which has adocumentation part, a definition part, and a code part.andP;  The documentationpart describes what the section is supposed to do, and is intended to beprocessed by a formatter--my WEBs use [T.sub.X], which is especiallyconvenient for mathematical symbols like those used in writing a formalsemantics.andP;  The definition part contains macro definitions.andP;  Each macro mayhave parameters or not, as the programmer chooses.andP;  The code in the code partis a fragment of the whole program.andP;  It is called a &quot;module&quot; and can be namedor unnamed.andP;  When the module is named, the module name &quot;stands for&quot; thatcode, just as a macro name stands for the code in its definition.andP;  Theunnamed module is special; the code in the unnamed module is considered to be&quot;the program.&quot;andM;Figure 3 shows a fragment of a WEB program; the fragment inverts anEBCDIC-to-ASCII table to obtain an ASCII-to-EBCDIC table.andP;  The targetprogramming language is C.andP;  One module, andless;Invert to_ascii, producingto_ebcdicandgt;, uses the code defined in the other, andless;Set to_ebcdic[i] [leftarrow] UNDEFINED_CODE for all iandgt;.andP;  The program, foo, of which this fragmentis a part, can be input to CTANGLE and CWEAVE, to produce foo.c and foo.texrespectively, as shown in Figure 1.andM;TANGLE's job is to take a collection of sections and to produce a compilableprogram.andP;  TANGLE reads all the sections, skipping the documentation partscompletely, but storing the macro definitions from the code parts.andP;  After ithas read all the sections, TANGLE then writes out the code in the unnamedmodule.andP;  But whenever it encounters a module name in that code, instead ofwriting out the name, it writes out the code for which this name stands.andO;That code may itself contain module names, which are replaced with the codefor which they stand, and so on until TANGLE reaches code which contains nooccurrences of module names.andP;  TANGLE processes macros similarly, except thatmacros may have parameters (modules may not).andM;As I have described it, the &quot;essence of tangling&quot; is language-independent.andO;In the full implementation of TANGLE there are only a few language-dependentdetails, and almost all of them come up only in lexical analysis.andP;  During itsinput phase, TANGLE converts macro definitions and module definitions intotoken lists.andP;  The major kinds of tokens are module name tokens, identifiertokens, and ordinary tokens.andP;  Identifier tokens may be expandable (when theyare macro names) or unexpandable (when they are programming-languageidentifiers).andP;  Module name tokens are always expandable, and ordinary tokensare never expandable.andP;  TANGLE uses a stack to write out the token listcorresponding to the unnamed module, expanding expandable tokens as it goes.andO;No token is ever expanded until the time comes to write that token on theoutput.andM;To build the language-dependent part of TANGLE, it is enough to tell TANGLEhow to tokenize the input and how to write out a token list.andP;  TANGLE uses a&quot;lowest-common-denominator&quot; lexical analyzer to tokenzie its input.andP;  The setof tokens recognized by this lexical analyzer is the union of the sets oflegal tokens of many different languages.andP;  For example, different ways ofdelimiting string literals are recognized.andP;  Identifiers may have underscores,even though some languages (e.g., Pascal) may not permit underscores inidentifiers, and others (e.g., Ada) may not permit consecutive underscores inan identifier.andP;  In general, TANGLE and WEAVE do the right thing with legalprograms, but they do not detect illegalities in a program.andM;TANGLE's lexical analyzer recognizes a fixed set of tokens representingidentifiers, string literals, and numeric literals.andP;  Any printable ASCIIcharacter which is not part of some other token forms a token all by itself.andO;A WEB builder can specify that certain strings should be treated as singletokens, and SPIDER will convert the specifications into appropriate code forTANGLE.andP;  For example, when building WEB for C, we tell SPIDER that thestrings ++, ==, and andamp;andamp; (and many others) should be treated as single tokens,by putting the statements token ++ ...andP;  token == ...andP;  token andamp;andamp; ...andP;  into thelanguage description file, c.spider.andM;TANGLE discards comments, rather than attempting to tokenize them.andP;  Commentsare assumed to begin with a special string, and to end either with anotherstring or with a newline.andP;  We specify C comment conventions by telling SPIDERcomment begin andless;&quot;/*&quot;andgt; end andless;&quot;*/&quot;andgt;andM;On output, TANGLE converts tokens to text by inverting the process of lexicalanalysis, so, for example, the token * is written out as &quot;++.&quot;andP;  TANGLE'soutput phase inserts white space between adjacent identifiers and numericliterals, but otherwise does not write white space.andP;  This can cause problemsin some cases; for example, in older C compilers the string &quot;=-&quot; isambiguous.andP;  We can solve this problem by telling SPIDER to build a TANGLEthat uses the text &quot;= &quot; when writing the *: token = tangleto andless;&quot;= &quot;andgt;andM;In sum, we can make TANGLE language-independent with almost no effort.andP;  We dothis by using a lowest-common-denominator lexical analyzer whose onlyparameter is a description of comments, and by providing a way to fine-tunethe way TANGLE writes tokens.andM;Unlike TANGLE, WEAVE does no rearranging of the sections; its job is totranslate its input into a prettyprinted program listing.andP;  The documentationpart of each section is simply copied to the output, but the definition andcode parts are prettyprinted.andP;  WEAVE's output is handed to a documentformatter, which is assumed to implement a prettyprinting algorithm like thatdescribed by Oppen [4].andP;  Since WEBs use [T.sub.E.X] as the documentformatter, the back-end prettyprinting is implemented by [T.sub.E.X] macros.andM;WEAVE copies the documentation parts as texts, but it converts definition andcode parts to token lists using the same lexical analyzer used by TANGLE.andO;WEAVE's part of the prettyprinting task (as distinct from [T.sub.E.X's] part)is converting these token lists to streams of [T.sub.E.X] text, possibly withprettyprinting instructions intercalated between tokens.andP;  If you like,WEAVE's job is to produce the input to Oppen's algorithm.andP;  For simplicity,only three prettyprinting instructions will be discussed: indent (increasethe level of indentation); outdent (decrease the level of indentation); andforce (force a line break).andM;We tell WEAVE how to convert tokens to [T.sub.E.X] text by specifying atranslation for each token.andP;  Suppose we want the C token * to be printed as&quot;[is not equal to]&quot;, which is  produced by the [T.sub.E.X] &quot;\ne&quot;.andP;  Then wewrite token != translation andless;&quot;\\ne&quot;andgt;andM;(Two backslashes appear in the translation because SPIDER uses C conventionsfor string literals.andP;  The angle brackets andless;...andgt; delimit translations.)andP;  Thedefault for translation is just as in TANGLE, so if we want &quot;+&quot; on input toproduce &quot;+&quot; on output we need not specify a translation for the token *.andM;The process of deciding where to put line breaks and indentation is the mostcomplicated part of WEAVE.andP;  We have to do this based on the sequence oftokens we have, but the exact details of which token is where usually are notneeded to do prettyprinting.andP;  Hence we introduce the scrap, which abstractsaway from theandM;detail not needed to do prettyprinting.andP;   A scrap has twoandM;parts: the translation, which we have already seen, and the category, whichcorresponds to a &quot;part of speech&quot; or a symbol in a grammar.andP;  WEAVE usescategories to decide where to put indentation and line breaks.andP;  Since thereare usually many different tokens having the same category, prettyprinting issimplified enormously.andM;WEAVE begins processing a program fragment by tokenizing the fragment, thenconverting each token in the resulting token list into a scrap.andP;  It thenattempts to reduce the length of the resulting scrap list by combiningadjacent scraps into a single scrap, possibly intrecalating additionaltranslations, which may include indent, outdent, and force instructions.andP;  Thescraps are combined according to one of many reduction rules.andP;  WEAVE decideswhich adjacent scraps are eligible to be reduced based only on the categoriesof the scraps and a knowledge of the reduction rules.andP;  The reduction rulesare the productions of the prettyprinting grammar.andP;  WEAVE's reductions ofscrps are like the reductions done in bottom-up parsing.andM;Fox example, suppose that we want statements to be separated by line breaks.andO;If we can guarantee that any scrap representing a statement has categorystmt, it will be enough to specify the reduction rule stmt andless;forceandgt; stmt[right arrow] stmt which says &quot;two adjacent stmt scraps may be reduced to asingle stmt scrap by intercalating a forced line break between them.&quot;andM;So we tell WEAVE how to prettyprint a language by telling how to assign acategory to each token and how to combine scraps.andP;  Here is another example:the language of C expressions.andP;  Let math be the category of expressions,binop be the category of binary infix operators, and unop be the category ofboth unary prefix and unary postfix operators.andP;  Here are some sample tokens:token identifier category math token + category binop token - category binoptoken = category binop translation andless;&quot;\\leftarrow&quot;andgt; token == translationandless;&quot;\\equiv&quot;andgt; category binop token ( category open token ) category closeandM;Notice we print the *-token (assignment) as [left arrow],whereas we print the* token (comparison) as *.andP;  This makes it a bit easier for us to see when aprogrammer has mistakenly used * instead of *.andM;The prettyprinting grammar for C expressions is: math binop math [rightarrow] math math unop [right arrow] math unop math [right arrow] math openmath close [right arrow] mathandM;Using this grammar, WEAVE can take a long expression consisting of manyscraps, and reduce it all to a single scrap of catergory math.andM;What about an operator like &quot;*&quot;, which is both binary infix and unary prefix?andO;This does the job: token * category unorbinop unorbinop math [right arrow]math math unorbinop math [right arrow] mathandM;There is a merchanism for assigning categories and translations to reservedworks as well as to tokens, using slightly different syntax.andM;To give an idea of the complexity of the grammars, the grammar describing AWKuses 24 categories in 39 productions.andP;  The Ada grammar uses 40 categories in65 productions, and the C grammar uses 54 categories in 129 productions.andM;SPIDER-generated versions of TANGLE and WEAVE differ subtly from theoriginals written by Donald Knuth.andP;  The most important difference is thatSPIDER-generated WEB is not self-contained: where Knuth's Pascal WEB requiredonly a Pascal compiler to bring up, SPIDER would need a C compiler and an AWKinterpreter to generate a Pascal WEB, and a Pascal compiler for the resultingWEB to be of any use.andP;  Other differences are minor; fox example, Knuth'sTANGLE does arithmetic on constants at TANGLE time, but SPIDER-generatedTANGLEs do not.andP;  Knuth's TANGLE provides three different kinds of macros, butnone with more than one parameter; SPIDER-generated TANGLEs provide only onekind of macro, but macros of that kind may have from zero to thirty-twoparameters.andM;SPIDER is a WEB generator, akin to parser generators.andP;  Both read formaldescriptions of some part of a progamming language, and both produce codethat processes programs written in that language.andP;  Since both produce codethat is part of the &quot;compiler,&quot; using them does not introduce any extra stepsinto the processing of user programs.andP;  SPIDER itself is a large AWK script,written as a WEB program.andP;  spider.web is about 2600 lines long; about a thirdof these are comments.andM;The major cost of using SPIDER is the cost of learning yet another language.andO;Learning this language is supposed to substitute for learning how to modifyWEB, so it is probably not an exorbitant cost.andP;  Some other limitations arethe need for a C compiler and an AWK interpreter, and the need to use alowest-common-denominator lexical analyzer.andM;The major benefit of using SPIDER is the ease with which new WEBs can bebuilt.andP;  The SPIDER description of a language is much smaller than the WEBimplementation generated from that description, and SPIDER descriptions ofsimilar languages are similar.andP;  Using SPIDER one can build a WEB withoutunderstanding the details of WEB's implementation, and one can easily adjustthat WEB to change as a language definition changes.andM;SPIDER should make one literate programming tool, WEB, available to a muchlarger audience.andP;  I hope that, by separating the language-independent partsof WEAVES and TANGLE, SPIDER will encourage us not just to think about thatthe essence of tangling and weaving is, but also about what the essence ofliterate programming is.andM;Acknowledgments.andP;  I enjoyed many useful discussions of WEB with CharlieMills.andP;  I am grateful to Silvio Levy for providing his CWEB as the basis forthe &quot;master copies&quot;of TANGLE and WEAVE, and to Dave Hanson for comments on anearlier version of this paper.andP;  Odyssey Research Associates supported thedevelopment of SPIDER.andM;Norman Ramsey Department of Computer Science Princeton University Princeton,New Jersey 08544andM;REFERENCESandM;[1.] Bentley, J.L.andP;  Programming pearls.andP;  Commun.andP;  ACM 29, 5 (May 1986),364-368; 29, 6 (June 1986), 471-483.andM;[2.] Knuth, D.E.andP;  Literate programming.andP;  The Computer Journal 27, 2 (May1984), 97-111.andM;[3.] Levy, S. WEB adapted to C, another approach.andP;  TUGBoat 8, 1 (Apr.andP;  1987),12-13.andM;[4.] Oppen.andP;  D. Prettyprinting.andP;  ACM Trans.andP;  Program.andP;  Lang.andP;  Syst.andP;  2, 4(Oct.andP;  1980), 465-483.andM;[5.] Ramsey, N. Developing formally verified Ada programs.andP;  In Proceedings ofthe Fifth International Workshop on Software Specification and Design.andP;  (May1989), pp.andP;  257-265.andM;[6.] Van Wyk, C.J.andP;  Literate programming.andP;  Commun.andP;  ACM 30, 7 (July 1987),593-599; 30, 12 (Dec.andP;  1987), 1000-1010.andO;</TEXT></DOC>