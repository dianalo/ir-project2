<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF109-409-215  </DOCNO><DOCID>09 409 215.andM;</DOCID><JOURNAL>Hewlett-Packard Journal  June 1990 v41 n3 p59(10)* Full Text COPYRIGHT Hewlett Packard 1990.andM;</JOURNAL><TITLE>HP Encapsulator: bridging the generation gap. (the descriptionlanguage used in the HP SoftBench software development environmentto integrate existing tools)</TITLE><AUTHOR>Fromme, Brian D.andM;</AUTHOR><SUMMARY>The HP Encapsulator description language in HP's SoftBenchsoftware development environment is used to integrate existingtools in the environment, assuring consistency in the overalltoolset.andP;  The program supports customization and extension of theHP SoftBench environment for automating organization, team andpersonal software development processes using event triggers.andP;  HPEncapsulator translates commands, actions and presentation betweenexisting tools and the rest of the SoftBench environment; thisprovides a link to the SoftBench event trigger facility, anOSF/Motif-style user interface compatible with SoftBench, supportfor remote subprocess execution using SoftBench distributedexecution and access to the network-wide communication facility inSoftBench.andP;  No source code modification is needed, so tools forwhich no source code is available can be encapsulated.andM;</SUMMARY><DESCRIPT>Company:   Hewlett-Packard Co. (products).andO;Ticker:    HWP.andO;Product:   HP Encapsulator (Program development software) (design andconstruction)HP SoftBench (Program development software) (design andconstruction).andO;Topic:     Program Development ToolsIntegrated SystemsProgram Development TechniquesComputer-Aided Software EngineeringSoftware DesignCompatible Software.andO;Feature:   illustrationtable.andO;Caption:   Intermediate code stored in statement table. (table)Identifier references stored in symbol table. (table)andM;</DESCRIPT><TEXT>By means of the Encapsulator description language, a user can integrate toolsinto the HP SoftBench environment without modifying their source code, andcan tailor the HP SoftBench environment to support a particular softwaredevelopment process.andM;THE HP ENCAPSULATOR is the tool integration and process specificationfacility of the HP SoftBench environment.andP;  It allows an HP SoftBench user topromote existing tools to be fully consistent, integrated HP SoftBench toolsand to tailor the HP SoftBench environment to support a specific softwaredevelopment process.andP;  The HP Encapsulator provides customization andextension capabilities for automating organization, team, and personalsoftware development processes using event triggers.andM;Integrating Existing ToolsandM;The HP Encapsulator can handle a range of existing applications.andP;  It isdesigned to handle programs written in the style of programs for the UNIX'operating system, that is, programs that have a command-line interface totheir functionality.andP;  Examples of this sort of program are nearly all UNIXtools (tar, prof, adb), customer-developed scripts and utility programs, andmany third-party tools (e.g., McCabe's ACT, Verilog's Logiscope, Softool'sCCC, and SMDS's Aide-Camp).andM;From the user's point of view, an encapsulated tool looks and behaves just asthe core HP SoftBench tools do.andP;  In fact, one of the core HP SoftBench toolsis actually an encapsulation-the HP SoftBench mail tool is an encapsulationof the HP-UX tool mailx.andP;  This encapsulation will be described in more detaillater in this article.andM;The HP Encapsulator can be used either to add a new tool to the HP SoftBenchenvironment or to replace an existing HP SoftBench tool or anotherencapsulated tool.andP;  The HP SoftBench architecture is designed to facilitatethis substitution of tools.andM;Tool Encapsulation OverviewandM;Encapsulating a tool means integrating the tool into the HP SoftBench toolintegration architecture.andP;  The HP Encapsulator is the liaison between theexisting tool and the rest of the HP SoftBench environment.andP;  It plays therole of translator of commands, actions, and presentation.andM;Integrating a tool using the HP Encapsulator provides the following benefits:andM;*  Provides a link to the HP SoftBench event trigger facility.andM;*  Provides an HP SoftBench-compatible, OSF/motif-style user interface (seearticle, page 6).andM;*  Uses HP SoftBench distributed execution to support remote subprocessexecution.andM;*  Uses the HP SoftBench network-wide communication facility.andM;An important aspect of the HP Encapsulator is that no source codemodifications are necessary to the tool being encapsulated.andP;  This allowscustomers to integrate purchased tools for which no source code is available.andM;There are also some limitations of encapsulation that should be understoodbefore an encapsulation program is attempted.andP;  The HP Encapsulator onlysupports encapsulation of tools written in the UNIX command-line interfacemodel.andP;  Tools that have highly interactive or graphical user interfaces areoften not good candidates for encapsulation because the HP Encapsulatorcannot understand what the tool is doing or has done.andP;  User interfacepotential is also limited by output from the encapsulated tool.andP;  If the tooldoes not provide error messages or some sort of output stream (typicallystdout or stderr), the HP Encapsulator is constrained in its ability tointerpret what the tool has done.andP;  Another limitation is that eventgranularity for triggers and notifications-that is, the level of detail atwhich events can be specified-is only as fine as can be initiated andrecognized from the encapsulated tool.andP;  To achieve the same level of eventgranularity as the other HP SoftBench tools, each atomic operation needs aunique command-line interface.andM;The HP SoftBench Mall EncepsulationandM;Before the design details of the HP Encapsulator are described, asophisticated encapsulation will be presented to illustrate the concepts thathave been presented so far.andM;The encapsulation to be described is the HP SoftBench mail tool.andP;  This toolis provided with the HP SoftBench tool set, and most users are not aware thatit is an encapsulation rather than a native tool like the other HP SoftBenchtools.andP;  The HP SoftBench mail tool is actually an encapsulation of the HP-UXmailx program.andP;  The mailx program was not modified in any way.andM;Fig.andP;  1 shows the original terminal-based interface to mailx, and Fig.andP;  2shows the encapsulation.andP;  Before encapsulating, malix was not related orlinked to the other HP SoftBench tools in any way.andP;  The encapsulated version,on the other hand, has useful links to the other HP SoftBench tools.andP;  Forexample, the user can configure HP SoftBench mail to send a mail message tothe project team whenever a project build has completed successfully.andP;  Withthe HP Encapsulator, customers can customize the specific conditions andactions to meet their particular needs.andP;  Other EncapsulationsandM;Many other tools have also been encapsulated.andP;  Fig.andP;  3 shows theencapsulation of the HP-UX performance profiling tool prof(1).andP;  Fig.andP;  4 showsan experimental encapsulation of the Analysis of Complexity Tool for metricscollection and structured testing support from McCabe and Associates.andP;  Fig.andO;5 shows a trigger panel with which the user can configure the relationshipbetween the McCabe testing tools and the rest of the development environment.andM;Prototype encapsulations have been written for configuration management,documentation, testing tools, and language-based environments such as Lispand Ada.andM;Encapsulator Description LanguageandM;The Encapsulator description language (EDL) is a specification languagedesigned to simplify the task of describing an encapsulation.andP;  The primaryreason for encapsulating a tool into the HP SoftBench environment is to allowthat tool to make use of the HP SoftBench architecture, primarily thebroadcast message server and aspects of the distributed environment.andO;Therefore, these architectural features have been made accessible in EDL.andM;From the perspective of the encapsulation system, there are two maincomponents in an encapsulation: interfaces and actions.andP;  Interfaces areconnectors to the outside world, such as the window system or the HPSoftBench message system.andP;  Actions are the steps to be taken when certainconditions are met on an interface.andP;  EDL defines a set of interfaces and datatypes that link conditions in an interface to actions that the user providesto respond to that condition.andP;  The actions are EDL code to be executed.andM;EDL has conventional programming language constructs such as data types,variables, operators, flow-of-control clauses, and user-defined functions.andO;EDL also contains a rich set of built-in functions, which provide aprogrammatic interface into the HP SoftBench architecture as well as theunderlying window system.andP;  The EDL data types are string, integer, Boolean,attribute, event, and object.andP;  There are C-like operators that can be used toform expressions.andP;  There are two flow-of-control clauses: if and while.andO;User-defined functions can be used to group and define parameters for EDLstatements, but are most useful as actions for responding to conditions.andM;A programmer develops EDL code much as one would develop code in otherspecification-language-based environments, that is, by first entering the EDLsource text into a file, then invoking the HP Encapsulator over that file.andO;See page 67 for a description of how the HP Encapsulator executes the EDLcode.andM;InterfacesandM;Four interfaces are defined in the Encapsulator description language.andP;  Theyare the user, message, application, and system interfaces.andP;  The userinterface is the window system, the message interface is the HP SoftBenchbroadcast message server, the application interface is the encapsulatedprogram or subprocess, and the system interface is the operating system.andO;Conditions on an interface are called events.andM;An event is a data type in EDL.andP;  Events have three components, a type, apattern, and an action.andP;  The type defines the interface to which an eventcorresponds.andP;  The type specifier is the identifier or the name of theinterface.andP;  Thus the user interface has events of type user.andP;  The pattern isthe condition to be met on an interface.andP;  A pattern is a string thatidentifies either the name or the form of a condition.andP;  For example,application events use the HP-UX regular expression pattern matchingfacility, so the pattern is a string that describes a regular expression tothat pattern matcher.andM;An example should help clarify how an event is declared.andP;  This event willoccur when the encapsulated program mailx finds that there is no new mailavailable.andM;First, we declare an event variable.andM;event mailx_event;andM;Now we assign that variable a newly created application event.andP;  The eventcorresponds to the condition that mailx has written the text &quot;No mail forFromme&quot; to stdout (its standard output file).andM;mailx_event = make_event(Application, &quot;^No mail for(.*)$0\n&quot;,andM;no_mail($0));andM;Finally, we add this event into the list of active events.andM;add_event(mailx_event);andM;Events can be activated and deactivated via built-in functions in EDL.andP;  Thisallows the user to control which conditions can be met at a given time.andP;  Whenan event is defined in the user interface, that event must correspond to aparticular object in the window system.andP;  EDL objects will be explained inmore detail later.andP;  ActionsandM;Actions are the steps to be taken when certain conditions are met on aninterface.andP;  In the example above, the action to be taken when the regularexpression is matched is a call to the function no-mail().andP;  Actions can bearbitrary statements of EDL code.andP;  In use, however, actions are typicallycalls to functions that are defined by the user.andP;  This makes the declarationof an event more readable and more easily changed or configured.andM;For example, we will define the function no-mail(), which is to be calledwhen the HP Encapsulator sees the no-mail pattern from mailx.andP;  Note that theargument passed to the no_mail() function from the event is $0.andP;  This is theEDL syntax for the special string variables that retrieve portions of aregular expression.andP;  In this case, so will be the name of the user runningthe SoftBench mail tool.andM;/*This function is called when mailx tells us there is no new mailandM;function no-mail_user)andM;string user; {andM;/*Let the user know that there is no new mail in the mailbox*/andM;clear(headers);  /* Clear mail headers list */andM;freeze_button();  /* Make the buttons insensitive */andM;/* This is a local string variable that holds the dialog prompt string info =print_to_string(&quot;User %s has no new mail&quot;, user);andM;/* Now pop up the dialog box to inform the user */ error(information, info);andM;/* No need to return data from this function */andM;Notice that the action function calls other functions, some of which arebuilt-in EDL functions and some of which are user-defined functions.andP;  Thisexample shows how we have taken a condition from the terminal based mailxapplication and turned it into an information dialog box via a call to thebuilt-in EDL function error().andM;User interfaceandM;The user interface is the window environment in which a user can interactwith the encapsulation.andP;  Components of the user interface are referred to asobjects.andP;  An object is any visual device that conveys information between theuser and the program-examples are labels, buttons, menus, and editablefields.andP;  An object is also a data type in EDL.andP;  Objects are EDLrepresentations of physical entities on the screen.andP;  There are two types ofEDL objects: manager and primitive.andP;  Manager objects can control otherobjects while primitive objects cannot.andP;  The set of EDL manager objectsincludes Toplevel, Transient, Pulldown, and Pane, while the set of EDLprimitive objects includes MenuButton, MenuSeparator, Command, Label, Edit,List, Toggle, and image.andM;To define a user interface in EDL, one specifies the hierarchy of manager andprimitive objects that compose each window as EDL statements.andP;  The followingexample will create a window with two objects, a Label object and an Editobject.andM;First, we declare the window and its first pane, both of which are managerobjects.andM;object mail_window = make_manager(NULL, Toplevel,andM;&quot;MailWindow&quot;);andM;object pane = make_manager(mail_window, Pane, &quot;firstPane&quot;); Now we declarethe components of the pane, both of which are primitive objects.andM;object target_label make_object(pane, &quot;target&quot;, Label,andM;&quot;Target:  );andM;object target_value make_object(pane,  &quot;value&quot;, Edit,andM;get_context_file();andM;In this example, the elements of a Toplevel window have been described.andO;Manager objects are declared with the built-in EDL function make-manager(),while primitive objects are declared with the built-in EDL functionmake-objecto.andP;  The parameters of these built-in functions describeinformation about how to create such an object when the time comes, such asthe parent (or manager) of this object, the name, the type, and the label (orinitial value to be displayed within the object).andP;  Objects described in thisway are not created until their entire window is needed.andP;  This is achievedvia a call to the built-in EDL function display().andM;To take an action in the user interface, the user often presses the leftmouse key (mapped to the Select action) while the mouse cursor is over theobject that describes the action.andP;  To define the action in EDL, theprogrammer must associate a user event with a user interface object.andP;  Thus,each user interface object is associated with distinct events or actions.andO;Several objects can be associated with a single event.andP;  The following examplecreates three Toggle buttons and two events.andP;  A Toggle button is a userinterface object that represents either an on or an off state.andP;  The twoevents are used to determine when the user turns the button on and off.andM;First, we create two events that trigger actions for any of the three Togglebuttons.andM;event toggle_on = make_event(User, &quot;Select&quot;, toggle(True));andM;event toggle_off = mak_-event(User, &quot;Release&quot;, toggle(False));andM;Then we declare three Toggle button objects.andM;object a, b, c;andM;Notice that we pass both events to each of these objects.andM;a =  make_object(pane, &quot;a&quot;, Toggle, &quot;Me&quot;, NULL, toggle_on,andM;toggle_off);andM;b =  make_object(pane, &quot;b&quot;, Toggle, &quot;Myself&quot;, NULL, toggle_on,andM;toggle_off);andM;c =  make_object(pane, &quot;c&quot;, Toggle, &quot;I&quot;, NULL, toggle_on,andM;toggle_off);andM;This function handles both the on and the off states for these Togglebuttons.andM;function toggle(on)andM;boolean on;andM;{/* Get the object with which this event is associated */ object this-button =self();andM;/* If we selected one of these buttons, then release theandM;* others.andP;  This makes the buttons exclusive (only one canandM;* be set at any given time).andP;  */andM;if (on) {andM;/* Send the  Release&quot; event to all buttons but this oneandM;if (this-button != a) send_event(a, toggle_off);andM;if (this_button != b) send_event(b, toggle_off);andM;if  this_button != c) send_event(c, toggle_off);andM;}}This example defines a window object and its action.andM;Another aspect of the user interface is the appearance of an object, such aswidth, height, color, and character font.andP;  In EDL, these characteristics ofan object are referred to as attributes.andP;  An attribute is a data type in EDL.andO;There are two attribute operators: merge and associate.andP;  The merge operatoris used to combine a single attribute into a set of attributes called anattribute list.andP;  The associate operator is used to combine a value with anamed attribute.andP;  As can be seen in the following example, the WIDTHattribute allows an associated value, while the SINGLELINE attribute doesnot.andP;  The example illustrates the creation of a single-line, labeled,editable field of a certain width.andM;object label, edit;andM;attribute attr;andM;The following attribute merges a font description with a specified width andalso tells the Label object to put the text as far left as possible.andM;attr = FONT : &quot;hp8x16&quot; | WIDTH : 100 | LEFTJUSTIFIED;andM;label = make_object(pane,  dirLabel&quot;, Label,  Directory:&quot;,andM;attr);andM;The following attribute merges a font description with a specified width andalso tells the Edit object to restrict its view to a single line.andM;attr = FONT : &quot;hp8x16&quot; | WIDTH : 300 | SINGLELINE;andM;edit = make_object(pane, &quot;dirValue&quot;, Edit,andM;get_context_directory, attr);andM;Attributes are used to specify the appearance and behavior of user interfaceobjects.andP;  The example above shows their static use, that is, to specify theobject's behavior when first displayed.andP;  Attributes can be used dynamicallythrough the EDL built-in function add-atttibute().andP;  This allows theappearance of an object to change during execution of the encapsulation.andM;Message interfaceandM;The message interface is the programmatic access to a tool's functionality.andO;This interface is the connection to the broadcast message server and allowstools to communicate with one another, just as a user would interact with atool through the user interface.andP;  The messages that a tool can emit andreceive define the tool's message protocol.andP;  The HP SoftBench tools have apredefined message protocol.andP;  When a user encapsulates a tool, a new messageprotocol is defined.andP;  This protocol is called the tool class.andM;To define a new tool class, one must decide what functionality of the newtool should be accessible to other tools.andP;  Most often this is the samefunctionality that is available to the user via the user interface.andP;  Next,the developer must decide how other tools are to be passed informationspecific to each tool function.andP;  Typically, information that the userinterface receives by bringing up a dialog box can be received in the messageinterface as the data fields of a message.andM;There are several requirements that should be met for a new tool class tobecome a &quot;good citizen&quot; HP SoftBench tool.andP;  A notification message must beannounced whenever the tool successfully performs a function.andP;  A failuremessage must be announced whenever the tool attempts to perform a function,but does not successfully complete it.andP;  A request message must be acceptedfor each function that the tool is able to perform.andM;The message model allows tools to request other tools to attempt to performfunctions.andP;  Furthermore, because tools send out notification or failuremessages after attempting to perform a function, a tool can determine theresults of such a request.andP;  Thus, tool interaction can be either synchronousor asynchronous.andP;  For example, a tool may request that an edit of aparticular file be started, but may not care whether the editor can actuallyperform the task.andP;  On the other hand, if a tool requests that a file bechecked out of the version control system, it will need to know whether thatfunction can be performed before continuing with the current operation.andM;To facilitate handling arbitrary requests, the broadcast message serverdefines a simple pattern matching facility.andP;  This facility is accessiblethrough the EDL built-in function make-message-pattern().andP;  When messageevents are defined, the message patterns will be passed to the broadcastmessage server.andP;  These describe the forms of messages to be forwarded to theHP Encapsulator.andM;The following example describes the message interface for the simple toolclass EXAMPLE.andM;/* Define the tool class */andM;tool_class(&quot;EXAMPLE&quot;);andM;These are variables used in the message interface.andM;string pattern;andM;event plan, estimate;andM;This describes the PLAN request message.andM;Pattern = make_message_pattern(Request, NULL,  PLAN&quot;);andM;plan = make_event(Message, pattern, plan-request();andM;This describes the ESTIMATE request message.andM;pattern = make-message-pattern(Request, NULL, &quot;ESTIMATE&quot;);andM;estimate = make_event(Message, pattern, estimate_request();andM;Now we activate these events.andM;add_event(plan);andM;add_event(estimate);andM;These are the functions for the PLAN and ESTIMATE messages.andP;  The PLAN messagetakes two data parameters: the name and the engineer-months.andP;  The ESTIMATEmessage takes no data parameters.andM;function plan_request()andM;{string name, months;andM;/* Extract and check the data parameters  */andM;name = message_data(1);andM;months = message_data(2);andM;/* If these aren't passed, then its an error if  (!name || !month)protocol_error();andM;elseandM;/* Perform the PLAN request */ if (plan(name, month))andM;/* Succeeded */andM;send_message(Notify, NULL, &quot;PLAN&quot;, name, months);andM;elseandM;/* Failed */andM;send_message(Failure, NULL, &quot;PLAN&quot;, name, months);andM;}function estimate_request()andM;{/* Perform the ESTIMATE request */ if (estimate()andM;/* Succeeded */andM;send_message(Notify, NULL, &quot;ESTIMATE&quot;);andM;elseandM;/* Failed */andM;send_message(Failure, NULL, &quot;ESTIMATE&quot;);andM;}In this example, we have declared a tool class EXAMPLE and registered twopatterns with the broadcast message server, each of which has a function tohandle the request when the corresponding message is forwarded to the HpEncapsulator.andP;  The functions check that each message has the appropriate dataand call other functions to attempt the requested action.andP;  If the actionssucceed, then a notification message is sent to the broadcast message server.andO;Otherwise, a failure message is sent.andM;By knowing the message protocols of a tool, one can use the HP Encapsulatorto:andM;* Create a tool that interacts with other HP SoftBench tools.andM;* Create a tool that drives other HP SoftBench tools.andM;* Create a tool that replaces an existing tool (substitution).andM;* Create agents.andP;  Agents are tools that orchestrate other tools to performtasks.andM;Tool TriggersandM;A trigger is a cause-effect relationship between tools.andP;  In the HP SoftBenchenvironment, a trigger occurs when a notification or failure message is sentfrom one tool and one or more other tools respond to that notification bytaking some new action.andP;  For example, when a file is saved from any tool, theHP SoftBench development manager tool will update its directory listing, ifneeded.andP;  This is a predefined trigger in the HP SoftBench environment.andM;The HP Encapsulator allows the user to define two types of triggers; thosethat take action in a tool and those that request some third tool to take anaction.andP;  The HP SoftBench development manager example above is a trigger thattakes action in a tool.andP;  The following code is an example of a trigger thatrequests a third tool to take an action.andP;  It listens for a notificationmessage from the development manager and asks the HP SoftBench programbuilder tool to attempt a build.andM;When we see a VERSION-UPDATE-DIR message notification, send out aBUILD-TARGET request.andM;event trigger;andM;string pattern;andM;This pattern and event describe the message to be seen.andM;pattern  make-message-pattern(Notify, &quot;DM&quot;,andM;&quot;VERSION-UPDATE-DIR&quot;);andM;trigger = make_event(message, pattern, request_build();andM;add_event(trigger);andM;This function requests that a build be started when an update of the versiondirectory is done in the development manager.andM;function request_build()andM;{/* convert a wildcard for directory to a nil */andM;string mfile = message_file();andM;if (string-compare(mfile,  &quot;*&quot;')) mfile = &quot;-&quot;;/*  MessageandM;* server nil */andM;/*  Get the current context */andM;host = get_context_host();andM;dir = get_context_directory();andM;/* Now set the context from the incoming message */andM;set_context(message_host(), message_directory(), mfile);andM;/* Send the request to the BUILD tool class */andM;send_message(Request, &quot;BUILD&quot;, &quot;BUILD-TARGET&quot;,&quot;:-&quot;,&quot;-&quot;,&quot;-&quot;);andM;}The ability to define triggers allows the user to customize the HP SoftBenchenvironment to meet process-specific needs.andP;  The following section describesthe benefits of userdefinable triggers.andM;Process IntegrationandM;One of the promising new areas in software engineering environment researchhas to do with providing automated support for the user's softwaredevelopment process.andP;  The HP Encapsulator is one of the first products toprovide a language for describing local organizational, team, and personalprocesses.andP;  We refer to an EDL program that supports a user's developmentprocess as a process specification, and we refer to this type ofenvironmental support as process integration.andM;Process SpecificationsandM;While not all development processes are amenable to being described with EDLprocess specifications, most can have at least some aspects automated.andP;  Inparticular, activities and tasks that are essentially event-driven are primecandidates for automated support.andM;The author of an EDL process specification tells the HP SoftBench environmentwhat to do when specific events occur.andP;  There are two keys to the successfulimplementation of EDL process specifications.andP;  First, the notificationmessage events must be announced so that the proper actions can be triggeredby the EDL process specification.andP;  All HP SoftBench tools and all properlyencapsulated tools issue these notification messages.andP;  Second, when a triggerin an EDL process specification occurs, the resulting action needs to be ableto control other tools in the environment.andP;  All HP SoftBench tools and allproperly encapsulated tools provide this by means of the message-basedinterface to their functionality.andM;As an example of an EDL process specification, the following team processcould be automated:andM;* Whenever a team member checks a file into the master source file repository(directly or indirectly through the development manager or a substitutedconfiguration management system supporting the DM versioning command class),with a state having the value Release, cause complexity metrics to becalculated.andM;* If the complexity metrics for the file are not acceptable as defined by theteam, create a metrics report detailing the unacceptable functions, and mailit to the user.andP;  Also notify the user of the problem via a Warningnotification box.andM;* If the complexity metrics for that file are acceptable, cause a tapearchive to be created.andM;* When the tape archive has been successfully made, cause a mail message tobe sent to the project team announcing a new release.andM;It is important to realize that each team member may have slightly differentversions of the above specification, for very legitimate reasons.andP;  Forexample, a software quality assurance engineer team member might want to takeaction when a metric is found to be unacceptable.andM;Linking Events and ActionsandM;Linking BP SoftBench Tools.andP;  Every action of every HP SoftBench tool providesthe hook needed for that action to act as a trigger for other actions.andP;  Bydefault, certain actions are predefined, such as the view synchronizationthat causes tools to know when the files they are displaying becomeout-of-date so that the user can be informed.andP;  With the HP Encapsulator, theuser can define additional triggers for situations where actions need to beautomatic.andP;  For example:andM;* When a file is checked out, cause the editor to display it automaticallyfor editing.andM;* Cause a file to be checked in whenever it has been saved from the editor.andM;* Cause a build to be initiated whenever a file is checked in.andM;* Cause the debugger to reload automatically whenever a build is successful.andM;* Cause the static analyzer to update its data base whenever a build issuccessful.andP;  Linking HP-UX Tools.andP;  The HP Encapsulator can be used toencapsulate and link UNIX tools.andP;  For example:andM;* Encapsulate the tape archiver (tar) and cause tape backups to be madewhenever a release is built.andM;* Encapsulate the job scheduling commands (at or cron) and cause builds torun at night.andM;* Encapsulate the source analysis program (lint) and cause it to analyze afile automatically when it has been checked into version control or savedfrom the editor.andM;* Encapsulate the source file printing programs (pr, lp) andandM;cause listings to be printed whenever a project release is made.andM;*  Encapsulate the performance display programs  prof, gprof) and cause theperformance data to be displayed after the program has been executed.andM;*  Encapsulate the symbol searching program (nm) to identify libraries thatmust be added to the library list when the linker finds symbols it cannotresolve.andM;*  Encapsulate the control flow program (cflow) and cause the output to bedisplayed whenever a file is checked into version control.andM;Linking Local Tools.andP;  After visiting several large customer installations andpresenting the ideas and capabilities of the HP Encapsulator, it became clearthat an important source of tools to encapsulate and processes to automatewould be local tools developed on site.andP;  Examples of some of the more commonencapsulations and process specifications are: n  Encapsulate local metricscollection tools and causeandM;them to process the files when they have been checkedandM;into version control.andP;  n  Depending on the nature of the local projectmanagementandM;tools, cause them to do their processing whenever a releaseandM;is made or when a file is checked in.andP;  n  Depending on the precisecapabilities and structure ofandM;the defect tracking mechanisms, cause the defect resolutionandM;component to prompt for its data whenever a newandM;local build is successful or whenever a file has beenandM;checked out or in.andP;  Linking Target Machines.andP;  When developing for a remotetarget machine, there is typically a great deal of manual interventioninvolved in transferring the application to the target computer and buildingand testing it there.andP;  Assuming there is some basic file transfer and remotejob entry capability from the host to the target system, then using theremote execution capability of the HP SoftBench environment and theEncapsulator, the cross-development process could be improved as follows:andM;*  Whenever a file is checked into version control on the development system,cause it to be copied automatically to the remote target.andM;*  When a build is requested, optionally cause it to execute on the targetcomputer (typically running make or any local compile mechanisms, such as abatch job).andM;*  Encapsulate the job control facility on the target system and cause buildsand tests to be run there, initiated from the local system.andM;*  Encapsulate any test scaffolding on the target system and run tests of theapplication on the target system under the control of the local developmentmachine.andM;*  Encapsulate any performance measurement facilities available on the remotetarget and monitor performance behavior remotely.andM;Linking Events with People.andP;  Perhaps the most important form of link is theconnection between people-individuals and the team-and important events.andP;  Thedefinition of an important event likely varies as the development projectprogresses.andP;  This is why the ability to change this definition frequently andfrom user to user is an important capability of the HP Encapsulator.andP;  Sometypical triggers for coordinating teams are: N Send mail to the projectleader when files are checked out.andM;Send mail to the project team when a new version of a common include file ischecked in.andM;Send mail to the project team when a successful system build completes.andP;  Sendmail to the project team when a system build fails.andM;Send mail to the project team when a new release is made.andM;Send mail to the project team when weekly static analysis data is available.andO;Use encapsulated write(1) or talk(1) to initiate interactive discussion ofchanges when an include file is checked in.andP;  Initiate an announcement tool(e.g., news or notes) to inform the team of a new release.andM;Process Specifications in the FutureandM;The examples given above show the types of process specifications that can bedesigned to assist with software development tasks and to link tools,computers, and people.andM;EDL process specifications are among the most interesting applications thatexploit the HP SoftBench tool integration architecture.andP;  The technology isquite new.andP;  More data needs to be gathered on the types of EDL processspecifications that users write and how much of their process they wish andare able to automate.andM;Languages in general are difficult to design.andP;  Special-purpose specificationlanguages are often more difficult since they are breaking new ground andtrying to express new ideas.andP;  EDL is a language used for specifying both toolencapsulations and process specifications.andP;  However, its design leans towardsexpressing those concepts necessary for integrating a tool.andP;  In certain casesit feels awkward writing a process specification with EDL.andP;  Language designfor process specification languages is a current research topic being pursuedat several university and industrial research labs and ongoing progress inthis area is sure to be seen.andM;HP Encapsulator ImplementationandM;The Encapsulator description language is a special-purpose specificationlanguage.andP;  It is implemented by means of a compiler and an interpreter.andP;  Thecompiler is responsible for parsing an EDL input file and generatingintermediate code.andP;  The interpreter is responsible for the execution of thatintermediate code.andP;  The HP Encapsulator is the development environment forproducing EDL code.andP;  The HP SoftBench environment contains a portion of theHP Encapsulator, which is the run-time environment for executing compiled EDLcode.andP;  This allows HP SoftBench and the HP Encapsulator to be two separateproducts.andP;  Users wishing to develop EDL code can do so with the HPEncapsulator and can deliver the production EDL code in binary form to any HPSoftBench system.andM;CompilerandM;The compiler is responsible for generating intermediate code from the user'ssource file or file8.andP;  It does this in two passes.andP;  The first pass is aninvocation of the C preprocessor over the EDL source file.andP;  This allows theprogrammer to make use of C preprocessor constructs such as macros, includefiles, and conditionally compiled code.andP;  The second pass invokes a parserover the preprocessed source code.andP;  The parser scans the input source codeinto tokens, recognizes and stores symbols, and forms productions.andO;Productions are groups of tokens that form an EDL statement.andP;  When aproduction is formed, intermediate code can be generated.andP;  The scanner andparser were produced from the HP-UX tools lex and yacc, respectively.andP;  Thesetools accept descriptions of tokens and grammars and generate the source codefor the scanner and parser components.andM;Symbols are identifiers such as variable names within the source program, andare stored in the symbol table.andP;  The symbol table is used to recordinformation about each symbol, such as its type, value, printable name, andfunction address, and whether it represents a function.andP;  Because there areoften many symbols in an EDL program, a hashing algorithm is used to makesymbol lookup more efficient.andM;Intermediate code is generated by the compiler and stored in the statementtable.andP;  The statement table has three components: the tag, the head, and thetail.andP;  The tag identifies the current instruction or operator.andP;  The head andtail refer to the left and right operands of the current instruction,respectively.andP;  The following is an example of the code generated by thesimple EDL statement, &quot;assign the variable X the value Y plus 10.&quot;andM;/* Here are the declarations of the integer variables.andP;  TheseandM;* two symbols are stored in the symbol table.andP;  No code is generated */integer X, Y;andM;/* Here's the assignment statement for which code is generatedandM;*  (below) */andM;X = Y + 10;andM;Table IandM;Iintermediate Code Stored in Statement TableandM;Tag                      Head                   TailandM;(1) Symbol            Symbol Index of x      NULL pointerandM;(2) Symbol            Symbol Index of Y      NULL pointerandM;(3) Integer Constant  10                    NULLpointerandM;(4) Plus              Pointer to stmt 2      Pointer to stmt 3andM;(5) Assignment        Pointer to stmt 1      Pointer to stmt 4andM;Table IIandM;Identifier References Stored in Symbol TableandM;Name              Type            Value         FunctionandM;Pointer to X       Integer             0             NoneandM;Pointer to Y       Integer             0             NoneandM;Table I is the statement table representation of the intermediate codegenerated from the assignment example.andP;  The intermediate code organizationand symbol table were modeled after interpreters for lambda calculuslanguages.' The variables referenced in this example have their symbol tableindexes stored in the symbol table, as shown in Table II.andP;  These indexes arereturned from the hashing algorithm during parsing and allow fast variablevalue lookup and assignment during evaluation.andM;InterpreterandM;The interpreter is responsible for the execution of intermediate code.andP;  Theinterpreter is referred to as a recursive evaluator because it looks at thetag of a statement in the statement table and then calls itself (recursively)to evaluate both of its operands (the head and the tail).andP;  The result ofcalling the evaluator is a typed value.andP;  That value can be used as part of anexpression or statement.andP;  Here is the pseudocode for the evaluator:andM;/* Pseudocode for the recursive evaluator, called eval() */andM;procedure eval( statement_pointer)andM;/*  eval() takes a single argument, a pointer to a new statement */andM;{/* For each operator there is a particular section ofandM;* evaluator code  */andM;switch (on tag of statement) {andM;case OPERATOR1:andM;/* Code specific to handling operator1...*/andM;break;andM;caseandM;OPERATOR2:andM;/* Code specific to handling operator2...andP;  */andM;break;andM;/* and so on for all operators */andM;} /*  End of operator specific handling code */andM;/* Now return the result of the operation  */andM;return result;andM;}Each case of the evaluator has code specific to executing the specifiedoperator.andP;  If that operator has operands, they will be stored in the head andtail of the current statement.andP;  In the example described above, theassignment operator has two operands.andP;  The head is the left-hand side of theassignment statement, which is the variable reference in which to store theresult of the assignment.andP;  The tail is the right-hand side of the assignmentstatement, which is the expression Y + 10, itself a separate operation in thestatement table.andM;Other ComponentsandM;Other essential components of the HP Encapsulator implementation include thebroadcast message server, event handler, and pattern matcher interfaces, theEDL built-in functions, the compile-time and run-time stacks, and thedump/load facility.andM;Of these components, the dump/load facility has the most significant productimplications.andP;  This facility allows the developer to compile an EDL programinto a binary format.andP;  This has two effects.andP;  It makes the subsequent loadingof the EDL code much faster and it allows the HP Encapsulator to have arun-only version.andP;  This run-only version is bundled into the HP SoftBenchproduct.andP;  Thus, an EDL developer can use the Encapsulator to implement anencapsulation program and can deliver that encapsulation to any HP SoftBenchinstallation.andP;  The run-only version of the HP Encapsulator is implemented byremoving the code modules that handle source code parsing, adding anintermediate code relocation module, and restoring code from a file intotables in memory that the HP Encapsulator can interpret.andP;  The term relocationrefers to the task of relocating an address in the code file into an addressin memory.andM;AcknowledgmentsandM;I would especially like to thank Martin Cagan for his continued enthusiasmfor an often controversial piece of software.andP;  It was his early use,inspiration, and guidance that helped create the HP Encapsulator.andP;  I wouldalso like to thank the development team-Elizabeth Carpenter, HillaryDavidson, Gary Fritz, Nancy Kirkwood, and Lisa Rogers for helping make the HPEncapsulator a product.andP;  Special thanks goes to the HP SoftBench mailteam-Bob Desinger and Nick Baer-for implementing the most advancedencapsulation we have to date and for contributing to the success of the HPSoftBench product.andP;  Finally, thanks to Bill Campbell for teaching me thebeauty of interpreters and to my wife, Cathy, for never tiring of the term&quot;encapsulation.&quot;andM;ReferenceandM;1.andP;  A. Church, &quot;The Calculi of Lambda-Conversion,&quot; Annals of MathematicalStudies, Vol.andP;  6, Princeton University Press, 1941.andM;BP Encapsulator CASE Case StudyandM;Frederick Brooks wrote: &quot;Plan to throw one away; you will, anyhow.&quot; The daybefore the U.S.A.andP;  announcement and demonstration of the HP SoftBenchenvironment, we threw away the mail tool.andP;  Work began immediately to rewriteit almost completely, using ideas we had learned from the previous effort.andO;This time, instead of writing an entirely new mail program, our approach wasto use the HP Encapsulator to encapsulate the HP-UX mail program mailx.andM;Why Another Maller?andM;There were several reasons for writing yet another mail program:andM;* Provide a bridge from HP SoftBench messages to mail messages.andP;  When aparticular HP SoftBench message is sent, a software developer might want tosend mail to notify the team, the developer, or others.andP;  This would beespecially true for processes that run unattended or at night.andM;* improve the user interface.andP;  Most mailers that run under the X WindowSystem have a human interface best described as nonideal.andP;  Some confuse newusers with clutter, some require a lot of customization, and some are hard tomaintain in a changing environment.andP;  HP SoftBench mail tries to provide abetter user interface.andM;* Teach the HP Encapsulator language by a nontrivial example.andP;  We wantedfuture developers to learn advanced techniques by studying the code and itscomments.andM;* Fine-tune the HP Encapsulator.andP;  The new technology of the HP Encapsulatorneeded to be used to get it ready for commercial use.andM;* Improve the usefulness of the HP SoftBench environment.andP;  Studies show thattechnical users buy a computer to solve important or costly problems likesoftware development, not for office automation tasks like mail.andO;Nevertheless, they expect the manufacturer to provide a mail system.andM;Using the EncapsulatorandM;The Encapsulator description language (EDL) is a new language.andP;  A newlanguage allows one to sail the seas of new higherlevel ideas, exploreuncharted waters of new constructs, and breeze past the rocks of low-leveldetails so prominent in such libraries as the X toolkit.andP;  However, newlanguages usually include a new paradigm-a new way of thinking about theprogramming problem.andP;  This is certainly true for EDL.andM;Encapsulating a complex tool like the HP-UX mailx application has itschallenges, too.andP;  As we progressed on the rewrite, we learned more aboutmaiix that caused us to modify our design.andP;  For instance, the code to managefolders was rewritten twice as we learned subtle interactions in the way thatmailx handles folders.andP;  Even though we did have access to the source filesfor mailx, we looked at them only once-to discover that we couldn't find theanswer in the code! it turned out to be much easier simply to set upconditions, run mailx in a terminal window, and observe its behavior.andP;  On theother hand, encapsulating an existing program is code reuse at its best.andO;Someone else had already solved hard problems of mail delivery, foldermanagement, alias creation, message presentation, and so forth.andP;  Toparaphrase isaac Newton, HP Softbench mail sees farther than its predecessorsbecause it is standing on the shoulders of the giants that already providedpart of the solution.andO;</TEXT></DOC>