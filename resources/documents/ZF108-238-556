<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-238-556  </DOCNO><DOCID>08 238 556.andM;</DOCID><JOURNAL>Computer Language  March 1990 v7 n3 p67(6)* Full Text COPYRIGHT Miller Freeman Publications 1990.andM;</JOURNAL><TITLE>Four principles of user interface design. (tutorial)</TITLE><AUTHOR>Cornish, Merrill.andM;</AUTHOR><SUMMARY>User interfaces have become more intuitive at the same time thatprogrammers are learning to construct programs in a manner thatallows changing an existing user interface or enhancing anapplication's internal functionality without either one adverselyimpacting the other.andP;  This new approach to user interfaceprogramming is designated a user interface management system(UIMS).andP;  A UIMS is based on a number of principles.andP;  Theseprinciples include the writing of an application's user interfaceby an interface builder utility as a standalone program that has aspecific look-and-feel provided by a predefined toolkit that usesa hardware-independent virtual interface to draw on the screen.andO;Each of these principles is examined in some detail.andM;</SUMMARY><DESCRIPT>Topic:     Programming InstructionTutorialUser InterfaceProgram Development Techniques.andM;</DESCRIPT><TEXT>Four Principles of User Interface Design Writing a user interface used to beeasy.andP;  If you wanted input, you displayed Aandgt; and waited for your user.andP;  Ifthe input displeased you, you displayed some options--Abort, Retry,Fail?--and waited some more.andM;Nowadays, the user interface has become a real hassle.andP;  The old religableglass TTY has been replaced by windows, icons, color, and mice.andP;  Previouslydocile users are asking impertinent questions such as &quot;Why abort?&quot;andP;  &quot;Retryhow?&quot;andP;  &quot;What failed?&quot;andM;The apperance of the user interface is up to you.andP;  But you can still programyour design so today's user interface won't drag down tomorrow's use of yourapplication.andM;Problems, problemsandM;Most of us don't set out to write a user interface.andP;  Usually, we have someapplication in mind and the user interface is a necessary evil...or it usedto be.andP;  For example, do you think the Turbo C and Quick C compilers would beas popular if all they had was a command-line interface?andP;  Could they havemade it just as bing as their speed and functionality alone?andM;Next question: is designing one good user interface enough?andP;  What happens if:andM;* You design an intricate graphical interface--and then you must move to asystem with a different graphics card?andM;* You design a highly interactive graphical interface--and someone wants touse your application over a dial-up line in TTY mode?andM;* You research and patiently field-test a custom graphical interface--andyour customers say they want to standardize on the look-and-feel of, say,Microsoft Windows?andM;* You carefully follow the application programming interface of Windows--andsomeone wants to use your application under OS/2 or the Macintosh?andM;* You design a fully integrated user interface--and someone wants to use justthe functionality of your application inside their own application?andM;While one good user interface may be required to gain initial acceptance ofyour application, the same user interface may later limit wider acceptance(and profits).andM;Good programming practices such as structured programming, data hiding, andfunctional modularity are just as valuable in programming a user interface asanywhere else.andP;  However, none of these techniques can help with the precedingproblems.andM;A maturing artandM;in days gone by, PC application writers prided themselves on innovative andoccasionally gimmicky user interfaces.andP;  The boot screen of some of theseapplications had the look-and-feel of an arcade game running in attract mode.andM;This uniqueness for the sake of uniqueness wasn't particularly objectionablebecause of the one-at-a-time nature of single-tasking PC operating systems.andO;The user was working in the private world of an application and often stayedin that world for an entire session at the computer.andP;  Nevertheless, the artof building user interfaces is maturing.andM;On one hand, the human-factors people have made great strides toward moreintuitive user interfaces.andP;  For example, they have shown that a good desktopmetaphor can deliver more of the system's functionality to new users fasterthan just about any command-line interface.andM;On the other hand, we are just now learning how to construct our programs sowe can change an existing user interface or enhance the application'sinternal functionality without either one mucking up the other.andP;  This newapproach to programming a given user interface design has the somewhatinflated name &quot;user interface management system&quot; (with its obligatoryabbreviation, UIMS).andP;  User interface management encompasses several more orless independent principles:andM;* An application's user interface is written as a stand-alone program.andM;* The user interface program uses a predefined toolkit to give its screens aparticular look-and-feel.andM;* That toolkit uses a hardware-independent virtual interface to draw on thescreen.andM;* The user interface program is itself written by an interface builderutility.andM;When modularity isn't enoughandM;The first of these interface management principles states that the userinterface should be in its own stand-alone program, but that sounds a bitextreme.andP;  Why aren't good old-fashioned modular programming and data hidingenough?andP;  Consider the following example.andM;Let's assume you took particular care in implementing your application tomake the sreen manager (and therefore the look-and-feel) modular.andP;  A typicalexchange between your application proper and its screen-manager functionsmight go as follows:andM;&quot;Screen manager, display the predefined menu named TOP and let me know whatthe user selects.&quot;andM;&quot;The user selected item 5, which is FILE MAINTENANCE.&quot;andM;&quot;OK, display the predefined menu named FILE OPERATIONS and tell me what theuser selects.&quot;andM;&quot;The user selected item 3, DELETE FILE.&quot;andM;&quot;Now, prompt for a file name.&quot;andM;&quot;The user entered C:\DOC1\UIMS.BAK.&quot;andM;At this point, your application would call an operating system function todelete the specified file.andM;This all sounds fine.andP;  You've designed your application so it doesn't knowhow the screen manager is presenting the questions to your user.andP;  Pop-upwindow?andP;  Pull-down menu?andP;  Text prompt?andP;  Neither does your application knowhow the user made the choice.andP;  Cursor keys?andP;  Mouse click?andP;  Keyboard input?andO;The menus are externally defined, so the layout, wording, and help messagescan be changed at will.andP;  Everything about the screen I/O is independent ofthe application except, of course, the order in which the questions areasked...but how hard could that be?andM;Well, what if you needed to substitute a Macintosh-like icon interface inplace of this meny hierarchy?andP;  Now if your users want to delete a file, theyclick on the appropriate file icon and drag it to the trash can.andP;  They haveprovided the same information to this icon interface as to our hypothericalmenu interface.andP;  By pointing at a FILE ICON, they indicate they want to doFILE MAINTENANCE.andP;  By dragging that icon to the trash can, they indicate theywant to delete a file.andP;  And by pointing at the UIMS.BAK file icon, theyindicate which file they want to delete.andM;In the end, your application would have made the same system call with thesame file name to delete the file.andP;  But there's a mismatch here.andP;  Yourapplication assumes that it initiates all actions by first displaying the TOPmenu.andP;  The new look-and-feel assumes that the user initiates the action byusing icons already displayed on the desktop.andM;Whe we look more closely at this &quot;modular? application, we see that isassumes a ping-pong dialogue with the screen manager.andP;  During that time, theapplication works its way through an internal decision tree to a leaf that inthis case, is a delete file system call.andP;  The new look-and-feel assumes thatall pertinent information is presented to the application in one chunk,Delete file C:\DOC1\U1MS.BAK.andM;Simple modularity isn't enough if we tacitly assume the application is thedriving force in an interactive program.andP;  We can hide the data.andP;  We can hidethe screen I/O.andP;  But if the application drives the interaction, weunavoidably hardcode patterns of interaction.andM;Wagging the dogandM;If strict modularity isn't enough, we must arrange for the tail to wag thedog: the user interface must drive the application.andP;  When a user boots your&quot;application,&quot; he or she is really booting your user interface program.andP;  Asthe user interface program finds out which application function is desired,the user interface calls that function and returns to wait on the nextaction.andM;In this scenario, the once all-powerful application is reduced to somethingakin to a function library.andP;  The functions in such a library tend to be thesame ones that would have been at the leaves of the user dialogue decisiontrees implied by our meny example.andP;  The main user interactions stillinitiated by the application are error messages and other exception handling.andM;Given this approach, swapping a high-performance graphics interface for adial-up glass TTY interface is simply a matter of writing a different userinterface program.andP;  This new program, however, calls exactly the sameapplication function library as before.andP;  You are free to customize your userinterface with impunity.andP;  Similarly, it is no problem to provide aprogrammatic function call interface to your application since that's theonly interface to your application's functionality.andM;On a pessimistic note: if you are careful to separate your user interface outinto its own program, you can afford to make more mistakes.andP;  If you pick thewrong look-and-feel, assume the wrong graphics adapter, find your interactiveapplication must run in batch mode, you can correct the problem without firsthaving to unravel your application to weave in another user interface.andM;Looking good, feeling goodandM;The second user interface management principle assumes that you buy yourapplication's look-and-feel off the shelf by using a predefined userinterface toolkit.andP;  Buying someone else's subroutine library doesn't soundlike much fun.andP;  Where's the creativity in that?andM;Again, the problem is maturity.andP;  As the software industry matured, certainmarketing points began to emerge.andP;  Improved functionality, robustness, andcompatibility sell more software than user interfaces that sell uniquenessfor the sake of uniqueness.andP;  And a good utilitarian interface alreadyfamiliar to the users sells more software than a unique interface handcraftedfor the application.andM;Nowadays, users want to use the application rather than experience thewonders of yet another flashy user interface.andP;  The goal is not monotony, butconsistency.andM;A new-car buyer can test-drive any car on the lot with no more than a word ortwo of explanation from the salesperson.andP;  Cars vary widely in size, cost,luxury, dependability, style, snob appeal, and most other measures.andP;  But youcan still be reasonably certain of finding the same steering wheel, gearshift, accelerator, and brake pedal in the same place in all cars.andP;  Thiscommon look-and-feel allows anyone to drive any car while still allowingworldwide competition among automobile manufacturers.andM;The notion of a common look-and-feel is relative.andP;  If you only want a commonlook-and-feel among your own applications, simply use the same screen managerlibrary in each of your user interface programs.andP;  A common screen managerlibrary, regardless of its source, is sufficient.andM;If, however, you want to establish the look-and-feel of one of the standardinterfaces such as Windows, Motif, or Open Look, it is mainly a matter ofwriting a user interface program for each, using the appropriate toolkit andfollowing suggestions from its style guide.andP;  Several products on the marketeven purport to allow one user interface program to assume several differentoutward appearances depending on which run-time library is linked in.andM;Actually, using someone else's look-and-feel isn't much of a strait-jacket.andO;Many of the appearance features addressed by the standard interface applyonly to the edges of the windows, so to speak.andP;  These standards control howyou scroll a window or what a menu bar looks like.andP;  Similarly, menuappearance and item choice are defined by the standard, but you still choosethe type of menu, when and where it appears, how its items are labeled, andwhat they do.andP;  Otherwise, what goes on inside those windows is mostly up toyou.andM;Ties that bindandM;Having the freedom to do just about anything you want inside yourapplication's window unfortunately means you are also free to hopelessly tieyour application to one vendor's graphics hardware, which brings us to thethird interface management principle.andP;  PC programmers are well acquaintedwith graphics standards.andP;  After all, we have so many to choose from.andP;  Part ofthe confusion in PC graphics cards is that the so-called standards don'tconcern graphics as much as pixel counts.andM;The most obvious differences among CGA, EGA, VGA, and their friends is thenumber of rows and columns of pixels.andP;  If you designed your application for a640X480 landscape monitor and you now want to run it on a 480X640 portraitmonitor, you are controlling the same number of pixels but would need yetanother &quot;standard.&quot;andP;  (Do you think we may have tied ourselves a bit tooclosely to fickle hardware?)andM;If your application is designed to run under the more sophisticated windowingsystems of the UNIX workstations, the vendor's screen-management softwarewill insulate you from such details as pixel counts and aspect ratios.andP;  Butat the same time, you are tried to that vendor's software...or at least youused to be.andP;  Nowadays, we have an attractive, vendor-independent windowingstandard, X Windows, from Massachusetts Institute of Technology.andM;The idea is that if your application has been written to manipulate onevendor's X Windows, your application can manipulate any vendor's X Windows.andO;Many vendors support X Windows, including virtually all UNIX workstations.andO;An added attraction of X Windows is that whatever your application candisplay on the local screen, it can display on a screen across the network.andO;It is now practical to implement an interactive application in the form of anetwork server.andM;The X Windows standard does not itself impose any particular look-and-feel.andO;Instead, the toolkit you use determines the look-and-feel of your windows.andO;Most commercially available look-and-feel toolkits are X Windows.andP;  Amongother things, the combination of X Windows and toolkits allows applicationsrunning in different windows on one monitor to have different look-and-feelcharacteristics.andP;  Therefore, your X Windows application could establish itsown look-and-feel independent of other applications on the system, if it wereso inclined.andM;Toward a full UIMSandM;Say you took these user interface principles to heart.andP;  You carefullyseparated your application from its user interface program and used astandard toolkit to establish your application's look-and-feel.andP;  After youhave written user interface programs for a number of applications, you'regoing to notice something: you seem to be doing a lot of the same things overand over.andM;All interfaces are different, of course.andP;  They have different menus,different choices, different messages, and so on.andP;  But the user interfaceprograms themselves have a suspiciously similar structure.andP;  Before too long,a general-purpose, table-driven user interface program will begin to suggestitself.andP;  Or if a table structure is too...structured, you might hit upon theidea suggested by the fourth interface management principle.andP;  Instead of atable, define a simple user interface declaration language that is turnedinto an executable user interface program by a translator or directlyexecuted by an interpreter.andP;  (All programmers secretly yearn to design theirown languages, right?)andM;These user interface declaration languages represent the culmination of theuser interface management movement.andP;  On one hand, these languages furtherlimit your creativity.andP;  If the language is simple and easy to use, itprobably offers less than the full power of the toolkit you have chosen.andP;  Onthe other hand, these languages are easy to use -- very easy compared tocoding and compiling a full user interface program from scratch.andM;Your application benefits from this easy construction of alternate userinterfaces in two ways.andP;  First, during initial design, you can experimentwith many more alternatives (and polish your final choice) far more than youcould ever have done with hand-coded user interface programs.andP;  Second, if youpackage the user interface declaration interpreter with your application, youcan actually allow your users to define their own interfaces to yourapplication.andM;A user-definable interface will not be of much interest to the casual user,but power users will appreciate the ability to customize your application totheir needs.andP;  At the other end of the scale, corporate users and OEMs willappreciate the capability of making your application fit into theirenvironments.andM;If you adopt the programming techniques described here, you should be able totame your user interface long enough to get more work done on your originalapplication.andM;Merrill Cornish is a member of the group technical staff at TexasInstruments.andO;</TEXT></DOC>