<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-624-578  </DOCNO><DOCID>08 624 578.andM;</DOCID><JOURNAL>Communications of the ACM  July 1990 v33 n7 p69(22)* Full Text COPYRIGHT Association for Computing Machinery 1990.andM;</JOURNAL><TITLE>An introduction to Prolog III.andO;</TITLE><AUTHOR>Colmerauer, Alain.andM;</AUTHOR><SUMMARY>The new Prolog III programming language is a fundamental reworkingof PROLOG based on changing the underlying theory of computationfrom a unification algorithm to one based on constraint programlogic.andP;  This change corrects some of PROLOG's limitations as aprogram development tool by enabling Prolog III to use externalprocedures.andP;  External procedures such as those for numericalprocessing require that some parameters be completely known, andPROLOG is designed to handle handle problems with unknown objects.andO;Prolog III overcomes this difficulty by redefining trees toinclude infinite ones, supporting all basic mathematicaloperations and greater than, lesser than and not equal torelations, and supporting Boolean operations.andP;  The structure ofProlog III is based on a triple, comprising a domain, a relationsset and an operations set.andM;</SUMMARY><DESCRIPT>Product:   Prolog 3.0 (Program development software) (design andconstruction).andO;Topic:     PROLOGProgram Development ToolsProgramming LanguagesAlgorithmsProgram LogicTheory of Computation.andO;Feature:   illustrationcharttable.andO;Caption:   An element of the domain of Prolog III. (chart)A set of operations of Prolog III. (table)A set of relations of Prolog III. (table)andM;</DESCRIPT><NOTE>Only Text is presented here; see printed issues for graphics.andO;</NOTE><TEXT>An Introduction to PrologandM;Prolog was initially designed to process natural languages.andP;  Its applicationin various problem solving areas has demonstrated its capabilities, but hasalso made clear its limitations.andP;  Some of these limitations have beenovercome as a result of increasingly efficient implementations and everricher environments.andP;  The fact remains, however, that the core of Prolog,namely, Alan Robinson's unification algorithm [22], has not changedfundamentally since the time of the first Prolog implementations.andP;  Moreover,it is becoming less and less significant compared to the ever-increasingnumber of external procedures as, for example, the procedures used fornumerical processing.andP;  These external procedures are not easy to use.andP;  Theirevocation requires that certain parameters be completely known, and this isnot in line with the general Prolog philosophy that it should be possibleanywhere and at any time to talk about an unknown object x.andM;In order to improve this state of affairs, we have fundamentally reshapedProlog by integrating at the unification level: 1) a refined manipulation oftrees, including infinite trees, together with a specific treatment of lists;2) a complete treatment of two-valued Boolean algebra; 3) a treatment of theoperations of addition, substraction, multiplication by a constant and of therelations [is less than], [is less than or equal to], [is greater than], [isgreater than or equal to]; 4) the general processing of the relation [is notequal to].andP;  By doing so, we replace the very concept of unification by theconcept of constraint solving in a chosen mathematicl structure.andP;  Bymathematical structure, we mean here a domain equipped with operations andrelations, the operations being not necessarily defined everywhere.andM;The incorporation of these features into Prolog resulted in the newprogramming language, Prolog III.andP;  In this article we establish itsfoundations and illustrate its capabilities using representative examples.andO;These foundations, which apply to a whole family of &quot;Prolog III-likecprogramming languages, will be presented by means of simple mathematicalconcepts without explicit recourse to first-order logic.andM;The research work on Prolog III is not an isolated effort; other research hasresulted in languages whose designs share features with Prolog III.andP;  TheCLP(R) language developed by J. Jaffar and S. Michaylov [19] emphasizes realnumber processing, whereas the CHIP language developed by the team led by M.andO;Dincbas [13] emphasizes processing of Boolean algebra and pragmaticprocessing of integers and elements of finite sets.andP;  We should also note thework by J. Jaffar et J-L.andP;  Lassez [18] on a general theory of &quot;ConstraintLogic Programming.&quot;andP;  Finally, we should mention Prolog II, thewell-established language which integrates infinite tress and the [is notequal to] relation, and whose foundations [9, 10] were already presented interms of constraint solving.andP;  From a historical point of view, Prolog II canbe regarded as the first step towards the development of the type oflanguages discussed in this article.andM;The Structure Underlying Prolog IIIandM;We now present the particular structure which is the basis of Prolog III andspecify the general concept of a structure at the same time.andP;  By structure wemean a triple (D, F, R) consisting of a domain D, a set F of operations and aset of relations on D.andM;DomainandM;The domain D of a structure is any set.andP;  The domain of the structure chosenfor Prolog III is the set of trees whose nodes are labeled by one of thefollowing:andM;1.andP;  identifiers,andM;2.andP;  characters,andM;3.andP;  Boolean values, 0' and 1',andM;4.andP;  real numbers,andM;5.andP;  special signs [is less than][is greater than][alpha], where [alpha] iseither zero or a positive irrational number.andM;Figure 1 illustrates such a tree:andM;The branches emanating from each node are ordered from left to right; theirnumber is finite and independent of the label attached to the node.andP;  The setof nodes of the tree can be infinite.andP;  We do not differentiate between a treehaving only one node and its label.andP;  Identifiers, characters, Boolean values,real numbers and special signs [is less than][is greater than][alpha] willtherefore be considered to be particular cases of trees.andM;By real numbers we mean perfect real numbers and not floating point numbers.andO;We make use of the partition of the reals into two large categories--therational numbers, which can be represented by fractions (and of which theintegers are a special case) and the irrational numbers (as for example [pi]and [square root of 2)] which no fraction can represent.andP;  In fact, themachine will compute with rational numbers only and this is related to anessential property of the constraints that can be employed in Prolog III; ifa variable is sufficiently constrained to represent a unique real number thenthis number is necessarily a rational number.andM;A tree a whose initial node is labeled by [is less than][is greaterthan][alpha] is called a list and is writtenandM;[is less than][a.sub.1.,...,a.sub.n][is greater than][sup.alpha],andM;where [a.sub.1]...[a.sub.n] is the (possibly empty) sequence of treesconstituting the immediate daughters of a.andP;  We may omit [alpha] whenever[alpha] is zero.andP;  The true lists are those for which [alpha] is zero: theyare used to represent sequences of trees (the sequence of their immediatedaughters).andP;  Lists in which [alpha] is not zero are improper lists that wehave not been able to exclude: they represent sequences of trees (thesequence of their immediate daughters) completed at their right by somethingunknown of length [alpha].andP;  The length |a| of the list a is thus the real n +[alpha].andP;  A true list has as its length a non-negative integer and animproper list has as its length a positive irrational number.andP;  The list [isless than][is greater than] is the only list with length zero; it is calledthe empty list.andP;  We define the operation of concatenation on a true list andan arbitrary list by the following equality:andM;[is less than][a.sub.1.,...,a.sub.m][is greater than][sup.0 .andP;  [is less than][b.sub.1.,...,b.sub.n][is greater than][sup.alpha] = [is lessthan][a.sub.1.,...,a.sub.m,b.sub.1.,...,b.sub.n][is greater than][sup.alpha].andM;This operation is associative, (a .a') .andP;  b = a .andP;  (a' .andP;  b), and the emptylist plays the role of the neutral element, a .andP;  [is less than][is greaterthan] = a et [is less than][is greater than .andP;  b = b.andP;  We observe that forany list b, there exists one and only one true list a, and one and only onereal [alpha] so thatandM;b = a .andP;  [is less than][is greater than][sup.alpha].andM;This list a is called the prefix of b and is written *b*.andM;OperationsandM;Let [D.sup.n] denote the set of tuples [a.sub.1....a.sub.n] constructed onthe domain D of a structure.andP;  An n-place operation f is a mapping from asubset E of [D.sup.n] to D,andM;[Mathematical Expression Omitted]andM;Note that if E is strictly included in [D.sup.n], the operation f is partial;it is not defined for all tuples of size n.andP;  The reader should also note thatin order to be systematic, the result of the operation is written in prefixnotation.andP;  The 0-place operations are simply mapping of the formandM;[Mathematical Expression Omitted]andM;where [and] is the empty tuple; they are also called constants since they canbe identified with elements of the domain.andM;As far as the chosen structure is concerned, Figure 2 gives the listing ofthe operations which belong to F.andP;  In this listing we introduce a moregeneral notation than the prefix notation.andM;In Figure 2, id designates an identifier, c and [c.sub.i] a character, q etq' rational numbers represented by fractions (or integers), with q' not zero,m a positive integer,andM;n a non-negative integer and [a.sub.i] an arbitrary tree.andP;   TheandM;result of the different operations is defined only if [b.sub.i] is a Booleanvalue, [r.sub.i] a real number [l.sub.i] a list and [e.sub.i] a label not ofthe form [is less than][is greater than][sup.alpha].andM;To each label corresponds a constant, with the exception of irrationalnumbers and labels of the form [is less than][is greater than][sup.alpha],where [alpha] is not zero.andP;  The constant &quot;[c.sub.1]...[c.sub.m]&quot; designatesthe true list whose immediate daughters make up the sequence of characters'[c.sub.1]'...'][c.sub.m]'.andP;  The operations *, [and], [or], *, [Xi],correspond to the classical Boolean operations when they are defined.andP;  theoperations [t or -.sup.1], [+ or -.sup.2], qx, when they are defined, are the1-place [+ or -], the 2-place [+ or -], multiplication by the constant q(when this does not lead to confusion we may omit the sign x) and division bythe constant q'.andP;  By |[l.sub.1]| we designate the length of the list[l.sub1].andP;  By [is less than][a.sub.1,...,a.sub.m][is greater than] wedesignate the true list whose immediate daughters make up the sequence[a.sub.1.,...,a.sub.m].andP;  The operation [a.sub.1]...[a.sub.n.sup.andP;  .  ]andO;applied to a list [l.sub.1] consists in concatenating the true list [is lessthan][a.sub.1.,...,a.sub.n][is greater than] to left of [l.sub.1].andP;  By[e.sub.1(a.sub.2.,...,a.sub.n+2)] we designate the tree consisting of aninitial node labeled [e.sub.1] and the sequence of immediate daughters[a.sub.2.,...,a.sub.n+2].andP;  By [e.sub.1][l.sub.2] we designate the treeconsisting of an initial node labeled [e.sub.1] and of the sequence ofimmediate daughters of the list [l.sub.2].andM;We note the following equalities (provided the different operations used areindeed defined):andM;&quot;[c.sub.1]...[c.sub.m]&quot; = [is less than] '[c.sub.1.,...,'c.sub.m'] [isgreater than]andM;[a.sub.0]([a.sub.1.,...,a.sub.m]) = [a.sub.0][ [is less than][a.sub.1.,...,a.sub.m] [is greater than].andM;Using the constants and the operations we have introduced, we can representour previous example of a tree by NameMarriedWeight(&quot;Dupont&quot;, 1', 755/10)andM;or byandM;NameMarriedWeight[andless;andless;'D', 'u'andgt;.&quot;pont&quot;, 0'V1',75+1/2andgt;].andM;RelationsandM;Let [D.sup.n] again denote the set of tuples [a.sub.1]...[a.sub.n]constructed on the domain D of a structure.andP;  An n-place relation r is asubset E of [D.sub.n].andP;  To express that the tuple [a.sub.1...a.sub.n] is inthe relation r we writeandM;r [a.sub.1...a.sub.n].andM;With respect to the structure chosen for Prolog III, Figure 3 shows therelations contained in F.andP;  We also introduce a more graceful notation thanthe prefix notation.andM;In Figure 3, n designates an integer greater than 1 and [a.sub.i] anarbitrary tree.andP;  The relations id, char, bool, num, irint, list and leaf areused to specify that the tree [a.sub.1] is an identifier, a character, aBoolean value, a real number, an integer or irrational number, a list, alabel not of the form [andless;andgt;.sup.a].andP;  The relations = and [is not equal to]correspond of course to the equality and inequality of trees.andP;  The pair oftrees [a.sub.1.a.sub.2] is in the relation =andgt; only if [a.sub.1] and [a.sub.2]are Boolean values and if [a.sub.1] = 1' entails that [a.sub.2' = 1'.andP;  Thepair of trees [a.sub.1.a.sub.2] is in relation andless;, andgt;, [is less than or equalto], [is greater than or equal to] only if it is a pair of reals in thecorresponding classical relation.andM;We use the relation [/.sup.3] to approximate division and writeandM;[Mathematical Expression Omitted]andM;to express, on the one hand, that [a.sub.1], [a.sub.2] and [a.sub.3] are realnumbers, with [a.sub.2] not equal to zero and, on the other hand, that if atleast one of the reals [a.sub.2] et a.sub.3] is rational, it is true thatandM;[a.sub.3] = [a.sub.1./a.sub.2.]andM;We use the relations [x.sup.n+1., with n [is greater than or equal to' 2, toapproximate a series of multiplications and writeandM;[Mathematical Expression Omitted]andM;to express, on the one hand, that the [a.sub.i]'s are real numbers and, onthe other hand, that if the sequence [a.sub.1...a.sub.n] contains n or n-1rational numbers, it is true thatandM;[a.sub.n+1] = [a.sub.1.x...xa.sub.n.]andM;We use the relations [.sup..n+1], with n [is greater than or equal to] 2, toapproximate a series of concatenations and writeandM;[Mathematical Expression Omitted]andM;to express that in all cases the [a.sub.i]'s are lists such thatandM;[|a.sub.n+1.|] = [|a.sub.1.|] +...+ [|a.sub.n.|]andM;and that, according to whether the element [Mathematical Expression Omitted]is or is not defined,andM;[Mathematical Expression Omitted] or [a.sub.+1] is of the form [MathematicalExpression Omitted]andM;where b is an arbitrary list and k is the largest integer for which theelement [Mathematical Expression Omitted] is defined.andM;We recall that [Mathematical Expression Omitted] is defined only if the lists[Mathematical Expression Omitted] are all true lists.andP;  We also recall that*a* designates the prefix of a, that is to say, the true list obtained byreplacing the initial label [andless;andgt;.sup.a] of a with the label [andless;andgt;.sup.0.]andM;Terms and ConstraintsandM;Let us suppose we are working in a structure (D, F, R) and let V be auniversal set of variables, given once and for all, used to refer to theelements of its domain D.andP;  We will assume that V is infinite and countable.andO;We can now construct syntactic objects of two kinds, terms and contraints.andO;Terms are sequences of juxtaposed elements from V U F of one of the twoforms,andM;x or f [t.sub.1....t.sub.n.,]andM;where x is a variable, f an n-place operation and where the [t]sub.i.'s] areless complex terms.andP;  Constraints are sequences of juxtaposed elements from VU F U R of the formandM;r [t.sub.1....t.sub.n.,]andM;where r is an n-place relation and the [t.sub.i]]s are terms.andP;  We observethat in the definition of terms we have not imposed any restriction on thesemantic compatibility between f and the [t.sub.i.'s].andP;  These restrictions,as we will see, are part of the mechanism which takes a term to its &quot;value.&quot;andM;We introduce first the notion of an assignment [sigma] to a subset W ofvariables : such an assignment is simply a mapping from W into the domain Dof the structure.andP;  This mapping [sigma] extends naturally to a mapping[sigma]* from a set [T.sub.[sigma]] of terms into D specified byandM;[[sigma].sup.*.(x)] = [sigma](x), [[sigma].sup.*.(f t.sub.1....t.sub.n.) = f[sigma.sup.*(t.sub.1.)...[sigma].sup.*.(t.sub.n.).]andM;The terms that are nor members of [T.sub.[sigma]] are those containingvariables not in W, and those containing partial operations not defined forthe arguments [[sigma].sup.*.(ti).]  Depending on whether a term t belongs ordoes not belong to [T.sub.[sigma],] the value of t under the assignment[sigma] is defined and equal to [[sigma].sup.*.(t)] or is not defined.andO;Intuitively, the value of a term under an assignment is obtained by replacingthe variables by their values and by evaluating the term.andP;  If this evaluationcannot be carried out, the value of the term is not defined for thisparticular assignment.andM;We say that the assignment [sigma] to a set of variables satisfies theconstraint r [t.sub.1...n] is the value [[sigma].sup.*.(t.sub.i.) of eachterm [t.sub.i] is defined, and if the tuple[[sigma].sup.*.(t.sub.1.)...[sigma].sup.*.(t.sub.n.) is in the relation r,that is to say ifandM;r [[sigma].sup.*.(t.sub.1.)...[sigma].sup.*.(t.sub.n).]andM;Here are some examples of terms associated with the structure chosen forProlog III.andP;  Instead of using the prefix notation, we adopt the notationsused when the different operations were introduced.andM;andless;xandgt;.y, x[y], andless;xandgt;.10, duo(+x, xVy).andM;The first term represents a list consisting of an element x followed by thelist y.andP;  The second term represents a tree, which is not a list, whose topnode is labeled by x and whose list of immediate daughters is y.andP;  The valueof the third term is never defined, since the concatenation of numbers is notpossible.andP;  The value of the last term is not defined under any assignment,since x cannot be a number and Boolean value at the same time.andM;The following list offers examples of constraints.andP;  Again we adopt thenotations introduced together with the different Prolog III relations.andM;[Mathematical Expression Omitted]andM;We observe that there exist assignments to {x,y,z} which satisfy the next tothe last constraint (for example [sigma](x) = 0', [sigma](y) = 2, [sigma](z)= 2), but that there is no assignment which satisfies the last constraint(the variable x cannot be a number and a Boolean value at the same time).andM;Systems of ConstraintsandM;Any finite set S of constraints is called a system of constraints.andP;  Anassignment [sigma] to the universal set V of variables which satisfies everyconstraint of S is a solution of S. If [sigma] is a solution of S, and W is asubset of V, then the assignment [sigma]' to W, so that for every variable xin W we have [sigma](x) = [sigma](x), is called a solution of S on W.andP;  Twosystems of constraints are said to be equivalent if they have the same set ofsolutions, and are said to be equivalent on W if they have the same ofsolutions on W.andM;We illustrate these definitions with some examples from our structure:andM;* The assignment [sigma] to V where [sigma](x) = 1' for every variable x is asolution of the system of constraints {x = y, y [is not equal to] 0}, but itis not a solution of the system {x = y, +y [is not equal] 0}.andM;* The assignment [sigma] to {y} defined by [sigma](y) = 4 is a solution on{y} of the system {x = y, y [is not equal to] 0}.andM;* The systems {x = y, +y [is not equal to] 0} and {-x = -y, y [is not equalto] 0} are equivalent.andP;  Similarly, the system { 1 = 1, x = x} is equivalentto the empty constraint system.andM;* The systems {x [is less than or equal to] y, y [is less than or equal to]z, x [is not equal to] z} and {x [is less than] z} are not equivalent, butthey are equivalent on the subset of variables {x, z}.andM;It should be noted that all solvable systems of constraints are equivalent onthe empty set of variables, and that all the nonsolvable systems areequivalent.andP;  By solvable system, we obviously mean a system that has at leastone solution.andM;The first Prolog III provides is a way to determine whether a system occonstraints is solvable and if so, it solves the system.andP;  For example, todetermine the number x of pigeons and the number y of rabbits so thattogether there is a total of 12 heads and 34 legs, the following query.andM;{x + y = 12, 12x+4y = 34}?andM;gives rise to the answerandM;{x = 7,y = 5}.andM;To compute the sequence z of 10 elements which results in the same sequencewhether, 1,2,3 is concatenated to its left or 2,3,1 is concatenated to itsright, it will suffice to pose the queryandM;[Mathematical Expression Omitted]andM;The unique answer isandM;{z = andless;1,2,3,1,2,3,1,2,3,1andgt;{.andM;If in the query the list andless;2,3,1andgt; is replaced by the list andless;2,1,3andgt; there is noanswer, which means that the systemandM;[Mathematical Expression Omitted]andM;is not solvable.andP;  In these examples the lists are all of integer length andare thus true lists.andP;  As a result, approximated concatenations behave liketrue concatenations.andM;In this connection, the reader should verify that the systemandM;[Mathematical Expression Omitted]andM;is solvable (it suffices to assign to z any improper list having no immediatedaughters), whereas the systemandM;[Mathematical Expression Omitted]andM;which constrains z to be a true list, is not solvable.andP;  The same holds forapproximated multiplication and division.andP;  Whereas the systemandM;[Mathematical Expression Omitted]andM;is solvable (because the approximated product of two irrational numbers isany number), the systemandM;[Mathematical Expression Omitted]andM;which constrains y to be a rational number, is not solvable.andM;Another example of the solving of systems is the beginning of a proof thatGod exists, as formalized by George Boole [4].andP;  The aim is to show that&quot;something has always existed&quot; using the following five premises:andM;1.andP;  Something is.andM;2.andP;  If something is, either something always was, or the things that now arehave risen out of nothing.andM;3.andP;  If something is, either it exists in the necessity of its own nature, orit exists by the will of another Being.andM;4.andP;  It if exists by the will of its own nature, something always was.andM;5.andP;  If it exists by the will of another being, then the hypothesis, that thethings which now are have risen out of nothing, is false.andM;We introduce five Boolean variables with the following meaning: a = 1' for&quot;Something is,&quot; b = 1' for &quot;Something always was,&quot; c = 1' for &quot;The thingswhich now are have risen from nothing,&quot; d = 1' for &quot;Something exists in thenecessity of its own nature,&quot; e = 1' for &quot;Something exists by the will ofanother Being.&quot;andM;The five premises are easily translated into the systemandM;[Mathematical Expression Omitted]andM;which when executed as a query produces the answerandM;One observes that the value b is indeed constrained to 1'.andM;After these examples, it is time to specify what we mean by solving a systemS of constraints involving a set W of variables.andP;  Intuitively, this meansthat we have to find all the solutions of S on W.andP;  Because there may be aninfinite set of such solutions, it is not possible to enumerate them all.andP;  Itis possible, however, to compute a system in solved form equivalent to S,whose &quot;most interesting&quot; solutions are explicitly presented.andP;  More preciselythrough a system in solved form, we understand a solvable system such that,for every variable x, the solutions of S on {x} is explicitly given, wheneverthis solution is unique.andP;  One can verify that in the preceding examples thesystems given as answers were all in solved form.andM;Before we conclude this section, we should mention a useful property forsolving systems of constraints in the chosen structure.andM;PROPERTY.andP;  IF S is a system of Prolog III constraints and W a set ofvariables, then the two following propositions are equivalent:andM;1.andP;  for every x in W, there are several numerical solutions of S on {x};andM;2.andP;  there exists a numerical irrational solution of S on W.andM;By numerical solution or irrational numerical solution, on a set ofvariables, we understand a solution in which all the variables in this sethave real numbers as values, or irrational numbers as values.andM;Semantics of Prolog III-LikeandM;LanguagesandM;On the basis of the structure we have chosen, we can now define theprogramming language Prolog III.andP;  As the method employed is independent ofthe chosen structure, we define in fact the notion of a &quot;Prolog III-like&quot;language associated with a given structure.andP;  The only assumption we will makeis that the equality relation is included in the set of relations of thestructure in question.andM;Meaning of a ProgramandM;In a Prolog III-like language, a progrm is a definition of a subset of thedomain of the chosen structure (the set of trees in the case of Prolog III).andO;Members of this subset are called admissible elements.andP;  The set of admissibleelements is in general infinite and constitutes--in a manner of speaking--anenormous hidden database.andP;  The execution of a program aims at uncovering acertain part of this database.andM;Strictly speaking, a program is a set of rules: Each rule has the formandM;[t.sub.0] [right arrow] [t.sub.1]...[t.sub.n], SandM;where n can be zero, where the [t.sub.1]'s are terms and where S is apossibly empty system of constraints (in which case it is simply absent).andO;The meaning of such a rule is roughly as follows: &quot;provided the constraintsin S are satisfied, [t.sub.0] is to an admissible element if [t.sub.1] and...andP;  and [t.sub.n] are admissible elements (or if n = 0).&quot;andP;  Figure 4 depictssuch a set of rules.andP;  This is our first example of a Prolog III program.andP;  Itis an improvement on a program which is perhaps too well-known, but whichremains a useful pedagogical tool: the calculation of well-balanced meals[9].andM;The meaning of the first rule is: &quot;provided the four conditions i [is greaterthan or equal] 0, j [is greater than or equal] 0, k [is greater than or equalto] 0, i+j+k [is less than or equal to] 10 are satisfied, the triple h,m,dconstitutes a light meal, if h is an hors-d'oeuvre with calorific value i, ifm is a main course with calorific value j and if d is a dessert withcalorific value k.&quot;andP;  The meaning of the last rule is: &quot;Ice-cream is a dessertwith calorific value 6.&quot;andM;We will now offer a precise definition of the set of admissible elements: Therules in the program are in fact rule schemas.andP;  Each rule (of the above form)stands for the set of evaluated rulesandM;[delta]*([t.sub.0]) [right arrow] [delta]*([t.sub.1])...[delta]*([t.sub.n])andM;obtained by considering all the solutions [delta] of S for which the values[delta]*([t.sub.i]) are defined.andP;  Each evaluated ruleandM;[a.sub.0 [right arrow] a.sub.1.....a.sub.n],andM;in which only elements [a.sub.i] of the domain occur, can be interpreted intwo ways:andM;1.andP;  as a closure property of certain subsets E of the domain: if all of[a.sub.1],...,[a.sub.n] are members of the subset E, then [a.sub.0] is alsois a member of E (when n = 0, this property states that [a.sub.0] is a memberof E),andM;2.andP;  as a rewrite rule which, given a sequence of elements of the domainbeginning with [a.sub.0], sanctions the replacement of the first element[a.sub.0] by the sequence [a.sub.1]...[a.sub.n] (when n = 0, this is the sameas deleting the first element [a.sub.0]).andM;Depending on which of these two interpretations is being considered, weformulate one or the other of the following definitions:andM;Definition 1.andP;  The set of admissible elements is the smallest subset of thedomain (in the sense of inclusion) which satisfies all the closure propertiesstemming from the program.andM;Definition 2.andP;  The admissible elements are the members of the domain which(considered as unary sequences) can be deleted by applying rewrite rulesstemming from the program a finite number of times.andM;In [10, 11] we show that the smallest subset in the first definition doesindeed exist and that the two definitions are equivalent.andP;  Let us re-examinethe previous program example.andP;  Here are some samples of evaluated rules:andM;LightMeal(pate, sole, fruit) [right arrow] Hors Doeuvre(pate, 6)MainCourse(sole, 2) Dessert(fruit,2);andM;MainCourse(sole, 2) [right arrow] Fish(sole,2);andM;HorsDoeuvre(pate,6) [right arrow];andM;Fish(sole,2) [right arrow];andM;Dessert(fruit,2) [right arrow];andM;If we consider these rules to be closure properties of a subset of trees, wecan successively conclude that the following three subsets are sets ofadmissible elements,andM;{HorsDoeuvre(pate,6), Fish(sole,2), Dessert(fruit,2)} {MainCourse(sole,2)},{LightMeal(pate,sole,fruit)}andM;and therefore that the treeandM;LightMeal(pate,sole,fruit)andM;is an admissible element.andP;  If we take these evaluated rules to be rewriterules, the sequence constituted solely by thet last tree can be deleted inthe following rewrite steps:andM;LightMeal(pate,sole,fruit) [right arrow] HorsDoeuvre(pate,6) MainCourse(sole,2) Dessert(fruit,2) [right arrow] MainCourse(sole,2) Dessert(fruit,2) [rightarrow] Fish(sole,2) Dessert(fruit,2) [right arrow] Dessert(fruit,2) [rightarrow],andM;which indeed confirms that the above is an admissible element.andM;Execution of a ProgramandM;We have now described the information implicit in a Prolog III-like program,but we have not yet explained how such a program is executed.andP;  The aim of theprogram's execution is to solve the following problem: given a sequence ofterms [t.sub.1]...[t.sub.n] and a system S of constraints, find the values ofthe variables which transform all the terms [t.sub.i] into admissibleelements, while satisfying all the constraints in S.andP;  This problem issubmitted to the machine by writing the queryandM;[t.sub.1]...[t.sub.n], S?andM;Two cases are of particular interest.andP;  1) If the sequence[t.sub.1]...[t.sub.n] is empty, then the query simply asks whether the systemS is solvable and if so, solves it.andP;  We have already seen examples of suchqueries.andP;  2) If the system S is empty (or absent) and the sequence of termsis reduced to one term only, the request can be summarized as: &quot;What are thevalues of the variables wh ich transform this term into an admissibleelement?&quot;andP;  Thus, using the preceding program example, the queryandM;LightMeal(h,m,d)?andM;will enable us to obtain all the triples of values for h, m, and d whichcnstitute a light meal.andP;  In this case, the replies will be the followingsimplified systems:andM;{h = radishes, m = beef, d = fruit}, {h = radishes, m = pork, d = fruit}, {h= radishes, m = sole, d = fruit}, {h = radishes, m = sole, d = icecream}, {h= radishes, m = tuna, d = fruit}, {h = pate, m = sole, d = fruit].andM;The method of comuting these answers is explained by introducing an abstractmachine.andP;  This is a nondeterministic machine whose state transitions aredescribed by the three formulas in Figure 5.andM;Formula (1) represents the state of the machine at a given moment.andP;  W is aset of variables whose values we want to determine,[t.sub.0][t.sub.1]...[t.sub.n] is a sequence of terms which we are trying todelete and S is a system of constraints which has to be satisfied.andP;  Formula(2) represents the rules in the program which is used to change the state.andO;If necessary, the variables of (2) are renamed, so that none of them areshared with (1).andP;  Formula (3) is the new state of the machine after theapplication of rule (2).andP;  The transition to this new state is possible onlyif the system of constraints in (3) possesses at least one solution [delta]with respect to which all the values [delta]*([s.sub.i]) and[delta]*([t.sub.i]) are defined.andM;In order to provide an answer to the query given above, the machine startsfrom the initial stateandM;(W, [t.sub.0]...[t.sub.n], S),andM;where W is the set of variables appearing in the query, and goes through allthe states which can be reached by authorized transitions.andP;  Each time itarrives at a state containing the empty sequence of terms A, it simplifiesthe system of constraints associated with it and presents it as an answer.andO;This simplification can also be carried out on all the states it passesthrough.andM;Let us now reconsider our first program example, and apply this process tothe query.andP;  LightMeal(h,m,d)?andM;The initial state of the machine is ({h,m,d}, LightMeal (h,m,d,), {}).andP;  Byapplying the rule LightMeal(h',m',d') [right arrow] HorsDoeuvre(h', i)MainCourse(m',j) Dessert(d', k), [Mathematical Expression Omitted] we proceedto the state ({h,p,d}, HorsDoeuvre(h',i) MainCourse(m',j) Dessert(d',k),[Mathematical Expression Omitted] LightMeal(h',m',d')}) which in turnsimplifies to ({h,p,d}, HorsDoeuvre(h',i) MainCourse(m',j) Dessert(d',k),{i[is greater than or equal to]0, k[is greater than or equal to]0, i+j+k[isless than or equal to]10, h=h' p=p', d=d'}), and to ({h,p,d},HorsDoeuvre(h,i) MainCourse(m,j) Dessert(d,k), {i[is greater than or equalto]0, k[is greater than or equal to]0, i+j+k[is less than or equal to]10}).andO;By applying the rule HorsDoeuvre(pate, 6) [righ arrow] and simplifying theresult, we progress to the state ({h,p,d}, MainCourse(p,j) Dessert(d,k),{h=pate,j[is greater than or equal to]0, k[is greater than or equal to]0, j +k[is less than or equal to]4}).andP;  By applying the rule MainCourse(p', i)[right arrow] Fish(p', i) and simplifying the result, we proceed to the state({h,m,d}, Fish(m', i) Dessert(d,k), {h=pate, j[is greater than or equal to]0,k[is greater than or equal to]0, j + k[is less than or equal to] 4, m=m',j=i}).andP;  which then simplifies to ({h,m,d}, Fish(m,j) Dessertnd,k),{h=pate,j[is greater than or equal to]0, k[is greater than or equal to]0, j +k[is less than or equal to]).andP;  By applying the rule Fish(sole, 2) [rightarrow] we obtain ({h,M,d}, Dessert(d,k), {h=pate, m=sole, k[is greater thanor equal to]0, k[is less than or equal to]2}).andP;  Finally, by applying the ruleDessert(fruit, 2) [right arrow] we obtain ({h,m,d}, [and] {h=pate, m=sole,d=fruit}).andP;  We can conclude that the system {h = pate, m = sole, d = fruit}constitutes one of the answers to the query.andM;To obtain the other ansers, we proceed in the same way, but use the otherrules.andP;  In [11] we prove that this method is complete and correct.andP;  To bemore exact, given the abstract machine Mp connected to a program P, we showthat the following property holds.andM;PROPERTY.andP;  Let {[t.sub.1,...,t.sub.n.]} be a set of terms, S a system ofconstraints, and W the set of variables occurring in them.andP;  For anyassignment [delta] to W, the following twopropositions are equivalent:andM;1.andP;  the assignment [delta] is a solution of S on W and each [delta]*([+.sub.i]) is an admissible element for P;andM;2.andP;  starting from state (W, [and] S') the abstract machine Mp can reach astate of the form (W, [t.sub.1]...[t.sub.n], S), where S' admits [delta] assolution on W.andM;It should be recognized that there are many ways of simplifying the states ofthe abstract machine and checking whether they contain solvable systems ofconstraints.andP;  Therefore, we should not always expect that the machine, whichuses very general algorithms, arrives at the same simplifications as thoseshown above.andP;  In [11] we show that the only principle to which allsimplifications must conform is that states of the abstract machine aretransformed into equivalent states in this sense:andM;DEFINITION.andP;  Two states are equivalent if they have the formandM;(W, [t.sub.1]...[t.sub.n], S) and (W, [t.sub.1']...[t.sub.n'], S'),andM;and if, by introducing n new variables [x.sub.1],...,[x.subn], the systemsandM;S[union]{[x.sub.1=t.sub.1,...,x.sub.n=t.sub.n]} and S'[union]{[x.sub.1=t.sub.1',...,x.sub.n.=t.sub.n']},andM;are equivalent on the subset of variables W [union] {[x.sub.1,...,x.sub.n]}.andM;Treatment of NumbersandM;Next, we will illustrate the possibilities of Prolog III in connection withdifferent program examples.andP;  We will consider, one after the other thetreatment of the following: numbers; Boolean values; trees and lists; andfinally, integers.andM;Computing InstallmentsandM;The first task is to calculate a series of installments made to repay capitalborrowed at a certain interest rate.andP;  We assume identical time periodsbetween two installments and an interest rate of 10 percent throughout.andP;  Theadmissible trees will be of the form:andM;InstallmentsCapital(x,c),andM;where x is the sequence of installments necessary to repay the capital c withan interest rate of 10 percent between two installments.andP;  In Figure 6 theprogram itself is given by two rules:andM;The first expresses the fact that it is not necessary to pay installments torepay zero capital.andP;  The second rule expresses the fact that the sequence ofn + 1 installments to repay capital c consists of an installment i and asequence of n installments to repay capital c increased by 10 percentinterest, but the whole reduced by installment i.andM;This program can be used in different ways.andP;  One of the most spectacular isto ask what value of i is required to repay $1000 given the sequence ofinstallments andless;i,2i, 3iandgt;.andP;  All we need to do is to put the queryandM;InstallmentsCapital(andless;i, 2i, 3iandgt;, 1000)?andM;to obtain the answerandM;{i = 207 + 413 / 641}.andM;Here is an abbreviated trace of how the computation proceeds.andP;  Starting fromthe initial state ({i}, InstallmentsCapital(andless;i,2i,3iandgt;,1000).andP;  {}).  andapplying the rule InstallmentsCapital(andless;i'andgt;.x,c) [right arrow] InstallmentsCapital(x,(1+10/100)c-i') we progress to the state ({i},InstallmentsCapital(x,(1+10/100)c-i'), {InstallmentsCapital(andless;i'andgt;.x,c)}),which simplifies to ({i}, InstallmentsCapital(x,(11/10)c-i'), {i'=i,x=andless;2i,3iandgt;, c=1000}), then to ({i}, InstallmentsCapital(andless;2i,3iandgt;,1100-i), {}).andM;The reader can verify that when the same rule is applied two more times, weobtain, after simplification, the states ({i},InstallmentsCapital(andless;3iandgt;,1210-(31/10)i), {}), ({i},InstallmentsCapital(andless;andgt;,1331-(641/100)i), {}).andM;By applying the rule InstallmentsCapital (andless; andgt;,0) [right arrow] to the laststate, we finally obtain ({i}, {1331-(641/100)i=0} which simplifies to ({i},{i=207+413/641}).andM;Here again the reader should be aware that the simplifications presented hereare not necessarily those the machine will perform.andM;Computing Scalar ProductsandM;As an example of approximated multiplication, Figure 7 shows small programwhich computes the scalar product [x.sub.1]X[y.sub.1]+...[x.sub.n]X[y.sub.n]of two vectors andless;[x.sub.1,...,x.sub.n]andgt; and andless;y.sub.1,...,y.sub.n]andgt;.andM;The queryandM;ScalarProduct(andless;1,1andgt;, X, 12) ScalarProduct(X, andless;2,4andgt;, 34)?andM;produces the answerandM;{X=andless;7,5andgt;}.andM;Computing the Periodicity of a SequenceandM;This problem was proposed in [5].andP;  We consider the infinite sequence of realnumbers defined byandM;[x.sub.i+2] = |[x.sub.i+1]| - [x.sub.i]andM;where [x.sub.1] and [x.sub.2] are arbitrary numbers.andP;  Our aim is to show thatthis sequence is always periodic and that the period is 9, in other words,that the sequencesandM;[x.sub.1], [x.sub.2], [x.sub.3],...andP;  and [x.sub.1+9], [x.sub.2+9],[x.sub.3+9],...andM;are always identical.andM;Each of these two sequences is completely determined if its first twoelements are known.andP;  To show that the sequences are equal, it is thereforesufficient to show that in any sequence of eleven elementsandM;[x.sub.1, x.sub.2, x.sub.3,...,x.sub.10, x.sub.11]andM;we haveandM;[x.sub.1=x.sub.10] and [x.sub.2=x.sub.11].andM;To begin with, Figure 8 illustrates the program that enumerates all thefinite sequences [x.sub.1],[x.sub.2],...,[x.sub.n] which respect the rulegiven above.andM;The + signs in the first rule constrain x and y to denote numbers.andP;  It willbe observed that the sequences are enumerated from left to right, that is,trees of the form Sequence(s) are only admissible if s has the formandless;[x.sub.n,...,x.sub.2,x.sub.1]andgt;.andP;  If we run this program by askingandM;Sequence(s), {|s| = 11, s = w .andP;  v .andP;  u, |u' = 2, |w' = 2, u [is not equalto] w}?andM;execution ends without providing an answer.andP;  From this we deduce that thereis no sequence of the form [x.sub.1x.sub.2,...x.sub.10,x.sub.11] such thatthe subsequences [x.sub.1]x.sub.2] and [x.sub.10,x.sub.11] (denoted by u andv) are different, and therefore that in any sequence[x.sub.1,x.sub.2,...x.sub.10,x.sub.11] we have indeed [x.sub.1]=x.sub.10] and[x.sub.2]=x.sub.11].andM;Computing a Geometric CoveringandM;Here is a final example which highlights the numerical part of Prolog III.andO;Given an integer n, we want to know whether it is possible to have n squaresof different sizes which can be assembled to form a rectangle.andP;  If this ispossible, we would like to determine the sizes of these squares and of therectangle thus formed.andP;  For example, Figure 9 shows two solutions to thisproblem, for n=9.andM;We will use a to denote the ratio between the length of the longest side ofthe constructed rectangle, and the length of its shortest side.andP;  Obviously,we can suppose that the length of the shortest side is 1, and therefore thatthe length of the longest side is a.andP;  Thus, we have to fill a rectanglehaving the size 1 X a with n squares, all of them different.andP;  With referenceto Figure 10, the basis of the filling algorithm will consist ofandM;1.andP;  placing a square in the lower left-hand corner of the rectangle.andM;2.andP;  filing zone A with squares,andM;3.andP;  filing zone B with squares.andM;Provided zones A and B are not empty, they will be filled recursively in thesame way: placing a square in the lower left-hand corner and filling twosubzones.andM;The zones and subzones are separated by jagged lines in the shape of steps,joining the upper right corner of the squares and the upper right corner ofthe rectangle.andP;  These jagged lines never go downward, and if several can beplotted to go from one point to another, the lowest one is the one weconsider.andP;  Figure 11 is an example of all the separation lines correspondingto the first solution of the problem for n=9:andM;To be more precise, a zone or subzone has the form given in the left box inFigure 12, whereas the entireandM;The zone is delimited below by a jagged Line L joining a point P to point Q,and in Figure 12 by a jagged line L' joining the same point P to the samepoint Q.andP;  Point P is placed anywhere in the rectangle to be filled, and Qdenotes the upper right corner of the rectangle.andP;  These jagged lines arerepresented by alternating sequences of vertical and horizontal segments.andM;[v.sub.0, h.sub.1, v.sub.1,..., h.sub.n, v.sub.n],andM;where [v.sub.i] denotes the length of a vertical segment, and [h.sub.i] thelength of a horizontal segment.andP;  The [h.sub.i]'s are always strictlypositive.andP;  The [v.sub.i]'s are either zero, either positive to denoteascending segments, or negative to denote descending segments.andP;  The[v.sub.i]'s of the upper lines are never negative, and if a zone is notempty, only the first vertical segment [v.sub.0] in its lower line isnegative.andM;If these conventions are applied to the entire rectangle (right diagramabove), the lower line L can be  represented by the sequence -1,a,1 and theupper line L' by a sequence having the form 0,[h.sub.1],0,...,[h.sub.n],0,where [h.sub.1 + ...andP;  + [h.sub.n] = a, and the [h.sub.i]'s are positive.andM;The heart of the program consists in admitting trees of the formandM;FilledZone(L, L,' C, C')andM;only if the zone delimited below by L can be filled with squares and can bebounded above by L'.andP;  The squares are to be taken from the beginning of thelist C, and C' has to be list of squares which remain.andP;  We also need tointroduce trees of the formandM;PlacedSquare(b, L, L')andM;which are admitted only if it is possible to place a square of size b x b atthe very beginning of line L and if L' is the line making up the rightvertical side of the square continued by the right part of L (see Figure 13).andO;In fact L denotes the lower line of a zone from which the first verticalsegment has been removed.andP;  The diagram shows the three cases that can occurand which will show up in three rules.andP;  Either the square overlaps the firststep, which in fact was a pseudostep of height zero, or the square fitsagainst the first step, or the square is not big enough to reach the firststep.andM;The program itself is constituted by the following 10 rules listed in Figure14.andM;[Mathematical Expression Omitted]andM;The call to the program is made with the queryandM;FilledRectangle(a, C), {|C| = n}?andM;where n, the only known parameter, is the number of squares of differentsizes that are to fill the rectangle.andP;  The program computes the possible size1 x a of the rectangle (a[is greater than or equal to] 1) and the list C ofthe sizes of each of the n squares.andP;  The computation begins by executing thefirst rule, which simultaneously constrains a to be greater than or equal to1, creates n different squares (of unknown size), and starts filling the zoneconstituted by the entire rectangle.andP;  Even if the line L, constituting theupper limit of this zone, is unknown at the beginning, given that this linemust join--without itself descending--two points at the same height, thisline will necessarily be a horizontal line (represented by steps of heightzero).andP;  If we ask the queryandM;FiledRectangle(a, C), {|C| = 9}?andM;we obtain 8 answers.andP;  The first twoandM;{a = 33/32, C = [is less than] 15/32, 9/16, 1/4, 7/32, 1/8, 7/16, 1/32, 5/16,9/32 [is greater than]}, {a = 69/61, C = andless; 33/61, 36/61, 28/61, 5/61, 2/61,9/61, 25/61, 7/61, 16/61 andgt;}.andM;correspond to the two solutions we have drawn earlier.andP;  The other six answersdescribe solutions which are symmetrical to these two.andP;  In order to locatethe positions of the various squares in the rectangle we can proceed asfollows.andP;  One fills the rectangle using all the squares of the list C intheir order of appearance.andP;  At each stage, one considers all the free cornershaving the same orientation as the lower left corner of the rectangle and onechooses the rightmost corner to place the square.andM;There is a vast amount of literature concerning this problem.andP;  Let us mentiontwo important results.andP;  It has been shown in [25] that for any rationalnumber a -- 1 there always exists an integer n such that the rectangle ofsize 1 X a can be filled with n distinct squares.andP;  For the case of a = 1(when the rectangle to be filled is a square), it has been shown in [14] thatthe smallest possible n is n = 21.andM;Treatment of Boolean ValuesandM;Computing FaultsandM;In this example we are interested in detecting the defective components in anadder which calculates the binary sum of three bits [x.sub.1], [x.sub.2],[x.sub.3] in the form of a binary number given in two bits [y.sub.1.y.sub.2].andO;As we can see in Figure 15, the circuit proposed in [16] is made up of 5components numbered from 1 to 5: two and gates (marked And), one or gate(marked Xor) and two exclusive or gates (marked Xor).andP;  We have also usedthree variables, [u.sub.1], [u.sub.2], [u.sub.3] to represent the output fromgates 1, 2 and 4.andM;We introduce five more Boolean variables [d.sub.i] to express by [d.sub.i] =1' that &quot;gate number i is defective.&quot;andP;  If we adopt the hypothesis that atmost, one of the five components has a defect, the program connecting thevalues [x.sub.i], [y.sub.i] and [d.sub.i] is shown in Figure 16.andM;Circuit(andless;x1,x2,x3andgt;, andless;y1,y2andgt;, andless;d1,d2,d3,d4,d5andgt;) [right arrow]AtMostOne(andless;d1,d2,d3,d4,d5andgt;), {~d1 [right arrow] (u1 [Xi] x1[and]x3), ~d2[right arrow] (u2 [Xi] x2[and]u3), ~d3 [right arrow] (y1 [Xi] u1[or]u2), ~d4[right arrow] (u3 [Xi] ~(x1[Xi]3)), ~d5 [right arrow] (y2 [Xi] ~(x2[Xi]u3))};andM;AtMostOne(D) [right arrow] OrInAtMostOne(D, d);andM;OrInAtMostOne(andless;andgt;, 0') [right arrow]; OrInAtMostOne(andless;dandgt;* D, d[or]e) [rightarrow] OrInAtMostOne(D, e), {d[and]e = 0'};andM;In this program the admissible trees of the formandM;AtMostOne(D)andM;are those in which D is a list of Boolean elements containing at most one 1'.andO;The admissible trees of the formandM;OrInAtMostOne(D, d)andM;are those in which D is a list of Boolean elements containing at most one 1'and where d is the disjunction of these elements.andM;If the state of the circuit leads us to write the queryandM;Circuit(andless;1', 1', 0'andgt;, andless;0', 1'andgt;, andless;d1, d2, d3, d4, d5andgt;)?andM;the diagnosis will be that component number 4 is defective:andM;{d1=0', d2=0', d3=0', d4=1', d5=0'}.andM;If the state of the circuit leads us to write the queryandM;Circuit(andless;1', 0', 1'andgt;, andless;0', 0'andgt;, andless;d1, d2, d3, d4, d5andgt;)?andM;the diagnosis will then be that either component number 1 or component number3 is the defective one:andM;{d1[or]d3=1', d1[and]d3=0', d2=0', d4=0', d5v0'}.andM;Computing InferencesandM;We now consider the 18 sentences of a puzzle by Lewis Carroll [7], which welist here.andP;  Questions of the following type are to be answered: &quot;whatconnection is there between being clear-headed, being popular and being fitto be a Member of Parliament?&quot; or &quot;what connection is there between beingable to keep a secret, being fit to be a Member of Parliament and being worthone's weight in gold?&quot;andM;1.andP;  Any one, fit to be an M.P., who is not always speaking, is a publicbenefactor.andM;2.andP;  Clear-headed people, who express themselves well, have a good education.andM;3.andP;  A woman, who deserves praise, is one who can keep a secret.andM;4.andP;  People, who benefit the public, but do not use their influence for goodpurpose, are not fit to go into Parliament.andM;5.andP;  People, who are worth their weight in gold and who deserve praise, arealways unassuming.andM;6.andP;  Public benefactors, who use their influence for good objects, deservepraise.andM;7.andP;  People, who are unpopular and not worth their weight in gold, never cankeep a secret.andM;8.andP;  People, who can talk for ever and are fit to be Members of Parliament,deserve praise.andM;9.andP;  Anyone, who can keep a secret and who is unassuming, is anever-to-be-forgotten public benefactor.andM;10.andP;  A woman, who benefits the public, is always popular.andM;11.andP;  People, who are worth their weight in gold, who never leave off talking,and whom it is impossible to forget, are just the people whose photographsare in all the shop-windows.andM;12.andP;  An ill-educated woman, who is not clear-headed, is not fit to go toParliament.andM;13.andP;  Anyone, who can keep a secret and is not forever talking, is sure to beunpopular.andM;14.andP;  A clear-headed person, who has influence and uses it for good objects,is a public benefactor.andM;15.andP;  A public benefactor, who is unassuming, is not the sort of person whosephotograph is in every shop-window.andM;16.andP;  People, who can keep a secret and who use their influence for goodpurposes, are worth their weight in gold.andM;17.andP;  A person, who has no power of expression and who cannot influenceothers, is certainly not a woman.andM;18.andP;  People, who are popular and worthy of praise, either are publicbenefactors or else are unassuming.andM;Each of these 18 statements is formed from basic propositions and logicalconnectives.andP;  To each basic proposition corresponds a name, in the form of acharacter string, and a logical value represented by a Boolean variable.andP;  Theinformation contained in the 18 statements can then be expressed in a singlerule formed by a large head term, an empty body, and a sizeable constraintpart depicted in Figure 17.andM;Possible Case(andless; andless;a,&quot;clear-headed&quot;andgt;, andless;b,&quot;well-educated&quot;andgt;, andless;c,&quot;constantlytalking&quot;andgt;, andless;a,&quot;using one's influence for good objects&quot;andgt;, andless;e,&quot;exhibited inshop-windows&quot;andgt;, andless;f,&quot;fit to be a Member of Parliament&quot;andgt;, andless;g,&quot;publicbenefactors&quot;andgt;, andless;h,&quot;deserving praise&quot;andgt;, andless;i,&quot;popular&quot;andgt;, andless;j,&quot;unassuming&quot;andgt;,andless;k,&quot;women&quot;andgt;, andless;l,&quot;never-to-be-forgotten&quot;andgt;, andless;m,&quot;influential&quot;andgt;, andless;n,&quot;able to keepa secret&quot;andgt;, andless;o,&quot;expressing oneself well&quot;andgt;, andless;p,&quot;worth one's weight in gold&quot;andgt;andgt;)[right arrow], {(f [and] ~c) [right arrow] g, (a [and] o) [right arrow] b, (k[and] h) [right arrow] n, (g [and] ~d) [right arrow] ~f, (p [and] h) [rightarrow] j, (g [and] d) [right arrow] h, (~i [and] ~p) [right arrow] ~n, (c[and] f) [right arrow] h, (n [and] j) [right arrow] (g [and] l), (k [and] g)[right arrow] i, (p [and] c [and] l) [right arrow] e, (k [and] ~a [and] ~ b)[right arrow] ~f, (n [and] ~c) [right arrow] ~i, (a [and] m [and] d) [rightarrow] g, (g [and] j) [right arrow] ~e, (n [and] d) [right arrow] p, (~o[and] ~m) [right arrow] ~k, (i [and] h) [right arrow] (g [or] j)};andM;To be able to deal with subcases, we introduce Figure 18:andM;PossibleSubCase(x) [right arrow] PossibleCase(y) SubSet(x,y);andM;SubSet(andless;andgt;, y) [right arrow]; SubSet(andless;eandgt;* x, y) [right arrow] ElementOf(e, y)SubSet(x, y);andM;ElementOf(e, andless;eandgt;* y) [right arrow]; ElementOf(e, andless;eandgt;* y) [right arrow]ElementOf(e, y), [e [is not equal to] e'[;andM;In order to compute the connection which exists between &quot;clear-headed,&quot;&quot;popular&quot; and &quot;fit to be a Member of Parliament&quot; it suffices to write thequeryandM;PossibleSubCase( andless; andless;p,&quot;clear-headed&quot;andgt;, andless;q,&quot;popular&quot;andgt;, andless;r,&quot;fit to be a Memberof Parliament&quot;andgt; andgt;)?andM;The answer is the set of constraintsandM;{p: bool, q : bool, r : bool},andM;which means that there is no connection between &quot;clear-headed,&quot; &quot;popular&quot; and&quot;fit to be a Member of Parliament.&quot;andM;To compute the connection which exists between &quot;able to keep a secret,&quot; &quot;fitto be a Member of Parliament&quot; and &quot;worth one's weight in gold&quot; it suffices towrite the queryandM;PossibleSubCase( andless; p,&quot;able to keep a secret&quot;andgt;, andless;q,&quot;fit to be a Member ofParliament&quot;andgt;, andless;r,&quot;worth one's weight in gold&quot;andgt; andgt;)?andM;The answer isandM;{p[and]q [right arrow] r},andM;which means that persons who can keep secrets and are fit to be Members ofParliament are worth their weight in gold.andM;In fact, in these two examples of program execution we have assumed thatProlog III yields as answers very simplified solved systems, particularly,those not containing superfluous Boolean variables.andP;  If this had not been thecase, to show (as opposed to find) that persons who can keep secrets and arefit to be Members of Parliament are worth their weight in gold, we would havehad to pose the queryandM;PossibleSubCase( andless; andless;p,&quot;able to keep a secret&quot;andgt;, andless;q,&quot;fit to be a Member ofParliament&quot;andgt;, andless;r,&quot;worth one's weight in gold&quot; andgt; andgt;), [Mathematical ExpressionOmitted]andM;and obtain a response of the form {x = 1',...} or obtain no answer to thequeryandM;PossibleSubCase( andless; p,&quot;able to keep a secret&quot;andgt;, andless;q,&quot;fit to be a Member ofParliament&quot;andgt;, andless;r,&quot;worth one's weight in gold&quot; andgt; andgt;)?andM;[Mathematical Expression Omitted]andM;Treatment of Trees and ListsandM;Computing the Leaves of a TreeandM;Here is, first of all, an example in which we access labels and daughters ofa tree by the operation [].andP;  We want to calculate the list of the leaves of afinite tree without taking into account the leaves labeled [andless; andgt;.sup.a].andO;Figure 19 illustrates the program.andM;Leaves(e[u], andless;eandgt;) [right arrow], {u = andless;andgt;}; Leaves(e[u], x) [right arrow]Leaves(u, x), {u [is not equal to] andless;andgt;}; Leaves(andless;andgt;, andless;andgt;) [right arrow];Leaves(andless;aandgt;* u, z) [right arrow] Leaves(a, x) Leaves(u, y), [MathematicalExpression Omitted]andM;Trees of the formandM;Leaves(a, x)andM;are admissible only if x is the list of leaves of the finite tree a (notincluding the leaves labeled andless; [andgt;.sup.a]).andP;  The queryandM;Leaves(height(&quot;Max&quot;, andless;180/100,metersandgt;,1'), x)? produces the answerandM;{x = andless;'M', 'a', 'x', 9/5, meters, 1'andgt; }.andM;Computing Decimal IntegersandM;Our second example shows how we can use approximated concatenation to accessthe last element of a list.andP;  We want to transform a sequence of digits intothe integer it represents.andP;  Figure 20 shows the program without comments.andM;Value(andless;andgt;, 0) [right arrow] ; Value(y, 10m+n) [right arrow] Value(x, m),[Mathematical Expression Omitted]andM;As a reply to the queryandM;Value(andless;1,9,9,0andgt;, x)?andM;we obtainandM;{x=1990}.andM;Computing the Reverse of ListsandM;If one knows how to access the first and the last elements of a list, it mustbe possible to write an elegant program computing the reverse of a list.andP;  Theone I propose is illustrated in Figure 21.andM;Reverse(x, y) [right arrow] Palindrome(u), [Mathematical Expression Omitted]andM;Palindrome(andless;andgt;) [right arrow] ; Palindrome(v) [right arrow] Palindrome(u),[Mathetical Expression Omitted]andM;Each of the two queriesandM;Reverse(andless;1,2,3,4,5andgt;, x)? Reverse(x, andless;1,2,3,4,5andgt; )?andM;produces the same answerandM;{x = andless;5,4,3,2,1andgt;}.andM;For the queryandM;Reverse(x, y) Reverse(y, z), {x [is not equal to] z, |x| = 10}?andM;we get no answer at all, which confirms that reversing a list twice yieldsthe initial list.andM;Context-Free RecognizerandM;The treatment of concatenation provides a systematic and natural means ofrelating &quot;context-free&quot; grammar rules with Prolog III rules, thusconstructing a recognizer.andP;  Let us for example consider the grammarandM;{S [right arrow] AX, A [right arrow] [Lambda], A [right arrow] aA, X [rightarrow] [Lambda], X [right arrow] aXb}andM;which defines the language consisting of sequences of symbols of the form[a.sup.m.b.sup.n] with m [is greater than or equal to] n.andP;  The program inFigure 22 corresponds to the grammar:andM;Sform(u) [right arrow] Aform(v) Xform(w), [Mathematical Expression Omitted]andM;Aform(u) [right arrow] {u = andless;andgt;};andM;Aform(u) [right arrow] Aform(v), {u = &quot;a&quot;* v};andM;Xform(u) [right arrow] {u = andless;andgt;};andM;Xform(u) [right arrow] {form(v), [Mathematical Expression Omitted]andM;The queryandM;Sform(&quot;aaabbb&quot;)?andM;produces the answerandM;{}which signifies that the string &quot;aaabb&quot; belongs to the language, whereas thequeryandM;Sform(&quot;aaabbb&quot;)?andM;produces no response, which means that the string ''aaabbbb'' does not belongto the language.andM;Treatment of IntegersandM;The algorithms used for solving constraints on integers are complex and quiteoften inefficient.andP;  It is for this reason that the structure underlyingProlog III does not contain a relation restricting a number to be only aninteger.andP;  However, we have considered a way of enumerating integerssatisfying the set of current constraints.andM;Enumeration of IntegersandM;The Prolog III abstract machine is modified to behave as if the followinginfinite set of rulesandM;enum(0) [right arrow]; enum(-1) [right arrow]; enum(1) [right arrow];enum(-2) [right arrow]; enum(2) [right arrow];andM;had been added to every program.andP;  Moreover, the abstract machine isimplemented to guarantee that the search for applicable rules takes a finiteamount of time whenever this set is itself finite.andP;  In connection with thedefinition of the abstract machine, this can be regarded as adding all thetransitions of the formandM;(W, [t.sub.0.t.sub.1.....t.sub.m], S) [right arrow] (W,[t.sub.1.....t.sub.m], S U {[t.sub.0] = enum(n)}),andM;where n is an integer such that the systm SU{[p.sub.0] = enum (n)} admits atleast one solution in which the values of the [t.sub.i]'s are all defined.andM;For example, if in the current state of the abstract machine, the first termto be deleted is andless;andless;enum(x)andgt;andgt; and if the system S of constraints is equivalenton {x} to {3/4 [is less than or equal to] x, x [is less than or equal to] 3 +1/4}, then there will be two transitions: one to a state with a systemequivalent to SU{x=1}, the other to a state with a system equivalent toSU{x=2}.andM;We should add in this connection that if S is a system forcing the variable xto represent a number, then, in the most complex case, the system S isequivalent on {x} to a system of the formandM;{x [is greater than or equal to] [a.sub.o], x [is not equal to][a.sub.1],..., x [is not equal to] [a.sub.n], x [is less than or equal to][a.sub.n+1]},andM;where the [a.sub.i]'s are rational numbers.andM;A problem, taken from one of the many books of M. Gardner [15], illustratesnicely the enumeration of integers.andP;  The problem goes like this.andP;  When pricesof farm animals were much lower than they are now, a farmer spent $100 to buy100 animals of three different kinds: cows, pigs and sheep.andP;  Each cow cost$10, each pig $3 and each sheep 50 cents.andP;  Assuming that he bought at leastone cow, one pig and one sheep, how many of each animal did the farmer buy?andM;Let x, y and z be the number of cows, pigs and sheep that the farmer bought.andO;The queryandM;enum (x) enum(y) enum (z), {x + y + z = 100, 10x + 3y + z/2 = 100, x [isgreater than or equal to] 1, y [is greater than or equal to] 1, z [is greaterthan or equal to] 1}?andM;produces the answerandM;{x=5, y=1, z=94}.andM;This problem reminds us of a problem mentioned at the beginning of thisarticle.andP;  Find the number x of pigeons and the number y of rabbits such thattogether there is a total of 12 heads and 34 legs.andP;  It was solved by puttingthe queryandM;{x + y = 12, 2x + 4y = 34}?andM;But, given that a priori, we have no guarantee that the solutions of thissystem are non-negative and integer numbers, it is more appropriate to putthe queryandM;enum(x) enum(y), {x + y = 12, 2x + 4y = 34, x [is greater than or equal to]0, y [is greater than or equal to] 0}?andM;which produces the same answerandM;{x=7, y= 5}.andM;Cripto-ArithmeticandM;Next we look at another problem that illustrates the enumeration of integers.andO;We are asked to solve a classical cripto-arithmetic puzzle: assign the tendigits 0,1,2,3,4,5,6,7,8,9 to the ten letters, D,G,R,O,E,N,B,A,L,T in such away that the addition DONALD + GERALD = ROBERT holds.andP;  We deterministicallyinstall the maximum number of constraints on the reals and use thenondeterminism to enumerate all the integers which are to satisfy theseconstraints.andP;  Figure 23 indicates the program without any comments:andM;The answer to the queryandM;Solution (i, j, k)?andM;isandM;{i=526485, j=197485, k=723970}.andM;Self-Referential PuzzleandM;The last example is a typical combinatorial problem that is given a naturalsolution by enumeration of integers involving approximated concatenation andmultiplication.andP;  Given a positive integer n, we are asked to find n integers[x.sub.1],...,[x.sub.n] so the following property holds:andM;&quot;In the sentence that I am presently uttering, the number 1 occurs [x.sub.1]times, the number 2 occurs [x.sub.2] times,..., the number n occurs [X.sub.n]times.&quot;andM;One proceeds as if one were using true (and not approximated) concatenationand one writes the program whose admissible trees are of the formandM;Counting(andless;[x.sub.1,...,X.sub.m]andgt;, andless;[y.sub.1]+1,...,[y.sub.n]+1andgt;),andM;each [x.sub.i] being an integer between 0 and m, each [y.sub.i] being thenumber of occurrences of the integer i in the list andless;[x.sub.1,...,x.sub.m]andgt;.andO;Figure 24 illustrates the program:andM;The constraint {andless;1andgt;.Y = Y.andless;1andgt;} is an elegant way of forcing Y to be a list of1's.andP;  If everything were perfect, we could simply ask the query &quot;Counting(X,X), {|X| = n}&quot; to obtain the list of the desired n integers.andP;  Since PrologIII is not perfect, we have to substitute approximate concatenations for trueconcatenations.andP;  We must, therefore, complete the program with an enumerationof the integers [x.sub.1],...,[x.sub.n] that we are looking for.andP;  All thelists are thus constrained to be of integer length--to be true lists;consequently all the approximated concatenations become true concatenations.andO;In order to reduce the enumeration of integers, we introduce two properties:The first property is [x.sub.1] + ...andP;  + [x.sub.n]=2n, which expresses thatthe total number of occurrences of numbers in the sentences is both [x.sub.1]+ ...andP;  + [x.sub.n] and 2n.andP;  The second isandM;[0x.sub.1] + [1x.sub.2] + ...andP;  + (n - 1)[X.sub.r] = n(n + 1)/2,andM;which expresses that the sum of numbers which appear in the sentence is both[1x.sub.1]+[2x.sub.2]+...+[nx.sub.n] and [x.sub.1]+...+[x.sub.n]+1+...+n.andO;From all these considerations the final program results in Figure 25.andM;Assigning successively to n the values 1,2,...,20 and asking the queryandM;Solution(X), {|X| = n}?andM;we obtain as answersandM;{X = andless;3,1,3,1andgt;}, {X = andless;2,3,2,1andgt;}, {X = andless;3,2,3,1,1andgt;}, {X = andless;4,3,2,2,1,1,1andgt;},{X = andless;5,3,2,1,2,1,1,1andgt;}, {X = andless;6,3,2,1,1,2,1,1,1andgt;}, {X =andless;7,3,2,1,1,1,2,1,1,1andgt;}, {X = andless;8,3,2,1,1,1,1,2,1,1,1andgt;},andM;{X = andless;16,3,2,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1andgt;}, {X =andless;17,3,2,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1andgt;}.andM;The regularity in the answer gives rise to the idea of proving that for n [isgreater than or equal to] 7 there always exists a solution of the formandM;[x.sub.1],...,[X.sub.n] = n - 3, 3, 2, 1,...,1, 2, 1, 1, 1.andM;Practical RealizationandM;Prolog III is obviously more than an intellectual exercise.andP;  A prototype of aProlog III interpreter has been running in our laboratory since the end of1987.andP;  A commerical version based on this prototype is now being distributedby the company PrologIA at Marseilles (Prolog III version 1).andP;  This productincorporates the functions described in this article as well as facilitiescalculating maximum and minimum values of numerical expressions.andP;  We havebeen able to use it to test our examples and to establish the followingbenchmarks (on a Mac II, first model).andM;All the figures in Figure 26, except when stated otherwise, are the completeexecution times of complete programs including the backtracking, input ofqueries and output of answers.andP;  The installment calculation consists ofcomputing a sequence of installments i, 2i, 3i,...,ni needed to reimburse acapital of 1000.andP;  In order to do justice to these results, one must take intoaccount the fact that all the calculations are carried out in infiniteprecision.andP;  In the installment example with n=100, a simplified fraction witha numerator and a denominator with more than 100 digits is produced!andM;We conclude this article with information on the implementation of PrologIII.andP;  The kernel of the Prolog III interpreter consists of a two-stackmachine which explores the search space of the abstract machine viabacktracking.andP;  These two stacks are filled and emptied simultaneously.andP;  Inthe first stack, one stores the structures representing the states throughwhich one passes.andP;  In the second stack, one keeps track of all themodifications made on the first stack; for this purpose address-value pairsare used to make the needed restorations upon backtracking.andP;  A general systemof garbage collection [23] is able to detect those structures that havebecome inaccessible and to regain the space they occupy by compacting the twostacks.andP;  During this compaction the topography of the stacks is completelyretained.andP;  The kernel of the interpreter also contains the central part ofthe solving algorithms for the = and [is not equal to] constraints.andP;  Thesealgorithms are essentially an extension of those already used in Prolog IIand described in [8].andP;  The extension concerns the treatment of listconcatenation and the treatment of linear numerical equations containing atleast one variable not restricted to represent a non-negative number.andP;  Ageneral mechanism for the delaying of constraints, which is used to implementapproximated multiplication and concatenation, is also provided in thekernel.andP;  Two submodules are called upon by the interpreter, one for thetreatment of Boolean algebra, the other for the remaining numerical part.andM;The Boolean algebra module works with clausal forms.andP;  The algorithms used [2]are an incremental version of those developed by P. Siegel [24], which arethemselves based on SL-resolution [20].andP;  They determine if a set of Booleanconstraints is solvable, and they simplify these constraints into a set ofconstraints containing only a minimal subset of variables.andP;  Relatedexperiments have been performed with an algorithm based on model enumeration[21].andP;  Although significant improvement has been achieved as far assolvability tests are concerned, a large part of these ameliorations is lostwhen it comes to simplifying the constraints on output.andP;  We should mentionthat W. Buttner and H. Simonis approach the incremental solving of Booleanconstraints with quite different algorithms [6].andM;The numerical module treats linear equations, the variables of which areconstrained to represent non-negative numbers.andP;  (These variables x areintroduced to replace constraints of the form p [is greater than or equal to]0 by constraints x = p and x [is greater than or equal to] 0).andP;  The moduleconsists essentially of an incremental implementation of G. Dantzig's simplexalgorithm [12].andP;  The choice of pivots follows a method proposed in M.andO;Balinski and R. Gomory [1] which, like the well-known method of R. Bland [3],avoids cycles.andP;  The simplex algorithm is used both to verify whether thenumerical constraints have solutions and to detect those variables havingonly one possible value.andP;  This allows us to simplify the constraints bydetecting the hidden equations in the original constraints.andP;  For example, thehidden equation x = y will be detected in {x [is greater than or equal to] y,y [is greater than or equal to] x}.andP;  The module also contains varioussubprograms needed for addition and multiplication operations in infiniteprecision, that is to say, on fractions whose numerators and denominators areunbounded integers.andP;  Unfortunately, we have not included algorithms for thesystematic elimination of useless numerical variables in the solved systemsof constraints.andP;  The work of J-L.andP;  Imbert [17] should be noted in thisconnection.andM;Acknowledgments.andM;I thank the entire research team which has been working on the Prolog IIIinterpreter: Jean-Marc Boi and Frederic Benhamou for the Boolean algebramodule, Pascal Bouvier for the supervisor, Michel Henrion for the numericalmodule, Touraivane for the kernel of the interpreter and for his work onapproximated multiplication and concatenation.andP;  I also thank Jacques Cohen ofBrandeis University whose strong interest has been responsible for my writingthis article, and Franz Guenthner of the University of Tubingen who helped inthe preparation of the final version.andP;  Finally, I thank Rudiger Loos of theUniversity of Tubingen who pointed my attention to two particularlyinteresting numerical problems: the periodical sequence and the filling of arectangle by squares.andM;ReferencesandM;[1] Balinski, M.L.andP;  and Gomory, R.E.andP;  A mutual primal-dual simplex method.andO;In Recent Advances in Mathematical Programming.andP;  R.L.andP;  Graves and P. Wolfe,Eds.andP;  McGraw-Hill, New York, 1963, pp.andP;  17-26.andM;[2] Benhamou F. and Boi, J-M.andP;  Le traitement des contraintes Booleennes dansProlog III.andP;  Theses de doctorat, GIA, Faculte des Sciences de Luminy,Universite Aix-Marseille II.andP;  Novembre 1988.andM;[3] Bland R.G.andP;  New finite pivoting for the simplex method.andP;  Math Oper Res.andO;2, (May 1977), 103-107.andM;[4] Boole G. The Laws of Thought.andP;  Dover Publication Inc., New York.andP;  1958.andM;[5] Brown M. Problem proposed in: Am.andP;  Math.andP;  Monthly 90, 8 (1983), 569.andM;[6] Buttner W. and Simonis, H. Embedding Boolean expressions into logicprogramming.andP;  Symbolic Comput.andP;  4, (October 1987), 191-205.andM;[7] Carroll L. Symbolic Logic and the Game of Logic.andP;  Dover, New York.andP;  1958.andM;[8] Colmerauer A. Equations and inequations on finite and infinite trees.andO;Invited lecture.andP;  In Proceedings of the International Conference on FifthGeneration Computer Systems, (Tokyo, November 1984), pp.andP;  85-99.andM;[9] Colmerauer A. Prolog in 10 figures.andP;  Commun.andP;  ACM 28, 12 (December 1985),1296-1310.andM;[10] Colmerauer A. Theoretical model of Prolog II.andP;  In Logic Programming andits Application, M. Van Caneghem and D. Warren, Eds.andP;  Ablex Publishing Corp.,andO;Norwood, N.J., 1986, 3-31.andM;[11] Colmerauer A. Final specifications for Prolog III, Esprit I projectP1106.andP;  February, 1988.andM;[12] Dantzig G.B.andP;  Linear Programming and Extensions.andP;  Princeton UniversityPress, Princeton, N.J., 1962.andM;[13] Dincbas M. et al.andP;  The constraint logic programming CHIP.andP;  InProceedings of the International Conference on Fifth Generation ComputerSystems, (Japan, December 1988), FGCS '88, pp.andP;  693-702.andM;[14] Duijvestijn A.J.W.andP;  Simple perfect squared square of lowest order.andO;Comb.andP;  Theory.andP;  ser.andP;  B 25, (1978), 240-243.andM;[15] Gardner M. Wheels, Life and Other Mathematical Amusements.andP;  W.H.andO;Freeman and Co., 1983.andM;[16] Genesereth M.R.andP;  and Ginsberg, M.L.andP;  Logic programming.andP;  Commun.andP;  ACM28, (September 1985), 933-941.andM;[17] Imbert J-L.andP;  About redundant inequalities generated by Fourier'salgorithm.andP;  AIMSA'90, Fourth International Congerence on ArtificialIntelligence: Methodology, Systems, Applications.andP;  Albena-Varna, Bulgaria.andO;(September 1990), To be published.andM;[18] Jaffar J. and Lassez, J-L.andP;  Constraint logic programming.andP;  FourteenthACM Symposium on the Principle of Programming Languages, (1987), pp.andO;111-119.andM;[19] Jaffar J. and Michaylov, S. Methodology and Implementation of aConstraint Logic Programming System.andP;  In Proceedings of the FourteenthInternational Conference on Logic Programming (Melbourne).andP;  MIT Press,Cambridge, Mass.andP;  1987, pp.andP;  196-218.andM;[20] Kowalski R. and Kuehner, D. Resolution with Selection Function.andP;  Artif.andO;Intell.andP;  3, (1970), 227-260.andM;[21] Oxusoff L. and Rauzy, A. Evaluation semantique en calcul propositionnel.andO;Theses de doctorat.andP;  GIA, Faculte des Sciences de Luminy, UniversiteAixMarseille II.andP;  January 1989.andM;[22] Robinson A. A machine-oriented logic based on the resolution principle.andO;J. ACM 12, (December 1965).andM;[23] Touraivane.andP;  La recuperation de memoire dans les machines nondeterministes.andP;  These de doctorat, Faculte des Sciences de Luminy, UniversiteAixMarseille II, November 1988.andM;[24] Siegel P. Representation et utilisation de la connaissance en calculpropositionnel, These de doctorat d'Etat, GIA, Faculte des Sciences deLuminy, Universite Aix-Marseille II, July 1987.andM;[25] Sprague R. Uber die Zerlegung von Rechtecken in lauter verschiedeneQuadrate.andP;  J. fur die reine und angewandte Mathematik 182, (1940).andM;CR Categories and Subject Descriptors: D.3.2 [Programming Languages] LanguageClassifications: I.2.3 [Artificial Intelligence] Deduction and TheoremProvingandM;General Terms: Design, LanguagesandM;Additional Key Words and Phrases: Constraints, logic programming, PrologandM;About the Author:andM;Alain Colmerauer is a professor in computer science at the University II ofMarseille.andP;  His current research interests include solving systems ofconstraints in various domains and design of very high-level programminglanguages.andP;  Author's Present address: Faculte des Sciences de Luminy, 13288Marseille, Cedex 9, France.andM;Permission to copy without fee all or part of this material is grantedprovided that the copies are not made or distributed for direct commercialadvantage, the ACM copyright notice and the title of the publication and itsdate appear, and notice is given that copying is by permission of theAssociation for Computing Machinery.andP;  To copy otherwise, or to republish,requires a fee and/or specific permission.andO;</TEXT></DOC>