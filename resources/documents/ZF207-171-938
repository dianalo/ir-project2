<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-171-938  </DOCNO><DOCID>07 171 938.andM;</DOCID><JOURNAL>AI Expert  Feb 1989 v4 n2 p50(7)* Full Text COPYRIGHT Miller-Freeman 1989.andM;</JOURNAL><TITLE>Natural language query processing. (includes related article onquery interpretation)</TITLE><AUTHOR>Winston, Timothy W.; Taylor, Michael B.; Leeds, Richard.andM;</AUTHOR><SUMMARY>Conflicting parsing demands can be satisfied with efficientnatural-language techniques and a restricted language domain.andO;Natural language access to database systems, one of the earliestimplementations of artificial intelligence technology, has becomeincreasingly important as the viability of a general mechanism forretrieving information has been increased by relational databases.andO;A technique is given that uses grammar inference rules to make aparse tree from a query and the eight steps needed to perform thetask are given.andM;</SUMMARY><DESCRIPT>Topic:     Natural Language InterfacesQuery ProcessingParsingRelational Data BasesQuery LanguagesInformation Storage and Retrieval.andO;Feature:   illustrationchart.andO;Caption:   Classical (Chomsky) parse. (chart)Assigning words to semantic classes. (chart)Rule results. (chart)andM;</DESCRIPT><TEXT>Natural LANGUAGE QUERY ProcessingandM;Natural-language access to database systems was one of the earliestcommercial applications of AI technology.andP;  Relational databases haveincreased the viability of a general mechanism for retrieving information,especially in formulating ad hoc queries.andP;  To meet the conflicting demands ofaccepting reasonable English questions and fast inter-active performance, wechose the most efficient natural-language technique and restricted thelanguage domain to questions about data.andM;Our technique uses gramar inference rules to make a parse tree from the queryand create a static representation of the query (or case frameinstantiation).andP;  The case frame is a platform for performing a query,handling in-context queries, or generating a formal language query.andM;Traditional natural-language systems try to resolve the input to awell-formed sentence using a classical Chomsky parse (Figure 1).andP;  The parsetree for the sentence is then used to determine input content.andP;  As a result,traditional systems have difficulty managing unusual sentence structure andsentence fragments.andP;  Our parsing system assumes the input is a database queryand doesn't need to resolve the input to a sentence.andP;  IT is sufficient toorganize the query into recognizable parts; unusual sentence structure andsentence fragments are handled without any extra processing.andM;TOKENIZE THE QUERYandM;Initially, each word is assigned a semantic class (Figure 2).andP;  Contractionsare expanded, then each word in the query is checked against the internalvocabulary, schema, user lexicon, previous spelling corrections, and datapreviously found in the database.andM;The built-in vocabulary contains about 300 words; each has a semantic classand subclass.andP;  The classes are based on the parser's meaning of the word,which may not be a person's interpretation.andP;  Checking words against thedatabase schema allows recognition of relation and field names and helpsadapt the parse to the data.andM;Data values may or may not be important to parsing a query.andP;  When a value isused in an explicit condition, such as List employees with city = Seattle?,andO;the grammar associates Seattle with the field city; it is unnecessary to findit in the data.andP;  But with implicit conditions such as List Chicagosecretaries, Chicago and secretaries must be recognized as data belonging tospecific fields to be converted into conditions.andP;  To minimize userclarification, spelling corrections and other dialogue are recorded and usedfor word identification in succeeding queries.andP;  As word is identified, it isput into a linear linked list: the initial parse tree.andM;LINEAR REPRESENTATIONSandM;Grammar rules transform the initial, linear parse tree into atwo-dimensional, final parse tree.andP;  The grammar rules work solely onphrases--the top-level nodes of the parse tree.andP;  Initially, each phrase is asingle word from the query.andP;  A grammar rule describes a transformation to theparse tree and reorders or reduces it.andP;  Reorder rules identify a group ofphrases and reorder them for later processing.andP;  Reduction rules identify agroup of phrases and replace them with a new phrase that has a differentsemantic class, reducing the number of top-level nodes.andP;  The original phrasesare added as children to the new phrase.andM;Since converting the user's query into a parse tree and interpretingresponses to clarification requests may execute the grammar rules many times,it is important that the process be as efficient as possible.andP;  The grammarrules are written in a specially designed language (Listing 1), which iscompiled into intermediate code.andP;  This code is then interpreted to match andexecute rules.andP;  Rules consist of two parts: the pattern to match and thetransformation definition.andM;Three elements determine how a grammar rule is matched:andM;* Filters: fast, predefined screening criteria for the query phraseandM;* Grammar description: the exact pattern that must matchandM;* Check number: a hook to a C language function to check matching criteriabeyond the scope of the rule language.andM;The transformation part of the rule also has three parts:andM;* Reorder/reduction flagandM;* Replacement grammarandM;* Demon number: a hook to a C language function to perform transformationbeyond the scope of the rule language.andM;Grammar analysis has two kinds of rules, iterative and noniterative.andP;  Theparse tree is checked only once against noniterative rules.andP;  The rule thatremoves articles from the query is an example of this type.andP;  Noniterativerules are checked first.andP;  Iterative rules are executed after all thenoniterative rules.andP;  Each time an iterative rule is matched, rule-matchingrestarts at the first iterative rule.andP;  This continues until no rules match(Figure 3).andM;Any rule can specify four filters that aid in pattern-matching efficiency.andO;&quot;Minimum&quot; defines the minimum number of parse tree nodes needed by the rule;&quot;class&quot; defines a class that must appear in the query for the rule to match;&quot;object&quot; requires the first node that matches the rule to be an object (forexample, a database field or value, data constant, or arithmetic expressioninvolving objects); and &quot;class at&quot; defines a class the rule requires at aspecified location in the parse tree (an offset from the first node thatmatches).andP;  A rule can also specify demon and check routines, whether thepatter must be at the beginning of the parse tree, and whether the ruleperforms a tree reorder or reduction.andM;The pattern to be matched consists of three parts: the leading, old, andtrailing sections.andP;  These sections consist of a list of item identifiers, inwhich an item corresponds to a node in the parse tree.andP;  These sections can bequire complex: each defines how the top level of the parse tree must beconstructed to match the rule.andP;  The leading and trailing sections areoptional and define the context of the pattern.andP;  The old section defines thepart of the parse tree that will be transformed.andP;  The last part of the rule,the new section, defines the transformation to be applied to the parse tree.andM;An item (node) is identified by up to four pieces of information: class,subclass, whether or not the item is an object, and data type (for objects).andO;Optionally, each item can be tagged with a label used in the new section.andP;  Inan item identifier, any or all of the pieces of information can be specified;if a piece is omitted, any value for it matches.andM;A simple list of item identifiers is insufficiently powerful to match evenmildly complex natural-language phrases.andP;  For this reason, a grammar rule canspecify two methods of alternate items: OR and NOT lists.andP;  An OR listspecifies item identifiers that can be used to match the curren parse treenode.andP;  A NOT list specifies item identifiers that, if any match the currentparse tree node, cause the list not to match.andP;  In addition, the grammar rulesallow repeating groups, which can contain OR and NOT lists.andP;  Repeating groupscome in three flavors (0 or more, 0 or 1, and 1 or more) and define anoptional list of item identifiers (0 or more and 0 or 1) that can be repeated(0 or more and 1 or more).andM;The new section is a list of item identifiers that define the new top-levelnodes of the parse tree.andP;  If the rule is a shuffle rule, these nodes replacethose matched by the old section.andP;  If the rule is a tree-reduction rule, thenodes matching the old section are made into a subtree pointed to by thefirst node of the new section.andP;  Any item identifier in the new section taggedwith a label is made by copying the corresponding node (and any subtreehanging from the node) in the old section.andP;  Any node without a label is newlycreated and must have a class specified.andM;The compiled grammar rules are stored in a linear list with all thenoniterative rules preceding the iterative rules.andP;  Since the rules are triedin order, their order is very important.andP;  Each rule is compared with eachphrase in the query.andP;  If a rule matches a phrase, it is executed.andP;  Afterexecution, a new rule is tried.andP;  The new rule is either the next rule afterthe one that matched (if the matching rule is a noniterative rule) or thefirst iterative rule.andP;  The pattern-matching engine counts the number oftop-level nodes in the parse tree and flags the classes that appear.andP;  Thisallows fast checking for the minimum and class filters.andP;  This task isperformed at the beginning and end of rule-matching.andM;When trying to match a rule, the engine first verifies the filter criteria.andO;If any of the filters fail, the next rule is tried.andP;  If all the filters pass,the engine uses a recursive pattern-matching algorithm to compare theleading, old, and trailing sections of the rule against the parse tree.andP;  Ifany of these tests fail, the process starts again with the next rule.andP;  If allthree sections pass, the check routine is called to test criteria beyond thescope of the rule language.andP;  If the check routine fails, the process startsagain with the next rule.andM;If all the tests pass, the rule matches a phrase in the query.andP;  The query isnow transformed using the new section of the rule.andP;  These transformations aredivided into three cases.andP;  The first is for rules with no new section.andP;  Inthis case, the old nodes (parse tree nodes that matched the old section) arediscarded and the nodes on either side of the old nodes are joined.andM;The other two cases are for rules with a new section.andP;  In these cases, theengine loops through the item identifiers in the new section and builds thenew nodes, either by allocating a new node or copying the node from the oldnodes.andP;  After the new nodes are built, the old nodes in the parse tree areexcised and the new nodes inserted.andP;  For re-order rules, the old nodes arediscarded.andP;  In reduction rules, the old nodes are attached as a subtree tothe first of the new nodes.andM;If the rule specifies a demon routine, it is called after the transformationgenerates new nodes and performs any final transformations beyond the scopeof the rule language.andP;  Because the pattern-matching engine is recursive anditerative, it is critical that the compiled versions of the grammar rulesexecute as rapidly as possible.andP;  These conditions also suggest using as fewgrammar rules as necessary.andM;Increasing the number of statements that can be correctly parsed increasesthe number of rules required to parse any given statement.andP;  Robustgrammar-rule syntax and a fast pattern-matching engine are required for asuccessful response to this problem.andM;IDENTIFY UNRECOGNIZED WORDSandM;After the grammar rules are completed, the top phrases are examined to ensurethat all nodes have a semantic class.andP;  The data is searched for unclassifiedwords; if any are found, information about them is stored and the parserrestarts at step 1.andM;If no unclassified words are found in the data, the user is asked either toidentify or define them.andP;  Using this new information, the parser restarts atstep 1.andP;  This step is attempted last to balance the time required for a datasearch with the benefit of using the data as part of the vocabulary.andM;After all words are recognized and the grammar rules have completed the parsetree, the user is asked to clarify incomplete phrases.andP;  An example of this isan extraneous numeric constant: &quot;Who's got 40,000?&quot;andP;  Something is equal to40,000; it is clearly a condition, but the condition is unclear--so we askthe user.andP;  The user's response is then parsed using the grammar rules, andthe new information, if it makes sense, is added to the parse tree.andP;  If itdoesn't make sense, the dialogue continues.andP;  After the parse tree has beencompletely resolved, the case frame is built (Figure 4).andP;  The case frame iscomprised of two data structures: the case frame proper, containing slots forstoring the various parts of a query (for example, sort fields), and anobject list of all the objects (for example, database fields, constants,expressions) needed by the query.andM;Building the case frame occurs in two phases: building the object list andfilling the case frame slots for the current query.andP;  The structure of theparse tree simplifies building the object list.andP;  Each node is examined to seeif it defines an object.andP;  If it defines a simple object, it is added to theobject list (unless it is already present).andP;  If the object is made up ofother objects (for example, an expression), all the objects in the subtreeare added, then the object for the node is added.andP;  Filling the case frameslots for the current query involves most of the discourse heuristics.andP;  Theseheuristics include:andM;* Determining when the word &quot;and&quot; in a conditional phrase is a logical OR(for example, List the employees in sales and marketing)andM;* Correct interpretation and scoping of words like &quot;not&quot; and &quot;except&quot; (forexample, List the employees in sales, except Smith in Seattle and Jones inDetroit, Show me everything except salary and hire date for the employees insales)andM;* Deciding between sorting and grouping in ambiguous phrases (for example,List employees by salary, List department by average salary).andM;When the case fram is completely built, it represents an explicit translationof the natural-language query.andP;  This explicit case frame is used to build thecompleted case frame and during frame building for the next query.andP;  Thediscourse heuristics used in frame building form one area of our system thatis almost continually evolving.andP;  As we gain experience on how users askquestions and what their intentions are for the questions they ask, we adjustthe heuristics to improve interpretation performance.andM;INTEGRATE CASE FRAMESandM;The query is now analyzed for context--that is, if it refers to the previousquery.andP;  This analysis uses two different methods.andP;  In the first, the parsetree is examined to find three basic types of in-context queries.andP;  If thequery begins with a conjunction (for example, &quot;or,&quot; &quot;and,&quot; &quot;also&quot;), weconsider it in context.andP;  Since pronouns (&quot;his,&quot; she,&quot; &quot;their&quot;) generallyrefer backward rather than forward, if a pronoun occurs before any object inthe query, we consider the query in context.andP;  If a query references noobjects at all (for example, List the top 5), we consider it in context.andM;In the second method, the case frame is examined to see if the user providedenough information (such as fields to list, data selection criteria, and sortor group fields) to build a reasonable query.andP;  Obviously, not all of theseare needed for a complete query.andP;  Any query that specifies no fields to listand either sort and group fields or data-selection criteria (but not both) isin context.andP;  If the query is in context, the previous case frame is mergedwith the current case frame.andP;  For in-context queries, merging is generally asimple process: lists of objects (objects to be printed) can be concatenatedwith duplicates removed.andM;For the data-selection criteria, however, the merging process is muchdifferent.andP;  In building the final current case frame, the selectionconditions of the current and previous case frames are examined for parallelconstructions.andP;  If any are found, conditions from the previous case frame arediscarded and replaced by conditions in the current case frame.andM;COMPLETE THE CASE FRAMEandM;Frame completion takes the explicit case frame and produces a complete query.andO;The explicit case frame contains only what was said in the query; it is not acomplete query.andP;  It must be formalized by adding implicit key elements, suchas relation links.andP;  It contains only explicit field references from thequery: implicit display, grouping, and sorting references must be added.andM;For example, the query List salaries greater than 30K contains only acondition, salaries andgt; 30,000.andP;  But by implication, salary should also bedisplayed.andP;  User present information is added to the case frame, such as who,referring to employees.andP;  The formalization of the case frame includesdetermining relation links and adding the link conditions to the selectioncriteria, coercing constant types to match field types in conditions,expanding condition of the form HIREDATE = March 1987 to be multipleconditions, HIREDATE [is greater than or equal] 3/1/1987 AND HIREDATE [isless than or equal] 3/31/1987, and determining which fields are detail andwhich are summary.andM;Implication heuristics are used to fill out the display list, and fields fromthe sort and group lists and nonequals conditions are added to it.andP;  The usermay present some implications, such as what fields are implied by who, when,and where, or fields to be displayed whenever their relation is referenced.andO;For example, presetting can cause the query list salaries to display EMPNAME,because SALARY is a field in EMPLOYEE.andM;As a result of implication heuristics, a natural query is often much shorterthan a formal query.andP;  For example:andM;* List employees by salary displays SALARY as well as sorting by it.andP;  Formallanguages require explicitly specifying SALARY as both a display and a sortfield: SELECT  EMPNAME SALARY FROM  EMPLOYEE ORDER BY  SALARYandM;* List Chicago secretaries adds the link between the EMPLOYEE and DEPARTMENTrelations and determines the user doesn't need to see CITY or JOBNAME butdoes want to see the employee name since the EMPLOYEE relation is beingqueried.andP;  Formal languages require all this to be explicitly stated: SELECT EMPNAME FROM  EMPLOYEE DEPARTMENT WHERE  CITY = &quot;Chicago&quot; AND  JOBNAME =&quot;secretary&quot; AND EMPLOYEE.DEPT# = DEPARTMENT.DEPT#andM;PERFORM THE QUERYandM;The completed case frame is the program's interpretation of thenatural-language query.andP;  It may be used to verify the interpretation of thequery, generate a formal query (such as SQL, QBE, or a fourth-generationdata-reporting language), or retrieve data directly from a database anddisplay the results, or all three (Listing 2).andM;Our goals when we designed the parser were to interpret reasonable Englishquestions, minimize user interaction, perform acceptably on a personalcomputer, and adapt to various software environments, like user interfaces,database programming languages, and operating systems.andP;  We met all of thesegoals by choosing efficient natural-language techniques and restricting thelanguage domain to questions about data.andO;</TEXT></DOC>