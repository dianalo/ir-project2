<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF207-731-790  </DOCNO><DOCID>07 731 790.andM;</DOCID><JOURNAL>Computer Language  Oct 1989 v6 n10 p45(5)* Full Text COPYRIGHT Miller-Freeman 1989.andM;</JOURNAL><TITLE>A numerical equation solver in PROLOG.andO;</TITLE><AUTHOR>Covington, Michael A.andM;</AUTHOR><SUMMARY>PROLOG is used here to do heuristic searches for solvingequations.andP;  Until now, PROLOG has not been known as a languagethat could be used to solve arithmetic equations since it cannotsearch a set of real number the way it searches symbols in aknowledge base.andP;  However, the author demonstrates how PROLOG isactually an ideal language for solving equations because equationscan be treated as data and the program can modify itself.andP;  Thesample program provided solves equations by the secant method.andM;</SUMMARY><DESCRIPT>Topic:     ProgramsPROLOGMathematical ProgrammingType-In Programs.andO;Feature:   illustrationgraphprogram.andO;Caption:   The secant method. (graph)Sample program listing of an algorithm in pseudocode form.andO;(program)andM;</DESCRIPT><TEXT>A Numerical Equation Solver in PROLOG One of the frustrating things aboutusing PROLOG is that it can't solve arithmetic equations.andP;  Ironically, PROLOGwas designed to solve for any unknown in queries that are not numeric.andP;  Forexample, given the fact father(michael,sharon).andP;  you can ask?--andO;father(michael,X).andP;  and get the answer sharon, or ask ?-- father(X,sharon).andO;and get the answer michael.andP;  This interchangebaility of unknowns extends tocomplex symbolic manipulations (for instance, append can be used to split aswell as concatenate lists), but not to arithmetic.andM;By contrast, PROLOG's arithmetic is as primitive as FORTRAN's was 30 yearsago.andP;  The unknown is a single variable on the left of the operator is, andeverything on the right must be known.andP;  Thus?-- X is 2+2 gets the answer 4,but?-- X is 1+1/X fails or raises an error condition.andM;The excuse for this restriction is that PROLOG cannot search the set of realnumbers the way it seaches the symbols in a knowledge base.andP;  As far asexhaustive search goes, this is true.andP;  However, mathematicians have beenusing heuristic searches to solve equations since the day of Isaac Newton.andO;The procedures given here implement one such method, making it possible tohave dialogues such as these with the computer:andM;?-- solve(X=1+11/X).andP;  X=1.618034andM;?-- solve(X=Cos(X)).andP;  X=0.739085.andM;The solutionandM;PROLOG is an ideal language for solving equations for two reasons: equationscan be treated as data and the program can modify itself.andP;  A procedure canaccept arithmetic expressions as parameters, then evaluate them or evencreate procedures to evaluate them.andP;  In Pascal or C, by contrast, no simpleway exists to introduce a wholly new equation into the program at run time.andO;The techniques shown here require full Edinbrugh-compatible PROLOG--theydon't work in Turbo PROLOG.andM;The program presented here solves equations by the secant method, one of thesimplest numerical methods though not the most robust.andP;  A different methodcan easily be substituted once the framework of the program is in place.andP;  Tosolve the equation Left = Right, the secant method uses the function Dif(x) =Left -- Right, where Left and Right are expressions that contain x.andP;  Theproblem is then to search for an x such that Dif(x) = 0.andM;The search is begun by taking two guesses at x and comparing the values ofDif(x) for each.andP;  One of them will normally be closer to zero than the other.andO;From this information the computer can tell whether to move toward higher orlower guesses.andP;  In fact, by assuming that Dif(x) increases or decreaseslinearly with x, the computer can estimate how far to move.andP;  Hence themethod's name: given two guesses, the third guess is formed by extending asecant line o n the graph of the function (Figure 1).andM;Success is not guaranteed--the two Dif values could be equal or the estimateof how far to move could be misleading--but the procedure usually convergeson a solution in just a few iterations.andP;  Listing 1 shows the algorithm inpseudo-code form.andM;Finding the unknownandM;Two things must be done: the problem must be set up and the computationperformed.andP;  The setting up is done by solve, which calls free__in,define__dif, and solve__for (Listing 2).andM;The first step is to identify the unknown; that is, to pick out the freevariable in the equation to be solved.andP;  This is done by free__in, which findsthe free (uninstantiated) variables in any PROLOG term.andP;  This is more generalthan what we need, but it's always useful to build a general-purpose tool.andM;If the term contains a free variable, two possibilities exist: either theterm is the variable, in which case the search is over, or the term has avariable somewhere in its argument structure.andP;  free__in has a clause for eachof these cases.andM;The second case requires the term to be decomposed into a list.andP;  The built-inpredicate univ (=..) does this:andM;a(b,c(d),e)=..[a,b,c(d),e].andM;2+3+X=..['+',2,3+X].andM;Even lists can be split this way, because any list is really a two- argumentstructure with the dot as its principal functor.andP;  In other words, the list[a,b,c] is really a.(b.(c.[])), though not all PROLOGs allow you to write itthat way, so [a,b,c]=..['.],a,[b,c]].andP;  Thus a list is not a special case; itcan be treated jus like any other complex term.andM;In free__in, the statement Term =.. [__,Arg|Args] discards the functor, whichcan't be a variable anyway, and obtains two things: the first argument, Arg,and the list of subsequent arguments, Args.andP;  It then becomes straightforwardto search for variables in both Arg and Args.andP;  Further, because Arg can be asingle variable, the first clause has a chance to terminate the recursion;and if it isn't, whatever is the first element of Args on this pass will beArg on the next recursive pass and will be examined then.andM;However, a special case must be ruled out.andP;  The term [[]] decomposes into['.',[],[]], giving Arg [] and Args = [[]], which would lead to an endlessloop.andP;  For this reason, free__in explicity tests for this term and rejectsit.andM;Defining a procedureandM;The next step is to define a procedure to compute Dif.andP;  Recall that theargument of solve is an equation in the form Left=Right.andP;  Clearly, the Diffunction is obtained by evaluating Left--Right.andP;  But how is this done?andM;One possibility would be to pass along the expression Left--Right andevaluate it whenever needed.andP;  This is easy, because X is Y will evaluate anyexpression to which Y is instantiated.andM;But the other, faster possibility is to define a procedure to do theevaluating.andP;  That's what define__dif does; it creates a procedure thataccepts a value of X and evaluates Dif.andP;  For example, if the equation to besolved is X=cos(X), the procedure is dif(X,Dif):- Dif is X -- cos(X).andM;In ALS PROLOG (Applied Logic Systems, Syracuse, New York), this dif procedureis compiled into threaded code when assert places it into the program; theprogram runs just as fast as if dif had been supplied by the originalprogrammer.andP;  Other PROLOGs run dif interpretively.andM;What connects the variable X to the expression Left--Right, in which it issupposed to occur?andP;  This question addresses the heart of PROLOG's variablescoping system.andP;  It isn't enough to simply call the variable X; like-namedvariables in PROLOG are not the same unless they occur in the same rule,fact, or goal.andM;That's why so many goals in this program have both X and Left = Right (orLeft--Right) as arguments.andP;  Initially, free__in takes Left and Right andfinds a variable in them.andP;  This variable may have any name, but it is unifiedwith the variable X in solve.andP;  This same X is then passed, along with Leftand Right, to define__dif, which uses is in creating the dif procedure.andO;Thereafter, the X in dif is guaranteed to be a variable that occurs inLeft--Right and in dif, regardless of what the user originally called it.andM;Solving the equationandM;The last step is to implement the secant method (Listing 3).andP;  The pseudocodein Listing 1 undergoes several changes when translated into PROLOG.andM;First, PROLOG has no loop constructs, so recursion is used instead.andP;  The loopis replaced by the procedure solve__aux, which calls itself.andP;  Because therecursive call is the last step of a procedure with no untried alternatives,the compiler converts it back into a loop in machine language, butconceptually the programmer thinks in terms of recursion.andM;Second, PROLOG has no way to change the value of an instantiated variable.andO;This means, for example, that PROLOG has no counterpart of Guess1 := Guess2,when Guess1 already has a value.andP;  Instead, the proper PROLOG technique is topass a new value in the same argument position on the next recursive call.andO;Thus the procedure that begins with solve--aux (...Guess1, Dif1, Guess2...)andO;:- ...  ends with the recursive call ...andP;  solve__aux(...Guess2,Dif2,Guess3...).andM;Third, minor rearangements will prevent Dif(X) from being computed more thanonce with the same value of X.andP;  These include the variable Dif2 and thepassing of Dif1 as an argument from the previous recursive pass.andM;Limitations and possibilitiesandM;The program in Listings 2 and 3 is intended as a demonstration of theintegration of numerical methods into PROLOG, not as a demonstration ofnumerical methods per se.andP;  The secant method is simple but far from perfect.andO;It has trouble with some equations.andP;  For example, if two successive Difvalues happen to be exactly the same distance from zero, solve__aux will tryto divide by zero.andP;  This simply fails in ALS PROLOG but may cause an errormessage in other PROLOGs.andM;This problem shows up with the equation Xandless;andless;2 - 3*X = 0, which has Dif=-2 forboth of th e first two guesses (1 and 2).andP;  With a case very close to this,such as Xandless;andless;2 - 3.01*X = 0, we find that although the method should work inprinciple, in practice the next guess is a long way from the correctsolution, and the guesses run wildly out of the range of representablenumbers.andP;  With some equations, the guesses will bounce back and forth betweentwo values, not getting better with successive iterations.andP;  [1]andM;More robust numerical methods can easily be substituted into the same programframework.andP;  The ability to solve for more than one unknown is desirable; thiscould be treated as a multivariable minimization problem where the goal is tominimize abs(Dif(X)).andP;  [2]  It is possible to solve systems of nonlinearequations by reducing them to systems of linear equations, which can then besolved by conventional methods.andM;The program was written in ALS PROLOG nd has been tested in Quintus PROLOG.andO;However, other PROLOGs may require minor modifications.andP;  Arity PROLOG 4.0requires spaces before certain opening parentheses, such as 2+ (3+4) +5rather than 2+(3+4)+5.andP;  And a general liitation of real-number arithmetic isthat a negative number cannot be raised to a noninteger power (4andless;andless;2.5 ispermitted but (-4)andless;andless;2.5 is not).andP;  Some PROLOGs assume all exponents arenoninteger.andM;ReferencesandM;[1] Hamming, Richad W. Introduction to Applied Numerical Analysis.andP;  New York,N.Y.: McGraw-Hill, 1971, pp.andP;  33-55.andM;[2] Press, William H., Brian P. Flannery, Saul A. Teukolsky, and William T.andO;Vetterling.andP;  Numerical Recipes: The Art of Scientific Computing.andP;  Cambridge,U.K.: Cambridge University Press, 1986, pp.andP;  240-334.andM;Michael A. Covington does research on natural language processing at theUniversity of Georgia at Athens and is a co-author of Prolog Programming inDepth (Scott, Foresman and Co., 1988).andO;</TEXT></DOC>