<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-156-518  </DOCNO><DOCID>08 156 518.andM;</DOCID><JOURNAL>Dr. Dobb's Journal  Feb 1990 v15 n2 p123(9)* Full Text COPYRIGHT Mandamp;T Publishing 1990.andM;</JOURNAL><TITLE>TEXTSRCH connections. (part three in the development of a textretrieval system) (column)</TITLE><AUTHOR>Stevens, Al.andM;</AUTHOR><SUMMARY>This third part in the development of a text retrieval system,TEXTSRCH, develops a program for building an index and integratesthe various components of the system.andP;  TEXTSRCH enables thebuilding of files in a text data base and creates aconcordance-like index for the data base.andP;  The construction of aninverted index for the data base is based on the extraction ofeach word from every file in the data base and the use of ahashing algorithm to create a random address for each word.andP;  Anormalizing function converts each word into a form suitable forindexing.andP;  A TEXTSRCH retrieval program, search.c, is developed.andO;It includes a search function, srchtree, to see if a target wordis in a 'noise word' list of common words and a search_indexfunction to determine the random address of each word beingsought.andM;</SUMMARY><DESCRIPT>Topic:     TutorialProgramming InstructionApplications ProgrammingInformation Storage and RetrievalText Data BasesIndexing.andO;Feature:   illustrationprogram.andO;Caption:   Listing five: code to build aand search files. (program)Listing six: program for building an index. (program)Listing eight: the TEXTSRCH retrieval process. (program)andM;</DESCRIPT><TEXT>TEXTSRCH ConnectionsandM;This month we continues with the TEXTSRCH project, one that started twomonths ago.andP;  To build the entire project, you will need the express.c sourcefile from December, the exinterp.c and textsrch.c files from January, and theseveral source files introduced this month.andM;TEXTSRCH is a text retrieval system that provides a concordance-like indexinto a text data base.andP;  You provide the files of text, and TEXTSRCH builds aninverted word index into the files.andP;  Later, when you go looking for someforgotten reference to something, you use the TEXTSRCH query language tocompose a query, and TEXTSRCH finds and reports to you the files that matchyour search.andP;  I described the syntax of the query two months ago anddeveloped its interpreter last month.andP;  This month we build index files andconnect it all together.andM;TEXTSRCH consists of several widely used techniques.andP;  Besides its usefulnessas a text management tool, it provides examples of hashing, binary trees,command-line parsing, expression parsing, infix and postfix expressionnotation, and expression interpreting.andM;Listing One, page 140, is textsrch.h, Version 3.andP;  We built the first versiontwo months ago and added to it last month.andP;  Most of this month's additionsare function prototypes for the code that follows, but there is one othernotable addition.andP;  The MAXFILES variable will influence the size of your database index.andP;  It specifies the maximum number of text files that a TEXTSRCHindex can support.andP;  If you change this number, you will change the size ofthe bit map that the expression interpreter needs.andP;  Remember, the bit map hasone bit per file in the data base.andP;  When the bit map size changes, so doesthe size of one of the index files.andP;  The file named &quot;TEXT.NDX&quot; includes,among other things, a copy of the bit map that corresponds to every uniqueword in the data base.andM;Before we get into the index code, let's look at two general-purposefunctions that TEXTSRCH uses and that you might find useful in otherprojects.andM;Parsing the Command LineandM;Listing Two, page 140, is cmdline.c, a source file that contains theparse_cmdline function.andP;  The function processes a program's command-lineparameters and is the only part of TEXTSRCH that is oriented to any specificarchitecture in that it works with MS-DOS and Turbo C.andP;  You can easily redoit for another compiler or a different architecture.andP;  Its purpose is to parsefile name specifications from the command-line into discrete file names andto call a specified function to process each file.andP;  In addition,parse_cmdline will sense the presence of command-line option switches and setentries in an associated array to logical true and false states accordingly.andO;TEXTSRCH does not use this last feature, but parse_cmdline supports itnonetheless.andM;When your program first begins, it calls parse_cmdline and passes theconventional argc and argv variables that are available as parameters to themain function.andP;  Your program also passes the address of a 128-byte array ofswitches and the address of a function.andP;  The function, provided in yourprogram, will process the files, one by one.andM;The option array contains the initial default setting for the command-lineswitches.andP;  This statement tests the array:andM;if (array('a')) ...andM;If the command-line had +a on it, this test would be true.andP;  If the parameterwas -a or if the default had a zero value in the 61st (ASCII assumed)position, the test would be false.andM;The function selects each file specification and calls the function addressedby the last parameter in the call to parse_cmdline.andP;  If you explicitly namefiles on the command-line, each of these is processed in turn.andP;  You can usewild cards or prefix a file name with the @ character to specify that thefile names to be processed are recorded in a text file.andM;If you use wild cards, the files that match the ambiguous specification areprocessed in the order in which the directory scan finds them.andP;  I used theTurbo C findfirst and findnext functions for the directory scan.andP;  Microsoft Chas similar but different ones named _dos_findfirst and _dos_findnext.andP;  Othercompilers have their own versions of these functions or, at least, ways tocall MS-DOS directly to use the MS-DOS functions that perform theseoperations.andP;  If you use a different operating system, then you must provideother ways to get the same result.andP;  If you use an operating system that doesnot support a directory scan or ambiguous file name specifications, then youmust use the @ prefixed file of file names supported by parse_cmdline.andM;A Binary TreeandM;Listing Three, page 141, is bintree.c.andP;  It contains the functions to buildand search a binary tree.andP;  The tree in question is used for what we call&quot;noise&quot; words, and I'll explain that feature soon, but first you need toconsider the addtree and srchtree functions and binary trees in general.andM;A binary tree is a search data structure that facilitates fast searches ofkey values.andP;  Each entry in the tree contains the value to be searched and twopointers--a pointer to the entries with values that collate higher than thecurrent one, and a pointer to the entries that are lower.andP;  Even with a largenumber of entries, the number of compares needed to find a value isreasonably small.andM;The addtree function adds entries to the tree, which is empty at first.andP;  Itallocates memory for the entry from the heap and then calls srchtree to seeif the entry is already there or, if not, where it should be inserted.andM;After the tree is built, we use the srchtree function to tell us if a valueis in the tree.andP;  In this implementation of the binary tree there are no otherdata values in an entry.andP;  We use the tree to determine the presence orabsence of a value, nothing more.andM;Binary trees are most efficient when the entries are added to the tree inrandom sequence.andP;  If you were to build one from an ordered list of entries,the tree would have one long branch, and searches would be inefficient.andO;There are tree balancing algorithms for binary trees, but we do not need onefor our use here because we build the tree once, and our original order israndom.andM;Noise WordsandM;We use the binary tree for a list of noise words.andP;  Noise words are thosewords that are so common that we can assume that they appear in every file.andO;The word &quot;the&quot; is a typical noise word.andP;  Because we can make that assumption,we can bypass such words when we build our index, thus saving index space.andO;Likewise, we can bypass searching the index for such words during retrievals,thus saving time.andM;The build_noisewords function in bintree.c builds the binary tree from a textfile that contains all the noise words.andP;  Listing Four, page 142, isnoise.1st, a small file of noise words that I arbitrarily selected.andP;  Youmight want to review the list and modify it.andP;  The more words you can put intothe noise word list, the more efficient your index will be.andM;Building the IndexandM;Last month we stubbed the text search process by using the GREP utilityprogram to process our queries.andP;  This month we toss that method aside andbuild an inverted index into our data base.andP;  To build the index we extracteach word from each file in the data base.andP;  From the word we use a hashingalgorithm to compute a random address.andP;  The random address points intoSLOTS.NDX, a file of slots with one slot available for each possible randomaddress.andP;  For this project we will assume a maximum of 64K words, so therewill be 64K slots.andM;Each slot contains a long integer with the value -1 if the slot is not inuse.andP;  If the slot is in use, it contains a character offset into a text indexfile, named TEXT.NDX.andP;  The offset points to the first character of avariable-length record in TEXT.NDX.andP;  The record contains the matching textword, a file bit map, and a record chain pointer.andM;The bit map in the TEXT.NDX record contains one bit for each text file in thedata base.andP;  If a bit in the bit map is one, the word appears in the file thatis associated with the bit.andM;The file named &quot;FILELIST.NDX&quot; contains the names of the text files in thedata base.andP;  The bit offset in the bit map and the name offset in FILELIST.NDXare the same.andM;The chain pointer in a TEXT.NDX record manages those words that hash tocommon slots.andP;  When a word hashes to a slot that a previous word used, wehave a collision.andP;  We will add a new record to the end of TEXT.NDX and writeits character offset into the pointer in the record pointed to by the slotentry.andP;  This builds a chain.andP;  The slot points to the first word that hashedto the slot.andP;  The first word's record points to the second, and so on.andO;Subsequent collisions lengthen the chain.andM;The code that builds and searches these files is contained in Listing Five,page 142, index.c.andM;Building the index is managed by the program that starts with Listing Six,page 144, bldindex.c.andP;  It calls the parse_cmdline function to extract filenames from the specifications on the command line and to execute theindex_file function for each file to be indexed.andP;  The index_file functionopens the specified file and calls the extract_word function (explained next)until there are no more words in the file to be extracted.andP;  The srchtreefunction tells us if the word is a noise word recorded in the binary tree.andO;If not, we add the word to the index by calling the addindex function, foundin index.c.andM;Extracting WordsandM;To build an index (and to build the noise word binary tree) we need afunction that extracts each word from a text file and normalizes it into aform suitable for indexing.andP;  The extract_word function in text.c, ListingSeven, page 144, does just that.andP;  You pass it the FILE pointer of an openfile and a character pointer where it will copy the next word, and it doesthe rest.andP;  The normalization process consists of skipping characters that arenot considered to be text and then selecting all text characters up to thenext nontext character.andP;  For my purposes, I select character groups thatinclude alphabetic characters, digits, the underscore (_), the plus (+) sign,and the pound (#) sign.andP;  This allows me to index text words, references toC++, function names, and preprocessor directives.andP;  The extract_word functionconverts alphabetic characters to lowercase.andP;  Other applications will havedifferent requirements, so the is-TEXT macro in text.c allows you to defineyour own select criteria.andM;The Hashing AlgorithmandM;Hashing is when you compute a random number from a key argument.andP;  You canthen use the number as a random address into a file where the informationrelated to the argument exists.andP;  With hashing you start with the key, computethe address, and use the address to find the record, all in the blink of aneye.andP;  Or so it would seem.andP;  In practice there is a bit more to it.andM;We will hash a random number from each of the words in our text files andlater from the words we use as arguments in our queries.andP;  The algorithm Ichose is a loose adaptation of the one that appeared in Steve Heller's&quot;Extensible Hashing&quot; article in the November 1989 issue of DDJ.andP;  It adds theseven-bit ASCII value of each character in the word to the initially zerohash total and shifts the total seven bits to the left.andP;  This add-shift loopcontinues for each character in the word.andM;There are as many different hashing algorithms as there are data formats tobe hashed.andP;  The idea is to compute a random number that is evenly distributedacross a defined range of values.andP;  If you can have 100,000 inventory recordsin a data base, the algorithm must compute from the inventory control key arandom number between 1 and 100,000.andP;  A common technique is to reduce the keyto a numerical value and divide that value by the prime number closest to therange.andP;  The remainder of that division is used as the random number.andM;In our approach we have decided that the range goes to 64K.andP;  Therefore, the16-bit integer that we compute from a text string should suffice as a randomnumber.andP;  Further reduction should not be necessary.andP;  Our 64K limitapproximates the number of different words we can expect to find in a textdata base.andP;  Most works of prose will have far fewer than that number ofunique words.andP;  Even if we build an index for some tome that exceeds thatnumber, then our collision strategy ensures that every word has a place inthe index.andM;The compute_hash function in index.c is our hashing algorithm.andM;TEXTSRCH RetrievalsandM;We established our query language and interpreter in earlier installments.andO;Now that we can build real indexes, we need to replace the stubs from lastmonth with a real search process.andP;  Listing Eight, page 144, is search.c andit replaces last month's search.c stub program.andP;  The real thing is simplerthan the stub because most of the work is now done in index.c.andP;  The searchfunction calls srchtree to see if the word is in the noise word list.andP;  If so,the search function returns a bit map with all bits set to one because noisewords are assumed to exist in all text files in the data base.andP;  If the wordis not a noise word, the search function calls search_index in index.c toderive the bit map that says which files in the data base contain the word.andM;The search_index function calls compute_hash to develop the random address ofthe word's entry in SLOT.NDX.andP;  That entry contains the character offset tothe first word that uses that slot.andP;  We read the offset and seek to thatrecord location in TEXT.NDX.andP;  If the word in that record is the same as theone we are looking for, we have a hit.andP;  If not, and there are no furtherrecords chained to the slot, we have a miss.andP;  We navigate the chain if itexists and compare each word in it to the one we are searching for.andP;  If weget a hit, the bit map associated with the matching record is the onereturned.andP;  Otherwise an all-zero bit map is returned.andM;The search process just described is for one word only.andP;  The expressioninterpreter from last month combines the searches for all the words in theexpression with the Boolean operators and develops one bit map thatrepresents the result of the full search.andM;The search.c file also contains the process_result function, which is nosmarter than the one we stubbed last month.andP;  All it does is display on theconsole the name of the files that match the search criteria.andP;  What you willdo with that list is up to you.andP;  See the discussion on Possible Enhancementsfor some thoughts on the matter.andM;Running TEXTSRCHandM;To build an index, get all your text files together and figure out how youare going to specify them on the command-line.andP;  If they are scatteredthroughout your subdirectories, you might want to make a list of them in afile.andP;  Use a text editor to make the file and put each file name on aseparate line.andP;  These are the different commands for building an index:andM;bldindex*.txt bldindex textfile.001 textfile.002 textfile.003 bldindex@files.lstandM;You can mix these formats like this:andM;bldindex*.txt textfile.001 @files.lstandM;The file specifications can have paths.andM;If the files named SLOTS.NDX, TEXT.NDX, and FILELIST.NDX already exist, youwill be adding to an existing index.andP;  Try not to add files that you alreadyindexed because this practice results in unnecessary redundancy in your indexfiles.andP;  If the files do not exist, you are building a new index.andM;Building an index takes a long time, so you might want to do it in smallincrements, a few files at a time.andP;  A power failure could make you start allover.andP;  The text files need to be accessible during the build phase, but canbe elsewhere during retrievals.andP;  The retrieval process only identifies thefile specifications as they existed when the index was built.andP;  Retrievals donot involve the text files themselves.andM;To perform a retrieval run the textsrch program from where the three .NDXfiles can be read.andP;  Enter query expressions as you did last month, and reviewthe file lists that result.andP;  A null query expression terminates the program.andM;Possible EnhancementsandM;TEXTSRCH has a lot of power and it has a lot of potential.andP;  As publishedhere, it is a subset of a more powerful text processing system that Ideveloped for engineering documentation applications.andP;  I use the version yousee here with no enhancements for personal use, but there are severalextensions that you might consider.andP;  Here are some of them.andM;Phrase Searches -- TEXTSRCH retrievals are based on word searches because theindex is built from discrete words.andP;  You can approximate a phrase search bycombining all the words in a phrase into a query expression with the ANDBoolean operator.andP;  This retrieval would deliver the names of the files thatcontain all the words in the phrase, but it would not tell you if the phraseitself was in any, all, or none of the files.andP;  You could search each file forthe specific phrase itself by using Boyer-Moore or a similar text-matchingalgorithm.andP;  This approach would require modification of the expression inputfunction to recognize the difference between phrases and individual words.andO;The process_result function must be extended to do the follow-up search ofthe text files themselves.andM;Wild Card Searches -- TEXTSRCH searches on a simple case-insensitive wordpattern.andP;  You could add the &quot;?&quot; wild card by changing the search function insearch.c to perform successive searches using every possible character wherethe wild card appeared.andM;Integrate with a Word ProcessorandM;The industrial system from which TEXTSRCH derives is integrated with a wordprocessor.andP;  When the file list is presented to the user, he or she selectsone, and the program fires up the word processor telling it to load theselected file and position itself to the first occurrence of the matchingword or phrase.andP;  This implementation binds the two applications together andis beyond the scope of this column.andM;What Good Is It?andM;How might you use TEXTSRCH?andP;  I spend a lot of time reading and writingelectronic mail and on-line service forum conversations.andP;  Sometimes I need togo back and find a message that mentioned something I want to recall.andP;  Youknow how it goes.andP;  Someone makes a comment about something that barelycatches your attention.andP;  A few months later you are working on a new projectand that comment would be helpful if only you could remember who made it andwhat they said.andP;  With TEXTSRCH indexes into my old mail I can usually findthe messages that pertain to the subject in question.andM;I keep all my columns, articles, and book manuscripts stored away in TEXTSRCHdata bases.andP;  That's right, I can't always remember what I wrote, when I wroteit, or where, and TEXTSRCH helps my failing memory (always the second thingto go).andM;I do another indexing trick with TEXTSRCH.andP;  I build dummy manuscripts thatsimulate the dozens of articles, manuals, and books I read every month.andP;  Thedummy manuscripts contain nothing more than key words from the articles andbooks.andP;  The subsequent TEXTSRCH indexes help me find the hard copies wherethe material appears.andP;  Someday when books and articles are available inmachine-readable media, or when I have a reliable OCR scanner, I'll be ableto build the indexes directly and bypass the dummy manuscript process.andM;There is one other use that will be of interest to C programmers.andP;  If you putonly the C keywords (int, long, typedef, and so on) into the noise word listand build an index from the source code for a huge project, you have inTEXTSRCH the beginnings of a handy cross reference of the functions andvariables.andP;  It isn't worth the trouble if you are developing a new system,but if you have inherited one of those behemoth undocumented applications tomaintain, TEXTSRCH might save you a lot of GREP time.andM;Book ReviewandM;Programming in C++ by Stephen C. Dewhurst and Kathy T. Stark.andP;  This book is amust for anyone who embarks on an intensive study of C++.andP;  It would help ifyou already had an exposure to C++, and knowledge of C is a prerequisite.andP;  Ithink I would have found this book a bit overwhelming a few months ago beforeI began to study C++.andP;  When read from the perspective of prior knowledge,however, this book is a gem.andP;  My one criticism is that it shares acharacteristic found in most C++ and object-oriented literature.andP;  It usesfruit for examples.andP;  If I have to stomp through one more orchard of apple andorange objects, I fear I may be felled by the dreaded canker.andP;  To theircredit, Dandamp;S don't dwell all that much on the ubiquitous citrus hierarchies,and other than for that one small lapse, their book is very good.andP;  To mysurprise I found that the book has clear and concise explanations ofprocedural programming, top-down design, and structured programming, not OOPsubjects at all.andP;  Most OOP books simply assume that you already know aboutthese things.andP;  Well, you should, but if you need brief explanations of themwritten in a style that real people can understand, this book does the job.andM;And, bless them, Dandamp;S do not dwell on object-oriented programming as thebe-all, end-all that we keep hearing about.andP;  No, they defer any detailedmention of OOP until Chapter 6, and then spend just a short amount of spacewith it.andP;  Skip that chapter and you might conclude from this book that C++ issimply an improved, extensible C.andP;  And that conclusion would not be far offthe mark.andP;  Other parts of the book discuss those properties of C++ thatcombine to make it embraceable by the OOP ilk, but these presentations arenot OOP-thumping paradigm evangelizations but rather mere explanations of thefeatures of the paradigm as they are implemented in C++.andM;C and C++ will converge.andP;  Despite the minor differences that causeincompatibility between ANSI C and C++, a common language will evolve if onlythrough usage.andP;  C++ brings too many improvements to C for that not to happen.andM;AvailabilityandM;All source code is available on a single disk and online.andP;  To order the disk,send $14.95 (Calif.andP;  residents add sales tax) to Dr. Dobb's Journal, 501Galveston Dr., Redwood City, CA 94063, or call 800-356-2002 (from insideCalif.) or 800-533-4372 (from outside Calif.).andP;  Please specify the issuenumber and format (MS-DOS, Macintosh, Kaypro).andP;  Source code is also availableonline through the DDJ Forum on CompuServe (type GO DDJ).andP;  The DDJ ListingService (603-882-1599) supports 300/1200/2400 baud, 8-data bits, no parity,1-stop bit.andP;  Press SPACEBAR when the system answers, type: listings(lowercase) at the log-in prompt.andO;</TEXT></DOC>