<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF108-785-058  </DOCNO><DOCID>08 785 058.andM;</DOCID><JOURNAL>Computer Language  Sept 1990 v7 n9 p36(5)* Full Text COPYRIGHT Miller Freeman Publications 1990.andM;</JOURNAL><TITLE>Applying the object paradigm to databases. (object-orienteddatabase management systems)</TITLE><AUTHOR>Atwood, Thomas.andM;</AUTHOR><SUMMARY>Object-oriented programming can be enhanced through use ofhighly-integrated object-oriented database management systems(OODBMS) that can be used to build applications and store reusablecode.andP;  Use of an OODBMS can save between 20 and 30 percent ofdevelopment cost above the savings resulting from use ofobject-oriented programming techniques alone.andP;  Responsibility forarbitrating data sharing among users, ensuring data integrity andrecovery when problems occur, distributing network data andmanaging the query process for large amounts of data is given tothe DBMS, which simplifies software development.andP;  OODBMSs areoptimized for such complex applications as two- andthree-dimensional graphical images, voice and video data incomputer-aided design, engineering, publishing, softwareengineering and advanced office automation applications.andP;  Use ofOODBMSs, object-oriented data models and how they can reducedevelopment costs are discussed.andM;</SUMMARY><DESCRIPT>Topic:     Object-Oriented ProgrammingObject-Oriented Data BasesProgram Development TechniquesTutorialData RepresentationModelsStandards.andM;</DESCRIPT><TEXT>Object-oriented programming techniques are rapidly gaining support forapplications where conventional procedural programming paradigms limitdevelopment.andP;  The benefits are straightforward: object-oriented programmingreduces the cost and time required to produce complex applications bysupporting the development of reusable code, which is easier to maintain andenhance.andM;Object-oriented programming makes it easier to model real-world entities suchas airplane wings and less tangible concepts such as software modules.andP;  Theapplication designer models the world in terms of primitives that describeobjects, their attributes and relationships, and operations that can beperformed on objects of a particular type.andM;Implementing systems object-oriented conceptual model results in:andM;* Highly efficient type-specific representationsandM;Insulation of the application from changes (encapsulation)andM;* Guaranteed consistency between the operations executed on objects of agiven type by different applicationsandM;* Dramatic reduction in the cost of developing new applications because codeinheritance from predefined object types.andM;But object-oriented pro ming by itself is not enough.andP;  a highly integrated,object-oriented database management system (OODBMS) to build applica andstore reusable code can 20% to 30% of development cost beyond that achievedsolely by objected-oriented programming.andP;  A DBMS simplifies softwaredevelopment by taking responsibility for arbitrating data sharing amongusers, ensuring data integrity and recovery in the event of problems,distributing data in a network, and managing the query process for largeamounts of data.andM;In addition, an OODBMS is optimized for complex applications that rely onnon-record-oriented data such as two- and three-dimensional graphical images,voice and video data found in computer-aided design (CAD), engineering,publishing, software engineering (CASE), and advanced office automationapplications.andM;An editorial team developing a document, a programming team creating anapplication, or a team designing a new computer chip all have similarrequirements for data management, including:andM;* The ability to group objects so they can be treated as a single logicalunit and let you manage different versions of the groupingsandM;* Concurrency control of collaborative work among a team of professionalsandM;* Backward compatibility so groups of objects created using both a previousand a new version can coexist in the same database.andM;At the same time, the OODBMS must operate at performance levels often twoorders of magnitude faster than existing DBMS technology.andP;  This tensionbetween the need for a full suite of traditional DBMS capabilities and veryhigh performance makes implementation architecture a key issue for OODBMSdesign.andP;  The basi tion becomes: &quot;How can you bly get it to go that fast?&quot;andM;The second generation of OODBMSs take a new approach to implementationarchitecture.andP;  Internally, they resemble the &quot;map-it-into-virtual memory&quot;architectures underneath the proprietary file systems used in CADapplications.andM;These next-generation architectures use sophisticated memory managementtechniques to maximize the data management operations that occur in memory.andO;Using the latest client-server architectures, they will perform mostcalculations on the client workstation to gain the maximum use of availablecompute cycles and employ caching and clustering techniques to minimizenetwork traffic.andM;By storing objects in an OODBMS, the operations that objects of a given typecan perform are known to the DBMS, which can exploit this knowledge tooptimize performance.andP;  Performance tools can be built to monitor referencetrace patterns for frequently used operations and do anticipatory fetching(prefetching) of objects the program is about to reference.andM;The conceptual modelandM;Object-oriented data models represent a major break with the record-orientedmodels on which the Codasyl and relational DBMSs of the 1970s and 1980s werebased.andP;  The difference in approach is so fundamental that the term &quot;datamodel&quot; may no longer be appropriate.andM;Object-oriented systems not only have a different data model (in the sensethat the relational data model was different from Codasyl's).andP;  They raise thelevel of abstraction the programmer must deal with.andP;  It is perhaps moreaccurate to say that object-oriented systems have a conceptual rather than adata model.andM;The Codasyl data model had two primitives: record_type and set_type.andP;  Therelational model had one: relation (equivalent to record_type).andP;  Therelationships between record_types were removed from the relational datamodel and replaced by joins in the data manipulation language.andP;  In bothcases, some conventional wisdom evolved about how real-world objects andrelationships between them should be modeled using the primitives of the datamodel.andP;  Objects were modeled as record types and relationships as set typesor (in the relational model) as foreign keys used to recover therelationships via joins at run time.andP;  Attributes of objects were modeled asfields within the records.andM;This direct mapping had some shortcomings, however.andP;  It did.andP;  not work foranything more than the simplest cases.andP;  Tuples (or records) in the relationalmodel were flat collections of fields and could not handle structuredattributes-for example, the address of a person, where address consists ofthe structure (street, [unit], city, state, zip).andP;  Set-valued attributes hadto be handled by introducing a separate tuple type containing the attributevalues and a foreign key to identify the tuple used to model the object withthese attribute values.andM;One-to-one and one-to-many relationships between objects could be handleddirectly by including the key value of the one side object in a field of themany side objects:andM;PROFESSOR (P#,...)andM;STUDENT (advisor_P#,...)andM;Even in this case, the schema ended up with a name for traversing theadvisor/advisee relationship in one direction (from STUDENT to PROFESSOR) butnot in the other direction.andP;  (The PROFESSOR tuple has no field calledadvisee.)andM;In addition, many-to-many relationships had to be handled by introducing adummy intermediate tuple type that does not correspond to any object type inthe real world.andP;  It is only a mechanism to allow the data manipulationlanguage to materialize m:n relationships: STUCLASS (Student#, Class#) tomodel the mn relationship between Students and classes.andP;  Student take severalclasses; classes are taken by several students.andM;The problem with mapping of real-world relationships into tuples is thatobjects and relationships behave differently.andP;  in particular, their deleteand create semantics are different.andP;  Since the relational model has only oneprimitive to model both objects and relationships between them, thatdifference in semantics cannot be captured cleanly in the data model.andP;  itmust be reintroduced as a set of constraints or rules with which the databasedesigner annotates the schema or, worse yet, as a set of conventions thatmust be followed by each programmer who uses the database.andM;For example, STUDENT-CLASS as two object types, STUDENT and CLASS, and onerelationship type.andP;  Students take classes (or, in the passive voice, classesare taken  y students).andP;  If in the real world a student drops a course (moreformally, if you break the relationship between a student and a course), thestudent does not cease to exist; neither does the course.andP;  However, deletingan object has widespread consequences.andP;  If you delete a student, therelationships between the student and the courses go away or becomeirrelevant.andM;In general, deleting a relationship between two objects has no effect on theobjects.andP;  However, deleting an object implies deleting all of therelationships between it and other objects.andP;  Formally, we say the existenceof the relationship is ontologically dependent on the prior existence of theobjects that participate in the relationship.andP;  Since it models both objectsand relationships using the same primitive (tuple), the relational data modelcannot capture this fundamental difference in semantics between objects andrelationships.andM;In some relational systems you can annotate the fields of a tuple used tohold the key of another tuple indicating that this field holds foreign key.andO;If the object ref by this key is deleted, this tuple must also be deleted.andO;But economy dictates that the database designer should not have to annotateevery relationship type between two objects.andP;  It should be built into theprimitive notion of what a relationship means.andM;Normal forms and normalization represent an attempt to add back the semanticsthe relational model leaves out.andP;  The database designer may design the schemausing an entity/relationship/attribute (ERA) diagramming tool that generatesa lower-level relational schema, which has been normalized to avoid theseanomalies.andP;  However, programmers writing applications for the database mustwrite to the resulting relational schema, not the ERA model.andM;Standardization at the conceptual-model rather than data-model level has thepositive side effect of freeing object-oriented systems to choose physicallevel representations for types according to what is most efficient for eachindividual type, rather than forcing everything into the mold of records.andO;This type-specific representation is the basis of object-oriented systems'ability to handle a wide range of diverse forms of data (graphics, text,voice, video, and so on).andM;OperationsandM;The object-oriented model allows the database designer to specify theoperations supported by objects of each type.andP;  This is a major break with therecord-oriented past.andP;  Hierarchical, network, and relational DBMSs allfocused exclusively on the data.andP;  The bulk of the operations that could bedone on the data types defined in the database schema were built intoprograms constructed independently of the database.andM;Object-oriented databases let application designers encapsulate operationswith persistent data structures.andP;  The result of this approach is to reducedevelopment and life-cycle costs.andM;Lower development costsandM;Separating the specification of data from the operations that work on it-onein a database schema, the other in subroutine libraries-does nothing intheory to prevent the disciplined programming shop from developing code asreusable libraries of subroutines grouped into sets according to objecttypes.andP;  In practice, it is rarely possible for the software developmentmanager to elicit this disciplined behavior from programmers.andP;  Arguingagainst defining the operations with the objects is analogous to insistingthat a disciplined use of well-defined macro sets could make assemblylanguage programming just as clear as a high-level language into whichcontrol constructs and abstract data types have been built.andP;  True intheory-not in practice.andM;It is difficult to enforce any discipline much above the level of formattingconventions for software development.andP;  It has been made doubly difficult bydesign methodologies that encourage decomposing the program along functionallines, packaging the objects with the procedure that needs them rather thanusing objects as the basic structuring vehicle, and packaging the proceduresthat act on an object type with its definition.andM;The upshot is clear in a string of before and after experiences usingobject-oriented software told by Dave Belanger, who is responsible for theprogramming environment used at ATandamp;T's Bell Laboratories.andP;  Since C++originated at Bell Labs, the company has perhaps the greatest experienceusing it in large applications, with more than 500 programmers working onsome 150 applications in C++.andM;When applications were written in C, 80% of any new application had to bewritten from scratch.andP;  Less than 20% of the application could be taken fromexisting C libraries.andP;  After three years of working with C++, the equationwas reversed.andP;  Up to 80% of a new application was inherited from the tree ofexisting C++ object types.andP;  Only 20% had to be written from scratch for thenew application.andP;  And since the inherited code had been used many timesalready, not only design and coding time were reduced, but also testing time.andM;Another important expected advantage of OODBMSs is lower life-cycle costs.andO;Major object-oriented applications have not been around long enough for us tohave actual numbers on their comparable life-cycle maintenance and evolutioncosts with applications of similar size and complexity written with oldertechniques.andP;  Industry experts predict, however, that total life cycle costsfor large-scale applications may be as little as 1/5 to 1/10 of similarapplications built with previous methodologies.andM;Relational databases and objectsandM;Most attempts to store complex data in relational databases have beenimplemented by putting a pointer to the data stored as a binary large objectinto a record.andP;  But all of the detailed structural information describingindividual small component objects is lost.andP;  Design applications still haveto manage their own data in files, and these files are stored in therelational DBMS.andP;  While this is viable for some business requirements, itfails to meet the needs of users developing high-performance, interactiveapplications of a graphical nature.andM;Others have attempted to decompose the complex graphical data into recordformats that can be stored in relational DBMSs.andP;  While technically feasible,the performance overhead associated with accessing this data in waysconsistent with interactive design applications have made theseimplementations impractical.andP;  Thus initially, OODBMS technology will notcompete with record-oriented DBMSs.andP;  OODBMS products will meet the needs ofapplications not served by relational technology and thus expand the entireDBMS world.andM;Because of the dramatic performance advantage of object-oriented systems fornon-record-oriented data, new applications requiring graphics, voice, text,and so on will be developed to run directly off of a real OODBMS.andP;  But theseapplications will have access to existing bodies of relational data.andP;  This isvery distinct from simply adding an object interface to an existingrelational DBMS.andP;  The latter is simply not fast enough for most of the newmultimedia applications the OODBMSs will serve.andP;  But it does provide amethodology for the coexistence of OODBMS and relational DBMS that will be anecessary part of the natural evolution of database technology.andM;Emerging standardsandM;An ideal OODBMS would fully support object-oriented design and programming,integrate into commercial computing environments, provide platformindependence, and offer interfaces to existing applications and databases.andO;This generation of OODBMSs will be UNIX-based, support the emerging userinterfaces standards, and focus initially on support for development in C++,now unarguably the de facto standard for object-oriented programming.andM;Because of the close link between object-oriented languages and databases, itis important to note that object-oriented database companies are workingclosely with language vendors.andP;  This is to ensure that future languagestandards include the features required to support their OODBMSs and thattheir products remain in the mainstream of object-oriented applicationdevelopment.andP;  One example of this type of cooperation is ATandamp;T's licensing ofObject Design's implementation of parameterized types for possible inclusionin future releases of the ATandamp;T C++ Language System.andM;Parameterized types can be thought of as a facility for creating classtemplates.andP;  They are invaluable for creating container classes (such aslists, vectors, and associative arrays) and enable programmers to more easilydevelop standard libraries of reliable, reusable code.andP;  Support for thisfeature lowers the costs of developing and maintaining software, because itencourages more widespread use of standard software libraries.andM;Several organizations help define standards that are relevant in theobject-oriented database world: the Object Management Group, ANSI, and theCAD Framework Initiative.andP;  Programmers eager to learn about the practicalapplication of OODBMS technology should follow the efforts of these groupswith great interest.andM;Tom Atwood, founder and chair of Object Design Inc., has pioneered thecommercial development of object-oriented technology.andP;  He was a founder ofOntologic, one of the first companies to introduce a commercialobject-oriented DBMS.andP;  He has worked extensively in the field of databasedevelopment at Data General and Digital Equipment Corp. Object  Design'sOODBMS product, ObjectStore, starts shipping in September 1990.andO;</TEXT></DOC>