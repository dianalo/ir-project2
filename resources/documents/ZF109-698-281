<?xml version='1.0' encoding='UTF-8'?>
<DOC><DOCNO>  ZF109-698-281  </DOCNO><DOCID>09 698 281.andM;</DOCID><JOURNAL>PC Week  Dec 17 1990 v7 n50 p55(1)* Full Text COPYRIGHT Ziff-Davis Publishing Co. 1990.andM;</JOURNAL><TITLE>Corporate software project managers rely now on one trend:uncertainty. (PC Week Labs: The Interop Report) (column)</TITLE><AUTHOR>Van Name, Mark L.; Catchings, Bill.andM;</AUTHOR><SUMMARY>The managers of corporate applications development programs willhave to face major challenges in 1991.andP;  The computer industry'sm more toward multiplatform computing makes the task of designingsoftware more complex, as does the rising level of uncertainty inthe industry.andP;  Users are no longer willing to confine their use ofa certain application to one operating system, interface, displaystandard and processor family; nor are they willing to confinetheir data storage to one format and one location.andP;  Developerstoday need to design with software migration as a goal.andP;  Thismeans keeping calls to the operating system at a minimum, andsurrounding important external dependencies with a layer ofabstraction.andM;</SUMMARY><DESCRIPT>Topic:     TrendsProgramming ManagementSoftware MigrationCompatible software.andM;</DESCRIPT><TEXT>The end of the year is a natural time to plan for the future.andP;  As 1990 drawsto a close, few will find planning as difficult as those who manage corporateapplications development.andP;  The trend toward multiplatform computing is makinglife unusually hard for those folks.andM;The problem is uncertainty.andP;  If you want to do a good job managing asoftware-development project today, you can't depend on much.andP;  Consider:andM;You can't depend on a particular processor family.andM;Not long ago, most applications ran on a single kind of CPU, and that wasthat.andP;  If you developed a program for an IBM mainframe, it ran on thatmainframe.andP;  PC programs stayed on PCs, and so on.andM;Not today.andP;  Every application is now a possible target for movement to a newplatform.andP;  Users who see applications they like running on one system want tobe able to run those applications on their own systems.andM;Even if you try to standardize on a single processor architecture, remember:andM;You can't depend on a particular operating environment, or a particularpresentation interface.andM;Just a few years ago, if you developed an application that ran on Intel CPUs,you were writing for DOS.andP;  Now there's Windows, which is coming on strong,and OS/2, which is still plodding along -- and, of course, there's alwaysUnix.andM;On top of the operating system you have the presentation interface.andP;  DOS PCdevelopers once had it easy, with only a few physical display standards andno real user-interface guidelines.andP;  Today, however, we have monochrome, CGA,EGA, VGA and a host of new contenders, from Super VGA to XGA.andP;  Environmentssuch as Windows and OS/2's Presentation Manager also bring their ownuser-interface standards to the DOS world.andM;Even assumptions about data are no longer safe.andP;  Where once you might haveplanned on storing all your data in dBASE files, now:andM;You can't depend on a particular data format, or on your data being in aparticular location.andM;Most of today's important applications are multiuser programs.andP;  As such, theyrequire tools for managing the data that users share.andP;  That need has led tothe rise in prominence of database servers, which, while they deliversignificant data-management power, also remove one layer from the underlyingdata.andP;  You often don't know exactly how your data is stored, only how toretrieve it.andM;Just as importantly, if you plan to move your application to a new platform,you'll need to move your data with it, which may well mean a newdata-management tool.andP;  The less your applications depend on storage details,the better.andM;In addition, when a particular system's data lived on one system, developerscould count on particular file names or directories.andP;  In today'smultiplatform networks, data could be on any system.andM;All this uncertainty makes developing applications a dicey proposition.andO;Still, you can lower your risk substantially with one simple rule:andM;Develop for portability.andM;Put another way, don't count on anything.andP;  As vague as this rule sounds,there's actually a very concrete way to implement it.andP;  Surround every majorexternal dependency with a layer of abstraction.andP;  For example, don't letdevelopers litter their programs with calls to the operating system.andO;Instead, replace all such calls with invocations of your own intermediaryroutines.andP;  Then the real operating system calls appear only inside yourspecial routines.andP;  If you need to move to a new operating system, only thoseroutines change; the rest of the application stays the same.andM;This practice isn't cheap, but it's less expensive than writing the sameapplication several times for different environments, or shelling out moneyfor outmoded hardware.andP;  You also don't have to pay the expense of creatinglibraries over and over.andP;  Create a good set once, and all your applicationscan share them.andM;Whether or not you develop for portability, the need for applications thatrun on multiple platforms will only grow.andP;  You might as well start planningfor that future now.andO;</TEXT></DOC>